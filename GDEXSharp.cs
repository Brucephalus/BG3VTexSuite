
// E:\Graphine Granite Toolset\GDEXSharp.dll
// GDEXSharp, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// Global type: <Module>
// Architecture: x64
// Runtime: v2.0.50727
// Hash algorithm: SHA1

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using GDEXSharp.StreamExtensions;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: AssemblyCompany("Graphine NV")]
[assembly: AssemblyProduct("Granite SDK")]
[assembly: AssemblyCopyright("Copyright Graphine NV Â© 2013-2017")]
[assembly: AssemblyInformationalVersion("5.0.0.34144")]
[assembly: AssemblyDescription("Generated by cholleme@ZELDA from master/9a8e2032016ca90aea9bc098289abc7dc1f56d8c")]
[assembly: AssemblyTitle("GDEXSharp")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: ComVisible(false)]
[assembly: Guid("3072c8f6-52eb-4df0-b025-4b18e9825acb")]
[assembly: AssemblyFileVersion("1.0.0.0")]
[assembly: AssemblyVersion("1.0.0.0")]
namespace GDEXSharp
{
	public abstract class DataItem
	{
		protected const int SHORT_HEADER_SIZE = 8;

		protected const int LONG_HEADER_SIZE = 12;

		protected const int TYPE_BITS = 8;

		protected const int TYPE_MASK = 255;

		protected const int FLAGS_SHIFT = 8;

		protected const int FLAGS_BITS = 8;

		protected const int FLAGS_MASK = 255;

		protected const int SIZE_SHIFT = 16;

		protected const int SIZE_BITS = 16;

		protected const int SIZE_MASK = 65535;

		public const int MAX_SHORT_HEADER_PAYLOAD = 65535;

		public const long MAX_LONG_HEADER_PAYLOAD = 281474976710655L;

		protected ItemType type;

		protected int tag;

		public ItemType Type => type;

		public string Tag
		{
			get
			{
				return ConvertTag(tag);
			}
			set
			{
				tag = ConvertTag(value);
			}
		}

		public int ValueInt
		{
			get
			{
				return (this as IntDataItem).Value;
			}
			set
			{
				(this as IntDataItem).Value = value;
			}
		}

		public long ValueLong
		{
			get
			{
				return (this as LongDataItem).Value;
			}
			set
			{
				(this as LongDataItem).Value = value;
			}
		}

		public float ValueFloat
		{
			get
			{
				return (this as FloatDataItem).Value;
			}
			set
			{
				(this as FloatDataItem).Value = value;
			}
		}

		public double ValueDouble
		{
			get
			{
				return (this as DoubleDataItem).Value;
			}
			set
			{
				(this as DoubleDataItem).Value = value;
			}
		}

		public string ValueString
		{
			get
			{
				return (this as StringDataItem).Value;
			}
			set
			{
				(this as StringDataItem).Value = value;
			}
		}

		public byte[] ValueRaw
		{
			get
			{
				return (this as RawDataItem).Value;
			}
			set
			{
				(this as RawDataItem).Value = value;
			}
		}

		public StructDataItem ValueStruct => this as StructDataItem;

		public IEnumerable<DataItem> Children => this as StructDataItem;

		protected DataItem(string tag, ItemType t)
		{
			this.tag = ConvertTag(tag);
			type = t;
		}

		public abstract void Write(Stream bw);

		protected virtual void WriteHeader(Stream bw, ItemType type, ItemFlags flags, long size)
		{
			bw.WriteInt32(tag);
			if (size > 65535)
			{
				flags |= ItemFlags.LongHeader;
			}
			uint value = (uint)(((int)(size & 0xFFFF) << 16) | ((int)flags << 8)) | (uint)type;
			bw.WriteInt32((int)value);
			if ((flags & ItemFlags.LongHeader) == ItemFlags.LongHeader)
			{
				if (size > 281474976710655L)
				{
					throw new Exception("Playload to big!");
				}
				bw.WriteInt32((int)(size >> 16));
			}
		}

		protected abstract void ReadValue(Stream br, ItemFlags flags, long sizeOrPayload);

		public static DataItem Read(Stream br)
		{
			string text = ConvertTag(br.ReadInt32());
			int num = br.ReadInt32();
			ItemType itemType = (ItemType)(num & 0xFF);
			ItemFlags itemFlags = (ItemFlags)((int)((uint)num >> 8) & 0xFF);
			long num2 = ((uint)num >> 16) & 0xFFFF;
			if ((itemFlags & ItemFlags.LongHeader) == ItemFlags.LongHeader)
			{
				long num3 = br.ReadInt32();
				num2 |= num3 << 16;
			}
			switch (itemType)
			{
			case ItemType.Raw:
			{
				RawDataItem rawDataItem2 = new RawDataItem(text, null);
				rawDataItem2.ReadValue(br, itemFlags, num2);
				return rawDataItem2;
			}
			case ItemType.Int32:
			{
				IntDataItem intDataItem2 = new IntDataItem(text);
				intDataItem2.ReadValue(br, itemFlags, num2);
				return intDataItem2;
			}
			case ItemType.Int64:
			{
				LongDataItem longDataItem = new LongDataItem(text);
				longDataItem.ReadValue(br, itemFlags, num2);
				return longDataItem;
			}
			case ItemType.Float:
			{
				FloatDataItem floatDataItem = new FloatDataItem(text);
				floatDataItem.ReadValue(br, itemFlags, num2);
				return floatDataItem;
			}
			case ItemType.Double:
			{
				IntDataItem intDataItem = new IntDataItem(text);
				intDataItem.ReadValue(br, itemFlags, num2);
				return intDataItem;
			}
			case ItemType.String:
			{
				StringDataItem stringDataItem = new StringDataItem(text);
				stringDataItem.ReadValue(br, itemFlags, num2);
				return stringDataItem;
			}
			case ItemType.Struct:
			{
				StructDataItem structDataItem = new StructDataItem(text);
				structDataItem.ReadValue(br, itemFlags, num2);
				return structDataItem;
			}
			case ItemType.Date:
			{
				DateDataItem dateDataItem = new DateDataItem(text);
				dateDataItem.ReadValue(br, itemFlags, num2);
				return dateDataItem;
			}
			case ItemType.Guid:
			{
				GuidDataItem guidDataItem = new GuidDataItem(text);
				guidDataItem.ReadValue(br, itemFlags, num2);
				return guidDataItem;
			}
			case ItemType.Int32Array:
			{
				IntArrayDataItem intArrayDataItem = new IntArrayDataItem(text);
				intArrayDataItem.ReadValue(br, itemFlags, num2);
				return intArrayDataItem;
			}
			case ItemType.Int64Array:
			{
				Int64ArrayDataItem int64ArrayDataItem = new Int64ArrayDataItem(text);
				int64ArrayDataItem.ReadValue(br, itemFlags, num2);
				return int64ArrayDataItem;
			}
			case ItemType.FloatArray:
			{
				FloatArrayDataItem floatArrayDataItem = new FloatArrayDataItem(text);
				floatArrayDataItem.ReadValue(br, itemFlags, num2);
				return floatArrayDataItem;
			}
			case ItemType.DoubleArray:
			{
				DoubleArrayDataItem doubleArrayDataItem = new DoubleArrayDataItem(text);
				doubleArrayDataItem.ReadValue(br, itemFlags, num2);
				return doubleArrayDataItem;
			}
			case ItemType.GuidArray:
			{
				GuidArrayDataItem guidArrayDataItem = new GuidArrayDataItem(text);
				guidArrayDataItem.ReadValue(br, itemFlags, num2);
				return guidArrayDataItem;
			}
			default:
			{
				RawDataItem rawDataItem = new RawDataItem(text, null);
				byte[] array = new byte[num2];
				br.Read(array, 0, array.Length);
				rawDataItem.Value = array;
				return rawDataItem;
			}
			}
		}

		public static int ConvertTag(string c)
		{
			return c.Length switch
			{
				1 => 0x20202000 | c[0], 
				2 => (int)(0x20200000 | ((uint)c[1] << 8) | c[0]), 
				3 => (int)(0x20000000 | ((uint)c[2] << 16) | ((uint)c[1] << 8) | c[0]), 
				4 => (int)(((uint)c[3] << 24) | ((uint)c[2] << 16) | ((uint)c[1] << 8) | c[0]), 
				_ => throw new Exception("Invalid FourCC code"), 
			};
		}

		public static string ConvertTag(int i)
		{
			return new string(new char[4]
			{
				(char)((uint)i & 0xFFu),
				(char)((uint)(i >> 8) & 0xFFu),
				(char)((uint)(i >> 16) & 0xFFu),
				(char)((uint)(i >> 24) & 0xFFu)
			});
		}

		public static IntDataItem New(string tag, int value)
		{
			return new IntDataItem(tag, value);
		}

		public static LongDataItem New(string tag, long value)
		{
			return new LongDataItem(tag, value);
		}

		public static FloatDataItem New(string tag, float value)
		{
			return new FloatDataItem(tag, value);
		}

		public static DoubleDataItem New(string tag, double value)
		{
			return new DoubleDataItem(tag, value);
		}

		public static StringDataItem New(string tag, string value)
		{
			return new StringDataItem(tag, value);
		}

		public static DateDataItem New(string tag, DateTime value)
		{
			return new DateDataItem(tag, value);
		}

		public static RawDataItem New(string tag, byte[] value)
		{
			return new RawDataItem(tag, value);
		}

		public static StructDataItem New(string tag)
		{
			return new StructDataItem(tag);
		}

		public static StructDataItem New(string tag, params DataItem[] values)
		{
			return new StructDataItem(tag, values);
		}

		public static ArrayDataItem<int> New(string tag, int[] values)
		{
			return new ArrayDataItem<int>(tag, ItemType.Int32Array, values);
		}
	}
	public class DateDataItem : DataItem
	{
		public DateTime Value { get; set; }

		public static DateTime ReferenceDate => new DateTime(2000, 1, 1);

		public DateDataItem(string tag)
			: this(tag, default(DateTime))
		{
		}

		public DateDataItem(string tag, DateTime value)
			: base(tag, ItemType.Date)
		{
			Value = value;
		}

		public override void Write(Stream bw)
		{
			WriteHeader(bw, type, ItemFlags.None, 8L);
			long value = DateTime.Now.Ticks - ReferenceDate.Ticks;
			bw.WriteInt64(value);
		}

		protected override void ReadValue(Stream br, ItemFlags flags, long size)
		{
			if (size != 8)
			{
				throw new IOException("Wrong size for Date");
			}
			long num = br.ReadInt64();
			Value = new DateTime(ReferenceDate.Ticks + num);
		}
	}
	[Flags]
	[Obfuscation(Exclude = true, ApplyToMembers = true)]
	public enum ItemFlags
	{
		None = 0,
		LongHeader = 1
	}
	public class IntDataItem : DataItem
	{
		public int Value { get; set; }

		public IntDataItem(string tag)
			: this(tag, 0)
		{
		}

		public IntDataItem(string tag, int value)
			: base(tag, ItemType.Int32)
		{
			Value = value;
		}

		public override void Write(Stream bw)
		{
			WriteHeader(bw, type, ItemFlags.None, 4L);
			bw.WriteInt32(Value);
		}

		protected override void ReadValue(Stream br, ItemFlags flags, long size)
		{
			if (size != 4)
			{
				throw new IOException("Wrong size for int");
			}
			Value = br.ReadInt32();
		}
	}
	public class LongDataItem : DataItem
	{
		public long Value { get; set; }

		public LongDataItem(string tag)
			: this(tag, 0L)
		{
		}

		public LongDataItem(string tag, long value)
			: base(tag, ItemType.Int64)
		{
			Value = value;
		}

		public override void Write(Stream bw)
		{
			WriteHeader(bw, type, ItemFlags.None, 8L);
			bw.WriteInt64(Value);
		}

		protected override void ReadValue(Stream br, ItemFlags flags, long size)
		{
			if (size != 8)
			{
				throw new IOException("Wrong size for long");
			}
			Value = br.ReadInt64();
		}
	}
	public class FloatDataItem : DataItem
	{
		public float Value { get; set; }

		public FloatDataItem(string tag)
			: this(tag, 0f)
		{
		}

		public FloatDataItem(string tag, float value)
			: base(tag, ItemType.Float)
		{
			Value = value;
		}

		public override void Write(Stream bw)
		{
			WriteHeader(bw, type, ItemFlags.None, 4L);
			bw.WriteInt32(BitConverter.ToInt32(BitConverter.GetBytes(Value), 0));
		}

		protected override void ReadValue(Stream br, ItemFlags flags, long size)
		{
			if (size != 4)
			{
				throw new IOException("Wrong size for float");
			}
			int value = br.ReadInt32();
			Value = BitConverter.ToSingle(BitConverter.GetBytes((uint)value), 0);
		}
	}
	public class DoubleDataItem : DataItem
	{
		public double Value { get; set; }

		public DoubleDataItem(string tag)
			: this(tag, 0.0)
		{
		}

		public DoubleDataItem(string tag, double value)
			: base(tag, ItemType.Double)
		{
			Value = value;
		}

		public override void Write(Stream bw)
		{
			WriteHeader(bw, type, ItemFlags.None, 8L);
			long value = BitConverter.DoubleToInt64Bits(Value);
			bw.WriteInt64(value);
		}

		protected override void ReadValue(Stream br, ItemFlags flags, long size)
		{
			if (size != 8)
			{
				throw new IOException("Wrong size for double");
			}
			long value = br.ReadInt64();
			Value = BitConverter.Int64BitsToDouble(value);
		}
	}
	public class GuidDataItem : DataItem
	{
		public Guid Value { get; set; }

		public GuidDataItem(string tag)
			: this(tag, Guid.Empty)
		{
		}

		public GuidDataItem(string tag, Guid value)
			: base(tag, ItemType.Guid)
		{
			Value = value;
		}

		public override void Write(Stream bw)
		{
			WriteHeader(bw, type, ItemFlags.None, 16L);
			byte[] array = Value.ToByteArray();
			bw.Write(array, 0, array.Length);
		}

		protected override void ReadValue(Stream br, ItemFlags flags, long size)
		{
			if (size != 16)
			{
				throw new IOException("Wrong size for guid");
			}
			byte[] array = new byte[16];
			br.Read(array, 0, array.Length);
			Value = new Guid(array);
		}
	}
	public class ArrayDataItem<T> : DataItem where T : struct
	{
		public T[] Value { get; set; }

		public ArrayDataItem(string tag, ItemType t, T[] value)
			: base(tag, t)
		{
			Value = value;
		}

		public override void Write(Stream bw)
		{
			int num = Marshal.SizeOf(typeof(T)) * Value.Length;
			WriteHeader(bw, type, ItemFlags.None, num);
			byte[] array = new byte[num];
			Buffer.BlockCopy(Value, 0, array, 0, num);
			bw.Write(array, 0, num);
			bw.WriteAlignmentBytes();
		}

		protected override void ReadValue(Stream br, ItemFlags flags, long size)
		{
			if (size > int.MaxValue)
			{
				throw new Exception("Large arrays are not supported!");
			}
			int num = Marshal.SizeOf(typeof(T));
			long num2 = size / num;
			if (num2 * num != size)
			{
				throw new Exception("Invalid size for array type");
			}
			Value = new T[num2];
			byte[] array = new byte[size];
			br.Read(array, 0, (int)size);
			Buffer.BlockCopy(array, 0, Value, 0, (int)size);
			br.ReadAlignmentBytes();
		}
	}
	public class IntArrayDataItem : ArrayDataItem<int>
	{
		public IntArrayDataItem(string tag)
			: this(tag, null)
		{
		}

		public IntArrayDataItem(string tag, int[] value)
			: base(tag, ItemType.Int32Array, value)
		{
		}
	}
	public class Int64ArrayDataItem : ArrayDataItem<long>
	{
		public Int64ArrayDataItem(string tag)
			: this(tag, null)
		{
		}

		public Int64ArrayDataItem(string tag, long[] value)
			: base(tag, ItemType.Int64Array, value)
		{
		}
	}
	public class FloatArrayDataItem : ArrayDataItem<float>
	{
		public FloatArrayDataItem(string tag)
			: this(tag, null)
		{
		}

		public FloatArrayDataItem(string tag, float[] value)
			: base(tag, ItemType.FloatArray, value)
		{
		}
	}
	public class DoubleArrayDataItem : ArrayDataItem<double>
	{
		public DoubleArrayDataItem(string tag)
			: this(tag, null)
		{
		}

		public DoubleArrayDataItem(string tag, double[] value)
			: base(tag, ItemType.DoubleArray, value)
		{
		}
	}
	public class GuidArrayDataItem : ArrayDataItem<Guid>
	{
		public GuidArrayDataItem(string tag)
			: this(tag, null)
		{
		}

		public GuidArrayDataItem(string tag, Guid[] value)
			: base(tag, ItemType.GuidArray, value)
		{
		}

		public override void Write(Stream bw)
		{
			WriteHeader(bw, type, ItemFlags.None, 16 * base.Value.Length);
			Guid[] value = base.Value;
			foreach (Guid guid in value)
			{
				byte[] array = guid.ToByteArray();
				if (array.Length != 16)
				{
					throw new Exception("Bad guid byte array size!");
				}
				bw.Write(array, 0, array.Length);
			}
			bw.WriteAlignmentBytes();
		}

		protected override void ReadValue(Stream br, ItemFlags flags, long size)
		{
			if (size > int.MaxValue)
			{
				throw new Exception("Large arrays are not supported!");
			}
			long num = size / 16;
			if (num * 16 != size)
			{
				throw new Exception("Invalid size for guid array type");
			}
			base.Value = new Guid[num];
			byte[] array = new byte[16];
			for (int i = 0; i < num; i++)
			{
				br.Read(array, 0, array.Length);
				base.Value[i] = new Guid(array);
			}
			br.ReadAlignmentBytes();
		}
	}
	[Obfuscation(Exclude = true, ApplyToMembers = true)]
	public enum ItemType
	{
		Raw,
		Struct,
		String,
		Int32,
		Int64,
		Float,
		Double,
		Date,
		Int32Array,
		FloatArray,
		Int64Array,
		DoubleArray,
		Guid,
		GuidArray
	}
	public class RawDataItem : DataItem
	{
		public byte[] Value { get; set; }

		public RawDataItem(string tag, byte[] data)
			: base(tag, ItemType.Raw)
		{
			Value = data;
		}

		public override void Write(Stream bw)
		{
			WriteHeader(bw, ItemType.Raw, ItemFlags.None, Value.Length);
			bw.Write(Value, 0, Value.Length);
			bw.WriteAlignmentBytes();
		}

		protected override void ReadValue(Stream br, ItemFlags flags, long size)
		{
			byte[] array = new byte[size];
			if (size > int.MaxValue)
			{
				throw new Exception(">2 GB chunks not supported yet");
			}
			br.Read(array, 0, (int)size);
			Value = array;
			br.ReadAlignmentBytes();
		}

		public MemoryStream CreateReadingStream()
		{
			return new MemoryStream(Value, writable: false);
		}
	}
	public class StringDataItem : DataItem
	{
		public string Value { get; set; }

		public StringDataItem(string tag)
			: this(tag, "")
		{
		}

		public StringDataItem(string tag, string value)
			: base(tag, ItemType.String)
		{
			Value = value;
		}

		public override void Write(Stream bw)
		{
			char[] array = Value.ToCharArray();
			int num = Buffer.ByteLength(array);
			byte[] array2 = new byte[num + 2];
			Buffer.BlockCopy(array, 0, array2, 0, num);
			WriteHeader(bw, ItemType.String, ItemFlags.None, array2.Length);
			bw.Write(array2, 0, array2.Length);
			bw.WriteAlignmentBytes();
		}

		protected override void ReadValue(Stream br, ItemFlags flags, long sizeOrPayload)
		{
			long num = sizeOrPayload / 2;
			char[] array = new char[num];
			byte[] array2 = new byte[num * 2];
			br.Read(array2, 0, (int)(num * 2));
			Buffer.BlockCopy(array2, 0, array, 0, array2.Length);
			Value = new string(array, 0, array.Length - 1);
			br.ReadAlignmentBytes();
		}
	}
	public class StructDataItem : DataItem, ICollection<DataItem>, IEnumerable<DataItem>, IEnumerable
	{
		private bool isShort;

		private List<DataItem> items = new List<DataItem>();

		public int Count => items.Count;

		public bool IsReadOnly => false;

		public DataItem this[int i]
		{
			get
			{
				return items[i];
			}
			set
			{
				items[i] = value;
			}
		}

		public DataItem this[string s]
		{
			get
			{
				foreach (DataItem item in items)
				{
					if (item.Tag == s)
					{
						return item;
					}
				}
				throw new Exception("Tag not found in child items: " + s);
			}
		}

		public StructDataItem(string tag)
			: this(tag, isShort: false)
		{
		}

		public StructDataItem(string tag, bool isShort)
			: base(tag, ItemType.Struct)
		{
			this.isShort = isShort;
		}

		public StructDataItem(string tag, params DataItem[] items)
			: base(tag, ItemType.Struct)
		{
			isShort = false;
			this.items.AddRange(items);
		}

		public StructDataItem(string tag, bool isShort, params DataItem[] items)
			: base(tag, ItemType.Struct)
		{
			this.isShort = isShort;
			this.items.AddRange(items);
		}

		public override void Write(Stream bw)
		{
			long offset = bw.Seek(0L, SeekOrigin.Current);
			WriteHeader(bw, ItemType.Struct, (!isShort) ? ItemFlags.LongHeader : ItemFlags.None, 0L);
			long num = bw.Seek(0L, SeekOrigin.Current);
			foreach (DataItem item in items)
			{
				item.Write(bw);
			}
			long num2 = bw.Seek(0L, SeekOrigin.Current);
			long num3 = num2 - num;
			if (isShort && num3 > 65535)
			{
				throw new Exception("This item was marked as a short item but it's length exceeds the maximum short length");
			}
			bw.Seek(offset, SeekOrigin.Begin);
			WriteHeader(bw, ItemType.Struct, (!isShort) ? ItemFlags.LongHeader : ItemFlags.None, num3);
			bw.Seek(num2, SeekOrigin.Begin);
			bw.WriteAlignmentBytes();
		}

		protected override void ReadValue(Stream br, ItemFlags flags, long sizeOrPayload)
		{
			long num = br.Seek(0L, SeekOrigin.Current);
			long num2 = br.Seek(0L, SeekOrigin.Current) + sizeOrPayload;
			while (num < num2)
			{
				Add(DataItem.Read(br));
				num = br.Seek(0L, SeekOrigin.Current);
			}
			br.ReadAlignmentBytes();
		}

		public void Add(DataItem item)
		{
			items.Add(item);
		}

		public void Clear()
		{
			items.Clear();
		}

		public bool Contains(DataItem item)
		{
			return items.Contains(item);
		}

		public void CopyTo(DataItem[] array, int arrayIndex)
		{
			items.CopyTo(array, arrayIndex);
		}

		public bool Remove(DataItem item)
		{
			return items.Remove(item);
		}

		public IEnumerator<DataItem> GetEnumerator()
		{
			return items.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return items.GetEnumerator();
		}
	}
}
namespace GDEXSharp.StreamExtensions
{
	public static class StreamExtensions
	{
		public static int ReadInt32(this Stream str)
		{
			return str.ReadByte() | (str.ReadByte() << 8) | (str.ReadByte() << 16) | (str.ReadByte() << 24);
		}

		public static long ReadInt64(this Stream str)
		{
			return str.ReadByte() | ((long)str.ReadByte() << 8) | ((long)str.ReadByte() << 16) | ((long)str.ReadByte() << 24) | ((long)str.ReadByte() << 32) | ((long)str.ReadByte() << 40) | ((long)str.ReadByte() << 48) | ((long)str.ReadByte() << 56);
		}

		public static void WriteInt32(this Stream str, int value)
		{
			str.WriteByte((byte)((uint)value & 0xFFu));
			str.WriteByte((byte)((uint)(value >> 8) & 0xFFu));
			str.WriteByte((byte)((uint)(value >> 16) & 0xFFu));
			str.WriteByte((byte)((uint)(value >> 24) & 0xFFu));
		}

		public static void WriteInt64(this Stream str, long value)
		{
			str.WriteByte((byte)(value & 0xFF));
			str.WriteByte((byte)((value >> 8) & 0xFF));
			str.WriteByte((byte)((value >> 16) & 0xFF));
			str.WriteByte((byte)((value >> 24) & 0xFF));
			str.WriteByte((byte)((value >> 32) & 0xFF));
			str.WriteByte((byte)((value >> 40) & 0xFF));
			str.WriteByte((byte)((value >> 48) & 0xFF));
			str.WriteByte((byte)((value >> 56) & 0xFF));
		}

		public static void WriteAlignmentBytes(this Stream str)
		{
			long num = str.Seek(0L, SeekOrigin.Current);
			long num2 = RoundUp(num, 4L) - num;
			for (int i = 0; i < num2; i++)
			{
				str.WriteByte(0);
			}
		}

		public static void ReadAlignmentBytes(this Stream str)
		{
			long num = str.Seek(0L, SeekOrigin.Current);
			long num2 = RoundUp(num, 4L) - num;
			for (int i = 0; i < num2; i++)
			{
				str.ReadByte();
			}
		}

		private static long RoundUp(long n, long roundTo)
		{
			if (roundTo == 0L)
			{
				return 0L;
			}
			return (n + roundTo - 1) / roundTo * roundTo;
		}
	}
}
