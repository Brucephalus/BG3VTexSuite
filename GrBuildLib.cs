
// E:\Graphine Granite Toolset\GrBuildLib.dll
// GrBuildLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// Global type: <Module>
// Architecture: x64
// Runtime: v4.0.30319
// Hash algorithm: SHA1

using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.ComponentModel;
using System.Configuration;
using System.Diagnostics;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Resources;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Versioning;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml;
using System.Xml.Schema;
using GDEXSharp;
using Graphine.Core;
using GrBuildLib;
using GrBuildLib.Properties;
using GrBuildLib.Tools;
using Grim;
using Nixel;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: AssemblyCompany("Graphine NV")]
[assembly: AssemblyProduct("Granite SDK")]
[assembly: AssemblyCopyright("Copyright Graphine NV Â© 2013-2017")]
[assembly: AssemblyInformationalVersion("5.0.0.34144")]
[assembly: AssemblyDescription("Generated by cholleme@ZELDA from master/9a8e2032016ca90aea9bc098289abc7dc1f56d8c")]
[assembly: AssemblyTitle("GrBuildLib")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: ComVisible(false)]
[assembly: Guid("fc952b33-9963-4459-89ad-2402b25935cc")]
[assembly: AssemblyFileVersion("1.0.0.0")]
[assembly: TargetFramework(".NETFramework,Version=v4.5", FrameworkDisplayName = ".NET Framework 4.5")]
[assembly: AssemblyVersion("1.0.0.0")]
namespace GrBuildStudio
{
	public class ProjectTemplate
	{
		public LayerConfig LayerConfig { get; set; }

		public ProjectTemplate()
		{
			LayerConfig = new LayerConfig();
		}
	}
}
namespace GrBuildLib
{
	internal class AssetImporterProcess : IAssetImporterProcess, IPipelineProcess
	{
		private class LayerResizingReport
		{
			public bool LayerAspectRatioChanged { get; set; }

			public bool Resized { get; set; }

			public List<Texture> TextureAspectRatioChanged { get; private set; }

			public LayerResizingReport()
			{
				TextureAspectRatioChanged = new List<Texture>();
			}
		}

		private List<Asset> importedAssets;

		public ProjectBuilder ProjectBuilder { get; private set; }

		public PipelineProcessResult LatestResult { get; private set; }

		public bool HasRun { get; private set; }

		public DateTime LastRun { get; private set; }

		public bool UpdateExistingAssets { get; set; }

		public AssetImporterProcess(ProjectBuilder builder)
		{
			ProjectBuilder = builder;
			importedAssets = new List<Asset>();
			UpdateExistingAssets = true;
		}

		public PipelineProcessResult PreProcess()
		{
			LatestResult = PipelineProcessResult.Failed;
			if (ProjectBuilder.ActiveProject.LayerConfiguration == null)
			{
				string innerMessage = "No LayerConfig set in project file, use \"-i file.xml\" to import assets and a LayerConfiguration";
				ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.Import, new ImportIssue(innerMessage));
				return LatestResult;
			}
			foreach (ImportAsset importAsset in ProjectBuilder.ActiveProject.ImportAssets)
			{
				if (importAsset.Name == null)
				{
					string innerMessage2 = "Name value is null, please set a correct name for an asset to import";
					ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.Import, new ImportIssue(innerMessage2));
					return LatestResult;
				}
			}
			foreach (ImportAssetTemplate importTemplate in ProjectBuilder.ActiveProject.ImportTemplates)
			{
				if (importTemplate.Name == null)
				{
					string innerMessage3 = "Template name value is null, please set a correct name for an asset template to import";
					ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.Import, new ImportIssue(innerMessage3));
					return LatestResult;
				}
				int num = 0;
				foreach (ImportAssetLayerTemplate layerTemplate in importTemplate.LayerTemplates)
				{
					if (layerTemplate.Source == null || layerTemplate.Source.Sources.Count <= 0)
					{
						string innerMessage4 = "Source on layer " + num + " is null, please fill in the source path for the import asset layer template";
						ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.Import, new ImportTemplateIssue(importTemplate.Name, innerMessage4));
						return LatestResult;
					}
					num++;
				}
			}
			LatestResult = PipelineProcessResult.Success;
			return LatestResult;
		}

		private void ReimportPatternAssets()
		{
			foreach (Asset value in ProjectBuilder.ActiveProject.Assets.Values)
			{
				if (AssetTools.IsAssetPatternChanged(value))
				{
					ImportAsset import;
					bool num = AssetTools.AssetToImportAsset(value, ProjectBuilder.GetProjectPath(), out import);
					import.Reimport = true;
					if (num)
					{
						ProjectBuilder.AddImportAsset(import);
						string innerMessage = $"Stacked Texture '{value.Name}' has had one or more of its textures removed or new textures have been added. Reimporting the Stacked Texture.";
						ProjectBuilder.BuildReportingHandler.OnWarning(BuildProcess.Import, new ImportIssue(innerMessage));
					}
				}
			}
		}

		public PipelineProcessResult Process()
		{
			ProjectBuilder.ProgressTracker.StartTask(SlowTask.ImportProcess);
			DateTime now = DateTime.Now;
			ProjectBuilder.logger.LogTitle("Importing assets for " + ProjectBuilder.ActiveProject.LayerConfiguration.Layers.Count() + " layers...", Logger.Verbosity.Normal);
			ProjectBuilder.ActiveProject.ImportSummary = new ImportSummary();
			try
			{
				ReimportPatternAssets();
				ImportAssets();
				RemoveAssets();
				AddImportedAssets();
				RemoveAssetsExclusive();
				if (UpdateExistingAssets)
				{
					UpdateAssets();
				}
				LogChanges();
			}
			catch (FatalException)
			{
				importedAssets.Clear();
				LatestResult = PipelineProcessResult.Failed;
				return LatestResult;
			}
			catch (GrBuildException ex2)
			{
				ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.Import, new ImportIssue(ex2.Message));
				importedAssets.Clear();
				LatestResult = PipelineProcessResult.Failed;
				return LatestResult;
			}
			importedAssets.Clear();
			if (ProjectBuilder.ProfilingEnabled)
			{
				double num = Math.Truncate((DateTime.Now - now).TotalMilliseconds) / 1000.0;
				ProjectBuilder.logger.LogConsole("Done, elapsed time: " + num + " s", Logger.Verbosity.Quiet);
			}
			HasRun = true;
			LastRun = DateTimeManagement.Now();
			LatestResult = PipelineProcessResult.Success;
			ProjectBuilder.ProgressTracker.EndTask(SlowTask.ImportProcess);
			return LatestResult;
		}

		public PipelineProcessResult PostProcess(PipelineProcessResult processResult)
		{
			return PipelineProcessResult.Success;
		}

		private bool IsNameAvailable(string name, out Asset conflict)
		{
			return ProjectBuilder.IsAssetNameAvavailable(name, out conflict);
		}

		private bool IsGroupNameAvailable(string name, out Asset conflict)
		{
			return IsNameAvailable(name, out conflict);
		}

		private bool IsAssetNameAvailable(string name, out Asset conflict)
		{
			return IsNameAvailable(name, out conflict);
		}

		private bool IsAssetNameValid(string name)
		{
			if (!string.IsNullOrEmpty(name))
			{
				return name.IndexOfAny(Path.GetInvalidFileNameChars()) < 0;
			}
			return false;
		}

		private LayerResizingReport ResizeAssetLayer(Asset asset, int layerIdx, Size layerSize, Size targetLayerSize, bool allowAspectChange, int subIndex)
		{
			LayerResizingReport layerResizingReport = new LayerResizingReport();
			AssetLayer assetLayer = asset.AssetLayers[layerIdx];
			if (layerSize.Width == 0 || layerSize.Height == 0)
			{
				return layerResizingReport;
			}
			bool flag = asset.UDimSettings != null && asset.UDimSettings[layerIdx] != null;
			if (flag && asset.TilingMethod != 0)
			{
				throw new ImportException($"Asset '{asset.Name}' has UDIM textures and is set for scaling to a clamp/repeat tiling method, which is not allowd. Please set AssetTilingMethod/BorderMethod to 'None', or do not use UDIM textures.");
			}
			if (!AssetImportTools.AspectRatioEquals(targetLayerSize.Width, targetLayerSize.Height, layerSize.Width, layerSize.Height))
			{
				if (!allowAspectChange)
				{
					throw new ImportException(string.Format("Input image for asset '{0}', layer {1} has a different resolution than that of other layers. Automatic resizing cannot proceed as Strict Mode is on, preventing resizing to a different aspect ratio. Please use a texture with the same aspect ratio for this layer or disable Strict Mode.", new object[2] { asset.Name, layerIdx }));
				}
				layerResizingReport.LayerAspectRatioChanged = true;
			}
			Size layerSize2 = AssetTools.CalculateLayerSize(asset, layerIdx, subIndex, useForcedSize: false);
			Double2 @double = AssetTools.CalculateLayerResizeScale(targetLayerSize, layerSize);
			Double2 double2 = AssetTools.CalculateLayerResizeScale(layerSize, layerSize2);
			Double2 double3 = new Double2(@double.X * double2.X, @double.Y * double2.Y);
			Size size = AssetImportTools.FindLargestTexture(assetLayer, openFiles: false, subIndex);
			foreach (Texture texture in assetLayer.Textures)
			{
				if (texture.SubIndex != subIndex)
				{
					continue;
				}
				int width;
				int height;
				if (assetLayer.TextureType[subIndex] == TextureType.UDim)
				{
					width = size.Width;
					height = size.Height;
				}
				else
				{
					width = texture.Width;
					height = texture.Height;
				}
				if (!AssetTools.IsIntegralScaling(new Size(width, height), double3))
				{
					string empty = string.Empty;
					empty = ((!flag) ? string.Format("Input image for asset '{0}', layer {1}, has a different size than other layers. Automatic resizing cannot proceed as the individual textures would need to be resized to non-integral resolutions. Please provide textures that have a resolution that is a multiple of the resolution of textures of the other layers/channels. In doubt, prefer power of two textures for the entire asset.", new object[2] { asset.Name, layerIdx }) : string.Format("Input image for asset '{0}', layer {1}, has a different size than other layers. Automatic resizing cannot proceed as one of the individual textures or UDIM patches would need to be resized to non-integral resolutions. For UDIMs, this can happen if you have a non-power of two number of patches either horizontally or vertically, and want to resize the asset (e.g., scaling six 2K patches to a 16K image). Please provide textures that have a resolution that is a multiple of the resolution of textures of the other layers/channels. In doubt, prefer power of two textures for the entire asset and use a power-of-2 number of UDIM patches horizontally and vertically (e.g., 4 by 4 patches).", new object[2] { asset.Name, layerIdx }));
					throw new ImportException(empty);
				}
				int num = (int)((double)width * double3.X);
				int num2 = (int)((double)height * double3.Y);
				if (!AssetImportTools.AspectRatioEquals(num, num2, texture.Width, texture.Height))
				{
					if (!allowAspectChange)
					{
						throw new ImportException(string.Format("Input image for asset '{0}', layer {1} has a different resolution than that of other layers. Automatic resizing cannot proceed as Strict Mode is on, preventing resizing to a different aspect ratio. Please use a texture with the same aspect ratio for this layer or disable Strict Mode.", new object[2] { asset.Name, layerIdx }));
					}
					layerResizingReport.TextureAspectRatioChanged.Add(texture);
				}
				if (texture.Width != num || texture.Height != num2)
				{
					int grimMaximumResizingSize = Constants.GrimMaximumResizingSize;
					if (num > grimMaximumResizingSize || num2 > grimMaximumResizingSize)
					{
						throw new ImportException(string.Format("Input image for asset '{0}', layer {1}, cannot be resized automatically. It has a different size than the images in other layers of said asset. GrBuild automatically resizes in this case, but GrBuild will not resize a layer texture to a size of more than {2} pixels in either dimension. Please manually resize the image.", new object[3] { asset.Name, layerIdx, grimMaximumResizingSize }));
					}
					layerResizingReport.Resized = true;
				}
				texture.Width = width;
				texture.Height = height;
			}
			return layerResizingReport;
		}

		private void ResizeAsset(Asset asset)
		{
			bool allowAspectChange = !ProjectBuilder.EnableStrictMode;
			List<Size>[] array = new List<Size>[4];
			for (int i = 0; i < 4; i++)
			{
				AssetTools.CalculateAssetSize(asset, out array[i], i, forceLayerSize: true);
			}
			Size targetLayerSize = AssetTools.CalculateAssetSize(asset);
			if (asset.TargetWidth > 0 || asset.TargetHeight > 0)
			{
				targetLayerSize = new Size(asset.TargetWidth, asset.TargetHeight);
			}
			if (asset.AutoScalingMode != 0)
			{
				targetLayerSize = AssetTools.CalculateScaledSize(targetLayerSize, asset.AutoScalingMode);
			}
			for (int j = 0; j < asset.AssetLayers.Count; j++)
			{
				for (int k = 0; k < 4; k++)
				{
					Size layerSize = array[k][j];
					LayerResizingReport layerResizingReport = ResizeAssetLayer(asset, j, layerSize, targetLayerSize, allowAspectChange, k);
					if (layerResizingReport.Resized && asset.AssetLayers[j].MipSourceType == TextureMipSourceType.File)
					{
						BuildIssue buildIssue = new ImportIssue(string.Format("Mips cannot be loaded from file when textures need to be resized to match other layer sizes. Mips will be auto generated. Textures of layer {1} of asset '{0}' were resized to match other layers and therefore have their mips auto generated. To preserve custom mips, please resize your texture to match the other layers so no resizing by the TileSetStudio is required.", new object[2] { asset.Name, j }));
						ProjectBuilder.BuildReportingHandler.OnWarning(BuildProcess.Import, buildIssue);
					}
					if (layerResizingReport.LayerAspectRatioChanged)
					{
						BuildIssue buildIssue2 = new ImportIssue(string.Format("Textures (sub-texture {2}) of layer {1} of asset '{0}' were resized and their aspect ratios have changed.", new object[3] { asset.Name, j, k }));
						ProjectBuilder.BuildReportingHandler.OnInfo(BuildProcess.Import, buildIssue2);
					}
				}
			}
			asset.Width = targetLayerSize.Width;
			asset.Height = targetLayerSize.Height;
			if (asset.Width == 0 || asset.Height == 0)
			{
				throw new ImportException("No textures could be imported, please check the asset and files on disk");
			}
		}

		public static string GenerateCubemapFaceAssetName(string assetName, int faceIndex)
		{
			return assetName + "_face" + faceIndex;
		}

		public static string GenerateCubemapNameFromFaceAsset(string assetName)
		{
			string text = "_face0";
			return assetName.Substring(0, assetName.Length - text.Length);
		}

		private void ValidatePattern(Asset asset, int layerIndex, int subIdx)
		{
			if (asset.AssetLayers[layerIndex].TextureType[subIdx] != TextureType.Tiled || AssetImportTools.ValidateTiledTextureSizes(asset.AssetLayers[layerIndex].Textures.Where((Texture _tex) => _tex.SubIndex == subIdx).ToList(), out var _, out var invalidRowIndex, out var invalidColumnIndex))
			{
				return;
			}
			string text = string.Empty;
			if (invalidRowIndex > -1)
			{
				text = text + "Row " + (invalidRowIndex + 1);
			}
			if (invalidColumnIndex > -1)
			{
				if (text.Length > 0)
				{
					text += ", ";
				}
				text = text + "Column " + (invalidColumnIndex + 1);
			}
			string message = string.Format("Invalid dimensions for a row or column for asset: '{0}', layer: {1} in the current pattern. One of the textures causes a row or column (could be {2}) in the pattern to size to a different size than the other rows or columns. Please check the requirements for patterns in the documentation.", new object[3]
			{
				asset.Name,
				layerIndex.ToString(),
				text
			});
			ImportedAssetCheckFailedException.FailedReason reason = ImportedAssetCheckFailedException.FailedReason.InvalidPatternDimensions;
			throw new ImportedAssetCheckFailedException(message, reason);
		}

		private void ImportAsset(ImportAsset asset)
		{
			try
			{
				if (asset.Type == AssetType.CubeMap)
				{
					ImportCubeMap(asset);
					return;
				}
				int faceIndex = 0;
				ImportAsset(asset, faceIndex);
			}
			catch (GrBuildException ex)
			{
				ProjectBuilder.ActiveProject.ImportSummary.FailedAssetImports.Add(asset);
				ProjectBuilder.ActiveProject.ImportSummary.FailedImportCount++;
				ImportIssue importIssue = null;
				importIssue = ((ex.LayerIndex == -1) ? ((ImportIssue)new ImportAssetIssue(asset.Name, ex.Message)) : ((ImportIssue)new ImportAssetLayerIssue(asset.Name, ex.LayerIndex, ex.Message)));
				if (GrBuildExceptionHandler.IsFatal(ex))
				{
					ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.Import, importIssue);
					throw new FatalException();
				}
				if (ProjectBuilder.BuildReportingHandler.OnError(BuildProcess.Import, importIssue) == ErrorAction.Stop)
				{
					throw new FatalException();
				}
				if (ex is FatalException)
				{
					throw ex;
				}
			}
		}

		private void ImportGTexAsset(Asset asset)
		{
			if (IsAlreadyOnImportList(asset.Name))
			{
				throw new ImportException($"Trying to import asset '{asset.Name}' more than once at the same time. This typically is caused by duplicate entries in the import script.");
			}
			importedAssets.Add(asset);
			ProjectBuilder.ActiveProject.ImportSummary.SuccessImportCount++;
		}

		private void ImportCubeMap(ImportAsset asset)
		{
			if (asset.Layers.Count != 1)
			{
				throw new ImportException("Multiple layers were set for a cube map. Cube map assets cannot have multiple layers. Please import into a project with a single layer.");
			}
			string name = asset.Name;
			if (!IsGroupNameAvailable(name, out var conflict) && conflict.Type != AssetType.CubeMap)
			{
				throw new ImportException($"Cube map '{name}' conflicts with an existing regular asset. Please remove the conflicting asset first or choose a different name for the cube map.");
			}
			for (int i = 0; i < 6; i++)
			{
				string text = GenerateCubemapFaceAssetName(asset.Name, i);
				if (!IsAssetNameAvailable(text, out conflict))
				{
					if (conflict.Type == AssetType.Normal)
					{
						throw new ImportException($"Cube map face name '{text}' conflicts with an existing asset. Please remove the conflicting asset first or choose a different name for the cube map.");
					}
					if (conflict.AssetGroupId != null && Various.NameEquals(conflict.AssetGroupId, text))
					{
						throw new ImportException($"Cube map face name '{text}' conflicts with an existing cube map or cube map face. Please remove the conflicting cube map first or choose a different name for the new cube map.");
					}
				}
			}
			for (int j = 0; j < 6; j++)
			{
				ImportAsset(asset, j);
			}
		}

		private bool IsAlreadyOnImportList(string assetName)
		{
			foreach (Asset importedAsset in importedAssets)
			{
				if (Various.NameEquals(importedAsset.Name, assetName))
				{
					return true;
				}
			}
			return false;
		}

		private void ImportAsset(ImportAsset asset, int faceIndex)
		{
			CreateImportAsset(asset, faceIndex, out var importedAsset);
			if (IsAlreadyOnImportList(importedAsset.Name))
			{
				throw new ImportException($"Trying to import asset '{importedAsset.Name}' more than once at the same time. This typically is caused by duplicate entries in the import script.");
			}
			importedAssets.Add(importedAsset);
			ProjectBuilder.ActiveProject.ImportSummary.SuccessImportCount++;
		}

		private void CreateImportAsset(ImportAsset asset, int faceIndex, out Asset importedAsset)
		{
			importedAsset = new Asset();
			importedAsset.Id = Guid.NewGuid();
			importedAsset.Type = asset.Type;
			if (asset.Type == AssetType.CubeMap)
			{
				importedAsset.Name = GenerateCubemapFaceAssetName(asset.Name, faceIndex);
				importedAsset.AssetGroupId = asset.Name;
			}
			else
			{
				importedAsset.Name = asset.Name;
			}
			importedAsset.Face = faceIndex;
			Asset conflict = null;
			if (importedAsset.AssetGroupId != null && !IsGroupNameAvailable(importedAsset.Name, out conflict) && asset.Type == AssetType.CubeMap && conflict.Type != AssetType.CubeMap)
			{
				throw new ImportException($"Cube map '{importedAsset.AssetGroupId}' conflicts with an existing asset. Please remove the conflicting asset first or choose a different name for the cube map.");
			}
			if (!IsAssetNameValid(importedAsset.Name))
			{
				throw new ImportException($"Asset name '{importedAsset.Name}' is not valid. Please choose a different name without any special characters.");
			}
			if (!IsAssetNameAvailable(importedAsset.Name, out conflict))
			{
				if (asset.Type == AssetType.CubeMap && conflict.Type == AssetType.Normal)
				{
					throw new ImportException($"Cube map face name '{importedAsset.Name}' conflicts with an existing asset. Please remove the conflicting asset first or choose a different name for the cube map.");
				}
				if (asset.Type == AssetType.Normal && conflict.Type == AssetType.CubeMap)
				{
					throw new ImportException($"The asset name '{importedAsset.Name}' conflicts with an existing cube map or cube map face. Please remove the conflicting cube map first or choose a different name for the cube map.");
				}
			}
			if (ProjectBuilder.ProfilingEnabled)
			{
				ProjectBuilder.logger.LogConsole(asset.Name, Logger.Verbosity.Quiet);
			}
			if (asset.Layers.Count < ProjectBuilder.ActiveProject.LayerConfiguration.Layers.Count)
			{
				throw new ImportException("Fewer layers set in asset than available in layer configuration, please add layers to the asset.");
			}
			if (asset.Layers.Count > ProjectBuilder.ActiveProject.LayerConfiguration.Layers.Count)
			{
				throw new ImportException(string.Format("More layers set in asset than available in layer configuration, please remove layers from the asset", asset.Name));
			}
			importedAsset.TilingMethod = asset.TilingMethod;
			importedAsset.TargetWidth = asset.TargetWidth;
			importedAsset.TargetHeight = asset.TargetHeight;
			importedAsset.AutoScalingMode = asset.AutoScalingMode;
			for (int i = 0; i < asset.Layers.Count; i++)
			{
				AssetLayer assetLayer = new AssetLayer(i);
				ImportAssetLayer importAssetLayer = asset.Layers[i];
				if (asset.Type == AssetType.CubeMap && importAssetLayer.Source.Sources.Count > 1)
				{
					throw new ImportedAssetCheckFailedException($"Channel packing is not supported for cubemaps! please validate input for {asset.Name}, layer {i}", ImportedAssetCheckFailedException.FailedReason.InvalidChannelMerging);
				}
				for (int j = 0; j < importAssetLayer.Source.Sources.Count; j++)
				{
					CombinedTextureSource.Item item = importAssetLayer.Source.Sources[j];
					string.IsNullOrEmpty(item.Source);
					ImportTemplateInfo importTemplateInfo = ImportTemplateInfo.ParseAndScan(item.Source, item.SubIndex);
					AssetImportTools.CreateTextures(ProjectBuilder.ActiveProject.LayerConfiguration, importTemplateInfo, faceIndex, i, out var textures, ProjectBuilder, importAssetLayer.MipSourceType, out var udimSettings);
					if (textures.Count() == 0)
					{
						_ = importTemplateInfo.Type;
						_ = 4;
					}
					if (importTemplateInfo.Type == TextureType.UDim)
					{
						importedAsset.UDimSettings[item.SubIndex] = UDimSettings.Merge(importedAsset.UDimSettings[item.SubIndex], udimSettings);
					}
					assetLayer.Textures.AddRange(textures);
					assetLayer.TextureType[item.SubIndex] = importTemplateInfo.Type;
				}
				for (int k = 0; k < 4; k++)
				{
					assetLayer.Swizzle[k] = importAssetLayer.Swizzle[k];
					assetLayer.InvertChannels[k] = importAssetLayer.InvertChannels[k];
				}
				assetLayer.Resize = importAssetLayer.Resize;
				if (importAssetLayer.QualityProfile != null)
				{
					assetLayer.QualityProfile = importAssetLayer.QualityProfile.ToLowerInvariant();
				}
				assetLayer.Flip = importAssetLayer.Flip;
				assetLayer.MipSourceType = importAssetLayer.MipSourceType;
				assetLayer.PackingMode = importAssetLayer.PackingMode;
				assetLayer.ResizeMode = importAssetLayer.ResizeMode;
				assetLayer.TargetWidth = importAssetLayer.TargetWidth;
				assetLayer.TargetHeight = importAssetLayer.TargetHeight;
				assetLayer.ColorSpace = importAssetLayer.ColorSpace;
				importedAsset.AssetLayers.Add(assetLayer);
			}
			UpdateAssetTextures(importedAsset);
		}

		private void CheckSwizzle(Asset asset, int layerIndex, int minNumChannels, int subIdx)
		{
			AssetLayer assetLayer = asset.AssetLayers[layerIndex];
			int numChannels = DataTypeInfo.GetNumChannels(ProjectBuilder.ActiveProject.LayerConfiguration.Layers[layerIndex].DataType);
			try
			{
				AssetImportTools.CheckSwizzle(assetLayer.Swizzle[subIdx], minNumChannels, numChannels);
			}
			catch (InvalidSwizzleException ex)
			{
				ImportAssetLayerIssue buildIssue = new ImportAssetLayerIssue(asset.Name, layerIndex, ex.Message);
				if (GrBuildExceptionHandler.IsFatal(ex))
				{
					ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.Import, buildIssue);
					throw new FatalException();
				}
				if (ProjectBuilder.BuildReportingHandler.OnError(BuildProcess.Import, buildIssue) == ErrorAction.Stop)
				{
					throw new FatalException();
				}
				assetLayer.Swizzle[subIdx] = null;
			}
		}

		private void UpdateAssetTextures(Asset asset)
		{
			if (asset.AssetLayers.Count < ProjectBuilder.ActiveProject.LayerConfiguration.Layers.Count)
			{
				throw new ImportException("Not enough layers set, please add layers to the asset.");
			}
			for (int i = 0; i < asset.AssetLayers.Count; i++)
			{
				AssetLayer assetLayer = asset.AssetLayers[i];
				int subIdx;
				for (subIdx = 0; subIdx < 4; subIdx++)
				{
					List<Texture> list = assetLayer.Textures.Where((Texture _tex) => _tex.SubIndex == subIdx).ToList();
					if (list.Count != 0)
					{
						AssetImportTools.UpdateTextures(assetLayer.TextureType[subIdx], asset.Type, ProjectBuilder.ActiveProject.LayerConfiguration, list, out var info, asset.UDimSettings[subIdx], asset.Face, i, ProjectBuilder, assetLayer.MipSourceType);
						if ((info.TotalWidth == 0 || info.TotalHeight == 0) && !assetLayer.IsEmpty())
						{
							throw new ImportException("No textures could be imported, please check the asset and files on disk");
						}
						CheckSwizzle(asset, i, info.MinNumChannels, subIdx);
						ValidatePattern(asset, i, subIdx);
					}
				}
			}
			ResizeAsset(asset);
			if (!AssetTools.TestTilingMethod(asset))
			{
				string innerMessage = string.Format("Asset '{0}' had its Tiling method set to '{1}', but does not have a power of two size. The asset will not have correct filtering at its edges as the Tiling Method will automatically resort to no tiling. Please resize the textures behind the asset to a pow-2 size, or change the tiling method.", new object[2]
				{
					asset.Name,
					asset.TilingMethod.ToString()
				});
				ProjectBuilder.BuildReportingHandler.OnWarning(BuildProcess.Import, new ImportIssue(innerMessage));
			}
		}

		private void ImportAssets()
		{
			AssetImportTools.AssetCollection assetCollection = new AssetImportTools.AssetCollection();
			assetCollection.Scan(ProjectBuilder.ActiveProject.ImportTemplates, ProjectBuilder);
			if (assetCollection.FailedTemplateImports.Count > 0)
			{
				ProjectBuilder.ActiveProject.ImportSummary.FailedTemplates.AddRange(assetCollection.FailedTemplateImports);
			}
			foreach (ImportAsset asset in assetCollection.Assets)
			{
				ImportAsset(asset);
			}
			foreach (ImportAsset importAsset in ProjectBuilder.ActiveProject.ImportAssets)
			{
				ImportAsset(importAsset);
			}
			foreach (Asset gTexImportAsset in ProjectBuilder.ActiveProject.GTexImportAssets)
			{
				ImportGTexAsset(gTexImportAsset);
			}
			ProjectBuilder.ActiveProject.ImportTemplates.Clear();
			ProjectBuilder.ActiveProject.ImportAssets.Clear();
			ProjectBuilder.ActiveProject.GTexImportAssets.Clear();
		}

		private void RemoveAssets()
		{
			Project activeProject = ProjectBuilder.ActiveProject;
			foreach (Asset item in activeProject.AssetsToRemove)
			{
				activeProject.ImportSummary.TextureChanges.AddRange(AssetImportTools.GetChangedTextures(null, item));
				activeProject.Assets.Remove(item.Id);
			}
			activeProject.AssetsToRemove.Clear();
		}

		private void AddImportedAssets()
		{
			Project activeProject = ProjectBuilder.ActiveProject;
			Dictionary<string, Guid> dictionary = new Dictionary<string, Guid>();
			foreach (Asset value in activeProject.Assets.Values)
			{
				dictionary.Add(value.Name.ToLowerInvariant(), value.Id);
			}
			foreach (Asset importedAsset in importedAssets)
			{
				if (dictionary.ContainsKey(importedAsset.Name.ToLowerInvariant()))
				{
					importedAsset.Id = dictionary[importedAsset.Name.ToLowerInvariant()];
					activeProject.ImportSummary.TextureChanges.AddRange(AssetImportTools.GetChangedTextures(importedAsset, activeProject.Assets[importedAsset.Id]));
					activeProject.Assets[importedAsset.Id] = importedAsset;
				}
				else
				{
					activeProject.ImportSummary.TextureChanges.AddRange(AssetImportTools.GetChangedTextures(importedAsset, null));
					activeProject.Assets.Add(importedAsset.Id, importedAsset);
				}
			}
		}

		private void RemoveAssetsExclusive()
		{
			if (!ProjectBuilder.ActiveProject.ExclusiveImport)
			{
				return;
			}
			Project activeProject = ProjectBuilder.ActiveProject;
			List<Guid> list = new List<Guid>();
			foreach (Asset importedAsset in importedAssets)
			{
				list.Add(importedAsset.Id);
			}
			List<Asset> list2 = new List<Asset>();
			foreach (Asset value in activeProject.Assets.Values)
			{
				if (!list.Contains(value.Id))
				{
					activeProject.ImportSummary.TextureChanges.AddRange(AssetImportTools.GetChangedTextures(null, value));
					list2.Add(value);
				}
			}
			TileSoupBuilder.DeleteSerializedFiles(ProjectBuilder, list2);
			foreach (Asset item in list2)
			{
				activeProject.Assets.Remove(item.Id);
			}
		}

		private void UpdateImportedAsset(Asset asset)
		{
			UpdateAssetTextures(asset);
		}

		private void UpdateAssets()
		{
			Project activeProject = ProjectBuilder.ActiveProject;
			foreach (Guid key in activeProject.Assets.Keys)
			{
				bool flag = activeProject.LayerConfiguration.SameDataTypes(ProjectBuilder.State.LayerConfiguration2);
				Asset asset = (Asset)activeProject.Assets[key].Clone();
				bool flag2 = ProjectBuilder.State.IsSoupFileValid(asset);
				if (flag2 && ProjectBuilder.ForceUseGTex)
				{
					continue;
				}
				try
				{
					UpdateImportedAsset(activeProject.Assets[key]);
					activeProject.ImportSummary.TextureChanges.AddRange(AssetImportTools.GetChangedTextures(activeProject.Assets[key], asset));
					if (!flag)
					{
						AssetImportTools.CheckDataTypes(activeProject.Assets[key], activeProject.LayerConfiguration, ProjectBuilder.GetProjectPath());
					}
				}
				catch (ImportException ex)
				{
					ProjectBuilder.ActiveProject.ImportSummary.FailedAssetUpdates.Add(asset);
					if (!flag2)
					{
						ImportAssetIssue buildIssue = new ImportAssetIssue(asset.Name, ex.Message);
						ProjectBuilder.BuildReportingHandler.OnWarning(BuildProcess.Import, buildIssue);
					}
				}
				catch (ImportedAssetCheckFailedException ex2)
				{
					ProjectBuilder.ActiveProject.ImportSummary.FailedAssetUpdates.Add(asset);
					ImportAssetIssue buildIssue2 = new ImportAssetIssue(asset.Name, ex2.Message);
					ProjectBuilder.BuildReportingHandler.OnError(BuildProcess.Import, buildIssue2);
					throw new FatalException();
				}
			}
		}

		private void LogChanges()
		{
			Project activeProject = ProjectBuilder.ActiveProject;
			if (activeProject.ImportSummary.TextureChanges.Count() == 0)
			{
				return;
			}
			int num = activeProject.ImportSummary.TextureChanges.Select((TextureChange x) => x.AssetId).Distinct().Count();
			ProjectBuilder.logger.LogMessage(num + " assets, " + activeProject.ImportSummary.TextureChanges.Count() + " textures changed", Logger.Verbosity.Normal);
			ProjectBuilder.logger.LogMessage("(N: New, D: Deleted, M: Modified)", Logger.Verbosity.Detailed);
			Guid guid = Guid.NewGuid();
			foreach (TextureChange textureChange in activeProject.ImportSummary.TextureChanges)
			{
				if (textureChange.AssetId != guid)
				{
					ProjectBuilder.logger.LogMessage("Asset: " + textureChange.AssetName, Logger.Verbosity.Detailed);
					guid = textureChange.AssetId;
				}
				ProjectBuilder.logger.LogMessage("(" + textureChange.ChangeType.ToString()[0] + ") " + textureChange.Source, Logger.Verbosity.Detailed);
			}
		}
	}
	internal class AssetImportTools
	{
		public class AssetCollection
		{
			public List<ImportAsset> Assets { get; private set; }

			public List<ImportAssetTemplate> FailedTemplateImports { get; set; }

			public AssetCollection()
			{
				Assets = new List<ImportAsset>();
				FailedTemplateImports = new List<ImportAssetTemplate>();
			}

			private void AddAssetsFromTemplate(ImportAssetTemplate template)
			{
				if (template.LayerTemplates.Count == 0)
				{
					throw new TemplateException("No layers set in template, please add layers");
				}
				if (!template.Name.Contains('*'))
				{
					throw new TemplateException("The template '" + template.Name + "' does not contain a wild card in the name.");
				}
				TemplateImportScanner templateImportScanner = new TemplateImportScanner();
				templateImportScanner.Scan(template);
				foreach (TemplateImportScanner.FoundAsset foundAsset in templateImportScanner.FoundAssets)
				{
					ImportAsset importAsset = new ImportAsset();
					importAsset.Name = foundAsset.Name;
					importAsset.TargetWidth = template.TargetWidth;
					importAsset.TargetHeight = template.TargetHeight;
					importAsset.AutoScalingMode = template.AutoScalingMode;
					importAsset.TilingMethod = template.TilingMethod;
					foreach (int key in foundAsset.LayerSourceTextures.Keys)
					{
						int index = key;
						ImportAssetLayerTemplate importAssetLayerTemplate = template.LayerTemplates[index];
						CombinedTextureSource combinedTextureSource = foundAsset.LayerSourceTextures[key];
						bool flag = true;
						foreach (CombinedTextureSource.Item source in combinedTextureSource.Sources)
						{
							if (!File.Exists(source.Source))
							{
								flag = false;
								break;
							}
						}
						if (flag)
						{
							ImportAssetLayer importAssetLayer = new ImportAssetLayer();
							importAssetLayer.Flip = importAssetLayerTemplate.Flip;
							importAssetLayer.QualityProfile = importAssetLayerTemplate.QualityProfile;
							for (int i = 0; i < 4; i++)
							{
								importAssetLayer.Swizzle[i] = importAssetLayerTemplate.Swizzle[i];
								importAssetLayer.InvertChannels[i] = importAssetLayerTemplate.InvertChannels[i];
							}
							importAssetLayer.PackingMode = importAssetLayerTemplate.PackingMode;
							importAssetLayer.Source = combinedTextureSource;
							importAssetLayer.MipSourceType = importAssetLayerTemplate.MipSourceType;
							importAssetLayer.ColorSpace = importAssetLayerTemplate.ColorSpace;
							importAsset.AddAssetLayer(importAssetLayer);
						}
					}
					if (importAsset.Layers.Count == template.LayerTemplates.Count)
					{
						Assets.Add(importAsset);
					}
				}
			}

			public void Scan(IEnumerable<ImportAssetTemplate> importTemplates, ProjectBuilder builder)
			{
				FailedTemplateImports.Clear();
				foreach (ImportAssetTemplate importTemplate in importTemplates)
				{
					try
					{
						int count = Assets.Count;
						AddAssetsFromTemplate(importTemplate);
						if (count == Assets.Count)
						{
							throw new TemplateException("No assets found in template");
						}
					}
					catch (GrBuildException ex)
					{
						FailedTemplateImports.Add(importTemplate);
						ImportTemplateIssue buildIssue = new ImportTemplateIssue(importTemplate.Name, ex.Message);
						if (GrBuildExceptionHandler.IsFatal(ex))
						{
							builder.BuildReportingHandler.OnFatalError(BuildProcess.Import, buildIssue);
							throw new FatalException();
						}
						if (builder.BuildReportingHandler.OnError(BuildProcess.Import, buildIssue) == ErrorAction.Stop)
						{
							throw new FatalException();
						}
					}
				}
			}
		}

		public class TexturesInfo
		{
			public int TotalWidth { get; set; }

			public int TotalHeight { get; set; }

			public int MinNumChannels { get; set; }

			public PatternScanner.PatternRange Range { get; set; }
		}

		private static Grim.Error GetTextureDimensions(string source, out uint width, out uint height)
		{
			width = 0u;
			height = 0u;
			Grim.Error error = ImageFactory.Create(out var image);
			if (error != 0)
			{
				return error;
			}
			error = image.Open(source);
			if (error != 0)
			{
				return error;
			}
			Spec spec = image.GetSpec();
			width = spec.GetWidth();
			height = spec.GetHeight();
			error = image.Close();
			if (error != 0)
			{
				return error;
			}
			return Grim.Error.Ok;
		}

		public static Size FindLargestTexture(List<AssetLayer> layers, bool openFiles)
		{
			int num = 0;
			int num2 = 0;
			foreach (AssetLayer layer in layers)
			{
				Size size = FindLargestTexture(layer, openFiles);
				num = Math.Max(num, size.Width);
				num2 = Math.Max(num2, size.Height);
			}
			return new Size(num, num2);
		}

		public static Size FindLargestTexture(AssetLayer layer, bool openFiles, int requiredSubIndex = -1)
		{
			int num = 0;
			int num2 = 0;
			foreach (Texture texture in layer.Textures)
			{
				if (requiredSubIndex >= 0 && texture.SubIndex != requiredSubIndex)
				{
					continue;
				}
				uint width;
				uint height;
				if (openFiles)
				{
					if (GetTextureDimensions(texture.Source, out width, out height) != 0)
					{
						string message = string.Format("Source file could not be opened: source: '{1}'", new object[1] { texture.Source });
						ImportedAssetCheckFailedException.FailedReason reason = ImportedAssetCheckFailedException.FailedReason.FileNotFound;
						throw new ImportedAssetCheckFailedException(message, reason);
					}
				}
				else
				{
					width = (uint)texture.Width;
					height = (uint)texture.Height;
				}
				num = Math.Max(num, (int)width);
				num2 = Math.Max(num2, (int)height);
			}
			return new Size(num, num2);
		}

		public static bool GetPatternRange(List<Texture> textures, out PatternScanner.PatternRange range)
		{
			range = default(PatternScanner.PatternRange);
			if (textures.Count == 0)
			{
				return false;
			}
			range.MinCol = textures.Min((Texture x) => x.Column);
			range.MaxCol = textures.Max((Texture x) => x.Column);
			range.MinRow = textures.Min((Texture x) => x.Row);
			range.MaxRow = textures.Max((Texture x) => x.Row);
			return true;
		}

		public static Size CalculateTiledTextureSize(List<Texture> textures)
		{
			int num = 0;
			int num2 = 0;
			if (textures.Count == 0)
			{
				return new Size(0, 0);
			}
			int num3 = textures.Min((Texture x) => x.Row);
			int num4 = textures.Max((Texture x) => x.Row);
			int num5 = textures.Min((Texture x) => x.Column);
			int num6 = textures.Max((Texture x) => x.Column);
			int y;
			for (y = num3; y < num4 + 1; y++)
			{
				int val = textures.Where((Texture p) => p.Row == y && p.Face == 0).Sum((Texture z) => z.Width);
				num = Math.Max(num, val);
			}
			int x2;
			for (x2 = num5; x2 < num6 + 1; x2++)
			{
				int val2 = textures.Where((Texture p) => p.Column == x2 && p.Face == 0).Sum((Texture z) => z.Height);
				num2 = Math.Max(num2, val2);
			}
			return new Size(num, num2);
		}

		public static bool ValidateTiledTextureSizes(List<Texture> textures, out Size size, out int invalidRowIndex, out int invalidColumnIndex)
		{
			size = CalculateTiledTextureSize(textures);
			invalidRowIndex = -1;
			invalidColumnIndex = -1;
			int num = textures.Min((Texture x) => x.Row);
			int num2 = textures.Max((Texture x) => x.Row);
			int num3 = textures.Min((Texture x) => x.Column);
			int num4 = textures.Max((Texture x) => x.Column);
			int y;
			for (y = num; y < num2 + 1; y++)
			{
				if (textures.Where((Texture p) => p.Row == y && p.Face == 0).Sum((Texture z) => z.Width) != size.Width)
				{
					invalidRowIndex = y;
					break;
				}
			}
			int x2;
			for (x2 = num3; x2 < num4 + 1; x2++)
			{
				if (textures.Where((Texture p) => p.Column == x2 && p.Face == 0).Sum((Texture z) => z.Height) != size.Height)
				{
					invalidColumnIndex = x2;
					break;
				}
			}
			if (invalidColumnIndex == -1)
			{
				return invalidRowIndex == -1;
			}
			return false;
		}

		private static string GetPrettyChannelDataTypeString(ChannelDataType dataType)
		{
			return dataType switch
			{
				ChannelDataType.UnsignedChar => "8-bit", 
				ChannelDataType.UnsignedShort => "16-bit unsigned short", 
				ChannelDataType.UnsignedInt => "16-bit unsigned int", 
				ChannelDataType.Float32 => "32-bit float", 
				ChannelDataType.Float16 => "16-bit float", 
				_ => "Unknown channel data type", 
			};
		}

		public static void LoadTexture(string filename, int row, int column, int face, bool isCube, DataType targetLayerDataType, ProjectBuilder builder, TextureMipSourceType mipSourceType, ref Texture texture)
		{
			ImageFactory.Create(out var image);
			filename = Paths.GetAbsolutePath(builder.GetProjectPath(), filename);
			Grim.Error error = image.Open(filename);
			switch (error)
			{
			case Grim.Error.FileIO:
				throw new ImportException(filename + " not found or inaccessible, make sure the file isn't being used by another process");
			case Grim.Error.UnsupportedCompression:
				throw new ImportException(filename + " is in an unsupported compressed format. Please provide the file in a different format, preferably an uncompressed format.");
			default:
				throw new GrimException(error, filename);
			case Grim.Error.Ok:
			{
				if (builder.ProfilingEnabled)
				{
					builder.logger.LogConsole(filename, Logger.Verbosity.Quiet);
				}
				Spec spec = image.GetSpec();
				ChannelDataType channelDataType = DataTypeInfo.GetChannelDataType(targetLayerDataType);
				if (channelDataType != spec.GetChannelFormat())
				{
					if (!ImageFactory.IsConvertable(spec.GetChannelFormat(), channelDataType) || !builder.EnableAutoDepthConversion)
					{
						throw new ImportInvalidTypeException(filename, spec.GetChannelFormat().ToString(), targetLayerDataType.ToString());
					}
					string text = ((spec.GetChannelFormat() != ChannelDataType.Float32) ? string.Format("Image input has {0} data channels while {1} data was requested. Converting automatically.", new object[2]
					{
						GetPrettyChannelDataTypeString(spec.GetChannelFormat()),
						GetPrettyChannelDataTypeString(channelDataType)
					}) : ((channelDataType != ChannelDataType.Float16) ? $"Image input has 32-bit or 16-bit float data while {GetPrettyChannelDataTypeString(channelDataType)} data was requested. Converting automatically." : $"Image input has 32-bit or 16-bit float data while 16-bit float data was requested. If the image contains 32-bit float data it will be automatically converted to 16-bit float data. If the image contains 16-bit float data you can ignore this warning."));
					builder.BuildReportingHandler.OnWarning(BuildProcess.Import, new ImportIssue(filename + ": " + text));
				}
				if (spec.GetNumFaces() < face)
				{
					throw new ImportException("File is not an array file format or does not contain enough array images to array image " + face + ", make sure the file '" + filename + "' is a valid array image.");
				}
				if (isCube && spec.GetNumFaces() != 6)
				{
					throw new ImportException("File is not a cube map or does not contain 6 array images,  make sure the file '" + filename + "' is a valid cube map. This is sometimes an indication of a compatibility issue with the cube map file and the DDS reader.");
				}
				texture.Width = (int)spec.GetWidth();
				texture.Height = (int)spec.GetHeight();
				texture.LastChangedDate = DateTimeManagement.Round(new FileInfo(filename).LastWriteTime);
				texture.Row = row;
				texture.Column = column;
				texture.Face = face;
				texture.Source = Paths.GetRelativePathForFile(builder.GetProjectPath(), filename);
				texture.NumChannels = (int)spec.GetNumChannels();
				image.Close();
				if (isCube && (!ExtraMath.IsPowerOfTwo((ulong)texture.Width) || !ExtraMath.IsPowerOfTwo((ulong)texture.Height)))
				{
					string text2 = "Cube map face image is not a power of 2 image. Incorrect sampling or sampling artefacts may occur when using with the Granite runtime. Please use power of 2 cube maps.";
					builder.BuildReportingHandler.OnWarning(BuildProcess.Import, new ImportIssue(filename + ": " + text2));
				}
				if (mipSourceType == TextureMipSourceType.Default)
				{
					mipSourceType = Defaults.TextureMipSourceType;
				}
				if (mipSourceType == TextureMipSourceType.File && (!ExtraMath.IsPowerOfTwo((ulong)texture.Width) || !ExtraMath.IsPowerOfTwo((ulong)texture.Height)))
				{
					throw new ImportException($"{filename}: Image that is set loading mips from file is not a power of 2 image. Please use power of 2 images when loading mips from image files.");
				}
				break;
			}
			}
		}

		public static void CreateTextures(LayerConfig layerConfig, ImportTemplateInfo templateInfo, int face, int layer, out List<Texture> textures, ProjectBuilder builder, TextureMipSourceType mipSourceType, out UDimSettings udimSettings)
		{
			udimSettings = new UDimSettings();
			textures = new List<Texture>();
			foreach (PatternScanner.TextureFile textureFile in templateInfo.FoundTextureFiles.TextureFiles)
			{
				_ = layerConfig.Layers[layer].DataType;
				Texture texture = new Texture();
				texture.Source = textureFile.Filename;
				texture.Column = textureFile.X;
				texture.Row = textureFile.Y;
				texture.SubIndex = textureFile.SubIndex;
				textures.Add(texture);
			}
			if (templateInfo.Type == TextureType.UDim)
			{
				udimSettings = new UDimSettings();
				udimSettings.VTiles = templateInfo.FoundTextureFiles.Range.GetUdimHeight();
				udimSettings.UTiles = templateInfo.FoundTextureFiles.Range.GetUdimWidth();
				udimSettings.UTileOffset = 0;
				udimSettings.VTileOffset = templateInfo.FoundTextureFiles.Range.MinRow;
				udimSettings.MaxUTiles = templateInfo.FoundTextureFiles.UDimDetectedUTiles;
			}
		}

		public static void UpdateTextures(TextureType importType, AssetType assetType, LayerConfig layerConfig, List<Texture> textures, out TexturesInfo info, UDimSettings udimSettings, int face, int layer, ProjectBuilder builder, TextureMipSourceType mipSourceType)
		{
			_ = builder.EnableAutoDepthConversion;
			info = new TexturesInfo();
			info.MinNumChannels = 4;
			for (int i = 0; i < textures.Count; i++)
			{
				Texture texture = textures[i];
				DataType dataType = layerConfig.Layers[layer].DataType;
				bool isCube = assetType == AssetType.CubeMap;
				LoadTexture(texture.Source, texture.Row, texture.Column, face, isCube, dataType, builder, mipSourceType, ref texture);
				if (info.MinNumChannels == 0)
				{
					throw new ImportException("Invalid image data (no channel data found) in texture source: " + texture.Source + ", make sure the file is a valid image");
				}
				info.MinNumChannels = Math.Min(info.MinNumChannels, texture.NumChannels);
			}
			GetPatternRange(textures, out var range);
			info.Range = range;
			switch (importType)
			{
			case TextureType.Single:
			case TextureType.UDim:
			{
				int num = 0;
				int num2 = 0;
				foreach (Texture texture2 in textures)
				{
					num = Math.Max(num, texture2.Width);
					num2 = Math.Max(num2, texture2.Height);
				}
				info.TotalWidth = info.Range.GetUdimWidth() * num;
				info.TotalHeight = (info.Range.MaxRow - info.Range.MinRow + 1) * num2;
				break;
			}
			case TextureType.Tiled:
			{
				Size size = CalculateTiledTextureSize(textures);
				info.TotalWidth = size.Width;
				info.TotalHeight = size.Height;
				break;
			}
			}
		}

		public static void CheckSwizzle(string swizzle, int numChannelsSrc, int numChannelsDst)
		{
			if (swizzle == null || swizzle.Length == 0)
			{
				return;
			}
			int num = Math.Max(numChannelsSrc, numChannelsDst);
			Math.Max(numChannelsSrc, numChannelsDst);
			if (swizzle.Length > num)
			{
				string message = "The number of digits in a swizzle string value can only be as high as the maximum of channels between source (" + numChannelsSrc + ") and destination (" + numChannelsDst + "), please review the swizzle value";
				throw new InvalidSwizzleException(swizzle, message);
			}
			for (int i = 0; i < Math.Min(num, swizzle.Length); i++)
			{
				if (!char.IsNumber(swizzle[i]))
				{
					throw new InvalidSwizzleException(swizzle, "Swizzle string can only contain digits, please remove non digit symbols, please review the swizzle value");
				}
				if (int.Parse(swizzle[i].ToString()) >= num)
				{
					throw new InvalidSwizzleException(swizzle, "Swizzle digits must be lower than " + num + ", which is the maximum number of channels between source (" + numChannelsSrc + ") and destination (" + numChannelsDst + "), please review the swizzle value");
				}
			}
		}

		public static List<TextureChange> GetChangedTextures(Asset newAsset, Asset oldAsset)
		{
			List<TextureChange> list = new List<TextureChange>();
			if (newAsset == null && oldAsset == null)
			{
				return list;
			}
			int num = newAsset?.AssetLayers.Count() ?? oldAsset.AssetLayers.Count();
			for (int i = 0; i < num; i++)
			{
				List<Texture> list2 = new List<Texture>();
				List<Texture> list3 = new List<Texture>();
				List<Texture> list4 = new List<Texture>();
				if (newAsset != null)
				{
					list2.AddRange(newAsset.AssetLayers[i].Textures);
					list3.AddRange(newAsset.AssetLayers[i].Textures);
				}
				if (oldAsset != null)
				{
					list4.AddRange(oldAsset.AssetLayers[i].Textures);
				}
				foreach (Texture sameNewTex in list3)
				{
					Texture texture = list4.Find((Texture t) => t.Source == sameNewTex.Source && t.Column == sameNewTex.Column && t.Row == sameNewTex.Row);
					if (texture != null)
					{
						if (!DateTimeManagement.SameTimeMs(sameNewTex.LastChangedDate, texture.LastChangedDate))
						{
							TextureChange item = default(TextureChange);
							item.ChangeType = TextureChangeType.Modified;
							item.AssetId = newAsset.Id;
							item.Layer = i;
							item.Source = sameNewTex.Source;
							item.AssetName = newAsset.Name;
							list.Add(item);
						}
						list4.Remove(texture);
						list2.Remove(sameNewTex);
					}
				}
				foreach (Texture item4 in list2)
				{
					TextureChange item2 = default(TextureChange);
					item2.ChangeType = TextureChangeType.New;
					item2.AssetId = newAsset.Id;
					item2.Layer = i;
					item2.Source = item4.Source;
					item2.AssetName = newAsset.Name;
					list.Add(item2);
				}
				foreach (Texture item5 in list4)
				{
					TextureChange item3 = default(TextureChange);
					item3.ChangeType = TextureChangeType.Deleted;
					item3.AssetId = oldAsset.Id;
					item3.Layer = i;
					item3.Source = item5.Source;
					item3.AssetName = oldAsset.Name;
					list.Add(item3);
				}
			}
			return list;
		}

		public static void CheckDataTypes(Asset asset, LayerConfig layerConfiguration, string projectDir)
		{
			if (asset == null || layerConfiguration == null || asset.AssetLayers == null || layerConfiguration.Layers == null || asset.AssetLayers.Count != layerConfiguration.Layers.Count)
			{
				return;
			}
			ImageFactory.Create(out var image);
			int num = 0;
			foreach (AssetLayer assetLayer in asset.AssetLayers)
			{
				DataType dataType = layerConfiguration.Layers[num].DataType;
				ChannelDataType channelDataType = DataTypeInfo.GetChannelDataType(dataType);
				foreach (Texture texture in assetLayer.Textures)
				{
					string absolutePath = Paths.GetAbsolutePath(projectDir, texture.Source);
					Grim.Error error = image.Open(absolutePath);
					if (error != 0)
					{
						throw new GrimException(error, absolutePath);
					}
					Spec spec = image.GetSpec();
					if (!ImageFactory.IsConvertable(spec.GetChannelFormat(), channelDataType))
					{
						throw new InvalidTypeException(asset.Name, absolutePath, spec.GetChannelFormat().ToString(), dataType.ToString());
					}
					image.Close();
				}
				num++;
			}
		}

		internal static bool AspectRatioEquals(int width1, int height1, int width2, int height2)
		{
			double num = (double)width1 / (double)height1;
			double num2 = (double)width2 / (double)height2;
			return Math.Abs(num - num2) < 5E-07;
		}

		internal static bool AssetImportSucceeded(ProjectBuilder builder, Asset asset)
		{
			if (asset.Type == AssetType.CubeMap)
			{
				Asset[] array = AssetTools.FindCubeMapAssets(builder.ActiveProject, asset.AssetGroupId);
				foreach (Asset face in array)
				{
					if (builder.ActiveProject.ImportSummary.FailedAssetUpdates.FindAll((Asset x) => x.Name.Equals(face.Name)).Count != 0)
					{
						return false;
					}
				}
				return true;
			}
			return builder.ActiveProject.ImportSummary.FailedAssetUpdates.FindAll((Asset x) => x.Name.Equals(asset.Name)).Count == 0;
		}

		internal static bool AssetWasImported(Project project, Asset asset)
		{
			ImportAsset importAsset = project.ImportAssets.Find((ImportAsset x) => string.Equals(x.Name, asset.Name, StringComparison.InvariantCultureIgnoreCase));
			Asset asset2 = project.GTexImportAssets.Find((Asset x) => string.Equals(x.Name, asset.Name, StringComparison.InvariantCultureIgnoreCase));
			if (importAsset == null)
			{
				return asset2 != null;
			}
			return true;
		}
	}
	public class AssetTools
	{
		public enum AssetToImportAssetConversionOptions
		{
			AllowExtend,
			AllowExtendAndShrink
		}

		internal struct TexturePlacing
		{
			public bool IsTop { get; set; }

			public bool IsBottom { get; set; }

			public bool IsLeft { get; set; }

			public bool IsRight { get; set; }

			public TexturePlacing(bool isTop, bool isBottom, bool isLeft, bool isRight)
			{
				this = default(TexturePlacing);
				IsTop = isTop;
				IsBottom = isBottom;
				IsLeft = isLeft;
				IsRight = IsRight;
			}
		}

		internal struct TextureRect
		{
			public MipRegion Region { get; set; }

			public TexturePlacing Placing { get; set; }

			public TextureRect(int x, int y, int level, int width, int height)
			{
				this = default(TextureRect);
				Region = new MipRegion(x, y, width, height, level);
			}

			public TextureRect(MipRegion region)
			{
				this = default(TextureRect);
				Region = region;
			}

			public TextureRect(MipRegion region, TexturePlacing placing)
			{
				this = default(TextureRect);
				Region = region;
				Placing = placing;
			}

			public Rectangle GetRectangleWithBorders(int borderSize)
			{
				int num = Region.X;
				int num2 = Region.Y;
				int num3 = Region.Width;
				int num4 = Region.Height;
				if (Placing.IsTop)
				{
					num2 -= borderSize;
					num4 += borderSize;
				}
				if (Placing.IsBottom)
				{
					num4 += borderSize;
				}
				if (Placing.IsLeft)
				{
					num -= borderSize;
					num3 += borderSize;
				}
				if (Placing.IsRight)
				{
					num3 += borderSize;
				}
				return new Rectangle(num, num2, num3, num4);
			}
		}

		internal struct AssetLayerRect
		{
			public int X { get; set; }

			public int Y { get; set; }

			public int Width { get; set; }

			public int Height { get; set; }

			public int FirstFilledLevel { get; set; }

			public int BorderSize { get; set; }

			public Rectangle Rect => new Rectangle(X, Y, Width, Height);

			public Rectangle RectangleWithBorders => new Rectangle(X - BorderSize, Y - BorderSize, Width + 2 * BorderSize, Height + 2 * BorderSize);

			public AssetLayerRect(int x, int y, int level, int width, int height, int borderSize)
			{
				this = default(AssetLayerRect);
				BorderSize = borderSize;
				X = x;
				Y = y;
				Width = width;
				Height = height;
			}
		}

		public static bool AssetToImportAsset(Asset asset, string projectPath, out ImportAsset import)
		{
			import = new ImportAsset();
			import.TilingMethod = asset.TilingMethod;
			import.TargetWidth = asset.TargetWidth;
			import.TargetHeight = asset.TargetHeight;
			import.AutoScalingMode = asset.AutoScalingMode;
			import.Type = asset.Type;
			if (asset.Type == AssetType.CubeMap)
			{
				if (asset.Face != 0)
				{
					return false;
				}
				import.Name = asset.AssetGroupId;
			}
			else
			{
				import.Name = asset.Name;
			}
			int subIdx;
			for (int i = 0; i < asset.AssetLayers.Count; i++)
			{
				AssetLayer assetLayer = asset.AssetLayers[i];
				ImportAssetLayer importAssetLayer = new ImportAssetLayer();
				importAssetLayer.Flip = assetLayer.Flip;
				importAssetLayer.QualityProfile = assetLayer.QualityProfile;
				importAssetLayer.Resize = assetLayer.Resize;
				for (int j = 0; j < 4; j++)
				{
					importAssetLayer.Swizzle[j] = assetLayer.Swizzle[j];
					importAssetLayer.InvertChannels[j] = assetLayer.InvertChannels[j];
				}
				importAssetLayer.MipSourceType = assetLayer.MipSourceType;
				importAssetLayer.PackingMode = assetLayer.PackingMode;
				importAssetLayer.TargetWidth = assetLayer.TargetWidth;
				importAssetLayer.TargetHeight = assetLayer.TargetHeight;
				importAssetLayer.ResizeMode = assetLayer.ResizeMode;
				importAssetLayer.ColorSpace = assetLayer.ColorSpace;
				if (assetLayer.Textures.Count != 0)
				{
					try
					{
						for (subIdx = 0; subIdx < 4; subIdx++)
						{
							Texture texture = assetLayer.Textures.Find((Texture _tex) => _tex.SubIndex == subIdx);
							if (texture != null)
							{
								string source = texture.Source;
								ImportTemplateInfo importTemplateInfo = ImportTemplateConstructor.TemplateFromFilename(Paths.GetAbsolutePath(projectPath, source), assetLayer.TextureType[subIdx]);
								importAssetLayer.Source.AddSource(importTemplateInfo.TemplateString, subIdx);
							}
						}
					}
					catch
					{
						CombinedTextureSource combinedTextureSource = new CombinedTextureSource();
						combinedTextureSource.AddSource(assetLayer.Textures[0].Source, 0);
						importAssetLayer.Source = combinedTextureSource;
					}
				}
				import.Layers.Add(importAssetLayer);
			}
			return true;
		}

		private static bool CompareLayerConfigDataTypes(LayerConfig config1, LayerConfig config2, int layersToMatch)
		{
			for (int i = 0; i < layersToMatch; i++)
			{
				if (config1.Layers[i].DataType != config2.Layers[i].DataType)
				{
					return false;
				}
			}
			return true;
		}

		public static bool ConvertAssetToImportAsset(Asset asset, string projectPath, LayerConfig sourceLayerConfig, LayerConfig targetLayerConfig, out ImportAsset import, AssetToImportAssetConversionOptions options)
		{
			if (!AssetToImportAsset(asset, projectPath, out import))
			{
				return false;
			}
			bool num = options == AssetToImportAssetConversionOptions.AllowExtendAndShrink;
			bool flag = options == AssetToImportAssetConversionOptions.AllowExtendAndShrink || options == AssetToImportAssetConversionOptions.AllowExtend;
			if (num && import.Layers.Count > targetLayerConfig.Layers.Count)
			{
				for (int num2 = import.Layers.Count - 1; num2 > targetLayerConfig.Layers.Count - 1; num2--)
				{
					import.Layers.RemoveAt(num2);
				}
			}
			if (flag && import.Layers.Count < targetLayerConfig.Layers.Count)
			{
				ImportAssetLayer item = new ImportAssetLayer();
				for (int i = import.Layers.Count; i < targetLayerConfig.Layers.Count; i++)
				{
					import.Layers.Add(item);
				}
			}
			bool num3 = import.Layers.Count == targetLayerConfig.Layers.Count;
			bool flag2 = CompareLayerConfigDataTypes(sourceLayerConfig, targetLayerConfig, Math.Min(sourceLayerConfig.Layers.Count, targetLayerConfig.Layers.Count));
			return num3 && flag2;
		}

		private static void CompareFiles(List<string> files, List<Texture> textures, out List<string> addedFiles, out List<string> missingFiles)
		{
			missingFiles = new List<string>();
			addedFiles = new List<string>();
			List<string> list = new List<string>();
			foreach (string file in files)
			{
				list.Add(Path.GetFileName(file).ToLower());
			}
			foreach (Texture texture in textures)
			{
				string item = Path.GetFileName(texture.Source).ToLower();
				if (list.Contains(item))
				{
					list.Remove(item);
				}
				else
				{
					missingFiles.Add(item);
				}
			}
			addedFiles.AddRange(list);
		}

		internal static bool IsAssetPatternChanged(Asset asset)
		{
			List<string> addedFiles;
			List<string> missingFiles;
			return IsAssetPatternChanged(asset, out addedFiles, out missingFiles);
		}

		internal static bool IsAssetPatternChanged(Asset asset, out List<string> addedFiles, out List<string> missingFiles)
		{
			addedFiles = new List<string>();
			missingFiles = new List<string>();
			bool flag = true;
			for (int j = 0; j < 4; j++)
			{
				flag = flag && asset.UDimSettings[j] == null;
				if (!flag)
				{
					break;
				}
			}
			if (flag)
			{
				return false;
			}
			bool flag2 = true;
			for (int k = 0; k < asset.AssetLayers.Count; k++)
			{
				AssetLayer assetLayer = asset.AssetLayers[k];
				if (assetLayer.Textures.Count == 0)
				{
					continue;
				}
				List<string> addedFiles2 = null;
				List<string> missingFiles2 = null;
				List<string> list = new List<string>();
				int num = ChannelMerging.GetMaxValidSubTextureIdx(assetLayer.PackingMode) + 1;
				int i;
				for (i = 0; i < num; i++)
				{
					List<Texture> list2 = assetLayer.Textures.FindAll((Texture _tex) => _tex.SubIndex == i);
					if (list2.Count <= 0)
					{
						continue;
					}
					ImportTemplateInfo importTemplateInfo = ImportTemplateConstructor.TemplateFromFilename(list2[0].Source);
					if (importTemplateInfo.Type == TextureType.UDim)
					{
						list.AddRange(importTemplateInfo.FoundTextureFiles.TextureFiles.Select((PatternScanner.TextureFile tf) => tf.Filename));
					}
				}
				CompareFiles(new List<string>(list), assetLayer.Textures, out addedFiles2, out missingFiles2);
				addedFiles.AddRange(addedFiles2);
				missingFiles.AddRange(missingFiles2);
				if (assetLayer.Textures.Count != missingFiles2.Count)
				{
					flag2 = false;
				}
			}
			if (flag2)
			{
				return false;
			}
			if (missingFiles.Count <= 0)
			{
				return addedFiles.Count > 0;
			}
			return true;
		}

		public static Size CalculateLayerSubTextureSize(Asset asset, int layer, int subIndex)
		{
			AssetLayer assetLayer = asset.AssetLayers[layer];
			if (assetLayer.Textures.Count == 0)
			{
				return new Size(0, 0);
			}
			if (assetLayer.TextureType[subIndex] == TextureType.UDim && asset.UDimSettings[subIndex] != null)
			{
				Size size = AssetImportTools.FindLargestTexture(assetLayer, openFiles: false, subIndex);
				UDimSettings uDimSettings = asset.UDimSettings[subIndex];
				int width = (uDimSettings.UTiles - uDimSettings.UTileOffset) * size.Width;
				int height = (uDimSettings.VTiles - uDimSettings.VTileOffset) * size.Height;
				return new Size(width, height);
			}
			if (assetLayer.TextureType[subIndex] == TextureType.Tiled)
			{
				return AssetImportTools.CalculateTiledTextureSize(assetLayer.Textures.Where((Texture _tex) => _tex.SubIndex == subIndex).ToList());
			}
			int num = assetLayer.Textures.FindIndex((Texture _tex) => _tex.SubIndex == subIndex);
			if (num == -1)
			{
				return new Size(0, 0);
			}
			return new Size(assetLayer.Textures[num].Width, assetLayer.Textures[num].Height);
		}

		public static Size CalculateLayerTextureSize(Asset asset, int layer, int subIndex)
		{
			_ = asset.AssetLayers[layer];
			if (subIndex < 0)
			{
				subIndex = GetDominantSubIndex(asset, layer);
			}
			return CalculateLayerSubTextureSize(asset, layer, subIndex);
		}

		public static Size CalculateLayerSize(Asset asset, int layer, int subIndex, bool useForcedSize)
		{
			AssetLayer assetLayer = asset.AssetLayers[layer];
			Size result = new Size(assetLayer.TargetWidth, assetLayer.TargetHeight);
			bool num = result.Width != 0 && result.Height != 0 && useForcedSize;
			Size result2 = CalculateLayerTextureSize(asset, layer, subIndex);
			if (num)
			{
				if (assetLayer.ResizeMode == AssetLayerResizeMode.RelativeToSource && assetLayer.TargetWidth < 0)
				{
					int num2 = (int)Math.Pow(2.0, -assetLayer.TargetWidth);
					return new Size(result2.Width / num2, result2.Height / num2);
				}
				if (assetLayer.ResizeMode == AssetLayerResizeMode.RelativeToStackedTexture && assetLayer.TargetWidth < 0)
				{
					Size size = CalculateNaturalAssetSize(asset);
					int num3 = (int)Math.Pow(2.0, -assetLayer.TargetWidth);
					return new Size(size.Width / num3, size.Height / num3);
				}
				return result;
			}
			return result2;
		}

		public static Size CalculateAssetSize(Asset asset, out List<Size> layerSizes, int subIndex, bool forceLayerSize)
		{
			layerSizes = new List<Size>();
			for (int i = 0; i < asset.AssetLayers.Count; i++)
			{
				layerSizes.Add(CalculateLayerSize(asset, i, subIndex, forceLayerSize));
			}
			return Various.MaxSize(layerSizes);
		}

		public static Size CalculateAssetSize(Asset asset)
		{
			List<Size> layerSizes = new List<Size>();
			return CalculateAssetSize(asset, out layerSizes, -1, forceLayerSize: true);
		}

		public static Size CalculateNaturalAssetSize(Asset asset)
		{
			List<Size> list = new List<Size>();
			for (int i = 0; i < asset.AssetLayers.Count; i++)
			{
				list.Add(CalculateLayerSize(asset, i, -1, useForcedSize: false));
			}
			return Various.MaxSize(list);
		}

		public static Size CalculateScaledSize(Size targetLayerSize, AutoScalingMode scaleMode)
		{
			return scaleMode switch
			{
				AutoScalingMode.NearestPowerOf2 => new Size(ExtraMath.NearestPowerOfTwo(targetLayerSize.Width), ExtraMath.NearestPowerOfTwo(targetLayerSize.Height)), 
				AutoScalingMode.NextPowerOf2 => new Size(ExtraMath.NextPowerOfTwo(targetLayerSize.Width), ExtraMath.NextPowerOfTwo(targetLayerSize.Height)), 
				AutoScalingMode.PreviousPowerOf2 => new Size(ExtraMath.PreviousPowerOfTwo(targetLayerSize.Width), ExtraMath.PreviousPowerOfTwo(targetLayerSize.Height)), 
				_ => targetLayerSize, 
			};
		}

		public static bool AssetHasNonLevel0Placement(Asset asset)
		{
			for (int i = 0; i < asset.AssetLayers.Count; i++)
			{
				Size targetLayerSize = new Size(asset.Width, asset.Height);
				Size layerSize = CalculateLayerSize(asset, i, 0, useForcedSize: true);
				Double2 @double = CalculateLayerResizeScale(targetLayerSize, layerSize);
				if (@double.X > 1.0 || @double.Y > 1.0)
				{
					return true;
				}
			}
			return false;
		}

		internal static void CalculateAssetLayerRegion(TiledTopology topology, Asset asset, Int2 packedAssetPos, int layer, Double2 assetScaling, int subIdx, out AssetLayerRect assetLayerRect)
		{
			List<Texture> list = asset.AssetLayers[layer].Textures.Where((Texture _tex) => _tex.SubIndex == subIdx).ToList();
			assetLayerRect = default(AssetLayerRect);
			if (list.Count != 0)
			{
				int level = 0;
				int num = 0;
				int x2 = packedAssetPos.X;
				int y = packedAssetPos.Y;
				int num2 = asset.UDimSettings[0]?.VTileOffset ?? 0;
				int num3 = list.Max((Texture x) => x.Row);
				int width = (list.Max((Texture x) => x.Column) + 1) * (int)Math.Round((double)list[0].Width * assetScaling.X);
				int height = (num3 - num2 + 1) * (int)Math.Round((double)list[0].Height * assetScaling.Y);
				assetLayerRect = new AssetLayerRect(x2 + num, y + num, level, width, height, num);
			}
		}

		internal static Double2 CalculateLayerResizeScale(Size targetLayerSize, Size layerSize)
		{
			double x = (double)targetLayerSize.Width / (double)layerSize.Width;
			double y = (double)targetLayerSize.Height / (double)layerSize.Height;
			return new Double2(x, y);
		}

		internal static void CalculateTextureRects(TiledTopology topology, Asset asset, Int2 packedAssetPos, int layer, Double2[] layerScaling, Double2[] textureScaling, bool enableTextureLevelClip, out Dictionary<Texture, TextureRect> textureRects, out Dictionary<Texture, TextureRect> importRects, out AssetLayerRect assetRect)
		{
			AssetLayer assetLayer = asset.AssetLayers[layer];
			int dominantSubIndex = GetDominantSubIndex(asset, layer);
			textureRects = new Dictionary<Texture, TextureRect>();
			importRects = new Dictionary<Texture, TextureRect>();
			assetRect = default(AssetLayerRect);
			List<Texture> textures = assetLayer.Textures;
			if (textures.Count == 0)
			{
				return;
			}
			int num = 0;
			CalculateLayerTextureSize(asset, layer, -1);
			foreach (Texture item in textures)
			{
				if (item.SubIndex == dominantSubIndex)
				{
					Size targetSize = default(Size);
					targetSize.Width = (int)Math.Round((double)item.Width * textureScaling[dominantSubIndex].X * layerScaling[dominantSubIndex].X);
					targetSize.Height = (int)Math.Round((double)item.Height * textureScaling[dominantSubIndex].Y * layerScaling[dominantSubIndex].Y);
					Size textureSize = new Size((int)Math.Round((double)item.Width * textureScaling[dominantSubIndex].X), (int)Math.Round((double)item.Height * textureScaling[dominantSubIndex].Y));
					int maxLevel = (int)(topology.numLevels - 1);
					int val = CalculateTextureImportLevel(enableTextureLevelClip, targetSize, textureSize, maxLevel);
					num = Math.Max(num, val);
				}
			}
			CalculateAssetLayerRegion(topology, asset, packedAssetPos, layer, layerScaling[dominantSubIndex], dominantSubIndex, out assetRect);
			assetRect.FirstFilledLevel = num;
			int left = assetRect.RectangleWithBorders.Left;
			int top = assetRect.RectangleWithBorders.Top;
			int borderSize = assetRect.BorderSize;
			int subIdx;
			for (subIdx = 0; subIdx < 4; subIdx++)
			{
				List<Texture> list = textures.Where((Texture _tex) => _tex.SubIndex == subIdx).ToList();
				if (list.Count == 0)
				{
					continue;
				}
				list.Min((Texture x) => x.Row);
				int num2 = list.Max((Texture x) => x.Row);
				int num3 = list.Max((Texture x) => x.Column);
				int num4 = 0;
				UDimSettings uDimSettings = asset.UDimSettings[0];
				if (uDimSettings != null)
				{
					num4 = uDimSettings.VTileOffset;
				}
				int num5 = num2 - num4 + 1;
				Size[,] array = new Size[num5, num3 + 1];
				Size size = new Size(0, 0);
				if (assetLayer.TextureType[subIdx] == TextureType.UDim && list.Count > 0)
				{
					size = new Size((int)Math.Round((double)list[0].Width * textureScaling[dominantSubIndex].X * layerScaling[subIdx].X), (int)Math.Round((double)list[0].Height * textureScaling[dominantSubIndex].Y * layerScaling[subIdx].Y));
				}
				for (int i = 0; i < num5; i++)
				{
					for (int j = 0; j < num3 + 1; j++)
					{
						array[i, j] = size;
					}
				}
				foreach (Texture item2 in list)
				{
					array[item2.Row - num4, item2.Column] = new Size((int)Math.Round((double)item2.Width * textureScaling[dominantSubIndex].X * layerScaling[subIdx].X), (int)Math.Round((double)item2.Height * textureScaling[dominantSubIndex].Y * layerScaling[subIdx].Y));
				}
				foreach (Texture item3 in list)
				{
					int num6 = left + borderSize;
					for (int k = 0; k < item3.Column; k++)
					{
						num6 += array[item3.Row - num4, k].Width;
					}
					int num7 = top + borderSize;
					for (int l = 0; l < item3.Row - num4; l++)
					{
						num7 += array[l, item3.Column].Height;
					}
					TextureRect value = new TextureRect(num6, num7, 0, (int)Math.Round((double)item3.Width * textureScaling[dominantSubIndex].X * layerScaling[subIdx].X), (int)Math.Round((double)item3.Height * textureScaling[dominantSubIndex].Y * layerScaling[subIdx].Y));
					TexturePlacing placing = default(TexturePlacing);
					if (item3.Column == 0)
					{
						placing.IsLeft = true;
					}
					if (item3.Column == num3)
					{
						placing.IsRight = true;
					}
					if (item3.Row == num4)
					{
						placing.IsTop = true;
					}
					if (item3.Row == num2)
					{
						placing.IsBottom = true;
					}
					value.Placing = placing;
					textureRects.Add(item3, value);
					MipRegion region = value.Region.ProjectOnLevel(num);
					TextureRect value2 = new TextureRect(region, placing);
					importRects.Add(item3, value2);
				}
			}
		}

		internal static bool IsIntegralScaling(Size dimensions, Double2 scale)
		{
			double x = Math.Round((double)dimensions.Width * scale.X, 10);
			double x2 = Math.Round((double)dimensions.Height * scale.Y, 10);
			if (ExtraMath.Frac(x) == 0.0)
			{
				return ExtraMath.Frac(x2) == 0.0;
			}
			return false;
		}

		internal static int CalculateTextureImportLevel(bool clipToLevel, Size targetSize, Size textureSize, int maxLevel)
		{
			double num = (double)targetSize.Width / (double)textureSize.Width;
			double num2 = (double)targetSize.Height / (double)textureSize.Height;
			int num3 = 0;
			while (num >= 1.5 && num2 >= 1.5 && clipToLevel && num3 < maxLevel)
			{
				double defaultValue = 1.0 / Math.Pow(2.0, num3 + 1);
				if (!IsIntegralScaling(targetSize, new Double2(defaultValue)))
				{
					break;
				}
				num /= 2.0;
				num2 /= 2.0;
				num3++;
			}
			return num3;
		}

		internal static bool TestTilingMethod(Asset asset)
		{
			if (asset.TilingMethod != 0)
			{
				if (ExtraMath.IsPowerOfTwo(asset.Width))
				{
					return ExtraMath.IsPowerOfTwo(asset.Height);
				}
				return false;
			}
			return true;
		}

		public static int GetNumTextureChannels(Asset Asset, ProjectBuilder Builder, int LayerIndex, int subIdx = 0)
		{
			LayerDescription layerDescription = Builder.ActiveProject.LayerConfiguration.Layers[LayerIndex];
			int numChannels = DataTypeInfo.GetNumChannels(layerDescription.DataType);
			int val = 4;
			foreach (Texture item in Asset.AssetLayers[LayerIndex].Textures.Where((Texture _tex) => _tex.SubIndex == subIdx))
			{
				val = Math.Min(val, item.NumChannels);
			}
			int val2 = Math.Min(val, numChannels);
			AssetPackingMode packingMode = Asset.AssetLayers[LayerIndex].PackingMode;
			_ = Asset.AssetLayers[LayerIndex];
			int channelCount = ChannelMerging.GetChannelCount(packingMode, layerDescription.DataType, LayerIndex, subIdx);
			return Math.Min(val2, channelCount);
		}

		public static System.Drawing.Color NixelColorToColor(Nixel.Color color)
		{
			return System.Drawing.Color.FromArgb(color.a, color.r, color.g, color.b);
		}

		public static Nixel.Color ParseNixelColor(string hexString, DataType layerDataType)
		{
			if (hexString == null || hexString.Length < 2)
			{
				Nixel.Color color = default(Nixel.Color);
				Nixel.Tools.GetDefaultColorForLayerType(layerDataType, ref color);
				return color;
			}
			uint num = 0u;
			try
			{
				if (!hexString.StartsWith("#") || hexString.Length <= 1)
				{
					throw new Exception("Invalid hex number");
				}
				num = uint.Parse(hexString.Substring(1), NumberStyles.AllowHexSpecifier);
			}
			catch (Exception innerException)
			{
				throw new UnspecifiedException("Default color could not be parsed", innerException);
			}
			byte a = (byte)(num & 0xFFu);
			byte b = (byte)((num >> 8) & 0xFFu);
			byte g = (byte)((num >> 16) & 0xFFu);
			return new Nixel.Color((byte)((num >> 24) & 0xFFu), g, b, a);
		}

		public static int GetDominantSubIndex(Asset asset, int layer)
		{
			AssetLayer assetLayer = asset.AssetLayers[layer];
			if (!ChannelMerging.IsCombinedMode(assetLayer.PackingMode))
			{
				return 0;
			}
			long num = 0L;
			int result = 0;
			int num2 = ChannelMerging.GetMaxValidSubTextureIdx(assetLayer.PackingMode) + 1;
			for (int i = 0; i < num2; i++)
			{
				Size size = CalculateLayerSubTextureSize(asset, layer, i);
				long num3 = (long)size.Width * (long)size.Height;
				if (num3 > num)
				{
					num = num3;
					result = i;
				}
			}
			return result;
		}

		public static Asset[] FindCubeMapAssets(Project project, string groupId)
		{
			List<Asset> list = new List<Asset>();
			foreach (Asset value in project.Assets.Values)
			{
				if (value.AssetGroupId != null && value.AssetGroupId.Equals(groupId))
				{
					list.Add(value);
				}
			}
			list.Sort((Asset a1, Asset a2) => a1.Face.CompareTo(a2.Face));
			return list.ToArray();
		}

		public static bool IsRootAsset(Project project, Asset asset)
		{
			return GetRootAsset(project, asset).Id == asset.Id;
		}

		public static Asset GetRootAsset(Project project, Asset asset)
		{
			if (asset.Type == AssetType.CubeMap)
			{
				if (asset.Face == 0)
				{
					return asset;
				}
				Asset[] array = FindCubeMapAssets(project, asset.AssetGroupId);
				if (array.Length == 0)
				{
					throw new FatalException();
				}
				return array[0];
			}
			return asset;
		}

		public static string GetIOFriendlyAssetName(string assetName)
		{
			return assetName.Replace("/", "_slash_").Replace("\\", "_bslash_").Replace(":", "_colon_")
				.Replace("<", "_lt_")
				.Replace(">", "_gt_")
				.Replace("\"", "_dquo_")
				.Replace("|", "_pipe_")
				.Replace("?", "_ques_")
				.Replace("*", "_ast_");
		}

		public static string GetIOFriendlyAssetName(Asset asset)
		{
			return GetIOFriendlyAssetName(asset.Name);
		}
	}
	internal class Atlasser
	{
		internal class AtlassedItem
		{
			public object Tag { get; set; }

			public int X { get; set; }

			public int Y { get; set; }

			public int Width { get; set; }

			public int Height { get; set; }
		}

		internal class AtlasItem
		{
			public object Tag { get; set; }

			public int Width { get; set; }

			public int Height { get; set; }

			public bool Power2Alignment { get; set; }

			public AtlasItem(object tag, int width, int height, bool power2Alignment)
			{
				Tag = tag;
				Width = width;
				Height = height;
				Power2Alignment = power2Alignment;
			}
		}

		private AtlasConfiguration config;

		private Int2 tileSize;

		public Atlasser(AtlasConfiguration config, Int2 tileSize)
		{
			this.config = config;
			this.tileSize = tileSize;
		}

		private int RoundToClosestPow2(int v)
		{
			switch (v)
			{
			case 0:
				return 0;
			case 1:
				return 1;
			default:
			{
				int num = (int)Math.Ceiling(Math.Log(v, 2.0));
				return 2 << num - 1;
			}
			}
		}

		private bool PackRectangles(int width, int height, IEnumerable<AtlassedItem> fixedRects, IEnumerable<AtlasItem> rects, out List<AtlassedItem> packedAssets, out int packedContentWidth, out int packedContentHeight)
		{
			packedAssets = new List<AtlassedItem>();
			BinPacking.PackingOptions options = default(BinPacking.PackingOptions);
			options.width = width;
			options.height = height;
			options.allowRotation = (config.AllowRotations ? 1 : 0);
			BinPacking.BeginPacking(ref options);
			if (fixedRects != null)
			{
				foreach (AtlassedItem fixedRect in fixedRects)
				{
					BinPacking.AddFixedRectangle(fixedRect.X, fixedRect.Y, fixedRect.Width, fixedRect.Height);
				}
			}
			foreach (AtlasItem rect in rects)
			{
				int num = RoundToClosestPow2(Math.Max(rect.Width, rect.Height));
				int alignment = 0;
				if (rect.Power2Alignment)
				{
					alignment = num;
				}
				BinPacking.AddRectangle(rect.Width, rect.Height, alignment);
			}
			int num2 = BinPacking.PackRectangles();
			packedContentWidth = 0;
			packedContentHeight = 0;
			if (num2 == 0)
			{
				return false;
			}
			int num3 = 0;
			foreach (AtlasItem rect2 in rects)
			{
				BinPacking.PackedRectangle outRectangle = default(BinPacking.PackedRectangle);
				BinPacking.GetPackedRectangle(num3, ref outRectangle);
				if (outRectangle.rotated != 0)
				{
					throw new Exception("Rotated rectangle!");
				}
				AtlassedItem atlassedItem = new AtlassedItem();
				atlassedItem.Tag = rect2.Tag;
				atlassedItem.X = outRectangle.x;
				atlassedItem.Y = outRectangle.y;
				atlassedItem.Width = outRectangle.width;
				atlassedItem.Height = outRectangle.height;
				packedContentWidth = Math.Max(atlassedItem.X + atlassedItem.Width, packedContentWidth);
				packedContentHeight = Math.Max(atlassedItem.Y + atlassedItem.Height, packedContentHeight);
				packedAssets.Add(atlassedItem);
				num3++;
			}
			if (fixedRects != null)
			{
				foreach (AtlassedItem fixedRect2 in fixedRects)
				{
					packedContentWidth = Math.Max(fixedRect2.X + fixedRect2.Width, packedContentWidth);
					packedContentHeight = Math.Max(fixedRect2.Y + fixedRect2.Height, packedContentHeight);
					packedAssets.Add(fixedRect2);
				}
			}
			return true;
		}

		private bool PackRectangles(IEnumerable<AtlassedItem> fixedRects, IEnumerable<AtlasItem> rects, out List<AtlassedItem> packed, out int packedWidth, out int packedHeight)
		{
			ulong num = 0uL;
			if (rects != null)
			{
				foreach (AtlasItem rect in rects)
				{
					_ = rect;
					num += (ulong)((long)tileSize.X * (long)tileSize.Y);
				}
			}
			if (fixedRects != null)
			{
				foreach (AtlassedItem fixedRect in fixedRects)
				{
					num += (ulong)((long)fixedRect.Width * (long)fixedRect.Height);
				}
			}
			if (num == 0L)
			{
				packed = new List<AtlassedItem>();
				packedWidth = (packedHeight = 0);
				return true;
			}
			int num2 = tileSize.X;
			int num3 = tileSize.Y;
			while ((ulong)((long)num2 * (long)num3) < num)
			{
				num2 *= 2;
				if ((ulong)((long)num2 * (long)num3) >= num)
				{
					break;
				}
				num3 *= 2;
			}
			do
			{
				if (PackRectangles(num2, num3, fixedRects, rects, out packed, out packedWidth, out packedHeight))
				{
					return true;
				}
				num2 *= 2;
				if (PackRectangles(num2, num3, fixedRects, rects, out packed, out packedWidth, out packedHeight))
				{
					return true;
				}
				num2 /= 2;
				num3 *= 2;
				if (PackRectangles(num2, num3, fixedRects, rects, out packed, out packedWidth, out packedHeight))
				{
					return true;
				}
				num2 *= 2;
			}
			while (num2 > 0 && num3 > 0);
			return false;
		}

		public bool Atlas(IEnumerable<AtlassedItem> fixedRects, IEnumerable<AtlasItem> rects, out List<AtlassedItem> packedAssets, out Int2 packedSize)
		{
			int packedWidth = 0;
			int packedHeight = 0;
			bool result = PackRectangles(fixedRects, rects, out packedAssets, out packedWidth, out packedHeight);
			packedSize = new Int2(packedWidth, packedHeight);
			return result;
		}
	}
	internal class CodingGroupManager
	{
		private class Entry
		{
			public NixelCodingGroupDescription codingGroup;

			public bool preset;

			public string quality;

			public int layer;

			public int nixelRegisteredIndex;

			public Entry()
			{
				nixelRegisteredIndex = -1;
			}
		}

		private List<Entry> codingGroups;

		private int layer;

		private DataType dataType;

		private CodingProfile codingProfile;

		public FixedTexFormat LayerFixedTexFormat;

		public CodingGroupManager(int layer, DataType dataType, CodingProfile codingProfile)
		{
			codingGroups = new List<Entry>();
			this.codingProfile = codingProfile;
			this.layer = layer;
			this.dataType = dataType;
		}

		private string CreateXMLCodingParameters(int datatype, string config)
		{
			return string.Concat(string.Concat(string.Concat(string.Concat(string.Concat(string.Concat(string.Concat(string.Concat("" + "<?XML version='1.0' encoding='UTF-8'?>", "<EncoderConfig>"), "<General>"), "<DataType>", datatype.ToString(), "</DataType>"), "</General>"), "<Parameters>"), config), "</Parameters>"), "</EncoderConfig>");
		}

		private Entry CreateDefaultCodingGroup(string quality)
		{
			string setQuality = quality;
			NixelCodingGroupDescription nixelCodingGroupDescription = new NixelCodingGroupDescription();
			nixelCodingGroupDescription.Id = Guid.NewGuid();
			QualityProfile qualityProfile = codingProfile.QualityProfiles.Find((QualityProfile x) => x.Name.ToLowerInvariant() == quality.ToLowerInvariant());
			if (qualityProfile == null)
			{
				setQuality = "default";
				qualityProfile = codingProfile.QualityProfiles.Find((QualityProfile x) => x.Name.ToLowerInvariant() == setQuality.ToLowerInvariant());
			}
			CodingConfig codingConfig = qualityProfile.CodingConfigs.Find((CodingConfig x) => x.DataTypes.Contains(dataType));
			nixelCodingGroupDescription.CodecConfig = new NixelCodecConfiguration();
			nixelCodingGroupDescription.CodecConfig.CodecId = codingConfig.CodecId;
			nixelCodingGroupDescription.CodecConfig.CodecConfiguration = codingConfig.CodecConfiguration;
			return new Entry
			{
				codingGroup = nixelCodingGroupDescription,
				preset = true,
				quality = setQuality,
				layer = layer
			};
		}

		public void AddCodingGroup(string quality)
		{
			Entry entry = CreateDefaultCodingGroup(quality);
			codingGroups.Add(entry);
			if (LayerFixedTexFormat == FixedTexFormat.Invalid)
			{
				return;
			}
			if (entry.quality.Equals("uniform"))
			{
				if (LayerFixedTexFormat == FixedTexFormat.Invalid)
				{
					LayerFixedTexFormat = FixedTexFormat.ANY;
				}
			}
			else
			{
				LayerFixedTexFormat = GetFixedTexFormat(dataType, entry.quality);
			}
		}

		public void RegisterCodingGroups(NixelContext ncontext)
		{
			RegisterCodingGroups(ncontext.TiledBuildParameters);
		}

		public void RegisterCodingGroups(ITiledBuildParameters buildParams)
		{
			foreach (Entry codingGroup in codingGroups)
			{
				string xmlCodingParameters = CreateXMLCodingParameters((int)dataType, codingGroup.codingGroup.CodecConfig.CodecConfiguration);
				int outLayerCodingGroupIndex = -1;
				buildParams.AddTileLayerCodingGroup((uint)layer, codingGroup.codingGroup.CodecConfig.CodecId, xmlCodingParameters, out outLayerCodingGroupIndex);
				codingGroup.nixelRegisteredIndex = outLayerCodingGroupIndex;
			}
		}

		private FixedTexFormat GetFixedTexFormat(DataType dataType, string quality)
		{
			CodingConfig codingConfig = codingProfile.QualityProfiles.Find((QualityProfile x) => x.Name.ToLowerInvariant() == quality.ToLowerInvariant()).CodingConfigs.Find((CodingConfig x) => x.DataTypes.Contains(dataType));
			FixedTexFormat result = FixedTexFormat.Invalid;
			if (Constants.CodecFixedFormats.ContainsKey(codingConfig.CodecId))
			{
				result = Constants.CodecFixedFormats[codingConfig.CodecId];
			}
			if (!string.IsNullOrEmpty(codingConfig.CodecConfiguration))
			{
				XmlDocument xmlDocument = new XmlDocument();
				xmlDocument.AppendChild(xmlDocument.CreateElement("head"));
				XmlNode xmlNode = xmlDocument.SelectSingleNode("head");
				xmlNode.InnerXml = codingConfig.CodecConfiguration;
				XmlNode xmlNode2 = xmlNode.SelectSingleNode("TextureFormat");
				if (xmlNode2 != null)
				{
					try
					{
						return Constants.GetFixedTexFormat((TextureFormat)System.Enum.Parse(typeof(TextureFormat), xmlNode2.InnerText.ToUpperInvariant()));
					}
					catch
					{
						return result;
					}
				}
			}
			return result;
		}

		public int FindCodingGroupNixelIndex(int layer, string quality)
		{
			if (quality == null)
			{
				return -1;
			}
			foreach (Entry codingGroup in codingGroups)
			{
				if (codingGroup.quality.ToLowerInvariant() == quality.ToLowerInvariant() && codingGroup.layer == layer)
				{
					return codingGroup.nixelRegisteredIndex;
				}
			}
			return -1;
		}
	}
	public class CodingProfileHelper
	{
		public static bool IsUniformQualityProfile(QualityProfile qp)
		{
			return qp.Name.ToLowerInvariant().Equals("uniform");
		}

		public static List<string> GetAvailableQualityProfiles(string codingProfileName, DataType layerDatatype)
		{
			return GetAvailableQualityProfiles(codingProfileName, layerDatatype, includeHidden: false, includeDefault: true);
		}

		public static List<string> GetAvailableQualityProfiles(CodingProfile profile, DataType layerDatatype, bool includeHidden, bool includeDefault)
		{
			List<string> list = new List<string>();
			if (includeDefault)
			{
				list.Add("Default");
			}
			foreach (QualityProfile qualityProfile in profile.QualityProfiles)
			{
				if (!includeHidden && qualityProfile.Hidden)
				{
					continue;
				}
				foreach (CodingConfig codingConfig in qualityProfile.CodingConfigs)
				{
					foreach (DataType dataType in codingConfig.DataTypes)
					{
						if (dataType == layerDatatype && !qualityProfile.Hidden && !(qualityProfile.Name.ToLowerInvariant().Equals("default") && includeDefault))
						{
							list.Add(qualityProfile.Name);
						}
					}
				}
			}
			return list;
		}

		public static List<string> GetAvailableQualityProfiles(string codingProfileName, DataType layerDatatype, bool includeHidden, bool includeDefault)
		{
			ProfileLoader.LoadCodingProfile(codingProfileName, out var profile);
			return GetAvailableQualityProfiles(profile, layerDatatype, includeHidden, includeDefault);
		}

		public static bool CodingProfileSupportsDataType(CodingProfile codingProfile, DataType layerDatatype)
		{
			return CodingProfileSupportsDataType(codingProfile, layerDatatype, includeUniform: false);
		}

		public static bool CodingProfileSupportsDataType(CodingProfile codingProfile, DataType layerDatatype, bool includeUniform)
		{
			foreach (QualityProfile qualityProfile in codingProfile.QualityProfiles)
			{
				if (!includeUniform && IsUniformQualityProfile(qualityProfile))
				{
					continue;
				}
				foreach (CodingConfig codingConfig in qualityProfile.CodingConfigs)
				{
					foreach (DataType dataType in codingConfig.DataTypes)
					{
						if (dataType == layerDatatype)
						{
							return true;
						}
					}
				}
			}
			return false;
		}

		public static List<CodingProfile> GetAvailableCodingProfiles(string buildProfileName, DataType layerDatatype)
		{
			BuildProfile profile;
			Error error = ProfileLoader.LoadBuildProfile(buildProfileName, out profile);
			if (error != 0)
			{
				throw new UnspecifiedException("Unable to load build profile '" + buildProfileName + "'. Detailed error message: '" + ProfileLoader.LastError + ".", error);
			}
			return GetAvailableCodingProfiles(profile, layerDatatype);
		}

		public static List<CodingProfile> GetAvailableCodingProfiles(BuildProfile buildProfile, DataType layerDatatype)
		{
			List<CodingProfile> list = new List<CodingProfile>();
			foreach (string availableCodingProfile in buildProfile.AvailableCodingProfiles)
			{
				ProfileLoader.LoadCodingProfile(availableCodingProfile, out var profile);
				if (profile == null)
				{
					throw new UnspecifiedException("Internal Error: No Coding Profile found named '" + availableCodingProfile + "'. Please contact Graphine.", Error.InvalidBuildProfile);
				}
				if (CodingProfileSupportsDataType(profile, layerDatatype))
				{
					list.Add(profile);
				}
			}
			return list;
		}

		public static Dictionary<DataType, List<string>> GetAvailableQualityProfiles(string codingProfileName)
		{
			ProfileLoader.LoadCodingProfile(codingProfileName, out var profile);
			Dictionary<DataType, List<string>> dictionary = new Dictionary<DataType, List<string>>();
			foreach (QualityProfile qualityProfile in profile.QualityProfiles)
			{
				foreach (CodingConfig codingConfig in qualityProfile.CodingConfigs)
				{
					foreach (DataType dataType in codingConfig.DataTypes)
					{
						if (!dictionary.ContainsKey(dataType))
						{
							dictionary[dataType] = new List<string>();
						}
						dictionary[dataType].Add(qualityProfile.Name.ToLowerInvariant());
					}
				}
			}
			return dictionary;
		}

		public static string ResolveNullCodingProfile(Project project, string codingProfileName, DataType dataType)
		{
			if (string.IsNullOrEmpty(codingProfileName))
			{
				ProfileLoader.LoadBuildProfile(project.BuildProfile, out var profile);
				codingProfileName = profile.DefaultCodingProfiles[dataType];
			}
			return codingProfileName;
		}

		public static string ResolveDefaultQualityProfile(Project project, string qualityProfile, string codingProfileName, string layerDefaultQualityProfile, DataType layerDatatype)
		{
			string text = "default";
			if (string.IsNullOrEmpty(qualityProfile))
			{
				qualityProfile = text;
			}
			if (!qualityProfile.Equals(text, StringComparison.InvariantCultureIgnoreCase))
			{
				return qualityProfile;
			}
			qualityProfile = layerDefaultQualityProfile;
			if (!qualityProfile.Equals(text, StringComparison.InvariantCultureIgnoreCase))
			{
				return qualityProfile;
			}
			if (string.IsNullOrEmpty(codingProfileName))
			{
				codingProfileName = ResolveNullCodingProfile(project, codingProfileName, layerDatatype);
			}
			ProfileLoader.LoadCodingProfile(codingProfileName, out var profile);
			foreach (DefaultQualitySetting defaultQualitySetting in profile.DefaultQualitySettings)
			{
				if (defaultQualitySetting.DataTypes.Contains(layerDatatype))
				{
					return defaultQualitySetting.QualityProfile;
				}
			}
			return qualityProfile;
		}
	}
	internal class CompositorSummary
	{
		public DateTime LastChangedDate { get; set; }
	}
	internal class Compositor
	{
		private struct ComposeAssetContext
		{
			public NixelContext NixelContext { get; set; }

			public Asset Asset { get; set; }

			public TileSetConfig TileSetConfig { get; set; }

			public uint AssetIndex { get; set; }

			public bool IncrementalBuild { get; set; }
		}

		private delegate Grim.Error GetScanLineDelegate(uint face, uint level, uint y, IntPtr data);

		internal class MipMapProgressTracker : IBuildProgressTracker
		{
			private ProjectBuilder builder;

			public MipMapProgressTracker(ProjectBuilder builder)
			{
				this.builder = builder;
			}

			public override CancelResult OnMipLevelGenerated(uint level, uint totalLevels)
			{
				return CancelResult.Continue;
			}
		}

		private ComposeAssetContext CurrentAsset;

		public ProjectBuilder ProjectBuilder { get; private set; }

		public Compositor(ProjectBuilder builder)
		{
			ProjectBuilder = builder;
		}

		public void ProcessAsset(Asset asset, NixelContextManager nixelContextManager)
		{
			Project activeProject = ProjectBuilder.ActiveProject;
			ProjectBuilder.State.IncrementalStates.Clear();
			DateTime now = DateTime.Now;
			if (!CheckState(out var error))
			{
				throw new CompositorException(error);
			}
			if (AssetTools.IsRootAsset(activeProject, asset) && !ProjectBuilder.Canceled)
			{
				ComposeAsset(asset, nixelContextManager);
				UpdateStateAsset(asset);
			}
			if (ProjectBuilder.ProfilingEnabled)
			{
				double num = Math.Truncate((DateTime.Now - now).TotalMilliseconds) / 1000.0;
				ProjectBuilder.logger.LogConsole("Done, elapsed time: " + num + " s", Logger.Verbosity.Quiet);
			}
		}

		private void ComposeAsset(Asset asset, NixelContextManager nixelContextManager)
		{
			_ = ProjectBuilder.ActiveProject;
			ProjectBuilder.State.IncrementalStates.Add(asset.Id, new BuildState.IncrementalBuildState());
			if (!ProjectBuilder.State.CodeRequired(asset))
			{
				return;
			}
			string rasterFileName = NixelContextManager.GetRasterFileName(ProjectBuilder, asset);
			NixelContext context = null;
			try
			{
				bool num = ProjectBuilder.State.ComposeRequired(asset);
				bool flag = num && !ProjectBuilder.NoPatching && ProjectBuilder.State.PartialComposePossible(asset);
				bool flag2 = ProjectBuilder.ActiveProject.ImportSummary.FailedAssetUpdates.FindAll((Asset x) => x.Id.Equals(asset.Id)).Count != 0;
				if (num && flag2)
				{
					throw new CompositorException("Some source files for asset '" + asset.Name + "' are not available and no GTex file was found. Cannot composite.");
				}
				bool clean = num && !flag;
				InitRasterData(asset, rasterFileName, clean, out context, out var tileSetConfig);
				nixelContextManager.SetContext(context, asset.Id);
				CurrentAsset = default(ComposeAssetContext);
				CurrentAsset.Asset = asset;
				CurrentAsset.NixelContext = context;
				CurrentAsset.TileSetConfig = tileSetConfig;
				CurrentAsset.AssetIndex = 1u;
				CurrentAsset.IncrementalBuild = flag;
				if (num)
				{
					ProjectBuilder.State.IncrementalStates[asset.Id].IncrementalBuildPossible = flag;
					ComposeAllData(asset, context);
				}
				else
				{
					SetAllBorderRegions(asset, context);
				}
			}
			catch (FatalException ex)
			{
				throw ex;
			}
			catch (GrBuildException ex2)
			{
				ComposeAssetIssue buildIssue = new ComposeAssetIssue(asset.Name, ex2.Message);
				if (GrBuildExceptionHandler.IsFatal(ex2))
				{
					ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.Compositor, buildIssue);
					throw new FatalException();
				}
				if (ProjectBuilder.BuildReportingHandler.OnError(BuildProcess.Compositor, buildIssue) == ErrorAction.Stop)
				{
					throw new FatalException();
				}
			}
		}

		private RasterDataType InitRasterData(Asset asset, string cacheFileName, bool clean, out NixelContext context, out TileSetConfig tileSetConfig)
		{
			_ = ProjectBuilder.ActiveProject;
			if (clean && File.Exists(cacheFileName) && !NixelContextManager.DeleteSerializedFiles(ProjectBuilder, cacheFileName))
			{
				throw new FatalException();
			}
			BuildState.CompositeState obj = ProjectBuilder.State.FindAssetCompositeState(asset.Id) ?? throw new FatalException();
			int packedWidth = obj.PackingSummary.PackedWidth;
			int packedHeight = obj.PackingSummary.PackedHeight;
			context = NixelContextManager.LoadorCreateContext(ProjectBuilder, cacheFileName, packedWidth, packedHeight, out tileSetConfig, out var newOrExisting);
			return newOrExisting;
		}

		private void ComposeAllData(Asset asset, NixelContext nixelContext)
		{
			Project activeProject = ProjectBuilder.ActiveProject;
			if (!AssetImportTools.AssetImportSucceeded(ProjectBuilder, asset))
			{
				return;
			}
			BuildState.CompositeState compositeState = ProjectBuilder.State.FindAssetCompositeState(asset.Id);
			if (compositeState == null)
			{
				compositeState = ProjectBuilder.State.CreateAssetCompositeState(asset.Id);
			}
			nixelContext.TiledRasterData.ClearAssetRectangles();
			nixelContext.TiledRasterData.ClearCubemapBorderRegions();
			nixelContext.TiledRasterData.ClearUserSetRectangles();
			TileSetConfig tileSetConfig = null;
			List<CompositedAsset> list = new List<CompositedAsset>();
			List<Asset> list2 = new List<Asset>();
			foreach (PackedAsset packedAsset in compositeState.PackedAssets)
			{
				Asset asset2 = activeProject.Assets[packedAsset.AssetId];
				if (asset2 == null)
				{
					throw new AssetNotPackedException(asset.Name);
				}
				ImportAssetData(asset2, out var compositedAsset);
				list.Add(compositedAsset);
				tileSetConfig = CurrentAsset.TileSetConfig;
				list2.Add(asset2);
			}
			compositeState.CompositedList.Clear();
			compositeState.Assets.Clear();
			compositeState.CompositedList.AddRange(list);
			compositeState.TileSetConfig = tileSetConfig;
			foreach (Asset item in list2)
			{
				compositeState.Assets.Add(item.Id, item);
			}
			using (MipMapProgressTracker buildProgressTracker = new MipMapProgressTracker(ProjectBuilder))
			{
				nixelContext.TiledRasterData.SetBuildProgressTracker(buildProgressTracker);
				if (nixelContext.TiledRasterData.AutoGenerateLevels() != 0)
				{
					ITileFileFactory.GetLastError(out var errorInfo);
					ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.Compositor, new ComposeCacheWriteIssue(asset.Name, errorInfo));
					throw new FatalException();
				}
				if (!ProjectBuilder.Canceled)
				{
					foreach (CompositedAsset composited in compositeState.CompositedList)
					{
						Asset asset3 = activeProject.Assets[composited.AssetId];
						UpdateThumbnails(asset3, nixelContext);
					}
					if (nixelContext.TiledRasterData.MakePersistent() != 0)
					{
						ITileFileFactory.GetLastError(out var errorInfo2);
						ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.Compositor, new ComposeCacheSaveIssue(asset.Name, errorInfo2));
						throw new FatalException();
					}
				}
			}
			if (!ProjectBuilder.Canceled)
			{
				compositeState.CompositorSummary = new CompositorSummary();
				compositeState.CompositorSummary.LastChangedDate = DateTimeManagement.Now();
				compositeState.LayerConfig = activeProject.LayerConfiguration;
			}
		}

		public Rectangle GetAssetLevelRange(CompositedAsset casset, int level)
		{
			double num = (int)Math.Pow(2.0, level);
			int x = (int)Math.Floor((double)casset.X / num);
			int y = (int)Math.Floor((double)casset.Y / num);
			int width = (int)Math.Ceiling((double)casset.Width / num);
			int height = (int)Math.Ceiling((double)casset.Height / num);
			return new Rectangle(x, y, width, height);
		}

		public Rectangle GetAssetLevelRange(PackedAsset passet, int level)
		{
			double num = (int)Math.Pow(2.0, level);
			int x = (int)Math.Floor((double)passet.X / num);
			int y = (int)Math.Floor((double)passet.Y / num);
			int width = (int)Math.Ceiling((double)passet.Width / num);
			int height = (int)Math.Ceiling((double)passet.Height / num);
			return new Rectangle(x, y, width, height);
		}

		private void WriteEmptyData(NixelContext context, PackedAsset passet, int layer)
		{
			for (uint num = 0u; num < context.TiledTopology.numLevels; num++)
			{
				Rectangle assetLevelRange = GetAssetLevelRange(passet, (int)num);
				uint left = (uint)assetLevelRange.Left;
				uint top = (uint)assetLevelRange.Top;
				uint width = (uint)assetLevelRange.Width;
				uint height = (uint)assetLevelRange.Height;
				context.TiledRasterData.RemoveTileRectangle(left, top, width, height, num, (uint)layer);
			}
			for (uint num2 = 1u; num2 < context.TiledTopology.numLevels; num2++)
			{
				Rectangle tileLevelRange = ProjectBuilder.State.GetTileLevelRange(passet, (int)num2);
				if (tileLevelRange.IsEmpty)
				{
					continue;
				}
				for (uint num3 = (uint)tileLevelRange.Top; num3 < tileLevelRange.Bottom; num3++)
				{
					for (uint num4 = (uint)tileLevelRange.Left; num4 < tileLevelRange.Right; num4++)
					{
						context.TiledRasterData.AutoGenerateTileLayer(new LayerTileId(num4, num3, num2, (uint)layer));
					}
				}
			}
		}

		private bool CheckState(out string error)
		{
			_ = ProjectBuilder.ActiveProject;
			error = null;
			if (ProjectBuilder.State.TileSetConfiguration == null)
			{
				error = "No tile layout information can be found, please rebuild the project";
				return false;
			}
			return true;
		}

		private void UpdateStateAsset(Asset asset)
		{
			Project activeProject = ProjectBuilder.ActiveProject;
			BuildState.CompositeState compositeState = ProjectBuilder.State.FindAssetCompositeState(asset.Id);
			if (compositeState != null)
			{
				compositeState.LayerConfig = activeProject.LayerConfiguration;
			}
			ProjectBuilder.State.Update(asset.Id, AssetChangeType.Data);
			ProjectBuilder.State.SaveCompositorState(ProjectBuilder, asset);
		}

		public static bool DeleteSerializedFiles(ProjectBuilder builder, List<Asset> assets)
		{
			bool result = true;
			foreach (Asset asset in assets)
			{
				string rasterFileName = NixelContextManager.GetRasterFileName(builder, asset);
				if (!NixelContextManager.DeleteSerializedFiles(builder, rasterFileName))
				{
					result = false;
				}
				string text = "";
				try
				{
					string rasterStateFilename = BuildState.GetRasterStateFilename(builder, asset);
					if (File.Exists(rasterStateFilename))
					{
						File.Delete(rasterStateFilename);
					}
				}
				catch (Exception ex)
				{
					string innerMessage = "Unable to delete a compositor temporary file '" + text + "due to the following error: " + ex.Message + ", make sure the folder isn't locked or being used by another process, then rebuild the project.";
					builder.BuildReportingHandler.OnFatalError(BuildProcess.Compositor, new GeneralIssue(innerMessage));
					result = false;
				}
			}
			return result;
		}

		private void SetAllBorderRegions(Asset asset, NixelContext context)
		{
			context.TiledRasterData.ClearAssetRectangles();
			context.TiledRasterData.ClearCubemapBorderRegions();
			context.TiledRasterData.ClearUserSetRectangles();
			CompositedAsset compositedAsset = ProjectBuilder.State.FindCompositedAsset(asset);
			if (compositedAsset == null)
			{
				return;
			}
			Rectangle tileLevelRange = ProjectBuilder.State.GetTileLevelRange(compositedAsset, 0);
			AssetTilingMethod mode = (AssetTools.TestTilingMethod(asset) ? asset.TilingMethod : AssetTilingMethod.None);
			BorderMode borderMode = NixelBorderModeFromTilingMethod(mode);
			context.TiledRasterData.RegisterAssetRectangle((uint)compositedAsset.X, (uint)compositedAsset.Y, (uint)compositedAsset.Width, (uint)compositedAsset.Height, CurrentAsset.AssetIndex, borderMode);
			if (asset.Type == AssetType.CubeMap)
			{
				uint cubeId = BitConverter.ToUInt32(BitConverter.GetBytes(asset.AssetGroupId.GetHashCode()), 0);
				context.TiledRasterData.SetCubemapBorderRegion((uint)tileLevelRange.X, (uint)tileLevelRange.Y, (uint)tileLevelRange.Width, (uint)tileLevelRange.Height, 0u, cubeId, asset.Face);
			}
			PackedAsset packedAsset = ProjectBuilder.State.FindPackedAsset(asset.Id);
			if (packedAsset == null)
			{
				return;
			}
			for (int i = 0; i < asset.AssetLayers.Count; i++)
			{
				Double2[] array = new Double2[4];
				Double2[] array2 = new Double2[4];
				for (int j = 0; j < 4; j++)
				{
					Size targetLayerSize = new Size(asset.Width, asset.Height);
					Size size = AssetTools.CalculateLayerSize(asset, i, j, useForcedSize: true);
					Size layerSize = AssetTools.CalculateLayerSize(asset, i, j, useForcedSize: false);
					array[j] = AssetTools.CalculateLayerResizeScale(targetLayerSize, size);
					array2[j] = AssetTools.CalculateLayerResizeScale(size, layerSize);
				}
				AssetTools.CalculateTextureRects(context.TiledRasterData.GetTopology(), asset, new Int2(packedAsset.X, packedAsset.Y), i, array, array2, ProjectBuilder.EnableAssetPlacementLevelOffset, out var _, out var importRects, out var _);
				foreach (AssetTools.TextureRect value in importRects.Values)
				{
					int borderSize = 0;
					MipRegion region = new MipRegion(value.GetRectangleWithBorders(borderSize), value.Region.Level);
					RegisterRegion(region, i);
				}
			}
		}

		private void RegisterRegion(MipRegion region, int layer)
		{
			CurrentAsset.NixelContext.TiledRasterData.RegisterUserSetRectangle((uint)region.X, (uint)region.Y, (uint)region.Width, (uint)region.Height, (uint)region.Level, (uint)layer);
		}

		private void FinishAssetLayerCompositing(int layer, List<MipRegion> touchedMipRegions)
		{
			foreach (MipRegion touchedMipRegion in touchedMipRegions)
			{
				RegisterRegion(touchedMipRegion, layer);
			}
		}

		private BorderMode NixelBorderModeFromTilingMethod(AssetTilingMethod mode)
		{
			return mode switch
			{
				AssetTilingMethod.Clamp => BorderMode.Clamp, 
				AssetTilingMethod.Repeat => BorderMode.Repeat, 
				AssetTilingMethod.None => BorderMode.Neighbor, 
				_ => BorderMode.Neighbor, 
			};
		}

		private void ImportAssetData(Asset asset, out CompositedAsset compositedAsset)
		{
			compositedAsset = new CompositedAsset();
			PackedAsset packedAsset = ProjectBuilder.State.FindPackedAsset(asset.Id);
			if (packedAsset == null)
			{
				throw new AssetNotPackedException(asset.Name);
			}
			compositedAsset.AssetId = packedAsset.AssetId;
			compositedAsset.Width = packedAsset.Width;
			compositedAsset.Height = packedAsset.Height;
			compositedAsset.X = packedAsset.X;
			compositedAsset.Y = packedAsset.Y;
			compositedAsset.TilingMethod = asset.TilingMethod;
			compositedAsset.Layers = new List<CompositedAssetLayer>();
			for (int i = 0; i < asset.AssetLayers.Count; i++)
			{
				ImportAssetDataLayer(asset, packedAsset, i, out var compositedAssetLayer);
				compositedAsset.Layers.Add(compositedAssetLayer);
			}
			compositedAsset.CompositedDate = DateTimeManagement.Now();
			AssetTilingMethod mode = (AssetTools.TestTilingMethod(asset) ? asset.TilingMethod : AssetTilingMethod.None);
			BorderMode borderMode = NixelBorderModeFromTilingMethod(mode);
			Rectangle tileLevelRange = ProjectBuilder.State.GetTileLevelRange(compositedAsset, 0);
			CurrentAsset.NixelContext.TiledRasterData.RegisterAssetRectangle((uint)compositedAsset.X, (uint)compositedAsset.Y, (uint)compositedAsset.Width, (uint)compositedAsset.Height, CurrentAsset.AssetIndex, borderMode);
			if (asset.Type == AssetType.CubeMap)
			{
				uint cubeId = BitConverter.ToUInt32(BitConverter.GetBytes(asset.AssetGroupId.GetHashCode()), 0);
				CurrentAsset.NixelContext.TiledRasterData.SetCubemapBorderRegion((uint)tileLevelRange.X, (uint)tileLevelRange.Y, (uint)tileLevelRange.Width, (uint)tileLevelRange.Height, 0u, cubeId, asset.Face);
			}
		}

		private void ImportAssetDataLayer(Asset asset, PackedAsset passet, int layer, out CompositedAssetLayer compositedAssetLayer)
		{
			AssetLayer assetLayer = asset.AssetLayers[layer];
			compositedAssetLayer = new CompositedAssetLayer();
			compositedAssetLayer.Textures = new List<CompositedTexture>();
			if (assetLayer.Textures.Count == 0)
			{
				WriteEmptyData(CurrentAsset.NixelContext, passet, layer);
				return;
			}
			if (CurrentAsset.IncrementalBuild && !ProjectBuilder.State.ComposeLayerHasChanged(asset, layer))
			{
				CompositedAsset compositedAsset = ProjectBuilder.State.FindAssetCompositeState(asset.Id).CompositedList.Find((CompositedAsset x) => x.AssetId == asset.Id);
				if (compositedAsset != null)
				{
					compositedAssetLayer = compositedAsset.Layers[layer];
					ProjectBuilder.State.IncrementalStates[asset.Id].IdenticalLayers.Add(layer);
					return;
				}
			}
			Double2[] array = new Double2[4];
			Double2[] array2 = new Double2[4];
			for (int i = 0; i < 4; i++)
			{
				Size targetLayerSize = new Size(asset.Width, asset.Height);
				Size size = AssetTools.CalculateLayerSize(asset, layer, i, useForcedSize: true);
				Size layerSize = AssetTools.CalculateLayerSize(asset, layer, i, useForcedSize: false);
				array[i] = AssetTools.CalculateLayerResizeScale(targetLayerSize, size);
				array2[i] = AssetTools.CalculateLayerResizeScale(size, layerSize);
			}
			AssetTools.CalculateTextureRects(CurrentAsset.NixelContext.TiledRasterData.GetTopology(), asset, new Int2(passet.X, passet.Y), layer, array, array2, ProjectBuilder.EnableAssetPlacementLevelOffset, out var textureRects, out var importRects, out var _);
			List<MipRegion> list = new List<MipRegion>();
			for (int j = 0; j < assetLayer.Textures.Count(); j++)
			{
				Texture texture = assetLayer.Textures[j];
				AssetTools.TextureRect textureRect = textureRects[texture];
				AssetTools.TextureRect textureRect2 = importRects[texture];
				List<MipRegion> touchedRegions = new List<MipRegion>();
				Guid thumbnail = Guid.Empty;
				ImportTexture(CurrentAsset.NixelContext.TiledTopology, texture, textureRect2.Region, assetLayer, assetLayer.Swizzle[texture.SubIndex], assetLayer.InvertChannels[texture.SubIndex], asset.Type == AssetType.CubeMap, out var _, out touchedRegions, ref thumbnail, ProjectBuilder.GetProjectPath());
				compositedAssetLayer.Thumbnail = thumbnail;
				list.AddRange(touchedRegions);
				CompositedTexture item = new CompositedTexture(textureRect.GetRectangleWithBorders(0), DateTimeManagement.Now());
				compositedAssetLayer.Textures.Add(item);
			}
			FinishAssetLayerCompositing(layer, list);
		}

		private void ImportTexture(TiledTopology topology, Texture texture, MipRegion destination, AssetLayer assetLayer, string swizzle, string invert, bool isCube, out int levelsWritten, out List<MipRegion> touchedRegions, ref Guid thumbnail, string projectDir)
		{
			int layerIndex = assetLayer.LayerIndex;
			TextureMipSourceType textureMipSourceType = assetLayer.MipSourceType;
			AssetPackingMode packingMode = assetLayer.PackingMode;
			Flip flip = assetLayer.Flip;
			touchedRegions = new List<MipRegion>();
			ImageFactory.Create(out var image);
			DataType dataType = ProjectBuilder.ActiveProject.LayerConfiguration.Layers[layerIndex].DataType;
			int numChannels = DataTypeInfo.GetNumChannels(dataType);
			ChannelDataType channelDataType = DataTypeInfo.GetChannelDataType(dataType);
			if (ProjectBuilder.ProfilingEnabled)
			{
				ProjectBuilder.logger.LogConsole(texture.Source, Logger.Verbosity.Quiet);
			}
			string absolutePath = Paths.GetAbsolutePath(projectDir, texture.Source);
			Grim.Error error = image.Open(absolutePath);
			if (error != 0)
			{
				throw new GrimSevereException(error, absolutePath);
			}
			if (image.Resize(destination.Width, destination.Height) != 0)
			{
				throw new CompositorException($"Error resizing image {texture.Source}. Resized image could be too large.");
			}
			switch (flip)
			{
			case Flip.Both:
				image.FlipHorizontal();
				image.FlipVertical();
				break;
			case Flip.Vertical:
				image.FlipVertical();
				break;
			case Flip.Horizontal:
				image.FlipHorizontal();
				break;
			}
			Spec spec = image.GetSpec();
			string channelMask = ChannelMerging.GetChannelMask(dataType, packingMode, texture.SubIndex);
			Layout layout = GetLayout(ref spec, channelMask);
			layout.Swizzle(swizzle);
			IConverter imageConverter = null;
			bool flag = false;
			string text = invert;
			if (text == null)
			{
				text = "";
			}
			if (text.Length < numChannels)
			{
				for (int i = text.Length; i < numChannels; i++)
				{
					text += "0";
				}
			}
			int channelSize = DataTypeInfo.GetChannelSize(dataType);
			if (spec.GetChannelSize() != channelSize || spec.GetNumChannels() != numChannels || text.Contains('1'))
			{
				flag = true;
				string layout2 = layout.Get().Substring(0, numChannels);
				error = ImageFactory.CreateConverter(image, channelDataType, (uint)numChannels, layout2, text, ProjectBuilder.EnableAutoDepthConversion, out imageConverter);
				if (error != 0)
				{
					image.Close();
					throw new GrimSevereException(error, texture.Source);
				}
				layout.Init();
				layout.SetMask(channelMask);
			}
			int pixelSize = DataTypeInfo.GetPixelSize(dataType);
			IntPtr intPtr = Marshal.AllocHGlobal((int)(spec.GetWidth() * pixelSize));
			GetScanLineDelegate getScanLineDelegate = ((!flag) ? new GetScanLineDelegate(image.GetScanLine) : new GetScanLineDelegate(imageConverter.GetScanLine));
			if (textureMipSourceType == TextureMipSourceType.Default && isCube)
			{
				textureMipSourceType = TextureMipSourceType.File;
			}
			uint num = 1u;
			if (textureMipSourceType == TextureMipSourceType.File)
			{
				uint numLevels = spec.GetNumLevels();
				uint val = topology.numLevels - (uint)destination.Level;
				numLevels = Math.Min(numLevels, val);
				num = 0u;
				for (num = 0u; num < numLevels && destination.IsIntegralProjectionOnLevel((int)num); num++)
				{
				}
			}
			levelsWritten = 0;
			for (uint num2 = 0u; num2 < num; num2++)
			{
				int level = destination.Level + (int)num2;
				MipRegion item = destination.ProjectOnLevel(level);
				for (uint num3 = 0u; num3 < item.Height; num3++)
				{
					uint y = num3;
					Grim.Error error2 = getScanLineDelegate((uint)texture.Face, num2, y, intPtr);
					if (error2 != 0)
					{
						image.Close();
						throw new GrimSevereException(error2, texture.Source);
					}
					uint x = (uint)item.X;
					uint offsetY = (uint)item.Y + num3;
					if (CurrentAsset.NixelContext.TiledRasterData.SetLine(x, offsetY, (uint)item.Level, (uint)layerIndex, (uint)item.Width, intPtr, layout) != 0)
					{
						ITileFileFactory.GetLastError(out var errorInfo);
						ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.Compositor, new ComposeCacheWriteIssue(texture.Source, errorInfo));
						throw new FatalException();
					}
				}
				if (textureMipSourceType == TextureMipSourceType.File)
				{
					int num4 = (int)(spec.GetNumLevels() - num);
					if (num4 > 0)
					{
						if (thumbnail == Guid.Empty)
						{
							thumbnail = Guid.NewGuid();
						}
						uint num5 = num;
						IntPtr[] array = new IntPtr[num4];
						try
						{
							for (uint num6 = num5; num6 < spec.GetNumLevels(); num6++)
							{
								array[num6 - num5] = Marshal.AllocHGlobal((int)(spec.GetLevelWidth(num6) * spec.GetLevelHeight(num6) * pixelSize));
							}
							for (uint num7 = num5; num7 < spec.GetNumLevels(); num7++)
							{
								for (uint num8 = 0u; num8 < spec.GetLevelHeight(num7); num8++)
								{
									IntPtr data = IntPtr.Add(array[num7 - num5], (int)spec.GetLevelWidth(num7) * pixelSize * (int)num8);
									getScanLineDelegate((uint)texture.Face, num7, num8, data);
								}
								if (!Nixel.Tools.SwizzleDataChannels(dataType, spec.GetLevelWidth(num7) * spec.GetLevelHeight(num7), layout, array[num7 - num5]))
								{
									throw new Exception("SwizzleDataChannels failed");
								}
							}
							Nixel.Error error3 = CurrentAsset.NixelContext.TiledRasterData.RegisterThumbnail(new GraphineGuid(thumbnail), spec.GetLevelWidth(num5), spec.GetLevelHeight(num5), (uint)num4, dataType, dropFirst: false, array);
							if (error3 != 0)
							{
								throw new Exception("RegisterThumbnail failed: " + error3);
							}
						}
						finally
						{
							for (int j = 0; j < array.Length; j++)
							{
								if (array[j] != IntPtr.Zero)
								{
									Marshal.FreeHGlobal(array[j]);
								}
							}
						}
					}
				}
				touchedRegions.Add(item);
				levelsWritten++;
			}
			Marshal.FreeHGlobal(intPtr);
			image.Close();
		}

		private Layout GetLayout(ref Spec spec, string channelMask)
		{
			string channelNames = spec.GetChannelNames();
			string text = "";
			switch (spec.GetNumChannels())
			{
			case 3u:
				channelNames += "A";
				text = text + channelNames.IndexOf("R") + channelNames.IndexOf("G") + channelNames.IndexOf("B") + channelNames.IndexOf("A");
				break;
			case 4u:
				text = text + channelNames.IndexOf("R") + channelNames.IndexOf("G") + channelNames.IndexOf("B") + channelNames.IndexOf("A");
				break;
			default:
				text = "0123";
				break;
			}
			Layout result = default(Layout);
			result.Set(text, channelMask);
			return result;
		}

		private void UpdateThumbnails(Asset asset, NixelContext context)
		{
			if (asset.TilingMethod == AssetTilingMethod.None)
			{
				return;
			}
			CompositedAsset compositedAsset = ProjectBuilder.State.FindCompositedAsset(asset);
			MipRegion mipRegion = new MipRegion(compositedAsset.X, compositedAsset.Y, asset.Width, asset.Height, 0);
			int num = 0;
			for (num = 0; num < 100 && mipRegion.IsIntegralProjectionOnLevel(num + 1); num++)
			{
			}
			num = Math.Min(num, (int)(context.TiledRasterData.GetTopology().numLevels - 1));
			MipRegion mipRegion2 = mipRegion.ProjectOnLevel(num);
			if (!ExtraMath.IsPowerOfTwo(mipRegion2.Width) || !ExtraMath.IsPowerOfTwo(mipRegion2.Height))
			{
				return;
			}
			for (int i = 0; i < asset.AssetLayers.Count; i++)
			{
				AssetLayer assetLayer = asset.AssetLayers[i];
				if (assetLayer.MipSourceType == TextureMipSourceType.File)
				{
					continue;
				}
				if (compositedAsset.Layers[i].Thumbnail == Guid.Empty)
				{
					compositedAsset.Layers[i].Thumbnail = Guid.NewGuid();
				}
				DataType dataType = ProjectBuilder.ActiveProject.LayerConfiguration.Layers[assetLayer.LayerIndex].DataType;
				IntPtr intPtr = Marshal.AllocHGlobal(mipRegion2.Width * mipRegion2.Height * DataTypeInfo.GetPixelSize(dataType));
				try
				{
					if (context.TiledRasterData.GetRectangle((uint)mipRegion2.X, (uint)mipRegion2.Y, (uint)mipRegion2.Level, (uint)assetLayer.LayerIndex, (uint)mipRegion2.Width, (uint)mipRegion2.Height, intPtr) != 0)
					{
						throw new Exception("Error fetching thumbnail data from raster file: " + Nixel.Error.Ok);
					}
					IntPtr[] levelPointers = new IntPtr[1] { intPtr };
					if (context.TiledRasterData.RegisterThumbnail(compositedAsset.Layers[i].Thumbnail, (uint)mipRegion2.Width, (uint)mipRegion2.Height, 1u, dataType, dropFirst: true, levelPointers) != 0)
					{
						throw new Exception("Error registering thumbnail to raster data: " + Nixel.Error.Ok);
					}
				}
				finally
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
		}
	}
	internal class EnumTools
	{
		public static bool ParseEnum<T>(string value, out T result)
		{
			try
			{
				result = (T)System.Enum.Parse(typeof(T), value, ignoreCase: true);
				return true;
			}
			catch (Exception)
			{
				result = default(T);
			}
			return false;
		}
	}
	public struct GrBuildLibInterfaceInfo
	{
		public NixelInitializationInfo nixelInfo;
	}
	public class GrBuildLibInterface
	{
		public static bool IsInitialized;

		private static GrBuildLibInterfaceInfo info;

		public static GrBuildLibInterfaceInfo InitializationInfo => info;

		public static void InitializeGrBuild()
		{
			if (IsInitialized)
			{
				return;
			}
			try
			{
				NixelTools.CheckDlls();
			}
			catch (InvalidDllException ex)
			{
				throw ex;
			}
			if (NixelInterface.InitializeNixel() != 0)
			{
				throw new UnspecifiedException("Unable to initialize Nixel library. Make sure Granite SDK is correctly installed, you have a valid license, and check the prerequisites in the documentation.", Error.Unknown);
			}
			info = default(GrBuildLibInterfaceInfo);
			info.nixelInfo = NixelInterface.InitializationInfo;
			if (!Constants.LightmapMode)
			{
				int value = info.nixelInfo.value2;
				if (value != 0 && value == 1000)
				{
					Constants.maxLicensedAtlasSize = new Int2(32768, 32768);
					Constants.fixedTileSize = new Int2(128, 128);
				}
			}
			IsInitialized = true;
		}

		public static void ReleaseGrBuild()
		{
			if (IsInitialized && NixelInterface.IsInitialized)
			{
				NixelInterface.ReleaseNixel();
			}
		}
	}
	internal class NixelContextManager : IDisposable
	{
		public static Nixel.BuildMode BuildMode { get; set; }

		public Dictionary<Guid, NixelContext> Contexts { get; private set; }

		public NixelContextManager()
		{
			Contexts = new Dictionary<Guid, NixelContext>();
		}

		public void SetContext(NixelContext context, Guid id)
		{
			Contexts.Add(id, context);
		}

		public NixelContext GetContext(Guid id)
		{
			if (!Contexts.ContainsKey(id))
			{
				return null;
			}
			return Contexts[id];
		}

		public void DestroyContext(Guid id)
		{
			NixelContext context = GetContext(id);
			if (context != null)
			{
				Contexts.Remove(id);
				DisposeContext(context);
			}
		}

		public void Destroy()
		{
			foreach (NixelContext value in Contexts.Values)
			{
				DisposeContext(value);
			}
			Contexts.Clear();
		}

		public static NixelContext CreateContext(ProjectBuilder projectBuilder, string filename, int packedWidth, int packedHeight, out TileSetConfig tileSetConfig)
		{
			NixelContext nixelContext = new NixelContext();
			tileSetConfig = CreateTileSetConfig(projectBuilder);
			RasterTileDimension dimensions = default(RasterTileDimension);
			CreateTiledTopology(projectBuilder, tileSetConfig.TileLayout, packedWidth, packedHeight, out dimensions);
			nixelContext.TileDimensions = dimensions;
			if (CreateRasterData(nixelContext, projectBuilder, filename) != 0)
			{
				DisposeContext(nixelContext);
				nixelContext = null;
				return null;
			}
			return nixelContext;
		}

		public static NixelContext LoadorCreateContext(ProjectBuilder projectBuilder, string filename, int packedWidth, int packedHeight, out TileSetConfig tileSetConfig, out RasterDataType newOrExisting)
		{
			NixelContext nixelContext = new NixelContext();
			tileSetConfig = CreateTileSetConfig(projectBuilder);
			RasterTileDimension dimensions = default(RasterTileDimension);
			nixelContext.TiledTopology = CreateTiledTopology(projectBuilder, tileSetConfig.TileLayout, packedWidth, packedHeight, out dimensions);
			nixelContext.TileDimensions = dimensions;
			newOrExisting = LoadRasterData(nixelContext, projectBuilder, filename);
			return nixelContext;
		}

		public static NixelContext LoadContext(ProjectBuilder projectBuilder, string filename, uint maximumAnisotropy, int packedWidth, int packedHeight)
		{
			NixelContext nixelContext = new NixelContext();
			TileSetConfig tileSetConfig = CreateTileSetConfig(projectBuilder);
			RasterTileDimension dimensions = default(RasterTileDimension);
			nixelContext.TiledTopology = CreateTiledTopology(projectBuilder, tileSetConfig.TileLayout, packedWidth, packedHeight, out dimensions);
			if (LoadRasterData(nixelContext, projectBuilder, filename) != RasterDataType.Existing)
			{
				DisposeContext(nixelContext);
				nixelContext = null;
				return null;
			}
			return nixelContext;
		}

		public static void CreateTiledBuildParameters(NixelContext context)
		{
			if (context.TiledBuildParameters == null)
			{
				ITiledBuildParameters tiledBuildParameters = null;
				ITileFileFactory.CreateTiledBuildParameters(context.TiledTopology, out tiledBuildParameters);
				context.TiledBuildParameters = tiledBuildParameters;
			}
		}

		public static void DisposeContext(NixelContext context)
		{
			if (context.TiledRasterData != null)
			{
				context.TiledRasterData.Dispose();
				context.TiledRasterData = null;
			}
			if (context.TiledBuildParameters != null)
			{
				context.TiledBuildParameters.Dispose();
				context.TiledBuildParameters = null;
			}
		}

		public static string GetRasterFileName(ProjectBuilder builder, Asset asset)
		{
			return Path.Combine(builder.StagingConfigurationDirectory, asset.NameIOFriendly + Constants.RasterDataCacheExtension);
		}

		public static string GetRasterFileName(ProjectBuilder builder, string asset)
		{
			return Path.Combine(builder.StagingConfigurationDirectory, asset + Constants.RasterDataCacheExtension);
		}

		public static string GetRasterFileIndexName(string cacheFilename)
		{
			string directoryName = Paths.GetDirectoryName(cacheFilename);
			string fileName = Path.GetFileName(cacheFilename);
			fileName = fileName.Substring(0, fileName.Length - Constants.RasterDataCacheExtension.Length);
			return Path.Combine(directoryName, fileName + Constants.RasterDataCacheIndexExtension);
		}

		public static void EnableUniformCoding(NixelContext context, int layer, bool enable)
		{
			context.TiledBuildParameters.EnableUniformCoding(layer, enable);
		}

		private static uint CalculateOptimalNixelCacheSize(TiledTopology topology, RasterTileDimension dimensions)
		{
			uint num = 0u;
			for (int i = 0; i < topology.dataType.Length; i++)
			{
				uint pixelSize = (uint)DataTypeInfo.GetPixelSize(topology.dataType[i]);
				uint num2 = (dimensions.width + dimensions.border) * (dimensions.height + dimensions.border);
				num += pixelSize * num2;
			}
			ulong num3 = num * topology.width * topology.height;
			if (num3 > Defaults.NixelMaximumCacheSize)
			{
				num3 = Defaults.NixelMaximumCacheSize;
			}
			if (num3 < Defaults.NixelMinimumCacheSize)
			{
				num3 = Defaults.NixelMinimumCacheSize;
			}
			uint num4 = 1048576u;
			num3 = (num3 + num4 - 1) / num4 * num4;
			return (uint)num3;
		}

		public static RasterDataType CreateRasterData(NixelContext context, ProjectBuilder builder, string filename)
		{
			if (File.Exists(filename))
			{
				File.Delete(filename);
			}
			uint maxCacheSizeInBytes = CalculateOptimalNixelCacheSize(context.TiledTopology, context.TileDimensions);
			if (ITileFileFactory.CreateTiledRasterData(context.TiledTopology, context.TileDimensions, maxCacheSizeInBytes, filename, out var tiledRasterData) != 0)
			{
				ITileFileFactory.GetLastError(out var errorInfo);
				builder.BuildReportingHandler.OnFatalError(BuildProcess.Compositor, new ComposeCacheWriteIssue(filename, errorInfo));
				throw new FatalException();
			}
			context.TiledRasterData = tiledRasterData;
			return RasterDataType.New;
		}

		public static RasterDataType LoadRasterData(NixelContext context, ProjectBuilder builder, string filename)
		{
			uint maxCacheSizeInBytes = CalculateOptimalNixelCacheSize(context.TiledTopology, context.TileDimensions);
			ITiledRasterData tiledRasterData;
			if (!File.Exists(filename))
			{
				if (ITileFileFactory.CreateTiledRasterData(context.TiledTopology, context.TileDimensions, maxCacheSizeInBytes, filename, out tiledRasterData) != 0)
				{
					ITileFileFactory.GetLastError(out var errorInfo);
					builder.BuildReportingHandler.OnFatalError(BuildProcess.Compositor, new ComposeCacheWriteIssue(filename, errorInfo));
					throw new FatalException();
				}
				context.TiledRasterData = tiledRasterData;
				return RasterDataType.New;
			}
			Nixel.Error error = ITileFileFactory.CreateTiledRasterData(context.TiledTopology, context.TileDimensions, maxCacheSizeInBytes, filename, out tiledRasterData);
			if (error == Nixel.Error.Ok)
			{
				context.TiledRasterData = tiledRasterData;
				return RasterDataType.Existing;
			}
			ITileFileFactory.GetLastError(out var errorInfo2);
			switch (error)
			{
			case Nixel.Error.IoBadPath:
			case Nixel.Error.IoFileNotFound:
			case Nixel.Error.IoDiskFull:
			case Nixel.Error.IoAccessDenied:
			case Nixel.Error.IoLocked:
			case Nixel.Error.IoUnknown:
				builder.BuildReportingHandler.OnFatalError(BuildProcess.Compositor, new ComposeCacheWriteIssue(filename, errorInfo2));
				throw new FatalException();
			case Nixel.Error.InvalidCacheFile:
			case Nixel.Error.InvalidRasterIndex:
			case Nixel.Error.MissingRasterIndex:
				if (!DeleteSerializedFiles(builder, filename))
				{
					throw new FatalException();
				}
				if (ITileFileFactory.CreateTiledRasterData(context.TiledTopology, context.TileDimensions, maxCacheSizeInBytes, filename, out tiledRasterData) != 0)
				{
					ITileFileFactory.GetLastError(out errorInfo2);
					builder.BuildReportingHandler.OnFatalError(BuildProcess.Compositor, new ComposeCacheWriteIssue(filename, errorInfo2));
					throw new FatalException();
				}
				context.TiledRasterData = tiledRasterData;
				return RasterDataType.New;
			default:
				builder.BuildReportingHandler.OnFatalError(BuildProcess.Compositor, new ComposeCacheWriteIssue(filename, errorInfo2));
				throw new FatalException();
			}
		}

		public static bool DeleteSerializedFiles(ProjectBuilder builder, string filename)
		{
			string text = "";
			try
			{
				string rasterFileIndexName = GetRasterFileIndexName(filename);
				if (File.Exists(filename))
				{
					File.Delete(filename);
				}
				if (File.Exists(rasterFileIndexName))
				{
					File.Delete(rasterFileIndexName);
				}
			}
			catch (Exception ex)
			{
				string innerMessage = "Unable to delete a compositor temporary file '" + text + "due to the following error: " + ex.Message + ", make sure the folder isn't locked or being used by another process, then rebuild the project.";
				builder.BuildReportingHandler.OnFatalError(BuildProcess.Compositor, new GeneralIssue(innerMessage));
				return false;
			}
			return true;
		}

		public static TileSetConfig CreateTileSetConfig(ProjectBuilder builder)
		{
			Project activeProject = builder.ActiveProject;
			TileSetConfig tileSetConfig = new TileSetConfig();
			TileLayout tileLayout = default(TileLayout);
			uint tileSize = Defaults.TileSize;
			tileLayout.borderSize = activeProject.BuildConfiguration.MaximumAnisotropy;
			tileLayout.tileWidth = tileSize;
			tileLayout.tileHeight = tileSize;
			if ((tileLayout.tileWidth + 2 * tileLayout.borderSize) % 16u != 0)
			{
				tileLayout.tileWidth += 16 - (tileLayout.tileWidth + 2 * tileLayout.borderSize) % 16u;
			}
			if ((tileLayout.tileHeight + 2 * tileLayout.borderSize) % 16u != 0)
			{
				tileLayout.tileHeight += 16 - (tileLayout.tileHeight + 2 * tileLayout.borderSize) % 16u;
			}
			bool flag = Constants.FixedTileSize.Y > 0;
			bool flag2 = false;
			if (activeProject.BuildConfiguration.TileHeight != 0 || flag)
			{
				if (flag)
				{
					tileLayout.tileHeight = (uint)Constants.FixedTileSize.Y;
					if (Constants.FixedTileSize.Y != (int)activeProject.BuildConfiguration.TileHeight && activeProject.BuildConfiguration.TileHeight != 0)
					{
						flag2 = true;
					}
				}
				else
				{
					tileLayout.tileHeight = activeProject.BuildConfiguration.TileHeight;
				}
				tileSetConfig.TileLayout = tileLayout;
			}
			bool flag3 = Constants.FixedTileSize.X > 0;
			if (activeProject.BuildConfiguration.TileWidth != 0 || flag3)
			{
				if (flag3)
				{
					tileLayout.tileWidth = (uint)Constants.FixedTileSize.X;
					if (Constants.FixedTileSize.X != (int)activeProject.BuildConfiguration.TileWidth && activeProject.BuildConfiguration.TileWidth != 0)
					{
						flag2 = true;
					}
				}
				else
				{
					tileLayout.tileWidth = activeProject.BuildConfiguration.TileWidth;
				}
				tileSetConfig.TileLayout = tileLayout;
			}
			if (flag2)
			{
				string message = $"Custom tile size could not be set ({activeProject.BuildConfiguration.TileWidth}x{activeProject.BuildConfiguration.TileHeight}). The license on this machine enforces a tile size of {Constants.FixedTileSize.X}x{Constants.FixedTileSize.Y}. Please upgrade your license if you require a different tile size.";
				builder.logger.LogConsole(message, Logger.Verbosity.Quiet);
			}
			tileSetConfig.TileLayout = tileLayout;
			tileSetConfig.LastChangedDate = DateTimeManagement.Now();
			return tileSetConfig;
		}

		public static TiledTopology CreateTiledTopology(ProjectBuilder builder, TileLayout tileLayout, int width, int height, out RasterTileDimension dimensions)
		{
			Project activeProject = builder.ActiveProject;
			uint count = (uint)activeProject.LayerConfiguration.Layers.Count;
			dimensions = default(RasterTileDimension);
			dimensions.border = tileLayout.borderSize;
			dimensions.width = tileLayout.tileWidth;
			dimensions.height = tileLayout.tileHeight;
			uint num = 1u;
			uint num2 = 1u;
			while (num * dimensions.width < width)
			{
				num *= 2;
			}
			while (num2 * dimensions.height < height)
			{
				num2 *= 2;
			}
			TiledTopology result = new TiledTopology(num, num2, count);
			for (int i = 0; i < activeProject.LayerConfiguration.Layers.Count; i++)
			{
				LayerDescription layerDescription = activeProject.LayerConfiguration.Layers[i];
				result.dataType[i] = layerDescription.DataType;
				Nixel.Color color;
				try
				{
					color = AssetTools.ParseNixelColor(layerDescription.DefaultColor, layerDescription.DataType);
				}
				catch
				{
					BuildIssue buildIssue = new TileFilePreprocessorIssue($"DefaultColor '{layerDescription.DefaultColor}' in the layer config could not be parsed. Check value format in XML import script. Using default value for default layer color.");
					builder.BuildReportingHandler.OnWarning(BuildProcess.General, buildIssue);
					color = default(Nixel.Color);
					Nixel.Tools.GetDefaultColorForLayerType(layerDescription.DataType, ref color);
				}
				result.defaultLayerColors[i] = color;
			}
			return result;
		}

		public void Dispose()
		{
			Destroy();
		}
	}
	internal class TileConfig
	{
		public int TileWidth { get; set; }

		public int TileHeight { get; set; }

		public int BorderSize { get; set; }
	}
	internal class CompatibilityHelpers
	{
		public static bool Compatible(RasterTileDimension dim1, RasterTileDimension dim2)
		{
			if (dim1.border == dim2.border && dim1.height == dim2.height)
			{
				return dim1.width == dim2.width;
			}
			return false;
		}

		public static bool Compatible(TiledTopology top1, TiledTopology top2)
		{
			if (top1.numLayers != top2.numLayers)
			{
				return false;
			}
			bool flag = true;
			for (int i = 0; i < top1.dataType.Length; i++)
			{
				flag = flag && top1.dataType[i] == top2.dataType[i];
			}
			return flag;
		}
	}
	internal class SoupFileInfo
	{
		public string TileSetName { get; set; }

		public SoupFileDescriptor SoupFileDescriptor { get; set; }

		public RasterTileDimension TileDim { get; set; }

		public TiledTopology Topology { get; set; }

		public BuildState.SoupState SoupState { get; set; }

		public bool IsCompatible(SoupFileInfo info)
		{
			if (true && ((string.IsNullOrEmpty(TileSetName) && string.IsNullOrEmpty(info.TileSetName)) || TileSetName.Equals(info.TileSetName)) && CompatibilityHelpers.Compatible(TileDim, info.TileDim))
			{
				return CompatibilityHelpers.Compatible(Topology, info.Topology);
			}
			return false;
		}
	}
	internal class PackedSoupFileInfo
	{
		public int X { get; set; }

		public int Y { get; set; }

		public int Width { get; set; }

		public int Height { get; set; }

		public SoupFileInfo SoupFileInfo { get; set; }
	}
	internal class SoupCollectionInfo
	{
		public List<SoupFileInfo> SoupFileInfos { get; private set; }

		public string TileSetName { get; private set; }

		public RasterTileDimension TileDim { get; private set; }

		public TiledTopology Topology { get; private set; }

		public bool Collect(ProjectBuilder projectBuilder, List<SoupFileDescriptor> soupFiles)
		{
			SoupFileInfos = new List<SoupFileInfo>();
			SoupFileInfo soupFileInfo = null;
			for (int i = 0; i < soupFiles.Count; i++)
			{
				SoupFileDescriptor soupFileDescriptor = soupFiles[i];
				SoupFileInfo soupFileInfo2 = new SoupFileInfo();
				soupFileInfo2.SoupFileDescriptor = soupFileDescriptor;
				if (i == 0)
				{
					soupFileInfo = soupFileInfo2;
				}
				if (ITileFileFactory.CreateTileSoupFileReader(soupFileDescriptor.SoupFilename, out var soupFileReader) != 0)
				{
					ITileFileFactory.GetLastError(out var errorInfo);
					string buildErrorMessage = Errors.GetBuildErrorMessage(errorInfo);
					projectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileSetBuilder, new TileSetBuilderIssue(buildErrorMessage));
					return false;
				}
				RasterTileDimension dimensions = default(RasterTileDimension);
				soupFileReader.GetTileDimensions(ref dimensions);
				soupFileInfo2.TileDim = dimensions;
				TiledTopology topology = default(TiledTopology);
				soupFileReader.GetTiledTopology(ref topology);
				soupFileInfo2.Topology = topology;
				try
				{
					SoupTools.ReadSoupBuildState(soupFileDescriptor.SoupFilename, out var soupState);
					if (projectBuilder.AllowForeignGTex)
					{
						BuildState.TranslateSoupStateToThisProject(projectBuilder, soupState);
					}
					soupFileInfo2.SoupState = soupState;
				}
				catch (IOException ex)
				{
					string text = "Failed to read soup file " + soupFileDescriptor.SoupFilename;
					text = string.Concat(text, " IOException at: ", ex.TargetSite, "\n-> ", ex.Message);
					projectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileSetBuilder, new TileSetBuilderIssue(text));
					return false;
				}
				catch (NixelException ex2)
				{
					string text2 = "Failed to read soup file " + soupFileDescriptor.SoupFilename;
					text2 = string.Concat(text2, " NixelException at: ", ex2.TargetSite, "\n-> ", ex2.Message);
					projectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileSetBuilder, new TileSetBuilderIssue(text2));
					return false;
				}
				catch (GrXmlException ex3)
				{
					string text3 = "Failed to read soup file " + soupFileDescriptor.SoupFilename;
					text3 = string.Concat(text3, " GrXmlException at: ", ex3.TargetSite, "\n-> ", ex3.Message);
					projectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileSetBuilder, new TileSetBuilderIssue(text3));
					return false;
				}
				catch (Exception ex4)
				{
					throw ex4;
				}
				if (soupFileInfo.IsCompatible(soupFileInfo2))
				{
					SoupFileInfos.Add(soupFileInfo2);
				}
				soupFileReader.Dispose();
			}
			if (soupFileInfo != null)
			{
				TileDim = soupFileInfo.TileDim;
				Topology = soupFileInfo.Topology;
				TileSetName = soupFileInfo.TileSetName;
			}
			return true;
		}

		public byte[] BuildMetadata(ProjectBuilder projectBuilder, List<PackedSoupFileInfo> packedSoupInfos)
		{
			return Metadata.CreateMetaData(projectBuilder, packedSoupInfos);
		}
	}
	internal class SoupFileAtlasser
	{
		public static bool Atlas(Int2 tileSize, IEnumerable<SoupFileInfo> rects, out List<PackedSoupFileInfo> packedAssets, out Int2 packedSize)
		{
			packedAssets = new List<PackedSoupFileInfo>();
			AtlasConfiguration atlasConfiguration = new AtlasConfiguration();
			atlasConfiguration.AllowRotations = false;
			List<Atlasser.AtlasItem> list = new List<Atlasser.AtlasItem>();
			foreach (SoupFileInfo rect in rects)
			{
				int width = tileSize.X * (int)rect.Topology.width;
				int height = tileSize.Y * (int)rect.Topology.height;
				Atlasser.AtlasItem item = new Atlasser.AtlasItem(rect, width, height, power2Alignment: true);
				list.Add(item);
			}
			List<Atlasser.AtlassedItem> packedAssets2;
			bool flag = new Atlasser(atlasConfiguration, tileSize).Atlas(new List<Atlasser.AtlassedItem>(), list, out packedAssets2, out packedSize);
			if (!flag)
			{
				return false;
			}
			foreach (Atlasser.AtlassedItem item2 in packedAssets2)
			{
				PackedSoupFileInfo packedSoupFileInfo = new PackedSoupFileInfo();
				packedSoupFileInfo.X = item2.X;
				packedSoupFileInfo.Y = item2.Y;
				packedSoupFileInfo.Width = item2.Width;
				packedSoupFileInfo.Height = item2.Height;
				packedSoupFileInfo.SoupFileInfo = (SoupFileInfo)item2.Tag;
				packedAssets.Add(packedSoupFileInfo);
			}
			return flag;
		}
	}
	internal class SoupTools
	{
		public static BuildState.SoupState ReadSoupStateAndRegisterWithBuildState(ProjectBuilder builder, string soupFilename, BuildState state)
		{
			ReadSoupBuildState(soupFilename, out var soupState);
			if (builder.AllowForeignGTex)
			{
				BuildState.TranslateSoupStateToThisProject(builder, soupState);
			}
			state.SoupStates[soupState.AssetId] = soupState;
			return soupState;
		}

		public static void ReadSoupBuildState(string soupFilename, out BuildState.SoupState soupState)
		{
			if (!File.Exists(soupFilename))
			{
				throw new NixelException(Nixel.Error.IoFileNotFound, soupFilename);
			}
			ITileSoupFileReader soupFileReader;
			Nixel.Error error = ITileFileFactory.CreateTileSoupFileReader(soupFilename, out soupFileReader);
			if (error != 0)
			{
				throw new NixelException(error, soupFilename);
			}
			byte[] metaDataBuffer = Metadata.GetMetaDataBuffer(soupFileReader.GetMetaData(), soupFileReader.GetMetaDataLength());
			soupFileReader.Dispose();
			XMLEngine.ReadSoupState(((StructDataItem)DataItem.Read(new MemoryStream(metaDataBuffer)))["STAT"].ValueString, out soupState);
		}

		public static bool IsSoupFileBuiltForThisProject(ProjectBuilder builder, Asset asset, string filepath, out bool isValidSoupFile)
		{
			isValidSoupFile = true;
			try
			{
				BuildState.SoupState soupState = builder.State.FindAssetSoupState(asset.Id);
				if (soupState == null)
				{
					ReadSoupBuildState(filepath, out soupState);
					if (soupState == null)
					{
						isValidSoupFile = false;
						return false;
					}
				}
				if (soupState.ProjectId != builder.ActiveProject.Id)
				{
					return false;
				}
				return true;
			}
			catch
			{
				isValidSoupFile = false;
				return false;
			}
		}
	}
	public static class FileTools
	{
		public static bool FileHasChanged(DateTime oldWriteTime, string filename, out DateTime newWriteTime)
		{
			newWriteTime = DateTimeManagement.Round(File.GetLastWriteTime(filename));
			try
			{
				return new TimeSpan(Math.Abs(newWriteTime.Ticks - oldWriteTime.Ticks)).TotalMilliseconds >= 1.0;
			}
			catch
			{
				return true;
			}
		}

		public static bool FileCanReadWrite(string filename)
		{
			try
			{
				using (new FileStream(filename, FileMode.Open, FileAccess.ReadWrite))
				{
					return true;
				}
			}
			catch
			{
				return false;
			}
		}

		public static bool MoveFile(string source, string destination)
		{
			if (File.Exists(destination))
			{
				try
				{
					File.Delete(destination);
				}
				catch (Exception)
				{
					return false;
				}
			}
			try
			{
				File.Move(source, destination);
			}
			catch (Exception)
			{
				return false;
			}
			return true;
		}
	}
	public class FileLock
	{
		private FileStream lockFileStream;

		private string filename;

		public bool Locked => lockFileStream != null;

		public FileLock(string filename)
		{
			this.filename = filename;
		}

		public bool Lock()
		{
			if (lockFileStream != null)
			{
				return true;
			}
			try
			{
				lockFileStream = new FileStream(filename, FileMode.Create);
			}
			catch
			{
				return false;
			}
			return true;
		}

		public void Unlock()
		{
			if (lockFileStream != null)
			{
				lockFileStream.Close();
				lockFileStream = null;
				try
				{
					File.Delete(filename);
				}
				catch
				{
				}
			}
		}
	}
	public static class GTSBuilderTools
	{
		private class TempGTPV2FileReader
		{
			public static bool GetGTPFiles(BinaryReader reader, out List<string> gtpFilenames)
			{
				gtpFilenames = new List<string>();
				reader.BaseStream.Seek(68L, SeekOrigin.Begin);
				uint num = reader.ReadUInt32();
				uint num2 = reader.ReadUInt32();
				reader.BaseStream.Seek(num2, SeekOrigin.Begin);
				for (int i = 0; i < num; i++)
				{
					byte[] array = reader.ReadBytes(256);
					reader.ReadUInt32();
					reader.ReadUInt32();
					gtpFilenames.Add(NixelTools.ReadWCharUnicodeString(array));
				}
				return true;
			}
		}

		public static void MoveGTS(string srcFilename, string dstFilename, bool patch)
		{
			string directoryName = Paths.GetDirectoryName(srcFilename);
			string directoryName2 = Paths.GetDirectoryName(dstFilename);
			if (!IsDirectoryWritable(directoryName2))
			{
				throw new GtsMoveException("Output directory \"" + directoryName2 + "\" not writable");
			}
			if (!GetGTPInfos(srcFilename, out var srcPageFiles))
			{
				throw new GtsMoveException("Unreadable GTS file \"" + srcFilename + "\"");
			}
			List<string> srcPageFilesFilenames = new List<string>();
			foreach (PageFileInfo item in srcPageFiles)
			{
				srcPageFilesFilenames.Add(item.name);
			}
			List<PageFileInfo> gtpFileInfos = new List<PageFileInfo>();
			TileFileType type = TileFileType.GTS_WITH_GTP;
			if (File.Exists(dstFilename))
			{
				GetGTPInfos(dstFilename, out gtpFileInfos, out type);
			}
			List<PageFileInfo> list = null;
			list = ((type != TileFileType.GTS_WITH_GTEX) ? gtpFileInfos.FindAll((PageFileInfo x) => !srcPageFilesFilenames.Contains(x.name)) : new List<PageFileInfo>());
			if (!IsFileWritable(srcFilename))
			{
				throw new GtsMoveException("Invalid access rights on \"" + srcFilename + "\"");
			}
			for (int j = 0; j < srcPageFiles.Count; j++)
			{
				string text = Path.Combine(directoryName, srcPageFiles[j].name);
				if (File.Exists(text) && !IsFileWritable(text))
				{
					throw new GtsMoveException("Invalid access rights on \"" + text + "\"");
				}
				string text2 = Path.Combine(directoryName2, srcPageFiles[j].name);
				if (File.Exists(text2) && !IsFileWritable(text2))
				{
					throw new GtsMoveException("Invalid access rights on \"" + text2 + "\"");
				}
			}
			if (File.Exists(dstFilename) && !IsFileWritable(dstFilename))
			{
				throw new GtsMoveException("Invalid access rights on \"" + dstFilename + "\"");
			}
			for (int k = 0; k < list.Count; k++)
			{
				string text3 = Path.Combine(directoryName2, list[k].name);
				if (File.Exists(text3) && !IsFileWritable(text3))
				{
					throw new GtsMoveException("Invalid access rights on \"" + dstFilename + "\"");
				}
			}
			try
			{
				int i;
				for (i = 0; i < srcPageFiles.Count; i++)
				{
					bool flag = true;
					if (patch)
					{
						List<PageFileInfo> list2 = gtpFileInfos.FindAll((PageFileInfo x) => x.name.Equals(srcPageFiles[i].name, StringComparison.InvariantCultureIgnoreCase));
						if (list2.Count == 1 && list2[0].loaded)
						{
							bool num = list2[0].checksumHeader0 == srcPageFiles[i].checksumHeader0 && list2[0].checksumHeader1 == srcPageFiles[i].checksumHeader1 && list2[0].checksumHeader2 == srcPageFiles[i].checksumHeader2 && list2[0].checksumHeader3 == srcPageFiles[i].checksumHeader3;
							bool flag2 = list2[0].checksumFile0 == srcPageFiles[i].checksumHeader0 && list2[0].checksumFile1 == srcPageFiles[i].checksumHeader1 && list2[0].checksumFile2 == srcPageFiles[i].checksumHeader2 && list2[0].checksumFile3 == srcPageFiles[i].checksumHeader3;
							if (num && flag2)
							{
								flag = false;
							}
						}
					}
					string text4 = Path.Combine(directoryName, srcPageFiles[i].name);
					string text5 = Path.Combine(directoryName2, srcPageFiles[i].name);
					if (!(text4 != text5))
					{
						continue;
					}
					if (flag)
					{
						if (File.Exists(text4))
						{
							if (File.Exists(text5))
							{
								File.Delete(text5);
							}
							File.Move(text4, text5);
						}
					}
					else if (File.Exists(text4))
					{
						File.Delete(text4);
					}
				}
				for (int l = 0; l < list.Count; l++)
				{
					string path = Path.Combine(directoryName2, list[l].name);
					if (File.Exists(path))
					{
						File.Delete(path);
					}
				}
				if (File.Exists(dstFilename))
				{
					File.Delete(dstFilename);
				}
				File.Move(srcFilename, dstFilename);
			}
			catch (Exception ex)
			{
				List<PageFileInfo> list3 = srcPageFiles.Union(gtpFileInfos).ToList();
				for (int m = 0; m < list3.Count; m++)
				{
					string path2 = Path.Combine(directoryName2, list3[m].name);
					if (File.Exists(path2))
					{
						try
						{
							File.Delete(path2);
						}
						catch
						{
						}
					}
				}
				if (File.Exists(dstFilename))
				{
					try
					{
						File.Delete(dstFilename);
					}
					catch
					{
					}
				}
				throw new GtsMoveException("A serious error occurred while moving the GTS and GTP files to the output directory, detail: \"" + ex.Message + "\", deletion attempted to prevent invalid output");
			}
		}

		public static bool GetGTPFiles(string gtsFilename, out List<string> gtpFilenames)
		{
			TileFileType gtsType;
			return GetGTPFiles(gtsFilename, out gtpFilenames, out gtsType);
		}

		public static bool GetGTPFiles(string gtsFilename, out List<string> gtpFilenames, out TileFileType gtsType)
		{
			gtsType = TileFileType.GTS_WITH_GTP;
			gtpFilenames = new List<string>();
			BinaryReader binaryReader = null;
			try
			{
				binaryReader = new BinaryReader(new FileStream(gtsFilename, FileMode.Open));
				if (binaryReader.ReadUInt32() != 1196446279)
				{
					return false;
				}
				if (binaryReader.ReadUInt32() == 2)
				{
					return TempGTPV2FileReader.GetGTPFiles(binaryReader, out gtpFilenames);
				}
				binaryReader.Close();
			}
			catch (Exception)
			{
				return false;
			}
			finally
			{
				binaryReader?.Close();
			}
			if (ITileFileFactory.CreateGtsFileReader(gtsFilename, null, 33554432u, out var gtsFileReader) != 0)
			{
				return false;
			}
			if (gtsFileReader.GetGtsInfo(out var arg) != 0)
			{
				gtsFileReader.Dispose();
				return false;
			}
			gtsType = arg.type;
			for (uint num = 0u; num < arg.numPageFiles; num++)
			{
				if (gtsFileReader.GetPageFileInfo(num, out var pageFileInfo) != 0)
				{
					gtsFileReader.Dispose();
					return false;
				}
				gtpFilenames.Add(pageFileInfo.name);
			}
			gtsFileReader.Dispose();
			return true;
		}

		public static bool GetGTPInfos(string gtsFilename, out List<PageFileInfo> gtpFileInfos)
		{
			TileFileType type;
			return GetGTPInfos(gtsFilename, out gtpFileInfos, out type);
		}

		public static bool GetGTPInfos(string gtsFilename, out List<PageFileInfo> gtpFileInfos, out TileFileType type)
		{
			type = TileFileType.GTS_WITH_GTP;
			gtpFileInfos = new List<PageFileInfo>();
			BinaryReader binaryReader = null;
			try
			{
				binaryReader = new BinaryReader(new FileStream(gtsFilename, FileMode.Open));
				if (binaryReader.ReadUInt32() != 1196446279)
				{
					return false;
				}
				if (binaryReader.ReadUInt32() == 2)
				{
					return false;
				}
				binaryReader.Close();
			}
			catch (Exception)
			{
				return false;
			}
			finally
			{
				binaryReader?.Close();
			}
			if (ITileFileFactory.CreateGtsFileReader(gtsFilename, null, 33554432u, out var gtsFileReader) != 0)
			{
				return false;
			}
			if (gtsFileReader.GetGtsInfo(out var arg) != 0)
			{
				gtsFileReader.Dispose();
				return false;
			}
			type = arg.type;
			for (uint num = 0u; num < arg.numPageFiles; num++)
			{
				if (gtsFileReader.GetPageFileInfo(num, out var pageFileInfo) != 0)
				{
					gtsFileReader.Dispose();
					return false;
				}
				gtpFileInfos.Add(pageFileInfo);
			}
			gtsFileReader.Dispose();
			return true;
		}

		public static Nixel.Error GetGtsInfo(string gtsFilename, out GtsInfo info)
		{
			info = default(GtsInfo);
			Nixel.Error error = ITileFileFactory.CreateGtsFileReader(gtsFilename, null, 33554432u, out var gtsFileReader);
			if (error != 0)
			{
				return error;
			}
			error = gtsFileReader.GetGtsInfo(out info);
			gtsFileReader.Dispose();
			return error;
		}

		public static bool IsFileWritable(string filePath)
		{
			FileStream fileStream = null;
			int num = 0;
			while (true)
			{
				try
				{
					fileStream = File.Open(filePath, FileMode.Open, FileAccess.ReadWrite);
				}
				catch (IOException)
				{
					num++;
					if (num > 3)
					{
						fileStream = null;
						break;
					}
					Thread.Sleep(1000);
					continue;
				}
				break;
			}
			bool result = false;
			if (fileStream != null)
			{
				result = true;
				fileStream.Close();
				fileStream.Dispose();
				fileStream = null;
			}
			return result;
		}

		public static bool IsDirectoryWritable(string dirPath)
		{
			try
			{
				FileStream fileStream = File.Create(Path.Combine(dirPath, Path.GetRandomFileName()), 1, FileOptions.DeleteOnClose);
				fileStream.Close();
				fileStream.Dispose();
				return true;
			}
			catch
			{
				return false;
			}
		}

		public static bool IsNixelIOError(Nixel.Error error)
		{
			switch (error)
			{
			case Nixel.Error.IoBadPath:
			case Nixel.Error.IoFileNotFound:
			case Nixel.Error.IoDiskFull:
			case Nixel.Error.IoAccessDenied:
			case Nixel.Error.IoLocked:
			case Nixel.Error.IoUnknown:
				return true;
			default:
				return false;
			}
		}
	}
	internal class PathHelper
	{
		public static string GetDirectoryName(string filename)
		{
			string directoryName = Path.GetDirectoryName(filename);
			if (directoryName == null)
			{
				return filename;
			}
			return directoryName;
		}
	}
	public class ImportTemplateInfo
	{
		public static readonly int MaxUDimVerticalPatches = 32;

		public TextureType Type { get; private set; }

		public bool Batch { get; private set; }

		public PatternScanner.TextureFileCollection FoundTextureFiles { get; private set; }

		public string DisplayString { get; private set; }

		public string SuggestedAssetName { get; private set; }

		public string BasePath { get; private set; }

		public string Filter { get; private set; }

		public string TemplateString => Path.Combine(BasePath, Filter);

		public string TemplateConstructorInput { get; set; }

		public int Width { get; private set; }

		public int Height { get; private set; }

		public static ImportTemplateInfo Empty => new ImportTemplateInfo
		{
			Type = TextureType.Empty,
			Batch = false,
			DisplayString = "Empty",
			SuggestedAssetName = "Empty",
			BasePath = string.Empty,
			Filter = string.Empty,
			Width = 0,
			Height = 0,
			TemplateConstructorInput = string.Empty
		};

		public static ImportTemplateInfo FileNotFoundTemplateInfo(string filename)
		{
			return new ImportTemplateInfo
			{
				Type = TextureType.Empty,
				Batch = false,
				DisplayString = filename,
				SuggestedAssetName = "",
				BasePath = PathHelper.GetDirectoryName(filename),
				Filter = Path.GetFileName(filename),
				Width = 0,
				Height = 0,
				TemplateConstructorInput = filename
			};
		}

		public ImportTemplateInfo()
		{
			FoundTextureFiles = new PatternScanner.TextureFileCollection();
			Type = TextureType.Unknown;
			SuggestedAssetName = string.Empty;
		}

		public static string CalculateSuggestedName(string filename)
		{
			string text = Path.GetFileNameWithoutExtension(filename);
			Match match = Regex.Match(text, "[-._ ]?(%u|%([0-9+]+)?[xy]|@[xy])[-._ ]?");
			while (match.Success)
			{
				text = text.Substring(0, match.Index) + "_" + text.Substring(match.Index + match.Length, text.Length - (match.Index + match.Length));
				match = Regex.Match(text, "[-._ ]?(%u|%([0-9+]+)?[xy]|@[xy])[-._ ]?");
			}
			if (Regex.Match(text, "[_]$").Success)
			{
				text = text.Substring(0, text.Length - 1);
			}
			return text;
		}

		private static bool IsValidTemplate(string filename)
		{
			try
			{
				if (filename == null)
				{
					return false;
				}
				if (filename.Length == 0)
				{
					return false;
				}
				if (filename.IndexOfAny(Path.GetInvalidPathChars()) >= 0)
				{
					return false;
				}
			}
			catch
			{
				return false;
			}
			return true;
		}

		private static void ScanDirectory(PatternScanner.TextureFileCollection collection, string templateBasePath, string templateFilter, int subIndex)
		{
			string text = Path.Combine(templateBasePath, templateFilter);
			string directoryName = PathHelper.GetDirectoryName(text);
			string fileName = Path.GetFileName(text);
			if (Directory.Exists(directoryName))
			{
				FileInfo[] files = new DirectoryInfo(directoryName).GetFiles(fileName);
				foreach (FileInfo fileInfo in files)
				{
					PatternScanner.TextureFile item = default(PatternScanner.TextureFile);
					item.Filename = fileInfo.FullName;
					item.SubIndex = subIndex;
					collection.TextureFiles.Add(item);
					collection.NumberOfTextures++;
				}
			}
		}

		private static void RecursivelyScanDirectory(PatternScanner.TextureFileCollection collection, string templateBasePath, string templateFilter, int subIndex)
		{
			if (!Directory.Exists(templateBasePath))
			{
				return;
			}
			string text = Path.Combine(templateBasePath, templateFilter);
			DirectoryInfo[] directories = new DirectoryInfo(templateBasePath).GetDirectories();
			foreach (DirectoryInfo directoryInfo in directories)
			{
				RecursivelyScanDirectory(collection, directoryInfo.FullName, templateFilter, subIndex);
			}
			string directoryName = PathHelper.GetDirectoryName(text);
			string fileName = Path.GetFileName(text);
			if (Directory.Exists(directoryName))
			{
				FileInfo[] files = new DirectoryInfo(directoryName).GetFiles(fileName);
				foreach (FileInfo fileInfo in files)
				{
					PatternScanner.TextureFile item = default(PatternScanner.TextureFile);
					item.Filename = fileInfo.FullName;
					item.SubIndex = subIndex;
					collection.TextureFiles.Add(item);
					collection.NumberOfTextures++;
				}
			}
		}

		public static ImportTemplateInfo ParseAndScan(string templateString, int subIndex = 0, bool scanRecursively = false)
		{
			string templateBasePath = string.Empty;
			string templateFilter = string.Empty;
			if (IsValidTemplate(templateString))
			{
				templateBasePath = PathHelper.GetDirectoryName(templateString);
				templateFilter = Path.GetFileName(templateString);
			}
			return ParseAndScan(templateBasePath, templateFilter, subIndex, scanRecursively);
		}

		public static ImportTemplateInfo ParseAndScan(string templateBasePath, string templateFilter, int subIndex = 0, bool scanRecursively = false)
		{
			string text = Path.Combine(templateBasePath, templateFilter);
			ImportTemplateInfo importTemplateInfo = new ImportTemplateInfo();
			if (!IsValidTemplate(text))
			{
				importTemplateInfo.Type = TextureType.Empty;
				importTemplateInfo.SuggestedAssetName = "Empty";
				importTemplateInfo.DisplayString = "Empty";
				importTemplateInfo.FoundTextureFiles = new PatternScanner.TextureFileCollection();
				importTemplateInfo.BasePath = templateBasePath;
				importTemplateInfo.Filter = templateFilter;
				importTemplateInfo.Width = 0;
				importTemplateInfo.Height = 0;
				return importTemplateInfo;
			}
			importTemplateInfo.BasePath = PathHelper.GetDirectoryName(text);
			importTemplateInfo.Type = TextureType.Unknown;
			importTemplateInfo.BasePath = templateBasePath;
			importTemplateInfo.Filter = templateFilter;
			importTemplateInfo.Filter = Path.GetFileName(text);
			importTemplateInfo.DisplayString = importTemplateInfo.Filter;
			importTemplateInfo.SuggestedAssetName = CalculateSuggestedName(text);
			importTemplateInfo.Width = 1;
			importTemplateInfo.Height = 1;
			PatternScanner.TextureFileCollection textureFiles = new PatternScanner.TextureFileCollection();
			if (!Regex.Match(text, "[*]").Success && PatternScanner.IsPatternUDim(text))
			{
				importTemplateInfo.Type = TextureType.UDim;
				PatternScanner.ScanUDimTemplate(text, out textureFiles, out var rows, out var cols, out var _);
				for (int i = 0; i < textureFiles.TextureFiles.Count; i++)
				{
					PatternScanner.TextureFile value = textureFiles.TextureFiles[i];
					value.SubIndex = subIndex;
					textureFiles.TextureFiles[i] = value;
				}
				importTemplateInfo.Width = cols;
				importTemplateInfo.Height = rows;
			}
			else if (PatternScanner.IsPattern(text) && !Regex.Match(text, "[*]").Success)
			{
				importTemplateInfo.Type = TextureType.Tiled;
				PatternScanner.ScanTiledTemplate(text, out textureFiles, out var rows2, out var columns);
				for (int j = 0; j < textureFiles.TextureFiles.Count; j++)
				{
					PatternScanner.TextureFile value2 = textureFiles.TextureFiles[j];
					value2.SubIndex = subIndex;
					textureFiles.TextureFiles[j] = value2;
				}
				importTemplateInfo.Width = columns;
				importTemplateInfo.Height = rows2;
			}
			if (importTemplateInfo.Type == TextureType.Unknown && Directory.Exists(PathHelper.GetDirectoryName(templateBasePath)))
			{
				if (Regex.Match(text, "^([^*]+)?[*]([^*]+)?$").Success)
				{
					if (scanRecursively)
					{
						RecursivelyScanDirectory(textureFiles, templateBasePath, templateFilter, subIndex);
					}
					else
					{
						ScanDirectory(textureFiles, templateBasePath, templateFilter, subIndex);
					}
					importTemplateInfo.Type = TextureType.Unknown;
					importTemplateInfo.Batch = true;
					importTemplateInfo.BasePath = templateBasePath;
					importTemplateInfo.Filter = templateFilter;
					importTemplateInfo.DisplayString = templateFilter;
				}
				else if (File.Exists(text))
				{
					importTemplateInfo.Type = TextureType.Single;
					PatternScanner.TextureFile item = default(PatternScanner.TextureFile);
					item.Filename = text;
					item.SubIndex = subIndex;
					textureFiles.TextureFiles.Add(item);
					textureFiles.NumberOfTextures++;
				}
			}
			importTemplateInfo.FoundTextureFiles = textureFiles;
			return importTemplateInfo;
		}
	}
	public class ImportTemplateConstructor
	{
		public struct TemplateMatch
		{
			public string Template { get; set; }

			public TextureType TextureType { get; set; }

			public uint FoundFileCount { get; set; }

			public bool FoundFistUdimTile { get; set; }

			public TemplateMatch(string template, TextureType type, uint foundFileCount, bool foundFirstUdimTile = false)
			{
				this = default(TemplateMatch);
				Template = template;
				TextureType = type;
				FoundFileCount = foundFileCount;
				FoundFistUdimTile = foundFirstUdimTile;
			}
		}

		public static ImportTemplateInfo TemplateFromFilename(string filename)
		{
			List<TemplateMatch> templateMatches;
			return TemplateFromFilename(filename, out templateMatches, TextureType.Unknown);
		}

		public static ImportTemplateInfo TemplateFromFilename(string filename, out List<TemplateMatch> templateMatches)
		{
			return TemplateFromFilename(filename, out templateMatches, TextureType.UDim);
		}

		public static ImportTemplateInfo TemplateFromFilename(string filename, TextureType preferredType)
		{
			List<TemplateMatch> templateMatches;
			return TemplateFromFilename(filename, out templateMatches, preferredType);
		}

		public static ImportTemplateInfo TemplateFromFilename(string filename, out List<TemplateMatch> templateMatches, TextureType preferredType)
		{
			string fileName = Path.GetFileName(filename);
			string directoryName = PathHelper.GetDirectoryName(filename);
			string extension = Path.GetExtension(filename);
			templateMatches = new List<TemplateMatch>();
			FileInfo[] files = new FileInfo[0];
			if (Directory.Exists(directoryName))
			{
				files = new DirectoryInfo(directoryName).GetFiles("*" + extension);
			}
			if (File.Exists(filename))
			{
				templateMatches.Add(new TemplateMatch(fileName, TextureType.Single, 1u));
			}
			List<TemplateMatch> foundMatches = null;
			if (RecognizeTiledPattern_Numbers(fileName, files, out foundMatches))
			{
				templateMatches.AddRange(foundMatches);
			}
			if (RecognizeTiledPattern_NumberAndLetter(fileName, files, out foundMatches))
			{
				templateMatches.AddRange(foundMatches);
			}
			if (RecognizeTiledPattern_Letters(fileName, files, out foundMatches))
			{
				templateMatches.AddRange(foundMatches);
			}
			if (RecognizeUdim(fileName, files, out foundMatches))
			{
				templateMatches.AddRange(foundMatches);
			}
			if (PatternScanner.IsPattern(fileName))
			{
				templateMatches.Add(new TemplateMatch(fileName, TextureType.Tiled, 1u));
			}
			if (PatternScanner.IsPatternUDim(fileName))
			{
				templateMatches.Add(new TemplateMatch(fileName, TextureType.UDim, 1u));
			}
			if (templateMatches.Count != 0)
			{
				ImportTemplateInfo importTemplateInfo = ImportTemplateInfo.ParseAndScan(directoryName + "\\" + SelectBestTemplateMatch(preferredType, templateMatches).Template);
				importTemplateInfo.TemplateConstructorInput = filename;
				return importTemplateInfo;
			}
			return ImportTemplateInfo.FileNotFoundTemplateInfo(filename);
		}

		private static TemplateMatch SelectBestTemplateMatch(TextureType preferredType, List<TemplateMatch> matches)
		{
			TemplateMatch? templateMatch = null;
			TemplateMatch? templateMatch2 = null;
			bool flag = false;
			if (preferredType == TextureType.Unknown)
			{
				flag = true;
				preferredType = TextureType.UDim;
			}
			foreach (TemplateMatch match in matches)
			{
				if (!templateMatch.HasValue)
				{
					templateMatch = match;
				}
				if (match.FoundFileCount > templateMatch.Value.FoundFileCount)
				{
					templateMatch = match;
				}
				if (!templateMatch2.HasValue && match.TextureType == preferredType)
				{
					templateMatch2 = match;
				}
				if (match.FoundFileCount > templateMatch.Value.FoundFileCount && preferredType == match.TextureType)
				{
					templateMatch2 = match;
				}
			}
			TemplateMatch result = (templateMatch2.HasValue ? templateMatch2.Value : templateMatch.Value);
			if (flag)
			{
				bool flag2 = false;
				if (result.TextureType == TextureType.UDim && result.FoundFileCount == 1 && !result.FoundFistUdimTile)
				{
					flag2 = true;
				}
				if (flag2)
				{
					return SelectBestTemplateMatch(TextureType.Single, matches);
				}
			}
			return result;
		}

		private static bool RecognizeTiledPattern_Numbers(string suggestedName, FileInfo[] files, out List<TemplateMatch> foundMatches)
		{
			int num = 2;
			uint num2 = 0u;
			foundMatches = new List<TemplateMatch>();
			string text = suggestedName;
			string empty = string.Empty;
			string empty2 = string.Empty;
			string empty3 = string.Empty;
			Match match = Regex.Match(suggestedName, "[0-9]+[^0-9]+[0-9]+");
			while (match.Success)
			{
				int num3 = 0;
				int num4 = 0;
				int num5 = 100;
				int num6 = 100;
				num2 = 0u;
				empty = suggestedName.Substring(0, match.Index);
				Match match2 = Regex.Match(suggestedName, empty + "[0-9]+");
				Match match3 = Regex.Match(suggestedName, empty + "[0-9]+[^0-9]+");
				Match match4 = Regex.Match(suggestedName, empty + "[0-9]+[^0-9]+[0-9]+");
				empty2 = suggestedName.Substring(match2.Length, match3.Length - match2.Length);
				empty3 = suggestedName.Substring(match4.Length, suggestedName.Length - match4.Length);
				num3 = match2.Length - match.Index;
				num4 = match.Index + match.Length - match3.Length;
				foreach (FileInfo fileInfo in files)
				{
					if (Regex.Match(fileInfo.Name, "^" + empty + "[0-9]+" + empty2 + "[0-9]+" + empty3 + "$").Success)
					{
						Match match5 = Regex.Match(fileInfo.Name, empty);
						Match match6 = Regex.Match(fileInfo.Name, empty + "[0-9]+");
						Match match7 = Regex.Match(fileInfo.Name, empty + "[0-9]+" + empty2);
						Match match8 = Regex.Match(fileInfo.Name, empty + "[0-9]+" + empty2 + "[0-9]+");
						num3 = ((num3 < match6.Length - match5.Length) ? num3 : (match6.Length - match5.Length));
						num4 = ((num4 < match8.Length - match7.Length) ? num4 : (match8.Length - match7.Length));
						int num7 = Convert.ToInt32(fileInfo.Name.Substring(match5.Index + match5.Length, num3));
						if (num5 >= num7)
						{
							num5 = num7;
							num6 = ((num6 < Convert.ToInt32(fileInfo.Name.Substring(match5.Index + match7.Length, num4))) ? num6 : Convert.ToInt32(fileInfo.Name.Substring(match5.Index + match7.Length, num4)));
						}
						num2++;
					}
					if (num2 > 10)
					{
						break;
					}
				}
				if (num2 >= num && (num5 == 0 || num5 == 1) && (num6 == 0 || num6 == 1))
				{
					text = empty + "%";
					if (num3 > 1)
					{
						if (num3 < 10)
						{
							text += "0";
						}
						text += num3;
					}
					if (num5 == 1)
					{
						text += "+";
					}
					text = text + "x" + empty2 + "%";
					if (num4 > 1)
					{
						if (num4 < 10)
						{
							text += "0";
						}
						text += num4;
					}
					if (num6 == 1)
					{
						text += "+";
					}
					text = text + "y" + empty3;
					TemplateMatch item = new TemplateMatch(text, TextureType.Tiled, num2);
					foundMatches.Add(item);
				}
				match = match.NextMatch();
			}
			return foundMatches.Count > 0;
		}

		private static bool RecognizeTiledPattern_NumberAndLetter(string suggestedName, FileInfo[] files, out List<TemplateMatch> foundMatches)
		{
			int num = 2;
			uint num2 = 0u;
			string text = suggestedName;
			foundMatches = new List<TemplateMatch>();
			string empty = string.Empty;
			string empty2 = string.Empty;
			string empty3 = string.Empty;
			Match match = Regex.Match(suggestedName, "[0-9]+");
			while (match.Success)
			{
				Match match2 = Regex.Match(suggestedName, "[A-Z]");
				while (match2.Success)
				{
					int num3 = 3;
					int num4 = 100;
					char c = 'Z';
					num2 = 0u;
					if (match.Index < match2.Index)
					{
						empty = suggestedName.Substring(0, match.Index);
						empty2 = suggestedName.Substring(match.Index + match.Length, match2.Index - (match.Index + match.Length));
						empty3 = suggestedName.Substring(match2.Index + match2.Length, suggestedName.Length - (match2.Index + match2.Length));
						FileInfo[] array = files;
						foreach (FileInfo fileInfo in array)
						{
							if (Regex.Match(fileInfo.Name, "^" + empty + "[0-9]+" + empty2 + "[A-Z]" + empty3 + "$").Success)
							{
								Match match3 = Regex.Match(fileInfo.Name, empty);
								Match match4 = Regex.Match(fileInfo.Name, empty + "[0-9]+");
								num3 = ((num3 < match4.Length - match3.Length) ? num3 : (match4.Length - match3.Length));
								int num5 = Convert.ToInt32(fileInfo.Name.Substring(match3.Index + match3.Length, match4.Length - match3.Length));
								if (num4 >= num5)
								{
									num4 = num5;
									c = ((c < fileInfo.Name.Substring(match4.Index + match4.Length + empty2.Length, 1)[0]) ? c : fileInfo.Name.Substring(match4.Index + match4.Length + empty2.Length, 1)[0]);
								}
								num2++;
							}
							if (num2 > 10)
							{
								break;
							}
						}
						if (num2 >= num && (num4 == 0 || num4 == 1) && c == 'A')
						{
							text = empty + "%";
							if (num3 > 1)
							{
								if (num3 < 10)
								{
									text += "0";
								}
								text += num3;
							}
							if (num4 == 1)
							{
								text += "+";
							}
							text = text + "x" + empty2 + "@y" + empty3;
							TemplateMatch item = new TemplateMatch(text, TextureType.Tiled, num2);
							foundMatches.Add(item);
						}
					}
					else
					{
						suggestedName.Substring(0, match2.Index);
						empty = suggestedName.Substring(0, match2.Index);
						empty2 = suggestedName.Substring(match2.Index + match2.Length, match.Index - (match2.Index + match2.Length));
						empty3 = suggestedName.Substring(match.Index + match.Length, suggestedName.Length - (match.Index + match.Length));
						FileInfo[] array = files;
						foreach (FileInfo fileInfo2 in array)
						{
							if (Regex.Match(fileInfo2.Name, "^" + empty + "[A-Z]" + empty2 + "[0-9]+" + empty3 + "$").Success)
							{
								Match match5 = Regex.Match(fileInfo2.Name, empty + "[A-Z]" + empty2);
								Match match6 = Regex.Match(fileInfo2.Name, empty + "[A-Z]" + empty2 + "[0-9]+");
								num3 = ((num3 < match6.Length - match5.Length) ? num3 : (match6.Length - match5.Length));
								char c2 = fileInfo2.Name.Substring(empty.Length, 1)[0];
								if (c >= c2)
								{
									num4 = ((num4 < Convert.ToInt32(fileInfo2.Name.Substring(match5.Index + match5.Length, match6.Length - match5.Length))) ? num4 : Convert.ToInt32(fileInfo2.Name.Substring(match5.Index + match5.Length, match6.Length - match5.Length)));
									c = c2;
								}
								num2++;
							}
							if (num2 > 10)
							{
								break;
							}
						}
						if (num2 >= num && (num4 == 0 || num4 == 1) && c == 'A')
						{
							text = empty + "@x" + empty2 + "%";
							if (num3 > 1)
							{
								if (num3 < 10)
								{
									text += "0";
								}
								text += num3;
							}
							if (num4 == 1)
							{
								text += "+";
							}
							text = text + "y" + empty3;
							TemplateMatch item2 = new TemplateMatch(text, TextureType.Tiled, num2);
							foundMatches.Add(item2);
						}
					}
					match2 = match2.NextMatch();
				}
				match = match.NextMatch();
			}
			return foundMatches.Count > 0;
		}

		private static bool RecognizeTiledPattern_Letters(string suggestedName, FileInfo[] files, out List<TemplateMatch> foundMatches)
		{
			int num = 2;
			uint num2 = 0u;
			string text = suggestedName;
			foundMatches = new List<TemplateMatch>();
			string empty = string.Empty;
			string empty2 = string.Empty;
			string empty3 = string.Empty;
			Match match = Regex.Match(suggestedName, "[A-Z][^A-Z]");
			while (match.Success)
			{
				string text2 = suggestedName.Substring(match.Index + match.Length - 1, suggestedName.Length - (match.Index + match.Length) + 1);
				Match match2 = Regex.Match(text2, "[^A-Z][A-Z]");
				while (match2.Success)
				{
					char c = 'Z';
					char c2 = 'Z';
					num2 = 0u;
					empty = suggestedName.Substring(0, match.Index);
					empty2 = suggestedName.Substring(match.Index + match.Length - 1, match2.Index + 1);
					empty3 = text2.Substring(match2.Index + match2.Length, text2.Length - (match2.Index + match2.Length));
					foreach (FileInfo fileInfo in files)
					{
						if (Regex.Match(fileInfo.Name, "^" + empty + "[A-Z]" + empty2 + "[A-Z]" + empty3 + "$").Success)
						{
							char c3 = fileInfo.Name.Substring(empty.Length, 1)[0];
							if (c >= c3)
							{
								c = c3;
								c2 = ((c2 < fileInfo.Name.Substring(empty.Length + empty2.Length + 1, 1)[0]) ? c2 : fileInfo.Name.Substring(empty.Length + empty2.Length + 1, 1)[0]);
							}
							num2++;
						}
						if (num2 > 10)
						{
							break;
						}
					}
					match2 = match2.NextMatch();
					if (num2 >= num && c == 'A' && c2 == 'A')
					{
						text = empty + "@x" + empty2 + "@y" + empty3;
						TemplateMatch item = new TemplateMatch(text, TextureType.Tiled, num2);
						foundMatches.Add(item);
					}
				}
				match = match.NextMatch();
			}
			return num2 > 2;
		}

		private static bool RecognizeUdim(string name, FileInfo[] files, out List<TemplateMatch> templateMatches)
		{
			int num = 1;
			uint num2 = 0u;
			templateMatches = new List<TemplateMatch>();
			Match match = Regex.Match(name, "^((.+)?[^0-9])?[1-9][0-9]{3}([^0-9](.+)?)?$");
			if (match.Success)
			{
				match = ((match.Value.Length <= 8) ? Regex.Match(name, "[1-9][0-9]{3}") : Regex.Match(name, "[^0-9][1-9][0-9]{3}[^0-9]"));
				if (match.Success)
				{
					match = Regex.Match(name, "[1-9][0-9]{3}");
				}
				else
				{
					match = Regex.Match(name, "^[1-9][0-9]{3}[^0-9]");
					if (match.Success)
					{
						match = Regex.Match(name, "[1-9][0-9]{3}");
					}
					else
					{
						match = Regex.Match(name, "[^0-9][1-9][0-9]{3}$");
						if (match.Success)
						{
							match = Regex.Match(name, "[1-9][0-9]{3}");
						}
					}
				}
				while (match.Success)
				{
					num2 = 0u;
					bool foundFirstUdimTile = false;
					string text = name.Substring(0, match.Index);
					string text2 = name.Substring(match.Index + match.Length, name.Length - (match.Index + match.Length));
					for (int i = 0; i < files.Length; i++)
					{
						Match match2 = Regex.Match(files[i].Name, "^" + text + "([1-9][0-9]{3})" + text2 + "$");
						if (!match2.Success || match2.Groups.Count < 2)
						{
							continue;
						}
						int result = 0;
						if (int.TryParse(match2.Groups[1].Value, out result))
						{
							if (result <= 1000)
							{
								continue;
							}
							int num3 = 1000 + 10 * ImportTemplateInfo.MaxUDimVerticalPatches;
							if (result >= num3)
							{
								continue;
							}
							if (result == 1001)
							{
								foundFirstUdimTile = true;
							}
							num2++;
						}
						if (num2 > 10)
						{
							break;
						}
					}
					if (num2 >= num)
					{
						string template = text + "%u" + text2;
						TemplateMatch item = new TemplateMatch(template, TextureType.UDim, num2, foundFirstUdimTile);
						templateMatches.Add(item);
					}
					match = match.NextMatch();
				}
			}
			return num2 != 0;
		}
	}
	public enum PipelineState
	{
		None,
		Imported,
		Atlassed,
		Composited,
		Coded,
		Built,
		Unknown
	}
	public enum CausingChanges
	{
		None,
		InputAdded,
		InputFailed,
		InputRemoved,
		InputChanged,
		CodingChanged,
		AtlasChanged,
		GeneralChanges,
		Unknown
	}
	public enum FailureState
	{
		TextureNotFound,
		TextureInaccessible,
		InvalidTextureFormat,
		InvalidUDimPattern,
		InvalidPatternDimensions,
		LayerResolutionsNotMatching,
		InvalidAssetBorder,
		None,
		Unknown
	}
	public enum SoupFailureState
	{
		Missing,
		Inaccessible,
		ReadOnly,
		None,
		Unknown
	}
	public enum TextureChanges
	{
		None,
		Missing,
		DataUpdated,
		Inaccessible
	}
	public class TextureAssetState
	{
		public string Source { get; set; }

		public TextureChanges Changes { get; set; }
	}
	public class LayerAssetState
	{
		public CausingChanges Changes { get; set; }

		public List<TextureAssetState> TextureStates { get; private set; }

		public FailureState FailureState { get; set; }

		public LayerAssetState()
		{
			Changes = CausingChanges.Unknown;
			FailureState = FailureState.Unknown;
			TextureStates = new List<TextureAssetState>();
		}
	}
	public class AssetState
	{
		public PipelineState PipelineState { get; set; }

		public CausingChanges Changes { get; set; }

		public FailureState FailureState { get; set; }

		public Dictionary<int, LayerAssetState> LayerStates { get; set; }

		public SoupFailureState SoupFailureState { get; set; }

		public bool builtForGTexStreaming { get; set; }

		public AssetState()
		{
			PipelineState = PipelineState.Unknown;
			Changes = CausingChanges.Unknown;
			FailureState = FailureState.Unknown;
			LayerStates = new Dictionary<int, LayerAssetState>();
			SoupFailureState = SoupFailureState.Unknown;
			builtForGTexStreaming = false;
		}
	}
	public class BuildStateSummary
	{
		public Dictionary<Guid, AssetState> AssetStates { get; set; }

		public PipelineState PipelineState { get; set; }

		public bool BuildRequired { get; set; }

		public CausingChanges Changes { get; set; }

		public BuildStateSummary()
		{
			AssetStates = new Dictionary<Guid, AssetState>();
		}
	}
	internal class BuildStateManager
	{
		private ProjectBuilder projectBuilder;

		public BuildStateSummary BuildSummary { get; private set; }

		public BuildStateManager(ProjectBuilder projectBuilder)
		{
			this.projectBuilder = projectBuilder;
		}

		private SoupFailureState CheckSoupState(Asset asset)
		{
			string soupFilePath = BuildState.GetSoupFilePath(projectBuilder.ActiveProject, asset);
			if (!File.Exists(soupFilePath))
			{
				return SoupFailureState.Missing;
			}
			try
			{
				using (File.Open(soupFilePath, FileMode.Open, FileAccess.ReadWrite))
				{
				}
			}
			catch (Exception)
			{
				try
				{
					using (File.Open(soupFilePath, FileMode.Open, FileAccess.Read, FileShare.Read))
					{
					}
				}
				catch (IOException)
				{
					return SoupFailureState.Inaccessible;
				}
				return SoupFailureState.ReadOnly;
			}
			return SoupFailureState.None;
		}

		private TextureAssetState CheckTextureState(Texture texture)
		{
			TextureAssetState textureAssetState = new TextureAssetState();
			textureAssetState.Source = texture.Source;
			textureAssetState.Changes = TextureChanges.None;
			if (!File.Exists(texture.Source))
			{
				textureAssetState.Changes = TextureChanges.Missing;
			}
			else
			{
				try
				{
					if (FileTools.FileHasChanged(texture.LastChangedDate, texture.Source, out var _))
					{
						textureAssetState.Changes = TextureChanges.DataUpdated;
					}
				}
				catch
				{
					textureAssetState.Changes = TextureChanges.Inaccessible;
				}
				if (textureAssetState.Changes == TextureChanges.DataUpdated)
				{
					try
					{
						using (File.Open(texture.Source, FileMode.Open, FileAccess.Read))
						{
							return textureAssetState;
						}
					}
					catch (IOException)
					{
						textureAssetState.Changes = TextureChanges.Inaccessible;
						return textureAssetState;
					}
				}
			}
			return textureAssetState;
		}

		private LayerAssetState CheckLayerAssetState(AssetLayer assetLayer)
		{
			LayerAssetState layerAssetState = new LayerAssetState();
			layerAssetState.Changes = CausingChanges.None;
			bool flag = false;
			bool flag2 = false;
			bool flag3 = false;
			bool flag4 = false;
			bool flag5 = false;
			bool flag6 = false;
			for (int i = 0; i < assetLayer.Textures.Count; i++)
			{
				TextureAssetState textureAssetState = CheckTextureState(assetLayer.Textures[i]);
				layerAssetState.TextureStates.Add(textureAssetState);
				if (textureAssetState.Changes == TextureChanges.DataUpdated)
				{
					flag2 = true;
				}
				else if (textureAssetState.Changes == TextureChanges.Missing)
				{
					flag = true;
				}
				else if (textureAssetState.Changes == TextureChanges.Inaccessible)
				{
					flag3 = true;
				}
			}
			flag4 = false;
			flag6 = false;
			flag5 = false;
			if (flag)
			{
				layerAssetState.Changes = CausingChanges.InputFailed;
				layerAssetState.FailureState = FailureState.TextureNotFound;
			}
			else if (flag3)
			{
				layerAssetState.Changes = CausingChanges.InputFailed;
				layerAssetState.FailureState = FailureState.TextureInaccessible;
			}
			else if (flag4)
			{
				layerAssetState.Changes = CausingChanges.InputFailed;
				if (flag5)
				{
					layerAssetState.FailureState = FailureState.InvalidUDimPattern;
				}
				else if (flag6)
				{
					layerAssetState.FailureState = FailureState.InvalidPatternDimensions;
				}
			}
			else if (flag2)
			{
				layerAssetState.Changes = CausingChanges.InputChanged;
				layerAssetState.FailureState = FailureState.None;
			}
			else
			{
				layerAssetState.Changes = CausingChanges.None;
				layerAssetState.FailureState = FailureState.None;
			}
			return layerAssetState;
		}

		private PipelineState CheckAssetPipelineState(Asset asset)
		{
			_ = projectBuilder.ActiveProject;
			BuildState state = projectBuilder.State;
			if (!state.BuildRequired())
			{
				return PipelineState.Built;
			}
			if (!state.CodeRequired(asset))
			{
				return PipelineState.Coded;
			}
			if (!state.ComposeRequired(asset))
			{
				return PipelineState.Composited;
			}
			if (!state.AtlasRequired(asset))
			{
				return PipelineState.Atlassed;
			}
			return PipelineState.Imported;
		}

		private AssetState CheckAssetState(Asset asset, bool builtForGTexStreaming)
		{
			BuildState state = projectBuilder.State;
			AssetState assetState = new AssetState();
			assetState.builtForGTexStreaming = builtForGTexStreaming;
			assetState.SoupFailureState = CheckSoupState(asset);
			FailureState failureState = FailureState.None;
			for (int i = 0; i < asset.AssetLayers.Count; i++)
			{
				LayerAssetState layerAssetState = CheckLayerAssetState(asset.AssetLayers[i]);
				assetState.LayerStates.Add(i, layerAssetState);
				if (layerAssetState.FailureState < failureState)
				{
					failureState = layerAssetState.FailureState;
				}
			}
			assetState.FailureState = failureState;
			if (AssetTools.IsAssetPatternChanged(asset, out var addedFiles, out var _))
			{
				assetState.PipelineState = PipelineState.None;
				if (addedFiles.Count > 0)
				{
					assetState.Changes = CausingChanges.InputAdded;
				}
				else
				{
					assetState.Changes = CausingChanges.InputRemoved;
				}
			}
			else
			{
				switch (state.IsAssetChanged(asset))
				{
				case AssetChangeType.None:
					assetState.Changes = CausingChanges.None;
					if (BuildSummary != null)
					{
						BuildSummary.AssetStates[asset.Id] = assetState;
					}
					assetState.PipelineState = CheckAssetPipelineState(asset);
					break;
				case AssetChangeType.Added:
					assetState.Changes = CausingChanges.InputAdded;
					assetState.PipelineState = PipelineState.Imported;
					break;
				case AssetChangeType.Deleted:
					assetState.Changes = CausingChanges.InputRemoved;
					assetState.PipelineState = PipelineState.None;
					break;
				case AssetChangeType.Resolution:
					assetState.Changes = CausingChanges.InputChanged;
					assetState.PipelineState = PipelineState.Imported;
					break;
				case AssetChangeType.Data:
					assetState.Changes = CausingChanges.InputChanged;
					assetState.PipelineState = PipelineState.Atlassed;
					break;
				case AssetChangeType.Codec:
					assetState.Changes = CausingChanges.CodingChanged;
					assetState.PipelineState = PipelineState.Composited;
					break;
				case AssetChangeType.MetaData:
					assetState.Changes = CausingChanges.GeneralChanges;
					assetState.PipelineState = PipelineState.Coded;
					break;
				}
			}
			return assetState;
		}

		public void Scan()
		{
			Project activeProject = projectBuilder.ActiveProject;
			BuildState state = projectBuilder.State;
			BuildSummary = new BuildStateSummary();
			bool checkGTSBuildMode = false;
			BuildMode buildMode = BuildMode.BuildForGTP;
			bool existingGTSbuiltForGTexStreaming;
			bool buildRequired = state.BuildRequired(checkGTSBuildMode, buildMode, out existingGTSbuiltForGTexStreaming);
			foreach (Asset value2 in activeProject.Assets.Values)
			{
				AssetState value = CheckAssetState(value2, existingGTSbuiltForGTexStreaming);
				BuildSummary.AssetStates[value2.Id] = value;
			}
			state.CheckChanges();
			BuildSummary.BuildRequired = buildRequired;
			if (state.AtlasRequired(activeProject))
			{
				BuildSummary.PipelineState = PipelineState.Imported;
				BuildSummary.BuildRequired = true;
				return;
			}
			bool flag = false;
			foreach (Asset value3 in activeProject.Assets.Values)
			{
				if (state.ComposeRequired(value3))
				{
					BuildSummary.PipelineState = PipelineState.Atlassed;
					BuildSummary.BuildRequired = true;
					flag = true;
					break;
				}
			}
			if (flag)
			{
				return;
			}
			bool flag2 = false;
			foreach (Asset value4 in activeProject.Assets.Values)
			{
				if (state.CodeRequired(value4))
				{
					BuildSummary.PipelineState = PipelineState.Composited;
					BuildSummary.BuildRequired = true;
					flag2 = true;
					break;
				}
			}
			if (!flag2)
			{
				if (state.BuildRequired())
				{
					BuildSummary.PipelineState = PipelineState.Coded;
					BuildSummary.BuildRequired = true;
				}
				else
				{
					BuildSummary.PipelineState = PipelineState.Built;
				}
			}
		}
	}
	internal class PackedAsset
	{
		public Guid AssetId { get; set; }

		public int X { get; set; }

		public int Y { get; set; }

		public int Width { get; set; }

		public int Height { get; set; }

		public DateTime PackedDate { get; set; }
	}
	internal class CompositedAsset
	{
		public Guid AssetId { get; set; }

		public DateTime CompositedDate { get; set; }

		public AssetTilingMethod TilingMethod { get; set; }

		public int X { get; set; }

		public int Y { get; set; }

		public int Width { get; set; }

		public int Height { get; set; }

		public List<CompositedAssetLayer> Layers { get; set; }
	}
	internal class CompositedAssetLayer
	{
		public List<CompositedTexture> Textures { get; set; }

		public Guid Thumbnail { get; set; }
	}
	internal class CompositedTexture
	{
		public int X { get; set; }

		public int Y { get; set; }

		public int Width { get; set; }

		public int Height { get; set; }

		public DateTime LastChangedDate { get; set; }

		public CompositedTexture(int x, int y, int width, int height, DateTime time)
		{
			X = x;
			Y = y;
			Width = width;
			Height = height;
			LastChangedDate = time;
		}

		public CompositedTexture(Rectangle rect, DateTime time)
		{
			X = rect.Left;
			Y = rect.Top;
			Width = rect.Width;
			Height = rect.Height;
			LastChangedDate = time;
		}
	}
	internal class SoupedAsset
	{
		public Guid AssetId { get; set; }

		public DateTime SoupedDate { get; set; }

		public AssetTilingMethod TilingMethod { get; set; }

		public int X { get; set; }

		public int Y { get; set; }

		public int Width { get; set; }

		public int Height { get; set; }

		public List<SoupedAssetLayer> Layers { get; set; }
	}
	internal class SoupedAssetLayer
	{
		public List<SoupedTexture> Textures { get; set; }

		public FixedTexFormat FixedTexFormat { get; set; }

		public Guid Thumbnail { get; set; }
	}
	internal class SoupedTexture
	{
		public int X { get; set; }

		public int Y { get; set; }

		public int Width { get; set; }

		public int Height { get; set; }

		public DateTime LastChangedDate { get; set; }

		public SoupedTexture(int x, int y, int width, int height, DateTime time)
		{
			X = x;
			Y = y;
			Width = width;
			Height = height;
			LastChangedDate = time;
		}
	}
	internal class BuildAsset
	{
		public Guid AssetId { get; set; }

		public DateTime BuildDate { get; set; }

		public DateTime GTexLastChangeDate { get; set; }

		public int X { get; set; }

		public int Y { get; set; }

		public int Width { get; set; }

		public int Height { get; set; }
	}
	internal class AssetAtlasser
	{
		public static bool Atlas(Int2 tileSize, IEnumerable<PackedAsset> fixedRects, IEnumerable<Asset> rects, out List<PackedAsset> packedAssets, out Int2 packedSize)
		{
			packedAssets = new List<PackedAsset>();
			AtlasConfiguration atlasConfiguration = new AtlasConfiguration();
			atlasConfiguration.AllowRotations = false;
			List<Atlasser.AtlasItem> list = new List<Atlasser.AtlasItem>();
			foreach (Asset rect in rects)
			{
				bool power2Alignment = true;
				int width = ExtraMath.RoundUpToPowerOfTwo(rect.Width);
				int height = ExtraMath.RoundUpToPowerOfTwo(rect.Height);
				Atlasser.AtlasItem item = new Atlasser.AtlasItem(rect, width, height, power2Alignment);
				list.Add(item);
			}
			List<Atlasser.AtlassedItem> packedAssets2;
			bool flag = new Atlasser(atlasConfiguration, tileSize).Atlas(new List<Atlasser.AtlassedItem>(), list, out packedAssets2, out packedSize);
			if (!flag)
			{
				return false;
			}
			foreach (Atlasser.AtlassedItem item2 in packedAssets2)
			{
				PackedAsset packedAsset = new PackedAsset();
				packedAsset.X = item2.X;
				packedAsset.Y = item2.Y;
				packedAsset.Width = item2.Width;
				packedAsset.Height = item2.Height;
				packedAsset.PackedDate = DateTimeManagement.Now();
				packedAsset.AssetId = ((Asset)item2.Tag).Id;
				packedAssets.Add(packedAsset);
			}
			return flag;
		}
	}
	internal class PackingSummary
	{
		public int PackedHeight { get; set; }

		public int PackedWidth { get; set; }

		public bool Repacked { get; set; }

		public DateTime LastChangedDate { get; set; }
	}
	internal class AtlasProcess : IAtlasProcess, IPipelineProcess
	{
		private PipelineProcessResult latestResult;

		public ProjectBuilder ProjectBuilder { get; private set; }

		public PipelineProcessResult LatestResult => latestResult;

		public bool HasRun { get; private set; }

		public DateTime LastRun { get; private set; }

		public AtlasProcess(ProjectBuilder builder)
		{
			ProjectBuilder = builder;
		}

		public PipelineProcessResult PreProcess()
		{
			return PipelineProcessResult.Success;
		}

		public PipelineProcessResult Process()
		{
			Project activeProject = ProjectBuilder.ActiveProject;
			DateTime now = DateTime.Now;
			ProjectBuilder.logger.LogTitle("Atlas...", Logger.Verbosity.Normal);
			foreach (Asset value in activeProject.Assets.Values)
			{
				if ((AssetImportTools.AssetImportSucceeded(ProjectBuilder, value) || ProjectBuilder.State.IsSoupFileValid(value)) && ProjectBuilder.State.AtlasRequired(value) && !AtlasAsset(value))
				{
					latestResult = PipelineProcessResult.Failed;
					return latestResult;
				}
			}
			if (!Atlas(out var summary))
			{
				string innerMessage = $"Unable to atlas items. Internal error. Please rebuild or contact Graphine support.";
				ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.Atlas, new AtlasIssue(innerMessage));
				latestResult = PipelineProcessResult.Failed;
				return latestResult;
			}
			Int2 @int = new Int2(ExtraMath.RoundUpToPowerOfTwo(summary.PackedWidth), ExtraMath.RoundUpToPowerOfTwo(summary.PackedHeight));
			Int2 tileContentSize = GetTileContentSize();
			Int2 int2 = new Int2((@int.X + tileContentSize.X - 1) / tileContentSize.X, (@int.Y + tileContentSize.Y - 1) / tileContentSize.Y);
			if (@int.X > Constants.MaxAtlasSize.X || @int.Y > Constants.MaxAtlasSize.Y)
			{
				string innerMessage2 = $"A tile set can not be larger than {Constants.MaxAtlasSize.X}x{Constants.MaxAtlasSize.Y} (currently needed: {@int.X}x{@int.Y}). Please remove or resize textures in your project.";
				ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.Atlas, new AtlasIssue(innerMessage2));
				latestResult = PipelineProcessResult.Failed;
				return latestResult;
			}
			if (int2.X > Constants.MaxAtlasSizeInTiles.X || int2.Y > Constants.MaxAtlasSizeInTiles.Y)
			{
				string innerMessage3 = $"A tile set can not be larger than {Constants.MaxAtlasSizeInTiles.X}x{Constants.MaxAtlasSizeInTiles.Y} tiles (currently needed: {int2.X}x{int2.Y} tiles). Please increase the tile size or remove or resize textures in your project.";
				ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.Atlas, new AtlasIssue(innerMessage3));
				latestResult = PipelineProcessResult.Failed;
				return latestResult;
			}
			if (@int.X > Constants.MaxLicensedAtlasSize.X || @int.Y > Constants.MaxLicensedAtlasSize.Y)
			{
				string innerMessage4 = $"Your license does not allow you to build a tile set larger than {Constants.MaxLicensedAtlasSize.X}x{Constants.MaxLicensedAtlasSize.Y} (currently needed: {@int.X}x{@int.Y}). Please upgrade your license, or remove or resize textures in your project.";
				ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.Atlas, new AtlasIssue(innerMessage4));
				latestResult = PipelineProcessResult.Failed;
				return latestResult;
			}
			ProjectBuilder.logger.LogMessage("Total texture resolution: " + summary.PackedWidth + "x" + summary.PackedHeight, Logger.Verbosity.Detailed);
			if (ProjectBuilder.ProfilingEnabled)
			{
				double num = Math.Truncate((DateTime.Now - now).TotalMilliseconds) / 1000.0;
				ProjectBuilder.logger.LogConsole("Done, elapsed time: " + num + " s", Logger.Verbosity.Quiet);
			}
			HasRun = true;
			LastRun = DateTimeManagement.Now();
			latestResult = PipelineProcessResult.Success;
			return latestResult;
		}

		private bool AtlasAsset(Asset asset)
		{
			Asset[] array = null;
			if (asset.Type == AssetType.CubeMap && asset.Face == 0)
			{
				array = AssetTools.FindCubeMapAssets(ProjectBuilder.ActiveProject, asset.AssetGroupId);
			}
			else if (asset.Type == AssetType.Normal)
			{
				array = new Asset[1] { asset };
			}
			if (array == null)
			{
				return true;
			}
			Atlasser atlasser = new Atlasser(new AtlasConfiguration
			{
				AllowRotations = false
			}, GetTileContentSize());
			List<Atlasser.AtlasItem> list = new List<Atlasser.AtlasItem>();
			Asset[] array2 = array;
			foreach (Asset asset2 in array2)
			{
				Atlasser.AtlasItem item = new Atlasser.AtlasItem(asset2, asset2.Width, asset2.Height, power2Alignment: true);
				list.Add(item);
			}
			List<Atlasser.AtlassedItem> packedAssets = new List<Atlasser.AtlassedItem>();
			if (!atlasser.Atlas(null, list, out packedAssets, out var packedSize))
			{
				return false;
			}
			BuildState.CompositeState compositeState = ProjectBuilder.State.FindAssetCompositeState(asset.Id);
			if (compositeState == null)
			{
				compositeState = ProjectBuilder.State.CreateAssetCompositeState(asset.Id);
			}
			compositeState.PackedAssets = new List<PackedAsset>();
			foreach (Atlasser.AtlassedItem item2 in packedAssets)
			{
				Asset asset3 = (Asset)item2.Tag;
				PackedAsset packedAsset = new PackedAsset();
				packedAsset.AssetId = asset3.Id;
				packedAsset.X = item2.X;
				packedAsset.Y = item2.Y;
				packedAsset.Width = item2.Width;
				packedAsset.Height = item2.Height;
				packedAsset.PackedDate = DateTimeManagement.Now();
				compositeState.PackedAssets.Add(packedAsset);
			}
			PackingSummary packingSummary = new PackingSummary();
			packingSummary.PackedHeight = packedSize.Y;
			packingSummary.PackedWidth = packedSize.X;
			packingSummary.Repacked = true;
			HasRun = true;
			packingSummary.LastChangedDate = DateTimeManagement.Now();
			compositeState.PackingSummary = packingSummary;
			UpdateState(asset);
			return true;
		}

		private bool Atlas(out PackingSummary summary)
		{
			Project activeProject = ProjectBuilder.ActiveProject;
			summary = new PackingSummary();
			if (activeProject.Assets.Count == 0)
			{
				string innerMessage = "No assets have been found to atlas, please import assets.";
				ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.Atlas, new AtlasIssue(innerMessage));
				latestResult = PipelineProcessResult.Failed;
				return false;
			}
			if (!AssetAtlasser.Atlas(GetTileContentSize(), null, activeProject.Assets.Values, out var _, out var packedSize))
			{
				return false;
			}
			summary.PackedHeight = packedSize.X;
			summary.PackedWidth = packedSize.Y;
			summary.Repacked = true;
			HasRun = true;
			summary.LastChangedDate = DateTimeManagement.Now();
			return true;
		}

		private void UpdateState(Asset asset)
		{
			ProjectBuilder.State.Update(asset.Id, AssetChangeType.Added);
			ProjectBuilder.State.Update(asset.Id, AssetChangeType.Deleted);
			ProjectBuilder.State.Update(asset.Id, AssetChangeType.Resolution);
		}

		private Int2 GetTileContentSize()
		{
			Project activeProject = ProjectBuilder.ActiveProject;
			int maximumAnisotropy = (int)activeProject.BuildConfiguration.MaximumAnisotropy;
			Int2 @int = new Int2();
			if (activeProject.BuildConfiguration.TilingMode == TilingMode.Software)
			{
				@int.X = (int)Defaults.TileSize;
				@int.Y = (int)Defaults.TileSize;
				if (activeProject.BuildConfiguration.TileWidth != 0)
				{
					@int.X = (int)activeProject.BuildConfiguration.TileWidth;
				}
				else if ((@int.X + 2 * maximumAnisotropy) % 16 != 0)
				{
					@int.X += 16 - (@int.X + 2 * maximumAnisotropy) % 16;
				}
				if (activeProject.BuildConfiguration.TileHeight != 0)
				{
					@int.Y = (int)activeProject.BuildConfiguration.TileHeight;
				}
				else if ((@int.Y + 2 * maximumAnisotropy) % 16 != 0)
				{
					@int.Y += 16 - (@int.Y + 2 * maximumAnisotropy) % 16;
				}
			}
			return @int;
		}

		public PipelineProcessResult PostProcess(PipelineProcessResult processResult)
		{
			return PipelineProcessResult.Success;
		}
	}
	internal class BinPacking
	{
		public struct PackingOptions
		{
			public int width;

			public int height;

			public int allowRotation;
		}

		public struct PackedRectangle
		{
			public int x;

			public int y;

			public int width;

			public int height;

			public int rotated;

			public int alignment;
		}

		[DllImport("BinPacking", CallingConvention = CallingConvention.Cdecl)]
		public static extern void BeginPacking(ref PackingOptions options);

		[DllImport("BinPacking", CallingConvention = CallingConvention.Cdecl)]
		public static extern void AddRectangle(int width, int height, int alignment);

		[DllImport("BinPacking", CallingConvention = CallingConvention.Cdecl)]
		public static extern void AddFixedRectangle(int x, int y, int width, int height);

		[DllImport("BinPacking", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PackRectangles();

		[DllImport("BinPacking", CallingConvention = CallingConvention.Cdecl)]
		public static extern void GetPackedRectangle(int id, ref PackedRectangle outRectangle);

		[DllImport("BinPacking", CallingConvention = CallingConvention.Cdecl)]
		public static extern void GetFixedRectangle(int id, ref PackedRectangle outRectangle);
	}
	internal class BuildState
	{
		internal class CompositeState
		{
			public Guid AssetId { get; set; }

			public string XMLFileName { get; set; }

			public PackingSummary PackingSummary { get; set; }

			public List<PackedAsset> PackedAssets { get; set; }

			public TileSetConfig TileSetConfig { get; set; }

			public LayerConfig LayerConfig { get; set; }

			public Dictionary<Guid, Asset> Assets { get; set; }

			public CompositorSummary CompositorSummary { get; set; }

			public List<CompositedAsset> CompositedList { get; set; }

			public Dictionary<Guid, AssetChangeType> ChangesDict { get; set; }

			public List<Dictionary<Guid, AssetChangeType>> LayerChangesDict { get; set; }

			public CompositeState()
			{
				Assets = new Dictionary<Guid, Asset>();
				CompositedList = new List<CompositedAsset>();
				ChangesDict = new Dictionary<Guid, AssetChangeType>();
				LayerChangesDict = new List<Dictionary<Guid, AssetChangeType>>();
				PackedAssets = new List<PackedAsset>();
			}

			public void SetAssetMetaData(Asset asset)
			{
				Assets[asset.Id].Name = asset.Name;
				if (!string.IsNullOrEmpty(asset.AssetGroupId))
				{
					Assets[asset.Id].AssetGroupId = asset.AssetGroupId;
				}
			}
		}

		internal class SoupState
		{
			public Guid AssetId { get; set; }

			public Guid ProjectId { get; set; }

			public TileLayout TileLayout { get; set; }

			public LayerConfig LayerConfig { get; set; }

			public Dictionary<Guid, Asset> Assets { get; set; }

			public Dictionary<Guid, SoupedAsset> SoupedAssets { get; set; }

			public SoupBuilderSummary SoupBuilderSummary { get; set; }

			public SoupState()
			{
				Assets = new Dictionary<Guid, Asset>();
				SoupedAssets = new Dictionary<Guid, SoupedAsset>();
			}
		}

		internal class IncrementalBuildState
		{
			public bool IncrementalBuildPossible { get; set; }

			public List<int> IdenticalLayers { get; set; }

			public IncrementalBuildState()
			{
				IncrementalBuildPossible = false;
				IdenticalLayers = new List<int>();
			}
		}

		private class BuildStateTools
		{
			private static bool StringsEqualOrNull(string x, string y)
			{
				string obj = ((x == null) ? "" : x);
				string value = ((y == null) ? "" : y);
				return obj.Equals(value, StringComparison.InvariantCultureIgnoreCase);
			}

			public static AssetChangeType GetAssetChangesGeneral(Project project, Asset origCompAsset, LayerConfig compositedLayerConfig, Asset newAsset)
			{
				if (origCompAsset.Height != newAsset.Height || origCompAsset.Width != newAsset.Width)
				{
					return AssetChangeType.Resolution;
				}
				if (origCompAsset.TilingMethod != newAsset.TilingMethod)
				{
					return AssetChangeType.Resolution;
				}
				if (compositedLayerConfig.Layers.Count != newAsset.AssetLayers.Count)
				{
					return AssetChangeType.Resolution;
				}
				return AssetChangeType.None;
			}

			public static AssetChangeType GetAssetChangesLayer(Project project, Asset origCompAsset, LayerConfig compositedLayerConfig, Asset newAsset, int layer)
			{
				if (origCompAsset.AssetLayers[layer].TargetWidth != newAsset.AssetLayers[layer].TargetWidth || origCompAsset.AssetLayers[layer].TargetHeight != newAsset.AssetLayers[layer].TargetHeight)
				{
					return AssetChangeType.Resolution;
				}
				if (origCompAsset.AssetLayers[layer].MipSourceType != newAsset.AssetLayers[layer].MipSourceType)
				{
					return AssetChangeType.Data;
				}
				if (origCompAsset.AssetLayers[layer].ColorSpace != newAsset.AssetLayers[layer].ColorSpace)
				{
					return AssetChangeType.Data;
				}
				if (origCompAsset.AssetLayers[layer].Flip != newAsset.AssetLayers[layer].Flip)
				{
					return AssetChangeType.Data;
				}
				for (int i = 0; i < 4; i++)
				{
					if (origCompAsset.AssetLayers[layer].Swizzle[i] != newAsset.AssetLayers[layer].Swizzle[i])
					{
						return AssetChangeType.Data;
					}
					if (origCompAsset.AssetLayers[layer].InvertChannels[i] != newAsset.AssetLayers[layer].InvertChannels[i])
					{
						return AssetChangeType.Data;
					}
				}
				if (origCompAsset.AssetLayers[layer].PackingMode != newAsset.AssetLayers[layer].PackingMode)
				{
					return AssetChangeType.Data;
				}
				if (origCompAsset.AssetLayers[layer].Textures.Count() != newAsset.AssetLayers[layer].Textures.Count())
				{
					return AssetChangeType.Data;
				}
				for (int j = 0; j < origCompAsset.AssetLayers[layer].Textures.Count(); j++)
				{
					Texture texture = origCompAsset.AssetLayers[layer].Textures[j];
					Texture texture2 = newAsset.AssetLayers[layer].Textures[j];
					if (texture.Source != texture2.Source)
					{
						return AssetChangeType.Data;
					}
					if (texture.Height != texture2.Height)
					{
						return AssetChangeType.Data;
					}
					if (texture.Width != texture2.Width)
					{
						return AssetChangeType.Data;
					}
					if (texture.Column != texture2.Column)
					{
						return AssetChangeType.Data;
					}
					if (texture.Row != texture2.Row)
					{
						return AssetChangeType.Data;
					}
					if (texture.SubIndex != texture2.SubIndex)
					{
						return AssetChangeType.Data;
					}
					if (texture.NumChannels != texture2.NumChannels)
					{
						return AssetChangeType.Data;
					}
					if (!DateTimeManagement.SameTimeMs(texture.LastChangedDate, texture2.LastChangedDate))
					{
						return AssetChangeType.Data;
					}
				}
				return AssetChangeType.None;
			}

			public static AssetChangeType GetAssetChanges(Project project, Asset origCompAsset, LayerConfig compositedLayerConfig, SoupState soupState, Asset newAsset)
			{
				AssetChangeType assetChangesGeneral = GetAssetChangesGeneral(project, origCompAsset, compositedLayerConfig, newAsset);
				if (assetChangesGeneral != 0)
				{
					return assetChangesGeneral;
				}
				for (int i = 0; i < origCompAsset.AssetLayers.Count(); i++)
				{
					AssetChangeType assetChangesLayer = GetAssetChangesLayer(project, origCompAsset, compositedLayerConfig, newAsset, i);
					if (assetChangesLayer != 0)
					{
						return assetChangesLayer;
					}
				}
				if (soupState == null || compositedLayerConfig == null)
				{
					return AssetChangeType.Codec;
				}
				if (compositedLayerConfig.Layers.Count != newAsset.AssetLayers.Count)
				{
					return AssetChangeType.Codec;
				}
				if (soupState.LayerConfig.Layers.Count != newAsset.AssetLayers.Count)
				{
					return AssetChangeType.Codec;
				}
				for (int j = 0; j < origCompAsset.AssetLayers.Count(); j++)
				{
					string y = CodingProfileHelper.ResolveDefaultQualityProfile(project, newAsset.AssetLayers[j].QualityProfile, project.LayerConfiguration.Layers[j].CodingProfile, project.LayerConfiguration.Layers[j].QualityProfile, project.LayerConfiguration.Layers[j].DataType);
					if (!StringsEqualOrNull(CodingProfileHelper.ResolveDefaultQualityProfile(project, origCompAsset.AssetLayers[j].QualityProfile, compositedLayerConfig.Layers[j].CodingProfile, compositedLayerConfig.Layers[j].QualityProfile, compositedLayerConfig.Layers[j].DataType), y))
					{
						return AssetChangeType.Codec;
					}
				}
				if (origCompAsset.Name != newAsset.Name)
				{
					return AssetChangeType.MetaData;
				}
				return AssetChangeType.None;
			}
		}

		public Dictionary<Guid, CompositeState> CompositeStates { get; private set; }

		public Dictionary<Guid, SoupState> SoupStates { get; private set; }

		public BuilderSummary BuilderSummary { get; set; }

		public Dictionary<Guid, BuildAsset> BuildAssets { get; set; }

		public Guid ProjectId { get; set; }

		public ProjectBuilder ProjectBuilder { get; private set; }

		public Version ProjectVersion { get; set; }

		public TileSetConfig TileSetConfiguration { get; set; }

		public LayerConfig BuildLayerConfiguration { get; set; }

		public LayerConfig LayerConfiguration2 { get; set; }

		public FixedTexFormat[] LayerFixedTexFormats { get; set; }

		public Dictionary<Guid, IncrementalBuildState> IncrementalStates { get; private set; }

		public BuildState(Guid projectId, ProjectBuilder builder)
		{
			Initialize();
			ProjectId = projectId;
			ProjectBuilder = builder;
		}

		public BuildState(ProjectBuilder builder)
		{
			Initialize();
			ProjectBuilder = builder;
		}

		public void Initialize()
		{
			BuildAssets = new Dictionary<Guid, BuildAsset>();
			CompositeStates = new Dictionary<Guid, CompositeState>();
			SoupStates = new Dictionary<Guid, SoupState>();
			IncrementalStates = new Dictionary<Guid, IncrementalBuildState>();
		}

		public void CheckChanges()
		{
			Project activeProject = ProjectBuilder.ActiveProject;
			foreach (Asset value2 in activeProject.Assets.Values)
			{
				if (!AssetTools.IsRootAsset(activeProject, value2) || IsSoupFileValid(value2))
				{
					continue;
				}
				CompositeState compositeState = FindAssetCompositeState(value2.Id);
				if (compositeState == null)
				{
					continue;
				}
				compositeState.ChangesDict = new Dictionary<Guid, AssetChangeType>();
				foreach (Guid key in compositeState.Assets.Keys)
				{
					if (activeProject.Assets.TryGetValue(key, out var _))
					{
						if (!compositeState.Assets.ContainsKey(key))
						{
							compositeState.ChangesDict.Add(key, AssetChangeType.Added);
						}
						else
						{
							SoupState soupState = FindAssetSoupState(value2.Id);
							AssetChangeType assetChanges = BuildStateTools.GetAssetChanges(activeProject, compositeState.Assets[value2.Id], compositeState.LayerConfig, soupState, value2);
							compositeState.ChangesDict.Add(key, assetChanges);
						}
					}
					else
					{
						compositeState.ChangesDict.Add(key, AssetChangeType.Deleted);
					}
					if (compositeState.ChangesDict[key] == AssetChangeType.None)
					{
						compositeState.ChangesDict.Remove(key);
					}
				}
			}
		}

		public bool ComposeLayerHasChanged(Asset asset, int layer)
		{
			Project activeProject = ProjectBuilder.ActiveProject;
			CompositeState compositeState = FindAssetCompositeState(asset.Id);
			if (compositeState == null)
			{
				return true;
			}
			if (!activeProject.Assets.Keys.Contains(asset.Id))
			{
				return true;
			}
			if (!compositeState.Assets.ContainsKey(asset.Id))
			{
				return true;
			}
			if (BuildStateTools.GetAssetChangesGeneral(activeProject, compositeState.Assets[asset.Id], compositeState.LayerConfig, asset) != 0)
			{
				return true;
			}
			if (BuildStateTools.GetAssetChangesLayer(activeProject, compositeState.Assets[asset.Id], compositeState.LayerConfig, asset, layer) != 0)
			{
				return true;
			}
			return false;
		}

		public List<Guid> GetChangedAssetKeys(AssetChangeType type)
		{
			List<Guid> list = new List<Guid>();
			foreach (CompositeState value in CompositeStates.Values)
			{
				CheckChanges();
				foreach (Guid key in value.ChangesDict.Keys)
				{
					if (value.ChangesDict[key] == type)
					{
						list.Add(key);
					}
				}
			}
			return list;
		}

		public AssetChangeType IsAssetChanged(Asset asset)
		{
			if (IsSoupFileValid(asset))
			{
				return AssetChangeType.None;
			}
			CompositeState compositeState = FindAssetCompositeState(asset.Id);
			if (compositeState == null)
			{
				return AssetChangeType.Added;
			}
			if (compositeState.ChangesDict.ContainsKey(asset.Id))
			{
				return compositeState.ChangesDict[asset.Id];
			}
			return AssetChangeType.None;
		}

		public void Update(AssetChangeType type)
		{
			foreach (Asset value in ProjectBuilder.ActiveProject.Assets.Values)
			{
				Update(value.Id, type);
			}
		}

		public void Update(Guid assetId, AssetChangeType type)
		{
			if (type == AssetChangeType.None)
			{
				return;
			}
			CompositeState compositeState = FindAssetCompositeState(assetId);
			if (compositeState == null)
			{
				return;
			}
			CheckChanges();
			List<Guid> list = new List<Guid>();
			foreach (Guid key in compositeState.ChangesDict.Keys)
			{
				if (compositeState.ChangesDict[key] == type)
				{
					list.Add(key);
				}
			}
			foreach (Guid item in list)
			{
				compositeState.ChangesDict.Remove(item);
			}
		}

		public bool AtlasRequired(Project project)
		{
			foreach (Asset value in project.Assets.Values)
			{
				if (AtlasRequired(value))
				{
					return true;
				}
			}
			return false;
		}

		public bool AtlasRequired(Asset asset)
		{
			if (!CodeRequired(asset))
			{
				return false;
			}
			CompositeState compositeState = FindAssetCompositeState(asset.Id);
			if (compositeState == null || compositeState.PackingSummary == null)
			{
				return true;
			}
			CheckChanges();
			using (Dictionary<Guid, AssetChangeType>.ValueCollection.Enumerator enumerator = compositeState.ChangesDict.Values.GetEnumerator())
			{
				while (enumerator.MoveNext())
				{
					switch (enumerator.Current)
					{
					case AssetChangeType.Added:
					case AssetChangeType.Deleted:
					case AssetChangeType.Resolution:
					case AssetChangeType.Data:
						return true;
					}
				}
			}
			return false;
		}

		public bool PartialComposePossible(Asset asset)
		{
			Project activeProject = ProjectBuilder.ActiveProject;
			CompositeState compositeState = FindAssetCompositeState(asset.Id);
			if (compositeState == null)
			{
				return false;
			}
			CheckChanges();
			CompositorSummary compositorSummary = compositeState.CompositorSummary;
			if (compositorSummary == null || compositorSummary.LastChangedDate == default(DateTime))
			{
				return false;
			}
			if (compositeState.CompositedList == null || compositeState.CompositedList.Count() == 0)
			{
				return false;
			}
			if (compositeState.TileSetConfig == null)
			{
				return false;
			}
			if (compositorSummary.LastChangedDate < compositeState.TileSetConfig.LastChangedDate)
			{
				return false;
			}
			if (!activeProject.BuildConfiguration.IsCompatibleWithTileLayout(compositeState.TileSetConfig.TileLayout))
			{
				return false;
			}
			LayerConfig layerConfig = compositeState.LayerConfig;
			if (layerConfig == null || !layerConfig.IsEqual(activeProject, activeProject.LayerConfiguration))
			{
				return false;
			}
			using (Dictionary<Guid, AssetChangeType>.ValueCollection.Enumerator enumerator = compositeState.ChangesDict.Values.GetEnumerator())
			{
				while (enumerator.MoveNext())
				{
					switch (enumerator.Current)
					{
					case AssetChangeType.Added:
					case AssetChangeType.Deleted:
					case AssetChangeType.Resolution:
						return false;
					}
				}
			}
			Asset asset2 = FindCompositedImportedAsset(asset);
			if (asset2 == null)
			{
				return false;
			}
			if (BuildStateTools.GetAssetChangesGeneral(activeProject, compositeState.Assets[asset.Id], compositeState.LayerConfig, asset) != 0)
			{
				return false;
			}
			for (int i = 0; i < asset2.AssetLayers.Count(); i++)
			{
				AssetChangeType assetChangesLayer = BuildStateTools.GetAssetChangesLayer(activeProject, asset2, compositeState.LayerConfig, asset, i);
				if (assetChangesLayer != AssetChangeType.Data && assetChangesLayer != 0)
				{
					return false;
				}
			}
			return true;
		}

		public bool PartialCodingPossible(Asset asset, out List<int> identicalLayers)
		{
			identicalLayers = new List<int>();
			if (IncrementalStates.Keys.Contains(asset.Id))
			{
				identicalLayers.AddRange(IncrementalStates[asset.Id].IdenticalLayers);
				return IncrementalStates[asset.Id].IncrementalBuildPossible;
			}
			return false;
		}

		public bool ComposeRequired(Asset asset)
		{
			Project activeProject = ProjectBuilder.ActiveProject;
			if (!CodeRequired(asset))
			{
				return false;
			}
			CompositeState compositeState = FindAssetCompositeState(asset.Id);
			if (compositeState == null)
			{
				return true;
			}
			CheckChanges();
			CompositorSummary compositorSummary = compositeState.CompositorSummary;
			if (compositorSummary == null || compositorSummary.LastChangedDate == default(DateTime))
			{
				return true;
			}
			if (compositeState.CompositedList == null || compositeState.CompositedList.Count() == 0)
			{
				return true;
			}
			if (compositeState.TileSetConfig == null)
			{
				return true;
			}
			if (compositorSummary.LastChangedDate < compositeState.TileSetConfig.LastChangedDate)
			{
				return true;
			}
			if (!activeProject.BuildConfiguration.IsCompatibleWithTileLayout(compositeState.TileSetConfig.TileLayout))
			{
				return true;
			}
			LayerConfig layerConfig = compositeState.LayerConfig;
			if (layerConfig == null)
			{
				return true;
			}
			if (!layerConfig.CompatibleForCompositing(activeProject, activeProject.LayerConfiguration))
			{
				return true;
			}
			using (Dictionary<Guid, AssetChangeType>.ValueCollection.Enumerator enumerator = compositeState.ChangesDict.Values.GetEnumerator())
			{
				while (enumerator.MoveNext())
				{
					switch (enumerator.Current)
					{
					case AssetChangeType.Added:
					case AssetChangeType.Deleted:
					case AssetChangeType.Resolution:
					case AssetChangeType.Data:
						return true;
					}
				}
			}
			return false;
		}

		public bool AreSourceFilesChanged(Project project, Asset asset)
		{
			if (project.builder.BuildStateSummary != null && project.builder.BuildStateSummary.AssetStates.ContainsKey(asset.Id))
			{
				if (project.builder.BuildStateSummary.AssetStates[asset.Id].Changes != 0)
				{
					return true;
				}
				foreach (KeyValuePair<int, LayerAssetState> layerState in project.builder.BuildStateSummary.AssetStates[asset.Id].LayerStates)
				{
					if (layerState.Value.Changes != 0 && layerState.Value.Changes != CausingChanges.InputFailed)
					{
						return true;
					}
				}
			}
			return false;
		}

		public SoupState ReReadSoupState(Asset asset)
		{
			Project activeProject = ProjectBuilder.ActiveProject;
			if (!AssetTools.IsRootAsset(activeProject, asset))
			{
				return null;
			}
			string soupFilePath = GetSoupFilePath(activeProject, asset);
			if (!File.Exists(soupFilePath))
			{
				return null;
			}
			try
			{
				return SoupTools.ReadSoupStateAndRegisterWithBuildState(ProjectBuilder, soupFilePath, ProjectBuilder.State);
			}
			catch
			{
				return null;
			}
		}

		public bool IsSoupFileValid(Asset asset)
		{
			Project activeProject = ProjectBuilder.ActiveProject;
			SoupState soupState = FindAssetSoupState(asset.Id);
			if (soupState == null)
			{
				soupState = ReReadSoupState(asset);
				if (soupState == null)
				{
					return false;
				}
			}
			if (!ProjectBuilder.AllowForeignGTex && soupState.ProjectId != activeProject.Id)
			{
				return false;
			}
			if (soupState.LayerConfig == null)
			{
				return false;
			}
			if (!soupState.LayerConfig.CompatibleForCoding(activeProject, activeProject.LayerConfiguration))
			{
				return false;
			}
			if (!activeProject.BuildConfiguration.IsCompatibleWithTileLayout(soupState.TileLayout))
			{
				return false;
			}
			if (!ProjectBuilder.ForceUseGTex)
			{
				foreach (Asset value2 in soupState.Assets.Values)
				{
					if (!activeProject.Assets.TryGetValue(value2.Id, out var value))
					{
						return false;
					}
					if (BuildStateTools.GetAssetChanges(activeProject, value2, soupState.LayerConfig, soupState, value) != 0)
					{
						return false;
					}
					if (AreSourceFilesChanged(activeProject, value))
					{
						return false;
					}
				}
			}
			return true;
		}

		public bool CodeRequired(Asset asset)
		{
			if (!IsSoupFileValid(asset))
			{
				return true;
			}
			return false;
		}

		public bool BuildRequired()
		{
			bool checkGTSBuildMode = false;
			bool existingGTSbuiltForGTexStreaming;
			return BuildRequired(checkGTSBuildMode, BuildMode.BuildForGTP, out existingGTSbuiltForGTexStreaming);
		}

		public bool BuildRequired(bool checkGTSBuildMode, BuildMode buildMode, out bool existingGTSbuiltForGTexStreaming)
		{
			Project activeProject = ProjectBuilder.ActiveProject;
			existingGTSbuiltForGTexStreaming = false;
			if (BuilderSummary == null)
			{
				return true;
			}
			try
			{
				string gtsFileName = activeProject.BuildConfiguration.GetGtsFileName();
				if (!File.Exists(gtsFileName))
				{
					return true;
				}
				if (!DateTimeManagement.SameTimeMs(DateTimeManagement.Round(File.GetLastWriteTime(gtsFileName)), BuilderSummary.LastChangedDate))
				{
					return true;
				}
				GtsInfo info = default(GtsInfo);
				if (GTSBuilderTools.GetGtsInfo(gtsFileName, out info) != 0)
				{
					return true;
				}
				existingGTSbuiltForGTexStreaming = info.type == TileFileType.GTS_WITH_GTEX;
				bool flag = buildMode == BuildMode.BuildForGTex;
				if (checkGTSBuildMode && existingGTSbuiltForGTexStreaming != flag)
				{
					return true;
				}
				if (!GTSBuilderTools.GetGTPFiles(gtsFileName, out var gtpFilenames))
				{
					return true;
				}
				foreach (string item in gtpFilenames)
				{
					if (!File.Exists(Path.Combine(Path.GetFullPath(activeProject.BuildConfiguration.OutputDirectory), item)))
					{
						return true;
					}
				}
			}
			catch
			{
				return true;
			}
			if (activeProject.BuildConfiguration.PageSize != 0 && BuilderSummary.PageSize != activeProject.BuildConfiguration.PageSize)
			{
				return true;
			}
			if ((activeProject.BuildConfiguration.PageSize == 0 && !BuilderSummary.AutoPageSize) || (activeProject.BuildConfiguration.PageSize != 0 && BuilderSummary.AutoPageSize))
			{
				return true;
			}
			if (BuilderSummary.AutoPageSize && BuilderSummary.BlockSize != activeProject.BuildConfiguration.BlockSize)
			{
				return true;
			}
			if (activeProject.BuildConfiguration.TargetDisk != BuilderSummary.TargetDisk)
			{
				return true;
			}
			PagingStrategy pagingStrategy = ProfileLoader.ResolvePagingStrategy(activeProject.BuildConfiguration.PagingStrategy, activeProject.BuildProfile);
			if (BuilderSummary.PagingStrategy != pagingStrategy)
			{
				return true;
			}
			if (activeProject.BuildConfiguration.PagesDirectory != BuilderSummary.PagesDirectory)
			{
				return true;
			}
			if (BuildAssets.Count != activeProject.Assets.Count)
			{
				return true;
			}
			foreach (Asset value in activeProject.Assets.Values)
			{
				if (!BuildAssets.ContainsKey(value.Id))
				{
					return true;
				}
			}
			foreach (BuildAsset value2 in BuildAssets.Values)
			{
				if (!activeProject.Assets.ContainsKey(value2.AssetId))
				{
					return true;
				}
			}
			foreach (Asset value3 in activeProject.Assets.Values)
			{
				if (!IsSoupFileValid(value3))
				{
					return true;
				}
			}
			foreach (SoupState value4 in SoupStates.Values)
			{
				if (value4.SoupedAssets == null)
				{
					continue;
				}
				foreach (SoupedAsset value5 in value4.SoupedAssets.Values)
				{
					if (value5.SoupedDate > BuilderSummary.LastChangedDate)
					{
						return true;
					}
					if (!BuildAssets.ContainsKey(value5.AssetId))
					{
						return true;
					}
					BuildAsset buildAsset = BuildAssets[value5.AssetId];
					if (buildAsset == null)
					{
						return true;
					}
					if (ProjectBuilder.ForceUseGTex)
					{
						if (value5.SoupedDate != buildAsset.GTexLastChangeDate)
						{
							return true;
						}
					}
					else if (value5.SoupedDate > buildAsset.GTexLastChangeDate)
					{
						return true;
					}
				}
			}
			return false;
		}

		public CompositeState FindAssetCompositeState(Guid assetId)
		{
			foreach (CompositeState value in CompositeStates.Values)
			{
				foreach (PackedAsset packedAsset in value.PackedAssets)
				{
					if (packedAsset.AssetId == assetId)
					{
						return value;
					}
				}
			}
			return null;
		}

		public bool AssetBuiltIncrementally(Guid assetId)
		{
			if (IncrementalStates.ContainsKey(assetId))
			{
				if (IncrementalStates[assetId].IncrementalBuildPossible)
				{
					return IncrementalStates[assetId].IdenticalLayers.Count > 0;
				}
				return false;
			}
			return false;
		}

		public CompositeState CreateAssetCompositeState(Guid assetId)
		{
			CompositeStates[assetId] = new CompositeState();
			CompositeStates[assetId].AssetId = assetId;
			return CompositeStates[assetId];
		}

		public SoupState FindAssetSoupState(Guid assetId)
		{
			foreach (SoupState value in SoupStates.Values)
			{
				foreach (SoupedAsset value2 in value.SoupedAssets.Values)
				{
					if (value2.AssetId == assetId)
					{
						return value;
					}
				}
			}
			return null;
		}

		public SoupState CreateAssetSoupState(Project project, Guid assetId)
		{
			SoupStates[assetId] = new SoupState();
			SoupStates[assetId].AssetId = assetId;
			SoupStates[assetId].ProjectId = project.Id;
			return SoupStates[assetId];
		}

		public PackedAsset FindPackedAsset(Guid assetId)
		{
			foreach (CompositeState value in CompositeStates.Values)
			{
				foreach (PackedAsset packedAsset in value.PackedAssets)
				{
					if (packedAsset.AssetId == assetId)
					{
						return packedAsset;
					}
				}
			}
			return null;
		}

		public CompositedAsset FindCompositedAsset(Asset asset)
		{
			Guid id = AssetTools.GetRootAsset(ProjectBuilder.ActiveProject, asset).Id;
			if (!CompositeStates.Keys.Contains(id))
			{
				return null;
			}
			foreach (CompositedAsset composited in CompositeStates[id].CompositedList)
			{
				if (composited.AssetId == asset.Id)
				{
					return composited;
				}
			}
			return null;
		}

		public Asset FindCompositedImportedAsset(Asset asset)
		{
			Guid id = AssetTools.GetRootAsset(ProjectBuilder.ActiveProject, asset).Id;
			if (!CompositeStates.Keys.Contains(id))
			{
				return null;
			}
			foreach (Asset value in CompositeStates[id].Assets.Values)
			{
				if (value.Id == asset.Id)
				{
					return value;
				}
			}
			return null;
		}

		public Rectangle GetTileLevelRange(CompositedAsset casset, int level)
		{
			return TileTools.GetTileLevelRange(TileSetConfiguration, new Rectangle(casset.X, casset.Y, casset.Width, casset.Height), level);
		}

		public Rectangle GetTileLevelRange(PackedAsset passet, int level)
		{
			return TileTools.GetTileLevelRange(TileSetConfiguration, new Rectangle(passet.X, passet.Y, passet.Width, passet.Height), level);
		}

		public Rectangle GetTileLevelRange(Rectangle pixelRectangle, int level)
		{
			return TileTools.GetTileLevelRange(TileSetConfiguration, pixelRectangle, level);
		}

		public static string GetSoupDirectory(Project project, Asset asset)
		{
			return project.BuildConfiguration.SoupOutputDirectory;
		}

		public static string GetSoupFilePath(Project project, Asset asset)
		{
			string text = asset.NameIOFriendly;
			if (asset.Type == AssetType.CubeMap)
			{
				text = AssetTools.GetIOFriendlyAssetName(AssetImporterProcess.GenerateCubemapNameFromFaceAsset(asset.Name));
			}
			return Path.Combine(GetSoupDirectory(project, asset), text + Constants.SoupFileExtension);
		}

		public static string GetSoupStagingDirectory(ProjectBuilder builder, Asset asset)
		{
			return Path.Combine(new string[3]
			{
				builder.StagingConfigurationDirectory,
				Constants.StageDirName,
				builder.ActiveProject.Name
			});
		}

		public static string GetSoupStagingFileName(ProjectBuilder builder, Asset asset)
		{
			string text = asset.NameIOFriendly;
			if (asset.Type == AssetType.CubeMap)
			{
				text = AssetTools.GetIOFriendlyAssetName(AssetImporterProcess.GenerateCubemapNameFromFaceAsset(asset.Name));
			}
			return Path.Combine(GetSoupStagingDirectory(builder, asset), text + Constants.SoupFileExtension);
		}

		public static string GetRasterStateFilename(ProjectBuilder builder, Asset asset)
		{
			return Path.Combine(builder.StagingConfigurationDirectory, asset.NameIOFriendly + ".state.xml");
		}

		public static List<string> GetAllRasterStateFileNames(ProjectBuilder builder)
		{
			List<string> list = new List<string>();
			foreach (Asset value in builder.ActiveProject.Assets.Values)
			{
				list.Add(GetRasterStateFilename(builder, value));
			}
			return list;
		}

		public void SaveCompositorState(ProjectBuilder builder, Asset asset)
		{
			XMLEngine.WriteBuildStateComposer(GetRasterStateFilename(builder, asset), this, asset);
		}

		public static void TranslateSoupStateToThisProject(ProjectBuilder builder, SoupState soupState)
		{
			Project activeProject = builder.ActiveProject;
			Dictionary<string, Guid> dictionary = new Dictionary<string, Guid>();
			foreach (Asset value in activeProject.Assets.Values)
			{
				dictionary.Add(value.Name, value.Id);
			}
			soupState.ProjectId = builder.ActiveProject.Id;
			List<Asset> list = soupState.Assets.Values.ToList();
			for (int i = 0; i < list.Count; i++)
			{
				Asset asset = list[i];
				Guid id = asset.Id;
				Guid guid = (dictionary.ContainsKey(asset.Name) ? dictionary[asset.Name] : id);
				if (dictionary.ContainsKey(asset.Name))
				{
					asset.Id = guid;
				}
				Collections.ChangeDictionaryKey(soupState.Assets, id, guid);
				Collections.ChangeDictionaryKey(soupState.SoupedAssets, id, guid);
				if (asset.Face == 0)
				{
					soupState.AssetId = asset.Id;
				}
			}
			foreach (Guid key in soupState.SoupedAssets.Keys)
			{
				soupState.SoupedAssets[key].AssetId = key;
			}
		}
	}
	internal class CompositeAndCodeSummary
	{
		public DateTime LastChangedDate { get; set; }
	}
	internal class CompositeAndCodeProcess : IPipelineProcess
	{
		private PipelineProcessResult latestResult;

		public ProjectBuilder ProjectBuilder { get; private set; }

		public PipelineProcessResult LatestResult => latestResult;

		public bool HasRun { get; private set; }

		public DateTime LastRun { get; private set; }

		public CompositeAndCodeProcess(ProjectBuilder builder)
		{
			ProjectBuilder = builder;
			HasRun = false;
		}

		public PipelineProcessResult PreProcess()
		{
			latestResult = PipelineProcessResult.Success;
			return latestResult;
		}

		private bool CheckState(out string error)
		{
			_ = ProjectBuilder.ActiveProject;
			error = null;
			if (ProjectBuilder.State.TileSetConfiguration == null)
			{
				error = "No tile layout information can be found, please rebuild the project";
				return false;
			}
			return true;
		}

		private void TestSoupForGettingOverwritten(Asset asset)
		{
			string soupFilePath = BuildState.GetSoupFilePath(ProjectBuilder.ActiveProject, asset);
			if (File.Exists(soupFilePath))
			{
				bool isValidSoupFile = false;
				if (!SoupTools.IsSoupFileBuiltForThisProject(ProjectBuilder, asset, soupFilePath, out isValidSoupFile) && isValidSoupFile)
				{
					string fileName = Path.GetFileName(soupFilePath);
					string message = "GTex file '" + fileName + "' was built for a different project and will be overwritten by this project. Make sure GTex files are saved to a folder not used by any other project.";
					ProjectBuilder.BuildReportingHandler.OnWarning(BuildProcess.TileSoupBuilder, new TileSoupBuilderIssue(message));
				}
			}
		}

		public PipelineProcessResult Process()
		{
			ProjectBuilder.ProgressTracker.StartTask(SlowTask.ComposeAndCodeProcess);
			Project activeProject = ProjectBuilder.ActiveProject;
			ProjectBuilder.logger.LogTitle("Compositing and coding assets...", Logger.Verbosity.Normal);
			if (ProjectBuilder.ProfilingEnabled)
			{
				ProjectBuilder.logger.LogConsole("Compose all assets", Logger.Verbosity.Quiet);
			}
			if (ProjectBuilder.ActiveProject.LayerConfiguration == null)
			{
				latestResult = PipelineProcessResult.Failed;
				return latestResult;
			}
			ProjectBuilder.State.IncrementalStates.Clear();
			using (NixelContextManager nixelContextManager = new NixelContextManager())
			{
				try
				{
					DateTime now = DateTime.Now;
					if (!CheckState(out var error))
					{
						throw new CompositorException(error);
					}
					uint num = 0u;
					foreach (Asset value in activeProject.Assets.Values)
					{
						if (AssetTools.IsRootAsset(activeProject, value))
						{
							num++;
						}
					}
					int num2 = 0;
					int num3 = 0;
					int count = activeProject.Assets.Count;
					foreach (Asset value2 in activeProject.Assets.Values)
					{
						ProjectBuilder.ProgressTracker.StartAsset(value2, num3, count);
						if (!AssetTools.IsRootAsset(activeProject, value2))
						{
							continue;
						}
						if (!ProjectBuilder.Canceled)
						{
							TestSoupForGettingOverwritten(value2);
							ProjectBuilder.ProgressTracker.StartTask(SlowTask.Composing);
							num2++;
							ProjectBuilder.ProgressTracker.UpdateProgress(0L, num, num2);
							object[] args = new object[3]
							{
								num2.ToString(),
								num.ToString(),
								value2.Name
							};
							string text = string.Format("({0}/{1}) '{2}' ... compositing ...", args);
							Console.Write(text, Logger.Verbosity.Normal);
							ProjectBuilder.logger.LogCurrentLine(text, Logger.Verbosity.Normal);
							new Compositor(ProjectBuilder).ProcessAsset(value2, nixelContextManager);
							ProjectBuilder.ProgressTracker.EndTask(SlowTask.Composing);
						}
						uint totalTileCount = CalculateNumTilesToProcess(value2, nixelContextManager);
						using (TileSoupBuilderProgressTracker tileSoupBuilderProgressTracker = new TileSoupBuilderProgressTracker(ProjectBuilder.TargetConfiguration, ProjectBuilder.ProgressTracker, ProjectBuilder, totalTileCount, value2, count, num3))
						{
							if (!AssetTools.IsRootAsset(ProjectBuilder.ActiveProject, value2))
							{
								continue;
							}
							if (!ProjectBuilder.Canceled)
							{
								TileSoupBuilder tileSoupBuilder = new TileSoupBuilder(ProjectBuilder);
								object[] args2 = new object[3]
								{
									num2.ToString(),
									num.ToString(),
									value2.Name
								};
								string text2 = string.Format("({0}/{1}) '{2}' ... compositing ... coding ...", args2);
								tileSoupBuilderProgressTracker.SetCurrentLogLine(text2 + " {0}%");
								ProjectBuilder.logger.LogCurrentLine(text2, Logger.Verbosity.Normal);
								ProjectBuilder.ProgressTracker.StartTask(SlowTask.Coding);
								if (!tileSoupBuilder.ProcessAsset(value2, tileSoupBuilderProgressTracker, nixelContextManager))
								{
									latestResult = PipelineProcessResult.Failed;
									return latestResult;
								}
								text2 = string.Format("({0}/{1}) '{2}' ... compositing ... coding ... done", args2);
								ProjectBuilder.logger.LogCurrentLine(text2, endWithNewLine: true, Logger.Verbosity.Normal);
								ProjectBuilder.ProgressTracker.EndTask(SlowTask.Coding);
							}
							goto IL_0342;
						}
						IL_0342:
						nixelContextManager.DestroyContext(value2.Id);
						num3++;
					}
					if (ProjectBuilder.ProfilingEnabled)
					{
						double num4 = Math.Truncate((DateTime.Now - now).TotalMilliseconds) / 1000.0;
						ProjectBuilder.logger.LogConsole("Done, elapsed time: " + num4 + " s", Logger.Verbosity.Quiet);
					}
				}
				catch (GrBuildException ex)
				{
					if (ex is FatalException)
					{
						ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.Compositor, new ComposeIssue(ex.Message));
					}
					latestResult = PipelineProcessResult.Failed;
					return latestResult;
				}
			}
			HasRun = true;
			LastRun = DateTimeManagement.Now();
			latestResult = PipelineProcessResult.Success;
			ProjectBuilder.ProgressTracker.EndTask(SlowTask.ComposeAndCodeProcess);
			return latestResult;
		}

		private uint CalculateNumTilesToProcess(Asset asset, NixelContextManager contextManager)
		{
			uint num = 0u;
			if (!AssetTools.IsRootAsset(ProjectBuilder.ActiveProject, asset))
			{
				return 0u;
			}
			NixelContext context = contextManager.GetContext(asset.Id);
			if (context != null)
			{
				List<int> identicalLayers;
				switch (TileSoupBuilder.GetSoupBuildTypeRequired(asset, ProjectBuilder, out identicalLayers))
				{
				case SoupBuildType.FullBuild:
				case SoupBuildType.IncrementalBuild:
				{
					new List<TileId>();
					for (uint num2 = 0u; num2 < context.TiledTopology.numLevels; num2++)
					{
						num += context.TiledTopology.GetLevelWidth(num2) * context.TiledTopology.GetLevelHeight(num2) * context.TiledTopology.numLayers;
					}
					break;
				}
				}
			}
			if (ProjectBuilder.TargetConfiguration == TargetConfiguration.Optimized)
			{
				num *= 2;
			}
			return num;
		}

		public bool DeleteSerializedFiles(CleanOperationParameters param)
		{
			List<Asset> assets = ProjectBuilder.ActiveProject.Assets.Values.ToList();
			return DeleteSerializedFiles(param, assets);
		}

		public bool DeleteSerializedFiles(CleanOperationParameters param, List<Asset> assets)
		{
			bool flag = true;
			if (param.intermediates)
			{
				flag = flag && Compositor.DeleteSerializedFiles(ProjectBuilder, assets);
			}
			if (param.soups)
			{
				flag = flag && TileSoupBuilder.DeleteSerializedFiles(ProjectBuilder, assets);
			}
			return flag;
		}

		public PipelineProcessResult PostProcess(PipelineProcessResult processResult)
		{
			return PipelineProcessResult.Success;
		}
	}
	public static class Defaults
	{
		private static TargetConfiguration defaultTargetConfiguration = TargetConfiguration.Optimized;

		private static uint maximumNixelCacheSize = 536870912u;

		private static uint minimumNixelCacheSize = 16777216u;

		private static uint defaultPageSize = 0u;

		private static uint defaultWarningLevel = 1u;

		private static Logger.Verbosity defaultVerbosity = Logger.Verbosity.Normal;

		private static uint defaultAniso = 8u;

		private static TilingMode defaultTilingMode = TilingMode.Software;

		private static uint defaultTileSize = 128u;

		private static uint defaultTileWidth = 0u;

		private static uint defaultTileHeight = 0u;

		private static BuildProfile defaultBuildprofile = null;

		private static uint blocksize = 4096u;

		private static TextureMipSourceType defaultMipSourceType = TextureMipSourceType.Generated;

		private static TargetDisk defaultTargetDisk = TargetDisk.Default;

		private static CleanOperationParameters defaultCleanOperationParams = CleanOperationParameters.AllButTileSet;

		public static TargetConfiguration TargetConfiguration
		{
			get
			{
				return defaultTargetConfiguration;
			}
			set
			{
				defaultTargetConfiguration = value;
			}
		}

		public static uint NixelMaximumCacheSize
		{
			get
			{
				return maximumNixelCacheSize;
			}
			set
			{
				maximumNixelCacheSize = value;
			}
		}

		public static uint NixelMinimumCacheSize
		{
			get
			{
				return minimumNixelCacheSize;
			}
			set
			{
				minimumNixelCacheSize = value;
			}
		}

		public static uint PageSize
		{
			get
			{
				return defaultPageSize;
			}
			set
			{
				defaultPageSize = value;
			}
		}

		public static uint WarningLevel
		{
			get
			{
				return defaultWarningLevel;
			}
			set
			{
				defaultWarningLevel = value;
			}
		}

		public static Logger.Verbosity Verbosity
		{
			get
			{
				return defaultVerbosity;
			}
			set
			{
				defaultVerbosity = value;
			}
		}

		public static uint Aniso
		{
			get
			{
				return defaultAniso;
			}
			set
			{
				defaultAniso = value;
			}
		}

		public static uint TileSize
		{
			get
			{
				return defaultTileSize;
			}
			set
			{
				defaultTileSize = value;
			}
		}

		public static uint TileWidth
		{
			get
			{
				return defaultTileWidth;
			}
			set
			{
				defaultTileWidth = value;
			}
		}

		public static uint TileHeight
		{
			get
			{
				return defaultTileHeight;
			}
			set
			{
				defaultTileHeight = value;
			}
		}

		public static TilingMode TilingMode
		{
			get
			{
				return defaultTilingMode;
			}
			set
			{
				defaultTilingMode = value;
			}
		}

		public static BuildProfile DefaultBuildProfile
		{
			get
			{
				if (defaultBuildprofile == null)
				{
					ProfileLoader.LoadBuildProfile("default", out defaultBuildprofile);
				}
				return defaultBuildprofile;
			}
		}

		public static uint BlockSize
		{
			get
			{
				return blocksize;
			}
			set
			{
				blocksize = value;
			}
		}

		public static TextureMipSourceType TextureMipSourceType
		{
			get
			{
				return defaultMipSourceType;
			}
			set
			{
				defaultMipSourceType = value;
			}
		}

		public static TargetDisk TargetDisk
		{
			get
			{
				return defaultTargetDisk;
			}
			set
			{
				defaultTargetDisk = value;
			}
		}

		public static CleanOperationParameters CleanOperationParameters
		{
			get
			{
				return defaultCleanOperationParams;
			}
			set
			{
				defaultCleanOperationParams = value;
			}
		}
	}
	public static class Constants
	{
		public class GrBuildVersion
		{
			private Version nixelBuildVersion;

			private string nixelBuildInfo;

			public Version ProjectCompatibilityVersion => new Version(GrBuildProjectVersionMajor, GrBuildProjectVersionMinor);

			public Version BuildVersion => nixelBuildVersion;

			public string BuildInfo => nixelBuildInfo;

			public GrBuildVersion()
			{
				NixelTools.GetNixelVersion(out nixelBuildVersion, out nixelBuildInfo);
			}

			public override string ToString()
			{
				return string.Format("Build version: {0}, project compatibility version: {1}, build info: {2}", new object[3]
				{
					nixelBuildVersion.ToString(),
					ProjectCompatibilityVersion.ToString(),
					nixelBuildInfo
				});
			}
		}

		private static readonly int GrBuildProjectVersionMajor = 2;

		private static readonly int GrBuildProjectVersionMinor = 16;

		private static readonly string stateDirName = ".\\GrBuildState";

		private static readonly string stageDirName = ".\\Staging";

		private static readonly string defaultSoupDirectory = ".";

		private static readonly string defaultPagefileDirectory = "";

		private static readonly uint hardwareTileByteSize = 65536u;

		private static readonly string rasterDataCacheExtension = "_cache.dat";

		private static readonly string rasterDataCacheIndexExtension = "_cache.dat.idx";

		private static readonly string buildStateExtension = "_build.state";

		private static readonly string soupFileExtension = ".gtex";

		private static readonly string sharedMipRasterFilename = "sharedmips-4d21-9930-75128e9d937e";

		private static readonly string defaultBuildProfile = "default";

		private static readonly string solutionExtension = "grsln";

		private static readonly string projectExtension = "grproj";

		private static readonly int grimMaximumResizingSize = 32768;

		private static readonly int maxLayers = 4;

		private static readonly int maxUDimVerticalPatches = ImportTemplateInfo.MaxUDimVerticalPatches;

		private static readonly Int2 maxAtlasSize = new Int2(262144, 262144);

		public static Int2 maxLicensedAtlasSize = maxAtlasSize;

		private static readonly Int2 maxAtlasSizeInTiles = new Int2(2048, 2048);

		public static Int2 fixedTileSize = new Int2(0, 0);

		public static bool lightmapMode = false;

		public static bool allowDeprecatedCodingProfiles = false;

		public const int NumChannelMixingMax = 4;

		private static readonly Version compatibleWith = new Version(5, 0);

		private static readonly Dictionary<int, FixedTexFormat> codecFixedFormats = new Dictionary<int, FixedTexFormat>
		{
			{
				0,
				FixedTexFormat.ANY
			},
			{
				1,
				FixedTexFormat.ANY
			},
			{
				2,
				FixedTexFormat.ANY
			},
			{
				3,
				FixedTexFormat.ANY
			},
			{
				4,
				FixedTexFormat.NOBC
			},
			{
				7,
				FixedTexFormat.ANY
			},
			{
				8,
				FixedTexFormat.ANY
			},
			{
				9,
				FixedTexFormat.Invalid
			},
			{
				10,
				FixedTexFormat.ANY
			}
		};

		public static GrBuildVersion Version => new GrBuildVersion();

		public static string StateDirName => stateDirName;

		public static string StageDirName => stageDirName;

		public static string DefaultSoupDirectory => defaultSoupDirectory;

		public static string DefaultPagefileDirectory => defaultPagefileDirectory;

		public static uint HardwareTileByteSize => hardwareTileByteSize;

		public static string RasterDataCacheExtension => rasterDataCacheExtension;

		public static string RasterDataCacheIndexExtension => rasterDataCacheIndexExtension;

		public static string BuildStateExtension => buildStateExtension;

		public static string SoupFileExtension => soupFileExtension;

		public static string SharedMipRasterFilename => sharedMipRasterFilename;

		public static Dictionary<int, FixedTexFormat> CodecFixedFormats => codecFixedFormats;

		public static string DefaultBuildProfile => defaultBuildProfile;

		public static string SolutionExtension => solutionExtension;

		public static string ProjectExtension => projectExtension;

		public static int GrimMaximumResizingSize => grimMaximumResizingSize;

		public static int MaxLayers => maxLayers;

		public static int MaxUDimVerticalPatches => maxUDimVerticalPatches;

		public static Int2 MaxAtlasSize => maxAtlasSize;

		public static Int2 MaxAtlasSizeInTiles => maxAtlasSizeInTiles;

		public static Int2 MaxLicensedAtlasSize => maxLicensedAtlasSize;

		public static Int2 FixedTileSize => fixedTileSize;

		public static bool LightmapMode => lightmapMode;

		public static bool AllowDeprecatedCodingProfiles => allowDeprecatedCodingProfiles;

		public static Version CompatibleWith => compatibleWith;

		public static FixedTexFormat GetFixedTexFormat(TextureFormat graniteFormat)
		{
			switch (graniteFormat)
			{
			case TextureFormat.R8G8B8A8:
			case TextureFormat.R16G16B16A16:
			case TextureFormat.R32G32B32A32:
				return FixedTexFormat.NOBC;
			case TextureFormat.BC1:
				return FixedTexFormat.BC1;
			case TextureFormat.BC3:
				return FixedTexFormat.BC3;
			case TextureFormat.BC4:
				return FixedTexFormat.BC4;
			case TextureFormat.BC5:
				return FixedTexFormat.BC5;
			case TextureFormat.BC6:
				return FixedTexFormat.BC6;
			case TextureFormat.BC7:
				return FixedTexFormat.BC7;
			case TextureFormat.ASTC4X4:
				return FixedTexFormat.ASTC4X4;
			case TextureFormat.ASTC8X8:
				return FixedTexFormat.ASTC8X8;
			default:
				return FixedTexFormat.Invalid;
			}
		}
	}
	[Obfuscation(Exclude = true, ApplyToMembers = true)]
	public enum ErrorAction
	{
		ForceContinue,
		Stop
	}
	[Obfuscation(Exclude = true, ApplyToMembers = true)]
	public enum BuildProcess
	{
		General,
		Import,
		Atlas,
		Coder,
		Compositor,
		TileFilePreprocessor,
		TileSoupBuilder,
		TileSetBuilder
	}
	public delegate void OnBuildFatalError(ProjectBuilder source, BuildProcess processId, BuildIssue buildIssue);
	public delegate ErrorAction OnBuildError(ProjectBuilder source, BuildProcess processId, BuildIssue buildIssue);
	public delegate void OnBuildWarning(ProjectBuilder source, BuildProcess processId, BuildIssue buildIssue);
	public delegate void OnBuildInfo(ProjectBuilder source, BuildProcess processId, BuildIssue buildIssue);
	public class ProjectBuilderReportingHandler
	{
		private ProjectBuilder builder;

		public ErrorAction DefaultErrorAction { get; set; }

		public event OnBuildFatalError OnFatalErrorHandler;

		public event OnBuildError OnErrorHandler;

		public event OnBuildWarning OnWarningHandler;

		public event OnBuildInfo OnInfoHandler;

		public ProjectBuilderReportingHandler(ProjectBuilder builder)
		{
			this.builder = builder;
		}

		public ProjectBuilderReportingHandler()
		{
			DefaultErrorAction = ErrorAction.Stop;
		}

		public void OnFatalError(BuildProcess processId, BuildIssue buildIssue)
		{
			if (this.OnFatalErrorHandler != null)
			{
				this.OnFatalErrorHandler(builder, processId, buildIssue);
			}
		}

		public ErrorAction OnError(BuildProcess processId, BuildIssue buildIssue)
		{
			if (this.OnErrorHandler != null)
			{
				bool flag = true;
				Delegate[] invocationList = this.OnErrorHandler.GetInvocationList();
				for (int i = 0; i < invocationList.Length; i++)
				{
					ErrorAction errorAction = ((OnBuildError)invocationList[i])(builder, processId, buildIssue);
					flag = flag && errorAction == ErrorAction.ForceContinue;
				}
				if (!flag)
				{
					return ErrorAction.Stop;
				}
				return ErrorAction.ForceContinue;
			}
			return DefaultErrorAction;
		}

		public void OnWarning(BuildProcess processId, BuildIssue buildIssue)
		{
			if (this.OnWarningHandler != null)
			{
				this.OnWarningHandler(builder, processId, buildIssue);
			}
		}

		public void OnInfo(BuildProcess processId, BuildIssue buildIssue)
		{
			if (this.OnInfoHandler != null)
			{
				this.OnInfoHandler(builder, processId, buildIssue);
			}
		}
	}
	public class SolutionBuilderReportingHandler
	{
		public ErrorAction DefaultErrorAction { get; set; }

		public event OnBuildFatalError OnFatalErrorHandler;

		public event OnBuildError OnErrorHandler;

		public event OnBuildWarning OnWarningHandler;

		public event OnBuildInfo OnInfoHandler;

		public SolutionBuilderReportingHandler()
		{
			DefaultErrorAction = ErrorAction.Stop;
		}

		internal void OnFatalError(ProjectBuilder source, BuildProcess processId, BuildIssue buildIssue)
		{
			if (this.OnFatalErrorHandler != null)
			{
				this.OnFatalErrorHandler(source, processId, buildIssue);
			}
		}

		internal ErrorAction OnError(ProjectBuilder source, BuildProcess processId, BuildIssue buildIssue)
		{
			if (this.OnErrorHandler != null)
			{
				bool flag = true;
				Delegate[] invocationList = this.OnErrorHandler.GetInvocationList();
				for (int i = 0; i < invocationList.Length; i++)
				{
					ErrorAction errorAction = ((OnBuildError)invocationList[i])(source, processId, buildIssue);
					flag = flag && errorAction == ErrorAction.ForceContinue;
				}
				if (!flag)
				{
					return ErrorAction.Stop;
				}
				return ErrorAction.ForceContinue;
			}
			return DefaultErrorAction;
		}

		internal void OnWarning(ProjectBuilder source, BuildProcess processId, BuildIssue buildIssue)
		{
			if (this.OnWarningHandler != null)
			{
				this.OnWarningHandler(source, processId, buildIssue);
			}
		}

		internal void OnInfo(ProjectBuilder source, BuildProcess processId, BuildIssue buildIssue)
		{
			if (this.OnInfoHandler != null)
			{
				this.OnInfoHandler(source, processId, buildIssue);
			}
		}
	}
	public interface BuildIssue
	{
		string InnerMessage { get; }

		new string ToString();
	}
	public class GeneralIssue : BuildIssue
	{
		public string InnerMessage { get; internal set; }

		public override string ToString()
		{
			return InnerMessage;
		}

		public GeneralIssue(string innerMessage)
		{
			InnerMessage = innerMessage;
		}
	}
	public class ImportIssue : BuildIssue
	{
		public string InnerMessage { get; internal set; }

		public override string ToString()
		{
			return InnerMessage;
		}

		public ImportIssue(string innerMessage)
		{
			InnerMessage = innerMessage;
		}
	}
	public class ImportAssetIssue : ImportIssue
	{
		public string AssetName { get; internal set; }

		public override string ToString()
		{
			return "Importing asset '" + AssetName + "' failure. Import engine reports: '" + base.InnerMessage + "'. Asset not changed. Please re-import your asset.";
		}

		public ImportAssetIssue(string assetName, string innerMessage)
			: base(innerMessage)
		{
			AssetName = assetName;
		}
	}
	public class ImportAssetLayerIssue : ImportIssue
	{
		public string AssetName { get; internal set; }

		public int Layer { get; internal set; }

		public override string ToString()
		{
			return "Importing asset '" + AssetName + "' failure, failed to import layer " + Layer + ". Import engine reports: '" + base.InnerMessage + "'. Asset not changed. Please re-import your asset.";
		}

		public ImportAssetLayerIssue(string assetName, int layer, string innerMessage)
			: base(innerMessage)
		{
			AssetName = assetName;
			Layer = layer;
		}
	}
	public class ImportTemplateIssue : ImportIssue
	{
		public string TemplateName { get; internal set; }

		public override string ToString()
		{
			return "Importing template '" + TemplateName + "' failure. Import engine reports: '" + base.InnerMessage + "'. Please re-import your asset template.";
		}

		public ImportTemplateIssue(string templateName, string innerMessage)
			: base(innerMessage)
		{
			TemplateName = templateName;
		}
	}
	public class AtlasIssue : BuildIssue
	{
		public string InnerMessage { get; internal set; }

		public AtlasIssue(string innerMessage)
		{
			InnerMessage = innerMessage;
		}

		public override string ToString()
		{
			return InnerMessage;
		}
	}
	public class DiskSpaceIssue : BuildIssue
	{
		public string InnerMessage { get; internal set; }

		public override string ToString()
		{
			return InnerMessage;
		}

		public DiskSpaceIssue(string innerMessage)
		{
			InnerMessage = innerMessage;
		}
	}
	public class CoderIssue : BuildIssue
	{
		public string InnerMessage { get; internal set; }

		public override string ToString()
		{
			return "General coding error: " + InnerMessage;
		}

		public CoderIssue(string innerMessage)
		{
			InnerMessage = innerMessage;
		}
	}
	public class CoderCodingProfileIssue : CoderIssue
	{
		public string CodingProfile { get; internal set; }

		public override string ToString()
		{
			return "Coding profile issue occurred upon initializing the profile '" + CodingProfile + "', the coding settings engine reports: " + base.InnerMessage;
		}

		public CoderCodingProfileIssue(string codingProfile, string innerMessage)
			: base(innerMessage)
		{
			CodingProfile = codingProfile;
		}
	}
	public class CoderAssetIssue : CoderIssue
	{
		public string AssetName { get; internal set; }

		public override string ToString()
		{
			return "Failed to set coding parameters for asset '" + AssetName + "', the coding settings engine reports:  " + base.InnerMessage;
		}

		public CoderAssetIssue(string assetName, string innerMessage)
			: base(innerMessage)
		{
			AssetName = assetName;
		}
	}
	public class ComposeIssue : BuildIssue
	{
		public string InnerMessage { get; internal set; }

		public override string ToString()
		{
			return InnerMessage;
		}

		public ComposeIssue(string innerMessage)
		{
			InnerMessage = innerMessage;
		}
	}
	public class ComposeCacheWriteIssue : ComposeIssue
	{
		public ComposeCacheWriteIssue(string assetName, ErrorInfo errorInfo)
			: base("")
		{
			Nixel.Error code = (Nixel.Error)errorInfo.code;
			if (code == Nixel.Error.IoAccessDenied || code == Nixel.Error.IoBadPath || code == Nixel.Error.IoDiskFull || code == Nixel.Error.IoFileNotFound || code == Nixel.Error.IoLocked || code == Nixel.Error.IoUnknown)
			{
				base.InnerMessage = "Internal IO error: error writing to compositor cache for asset '" + assetName + "'. Please rebuild the project, make sure no other processes are using the project folder, the project folder isn't locked and you have enough disk space. Detailed error: '" + errorInfo.message + "', code: " + code;
			}
			else
			{
				base.InnerMessage = "Internal error: error writing to compositor cache for asset '" + assetName + "'. Please rebuild the project, if this error persists contact Graphine with the following information. Detailed error: " + errorInfo.function + ":" + errorInfo.line + " '" + errorInfo.message + "', code: " + code;
			}
		}
	}
	public class ComposeCacheSaveIssue : ComposeIssue
	{
		public ComposeCacheSaveIssue(string assetName, ErrorInfo errorInfo)
			: base("")
		{
			Nixel.Error code = (Nixel.Error)errorInfo.code;
			if (code == Nixel.Error.IoAccessDenied || code == Nixel.Error.IoBadPath || code == Nixel.Error.IoDiskFull || code == Nixel.Error.IoFileNotFound || code == Nixel.Error.IoLocked || code == Nixel.Error.IoUnknown)
			{
				base.InnerMessage = "Internal IO error: error saving the compositor cache for asset '" + assetName + "'. Please rebuild the project, make sure no other processes are using the project folder, the project folder isn't locked and you have enough disk space. Detailed error: '" + errorInfo.message + "', code: " + code;
			}
			else
			{
				base.InnerMessage = "Internal error: error saving the compositor cache for asset '" + assetName + "'. Please rebuild the project, if this error persists contact Graphine with the following information. Detailed error: " + errorInfo.function + ":" + errorInfo.line + " '" + errorInfo.message + "', code: " + code;
			}
		}
	}
	public class ComposeAssetIssue : ComposeIssue
	{
		public string AssetName { get; internal set; }

		public override string ToString()
		{
			return "Failed to compose asset '" + AssetName + "', the compositor engine reports: " + base.InnerMessage;
		}

		public ComposeAssetIssue(string assetName, string innerMessage)
			: base(innerMessage)
		{
			AssetName = assetName;
		}
	}
	public class TileFilePreprocessorIssue : BuildIssue
	{
		public string InnerMessage { get; internal set; }

		public override string ToString()
		{
			return InnerMessage;
		}

		public TileFilePreprocessorIssue(string innerMessage)
		{
			InnerMessage = innerMessage;
		}
	}
	public class TileFileInvalidParameterIssue : TileFilePreprocessorIssue
	{
		public string Parameter { get; internal set; }

		public string ExpectedValue { get; internal set; }

		public TileFileInvalidParameterIssue(string parameter, string expectedValue)
			: base("")
		{
			Parameter = parameter;
			ExpectedValue = expectedValue;
			base.InnerMessage = "Invalid parameter '" + parameter + "': " + expectedValue + ", please update the parameter value and build the project";
		}
	}
	public class TileSoupBuilderIssue : BuildIssue
	{
		private string formattedMessage = string.Empty;

		public string AssetName { get; internal set; }

		public string InnerMessage { get; internal set; }

		public override string ToString()
		{
			return formattedMessage;
		}

		public TileSoupBuilderIssue(string assetName, string innerMessage)
		{
			AssetName = assetName;
			InnerMessage = innerMessage;
			formattedMessage = "Data coding failure while coding '" + AssetName + "', the coding engine reports: '" + InnerMessage + "', please rebuild your project";
		}

		public TileSoupBuilderIssue(string message)
		{
			formattedMessage = (InnerMessage = message);
		}
	}
	public class TileSoupBuilderCodeIssue : TileSoupBuilderIssue
	{
		public TileSoupBuilderCodeIssue(string assetName, string innerMessage)
			: base(assetName, innerMessage)
		{
		}

		public override string ToString()
		{
			return "Data coding failure while coding '" + base.AssetName + "', the coding engine reports: " + base.InnerMessage;
		}
	}
	public class TileSetBuilderIssue : BuildIssue
	{
		public string InnerMessage { get; internal set; }

		public override string ToString()
		{
			return "Tile set build failure, the tile set builder engine reports: " + InnerMessage;
		}

		public TileSetBuilderIssue(string innerMessage)
		{
			InnerMessage = innerMessage;
		}
	}
	public static class GrBuildExceptionHandler
	{
		public const int maxWarningLevel = 3;

		public const int minWarningLevel = 1;

		public static uint WarningLevel { get; set; }

		public static bool IsFatal(GrBuildException e)
		{
			return e.ExceptionLevel >= 4 - WarningLevel;
		}
	}
	public abstract class GrBuildException : Exception
	{
		public int ExceptionLevel { get; set; }

		public int LayerIndex { get; set; }

		public GrBuildException()
		{
			LayerIndex = -1;
		}

		public GrBuildException(string message)
			: base(message)
		{
			LayerIndex = -1;
		}

		public GrBuildException(int layerIndex, string message)
			: base(message)
		{
			LayerIndex = layerIndex;
		}

		public GrBuildException(string message, Exception inner)
			: base(message, inner)
		{
			LayerIndex = -1;
		}

		public GrBuildException(int layerIndex, string message, Exception inner)
			: base(message, inner)
		{
			LayerIndex = layerIndex;
		}
	}
	public class NodeNotFoundException : GrBuildException
	{
		public NodeNotFoundException(string nodeName)
			: base("Missing node: " + nodeName)
		{
			base.ExceptionLevel = 2;
		}
	}
	public class GrimException : GrBuildException
	{
		public GrimException(Grim.Error error, string filename)
			: base("An error occurred while reading the image \"" + filename + "\", detailed error code: " + error.ToString() + ". Make sure the image is valid.")
		{
			base.ExceptionLevel = 2;
		}
	}
	public class GrimSevereException : GrBuildException
	{
		public GrimSevereException(Grim.Error error, string filename)
			: base("An error occurred while reading the image \"" + filename + "\", detailed error code: " + error.ToString() + ". Make sure the image is valid.")
		{
			base.ExceptionLevel = 3;
		}
	}
	public class NixelException : GrBuildException
	{
		public Nixel.Error Error { get; set; }

		public NixelException(Nixel.Error error, string filename)
			: base("An error occurred while reading \"" + filename + "\", detailed error code: " + error.ToString() + ".")
		{
			Error = error;
			base.ExceptionLevel = 2;
		}
	}
	public class ImportInvalidTypeException : GrBuildException
	{
		public ImportInvalidTypeException(string filename, string sourceFormat, string destType)
			: base("Failed to import file: Channel format " + sourceFormat + " of " + filename + " is incompatible with " + destType + ", please change the layer configuration data type or convert image format")
		{
			base.ExceptionLevel = 1;
		}
	}
	public class InvalidTypeException : GrBuildException
	{
		public InvalidTypeException(string assetName, string filename, string sourceFormat, string destType)
			: base("Channel format " + sourceFormat + " of " + filename + " is incompatible with " + destType + ", possible solutions are: removing the asset \"" + assetName + "\", converting the image file manually or changing the layer configuration data type")
		{
			base.ExceptionLevel = 3;
		}
	}
	public class ImportException : GrBuildException
	{
		public ImportException(string message)
			: base(message)
		{
			base.ExceptionLevel = 1;
		}

		public ImportException(int layerIndex, string message)
			: base(layerIndex, message)
		{
			base.ExceptionLevel = 1;
		}
	}
	public class ImportedAssetCheckFailedException : GrBuildException
	{
		public enum FailedReason
		{
			Unknown,
			FileNotFound,
			FileNotAccessible,
			NoSourceTextures,
			InvalidFormat,
			InvalidUDimPattern,
			InvalidPatternDimensions,
			LayerResolutionsNotMatching,
			InvalidAssetBorder,
			InvalidChannelMerging
		}

		public FailedReason Reason { get; set; }

		public ImportedAssetCheckFailedException(string message)
			: base(message)
		{
			base.ExceptionLevel = 3;
		}

		public ImportedAssetCheckFailedException(string message, FailedReason reason)
			: base(message)
		{
			base.ExceptionLevel = 3;
			Reason = reason;
		}
	}
	public class InvalidPatternDimensionsException : GrBuildException
	{
		public InvalidPatternDimensionsException(string patternFilename)
			: base("Width/Height of Rows/Columns don't match for file pattern " + patternFilename + ", review the file pattern on disk or remove the asset")
		{
			base.ExceptionLevel = 1;
		}
	}
	public class InvalidUDimPatternException : GrBuildException
	{
		public InvalidUDimPatternException(string patternFilename)
			: base("Not all the UDim tiles have the same dimensions " + patternFilename)
		{
			base.ExceptionLevel = 1;
		}
	}
	public class PatternFilesNotFoundException : GrBuildException
	{
		public PatternFilesNotFoundException(string patternFilename)
			: base("Some files not found for pattern " + patternFilename)
		{
			base.ExceptionLevel = 1;
		}
	}
	public class TemplateException : GrBuildException
	{
		public TemplateException(string message)
			: base(message)
		{
			base.ExceptionLevel = 1;
		}
	}
	public class AssetNotPackedException : GrBuildException
	{
		public AssetNotPackedException(string assetName)
			: base("Internal error: the asset '" + assetName + "' hasn't been correctly packed, please build the project")
		{
			base.ExceptionLevel = 3;
		}
	}
	public class AssetNotComposedException : GrBuildException
	{
		public AssetNotComposedException(string assetName)
			: base("Internal error: the asset '" + assetName + "' hasn't been correctly composed, please build the project.")
		{
			base.ExceptionLevel = 3;
		}
	}
	public class AssetNotFoundException : GrBuildException
	{
		public AssetNotFoundException(Guid key)
			: base("Internal error: the asset with id '" + key.ToString() + "' can't be found, please rebuild the project")
		{
			base.ExceptionLevel = 3;
		}
	}
	public class CompositorException : GrBuildException
	{
		public CompositorException(string message)
			: base(message)
		{
			base.ExceptionLevel = 3;
		}
	}
	public class CoderException : GrBuildException
	{
		public CoderException(string message)
			: base(message)
		{
			base.ExceptionLevel = 2;
		}
	}
	public class IncompatibleQualityProfileException : GrBuildException
	{
		public IncompatibleQualityProfileException()
		{
			base.ExceptionLevel = 3;
		}

		public IncompatibleQualityProfileException(string message)
			: base(message)
		{
			base.ExceptionLevel = 3;
		}
	}
	public class CodingProfileLoaderException : GrBuildException
	{
		public CodingProfileLoaderException(string message)
			: base(message)
		{
			base.ExceptionLevel = 3;
		}
	}
	public class RasterDataException : GrBuildException
	{
		public RasterDataException(string message)
			: base(message)
		{
			base.ExceptionLevel = 3;
		}
	}
	public class InvalidSwizzleException : GrBuildException
	{
		public InvalidSwizzleException(string swizzle, string message)
			: base("Invalid swizzle \"" + swizzle + "\" " + message)
		{
			base.ExceptionLevel = 2;
		}
	}
	public class InvalidDllException : GrBuildException
	{
		public InvalidDllException(string dllname, Exception innerException)
			: base("Couldn't load " + dllname + ", make sure Granite SDK is correctly installed, you have a valid license, and check the prerequisites in the documentation.", innerException)
		{
			base.ExceptionLevel = 3;
		}
	}
	public class UserAbortException : GrBuildException
	{
		public UserAbortException()
			: base("Aborted by user")
		{
			base.ExceptionLevel = 3;
		}
	}
	public class FatalException : GrBuildException
	{
		public FatalException()
		{
			base.ExceptionLevel = 3;
		}
	}
	public class GtsMoveException : GrBuildException
	{
		public GtsMoveException(string detailMsg)
			: base("Unable to move GTS file in place due to the following error: '" + detailMsg + "', please check the output directory and build again.")
		{
			base.ExceptionLevel = 3;
		}
	}
	public abstract class GrXmlException : ConfigurationErrorsException
	{
		public GrXmlException(string message, XmlNode node)
			: base(message, node)
		{
		}

		public GrXmlException(string message)
			: base(message)
		{
		}

		public GrXmlException(string message, XmlException e)
			: base(message, e)
		{
		}
	}
	internal class GrInvalidParseAttributeException : GrXmlException
	{
		public GrInvalidParseAttributeException(string variable, XmlNode node)
			: base("Invalid attribute text for \"" + variable + "\" couldn't parse information", node)
		{
		}
	}
	public class GrInvalidParseNodeException : GrXmlException
	{
		public GrInvalidParseNodeException(string variable, XmlNode node)
			: base("Invalid inner node text for \"" + variable + "\" couldn't parse information", node)
		{
		}
	}
	public class GrInvalidElementException : GrXmlException
	{
		public GrInvalidElementException(string message, XmlNode node)
			: base(message, node)
		{
		}
	}
	public class GrMissingNodeException : GrXmlException
	{
		public GrMissingNodeException(string name, XmlNode parent)
			: base("Node " + name + " missing in XML", parent)
		{
		}

		public GrMissingNodeException(string name)
			: base("Node " + name + " missing in XML")
		{
		}
	}
	public class GrMissingAttributeException : GrXmlException
	{
		public GrMissingAttributeException(string name, XmlNode node)
			: base("Attribute " + name + " missing", node)
		{
		}
	}
	public class GrDeprecatedAttributeException : GrXmlException
	{
		public GrDeprecatedAttributeException(string name, XmlNode node, string replacedByMessage)
			: base("Attribute " + name + " deprecated and replaced by " + replacedByMessage, node)
		{
		}
	}
	public class GrInvalidProjectCompatibilityVersionException : GrBuildException
	{
		public Version Found { get; private set; }

		public Version Required { get; private set; }

		public GrInvalidProjectCompatibilityVersionException(Version found, Version required)
			: base(string.Format("Incompatible project version. The project was build with a version of GrBuild that is not compatible with this version; found: {0}, required: {1}. Please delete the project and reimport your assets in a new project.", new object[2]
			{
				found.ToString(),
				required.ToString()
			}))
		{
			Found = found;
			Required = required;
		}
	}
	public class GrGeneralXmlException : GrXmlException
	{
		public GrGeneralXmlException(XmlException e)
			: base(e.Message, e)
		{
		}
	}
	public class FileInaccessibleException : GrBuildException
	{
		public FileInaccessibleException(string fileName)
			: base("File '" + fileName + "' is inaccessible.")
		{
		}
	}
	public class InvalidProgramStateException : GrBuildException
	{
		public InvalidProgramStateException(string message)
			: base("Program has entered an invalid state. Specific error message: '" + message + "'. Please restart the program and rebuild. If the problem persists, please contact Graphine.")
		{
			base.ExceptionLevel = 3;
		}
	}
	public class InvalidLayerConfigurationException : GrBuildException
	{
		public InvalidLayerConfigurationException(string message)
			: base(message)
		{
			base.ExceptionLevel = 3;
		}
	}
	public class MissingLayerConfigurationException : GrBuildException
	{
		public MissingLayerConfigurationException(string message)
			: base(message)
		{
			base.ExceptionLevel = 3;
		}
	}
	public class IncompatibleGTexException : GrBuildException
	{
		public IncompatibleGTexException(string message)
			: base(message)
		{
			base.ExceptionLevel = 3;
		}
	}
	public class ProjectSaveException : GrBuildException
	{
		public ProjectSaveException(string message)
			: base(message)
		{
			base.ExceptionLevel = 3;
		}
	}
	public class UnspecifiedException : GrBuildException
	{
		public Error ErrorCode { get; set; }

		public UnspecifiedException(string message, Error error)
			: base(message)
		{
			ErrorCode = error;
			base.ExceptionLevel = 3;
		}

		public UnspecifiedException(string message, Exception innerException)
			: base(message, innerException)
		{
			ErrorCode = ((innerException is UnspecifiedException) ? ((UnspecifiedException)innerException).ErrorCode : Error.Unknown);
			base.ExceptionLevel = 3;
		}

		public UnspecifiedException(string message, Error error, Exception innerException)
			: base(message, innerException)
		{
			ErrorCode = error;
			base.ExceptionLevel = 3;
		}
	}
	public class ImportSummary
	{
		public int FailedImportCount { get; set; }

		public int SuccessImportCount { get; set; }

		public List<ImportAsset> FailedAssetImports { get; set; }

		public List<ImportAssetTemplate> FailedTemplates { get; set; }

		public List<Asset> FailedAssetUpdates { get; set; }

		public List<TextureChange> TextureChanges { get; set; }

		public ImportSummary()
		{
			FailedImportCount = 0;
			SuccessImportCount = 0;
			FailedAssetImports = new List<ImportAsset>();
			FailedTemplates = new List<ImportAssetTemplate>();
			TextureChanges = new List<TextureChange>();
			FailedAssetUpdates = new List<Asset>();
		}
	}
	public class LayerConfig
	{
		public List<LayerDescription> Layers { get; private set; }

		public LayerConfig()
		{
			Layers = new List<LayerDescription>();
		}

		public bool IsEqual(Project project, LayerConfig rhs)
		{
			if (rhs == null)
			{
				return false;
			}
			if (Layers.Count != rhs.Layers.Count)
			{
				return false;
			}
			if (SameDataTypes(rhs) && SameCodingProfiles(project, rhs) && SameQualityLevels(project, rhs))
			{
				return SameNames(rhs);
			}
			return false;
		}

		public bool CompatibleForCompositing(Project project, LayerConfig rhs)
		{
			if (rhs == null)
			{
				return false;
			}
			if (Layers.Count != rhs.Layers.Count)
			{
				return false;
			}
			return SameDataTypes(rhs);
		}

		public bool CompatibleForCoding(Project project, LayerConfig rhs)
		{
			if (rhs == null)
			{
				return false;
			}
			if (Layers.Count != rhs.Layers.Count)
			{
				return false;
			}
			if (SameDataTypes(rhs))
			{
				return SameCodingProfiles(project, rhs);
			}
			return false;
		}

		public bool CompatibleForBuildingTileset(Project project, LayerConfig rhs)
		{
			if (SameDataTypes(rhs))
			{
				return SameCodingProfiles(project, rhs);
			}
			return false;
		}

		public bool SameDataTypes(LayerConfig rhs)
		{
			if (rhs == null)
			{
				return false;
			}
			if (Layers.Count != rhs.Layers.Count)
			{
				return false;
			}
			int num = 0;
			foreach (LayerDescription layer in Layers)
			{
				if (layer.DataType != rhs.Layers[num].DataType)
				{
					return false;
				}
				num++;
			}
			return true;
		}

		public bool SameNames(LayerConfig rhs)
		{
			if (rhs == null)
			{
				return false;
			}
			if (Layers.Count != rhs.Layers.Count)
			{
				return false;
			}
			int num = 0;
			foreach (LayerDescription layer in Layers)
			{
				if (layer.LayerName != rhs.Layers[num].LayerName)
				{
					return false;
				}
				num++;
			}
			return true;
		}

		public bool SameDefaultColors(LayerConfig rhs)
		{
			if (rhs == null)
			{
				return false;
			}
			if (Layers.Count != rhs.Layers.Count)
			{
				return false;
			}
			int num = 0;
			foreach (LayerDescription layer in Layers)
			{
				if (!AreColorsEqual(layer.DefaultColor, rhs.Layers[num].DefaultColor))
				{
					return false;
				}
				num++;
			}
			return true;
		}

		private static bool AreColorsEqual(string a, string b)
		{
			if (string.IsNullOrEmpty(a))
			{
				return string.IsNullOrEmpty(b);
			}
			return string.Equals(a, b);
		}

		public bool SameQualityLevels(Project project, LayerConfig rhs)
		{
			if (Layers.Count != rhs.Layers.Count)
			{
				return false;
			}
			int num = 0;
			foreach (LayerDescription layer in Layers)
			{
				string a = CodingProfileHelper.ResolveDefaultQualityProfile(project, layer.QualityProfile, layer.CodingProfile, layer.QualityProfile, layer.DataType);
				string b = CodingProfileHelper.ResolveDefaultQualityProfile(project, rhs.Layers[num].QualityProfile, rhs.Layers[num].CodingProfile, rhs.Layers[num].QualityProfile, rhs.Layers[num].DataType);
				if (!string.Equals(a, b, StringComparison.InvariantCultureIgnoreCase))
				{
					return false;
				}
				num++;
			}
			return true;
		}

		public bool SameCodingProfiles(Project project, LayerConfig rhs)
		{
			if (Layers.Count != rhs.Layers.Count)
			{
				return false;
			}
			int num = 0;
			foreach (LayerDescription layer in Layers)
			{
				string a = CodingProfileHelper.ResolveNullCodingProfile(project, layer.CodingProfile, layer.DataType);
				string b = CodingProfileHelper.ResolveNullCodingProfile(project, rhs.Layers[num].CodingProfile, rhs.Layers[num].DataType);
				if (!string.Equals(a, b, StringComparison.InvariantCultureIgnoreCase))
				{
					return false;
				}
				num++;
			}
			return true;
		}
	}
	public class LayerDescription
	{
		public DataType DataType { get; set; }

		public string QualityProfile { get; set; }

		public string CodingProfile { get; set; }

		public string LayerName { get; set; }

		public string DefaultColor { get; set; }

		public LayerDescription()
		{
		}

		public LayerDescription(DataType dataType, string codingProfile, string qualityProfile, string layerName)
		{
			DataType = dataType;
			CodingProfile = codingProfile;
			QualityProfile = qualityProfile;
			LayerName = layerName;
			DefaultColor = string.Empty;
		}

		public LayerDescription(DataType dataType, string codingProfile, string qualityProfile, string layerName, string defaultColor)
		{
			DataType = dataType;
			CodingProfile = codingProfile;
			QualityProfile = qualityProfile;
			LayerName = layerName;
			DefaultColor = defaultColor;
		}
	}
	public class BuildProfile
	{
		public string Name { get; set; }

		public string DisplayName { get; set; }

		public uint? BlockSize { get; set; }

		public TargetDisk? TargetDisk { get; set; }

		public uint? TileSize { get; set; }

		public uint? Anisotropy { get; set; }

		public TilingMode? TilingMode { get; set; }

		public string Description { get; set; }

		public PagingStrategy DefaultPagingStrategyMapsTo { get; set; }

		public List<string> AvailableCodingProfiles { get; set; }

		public List<PagingStrategy> AvailablePagingStrategies { get; set; }

		public Dictionary<DataType, string> DefaultCodingProfiles { get; set; }

		public BuildProfile()
		{
			TileSize = null;
			Anisotropy = null;
			TilingMode = null;
			AvailableCodingProfiles = new List<string>();
			DefaultCodingProfiles = new Dictionary<DataType, string>();
			TargetDisk = null;
			Description = string.Empty;
			DefaultPagingStrategyMapsTo = PagingStrategy.Default;
			AvailablePagingStrategies = new List<PagingStrategy>();
		}
	}
	public class CodingProfile : ICloneable
	{
		public string Name { get; set; }

		public string DisplayName { get; set; }

		public List<DefaultQualitySetting> DefaultQualitySettings { get; set; }

		public bool UniformCodecAvailable { get; set; }

		public List<QualityProfile> QualityProfiles { get; set; }

		public CodingProfile()
		{
			Name = "";
			DefaultQualitySettings = new List<DefaultQualitySetting>();
			QualityProfiles = new List<QualityProfile>();
		}

		public object Clone()
		{
			CodingProfile codingProfile = (CodingProfile)MemberwiseClone();
			if (DefaultQualitySettings != null)
			{
				codingProfile.DefaultQualitySettings = new List<DefaultQualitySetting>();
				foreach (DefaultQualitySetting defaultQualitySetting in DefaultQualitySettings)
				{
					codingProfile.DefaultQualitySettings.Add((DefaultQualitySetting)defaultQualitySetting.Clone());
				}
			}
			if (QualityProfiles != null)
			{
				codingProfile.QualityProfiles = new List<QualityProfile>();
				{
					foreach (QualityProfile qualityProfile in QualityProfiles)
					{
						codingProfile.QualityProfiles.Add((QualityProfile)qualityProfile.Clone());
					}
					return codingProfile;
				}
			}
			return codingProfile;
		}

		public bool HasQualityProfileForDataType(string name, DataType dataType)
		{
			foreach (QualityProfile qualityProfile in QualityProfiles)
			{
				if (!qualityProfile.Name.Equals(name, StringComparison.OrdinalIgnoreCase))
				{
					continue;
				}
				foreach (CodingConfig codingConfig in qualityProfile.CodingConfigs)
				{
					if (codingConfig.DataTypes.Contains(dataType))
					{
						return true;
					}
				}
			}
			return false;
		}
	}
	public class DefaultQualitySetting : ICloneable
	{
		public string QualityProfile { get; set; }

		public List<DataType> DataTypes { get; set; }

		public DefaultQualitySetting()
		{
			QualityProfile = "";
			DataTypes = new List<DataType>();
		}

		public object Clone()
		{
			DefaultQualitySetting defaultQualitySetting = (DefaultQualitySetting)MemberwiseClone();
			if (DataTypes != null)
			{
				defaultQualitySetting.DataTypes = new List<DataType>();
				defaultQualitySetting.DataTypes.AddRange(DataTypes);
			}
			return defaultQualitySetting;
		}
	}
	public class CodingConfig : ICloneable
	{
		public List<DataType> DataTypes { get; set; }

		public int CodecId { get; set; }

		public string CodecConfiguration { get; set; }

		public CodingConfig()
		{
			DataTypes = new List<DataType>();
			CodecConfiguration = "";
		}

		public CodingConfig(DataType[] datatypes, int codecId, string codecConfig)
		{
			DataTypes = new List<DataType>(datatypes);
			CodecConfiguration = codecConfig;
			CodecId = codecId;
		}

		public object Clone()
		{
			CodingConfig codingConfig = (CodingConfig)MemberwiseClone();
			if (DataTypes != null)
			{
				codingConfig.DataTypes = new List<DataType>();
				codingConfig.DataTypes.AddRange(DataTypes);
			}
			return codingConfig;
		}
	}
	public class QualityProfile : ICloneable
	{
		public string Name { get; set; }

		public uint Priority { get; set; }

		public List<CodingConfig> CodingConfigs { get; set; }

		public bool Hidden { get; set; }

		public QualityProfile()
		{
			Priority = 50u;
			Name = "";
			Hidden = false;
			CodingConfigs = new List<CodingConfig>();
		}

		public object Clone()
		{
			QualityProfile qualityProfile = (QualityProfile)MemberwiseClone();
			if (CodingConfigs != null)
			{
				qualityProfile.CodingConfigs = new List<CodingConfig>();
				{
					foreach (CodingConfig codingConfig in CodingConfigs)
					{
						qualityProfile.CodingConfigs.Add((CodingConfig)codingConfig.Clone());
					}
					return qualityProfile;
				}
			}
			return qualityProfile;
		}
	}
	[Obfuscation(Exclude = true, ApplyToMembers = true)]
	public enum PipelineProcessResult
	{
		Success,
		Failed,
		Canceled
	}
	internal interface IPipelineProcess
	{
		bool HasRun { get; }

		DateTime LastRun { get; }

		PipelineProcessResult LatestResult { get; }

		PipelineProcessResult PreProcess();

		PipelineProcessResult Process();

		PipelineProcessResult PostProcess(PipelineProcessResult processResult);
	}
	internal interface IAssetImporterProcess : IPipelineProcess
	{
	}
	internal interface IAtlasProcess : IPipelineProcess
	{
	}
	internal interface ITileFilePreprocessorProcess : IPipelineProcess
	{
	}
	internal interface ICompositorProcess : IPipelineProcess
	{
		bool DeleteSerializedFiles();
	}
	internal interface ICoderProcess : IPipelineProcess
	{
	}
	internal interface IOrdererProcess : IPipelineProcess
	{
	}
	internal interface ITileSetBuilderProcess : IPipelineProcess
	{
	}
	internal interface ITileSoupBuilderProcess : IPipelineProcess
	{
		bool DeleteSerializedFiles();
	}
	[Obfuscation(Exclude = true, ApplyToMembers = true)]
	public enum ConfigurationMethod
	{
		Auto,
		Manual
	}
	[Obfuscation(Exclude = true, ApplyToMembers = true)]
	public enum AddMethod
	{
		Manual,
		Templated
	}
	[Obfuscation(Exclude = true, ApplyToMembers = true)]
	public enum TargetConfiguration
	{
		Fast,
		Optimized,
		Default
	}
	[Obfuscation(Exclude = true, ApplyToMembers = true)]
	public enum Task
	{
		Build,
		Rebuild,
		Clean,
		NoBuild,
		Repage
	}
	[Obfuscation(Exclude = true, ApplyToMembers = true)]
	public enum Process
	{
		All,
		Import,
		Atlas,
		ComposeAndCode,
		Order,
		TileFilePreProcess,
		Build,
		None
	}
	[Obfuscation(Exclude = true, ApplyToMembers = true)]
	public enum BuildMode
	{
		BuildForGTP,
		BuildForGTex
	}
	[Obfuscation(Exclude = true, ApplyToMembers = true)]
	public enum TilingMode
	{
		Software
	}
	[Obfuscation(Exclude = true, ApplyToMembers = true)]
	public enum Flip
	{
		None,
		Horizontal,
		Vertical,
		Both
	}
	[Obfuscation(Exclude = true, ApplyToMembers = true)]
	public enum AssetChangeType
	{
		None,
		Added,
		Deleted,
		Resolution,
		Data,
		Codec,
		MetaData
	}
	[Obfuscation(Exclude = true, ApplyToMembers = true)]
	public enum TextureChangeType
	{
		New,
		Modified,
		Deleted
	}
	[Obfuscation(Exclude = true, ApplyToMembers = true)]
	public enum RasterDataType
	{
		New,
		Existing
	}
	[Obfuscation(Exclude = true, ApplyToMembers = true)]
	public enum AssetTilingMethod
	{
		None,
		Repeat,
		Clamp
	}
	[Obfuscation(Exclude = true, ApplyToMembers = true)]
	public enum AutoScalingMode
	{
		None,
		NearestPowerOf2,
		NextPowerOf2,
		PreviousPowerOf2
	}
	[Obfuscation(Exclude = true, ApplyToMembers = true)]
	public enum FixedTexFormat
	{
		ANY,
		BC1,
		BC2,
		BC3,
		BC4,
		BC5,
		BC6,
		BC7,
		NOBC,
		Invalid,
		ASTC4X4,
		ASTC8X8
	}
	[Obfuscation(Exclude = true, ApplyToMembers = true)]
	public enum TextureFormat
	{
		R8G8B8A8,
		R16G16B16A16,
		R32G32B32A32,
		BC1,
		BC3,
		BC5,
		BC7,
		BC6,
		BC4,
		ASTC4X4,
		ASTC8X8,
		R32,
		R32G32,
		R32G32B32
	}
	[Obfuscation(Exclude = true, ApplyToMembers = true)]
	public enum Error
	{
		Ok,
		FileAlreadyExists,
		FileNotFound,
		InvalidParameter,
		IOError,
		NoProjectLoaded,
		InvalidInternalState,
		InvalidProjectState,
		XMLValidation,
		XMLParsing,
		InvalidBuildProfile,
		AlreadySet,
		ProjectLocked,
		SolutionLocked,
		Fail,
		Unknown
	}
	[Obfuscation(Exclude = true, ApplyToMembers = true)]
	public enum AssetType
	{
		Normal,
		CubeMap
	}
	[Obfuscation(Exclude = true, ApplyToMembers = true)]
	public enum TextureMipSourceType
	{
		Default,
		Generated,
		File
	}
	[Obfuscation(Exclude = true, ApplyToMembers = true)]
	public enum TextureType
	{
		Unknown,
		Single,
		UDim,
		Tiled,
		Empty
	}
	[Obfuscation(Exclude = true, ApplyToMembers = true)]
	public enum TargetDisk
	{
		Default,
		Generic,
		SSD,
		HDD
	}
	[Obfuscation(Exclude = true, ApplyToMembers = true)]
	public enum AssetPackingMode
	{
		None,
		Combined,
		Combined3,
		Combined4
	}
	[Obfuscation(Exclude = true, ApplyToMembers = true)]
	public enum AssetLayerResizeMode
	{
		Absolute,
		RelativeToSource,
		RelativeToStackedTexture
	}
	[Obfuscation(Exclude = true, ApplyToMembers = true)]
	public enum ProjectLoadMode
	{
		Default,
		ReadOnly,
		ReadAndWrite
	}
	[Obfuscation(Exclude = true, ApplyToMembers = true)]
	public enum ColorSpace
	{
		Default,
		SRGB,
		Linear
	}
	[Obfuscation(Exclude = true, ApplyToMembers = true)]
	public enum PagingStrategy
	{
		Default,
		GTPPerLevel,
		GTPPerGTex
	}
	public class ExtraMath
	{
		public static double Frac(double x)
		{
			return x - Math.Floor(x);
		}

		public static bool IsPowerOfTwo(ulong x)
		{
			if (x != 0L)
			{
				return (x & (x - 1)) == 0;
			}
			return false;
		}

		public static bool IsPowerOfTwo(int x)
		{
			if (x >= 0)
			{
				if (x != 0)
				{
					return (x & (x - 1)) == 0;
				}
				return false;
			}
			return false;
		}

		public static int NearestPowerOfTwo(int x)
		{
			int num = NextPowerOfTwo(x);
			int num2 = PreviousPowerOfTwo(x);
			int num3 = num - x;
			int num4 = x - num2;
			if (num3 >= num4)
			{
				return num2;
			}
			return num;
		}

		public static int NextPowerOfTwo(int x)
		{
			x--;
			x |= x >> 1;
			x |= x >> 2;
			x |= x >> 4;
			x |= x >> 8;
			x |= x >> 16;
			return x + 1;
		}

		public static int PreviousPowerOfTwo(int x)
		{
			x |= x >> 1;
			x |= x >> 2;
			x |= x >> 4;
			x |= x >> 8;
			x |= x >> 16;
			return x - (x >> 1);
		}

		public static int RoundUpToPowerOfTwo(int v)
		{
			switch (v)
			{
			case 0:
				return 0;
			case 1:
				return 1;
			default:
			{
				int num = (int)Math.Ceiling(Math.Log(v, 2.0));
				return 2 << num - 1;
			}
			}
		}

		public static int Log2(int x)
		{
			int num = 0;
			while ((x >>= 1) != 0)
			{
				num++;
			}
			return num;
		}
	}
	public class NixelInterface
	{
		public static bool IsInitialized;

		private static NixelInitializationInfo initInfo;

		public static NixelInitializationInfo InitializationInfo => initInfo;

		public static Nixel.Error InitializeNixel()
		{
			if (IsInitialized)
			{
				return Nixel.Error.InvalidState;
			}
			string fullName = new FileInfo(Assembly.GetEntryAssembly().Location).Directory.FullName;
			string currentDirectory = Directory.GetCurrentDirectory();
			Directory.SetCurrentDirectory(fullName);
			Nixel.Error num = ITileFileFactory.Initialize(ref initInfo);
			Directory.SetCurrentDirectory(currentDirectory);
			IsInitialized = num == Nixel.Error.Ok;
			return num;
		}

		public static Nixel.Error ReleaseNixel()
		{
			if (!IsInitialized)
			{
				return Nixel.Error.InvalidState;
			}
			Nixel.Error num = ITileFileFactory.Release();
			IsInitialized = num != Nixel.Error.Ok;
			return num;
		}
	}
	public enum SlowTask
	{
		Preprocess,
		ImportProcess,
		AtlasProcess,
		ComposeAndCodeProcess,
		OrderProcess,
		TileFilePreTaskProcess,
		TileFileBuildProcess,
		PostProcess,
		Composing,
		Coding,
		Cleaning
	}
	public class ProgressTracker<T> where T : IComparable
	{
		public struct TaskDescription
		{
			public T Task { get; set; }

			public double EstimatedContribution { get; set; }

			public TaskDescription(T task, double estimatedContribution)
			{
				this = default(TaskDescription);
				EstimatedContribution = estimatedContribution;
				Task = task;
			}
		}

		public delegate void ProgressTickEventHandler(object sender, long min, long max, long value);

		public delegate void ProgressTextEventHandler(object sender, string text);

		public delegate void TaskStartedEventHandler(object sender, TaskDescription desc);

		public delegate void AssetStartedEventHandler(object sender, Asset a, int assetIndex, int assetCount);

		public delegate void TaskFinishedEventHandler(object sender, TaskDescription desc);

		private Stack<TaskDescription> tasks;

		public event ProgressTickEventHandler ProgressTick;

		public event ProgressTextEventHandler ProgressText;

		public event TaskStartedEventHandler TaskStarted;

		public event AssetStartedEventHandler AssetStarted;

		public event TaskFinishedEventHandler TaskFinished;

		protected virtual void OnProgressTick(long min, long max, long value)
		{
			this.ProgressTick?.Invoke(this, min, max, value);
		}

		protected virtual void OnProgressText(string text)
		{
			this.ProgressText?.Invoke(this, text);
		}

		protected virtual void OnTaskStarted(TaskDescription desc)
		{
			this.TaskStarted?.Invoke(this, desc);
		}

		protected virtual void OnAssetStarted(Asset a, int assetIndex, int assetCount)
		{
			this.AssetStarted?.Invoke(this, a, assetIndex, assetCount);
		}

		protected virtual void OnTaskFinished(TaskDescription desc)
		{
			this.TaskFinished?.Invoke(this, desc);
		}

		public ProgressTracker()
		{
			tasks = new Stack<TaskDescription>();
		}

		public void StartTask(T task, double estimatedContribution)
		{
			TaskDescription taskDescription = new TaskDescription(task, estimatedContribution);
			tasks.Push(taskDescription);
			OnTaskStarted(taskDescription);
		}

		public void StartTask(T task)
		{
			StartTask(task, 1.0);
		}

		public void EndTask(T task)
		{
			TaskDescription desc = tasks.Pop();
			OnTaskFinished(desc);
		}

		public void StartAsset(Asset a, int assetIndex, int assetCount)
		{
			OnAssetStarted(a, assetIndex, assetCount);
		}

		public void UpdateProgress(long min, long max, long value)
		{
			OnProgressTick(min, max, value);
		}

		public void UpdateText(string text)
		{
			OnProgressText(text);
		}
	}
	public class SolutionProjectDecriptor
	{
		public Guid Id { get; set; }

		public string FilePath { get; set; }

		public string Name { get; set; }
	}
	public class Solution
	{
		public string Name { get; set; }

		public Guid Id { get; set; }

		public Dictionary<Guid, SolutionProjectDecriptor> Projects { get; set; }

		public Solution()
		{
			Name = "unnamed";
			Projects = new Dictionary<Guid, SolutionProjectDecriptor>();
		}
	}
	public class SolutionBuilder
	{
		public delegate void ProjectAddedEventHandler(object sender, SolutionProjectDecriptor project, ProjectBuilder builder, bool isNew);

		public delegate void ProjectRemovedEventHandler(object sender, SolutionProjectDecriptor project);

		public delegate void ProjectLoadedEventHandler(object sender, SolutionProjectDecriptor project);

		public delegate void ProjectUnloadedEventHandler(object sender, SolutionProjectDecriptor project);

		public delegate void SolutionLoadedEventHandler(object sender, Solution solution);

		public delegate void SolutionLoadingEventHandler(object sender);

		public delegate void SolutionClosedEventHandler(object sender);

		public delegate void SolutionClosingEventHandler(object sender, Solution solution);

		public delegate void ProjectBuildEventHandler(object sender, ProjectBuilder builder);

		public delegate void ProjectCleanStartingEventHandler(object sender, ProjectBuilder builder);

		public delegate void ProjectCleanFinishedEventHandler(object sender, ProjectBuilder builder);

		public delegate void ProjectRepageStartingEventHandler(object sender, ProjectBuilder builder);

		public delegate void ProjectRepageFinishedEventHandler(object sender, ProjectBuilder builder);

		public delegate void ProjectUpgradingEventHandler(object sender, ProjectBuilder builder, ProjectBuilder.UpgradeInfo info);

		public delegate void OnSetBuildErrorHandles(ProjectBuilder builder);

		private string lockFileName;

		private FileLock fileLock;

		private bool Canceled;

		private string SolutionFileName { get; set; }

		private string SolutionPath { get; set; }

		public Solution ActiveSolution { get; private set; }

		public Dictionary<Guid, ProjectBuilder> ProjectBuilders { get; private set; }

		public string ActiveSolutionFullPath => Path.Combine(SolutionPath, SolutionFileName);

		public bool ExportImportScriptOnSave { get; set; }

		public Logger Logger { get; private set; }

		public bool ReadOnly { get; set; }

		public bool ProjectsReadOnly { get; set; }

		public SolutionBuilderReportingHandler BuildReportingHandler { get; private set; }

		public event ProjectAddedEventHandler ProjectAdded;

		public event ProjectRemovedEventHandler ProjectRemoved;

		public event ProjectLoadedEventHandler ProjectLoaded;

		public event ProjectUnloadedEventHandler ProjectUnloaded;

		public event SolutionLoadedEventHandler SolutionLoaded;

		public event SolutionLoadingEventHandler SolutionLoading;

		public event SolutionClosedEventHandler SolutionClosed;

		public event SolutionClosingEventHandler SolutionClosing;

		public event ProjectBuildEventHandler ProjectBuildStarting;

		public event ProjectBuildEventHandler ProjectBuildFinished;

		public event ProjectCleanStartingEventHandler ProjectCleanStarting;

		public event ProjectCleanFinishedEventHandler ProjectCleanFinished;

		public event ProjectRepageStartingEventHandler ProjectRepageStarting;

		public event ProjectRepageFinishedEventHandler ProjectRepageFinished;

		public event EventHandler SolutionBuildStarting;

		public event EventHandler SolutionBuildFinished;

		public event ProjectUpgradingEventHandler ProjectUpgrading;

		protected virtual void OnProjectAdded(SolutionProjectDecriptor project, ProjectBuilder builder, bool isNew)
		{
			this.ProjectAdded?.Invoke(this, project, builder, isNew);
		}

		protected virtual void OnProjectRemoved(SolutionProjectDecriptor project)
		{
			this.ProjectRemoved?.Invoke(this, project);
		}

		protected virtual void OnProjectLoaded(SolutionProjectDecriptor project)
		{
			this.ProjectLoaded?.Invoke(this, project);
		}

		protected virtual void OnProjectUnloaded(SolutionProjectDecriptor project)
		{
			this.ProjectUnloaded?.Invoke(this, project);
		}

		protected virtual void OnSolutionLoaded(Solution solution)
		{
			this.SolutionLoaded?.Invoke(this, solution);
		}

		protected virtual void OnSolutionLoading()
		{
			this.SolutionLoading?.Invoke(this);
		}

		protected virtual void OnSolutionClosed()
		{
			this.SolutionClosed?.Invoke(this);
		}

		protected virtual void OnSolutionClosing(Solution solution)
		{
			this.SolutionClosing?.Invoke(this, solution);
		}

		protected virtual void OnProjectBuildStarting(ProjectBuilder builder)
		{
			this.ProjectBuildStarting?.Invoke(this, builder);
		}

		protected virtual void OnProjectBuildFinished(ProjectBuilder builder)
		{
			this.ProjectBuildFinished?.Invoke(this, builder);
		}

		protected virtual void OnProjectCleanStarting(ProjectBuilder builder)
		{
			this.ProjectCleanStarting?.Invoke(this, builder);
		}

		protected virtual void OnProjectCleanFinished(ProjectBuilder builder)
		{
			this.ProjectCleanFinished?.Invoke(this, builder);
		}

		protected virtual void OnProjectRepageStarting(ProjectBuilder builder)
		{
			this.ProjectRepageStarting?.Invoke(this, builder);
		}

		protected virtual void OnProjectRepageFinished(ProjectBuilder builder)
		{
			this.ProjectRepageFinished?.Invoke(this, builder);
		}

		protected virtual void OnSolutionBuildStarting()
		{
			this.SolutionBuildStarting?.Invoke(this, new EventArgs());
		}

		protected virtual void OnSolutionBuildFinished()
		{
			this.SolutionBuildFinished?.Invoke(this, new EventArgs());
		}

		protected virtual void OnProjectUpgrading(ProjectBuilder builder, ProjectBuilder.UpgradeInfo info)
		{
			this.ProjectUpgrading?.Invoke(this, builder, info);
		}

		public SolutionBuilder()
		{
			ProjectBuilders = new Dictionary<Guid, ProjectBuilder>();
			BuildReportingHandler = new SolutionBuilderReportingHandler();
			Logger = new Logger(Defaults.Verbosity);
		}

		public bool IsSolutionLoaded()
		{
			return ActiveSolution != null;
		}

		public static XMLValidator.XMLValidationResult ValidateSolutionFile(string xmlFilename)
		{
			XMLValidator xMLValidator = new XMLValidator();
			try
			{
				return xMLValidator.ValidationResult;
			}
			catch (FileNotFoundException)
			{
				return new XMLValidator.XMLValidationResult
				{
					Errors = { "File not found: " + xmlFilename }
				};
			}
		}

		public Error LoadSolution(string filename, bool createIfNotExist)
		{
			return LoadSolution(filename, createIfNotExist, ProjectLoadMode.Default);
		}

		public Error LoadSolution(string filename, bool createIfNotExist, ProjectLoadMode mode)
		{
			if (ActiveSolution != null)
			{
				CloseSolution();
			}
			OnSolutionLoading();
			if (!Paths.IsValidFilename(filename))
			{
				throw new UnspecifiedException("The file name '" + filename + "' is invalid, please use a valid file name.", Error.InvalidParameter);
			}
			if (!File.Exists(filename))
			{
				if (!createIfNotExist)
				{
					throw new UnspecifiedException("Could not load solution. Solution does not exist.", Error.FileNotFound);
				}
				return NewSolution(filename);
			}
			bool flag = FileTools.FileCanReadWrite(filename);
			if (mode == ProjectLoadMode.ReadAndWrite && !flag)
			{
				throw new UnspecifiedException("Solution '" + filename + "' could not be opened for writing.", Error.IOError);
			}
			ReadOnly = !flag;
			if (!LockSolution(filename))
			{
				return Error.SolutionLocked;
			}
			XMLValidator.XMLValidationResult xMLValidationResult = ValidateSolutionFile(filename);
			if (!xMLValidationResult.Valid)
			{
				CloseSolution();
				throw new UnspecifiedException("The solution file '" + filename + "' is invalid and could not be validated. Please provide a valid solution file or create a new solution. Validation error: " + xMLValidationResult.ToString(), Error.XMLValidation);
			}
			Solution solution;
			try
			{
				XMLEngine.ReadSolution(filename, out solution);
			}
			catch (UnspecifiedException ex)
			{
				CloseSolution();
				throw new UnspecifiedException("Unable to read solution file '" + filename + "'. Please make sure the file is accessible, contains a valid solution or please create a new solution. Error description: '" + ex.Message + "'.", ex.ErrorCode, ex);
			}
			catch (Exception ex2)
			{
				CloseSolution();
				throw new UnspecifiedException("Unable to read solution file '" + filename + "'. Please make sure the file is accessible, contains a valid solution or please create a new solution. Error description: '" + ex2.Message + "'.", Error.Unknown, ex2);
			}
			ActiveSolution = solution;
			SolutionFileName = Path.GetFileName(filename);
			SolutionPath = Directory.GetParent(Path.GetFullPath(filename)).FullName;
			try
			{
				Directory.SetCurrentDirectory(SolutionPath);
			}
			catch (Exception ex3)
			{
				CloseSolution();
				throw new UnspecifiedException("Unable to initialize the solution working directory, detailed error: '" + ex3.Message + "'", Error.Unknown, ex3);
			}
			bool flag2 = false;
			try
			{
				LoadProjects();
				flag2 = true;
			}
			catch (UnspecifiedException)
			{
				throw;
			}
			catch (GrBuildException)
			{
				throw;
			}
			catch (Exception ex6)
			{
				throw new UnspecifiedException("Unspecified error loading project. Detailed message: " + ex6.Message, Error.Unknown);
			}
			finally
			{
				if (!flag2)
				{
					try
					{
						CloseSolution();
					}
					catch
					{
					}
				}
			}
			OnSolutionLoaded(solution);
			return Error.Ok;
		}

		public Error NewSolution(string filename)
		{
			if (ActiveSolution != null)
			{
				CloseSolution();
			}
			if (!Paths.IsValidFilename(filename))
			{
				throw new UnspecifiedException("The file name '" + filename + "' is invalid, please use a valid file name", Error.Unknown);
			}
			string fullName = Directory.GetParent(Path.GetFullPath(filename)).FullName;
			try
			{
				Directory.CreateDirectory(fullName);
			}
			catch (Exception ex)
			{
				throw new UnspecifiedException("Unable to create solution folder '" + SolutionPath + "', detailed error: '" + ex.Message + "'", Error.Unknown, ex);
			}
			if (File.Exists(filename))
			{
				throw new UnspecifiedException("Could not create new solution, solution already exists", Error.FileAlreadyExists);
			}
			if (!LockSolution(filename))
			{
				throw new UnspecifiedException("Could not get a lock on solution the new solution file. Make sure you have access to the file.", Error.SolutionLocked);
			}
			ActiveSolution = new Solution();
			ActiveSolution.Id = Guid.NewGuid();
			ActiveSolution.Name = Path.GetFileNameWithoutExtension(filename);
			SolutionFileName = Path.GetFileName(filename);
			SolutionPath = fullName;
			Error error = Save();
			if (error != 0)
			{
				return error;
			}
			OnSolutionLoaded(ActiveSolution);
			return Error.Ok;
		}

		public void CloseSolution()
		{
			OnSolutionClosing(ActiveSolution);
			if (ActiveSolution != null)
			{
				UnloadProjects();
				ActiveSolution = null;
			}
			UnlockSolution();
			ReadOnly = false;
			ProjectsReadOnly = false;
			OnSolutionClosed();
		}

		public bool SaveSolution()
		{
			if (ActiveSolution == null)
			{
				return false;
			}
			if (ReadOnly)
			{
				return true;
			}
			try
			{
				XMLEngine.WriteSolution(ActiveSolutionFullPath, ActiveSolution);
			}
			catch (Exception ex)
			{
				throw new UnspecifiedException("Unable to save the Solution file '" + SolutionFileName + "', detailed error: '" + ex.Message + "'", Error.Unknown, ex);
			}
			return true;
		}

		private Error Save()
		{
			if (ReadOnly)
			{
				return Error.Ok;
			}
			string text = Path.Combine(SolutionPath, ActiveSolution.Name + ".xtmp");
			try
			{
				XMLEngine.WriteSolution(text, ActiveSolution);
			}
			catch (Exception ex)
			{
				throw new UnspecifiedException("Unable to write a temporary version of the solution file '" + text + ". Detailed error: '" + ex.Message + "' please make sure that no other process is using the project files, the project folder is accessible and try again", Error.IOError, ex);
			}
			try
			{
				if (File.Exists(ActiveSolutionFullPath))
				{
					File.Delete(ActiveSolutionFullPath);
				}
				File.Move(text, ActiveSolutionFullPath);
			}
			catch (Exception ex2)
			{
				throw new UnspecifiedException("Unable to write the solution file '" + SolutionFileName + ". Detailed error: '" + ex2.Message + "' please make sure that no other process is using the solution file, the solution folder is accessible and try again", Error.IOError, ex2);
			}
			return Error.Ok;
		}

		private void SetDefaultBuildErrorHandles(ProjectBuilder builder)
		{
			builder.BuildReportingHandler.OnErrorHandler += BuildReportingHandler_OnErrorHandler;
			builder.BuildReportingHandler.OnFatalErrorHandler += BuildReportingHandler_OnFatalErrorHandler;
			builder.BuildReportingHandler.OnWarningHandler += BuildReportingHandler_OnWarningHandler;
			builder.BuildReportingHandler.OnInfoHandler += BuildReportingHandler_OnInfoHandler;
		}

		private Error CreateNewProjectInternal(string name, string path, LayerConfig template, string xmlPath, out Guid projectId, OnSetBuildErrorHandles setBuildErrorHandles = null, bool overwrite = false)
		{
			projectId = Guid.Empty;
			SolutionProjectDecriptor solutionProjectDecriptor = new SolutionProjectDecriptor();
			solutionProjectDecriptor.Name = name;
			string text = Path.Combine(path, name + "." + Constants.ProjectExtension);
			solutionProjectDecriptor.FilePath = Paths.GetRelativePathForFile(SolutionPath, text);
			if (File.Exists(text) && !overwrite)
			{
				return Error.FileAlreadyExists;
			}
			ProjectBuilder projectBuilder = new ProjectBuilder();
			if (setBuildErrorHandles != null)
			{
				setBuildErrorHandles(projectBuilder);
			}
			else
			{
				SetDefaultBuildErrorHandles(projectBuilder);
			}
			Error error = projectBuilder.NewProject(text);
			if (error != 0)
			{
				return error;
			}
			solutionProjectDecriptor.Id = projectBuilder.ActiveProject.Id;
			projectId = solutionProjectDecriptor.Id;
			if (template != null)
			{
				error = projectBuilder.SetLayerConfig(template);
				if (error != 0)
				{
					return error;
				}
			}
			else if (xmlPath != null)
			{
				try
				{
					error = projectBuilder.Import(xmlPath);
					if (error != 0)
					{
						return error;
					}
				}
				catch (GrXmlException)
				{
					return Error.XMLParsing;
				}
				catch (InvalidLayerConfigurationException)
				{
					return Error.XMLParsing;
				}
				catch (MissingLayerConfigurationException)
				{
					return Error.XMLParsing;
				}
				catch (FileNotFoundException)
				{
					return Error.FileNotFound;
				}
				catch (Exception ex5)
				{
					throw ex5;
				}
			}
			projectBuilder.ExportImportScriptOnSave = ExportImportScriptOnSave;
			projectBuilder.SaveProject();
			ActiveSolution.Projects.Add(solutionProjectDecriptor.Id, solutionProjectDecriptor);
			ProjectBuilders.Add(solutionProjectDecriptor.Id, projectBuilder);
			OnProjectAdded(solutionProjectDecriptor, projectBuilder, isNew: true);
			OnProjectLoaded(solutionProjectDecriptor);
			Save();
			return Error.Ok;
		}

		public Error CreateNewProjectFromXML(string name, string path, string xmlPath, out Guid projectId, OnSetBuildErrorHandles setBuildErrorHandles = null, bool overwrite = false)
		{
			return CreateNewProjectInternal(name, path, null, xmlPath, out projectId, setBuildErrorHandles, overwrite);
		}

		public Error CreateNewProject(string name, string path, LayerConfig template, out Guid projectId)
		{
			return CreateNewProjectInternal(name, path, template, null, out projectId);
		}

		public Error RemoveProject(Guid projectId)
		{
			if (!ActiveSolution.Projects.ContainsKey(projectId))
			{
				return Error.InvalidParameter;
			}
			SolutionProjectDecriptor project = ActiveSolution.Projects[projectId];
			UnloadProject(project);
			ActiveSolution.Projects.Remove(projectId);
			OnProjectRemoved(project);
			SaveSolution();
			return Error.Ok;
		}

		private ErrorAction BuildReportingHandler_OnErrorHandler(ProjectBuilder source, BuildProcess processId, BuildIssue buildIssue)
		{
			return BuildReportingHandler.OnError(source, processId, buildIssue);
		}

		private void BuildReportingHandler_OnWarningHandler(ProjectBuilder source, BuildProcess processId, BuildIssue buildIssue)
		{
			BuildReportingHandler.OnWarning(source, processId, buildIssue);
		}

		private void BuildReportingHandler_OnInfoHandler(ProjectBuilder source, BuildProcess processId, BuildIssue buildIssue)
		{
			BuildReportingHandler.OnInfo(source, processId, buildIssue);
		}

		private void BuildReportingHandler_OnFatalErrorHandler(ProjectBuilder source, BuildProcess processId, BuildIssue buildIssue)
		{
			BuildReportingHandler.OnFatalError(source, processId, buildIssue);
		}

		public void LoadConfiguration(TargetConfiguration configuration)
		{
			if (ActiveSolution != null)
			{
				List<SolutionProjectDecriptor> list = ActiveSolution.Projects.Values.ToList();
				for (int i = 0; i < ActiveSolution.Projects.Count; i++)
				{
					ProjectBuilders[list[i].Id].LoadConfiguration(configuration);
				}
			}
		}

		public void BuildSolution(BuildMode buildMode)
		{
			if (ActiveSolution == null)
			{
				return;
			}
			OnSolutionBuildStarting();
			List<SolutionProjectDecriptor> list = ActiveSolution.Projects.Values.ToList();
			for (int i = 0; i < ActiveSolution.Projects.Count; i++)
			{
				if (Canceled)
				{
					break;
				}
				if (!BuildProject(projectBuildOptions: new ProjectBuildOptions(buildMode, allowForeignGTex: false, forceUseGTex: false, buildnotileset: false), projectId: list[i].Id))
				{
					break;
				}
			}
			OnSolutionBuildFinished();
		}

		public bool BuildProject(Guid projectId, ProjectBuildOptions projectBuildOptions)
		{
			if (ActiveSolution == null)
			{
				return false;
			}
			if (!ActiveSolution.Projects.ContainsKey(projectId))
			{
				throw new UnspecifiedException("Invalid or unknown project Id:'" + projectId.ToString() + "'. Build aborting.", Error.InvalidParameter);
			}
			ProjectBuilder projectBuilder = ProjectBuilders[projectId];
			projectBuilder.AllowForeignGTex = projectBuildOptions.allowForeignGTex;
			projectBuilder.ForceUseGTex = projectBuildOptions.forceUseGTex;
			projectBuilder.NoGTSBuilding = projectBuildOptions.buildnotileset;
			OnProjectBuildStarting(projectBuilder);
			projectBuilder.Build(Task.Build, Process.All, projectBuildOptions.buildMode);
			OnProjectBuildFinished(projectBuilder);
			return true;
		}

		public void RebuildSolution(BuildMode buildMode)
		{
			if (ActiveSolution != null)
			{
				CleanSolution();
				BuildSolution(buildMode);
			}
		}

		public bool RebuildProject(Guid projectId, BuildMode buildMode)
		{
			if (!CleanProject(projectId))
			{
				return false;
			}
			ProjectBuildOptions projectBuildOptions = new ProjectBuildOptions(buildMode, allowForeignGTex: false, forceUseGTex: false, buildnotileset: false);
			if (!BuildProject(projectId, projectBuildOptions))
			{
				return false;
			}
			return true;
		}

		public void CleanSolution()
		{
			if (ActiveSolution == null)
			{
				return;
			}
			List<SolutionProjectDecriptor> list = ActiveSolution.Projects.Values.ToList();
			for (int i = 0; i < ActiveSolution.Projects.Count; i++)
			{
				if (Canceled)
				{
					break;
				}
				ProjectBuilder projectBuilder = ProjectBuilders[list[i].Id];
				OnProjectCleanStarting(projectBuilder);
				projectBuilder.Build(Task.Clean, Process.All);
				OnProjectCleanFinished(projectBuilder);
			}
		}

		public bool CleanProject(Guid projectId)
		{
			return CleanProject(projectId, Defaults.CleanOperationParameters);
		}

		public bool CleanProject(Guid projectId, CleanOperationParameters cleanParams)
		{
			if (ActiveSolution == null)
			{
				return false;
			}
			if (!ActiveSolution.Projects.ContainsKey(projectId))
			{
				throw new UnspecifiedException("Invalid or unknown project Id:'" + projectId.ToString() + "'. Clean aborting.", Error.InvalidParameter);
			}
			ProjectBuilder projectBuilder = ProjectBuilders[ActiveSolution.Projects[projectId].Id];
			projectBuilder.SetCleanOperationParameters(cleanParams);
			OnProjectCleanStarting(projectBuilder);
			projectBuilder.Build(Task.Clean, Process.All);
			OnProjectCleanFinished(projectBuilder);
			return true;
		}

		public bool RepageProject(Guid projectId)
		{
			if (ActiveSolution == null)
			{
				return false;
			}
			if (!ActiveSolution.Projects.ContainsKey(projectId))
			{
				throw new UnspecifiedException("Invalid or unknown project Id:'" + projectId.ToString() + "'. Repage aborting.", Error.InvalidParameter);
			}
			ProjectBuilder projectBuilder = ProjectBuilders[ActiveSolution.Projects[projectId].Id];
			OnProjectRepageStarting(projectBuilder);
			projectBuilder.Build(Task.Repage, Process.All);
			OnProjectRepageFinished(projectBuilder);
			return true;
		}

		public void CancelBuild(bool cancel)
		{
			if (ActiveSolution != null)
			{
				Canceled = cancel;
				List<SolutionProjectDecriptor> list = ActiveSolution.Projects.Values.ToList();
				for (int i = 0; i < ActiveSolution.Projects.Count; i++)
				{
					ProjectBuilders[list[i].Id].Cancel(cancel);
				}
			}
		}

		public Error LoadProjects()
		{
			foreach (SolutionProjectDecriptor item in ActiveSolution.Projects.Values.ToList())
			{
				ProjectBuilder builder;
				Error error = LoadProject(item, out builder);
				if (error != 0)
				{
					return error;
				}
				ProjectsReadOnly = ProjectsReadOnly || builder.ReadOnly;
			}
			return Error.Ok;
		}

		public bool UnloadProjects()
		{
			if (ActiveSolution == null)
			{
				return false;
			}
			foreach (SolutionProjectDecriptor value in ActiveSolution.Projects.Values)
			{
				try
				{
					UnloadProject(value);
				}
				catch (ProjectSaveException ex)
				{
					throw ex;
				}
				catch (Exception ex2)
				{
					throw new UnspecifiedException("Unable to unload project:'" + value.FilePath + "'. Detailed error: '" + ex2.Message + "'.", Error.Unknown, ex2);
				}
			}
			return true;
		}

		private Error LoadProject(SolutionProjectDecriptor project, out ProjectBuilder builder)
		{
			builder = new ProjectBuilder();
			builder.ProjectUpgrading += builder_ProjectUpgrading;
			SetDefaultBuildErrorHandles(builder);
			string absolutePath = Paths.GetAbsolutePath(SolutionPath, project.FilePath);
			Error error = Error.Ok;
			try
			{
				error = builder.LoadProject(absolutePath);
			}
			catch (UnspecifiedException ex)
			{
				throw new UnspecifiedException("Unable to load project '" + project.FilePath + "'. Detailed error: '" + ex.Message, ex.ErrorCode, ex);
			}
			if (error != 0)
			{
				return error;
			}
			if (builder.ActiveProject.Id != project.Id)
			{
				project.Id = builder.ActiveProject.Id;
			}
			builder.ExportImportScriptOnSave = ExportImportScriptOnSave;
			ProjectBuilders.Add(project.Id, builder);
			OnProjectLoaded(project);
			return Error.Ok;
		}

		private void builder_ProjectUpgrading(object sender, ProjectBuilder.UpgradeInfo info)
		{
			ProjectBuilder builder = (ProjectBuilder)sender;
			OnProjectUpgrading(builder, info);
		}

		private bool IsProjectLoaded(SolutionProjectDecriptor project)
		{
			return ProjectBuilders.ContainsKey(project.Id);
		}

		private bool UnloadProject(SolutionProjectDecriptor project)
		{
			if (!IsProjectLoaded(project))
			{
				return false;
			}
			ProjectBuilder projectBuilder = ProjectBuilders[project.Id];
			try
			{
				projectBuilder.SaveProject();
			}
			catch (Exception ex)
			{
				throw ex;
			}
			projectBuilder.CloseProject();
			ProjectBuilders.Remove(project.Id);
			OnProjectUnloaded(project);
			return true;
		}

		public ProjectBuilder GetProjectBuilder(Guid projectId)
		{
			if (!ProjectBuilders.ContainsKey(projectId))
			{
				return null;
			}
			return ProjectBuilders[projectId];
		}

		public ProjectBuilder GetProjectBuilder(string projectName)
		{
			SolutionProjectDecriptor value = ActiveSolution.Projects.Where((KeyValuePair<Guid, SolutionProjectDecriptor> _p) => _p.Value.Name == projectName).FirstOrDefault().Value;
			if (value != null)
			{
				return ProjectBuilders[value.Id];
			}
			return null;
		}

		private bool LockSolution(string solutionFile)
		{
			lockFileName = solutionFile + ".lock";
			if (fileLock == null)
			{
				fileLock = new FileLock(lockFileName);
				bool num = fileLock.Lock();
				if (!num)
				{
					fileLock = null;
				}
				return num;
			}
			return fileLock.Lock();
		}

		private void UnlockSolution()
		{
			if (fileLock != null)
			{
				fileLock.Unlock();
				fileLock = null;
			}
		}
	}
	public class TemplateImportScanner
	{
		public struct FoundAsset
		{
			public string Name { get; private set; }

			public Dictionary<int, CombinedTextureSource> LayerSourceTextures { get; private set; }

			public FoundAsset(string name)
			{
				this = default(FoundAsset);
				Name = name;
				LayerSourceTextures = new Dictionary<int, CombinedTextureSource>();
			}
		}

		public List<FoundAsset> FoundAssets { get; private set; }

		public TemplateImportScanner()
		{
			FoundAssets = new List<FoundAsset>();
		}

		public void Scan(ImportAssetTemplate template)
		{
			FoundAssets = new List<FoundAsset>();
			if (template.LayerTemplates.Count == 0)
			{
				throw new TemplateException("No layers set in template, please add layers");
			}
			ImportAssetLayerTemplate importAssetLayerTemplate = template.LayerTemplates[0];
			if (importAssetLayerTemplate.Source.Sources == null || importAssetLayerTemplate.Source.Sources.Count == 0)
			{
				return;
			}
			int num = importAssetLayerTemplate.Source.GetDefaultPath().LastIndexOf('*');
			string text = ((num >= 0) ? importAssetLayerTemplate.Source.GetDefaultPath().Substring(0, num) : importAssetLayerTemplate.Source.GetDefaultPath());
			string text2 = ((num >= 0) ? importAssetLayerTemplate.Source.GetDefaultPath().Remove(0, text.Length + 1) : string.Empty);
			int num2 = Math.Max(text.LastIndexOf("/"), text.LastIndexOf("\\"));
			string path;
			string searchPattern;
			if (num2 != -1)
			{
				path = ((Path.GetDirectoryName(text) != null) ? text.Substring(0, num2) : (text.Substring(0, num2) + "\\"));
				searchPattern = importAssetLayerTemplate.Source.GetDefaultPath().Substring(num2 + 1);
			}
			else
			{
				path = ".";
				searchPattern = importAssetLayerTemplate.Source.GetDefaultPath();
			}
			string[] array;
			try
			{
				array = Directory.GetFiles(path, searchPattern);
			}
			catch (IOException)
			{
				array = new string[0];
			}
			if (array.Length == 0)
			{
				return;
			}
			List<string> list = new List<string>();
			string[] array2 = array;
			foreach (string text3 in array2)
			{
				string text4 = text3.Remove(0, text.Length);
				text4 = ((text4.Length != 0) ? text4.Substring(0, text4.Length - text2.Length) : Path.GetFileNameWithoutExtension(text3));
				list.Add(text4);
			}
			foreach (string item2 in list)
			{
				string name = template.Name.Replace("*", item2);
				FoundAsset item = new FoundAsset(name);
				for (int j = 0; j < template.LayerTemplates.Count; j++)
				{
					ImportAssetLayerTemplate importAssetLayerTemplate2 = template.LayerTemplates[j];
					CombinedTextureSource combinedTextureSource = new CombinedTextureSource();
					foreach (CombinedTextureSource.Item source in importAssetLayerTemplate2.Source.Sources)
					{
						string path2 = source.Source.Replace("*", item2);
						if (File.Exists(path2))
						{
							combinedTextureSource.AddSource(path2, source.SubIndex);
						}
					}
					if (combinedTextureSource.Sources.Count >= 0)
					{
						item.LayerSourceTextures.Add(j, combinedTextureSource);
					}
				}
				if (item.LayerSourceTextures.Count == template.LayerTemplates.Count)
				{
					FoundAssets.Add(item);
				}
			}
		}
	}
	public struct MipRegion
	{
		public int X { get; set; }

		public int Y { get; set; }

		public int Width { get; set; }

		public int Height { get; set; }

		public int Level { get; set; }

		public Rectangle Rectangle => new Rectangle(X, Y, Width, Height);

		public MipRegion(int x, int y, int width, int height, int level)
		{
			this = default(MipRegion);
			X = x;
			Y = y;
			Width = width;
			Height = height;
			Level = level;
		}

		public MipRegion(Rectangle rect, int level)
		{
			this = default(MipRegion);
			X = rect.Left;
			Y = rect.Top;
			Width = rect.Width;
			Height = rect.Height;
			Level = level;
		}

		public MipRegion(MipRegion region)
		{
			this = default(MipRegion);
			X = region.X;
			Y = region.Y;
			Width = region.Width;
			Height = region.Height;
			Level = region.Level;
		}

		public override string ToString()
		{
			return $"x: {X}, y: {Y}, width: {Width}, height: {Height}, level: {Level}";
		}

		private int ShiftRight(int x, int bits)
		{
			if (bits >= 0)
			{
				return x >> bits;
			}
			return x << -bits;
		}

		public MipRegion ProjectOnLevel(int level)
		{
			int bits = level - Level;
			int x = ShiftRight(X, bits);
			int y = ShiftRight(Y, bits);
			int width = ShiftRight(Width, bits);
			int height = ShiftRight(Height, bits);
			return new MipRegion(x, y, width, height, level);
		}

		private bool IsIntegralOnMip(int x, int level)
		{
			return x == x >> level << level;
		}

		public bool IsIntegralProjectionOnLevel(int level)
		{
			if (IsIntegralOnMip(X, level) && IsIntegralOnMip(Y, level) && IsIntegralOnMip(Width, level))
			{
				return IsIntegralOnMip(Height, level);
			}
			return false;
		}
	}
	internal class TileTools
	{
		public static List<Point> GetDisjointPointsInRectangle(List<Rectangle> inputRectangles, Rectangle rectangleToDisjoint)
		{
			List<Point> list = new List<Point>();
			List<Rectangle> list2 = new List<Rectangle>();
			foreach (Rectangle inputRectangle in inputRectangles)
			{
				if (inputRectangle == rectangleToDisjoint)
				{
					return list;
				}
				if (inputRectangle.IntersectsWith(rectangleToDisjoint))
				{
					list2.Add(Rectangle.Intersect(inputRectangle, rectangleToDisjoint));
				}
			}
			for (int i = rectangleToDisjoint.Left; i < rectangleToDisjoint.Right; i++)
			{
				for (int j = rectangleToDisjoint.Top; j < rectangleToDisjoint.Bottom; j++)
				{
					Point point = new Point(i, j);
					bool flag = false;
					foreach (Rectangle item in list2)
					{
						if (item.Contains(point))
						{
							flag = true;
							break;
						}
					}
					if (!flag)
					{
						list.Add(point);
					}
				}
			}
			return list;
		}

		public static Rectangle GetTileLevelRange(TileSetConfig config, Rectangle pixelRect, int level)
		{
			int tileWidth = (int)config.TileLayout.tileWidth;
			int tileHeight = (int)config.TileLayout.tileHeight;
			int num = (int)Math.Pow(2.0, level);
			int num2 = pixelRect.X / num;
			int num3 = pixelRect.Y / num;
			int num4 = (pixelRect.Width + pixelRect.X) / num;
			int num5 = (pixelRect.Height + pixelRect.Y) / num;
			if (num4 == 0)
			{
				num4++;
			}
			if (num5 == 0)
			{
				num5++;
			}
			int num6 = num2 / tileWidth;
			int num7 = num3 / tileHeight;
			int width = (num4 + tileWidth - 1) / tileWidth - num6;
			int height = (num5 + tileHeight - 1) / tileHeight - num7;
			return new Rectangle(num6, num7, width, height);
		}

		public static Rectangle GetAffectedTileRange(TiledTopology topology, ProjectBuilder projectBuilder, Rectangle pixelRect, int level)
		{
			BuildState state = projectBuilder.State;
			int borderSize = (int)state.TileSetConfiguration.TileLayout.borderSize;
			int tileWidth = (int)state.TileSetConfiguration.TileLayout.tileWidth;
			int tileHeight = (int)state.TileSetConfiguration.TileLayout.tileHeight;
			int width = (int)topology.GetLevelWidth((uint)level) * tileWidth;
			int height = (int)topology.GetLevelHeight((uint)level) * tileHeight;
			Rectangle a = new Rectangle(0, 0, width, height);
			int num = (int)Math.Pow(2.0, level);
			pixelRect.X /= num;
			pixelRect.Y /= num;
			pixelRect.Width /= num;
			pixelRect.Height /= num;
			pixelRect.Inflate(borderSize, borderSize);
			pixelRect = Rectangle.Intersect(a, pixelRect);
			int num2 = pixelRect.X / tileWidth;
			int num3 = pixelRect.Y / tileHeight;
			int width2 = (pixelRect.Right + tileWidth - 1) / tileWidth - num2;
			int height2 = (pixelRect.Bottom + tileHeight - 1) / tileHeight - num3;
			return new Rectangle(num2, num3, width2, height2);
		}
	}
	public interface LogListener
	{
		Logger.Verbosity VerbosityLevel { get; set; }

		bool Supressed { get; set; }

		void LogTitle(string title, Logger.Verbosity verbosity);

		void LogLine(Logger.Verbosity verbosity);

		void LogMessage(string message, Logger.Verbosity verbosity);

		void LogCurrentLine(string message, Logger.Verbosity verbosity);

		void LogCurrentLine(string message, bool endWithNewLine, Logger.Verbosity verbosity);

		void LogConsole(string message, Logger.Verbosity verbosity);

		void LogError(string message);

		void LogWarning(string message);

		void LogInfo(string message);

		void PrintProgress(string message, bool isLast, Logger.Verbosity verbosity);
	}
	public class ConsoleLogListener : LogListener
	{
		public Logger.Verbosity VerbosityLevel { get; set; }

		public bool Supressed { get; set; }

		public bool UseColor { get; set; }

		public ConsoleLogListener()
		{
			VerbosityLevel = Defaults.Verbosity;
			UseColor = false;
			Console.OutputEncoding = Encoding.UTF8;
		}

		public void LogTitle(string title, Logger.Verbosity verbosity)
		{
			if (!Supressed && !Logger.IsMoreVerbose(verbosity, VerbosityLevel))
			{
				if (UseColor)
				{
					Console.ForegroundColor = ConsoleColor.White;
				}
				Console.WriteLine(title);
				if (UseColor)
				{
					Console.ForegroundColor = ConsoleColor.Gray;
				}
			}
		}

		public void LogLine(Logger.Verbosity verbosity)
		{
			if (!Supressed)
			{
				string value = new string('-', 40);
				if (!Logger.IsMoreVerbose(verbosity, VerbosityLevel))
				{
					Console.WriteLine(value);
				}
			}
		}

		public void LogCurrentLine(string line, Logger.Verbosity verbosity)
		{
			if (!Supressed && !Logger.IsMoreVerbose(verbosity, VerbosityLevel))
			{
				Console.Write("\r" + line);
			}
		}

		public void LogCurrentLine(string line, bool endWithNewLine, Logger.Verbosity verbosity)
		{
			if (!Supressed && !Logger.IsMoreVerbose(verbosity, VerbosityLevel))
			{
				Console.Write("\r" + line);
				if (endWithNewLine)
				{
					Console.Write("\n");
				}
			}
		}

		public void LogMessage(string message, Logger.Verbosity verbosity)
		{
			if (!Supressed && !Logger.IsMoreVerbose(verbosity, VerbosityLevel))
			{
				Console.WriteLine(message);
			}
		}

		public void LogConsole(string message, Logger.Verbosity verbosity)
		{
			if (!Supressed && !Logger.IsMoreVerbose(verbosity, VerbosityLevel))
			{
				Console.WriteLine(message);
			}
		}

		public void LogError(string message)
		{
			if (!Supressed)
			{
				string value = "ERROR: " + message;
				if (UseColor)
				{
					Console.ForegroundColor = ConsoleColor.Red;
				}
				Console.Error.WriteLine(value);
				if (UseColor)
				{
					Console.ForegroundColor = ConsoleColor.Gray;
				}
			}
		}

		public void LogWarning(string message)
		{
			if (!Supressed)
			{
				string value = "WARNING: " + message;
				if (UseColor)
				{
					Console.ForegroundColor = ConsoleColor.Yellow;
				}
				Console.WriteLine(value);
				if (UseColor)
				{
					Console.ForegroundColor = ConsoleColor.Gray;
				}
			}
		}

		public void LogInfo(string message)
		{
			if (!Supressed)
			{
				string value = "INFO: " + message;
				if (UseColor)
				{
					Console.ForegroundColor = ConsoleColor.Yellow;
				}
				Console.WriteLine(value);
				if (UseColor)
				{
					Console.ForegroundColor = ConsoleColor.Gray;
				}
			}
		}

		public void PrintProgress(string message, bool isLast, Logger.Verbosity verbosity)
		{
			if (Supressed || Logger.IsMoreVerbose(verbosity, VerbosityLevel))
			{
				return;
			}
			if (!isLast)
			{
				if (UseColor)
				{
					Console.ForegroundColor = ConsoleColor.DarkGreen;
				}
				Console.Write("\r" + message);
				if (UseColor)
				{
					Console.ForegroundColor = ConsoleColor.Gray;
				}
			}
			else
			{
				Console.Write("\r" + message);
				Console.Write("\n");
			}
		}
	}
	public class StreamLogListener : LogListener
	{
		public Logger.Verbosity VerbosityLevel { get; set; }

		public StreamWriter LogStream { get; set; }

		public bool Supressed { get; set; }

		public bool TimeStamp { get; set; }

		public StreamLogListener()
		{
			VerbosityLevel = Defaults.Verbosity;
			TimeStamp = true;
		}

		public StreamLogListener(string filename)
		{
			VerbosityLevel = Defaults.Verbosity;
			TimeStamp = true;
			Open(filename);
		}

		public void Open(string filename)
		{
			if (LogStream != null)
			{
				Close();
			}
			LogStream = new StreamWriter(filename);
			LogStream.AutoFlush = true;
		}

		public void Close()
		{
			if (LogStream != null)
			{
				LogStream.Flush();
				LogStream.Close();
				LogStream = null;
			}
		}

		private string StampTime(string value)
		{
			if (!TimeStamp)
			{
				return value;
			}
			string text = "[" + DateTime.Now.ToString("yyyy.MM.dd-HH.mm.ss:ff") + "] ";
			bool num = value.EndsWith("\n");
			if (num)
			{
				value = value.Substring(0, value.Length - 1);
			}
			string text2 = value.Replace("\n", "\n" + text);
			text2 = text + text2;
			if (num)
			{
				text2 += "\n";
			}
			return text2;
		}

		public void LogTitle(string title, Logger.Verbosity verbosity)
		{
			if (!Supressed && LogStream != null)
			{
				LogStream.WriteLine(StampTime(title));
			}
		}

		public void LogConsole(string message, Logger.Verbosity verbosity)
		{
			if (!Supressed && !Logger.IsMoreVerbose(verbosity, VerbosityLevel) && LogStream != null)
			{
				LogStream.WriteLine(StampTime(message));
			}
		}

		public void LogLine(Logger.Verbosity verbosity)
		{
			if (!Supressed)
			{
				string value = new string('-', 40);
				if (LogStream != null)
				{
					LogStream.WriteLine(StampTime(value));
				}
			}
		}

		public void LogCurrentLine(string line, Logger.Verbosity verbosity)
		{
			LogMessage(line, verbosity);
		}

		public void LogCurrentLine(string line, bool endWithNewLine, Logger.Verbosity verbosity)
		{
			LogMessage(line, verbosity);
		}

		public void LogMessage(string message, Logger.Verbosity verbosity)
		{
			if (!Supressed && LogStream != null)
			{
				LogStream.WriteLine(StampTime(message));
			}
		}

		public void LogError(string message)
		{
			if (!Supressed)
			{
				string value = "ERROR: " + message;
				if (LogStream != null)
				{
					LogStream.WriteLine(StampTime(value));
				}
			}
		}

		public void LogWarning(string message)
		{
			if (!Supressed)
			{
				string value = "WARNING: " + message;
				if (LogStream != null)
				{
					LogStream.WriteLine(StampTime(value));
				}
			}
		}

		public void LogInfo(string message)
		{
			if (!Supressed)
			{
				string value = "INFO: " + message;
				if (LogStream != null)
				{
					LogStream.WriteLine(StampTime(value));
				}
			}
		}

		public void PrintProgress(string message, bool isLast, Logger.Verbosity verbosity)
		{
		}
	}
	public class Logger : LogListener
	{
		public enum Verbosity
		{
			Quiet,
			Normal,
			Detailed
		}

		private Verbosity verbosityLevel;

		public bool supressed;

		private List<LogListener> loggers = new List<LogListener>();

		private readonly object countLock = new object();

		public Verbosity VerbosityLevel
		{
			get
			{
				return verbosityLevel;
			}
			set
			{
				SetVerbosity(value);
			}
		}

		public bool Supressed
		{
			get
			{
				return supressed;
			}
			set
			{
				supressed = value;
				foreach (LogListener logger in loggers)
				{
					logger.Supressed = supressed;
				}
			}
		}

		public int ErrorCount { get; private set; }

		public int WarningCount { get; private set; }

		public int InfoCount { get; private set; }

		public string LastLogged { get; private set; }

		public void RegisterLogListener(LogListener logger)
		{
			loggers.Add(logger);
			logger.VerbosityLevel = verbosityLevel;
		}

		public void UnregisterLogListener(LogListener logger)
		{
			loggers.Remove(logger);
		}

		public static bool IsMoreVerbose(Verbosity v1, Verbosity v2)
		{
			return v1 > v2;
		}

		public Logger(Verbosity verbosityLevel)
		{
			ErrorCount = 0;
			WarningCount = 0;
			InfoCount = 0;
			LastLogged = string.Empty;
			this.verbosityLevel = verbosityLevel;
		}

		public void SetVerbosity(Verbosity verbosity)
		{
			verbosityLevel = verbosity;
			foreach (LogListener logger in loggers)
			{
				logger.VerbosityLevel = verbosityLevel;
			}
		}

		public void LogTitle(string title, Verbosity verbosity)
		{
			foreach (LogListener logger in loggers)
			{
				logger.LogTitle(title, verbosity);
			}
		}

		public void LogLine(Verbosity verbosity)
		{
			foreach (LogListener logger in loggers)
			{
				logger.LogLine(verbosity);
			}
		}

		public void LogConsole(string message, Verbosity verbosity)
		{
			foreach (LogListener logger in loggers)
			{
				logger.LogConsole(message, verbosity);
			}
		}

		public void LogMessage(string message, Verbosity verbosity)
		{
			LastLogged = message;
			foreach (LogListener logger in loggers)
			{
				logger.LogMessage(message, verbosity);
			}
		}

		public void LogCurrentLine(string message, Verbosity verbosity)
		{
			LastLogged = message;
			foreach (LogListener logger in loggers)
			{
				logger.LogCurrentLine(message, verbosity);
			}
		}

		public void LogCurrentLine(string message, bool endWithNewLine, Verbosity verbosity)
		{
			LastLogged = message;
			foreach (LogListener logger in loggers)
			{
				logger.LogCurrentLine(message, endWithNewLine, verbosity);
			}
		}

		public void LogError(string message)
		{
			LastLogged = message;
			foreach (LogListener logger in loggers)
			{
				if (!logger.Supressed)
				{
					logger.LogError(message);
				}
			}
		}

		public void LogError(string message, string detailedMessage)
		{
			LastLogged = message;
			string text = "";
			if (detailedMessage.Length > 0)
			{
				text = " Detailed message: " + detailedMessage;
			}
			foreach (LogListener logger in loggers)
			{
				logger.LogError(message + text);
			}
		}

		public void LogWarning(string message)
		{
			LastLogged = message;
			foreach (LogListener logger in loggers)
			{
				logger.LogWarning(message);
			}
		}

		public void LogInfo(string message)
		{
			LastLogged = message;
			foreach (LogListener logger in loggers)
			{
				logger.LogInfo(message);
			}
		}

		public void PrintProgress(string message, bool isLast, Verbosity verbosity)
		{
			foreach (LogListener logger in loggers)
			{
				logger.PrintProgress(message, isLast, verbosity);
			}
		}
	}
	internal class Metadata
	{
		private static Int2 FindFaceSoupedAsset(Guid faceId, List<PackedSoupFileInfo> soupFileInfos)
		{
			foreach (PackedSoupFileInfo soupFileInfo in soupFileInfos)
			{
				if (soupFileInfo.SoupFileInfo.SoupState.SoupedAssets.TryGetValue(faceId, out var value))
				{
					return new Int2(soupFileInfo.X + value.X, soupFileInfo.Y + value.Y);
				}
			}
			throw new InvalidProgramStateException("Cube map imported, but no souped 6 faces found.");
		}

		private static StructDataItem CreateCubeMapMetaData(Asset asset, ProjectBuilder builder, List<PackedSoupFileInfo> soupFileInfos)
		{
			Asset[] array = AssetTools.FindCubeMapAssets(builder.ActiveProject, asset.AssetGroupId);
			if (array.Length != 6)
			{
				throw new InvalidProgramStateException("Cube map imported, but no 6 faces found.");
			}
			StructDataItem structDataItem = DataItem.New("CUBE", DataItem.New("NAME", asset.AssetGroupId), DataItem.New("WDTH", asset.Width), DataItem.New("HGHT", asset.Height), DataItem.New("ADDR", asset.TilingMethod.ToString()));
			StructDataItem structDataItem2 = DataItem.New("FACS");
			foreach (Asset asset2 in array)
			{
				Int2 @int = FindFaceSoupedAsset(asset2.Id, soupFileInfos);
				StructDataItem item = DataItem.New("FACE", DataItem.New("NAME", asset2.Name), DataItem.New("WDTH", asset2.Width), DataItem.New("HGHT", asset2.Height), DataItem.New("XXXX", @int.X), DataItem.New("YYYY", @int.Y));
				structDataItem2.Add(item);
			}
			structDataItem.Add(structDataItem2);
			return structDataItem;
		}

		private static int[] GetSRGBArray(Asset asset, Project project)
		{
			int[] array = new int[asset.AssetLayers.Count];
			for (int i = 0; i < asset.AssetLayers.Count; i++)
			{
				DataType dataType = project.LayerConfiguration.Layers[i].DataType;
				ColorSpace colorSpace = asset.AssetLayers[i].ColorSpace;
				if (colorSpace == ColorSpace.Default)
				{
					colorSpace = ((!DataTypeInfo.IsLinear(dataType)) ? ColorSpace.SRGB : ColorSpace.Linear);
				}
				array[i] = ((colorSpace == ColorSpace.SRGB) ? 1 : 0);
			}
			return array;
		}

		public static byte[] CreateMetaData(ProjectBuilder projectBuilder, List<PackedSoupFileInfo> soupFileInfos)
		{
			StructDataItem structDataItem = DataItem.New("META");
			StructDataItem structDataItem2 = DataItem.New("ATLS");
			structDataItem.Add(structDataItem2);
			StructDataItem structDataItem3 = DataItem.New("TXTS");
			structDataItem2.Add(structDataItem3);
			SoupedAsset soupedAsset = null;
			foreach (PackedSoupFileInfo soupFileInfo in soupFileInfos)
			{
				BuildState.SoupState soupState = soupFileInfo.SoupFileInfo.SoupState;
				foreach (Asset value3 in soupState.Assets.Values)
				{
					SoupedAsset soupedAsset2 = soupState.SoupedAssets[value3.Id];
					soupedAsset = soupedAsset2;
					if (value3.Type == AssetType.CubeMap)
					{
						if (value3.Face == 0)
						{
							StructDataItem item = CreateCubeMapMetaData(value3, projectBuilder, soupFileInfos);
							structDataItem3.Add(item);
						}
						continue;
					}
					int x = soupFileInfo.X;
					int y = soupFileInfo.Y;
					int[] sRGBArray = GetSRGBArray(value3, projectBuilder.ActiveProject);
					StructDataItem structDataItem4 = DataItem.New("TXTR", DataItem.New("NAME", value3.Name), DataItem.New("WDTH", value3.Width), DataItem.New("HGHT", value3.Height), DataItem.New("XXXX", x), DataItem.New("YYYY", y), DataItem.New("ADDR", soupedAsset2.TilingMethod.ToString()), DataItem.New("SRGB", sRGBArray));
					if (value3.UDimSettings[0] != null)
					{
						StructDataItem item2 = DataItem.New("UDIM", DataItem.New("WDTH", value3.UDimSettings[0].UTiles), DataItem.New("HGHT", value3.UDimSettings[0].VTiles), DataItem.New("XXXX", value3.UDimSettings[0].UTileOffset), DataItem.New("YYYY", value3.UDimSettings[0].VTileOffset));
						structDataItem4.Add(item2);
					}
					Guid[] array = new Guid[value3.AssetLayers.Count];
					bool flag = false;
					for (int i = 0; i < soupedAsset2.Layers.Count; i++)
					{
						if (soupedAsset2.Layers[i].Thumbnail != Guid.Empty)
						{
							flag = true;
						}
						array[i] = soupedAsset2.Layers[i].Thumbnail;
					}
					if (flag)
					{
						structDataItem4.Add(new GuidArrayDataItem("THMB", array));
					}
					structDataItem3.Add(structDataItem4);
				}
			}
			if (projectBuilder.WriteDebugMetaData)
			{
				StringDataItem item3 = DataItem.New("PROJ", XMLEngine.WriteProjectToString(projectBuilder.ActiveProject));
				structDataItem.Add(item3);
			}
			bool flag2 = false;
			foreach (Guid key in projectBuilder.State.IncrementalStates.Keys)
			{
				flag2 = flag2 || projectBuilder.State.AssetBuiltIncrementally(key);
			}
			if (flag2)
			{
				StructDataItem item4 = DataItem.New("BINF", DataItem.New("MODE", "Incremental"));
				structDataItem.Add(item4);
			}
			if (soupedAsset == null)
			{
				throw new InvalidProgramStateException("Metadata creation failed. No souped asset found.");
			}
			StructDataItem structDataItem5 = DataItem.New("LINF");
			for (int j = 0; j < projectBuilder.ActiveProject.LayerConfiguration.Layers.Count; j++)
			{
				string value = soupedAsset.Layers[j].FixedTexFormat.ToString();
				string layerName = projectBuilder.ActiveProject.LayerConfiguration.Layers[j].LayerName;
				if (layerName == null)
				{
					StructDataItem item5 = DataItem.New("LAYR", DataItem.New("INDX", j), DataItem.New("TYPE", value));
					structDataItem5.Add(item5);
				}
				else
				{
					StructDataItem item6 = DataItem.New("LAYR", DataItem.New("INDX", j), DataItem.New("TYPE", value), DataItem.New("NAME", layerName));
					structDataItem5.Add(item6);
				}
			}
			structDataItem.Add(structDataItem5);
			int value2 = (Constants.LightmapMode ? 1 : 0);
			StructDataItem structDataItem6 = DataItem.New("INFO", DataItem.New("COMP", DataItem.New("CMPW", DataItem.New("MAJR", Constants.CompatibleWith.Major), DataItem.New("MINR", Constants.CompatibleWith.Minor)), DataItem.New("BLDV", DataItem.New("MAJR", Constants.Version.BuildVersion.Major), DataItem.New("MINR", Constants.Version.BuildVersion.Minor), DataItem.New("BINF", Constants.Version.BuildInfo))), DataItem.New("DATE", DateTimeManagement.SerializeDateTimeToString(DateTime.Now)), DataItem.New("BLKS", projectBuilder.ActiveProject.BuildConfiguration.BlockSize.ToString()), DataItem.New("TILE", projectBuilder.ActiveProject.BuildConfiguration.TilingMode.ToString()), DataItem.New("BDPR", projectBuilder.ActiveProject.BuildProfile), DataItem.New("LTMP", value2));
			if (GrBuildLibInterface.InitializationInfo.nixelInfo.value4.Length > 0)
			{
				string s = GrBuildLibInterface.InitializationInfo.nixelInfo.value4.ToLowerInvariant();
				byte[] bytes = Encoding.UTF8.GetBytes(s);
				byte[] hash;
				using (HashAlgorithm hashAlgorithm = MD5.Create())
				{
					hashAlgorithm.TransformFinalBlock(bytes, 0, bytes.Length);
					hash = hashAlgorithm.Hash;
				}
				structDataItem6.Add(new GuidDataItem("GAME", new Guid(hash)));
			}
			structDataItem.Add(structDataItem6);
			MemoryStream memoryStream = new MemoryStream();
			structDataItem.Write(memoryStream);
			memoryStream.Position = 0L;
			byte[] array2 = new byte[memoryStream.Length];
			memoryStream.Read(array2, 0, (int)memoryStream.Length);
			memoryStream.Dispose();
			return array2;
		}

		public static byte[] CreateSoupMetaData(ProjectBuilder projectBuilder, Asset asset)
		{
			string value = XMLEngine.WriteSoupStateToString(projectBuilder.State, asset);
			StructDataItem structDataItem = DataItem.New("META");
			StringDataItem item = DataItem.New("STAT", value);
			structDataItem.Add(item);
			StringDataItem item2 = DataItem.New("PROJ", XMLEngine.WriteProjectToString(projectBuilder.ActiveProject));
			structDataItem.Add(item2);
			if (projectBuilder.State.IncrementalStates.ContainsKey(asset.Id) && projectBuilder.State.IncrementalStates[asset.Id].IncrementalBuildPossible)
			{
				StructDataItem item3 = DataItem.New("BINF", DataItem.New("MODE", "Incremental"));
				structDataItem.Add(item3);
			}
			MemoryStream memoryStream = new MemoryStream();
			structDataItem.Write(memoryStream);
			memoryStream.Position = 0L;
			byte[] array = new byte[memoryStream.Length];
			memoryStream.Read(array, 0, (int)memoryStream.Length);
			memoryStream.Dispose();
			return array;
		}

		public static Stream GetMetaDataStream(IntPtr ptr, uint length)
		{
			byte[] array = new byte[length];
			Marshal.Copy(ptr, array, 0, (int)length);
			return new MemoryStream(array);
		}

		public static byte[] GetMetaDataBuffer(IntPtr ptr, uint length)
		{
			byte[] array = new byte[length];
			Marshal.Copy(ptr, array, 0, (int)length);
			return array;
		}
	}
	internal class OrdererProcess : IOrdererProcess, IPipelineProcess
	{
		private PipelineProcessResult latestResult;

		public ProjectBuilder ProjectBuilder { get; private set; }

		public PipelineProcessResult LatestResult => latestResult;

		public bool HasRun { get; private set; }

		public DateTime LastRun { get; private set; }

		public OrdererProcess(ProjectBuilder builder)
		{
			ProjectBuilder = builder;
		}

		public PipelineProcessResult PreProcess()
		{
			return PipelineProcessResult.Success;
		}

		public PipelineProcessResult Process()
		{
			ProjectBuilder.ProgressTracker.StartTask(SlowTask.OrderProcess);
			ProjectBuilder.ProgressTracker.EndTask(SlowTask.OrderProcess);
			return PipelineProcessResult.Success;
		}

		public PipelineProcessResult PostProcess(PipelineProcessResult processResult)
		{
			return PipelineProcessResult.Success;
		}
	}
	public class Int2
	{
		public int X { get; set; }

		public int Y { get; set; }

		public Int2()
		{
		}

		public Int2(Int2 int2)
		{
			X = int2.X;
			Y = int2.Y;
		}

		public Int2(int defaultValue)
		{
			X = defaultValue;
			Y = defaultValue;
		}

		public Int2(int x, int y)
		{
			X = x;
			Y = y;
		}

		public override string ToString()
		{
			return string.Format("[{0},{1}]", new object[2]
			{
				X.ToString(),
				Y.ToString()
			});
		}
	}
	public class Uint2
	{
		public uint X { get; set; }

		public uint Y { get; set; }

		public Uint2()
		{
		}

		public Uint2(Uint2 uint2)
		{
			X = uint2.X;
			Y = uint2.Y;
		}

		public Uint2(uint defaultValue)
		{
			X = defaultValue;
			Y = defaultValue;
		}

		public Uint2(uint x, uint y)
		{
			X = x;
			Y = y;
		}

		public override string ToString()
		{
			return string.Format("[{0},{1}]", new object[2]
			{
				X.ToString(),
				Y.ToString()
			});
		}
	}
	public class Double2
	{
		public double X { get; set; }

		public double Y { get; set; }

		public Double2()
		{
		}

		public Double2(Double2 double2)
		{
			X = double2.X;
			Y = double2.Y;
		}

		public Double2(double defaultValue)
		{
			X = defaultValue;
			Y = defaultValue;
		}

		public Double2(double x, double y)
		{
			X = x;
			Y = y;
		}

		public override string ToString()
		{
			return string.Format("[{0},{1}]", new object[2]
			{
				X.ToString(),
				Y.ToString()
			});
		}
	}
	public class ProfileLoader
	{
		public static string LastError = "";

		public static List<BuildProfile> GetAvailableBuildProfiles()
		{
			Paths.GetResourceFiles("BuildProfiles", "xml", out var names, out var _, (string _name) => IsBuildProfileDepricated(_name));
			List<BuildProfile> list = new List<BuildProfile>();
			foreach (string item in names)
			{
				try
				{
					LoadBuildProfile(item, out var profile);
					list.Add(profile);
				}
				catch
				{
				}
			}
			return list;
		}

		public static bool IsBuildProfileDepricated(string buildProfileName)
		{
			return new string[1] { "directx11.2_tiledresources" }.Contains(buildProfileName);
		}

		public static bool IsValidQualityProfile(string qualityProfile, string codingProfile, DataType dataType)
		{
			try
			{
				LoadCodingProfile(codingProfile, out var profile);
				return profile.HasQualityProfileForDataType(qualityProfile, dataType);
			}
			catch
			{
				return false;
			}
		}

		public static bool IsValidQualityProfile(string qualityProfile, CodingProfile codingProfile, DataType dataType)
		{
			try
			{
				return codingProfile.HasQualityProfileForDataType(qualityProfile, dataType);
			}
			catch
			{
				return false;
			}
		}

		public static bool IsValidPagingStrategy(PagingStrategy strategy, string buildprofileName)
		{
			LoadBuildProfile(buildprofileName, out var profile);
			return profile.AvailablePagingStrategies.Contains(strategy);
		}

		public static PagingStrategy ResolvePagingStrategy(PagingStrategy strategy, string buildprofileName)
		{
			if (strategy == PagingStrategy.Default)
			{
				LoadBuildProfile(buildprofileName, out var profile);
				return profile.DefaultPagingStrategyMapsTo;
			}
			return strategy;
		}

		public static string GetDefaultBuildProfile()
		{
			return "default";
		}

		public static Error LoadCodingProfile(string name, out CodingProfile profile)
		{
			profile = null;
			if (name == null)
			{
				return Error.InvalidParameter;
			}
			string resourceString = Paths.GetResourceString("CodingProfiles", name.ToLowerInvariant() + ".xml");
			if (resourceString == null)
			{
				LastError = "Coding profile '" + name + "' was not found";
				return Error.FileNotFound;
			}
			try
			{
				XMLEngine.ReadCodingProfileFromString(resourceString, out profile);
			}
			catch (Exception ex)
			{
				LastError = "Unable to read internal coding profile '" + name + "', detailed parsing error: " + ex.Message;
				return Error.XMLParsing;
			}
			QualityProfile qualityProfile = profile.QualityProfiles.Find((QualityProfile x) => x.Name.Equals("uniform", StringComparison.OrdinalIgnoreCase));
			profile.UniformCodecAvailable = qualityProfile != null;
			return Error.Ok;
		}

		public static Error LoadCodingProfileFromXML(string filename, out CodingProfile profile)
		{
			profile = null;
			try
			{
				XMLEngine.ReadCodingProfile(filename, out profile);
			}
			catch (Exception ex)
			{
				LastError = "Unable to read coding profile from '" + filename + "', detailed parsing error: '" + ex.Message + "'";
				return Error.XMLParsing;
			}
			return Error.Ok;
		}

		public static Error LoadAndActivateBuildProfile(string name)
		{
			Error error = LoadBuildProfile(name, out var profile);
			if (error != 0)
			{
				return error;
			}
			error = ActivateBuildProfile(profile);
			if (error != 0)
			{
				return error;
			}
			return Error.Ok;
		}

		public static Error LoadBuildProfile(string name, out BuildProfile profile)
		{
			profile = null;
			if (name == null)
			{
				return Error.InvalidParameter;
			}
			string resourceString = Paths.GetResourceString("BuildProfiles", name.ToLowerInvariant() + ".xml");
			if (resourceString != null)
			{
				try
				{
					XMLEngine.ReadBuildProfileFromString(resourceString, out profile);
					return Error.Ok;
				}
				catch (Exception ex)
				{
					LastError = "Unable to read internal build profile '" + name + "', detailed parsing error: '" + ex.Message + "'";
				}
			}
			else
			{
				LastError = "Build profile '" + name + "' was not found";
			}
			return Error.InvalidBuildProfile;
		}

		public static Error ActivateBuildProfile(BuildProfile profile)
		{
			if (profile == null)
			{
				return Error.InvalidParameter;
			}
			if (profile.BlockSize.HasValue)
			{
				Defaults.BlockSize = profile.BlockSize.Value;
			}
			if (profile.TargetDisk.HasValue)
			{
				Defaults.TargetDisk = profile.TargetDisk.Value;
			}
			if (profile.TileSize.HasValue)
			{
				Defaults.TileSize = profile.TileSize.Value;
			}
			if (profile.Anisotropy.HasValue)
			{
				Defaults.Aniso = profile.Anisotropy.Value;
			}
			if (profile.TilingMode.HasValue)
			{
				Defaults.TilingMode = profile.TilingMode.Value;
			}
			return Error.Ok;
		}
	}
	public class Project
	{
		public Dictionary<Guid, Asset> Assets { get; set; }

		public LayerConfig LayerConfiguration { get; set; }

		public string Name { get; set; }

		public Guid Id { get; set; }

		public Version Version { get; set; }

		public BuildConfiguration BuildConfiguration { get; set; }

		public string BuildProfile { get; set; }

		internal ImportSummary ImportSummary { get; set; }

		internal List<ImportAssetTemplate> ImportTemplates { get; set; }

		internal List<ImportAsset> ImportAssets { get; set; }

		internal List<Asset> GTexImportAssets { get; set; }

		internal List<Asset> AssetsToRemove { get; set; }

		internal bool ExclusiveImport { get; set; }

		internal ProjectBuilder builder { get; private set; }

		public Project(ProjectBuilder builder)
		{
			Assets = new Dictionary<Guid, Asset>();
			Name = "Unnamed";
			BuildProfile = Constants.DefaultBuildProfile;
			ImportTemplates = new List<ImportAssetTemplate>();
			ImportAssets = new List<ImportAsset>();
			GTexImportAssets = new List<Asset>();
			ExclusiveImport = false;
			AssetsToRemove = new List<Asset>();
			ImportSummary = new ImportSummary();
			this.builder = builder;
		}

		internal void AddImportAsset(ImportAsset asset)
		{
			ImportAsset importAsset = ImportAssets.Find((ImportAsset x) => string.Equals(x.Name, asset.Name, StringComparison.InvariantCultureIgnoreCase));
			if (importAsset != null)
			{
				ImportAssets.Remove(importAsset);
			}
			ImportAssets.Add(asset);
		}

		internal void AddImportAssetsByTemplate(ImportAssetTemplate template)
		{
			ImportTemplates.Add(template);
		}

		internal bool AddImportAssetsFromXMLFile(string filename, ProjectBuilder builder)
		{
			LayerConfig layerConfiguration = LayerConfiguration;
			string fullName = Directory.GetParent(filename).FullName;
			LayerConfig layerConfig;
			List<ImportAsset> assets;
			List<ImportAssetTemplate> assetImportTemplates;
			List<ImportGTex> gtexImports;
			try
			{
				XMLEngine.ReadAssets(filename, out layerConfig, out assets, out assetImportTemplates, out gtexImports);
			}
			catch (Exception ex)
			{
				throw ex;
			}
			if (layerConfig != null)
			{
				if (layerConfig.Layers.Count > Constants.MaxLayers)
				{
					throw new InvalidLayerConfigurationException("The import XML from \"" + filename + "\" contains too many layers (" + layerConfig.Layers.Count + ")! Tile sets support a maximum of " + Constants.MaxLayers + " layers.");
				}
				if (layerConfiguration == null)
				{
					LayerConfiguration = layerConfig;
				}
				else if (Assets.Count == 0)
				{
					LayerConfiguration = layerConfig;
					for (int i = 0; i < layerConfig.Layers.Count; i++)
					{
						if (layerConfig.Layers[i].LayerName != string.Empty)
						{
							if (i < layerConfiguration.Layers.Count)
							{
								LayerConfiguration.Layers[i].LayerName = layerConfiguration.Layers[i].LayerName;
							}
							else
							{
								LayerConfiguration.Layers[i].LayerName = "layer " + (i + 1);
							}
						}
					}
				}
				else if (LayerConfiguration.Layers.Count == layerConfig.Layers.Count)
				{
					for (int j = 0; j < layerConfig.Layers.Count; j++)
					{
						if (LayerConfiguration.Layers[j].DataType != layerConfig.Layers[j].DataType)
						{
							LayerConfiguration.Layers[j].QualityProfile = "";
							LayerConfiguration.Layers[j].CodingProfile = "";
						}
						LayerConfiguration.Layers[j].DataType = layerConfig.Layers[j].DataType;
						if (layerConfig.Layers[j].CodingProfile != null)
						{
							if (LayerConfiguration.Layers[j].CodingProfile.Equals(layerConfig.Layers[j].CodingProfile, StringComparison.OrdinalIgnoreCase))
							{
								LayerConfiguration.Layers[j].QualityProfile = "";
							}
							LayerConfiguration.Layers[j].CodingProfile = layerConfig.Layers[j].CodingProfile;
						}
						if (layerConfig.Layers[j].QualityProfile != null)
						{
							LayerConfiguration.Layers[j].QualityProfile = layerConfig.Layers[j].QualityProfile;
						}
						if (layerConfig.Layers[j].DefaultColor != null)
						{
							LayerConfiguration.Layers[j].DefaultColor = layerConfig.Layers[j].DefaultColor;
						}
						if (layerConfig.Layers[j].LayerName != null && layerConfig.Layers[j].LayerName.Length != 0)
						{
							LayerConfiguration.Layers[j].LayerName = layerConfig.Layers[j].LayerName;
						}
					}
				}
				else
				{
					if (LayerConfiguration.Layers.Count == layerConfig.Layers.Count || !ExclusiveImport)
					{
						throw new InvalidLayerConfigurationException("The layer configuration has already been set and is incompatible with the new layer configuration, please review your import XML '" + filename + "' or start a new project");
					}
					builder.logger.LogWarning("Layerconfig has not the same amount of layers as importscript! Deleting old assets.");
					Assets.Clear();
					LayerConfiguration = layerConfig;
					for (int k = 0; k < layerConfig.Layers.Count; k++)
					{
						if (layerConfig.Layers[k].LayerName != string.Empty)
						{
							LayerConfiguration.Layers[k].LayerName = "layer " + (k + 1);
						}
					}
				}
			}
			if (layerConfig == null && layerConfiguration == null)
			{
				throw new MissingLayerConfigurationException("No layer configuration has been specified, a layer configuration is needed to build the tile set. Please review your import XML '" + filename + "' and add a layer configuration node");
			}
			foreach (ImportAsset item3 in assets)
			{
				string text = null;
				for (int l = 0; l < item3.Layers.Count; l++)
				{
					ImportAssetLayer importAssetLayer = item3.Layers[l];
					if (importAssetLayer.Source == null)
					{
						continue;
					}
					for (int m = 0; m < importAssetLayer.Source.Sources.Count; m++)
					{
						CombinedTextureSource.Item item = importAssetLayer.Source.Sources[m];
						bool flag = string.IsNullOrEmpty(item.Source);
						try
						{
							importAssetLayer.Source.Sources[m].Source = ((!flag) ? Path.Combine(fullName, item.Source) : "");
							if (!flag && text == null)
							{
								text = Path.GetFileNameWithoutExtension(item.Source);
							}
						}
						catch (Exception ex2)
						{
							throw new UnspecifiedException(string.Format("Error importing asset '{0}', layer {1}. Detailed message: {2}", new object[3] { item3.Name, l, ex2.Message }), ex2);
						}
					}
				}
				if (text != null && item3.Name.Contains("*"))
				{
					item3.Name = item3.Name.Replace("*", text);
				}
				ImportAssets.Add(item3);
			}
			foreach (ImportAssetTemplate item4 in assetImportTemplates)
			{
				for (int n = 0; n < item4.LayerTemplates.Count; n++)
				{
					ImportAssetLayerTemplate importAssetLayerTemplate = item4.LayerTemplates[n];
					if (!(importAssetLayerTemplate.Source == null))
					{
						for (int num = 0; num < importAssetLayerTemplate.Source.Sources.Count; num++)
						{
							CombinedTextureSource.Item item2 = importAssetLayerTemplate.Source.Sources[num];
							importAssetLayerTemplate.Source.Sources[num].Source = ((item2 != null && item2.Source != string.Empty) ? Path.Combine(fullName, item2.Source) : "");
						}
					}
				}
				ImportTemplates.Add(item4);
			}
			foreach (ImportGTex item5 in gtexImports)
			{
				BuildState.SoupState soupState;
				try
				{
					SoupTools.ReadSoupBuildState(item5.Src, out soupState);
				}
				catch
				{
					throw new IncompatibleGTexException("GTex '" + item5.Src + "' could not be read. Could be a corrupt file or an incompatible GTex file.");
				}
				if (!BuildConfiguration.IsCompatibleWithTileLayout(soupState.TileLayout))
				{
					throw new IncompatibleGTexException("GTex '" + item5.Src + "' is incompatible with this project because it was built with a different tile layout configuration.");
				}
				if (!soupState.ProjectId.Equals(Id) && !builder.AllowForeignGTex)
				{
					throw new IncompatibleGTexException("GTex '" + item5.Src + "' was built for a different project. Please use flag -allowforeigngtex to allow importing of and building with gtex files that were built for other projects.");
				}
				if (!soupState.LayerConfig.CompatibleForBuildingTileset(this, LayerConfiguration))
				{
					throw new IncompatibleGTexException("GTex '" + item5.Src + "' is incompatible with this project because of incompatible LayerConfig.");
				}
				foreach (Asset value in soupState.Assets.Values)
				{
					GTexImportAssets.Add(value);
				}
			}
			return true;
		}

		internal bool RemoveImportedAssets(string names)
		{
			string[] array = names.Split(new char[1] { ',' }, StringSplitOptions.RemoveEmptyEntries);
			foreach (string name in array)
			{
				if (name.ToLowerInvariant() == "all")
				{
					AssetsToRemove.AddRange(Assets.Values);
					return true;
				}
				Asset asset = Assets.Values.ToList().Find((Asset x) => x.Name.ToLowerInvariant() == name.ToLowerInvariant());
				if (asset == null)
				{
					return false;
				}
				AssetsToRemove.Add(asset);
			}
			return true;
		}

		internal void RemoveImportedAssets(List<Asset> assets)
		{
			AssetsToRemove.AddRange(assets);
		}
	}
	internal class TextureDistinctSubIdxComparer : IEqualityComparer<Texture>
	{
		public bool Equals(Texture x, Texture y)
		{
			if (x == y)
			{
				return true;
			}
			if (x == null || y == null)
			{
				return false;
			}
			return x.SubIndex == y.SubIndex;
		}

		public int GetHashCode(Texture product)
		{
			return product?.SubIndex.GetHashCode() ?? 0;
		}
	}
	public struct CleanOperationParameters
	{
		public bool intermediates;

		public bool tileSet;

		public bool soups;

		public static readonly CleanOperationParameters Intermediates = new CleanOperationParameters(intermediates: true, tileSet: false, soups: false);

		public static readonly CleanOperationParameters All = new CleanOperationParameters(intermediates: true, tileSet: true, soups: true);

		public static readonly CleanOperationParameters AllButSoups = new CleanOperationParameters(intermediates: true, tileSet: true, soups: false);

		public static readonly CleanOperationParameters AllButTileSet = new CleanOperationParameters(intermediates: true, tileSet: false, soups: true);

		public CleanOperationParameters(bool intermediates, bool tileSet, bool soups)
		{
			this.intermediates = intermediates;
			this.tileSet = tileSet;
			this.soups = soups;
		}
	}
	public struct ProjectBuildOptions
	{
		public BuildMode buildMode;

		public bool allowForeignGTex;

		public bool forceUseGTex;

		public bool buildnotileset;

		public ProjectBuildOptions(BuildMode buildMode, bool allowForeignGTex, bool forceUseGTex, bool buildnotileset)
		{
			this.buildMode = buildMode;
			this.allowForeignGTex = allowForeignGTex;
			this.forceUseGTex = forceUseGTex;
			this.buildnotileset = buildnotileset;
		}
	}
	public class ProjectBuilder
	{
		public delegate void OnCanceledDelegate(bool value);

		private delegate PipelineProcessResult PreProcessDelegate();

		private delegate PipelineProcessResult ProcessDelegate();

		private delegate PipelineProcessResult PostProcessDelegate(PipelineProcessResult processResult);

		public class UpgradeInfo
		{
			public bool WillUpgradeCodingProfiles2dot7 { get; set; }
		}

		public delegate void ProjectUpgradingEventHandler(object sender, UpgradeInfo info);

		private struct ProcessTask
		{
			public ProcessDelegate procedure;

			public Process owningProcess;

			public ProcessTask(ProcessDelegate procedure, Process owningProcess)
			{
				this.procedure = procedure;
				this.owningProcess = owningProcess;
			}
		}

		private struct PreProcessTask
		{
			public PreProcessDelegate procedure;

			public Process owningProcess;

			public PreProcessTask(PreProcessDelegate procedure, Process owningProcess)
			{
				this.procedure = procedure;
				this.owningProcess = owningProcess;
			}
		}

		private struct PostProcessTask
		{
			public PostProcessDelegate procedure;

			public Process owningProcess;

			public PostProcessTask(PostProcessDelegate procedure, Process owningProcess)
			{
				this.procedure = procedure;
				this.owningProcess = owningProcess;
			}
		}

		public Logger logger;

		private StreamLogListener streamLogger;

		private AssetImporterProcess AssetImporter { get; set; }

		private AtlasProcess Atlasser { get; set; }

		private TileFilePreprocessorProcess TileFilePreprocessor { get; set; }

		private CompositeAndCodeProcess CompositorAndCoder { get; set; }

		private OrdererProcess Orderer { get; set; }

		private TileSetBuilderProcess TileFileBuilder { get; set; }

		public bool RescanPatternFilesOnImport { get; set; }

		public bool ExportImportScriptOnSave { get; set; }

		public bool NoFileLogging { get; set; }

		public bool NoPatching { get; set; }

		public bool EnableUniformCoding { get; set; }

		public bool EnableStrictMode { get; set; }

		public bool EnableAssetPlacementLevelOffset { get; set; }

		public bool EnableAutoDepthConversion => !EnableStrictMode;

		public bool ProfilingEnabled { get; private set; }

		public Project ActiveProject { get; set; }

		public bool ReadOnly { get; set; }

		public bool EnableHighQualityCoding { get; set; }

		public bool WriteDebugMetaData { get; set; }

		public bool ForceUseGTex { get; set; }

		public bool AllowForeignGTex { get; set; }

		public bool NoGTSBuilding { get; set; }

		public bool EnableSharedMipGeneration { get; set; }

		public bool EnableRedirection { get; set; }

		public bool EnableMipStripping { get; set; }

		public string OverrideGuid { get; set; }

		public BuildMode ActiveBuildingMode { get; private set; }

		public bool Canceled { get; private set; }

		internal string StagingDirectory { get; set; }

		internal string StagingConfigurationDirectory { get; set; }

		internal BuildState State { get; set; }

		internal TargetConfiguration TargetConfiguration { get; private set; }

		internal BuildStateManager BuildStateManager { get; private set; }

		private FileLock FileLock { get; set; }

		private string ProjectFileName { get; set; }

		private string ProjectPath { get; set; }

		private bool NewAssetsImported { get; set; }

		private bool BuildProfileChanged { get; set; }

		public PipelineProcessResult ProcessResult { get; private set; }

		public ProgressTracker<SlowTask> ProgressTracker { get; private set; }

		public ProjectBuilderReportingHandler BuildReportingHandler { get; set; }

		public BuildStateSummary BuildStateSummary => BuildStateManager.BuildSummary;

		public event OnCanceledDelegate OnCanceled;

		public event ProjectUpgradingEventHandler ProjectUpgrading;

		public void Cancel(bool value)
		{
			if (this.OnCanceled != null)
			{
				this.OnCanceled(value);
			}
			Canceled = value;
		}

		protected virtual void OnProjectUpgrading(UpgradeInfo info)
		{
			this.ProjectUpgrading?.Invoke(this, info);
		}

		public ProjectBuilder()
		{
			Initialize();
		}

		private void Initialize()
		{
			logger = new Logger(Defaults.Verbosity);
			streamLogger = new StreamLogListener();
			logger.RegisterLogListener(streamLogger);
			AssetImporter = new AssetImporterProcess(this);
			Atlasser = new AtlasProcess(this);
			TileFilePreprocessor = new TileFilePreprocessorProcess(this);
			CompositorAndCoder = new CompositeAndCodeProcess(this);
			Orderer = new OrdererProcess(this);
			TileFileBuilder = new TileSetBuilderProcess(this);
			BuildStateManager = new BuildStateManager(this);
			ProcessResult = PipelineProcessResult.Success;
			RescanPatternFilesOnImport = true;
			ExportImportScriptOnSave = false;
			NoFileLogging = false;
			NoPatching = false;
			WriteDebugMetaData = true;
			EnableUniformCoding = true;
			EnableStrictMode = false;
			EnableAssetPlacementLevelOffset = true;
			EnableHighQualityCoding = true;
			EnableSharedMipGeneration = true;
			EnableRedirection = true;
			EnableMipStripping = true;
			NewAssetsImported = false;
			ProgressTracker = new ProgressTracker<SlowTask>();
			BuildReportingHandler = new ProjectBuilderReportingHandler(this);
			Cancel(value: false);
			if (!GrBuildLibInterface.IsInitialized)
			{
				GrBuildLibInterface.InitializeGrBuild();
			}
		}

		public void HookBuildErrorsOnGlobalLogger()
		{
			BuildReportingHandler.OnErrorHandler += BuildReportingHandler_OnErrorHandler;
			BuildReportingHandler.OnFatalErrorHandler += BuildReportingHandler_OnFatalErrorHandler;
			BuildReportingHandler.OnWarningHandler += BuildReportingHandler_OnWarningHandler;
			BuildReportingHandler.OnInfoHandler += BuildReportingHandler_OnInfoHandler;
		}

		private void BuildReportingHandler_OnInfoHandler(ProjectBuilder source, BuildProcess processId, BuildIssue buildIssue)
		{
			logger.LogInfo(buildIssue.ToString());
		}

		private void BuildReportingHandler_OnWarningHandler(ProjectBuilder source, BuildProcess processId, BuildIssue buildIssue)
		{
			logger.LogWarning(buildIssue.ToString());
		}

		private void BuildReportingHandler_OnFatalErrorHandler(ProjectBuilder source, BuildProcess processId, BuildIssue buildIssue)
		{
			logger.LogError(buildIssue.ToString());
		}

		private ErrorAction BuildReportingHandler_OnErrorHandler(ProjectBuilder source, BuildProcess processId, BuildIssue buildIssue)
		{
			logger.LogError(buildIssue.ToString());
			return ErrorAction.ForceContinue;
		}

		public Error LoadProject(string filename)
		{
			return LoadProject(filename, ProjectLoadMode.Default);
		}

		public Error LoadProject(string filename, ProjectLoadMode mode)
		{
			if (ActiveProject != null)
			{
				CloseProject();
			}
			if (!Paths.IsValidFilename(filename))
			{
				throw new UnspecifiedException("The file name '" + filename + "' is invalid, please use a valid file name", Error.InvalidParameter);
			}
			if (!File.Exists(filename))
			{
				return NewProject(filename);
			}
			bool flag = FileTools.FileCanReadWrite(filename);
			if (mode == ProjectLoadMode.ReadAndWrite && !flag)
			{
				throw new UnspecifiedException("The project '" + filename + "' could not be opened for writing.", Error.IOError);
			}
			if (mode == ProjectLoadMode.ReadOnly || !flag)
			{
				ReadOnly = true;
			}
			try
			{
				new XMLValidator().ValidateXMLFile(filename);
			}
			catch (Exception ex)
			{
				throw new UnspecifiedException(string.Format("Project file '{0}' is not a valid XML file. Detailed error message: '{1}', please correct the file or start a new project.", new object[2] { filename, ex.Message }), Error.XMLValidation, ex);
			}
			if (!TestProjectCompatibility(filename, out var found, out var required))
			{
				throw new GrInvalidProjectCompatibilityVersionException(found, required);
			}
			if (Version.Compare(found, required) != 0)
			{
				try
				{
					string destFileName = string.Format("{0}.v{1}_{2}_preupgrade.bak", new object[3] { filename, found.Major, found.Minor });
					File.Copy(filename, destFileName);
				}
				catch
				{
				}
			}
			XMLValidator.XMLValidationResult xMLValidationResult = ValidateProjectFile(filename);
			if (!xMLValidationResult.Valid)
			{
				throw new UnspecifiedException("Error validating project file '" + filename + "'. Detailed error message: '" + xMLValidationResult.ToString() + "', please start a new project", Error.XMLValidation);
			}
			Project project;
			try
			{
				XMLEngine.ReadProject(filename, out project, this);
			}
			catch (Exception ex2)
			{
				throw new UnspecifiedException("Unable to read project file '" + filename + "'. Detailed error message: '" + ex2.Message + "', please make sure the project files are accessible", Error.XMLParsing, ex2);
			}
			if (OverrideGuid != null)
			{
				if (!Guid.TryParse(OverrideGuid, out var result))
				{
					throw new UnspecifiedException("Unable to override project Guid. Guid could not be parsed as a Guid.", Error.InvalidParameter);
				}
				project.Id = result;
			}
			if (project.LayerConfiguration != null && project.LayerConfiguration.Layers.Count > Constants.MaxLayers)
			{
				throw new UnspecifiedException("Project file '" + filename + "' contains too many layers (" + project.LayerConfiguration.Layers.Count + ")! Please create a new project with at most " + Constants.MaxLayers + " layers.", Error.InvalidProjectState);
			}
			ActiveProject = project;
			Error error = ProfileLoader.LoadAndActivateBuildProfile(ActiveProject.BuildProfile);
			if (error != 0)
			{
				throw new UnspecifiedException("Unable to load build profile '" + ActiveProject.BuildProfile + "'. Detailed error message: '" + ProfileLoader.LastError + "', please change your build profile", error);
			}
			GrBuildExceptionHandler.WarningLevel = project.BuildConfiguration.WarningLevel;
			ProjectFileName = Path.GetFileName(filename);
			ProjectPath = Directory.GetParent(Path.GetFullPath(filename)).FullName;
			if (!SetWorkingDirectory())
			{
				throw new UnspecifiedException("Unable to set working directory", Error.IOError);
			}
			StagingDirectory = Constants.StateDirName;
			try
			{
				CreateDirectoryIfNotExists(StagingDirectory);
			}
			catch (Exception ex3)
			{
				throw new UnspecifiedException("Unable to create temporary state directory '" + StagingDirectory + "', detailed error message: '" + ex3.Message + "', please make sure the directory is accessible", Error.IOError);
			}
			if (!NoFileLogging)
			{
				try
				{
					streamLogger.Close();
					streamLogger.Open(ActiveProject.BuildConfiguration.LogFile);
					streamLogger.LogMessage("Logging information on building, the complete application log can be found in the application folder.", Logger.Verbosity.Normal);
				}
				catch (Exception ex4)
				{
					throw new UnspecifiedException("Unable to create log file, make sure no other processes are using the file '" + ActiveProject.BuildConfiguration.LogFile + "', detailed error: '" + ex4.Message + "'", Error.IOError, ex4);
				}
			}
			error = LoadConfiguration(Defaults.TargetConfiguration);
			if (error != 0)
			{
				throw new UnspecifiedException(string.Concat("Unable to open configuration '", Defaults.TargetConfiguration, "'"), error);
			}
			if (!TestProjectIntermediatesCompatibility())
			{
				string arg = ((State != null) ? State.ProjectVersion.ToString() : "unknown");
				string arg2 = Constants.Version.ProjectCompatibilityVersion.ToString();
				string message = $"Project intermediary files are built with version '{arg}', binaries are version '{arg2}'. Intermediary files will be cleaned before build.";
				logger.LogMessage(message, Logger.Verbosity.Normal);
				if (!State.ProjectVersion.IsNewer(new Version(2, 7)))
				{
					CleanCompatibilityV31();
				}
				else
				{
					Clean(CleanOperationParameters.Intermediates);
				}
			}
			try
			{
				UpgradeProject();
			}
			catch (Exception ex5)
			{
				throw new UnspecifiedException("Unable to upgrade project file to newer version. Please retry opening the project, or start a new project and reimport all assets. Message:'" + ex5.Message + "'", error);
			}
			return Error.Ok;
		}

		public bool CheckCodingParameters()
		{
			if (ActiveProject.LayerConfiguration == null || ActiveProject.LayerConfiguration.Layers.Count == 0)
			{
				return false;
			}
			int count = ActiveProject.LayerConfiguration.Layers.Count;
			CodingProfile[] array = new CodingProfile[count];
			List<DataType>[] array2 = new List<DataType>[count];
			Dictionary<DataType, string>[] array3 = new Dictionary<DataType, string>[count];
			Dictionary<DataType, List<string>>[] array4 = new Dictionary<DataType, List<string>>[count];
			ProfileLoader.LoadBuildProfile(ActiveProject.BuildProfile, out var profile);
			for (int i = 0; i < count; i++)
			{
				LayerDescription layerDescription = ActiveProject.LayerConfiguration.Layers[i];
				string text = ActiveProject.LayerConfiguration.Layers[i].CodingProfile;
				if (string.IsNullOrEmpty(text))
				{
					text = (layerDescription.CodingProfile = profile.DefaultCodingProfiles[layerDescription.DataType]);
				}
				EnsureValidLayerCodingProfile(profile, layerDescription, i);
				if (ProfileLoader.LoadCodingProfile(text, out var profile2) != 0)
				{
					string innerMessage = "Unable to load coding profile, detailed error: '" + ProfileLoader.LastError + "', please choose one of the included coding profiles";
					BuildReportingHandler.OnFatalError(BuildProcess.Coder, new CoderCodingProfileIssue(text, innerMessage));
					return false;
				}
				array[i] = profile2;
				array2[i] = new List<DataType>();
				array4[i] = new Dictionary<DataType, List<string>>();
				foreach (QualityProfile qualityProfile in profile2.QualityProfiles)
				{
					foreach (CodingConfig codingConfig in qualityProfile.CodingConfigs)
					{
						foreach (DataType dataType in codingConfig.DataTypes)
						{
							if (!array2[i].Contains(dataType))
							{
								array2[i].Add(dataType);
							}
							if (!array4[i].ContainsKey(dataType))
							{
								array4[i][dataType] = new List<string>();
							}
							array4[i][dataType].Add(qualityProfile.Name.ToLowerInvariant());
						}
					}
				}
				array3[i] = new Dictionary<DataType, string>();
				foreach (DefaultQualitySetting defaultQualitySetting in profile2.DefaultQualitySettings)
				{
					foreach (DataType dataType2 in defaultQualitySetting.DataTypes)
					{
						array3[i][dataType2] = defaultQualitySetting.QualityProfile.ToLowerInvariant();
						if (!array4[i][dataType2].Contains(defaultQualitySetting.QualityProfile.ToLowerInvariant()))
						{
							string innerMessage2 = string.Concat("Invalid default QualityProfile for '", dataType2, "', no quality profile specified for that type, please set the default value to a defined quality profile for '", dataType2, "'");
							BuildReportingHandler.OnFatalError(BuildProcess.Coder, new CoderCodingProfileIssue(text, innerMessage2));
							return false;
						}
					}
				}
				if (!array2[i].Contains(layerDescription.DataType))
				{
					string innerMessage3 = "Data type '" + layerDescription.DataType.ToString() + "' is not supported for the '" + profile2.Name + "' configuration, please change the data type of layer " + i + " or select a compatible coding profile";
					BuildReportingHandler.OnFatalError(BuildProcess.Coder, new CoderIssue(innerMessage3));
					return false;
				}
				if (string.IsNullOrEmpty(layerDescription.QualityProfile) || layerDescription.QualityProfile.ToLowerInvariant() == "default")
				{
					if (array3[i].ContainsKey(layerDescription.DataType))
					{
						layerDescription.QualityProfile = array3[i][layerDescription.DataType];
						continue;
					}
					string innerMessage4 = "No default quality profile available for '" + layerDescription.DataType.ToString() + "', please change the quality profile for layer " + i + " or select a compatible coding profile";
					BuildReportingHandler.OnFatalError(BuildProcess.Coder, new CoderIssue(innerMessage4));
					return false;
				}
				try
				{
					if (!array4[i][layerDescription.DataType].Contains(layerDescription.QualityProfile.ToLowerInvariant()))
					{
						throw new CoderException("The quality profile for layer " + i + ": '" + layerDescription.QualityProfile.ToString() + "' is not available for data type '" + layerDescription.DataType.ToString() + "' in the coding profile '" + profile2.Name + "', please change the quality profile or select a compatible coding profile.");
					}
				}
				catch (CoderException ex)
				{
					if (GrBuildExceptionHandler.IsFatal(ex))
					{
						BuildReportingHandler.OnFatalError(BuildProcess.Coder, new CoderIssue(ex.Message));
						return false;
					}
					if (array3[i].ContainsKey(layerDescription.DataType))
					{
						string innerMessage5 = ex.Message + " The quality profile will be set to '" + array3[i][layerDescription.DataType].ToString() + ".";
						if (BuildReportingHandler.OnError(BuildProcess.Coder, new CoderIssue(innerMessage5)) == ErrorAction.Stop)
						{
							return false;
						}
						layerDescription.QualityProfile = array3[i][layerDescription.DataType];
						continue;
					}
					string innerMessage6 = ex.Message + " Unable to assign a valid quality profile because no default quality level is available for '" + layerDescription.DataType.ToString() + "'";
					BuildReportingHandler.OnFatalError(BuildProcess.Coder, new CoderIssue(innerMessage6));
					return false;
				}
			}
			return true;
		}

		public bool CanBuildProject()
		{
			if (!CheckCodingParameters())
			{
				return false;
			}
			QueryAssetBuildStates();
			bool result = true;
			foreach (KeyValuePair<Guid, Asset> asset in ActiveProject.Assets)
			{
				Asset value = asset.Value;
				if (BuildStateSummary == null)
				{
					continue;
				}
				if (BuildStateSummary.AssetStates[value.Id].SoupFailureState == SoupFailureState.Inaccessible)
				{
					string innerMessage = "Asset '" + value.Name + "' cannot be build because the gtex is not accessible.";
					BuildReportingHandler.OnFatalError(BuildProcess.General, new GeneralIssue(innerMessage));
					result = false;
					continue;
				}
				bool flag = false;
				if (value.UDimSettings != null)
				{
					UDimSettings[] uDimSettings = value.UDimSettings;
					foreach (UDimSettings uDimSettings2 in uDimSettings)
					{
						if (uDimSettings2 == null || (uDimSettings2.UTiles <= 1 && uDimSettings2.VTiles <= 1))
						{
							continue;
						}
						bool flag2 = false;
						foreach (KeyValuePair<int, LayerAssetState> layerState in BuildStateSummary.AssetStates[value.Id].LayerStates)
						{
							foreach (TextureAssetState textureState in layerState.Value.TextureStates)
							{
								if (textureState.Changes != TextureChanges.Missing)
								{
									flag2 = true;
								}
							}
						}
						if (flag2)
						{
							flag = true;
						}
					}
				}
				FailureState failureState = BuildStateSummary.AssetStates[value.Id].FailureState;
				if (failureState == FailureState.None || flag)
				{
					continue;
				}
				bool exclusiveImport = ActiveProject.ExclusiveImport;
				bool flag3 = AssetImportTools.AssetWasImported(ActiveProject, value);
				if (exclusiveImport && !flag3)
				{
					continue;
				}
				if (!State.IsSoupFileValid(value))
				{
					string text = "";
					text = failureState switch
					{
						FailureState.TextureNotFound => "source data is missing", 
						FailureState.TextureInaccessible => "source data is inaccessible", 
						FailureState.InvalidTextureFormat => "source data has an invalid texture format", 
						FailureState.InvalidUDimPattern => "the asset has an invalid UDIM pattern", 
						FailureState.InvalidPatternDimensions => "the asset has invalid pattern dimensions", 
						FailureState.InvalidAssetBorder => "the border is too large for the asset's dimensions", 
						_ => "of unknown reasons", 
					};
					string innerMessage2 = "Asset '" + value.Name + "' cannot be build because " + text + " and no valid gtex was found.";
					BuildReportingHandler.OnFatalError(BuildProcess.General, new GeneralIssue(innerMessage2));
					result = false;
					continue;
				}
				foreach (KeyValuePair<int, LayerAssetState> layerState2 in BuildStateSummary.AssetStates[value.Id].LayerStates)
				{
					if (layerState2.Value.FailureState == FailureState.TextureInaccessible)
					{
						if (value.AssetLayers[layerState2.Key].Textures.Count == 1)
						{
							string innerMessage3 = "Asset '" + value.Name + "' can contain old data because texture " + value.AssetLayers[layerState2.Key].Textures[0].Source + " on layer " + layerState2.Key + " is inaccessible.";
							BuildReportingHandler.OnWarning(BuildProcess.General, new GeneralIssue(innerMessage3));
						}
						else
						{
							string innerMessage4 = "Asset '" + value.Name + "' can contain old data because texture data on layer " + layerState2.Key + " is inaccessible.";
							BuildReportingHandler.OnWarning(BuildProcess.General, new GeneralIssue(innerMessage4));
						}
					}
				}
			}
			return result;
		}

		public bool IsAssetNameAvavailable(string name, out Asset conflict)
		{
			conflict = null;
			foreach (Asset value in ActiveProject.Assets.Values)
			{
				if (value.AssetGroupId != null && Various.NameEquals(value.AssetGroupId, name))
				{
					conflict = value;
					return false;
				}
				if (Various.NameEquals(value.Name, name))
				{
					conflict = value;
					return false;
				}
			}
			return true;
		}

		public Error NewProject(string filename)
		{
			if (ActiveProject != null)
			{
				CloseProject();
			}
			if (!Paths.IsValidFilename(filename))
			{
				throw new UnspecifiedException("The file name '" + filename + "' is invalid, please use a valid file name", Error.InvalidParameter);
			}
			ActiveProject = new Project(this);
			Error error = ProfileLoader.LoadAndActivateBuildProfile(ActiveProject.BuildProfile);
			if (error != 0)
			{
				throw new UnspecifiedException("Unable to load build profile '" + ActiveProject.BuildProfile + "'. Detailed error message: '" + ProfileLoader.LastError + "', please change your build profile", error);
			}
			if (OverrideGuid != null)
			{
				if (!Guid.TryParse(OverrideGuid, out var result))
				{
					throw new UnspecifiedException("Unable to override project Guid. Guid could not be parsed as a Guid.", error);
				}
				ActiveProject.Id = result;
			}
			else
			{
				ActiveProject.Id = Guid.NewGuid();
			}
			ActiveProject.Name = Path.GetFileNameWithoutExtension(filename);
			ActiveProject.BuildConfiguration = new BuildConfiguration(filename);
			GrBuildExceptionHandler.WarningLevel = ActiveProject.BuildConfiguration.WarningLevel;
			ProjectFileName = Path.GetFileName(filename);
			ProjectPath = Directory.GetParent(Path.GetFullPath(filename)).FullName;
			try
			{
				CreateDirectoryIfNotExists(ProjectPath);
				Directory.SetCurrentDirectory(ProjectPath);
			}
			catch (Exception ex)
			{
				throw new UnspecifiedException("Unable to initialize the project working directory, detailed error: '" + ex.Message + "'", Error.IOError, ex);
			}
			StagingDirectory = Constants.StateDirName;
			try
			{
				CreateDirectoryIfNotExists(StagingDirectory);
			}
			catch (Exception ex2)
			{
				throw new UnspecifiedException("Unable to create temporary state directory '" + StagingDirectory + "', detailed error message: '" + ex2.Message + "', please make sure the directory is accessible", Error.IOError, ex2);
			}
			if (!NoFileLogging)
			{
				try
				{
					streamLogger.Close();
					streamLogger.Open(ActiveProject.BuildConfiguration.LogFile);
				}
				catch (Exception ex3)
				{
					throw new UnspecifiedException("Unable to create log file, make sure no other processes are using the file '" + ActiveProject.BuildConfiguration.LogFile + "', detailed error: '" + ex3.Message + "'", Error.IOError, ex3);
				}
			}
			error = LoadConfiguration(Defaults.TargetConfiguration);
			if (error != 0)
			{
				throw new UnspecifiedException(string.Concat("Unable to load target configuration '", Defaults.TargetConfiguration, "'."), error);
			}
			ReadOnly = false;
			return Error.Ok;
		}

		public Error LoadConfiguration(TargetConfiguration configuration)
		{
			if (configuration == TargetConfiguration.Default)
			{
				configuration = Defaults.TargetConfiguration;
			}
			TargetConfiguration = configuration;
			StagingConfigurationDirectory = Path.Combine(StagingDirectory, configuration.ToString());
			if (!SetWorkingDirectory())
			{
				return Error.IOError;
			}
			Error error = CreateStagingConfigurationDirectory();
			if (error != 0)
			{
				return error;
			}
			if (!LockProject())
			{
				return Error.ProjectLocked;
			}
			if (!OpenState())
			{
				UnLockProject();
				return Error.InvalidProjectState;
			}
			UnLockProject();
			return Error.Ok;
		}

		public bool RequiresCodingProfileUpgrade()
		{
			if (ActiveProject.LayerConfiguration == null)
			{
				return false;
			}
			for (int i = 0; i < ActiveProject.LayerConfiguration.Layers.Count; i++)
			{
				if (string.IsNullOrEmpty(ActiveProject.LayerConfiguration.Layers[i].CodingProfile))
				{
					return true;
				}
			}
			return false;
		}

		private void UpgradeProject()
		{
			UpgradeInfo upgradeInfo = new UpgradeInfo();
			upgradeInfo.WillUpgradeCodingProfiles2dot7 = RequiresCodingProfileUpgrade();
			OnProjectUpgrading(upgradeInfo);
			if (string.IsNullOrEmpty(ActiveProject.BuildConfiguration.SoupOutputDirectory))
			{
				ActiveProject.BuildConfiguration.SoupOutputDirectory = ".";
			}
			if (ProfileLoader.IsBuildProfileDepricated(ActiveProject.BuildProfile))
			{
				logger.LogWarning(ActiveProject.Name + " references a deprecated build profile '" + ActiveProject.BuildProfile + "'. The build profile is restored to default.");
				ActiveProject.BuildProfile = ProfileLoader.GetDefaultBuildProfile();
			}
			bool flag = false;
			if (ActiveProject.LayerConfiguration != null)
			{
				for (int i = 0; i < ActiveProject.LayerConfiguration.Layers.Count; i++)
				{
					if (string.IsNullOrEmpty(ActiveProject.LayerConfiguration.Layers[i].CodingProfile))
					{
						UpgradeCodingProfiles.UpgradeLayerCodingProfile(ActiveProject, i);
						flag = true;
					}
				}
			}
			if (flag && ActiveProject.LayerConfiguration != null)
			{
				for (int j = 0; j < ActiveProject.LayerConfiguration.Layers.Count; j++)
				{
					DataType dataType = ActiveProject.LayerConfiguration.Layers[j].DataType;
					foreach (Asset value in ActiveProject.Assets.Values)
					{
						if (!ProfileLoader.IsValidQualityProfile(value.AssetLayers[j].QualityProfile, ActiveProject.LayerConfiguration.Layers[j].CodingProfile, dataType))
						{
							value.AssetLayers[j].QualityProfile = "default";
						}
					}
				}
			}
			foreach (Asset value2 in ActiveProject.Assets.Values)
			{
				for (int k = 0; k < value2.AssetLayers.Count; k++)
				{
					AssetLayer assetLayer = value2.AssetLayers[k];
					if (assetLayer.TextureType[0] == TextureType.Unknown && !ChannelMerging.IsCombinedMode(assetLayer.PackingMode))
					{
						if (assetLayer.Textures == null)
						{
							assetLayer.TextureType[0] = TextureType.Unknown;
						}
						else if (assetLayer.Textures.Count == 0)
						{
							assetLayer.TextureType[0] = TextureType.Empty;
						}
						else
						{
							try
							{
								ImportTemplateInfo importTemplateInfo = ImportTemplateConstructor.TemplateFromFilename(assetLayer.Textures[0].Source);
								assetLayer.TextureType[0] = importTemplateInfo.Type;
							}
							catch
							{
								if (assetLayer.Textures.Count > 1)
								{
									if (value2.UDimSettings[0] != null)
									{
										assetLayer.TextureType[0] = TextureType.UDim;
									}
									else
									{
										assetLayer.TextureType[0] = TextureType.Tiled;
									}
								}
								else if (assetLayer.Textures.Count == 1)
								{
									assetLayer.TextureType[0] = TextureType.Single;
								}
								else
								{
									assetLayer.TextureType[0] = TextureType.Empty;
								}
							}
						}
					}
					bool isCube = value2.Type == AssetType.CubeMap;
					int count = assetLayer.Textures.Count;
					for (int l = 0; l < count; l++)
					{
						Texture texture = assetLayer.Textures[l];
						if (texture.NumChannels == 0)
						{
							try
							{
								DataType dataType2 = ActiveProject.LayerConfiguration.Layers[k].DataType;
								AssetImportTools.LoadTexture(texture.Source, texture.Row, texture.Column, texture.Face, isCube, dataType2, this, assetLayer.MipSourceType, ref texture);
							}
							catch
							{
							}
						}
					}
				}
			}
		}

		public void CloseProject()
		{
			State = null;
			ActiveProject = null;
			ReadOnly = false;
			streamLogger.Close();
		}

		public bool SaveProject()
		{
			if (ActiveProject == null)
			{
				return false;
			}
			if (ReadOnly)
			{
				return true;
			}
			if (!SetWorkingDirectory())
			{
				throw new UnspecifiedException("Unable to set working directory while saving.", Error.Unknown);
			}
			try
			{
				XMLEngine.WriteProject(ProjectFileName, ActiveProject);
			}
			catch (UnauthorizedAccessException ex)
			{
				throw new ProjectSaveException("Unable to save the project file '" + ProjectFileName + "', detailed error: '" + ex.Message + "'");
			}
			catch (Exception ex2)
			{
				throw new UnspecifiedException("Unable to save the project file '" + ProjectFileName + "', detailed error: '" + ex2.Message + "'", Error.Unknown, ex2);
			}
			return true;
		}

		public Error SetLayerConfig(LayerConfig config)
		{
			if (ActiveProject == null)
			{
				return Error.NoProjectLoaded;
			}
			if (ActiveProject.LayerConfiguration == null)
			{
				ActiveProject.LayerConfiguration = config;
				return Error.Ok;
			}
			if (ActiveProject.ExclusiveImport)
			{
				ActiveProject.LayerConfiguration = config;
				return Error.Ok;
			}
			if (ActiveProject.Assets.Count == 0)
			{
				ActiveProject.LayerConfiguration = config;
				return Error.Ok;
			}
			return Error.AlreadySet;
		}

		public Error UpdateLayerConfig(LayerConfig config)
		{
			if (ActiveProject == null)
			{
				return Error.NoProjectLoaded;
			}
			ActiveProject.LayerConfiguration = config;
			return Error.Ok;
		}

		public bool SetWarningLevel(uint level)
		{
			if (ActiveProject == null)
			{
				return false;
			}
			if (level > 3 || level < 1)
			{
				throw new UnspecifiedException("Unknown warning level: '" + level + "', please set the warning level to a valid value (" + 1 + "-" + 3 + ")", Error.InvalidParameter);
			}
			ActiveProject.BuildConfiguration.WarningLevel = level;
			GrBuildExceptionHandler.WarningLevel = level;
			return true;
		}

		public void SetVerbosity(Logger.Verbosity verbosity)
		{
			logger.SetVerbosity(verbosity);
		}

		public static XMLValidator.XMLValidationResult ValidateProjectFile(string xmlFilename)
		{
			XMLValidator xMLValidator = new XMLValidator();
			try
			{
				xMLValidator.ValidateXMLFile(xmlFilename, Resources.ProjectValidation);
				return xMLValidator.ValidationResult;
			}
			catch (FileNotFoundException)
			{
				return new XMLValidator.XMLValidationResult
				{
					Errors = { "File not found: " + xmlFilename }
				};
			}
		}

		public static XMLValidator.XMLValidationResult ValidateImportXmlFile(string xmlFilename)
		{
			XMLValidator xMLValidator = new XMLValidator();
			try
			{
				xMLValidator.ValidateXMLFile(xmlFilename, Resources.ImportValidation);
				return xMLValidator.ValidationResult;
			}
			catch (FileNotFoundException)
			{
				return new XMLValidator.XMLValidationResult
				{
					Errors = { "File not found: " + xmlFilename }
				};
			}
		}

		public bool AddLayersAndAssetsFromXMLFile(string filename)
		{
			if (ActiveProject == null)
			{
				return false;
			}
			NewAssetsImported = true;
			bool flag = false;
			try
			{
				return ActiveProject.AddImportAssetsFromXMLFile(filename, this);
			}
			catch (Exception ex)
			{
				throw ex;
			}
		}

		public bool SetExclusiveImport(bool exclusive)
		{
			if (ActiveProject == null)
			{
				return false;
			}
			ActiveProject.ExclusiveImport = exclusive;
			return true;
		}

		public bool AddImportAsset(ImportAsset asset)
		{
			if (ActiveProject == null)
			{
				return false;
			}
			NewAssetsImported = true;
			ActiveProject.AddImportAsset(asset);
			return true;
		}

		public bool AddImportAssetsByTemplate(ImportAssetTemplate template)
		{
			if (ActiveProject == null)
			{
				return false;
			}
			NewAssetsImported = true;
			ActiveProject.AddImportAssetsByTemplate(template);
			return true;
		}

		public bool AddAssetsToRemove(string names)
		{
			if (ActiveProject == null)
			{
				return false;
			}
			if (!ActiveProject.RemoveImportedAssets(names))
			{
				throw new UnspecifiedException("Asset(s) '" + names + "' can not be found in the project: '" + ActiveProject.Name + "', you can only mark existing assets for removal", Error.Unknown);
			}
			logger.LogMessage("Asset(s): " + names + " flagged for removal", Logger.Verbosity.Normal);
			return true;
		}

		public bool AddAssetsToRemove(List<Asset> assets)
		{
			if (ActiveProject == null)
			{
				return false;
			}
			ActiveProject.RemoveImportedAssets(assets);
			return true;
		}

		public void ClearImportAssets()
		{
			if (ActiveProject != null)
			{
				ActiveProject.ImportAssets.Clear();
				ActiveProject.GTexImportAssets.Clear();
			}
		}

		public List<string> GetAssetNames()
		{
			if (ActiveProject == null)
			{
				return null;
			}
			return ActiveProject.Assets.Values.Select((Asset x) => x.Name).ToList();
		}

		public Asset GetAsset(Guid id)
		{
			if (ActiveProject == null)
			{
				return null;
			}
			if (!ActiveProject.Assets.ContainsKey(id))
			{
				return null;
			}
			return ActiveProject.Assets[id];
		}

		public Asset GetAsset(string name)
		{
			if (ActiveProject == null)
			{
				return null;
			}
			if (name == null)
			{
				return null;
			}
			return ActiveProject.Assets.Values.ToList().Find((Asset x) => x.Name.ToLowerInvariant() == name.ToLower());
		}

		public bool SetBlockSize(uint value)
		{
			if (ActiveProject == null)
			{
				return false;
			}
			if (value == 0)
			{
				value = Defaults.BlockSize;
			}
			ActiveProject.BuildConfiguration.BlockSize = value;
			return true;
		}

		public bool SetTileHeight(uint value)
		{
			if (ActiveProject == null)
			{
				return false;
			}
			ActiveProject.BuildConfiguration.TileHeight = value;
			return true;
		}

		public bool SetTileWidth(uint value)
		{
			if (ActiveProject == null)
			{
				return false;
			}
			ActiveProject.BuildConfiguration.TileWidth = value;
			return true;
		}

		public bool SetPageSize(uint value)
		{
			if (ActiveProject == null)
			{
				return false;
			}
			ActiveProject.BuildConfiguration.PageSize = value;
			return true;
		}

		public bool SetPagingStrategy(PagingStrategy value)
		{
			if (ActiveProject == null)
			{
				return false;
			}
			ActiveProject.BuildConfiguration.PagingStrategy = value;
			return true;
		}

		public bool SetTargetDisk(TargetDisk value)
		{
			if (ActiveProject == null)
			{
				return false;
			}
			ActiveProject.BuildConfiguration.TargetDisk = value;
			return true;
		}

		public bool SetMaximumAnisotropy(uint value)
		{
			if (ActiveProject == null)
			{
				return false;
			}
			ActiveProject.BuildConfiguration.MaximumAnisotropy = value;
			return true;
		}

		public bool SetTilingMode(TilingMode mode)
		{
			if (ActiveProject == null)
			{
				return false;
			}
			if (ActiveProject.BuildConfiguration.TilingMode != mode)
			{
				ActiveProject.BuildConfiguration.TilingMode = mode;
			}
			return true;
		}

		public bool SetOutputLocation(string path)
		{
			if (ActiveProject == null)
			{
				return false;
			}
			if (!ActiveProject.BuildConfiguration.SetOutputDirectoryAndFile(path))
			{
				throw new UnspecifiedException("Invalid output path '" + path + "', please set the output to a valid .gts filepath", Error.Unknown);
			}
			return true;
		}

		public bool SetOutputDirectory(string path, bool tryToMake)
		{
			if (ActiveProject == null)
			{
				return false;
			}
			if (!ActiveProject.BuildConfiguration.SetOutputDirectory(path))
			{
				if (tryToMake)
				{
					try
					{
						Directory.CreateDirectory(path);
					}
					catch
					{
					}
				}
				if (!ActiveProject.BuildConfiguration.SetOutputDirectory(path))
				{
					throw new UnspecifiedException("Invalid output directory path '" + path + "', please set the output directory to a valid path", Error.Unknown);
				}
			}
			return true;
		}

		public bool SetSoupOutputDirectory(string path, bool tryToMake)
		{
			if (ActiveProject == null)
			{
				return false;
			}
			if (!ActiveProject.BuildConfiguration.SetSoupOutputDirectory(path))
			{
				if (tryToMake)
				{
					try
					{
						Directory.CreateDirectory(path);
					}
					catch
					{
					}
				}
				if (!ActiveProject.BuildConfiguration.SetSoupOutputDirectory(path))
				{
					throw new UnspecifiedException("Invalid GTEX output directory path '" + path + "', please set the GTEX output directory to a valid path", Error.Unknown);
				}
			}
			return true;
		}

		public bool SetPagesDirectory(string path)
		{
			return SetPagesDirectory(path, tryToMake: false);
		}

		public bool SetPagesDirectory(string path, bool tryToMake)
		{
			if (ActiveProject == null)
			{
				return false;
			}
			if (!ActiveProject.BuildConfiguration.SetPagesOutputDirectory(path))
			{
				if (tryToMake)
				{
					try
					{
						Directory.CreateDirectory(path);
					}
					catch
					{
					}
				}
				if (!ActiveProject.BuildConfiguration.SetPagesOutputDirectory(path))
				{
					throw new UnspecifiedException("Invalid page file output directory path '" + path + "', please set the page file output directory to a valid path", Error.Unknown);
				}
			}
			return true;
		}

		public void SetCleanOperationParameters(CleanOperationParameters param)
		{
			ActiveProject.BuildConfiguration.CleanOperationParameters = param;
		}

		public Error SetBuildProfile(string name)
		{
			if (ActiveProject == null)
			{
				return Error.NoProjectLoaded;
			}
			if (string.IsNullOrEmpty(name))
			{
				return Error.InvalidParameter;
			}
			if (!SetWorkingDirectory())
			{
				return Error.IOError;
			}
			if (ProfileLoader.IsBuildProfileDepricated(name))
			{
				throw new UnspecifiedException("Build profile '" + name + "' is deprecated!", Error.Unknown);
			}
			Error error = ProfileLoader.LoadAndActivateBuildProfile(name);
			if (error != 0)
			{
				throw new UnspecifiedException("Unable to load build profile '" + name + "', detailed error: '" + ProfileLoader.LastError + "'", error);
			}
			ActiveProject.BuildConfiguration.SetDefaults();
			BuildProfileChanged = !ActiveProject.BuildProfile.Equals(name, StringComparison.OrdinalIgnoreCase);
			ActiveProject.BuildProfile = name;
			return Save();
		}

		public CodingProfile MakeCodingProfileFromTemplate(string templateName)
		{
			ProfileLoader.LoadCodingProfile(templateName, out var profile);
			if (profile != null)
			{
				profile.Name = "Custom";
			}
			return profile;
		}

		public ImportSummary GetImportSummary()
		{
			if (ActiveProject == null)
			{
				return null;
			}
			return ActiveProject.ImportSummary;
		}

		public void Import()
		{
			Build(Task.NoBuild, Process.Import);
		}

		public void Import(ImportAsset importAsset)
		{
			ActiveProject.ImportAssets.Clear();
			ActiveProject.ImportTemplates.Clear();
			ActiveProject.GTexImportAssets.Clear();
			AddImportAsset(importAsset);
			Import();
			QueryAssetBuildStates();
		}

		public void Import(ImportAssetTemplate importAssetTemplate)
		{
			ActiveProject.ImportAssets.Clear();
			ActiveProject.ImportTemplates.Clear();
			ActiveProject.GTexImportAssets.Clear();
			AddImportAssetsByTemplate(importAssetTemplate);
			Import();
			QueryAssetBuildStates();
		}

		public Error Import(string importScriptfilename)
		{
			ActiveProject.ImportAssets.Clear();
			ActiveProject.GTexImportAssets.Clear();
			if (!AddLayersAndAssetsFromXMLFile(importScriptfilename))
			{
				return Error.Fail;
			}
			Import();
			QueryAssetBuildStates();
			return Error.Ok;
		}

		public bool RemoveAsset(Guid assetId)
		{
			Asset asset = GetAsset(assetId);
			if (asset == null)
			{
				return false;
			}
			if (asset.Type == AssetType.CubeMap)
			{
				List<Asset> cubeMapFaces = GetCubeMapFaces(asset.AssetGroupId);
				ActiveProject.AssetsToRemove.AddRange(cubeMapFaces);
				CleanAssets(cubeMapFaces);
			}
			else
			{
				ActiveProject.AssetsToRemove.Add(asset);
				CleanAsset(asset);
			}
			ActiveProject.ImportAssets.Clear();
			ActiveProject.GTexImportAssets.Clear();
			Import();
			QueryAssetBuildStates();
			return true;
		}

		public List<Asset> RenameAsset(Guid assetId, string name)
		{
			Asset asset = GetAsset(assetId);
			if (asset == null)
			{
				return null;
			}
			List<Asset> list = new List<Asset>();
			string text = null;
			if (!string.IsNullOrEmpty(asset.AssetGroupId))
			{
				IEnumerable<Asset> collection = ActiveProject.Assets.Values.Where((Asset x) => asset.AssetGroupId.Equals(x.AssetGroupId));
				list.AddRange(collection);
				list.Sort((Asset _asset1, Asset _asset2) => _asset1.Name.CompareTo(_asset2.Name));
				text = "_face";
			}
			else
			{
				list.Add(asset);
			}
			for (int i = 0; i < list.Count; i++)
			{
				string text2 = name;
				if (text != null)
				{
					text2 = text2 + text + i;
				}
				RenameAssetFiles(list[i], text2);
				list[i].Name = text2;
				if (!string.IsNullOrEmpty(list[i].AssetGroupId))
				{
					list[i].AssetGroupId = name;
				}
				BuildStateSummary.AssetStates[list[i].Id].Changes = CausingChanges.GeneralChanges;
			}
			Build(Task.NoBuild, Process.None);
			return list;
		}

		private void RenameAssetFiles(Asset asset, string newName)
		{
			List<Asset> list = new List<Asset>();
			list.Add(asset);
			CleanFiles(list);
		}

		public bool RemoveAssets(List<Guid> assetIds, bool autoRemoveGroups)
		{
			foreach (Guid assetId in assetIds)
			{
				Asset asset = GetAsset(assetId);
				if (asset == null)
				{
					break;
				}
				List<Asset> list = new List<Asset>();
				list.Add(asset);
				if (asset.AssetGroupId != null && asset.AssetGroupId.Length > 0 && autoRemoveGroups)
				{
					IEnumerable<Asset> collection = ActiveProject.Assets.Values.Where((Asset x) => asset.AssetGroupId.Equals(x.AssetGroupId));
					list.AddRange(collection);
				}
				foreach (Asset item in list)
				{
					CleanAsset(item);
					if (!ActiveProject.AssetsToRemove.Contains(item))
					{
						ActiveProject.AssetsToRemove.Add(item);
					}
				}
			}
			ActiveProject.ImportAssets.Clear();
			Import();
			QueryAssetBuildStates();
			return true;
		}

		public bool RemoveAssets(List<Guid> assetIds)
		{
			return RemoveAssets(assetIds, autoRemoveGroups: false);
		}

		private void Clean(CleanOperationParameters param)
		{
			ProgressTracker.StartTask(SlowTask.Cleaning);
			if (CleanFiles(param))
			{
				ProcessResult = PipelineProcessResult.Success;
			}
			else
			{
				ProcessResult = PipelineProcessResult.Failed;
			}
			CleanTempDir();
			logger.LogMessage("Clean finished", Logger.Verbosity.Normal);
			LoadConfiguration(TargetConfiguration);
			ProgressTracker.EndTask(SlowTask.Cleaning);
		}

		private void CleanCompatibilityV31()
		{
			ProgressTracker.StartTask(SlowTask.Cleaning);
			if (CleanFilesCompatibilityV31())
			{
				ProcessResult = PipelineProcessResult.Success;
			}
			else
			{
				ProcessResult = PipelineProcessResult.Failed;
			}
			CleanTempDir();
			logger.LogMessage("Clean finished", Logger.Verbosity.Normal);
			LoadConfiguration(TargetConfiguration);
			ProgressTracker.EndTask(SlowTask.Cleaning);
		}

		private void CleanAsset(Asset asset)
		{
			List<Asset> list = new List<Asset>();
			list.Add(asset);
			CleanAssets(list);
		}

		private void CleanAssets(List<Asset> assets)
		{
			ProgressTracker.StartTask(SlowTask.Cleaning);
			if (CleanFiles(assets))
			{
				ProcessResult = PipelineProcessResult.Success;
			}
			else
			{
				ProcessResult = PipelineProcessResult.Failed;
			}
			CleanTempDir();
			logger.LogMessage("Clean finished", Logger.Verbosity.Normal);
			ProgressTracker.EndTask(SlowTask.Cleaning);
		}

		public void Build(Task task, Process process, BuildMode buildMode = BuildMode.BuildForGTP)
		{
			Cancel(value: false);
			if (ActiveProject == null)
			{
				ProcessResult = PipelineProcessResult.Failed;
				return;
			}
			string currentDirectory = Directory.GetCurrentDirectory();
			SetWorkingDirectory();
			NixelContextManager.BuildMode = (EnableHighQualityCoding ? Nixel.BuildMode.High : Nixel.BuildMode.Fast);
			ActiveBuildingMode = buildMode;
			BuildConfiguration buildConfiguration = ActiveProject.BuildConfiguration;
			string title = string.Format("GrBuild {0} (project version {1})", new object[2]
			{
				Constants.Version.BuildVersion,
				Constants.Version.ProjectCompatibilityVersion
			});
			logger.LogTitle(title, Logger.Verbosity.Normal);
			logger.LogLine(Logger.Verbosity.Normal);
			logger.LogMessage("Settings:", Logger.Verbosity.Normal);
			logger.LogMessage("\tBuild Profile:\t\t" + ActiveProject.BuildProfile, Logger.Verbosity.Normal);
			logger.LogMessage("\tBuild config:\t\t" + TargetConfiguration, Logger.Verbosity.Normal);
			logger.LogMessage("\tGTex directory:\t" + buildConfiguration.SoupOutputDirectory, Logger.Verbosity.Normal);
			logger.LogMessage("\tOutput directory:\t" + buildConfiguration.OutputDirectory, Logger.Verbosity.Normal);
			logger.LogMessage("\tOutput filename:\t" + buildConfiguration.OutputFilename, Logger.Verbosity.Normal);
			logger.LogMessage("\tLog file:\t\t" + buildConfiguration.LogFile, Logger.Verbosity.Normal);
			logger.LogMessage("\tMaximum anisotropy:\t" + buildConfiguration.MaximumAnisotropy + ((buildConfiguration.MaximumAnisotropy == Defaults.Aniso) ? "" : " (Custom)"), Logger.Verbosity.Normal);
			logger.LogMessage("\tPage size:\t\t" + ((buildConfiguration.PageSize != 0) ? buildConfiguration.PageSize.ToString() : "Auto") + ((buildConfiguration.PageSize == Defaults.PageSize) ? "" : " (Custom)"), Logger.Verbosity.Normal);
			logger.LogMessage("\tTargetDisk:\t\t" + buildConfiguration.TargetDisk, Logger.Verbosity.Normal);
			logger.LogMessage("\tTile width:\t\t" + ((buildConfiguration.TileWidth != 0) ? buildConfiguration.TileWidth.ToString() : "Auto") + ((buildConfiguration.TileWidth == Defaults.TileWidth) ? "" : " (Custom)"), Logger.Verbosity.Normal);
			logger.LogMessage("\tTile height:\t\t" + ((buildConfiguration.TileHeight != 0) ? buildConfiguration.TileHeight.ToString() : "Auto") + ((buildConfiguration.TileHeight == Defaults.TileHeight) ? "" : " (Custom)"), Logger.Verbosity.Normal);
			logger.LogLine(Logger.Verbosity.Normal);
			DateTime now = DateTime.Now;
			if (!NewAssetsImported && ActiveProject.Assets.Count() == 0)
			{
				logger.LogMessage("no assets to build", Logger.Verbosity.Normal);
				process = Process.None;
			}
			switch (task)
			{
			case Task.Rebuild:
				if (!CleanFiles(CleanOperationParameters.AllButSoups))
				{
					ProcessResult = PipelineProcessResult.Failed;
					Directory.SetCurrentDirectory(currentDirectory);
					return;
				}
				break;
			case Task.Clean:
				Clean(ActiveProject.BuildConfiguration.CleanOperationParameters);
				Directory.SetCurrentDirectory(currentDirectory);
				return;
			case Task.Repage:
				CleanGTSFiles();
				break;
			}
			if (!LockProject())
			{
				ProcessResult = PipelineProcessResult.Failed;
				Directory.SetCurrentDirectory(currentDirectory);
				return;
			}
			if (!OpenState())
			{
				UnLockProject();
				ProcessResult = PipelineProcessResult.Failed;
				Directory.SetCurrentDirectory(currentDirectory);
				return;
			}
			if (process == Process.None)
			{
				if (Save() != 0)
				{
					UnLockProject();
					ProcessResult = PipelineProcessResult.Failed;
					Directory.SetCurrentDirectory(currentDirectory);
					return;
				}
				ProcessResult = PipelineProcessResult.Success;
			}
			if (process != Process.Import && !CanBuildProject())
			{
				ProcessResult = PipelineProcessResult.Failed;
				return;
			}
			PreProcessTask[] array = new PreProcessTask[6]
			{
				new PreProcessTask(AssetImporter.PreProcess, Process.Import),
				new PreProcessTask(Atlasser.PreProcess, Process.Atlas),
				new PreProcessTask(TileFilePreprocessor.PreProcess, Process.TileFilePreProcess),
				new PreProcessTask(CompositorAndCoder.PreProcess, Process.ComposeAndCode),
				new PreProcessTask(Orderer.PreProcess, Process.Order),
				new PreProcessTask(TileFileBuilder.PreProcess, Process.Build)
			};
			ProcessTask[] array2 = new ProcessTask[6]
			{
				new ProcessTask(AssetImporter.Process, Process.Import),
				new ProcessTask(Atlasser.Process, Process.Atlas),
				new ProcessTask(TileFilePreprocessor.Process, Process.TileFilePreProcess),
				new ProcessTask(CompositorAndCoder.Process, Process.ComposeAndCode),
				new ProcessTask(Orderer.Process, Process.Order),
				new ProcessTask(TileFileBuilder.Process, Process.Build)
			};
			PostProcessTask[] array3 = new PostProcessTask[6]
			{
				new PostProcessTask(AssetImporter.PostProcess, Process.Import),
				new PostProcessTask(Atlasser.PostProcess, Process.Atlas),
				new PostProcessTask(TileFilePreprocessor.PostProcess, Process.TileFilePreProcess),
				new PostProcessTask(CompositorAndCoder.PostProcess, Process.ComposeAndCode),
				new PostProcessTask(Orderer.PostProcess, Process.Order),
				new PostProcessTask(TileFileBuilder.PostProcess, Process.Build)
			};
			List<PreProcessTask> list = new List<PreProcessTask>();
			for (int i = 0; i < array.Length; i++)
			{
				if (process == Process.All || process == array[i].owningProcess)
				{
					list.Add(array[i]);
				}
			}
			List<ProcessTask> list2 = new List<ProcessTask>();
			for (int j = 0; j < array2.Length; j++)
			{
				if (process == Process.All || process == array2[j].owningProcess)
				{
					list2.Add(array2[j]);
				}
			}
			List<PostProcessTask> list3 = new List<PostProcessTask>();
			for (int k = 0; k < array3.Length; k++)
			{
				if (process == Process.All || process == array3[k].owningProcess)
				{
					list3.Add(array3[k]);
				}
			}
			ProgressTracker.StartTask(SlowTask.Preprocess);
			foreach (PreProcessTask item in list)
			{
				if (Canceled)
				{
					ProcessResult = PipelineProcessResult.Canceled;
				}
				else
				{
					ProcessResult = item.procedure();
				}
				if (ProcessResult != 0)
				{
					Failed(process, now);
					UnLockProject();
					Cancel(value: false);
					Directory.SetCurrentDirectory(currentDirectory);
					return;
				}
				if (Save() != 0)
				{
					UnLockProject();
					Directory.SetCurrentDirectory(currentDirectory);
					return;
				}
			}
			ProgressTracker.EndTask(SlowTask.Preprocess);
			foreach (ProcessTask item2 in list2)
			{
				if (Canceled)
				{
					ProcessResult = PipelineProcessResult.Canceled;
				}
				else
				{
					ProcessResult = item2.procedure();
				}
				if (ProcessResult != 0)
				{
					Failed(process, now);
					UnLockProject();
					Cancel(value: false);
					Directory.SetCurrentDirectory(currentDirectory);
					return;
				}
				if (Save() != 0)
				{
					UnLockProject();
					Directory.SetCurrentDirectory(currentDirectory);
					return;
				}
			}
			PipelineProcessResult processResult = ProcessResult;
			foreach (PostProcessTask item3 in list3)
			{
				if (Canceled)
				{
					ProcessResult = PipelineProcessResult.Canceled;
				}
				else
				{
					ProcessResult = item3.procedure(processResult);
				}
				if (ProcessResult != 0)
				{
					Failed(process, now);
					UnLockProject();
					Cancel(value: false);
					Directory.SetCurrentDirectory(currentDirectory);
					return;
				}
				if (Save() != 0)
				{
					UnLockProject();
					Directory.SetCurrentDirectory(currentDirectory);
					return;
				}
			}
			logger.LogLine(Logger.Verbosity.Normal);
			DateTime dateTime = new DateTime(DateTime.Now.Ticks - now.Ticks + 10000000 - 1);
			string text = "";
			string text2 = dateTime.ToString("HH:mm:ss");
			if (process == Process.All)
			{
				string path = Path.Combine(ActiveProject.BuildConfiguration.OutputDirectory, ActiveProject.BuildConfiguration.OutputFilename);
				path = Path.GetFullPath(path);
				text = string.Format("Build succeeded ({0}).\nOutput written to \"{1}\".", new object[2] { text2, path });
			}
			else
			{
				text = process.ToString() + " succeeded (" + text2 + ")";
			}
			logger.LogMessage(text, Logger.Verbosity.Normal);
			UnLockProject();
			CleanTempDir();
			Directory.SetCurrentDirectory(currentDirectory);
		}

		public string GetProjectPath()
		{
			return ProjectPath;
		}

		public void QueryAssetBuildStates()
		{
			BuildStateManager.Scan();
		}

		public ImportScript RecreateImportScript()
		{
			ImportScript importScript = new ImportScript();
			importScript.LayerConfig = ActiveProject.LayerConfiguration;
			foreach (Asset value in ActiveProject.Assets.Values)
			{
				ImportAsset import = null;
				if (AssetTools.AssetToImportAsset(value, ProjectPath, out import))
				{
					importScript.ImportAssets.Add(import);
				}
			}
			return importScript;
		}

		public void ExportToImportScript(string filename)
		{
			ImportScript script = RecreateImportScript();
			XMLEngine.WriteImportScript(filename, script);
		}

		public Asset GetCubeMapFace0(string groupName)
		{
			if (ActiveProject == null)
			{
				return null;
			}
			List<Asset> list = new List<Asset>(ActiveProject.Assets.Values).FindAll((Asset x) => x.AssetGroupId != null && x.AssetGroupId.Equals(groupName) && x.Face == 0);
			if (list.Count > 0)
			{
				return list[0];
			}
			return null;
		}

		public List<Asset> GetCubeMapFaces(string groupName)
		{
			if (ActiveProject == null)
			{
				return null;
			}
			return new List<Asset>(ActiveProject.Assets.Values).FindAll((Asset x) => x.AssetGroupId.Equals(groupName));
		}

		public bool HasCustomQualityProfilesSet(int layerIdx)
		{
			foreach (Asset value in ActiveProject.Assets.Values)
			{
				string qualityProfile = value.AssetLayers[layerIdx].QualityProfile;
				if (!string.IsNullOrEmpty(qualityProfile) && !qualityProfile.Equals("default", StringComparison.OrdinalIgnoreCase))
				{
					return true;
				}
			}
			return false;
		}

		public bool HasCustomQualityProfilesSet()
		{
			foreach (Asset value in ActiveProject.Assets.Values)
			{
				foreach (AssetLayer assetLayer in value.AssetLayers)
				{
					string qualityProfile = assetLayer.QualityProfile;
					if (!string.IsNullOrEmpty(qualityProfile) && !qualityProfile.Equals("default", StringComparison.OrdinalIgnoreCase))
					{
						return true;
					}
				}
			}
			return false;
		}

		private void Failed(Process process, DateTime startTime)
		{
			DateTime dateTime = new DateTime(DateTime.Now.Ticks - startTime.Ticks + 10000000 - 1);
			logger.LogLine(Logger.Verbosity.Normal);
			string text = ((process != 0) ? process.ToString() : "Build");
			text = text + " failed. (" + logger.ErrorCount + ") errors, (" + logger.WarningCount.ToString() + ") warnings (" + dateTime.ToString("HH:mm:ss") + ")";
			logger.LogMessage(text, Logger.Verbosity.Normal);
		}

		private bool OpenState()
		{
			if (!SetWorkingDirectory())
			{
				return false;
			}
			try
			{
				CreateDirectoryIfNotExists(StagingConfigurationDirectory);
			}
			catch (Exception ex)
			{
				string innerMessage = "Failed to create temporary directory '" + StagingConfigurationDirectory + "', detailed error: '" + ex.Message + "', please check your project folder access rights and try again";
				BuildReportingHandler.OnFatalError(BuildProcess.General, new GeneralIssue(innerMessage));
			}
			string text = Path.Combine(StagingConfigurationDirectory, ActiveProject.Name + Constants.BuildStateExtension);
			List<string> list = new List<string>();
			foreach (Asset value in ActiveProject.Assets.Values)
			{
				if (AssetTools.IsRootAsset(ActiveProject, value))
				{
					string soupFilePath = BuildState.GetSoupFilePath(ActiveProject, value);
					list.Add(soupFilePath);
				}
			}
			List<string> allRasterStateFileNames = BuildState.GetAllRasterStateFileNames(this);
			Project activeProject = ActiveProject;
			BuildState state = null;
			if (File.Exists(text))
			{
				try
				{
					XMLEngine.ReadBuildState(this, text, allRasterStateFileNames, list, out state);
					if (!AllowForeignGTex && state.ProjectId != ActiveProject.Id)
					{
						string innerMessage2 = "The temporary state doesn't match the project id, a new state will be created automatically";
						BuildReportingHandler.OnWarning(BuildProcess.General, new GeneralIssue(innerMessage2));
						state = null;
					}
				}
				catch (Exception ex2)
				{
					string innerMessage3 = "Unable to read the temporary state file '" + text + "' due to the following error: '" + ex2.Message + "', a new state file will be created automatically";
					BuildReportingHandler.OnWarning(BuildProcess.General, new GeneralIssue(innerMessage3));
					state = null;
				}
			}
			if (state == null)
			{
				state = new BuildState(activeProject.Id, this);
				try
				{
					XMLEngine.WriteBuildState(text, state);
					XMLEngine.ReadBuildState(this, text, allRasterStateFileNames, list, out state);
				}
				catch (Exception ex3)
				{
					string innerMessage4 = "Unable to create the temporary state file '" + text + "' due to the following error: '" + ex3.Message + "', please check your project folder and try again";
					BuildReportingHandler.OnFatalError(BuildProcess.General, new GeneralIssue(innerMessage4));
					return false;
				}
			}
			State = state;
			return true;
		}

		private bool CleanFiles(CleanOperationParameters param)
		{
			if (!SetWorkingDirectory())
			{
				return false;
			}
			if ((param.intermediates || param.soups) && !CompositorAndCoder.DeleteSerializedFiles(param))
			{
				return false;
			}
			if (param.intermediates && !TileFileBuilder.DeleteIntermediateFiles())
			{
				return false;
			}
			if (param.tileSet && !TileFileBuilder.DeleteOutputFiles())
			{
				return false;
			}
			if (!DeleteStateFile())
			{
				return false;
			}
			return true;
		}

		private bool CleanFilesCompatibilityV31()
		{
			try
			{
				Directory.Delete(Constants.StateDirName, recursive: true);
			}
			catch
			{
				string innerMessage = "Unable to delete folder '" + Constants.StateDirName + "'. Please delete this folder manually.";
				BuildReportingHandler.OnFatalError(BuildProcess.General, new GeneralIssue(innerMessage));
				return false;
			}
			return true;
		}

		private bool CleanFiles(List<Asset> assets)
		{
			if (!SetWorkingDirectory())
			{
				return false;
			}
			CleanOperationParameters allButTileSet = CleanOperationParameters.AllButTileSet;
			if (!CompositorAndCoder.DeleteSerializedFiles(allButTileSet, assets))
			{
				return false;
			}
			if (!TileSoupBuilder.DeleteSerializedFiles(this, assets))
			{
				return false;
			}
			return true;
		}

		private void CleanGTSFiles()
		{
			string fullPath = Path.GetFullPath(ActiveProject.BuildConfiguration.OutputDirectory);
			string outputFilename = ActiveProject.BuildConfiguration.OutputFilename;
			string text = Path.Combine(fullPath, outputFilename);
			GtsInfo info = default(GtsInfo);
			if (GTSBuilderTools.GetGtsInfo(text, out info) == Nixel.Error.Ok && GTSBuilderTools.GetGTPFiles(text, out var gtpFilenames, out var gtsType) && gtsType == TileFileType.GTS_WITH_GTP)
			{
				foreach (string item in gtpFilenames)
				{
					string path = Path.Combine(fullPath, item);
					try
					{
						File.Delete(path);
					}
					catch
					{
					}
				}
			}
			try
			{
				File.Delete(text);
			}
			catch
			{
			}
		}

		private bool DeleteStateFile()
		{
			string text = Path.Combine(StagingConfigurationDirectory, ActiveProject.Name + Constants.BuildStateExtension);
			try
			{
				if (File.Exists(text))
				{
					File.Delete(text);
				}
			}
			catch (Exception ex)
			{
				string innerMessage = "Unable to delete state file '" + text + "' due to the following error: " + ex.Message + ", make sure the folder '" + StagingConfigurationDirectory + "' isn't locked or being used by another process, then rebuild the project.";
				BuildReportingHandler.OnFatalError(BuildProcess.General, new GeneralIssue(innerMessage));
				return false;
			}
			return true;
		}

		private bool DeleteDirectoryIfEmpty(string folderName)
		{
			string randomFileName = Path.GetRandomFileName();
			DirectoryInfo directoryInfo = new DirectoryInfo(folderName);
			if (directoryInfo.Exists && directoryInfo.GetDirectories().Length == 0 && directoryInfo.GetFiles().Length == 0)
			{
				try
				{
					directoryInfo.MoveTo(randomFileName);
					directoryInfo.Delete();
				}
				catch
				{
				}
			}
			GC.Collect();
			return directoryInfo.Exists;
		}

		private bool CreateDirectoryIfNotExists(string folderName)
		{
			DirectoryInfo directoryInfo = new DirectoryInfo(folderName);
			if (directoryInfo.Exists)
			{
				return true;
			}
			directoryInfo.Create();
			return false;
		}

		private Error CreateStagingDirectory()
		{
			try
			{
				CreateDirectoryIfNotExists(StagingDirectory);
			}
			catch (Exception ex)
			{
				string innerMessage = "Failed to create temporary directory '" + StagingDirectory + "', detailed error: '" + ex.Message + "', please check your project folder access rights and try again";
				BuildReportingHandler.OnFatalError(BuildProcess.General, new GeneralIssue(innerMessage));
				return Error.IOError;
			}
			return Error.Ok;
		}

		private Error CreateStagingConfigurationDirectory()
		{
			Error error = CreateStagingDirectory();
			if (error != 0)
			{
				return error;
			}
			try
			{
				CreateDirectoryIfNotExists(StagingConfigurationDirectory);
			}
			catch (Exception ex)
			{
				string innerMessage = "Failed to create temporary directory '" + StagingConfigurationDirectory + "', detailed error: '" + ex.Message + "', please check your project folder access rights and try again";
				BuildReportingHandler.OnFatalError(BuildProcess.General, new GeneralIssue(innerMessage));
				return Error.IOError;
			}
			return Error.Ok;
		}

		private bool SetWorkingDirectory()
		{
			try
			{
				Directory.SetCurrentDirectory(ProjectPath);
			}
			catch (Exception ex)
			{
				throw new UnspecifiedException("Unable to initialize the project working directory, detailed error: '" + ex.Message + "'", Error.IOError);
			}
			return true;
		}

		private void CleanTempDir()
		{
			if (StagingConfigurationDirectory != null)
			{
				string folderName = Path.Combine(StagingConfigurationDirectory, Constants.StageDirName);
				DeleteDirectoryIfEmpty(folderName);
				DeleteDirectoryIfEmpty(StagingConfigurationDirectory);
				DeleteDirectoryIfEmpty(Constants.StateDirName);
			}
		}

		private Error Save()
		{
			if (ReadOnly)
			{
				return Error.Ok;
			}
			if (ExportImportScriptOnSave)
			{
				string filename = Path.Combine(ProjectPath, ActiveProject.Name + ".import.bak");
				try
				{
					ExportToImportScript(filename);
				}
				catch (Exception ex)
				{
					throw new UnspecifiedException("Unable to write a backup import script for the project. Detailed error: '" + ex.Message + "' please make sure that no other process is using the project files, the project folder is accessible and try again", Error.Unknown, ex);
				}
			}
			if (StagingConfigurationDirectory == null)
			{
				return Error.InvalidInternalState;
			}
			string text = Path.Combine(StagingConfigurationDirectory, ActiveProject.Name + ".xtmp");
			string text2 = Path.Combine(StagingConfigurationDirectory, ActiveProject.Name + Constants.BuildStateExtension);
			if (!SetWorkingDirectory())
			{
				return Error.IOError;
			}
			try
			{
				XMLEngine.WriteProject(text, ActiveProject);
				try
				{
					if (File.Exists(ProjectFileName))
					{
						File.Delete(ProjectFileName);
					}
					File.Move(text, ProjectFileName);
				}
				catch (Exception ex2)
				{
					string innerMessage = "Unable to write a the project file '" + ProjectFileName + ". Detailed error: '" + ex2.Message + "' please make sure that no other process is using the project files, the project folder is accessible and try again";
					BuildReportingHandler.OnFatalError(BuildProcess.General, new GeneralIssue(innerMessage));
					return Error.IOError;
				}
			}
			catch (Exception ex3)
			{
				string innerMessage2 = "Unable to write a temporary version of the project file '" + text + ". Detailed error: '" + ex3.Message + "' please make sure that no other process is using the project files, the project folder is accessible and try again";
				BuildReportingHandler.OnFatalError(BuildProcess.General, new GeneralIssue(innerMessage2));
			}
			try
			{
				if (State != null)
				{
					XMLEngine.WriteBuildState(text2, State);
				}
			}
			catch (Exception ex4)
			{
				string innerMessage3 = "Unable to write the state file '" + text2 + ". Detailed error: '" + ex4.Message + "' please make sure that no other process is using the project files, the project folder is accessible and try again";
				BuildReportingHandler.OnFatalError(BuildProcess.General, new GeneralIssue(innerMessage3));
				return Error.IOError;
			}
			return Error.Ok;
		}

		private bool LockProject()
		{
			if (ProjectFileName == null)
			{
				return false;
			}
			if (FileLock == null)
			{
				string filename = Path.Combine(ProjectPath, ActiveProject.Name + ".lock");
				FileLock = new FileLock(filename);
			}
			if (!FileLock.Lock())
			{
				string innerMessage = "Unable to lock the project, please make sure that no other process is using the project files, the project folder is accessible and try again";
				BuildReportingHandler.OnFatalError(BuildProcess.General, new GeneralIssue(innerMessage));
				return false;
			}
			return true;
		}

		private void UnLockProject()
		{
			if (FileLock != null)
			{
				FileLock.Unlock();
			}
		}

		private bool TestProjectCompatibility(string filename, out Version found, out Version required)
		{
			found = null;
			required = Constants.Version.ProjectCompatibilityVersion;
			try
			{
				found = XMLEngine.ReadProjectVersion(filename);
				if (!required.IsMajorCompatible(found))
				{
					return false;
				}
				if (found.IsNewer(required))
				{
					return false;
				}
			}
			catch
			{
				return false;
			}
			return true;
		}

		private bool TestProjectIntermediatesCompatibility()
		{
			if (State == null || State.ProjectVersion == null)
			{
				return true;
			}
			return State.ProjectVersion.IsMinorCompatible(Constants.Version.ProjectCompatibilityVersion);
		}

		private void EnsureValidLayerCodingProfile(BuildProfile buildProfile, LayerDescription layer, int layerIdx)
		{
			if (BuildProfileChanged && !layer.CodingProfile.Equals(buildProfile.DefaultCodingProfiles[layer.DataType], StringComparison.OrdinalIgnoreCase))
			{
				logger.LogWarning("Build Profile changed, converting Coding Profile '" + layer.CodingProfile + "' for layer " + layerIdx + " to Build Profile '" + buildProfile.DisplayName + "'. Switching to the default: '" + buildProfile.DefaultCodingProfiles[layer.DataType] + "'.");
				layer.CodingProfile = buildProfile.DefaultCodingProfiles[layer.DataType];
				return;
			}
			bool flag = false;
			for (int i = 0; i < buildProfile.AvailableCodingProfiles.Count; i++)
			{
				if (buildProfile.AvailableCodingProfiles[i].Equals(layer.CodingProfile, StringComparison.OrdinalIgnoreCase))
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				logger.LogWarning("Coding Profile '" + layer.CodingProfile + "' for layer " + layerIdx + " is incompatible with Build Profile '" + buildProfile.DisplayName + "'. Switching to the default: '" + buildProfile.DefaultCodingProfiles[layer.DataType] + "'.");
				layer.CodingProfile = buildProfile.DefaultCodingProfiles[layer.DataType];
			}
		}
	}
	public class BuildConfiguration
	{
		public string DepricatedCodingProfile { get; set; }

		public string OutputDirectory { get; set; }

		public string OutputType { get; set; }

		public string OutputFilename { get; set; }

		public string SoupOutputDirectory { get; set; }

		public uint WarningLevel { get; set; }

		public string LogFile { get; set; }

		public TilingMode TilingMode { get; set; }

		public uint MaximumAnisotropy { get; set; }

		public uint PageSize { get; set; }

		public TargetDisk TargetDisk { get; set; }

		public uint TileWidth { get; set; }

		public uint TileHeight { get; set; }

		public string PagesDirectory { get; set; }

		public uint BlockSize { get; set; }

		public PagingStrategy PagingStrategy { get; set; }

		public CleanOperationParameters CleanOperationParameters { get; set; }

		public BuildConfiguration(string filename)
		{
			string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(filename);
			OutputDirectory = ".";
			SoupOutputDirectory = ".";
			LogFile = fileNameWithoutExtension + ".log";
			OutputType = "GTS";
			OutputFilename = fileNameWithoutExtension + ".gts";
			PagesDirectory = "";
			SetDefaults();
		}

		public BuildConfiguration()
		{
			OutputDirectory = ".";
			SoupOutputDirectory = ".";
			LogFile = null;
			OutputType = "GTS";
			OutputFilename = null;
			PagesDirectory = "";
			SetDefaults();
		}

		public bool SetOutputDirectoryAndFile(string path)
		{
			try
			{
				OutputDirectory = Paths.GetDirectoryName(path);
				if (OutputDirectory.Length == 0)
				{
					OutputDirectory = ".";
				}
				OutputFilename = Path.GetFileName(path);
				if (OutputFilename.Length == 0 || Path.GetExtension(OutputFilename).Length == 0)
				{
					return false;
				}
			}
			catch
			{
				return false;
			}
			return true;
		}

		public bool SetOutputDirectory(string path)
		{
			try
			{
				if ((File.GetAttributes(path) & FileAttributes.Directory) != FileAttributes.Directory)
				{
					return false;
				}
				OutputDirectory = path;
				if (OutputDirectory.Length == 0)
				{
					OutputDirectory = ".";
				}
			}
			catch
			{
				return false;
			}
			return true;
		}

		public bool SetSoupOutputDirectory(string path)
		{
			try
			{
				if ((File.GetAttributes(path) & FileAttributes.Directory) != FileAttributes.Directory)
				{
					return false;
				}
				SoupOutputDirectory = path;
				if (SoupOutputDirectory.Length == 0)
				{
					SoupOutputDirectory = Constants.DefaultSoupDirectory;
				}
			}
			catch (FileNotFoundException)
			{
				try
				{
					Directory.CreateDirectory(path);
				}
				catch
				{
					return false;
				}
				return false;
			}
			catch (Exception)
			{
				return false;
			}
			return true;
		}

		public bool SetPagesOutputDirectory(string path)
		{
			if (string.IsNullOrEmpty(path))
			{
				PagesDirectory = Constants.DefaultPagefileDirectory;
				return true;
			}
			PagesDirectory = path.Replace('/', '\\');
			if (PagesDirectory.Length == 0)
			{
				PagesDirectory = Constants.DefaultPagefileDirectory;
			}
			return true;
		}

		public string GetGtsFileName()
		{
			return Path.Combine(OutputDirectory, OutputFilename);
		}

		public void SetDefaults()
		{
			TilingMode = Defaults.TilingMode;
			WarningLevel = Defaults.WarningLevel;
			MaximumAnisotropy = Defaults.Aniso;
			PageSize = Defaults.PageSize;
			TargetDisk = Defaults.TargetDisk;
			TileWidth = Defaults.TileWidth;
			TileHeight = Defaults.TileHeight;
			BlockSize = Defaults.BlockSize;
			CleanOperationParameters = Defaults.CleanOperationParameters;
		}

		public bool IsCompatibleWithTileLayout(TileLayout tileLayout)
		{
			TileLayout rhs = TileLayout.ResolveDefaults(tileLayout);
			return TileLayout.ResolveDefaults(new TileLayout(TileWidth, TileHeight, MaximumAnisotropy)).Equals(rhs);
		}
	}
	internal class AtlasConfiguration
	{
		public bool AllowRotations { get; set; }
	}
	public struct TileLayout
	{
		public uint tileWidth;

		public uint tileHeight;

		public uint borderSize;

		public TileLayout(uint width, uint height, uint borderSize)
		{
			tileWidth = width;
			tileHeight = height;
			this.borderSize = borderSize;
		}

		public bool Equals(TileLayout rhs)
		{
			if (tileWidth == rhs.tileWidth && tileHeight == rhs.tileHeight)
			{
				return borderSize == rhs.borderSize;
			}
			return false;
		}

		public static TileLayout ResolveDefaults(TileLayout tileLayout)
		{
			TileLayout result = default(TileLayout);
			result.tileWidth = ((tileLayout.tileWidth == 0) ? Defaults.TileSize : tileLayout.tileWidth);
			result.tileHeight = ((tileLayout.tileHeight == 0) ? Defaults.TileSize : tileLayout.tileHeight);
			result.borderSize = tileLayout.borderSize;
			return result;
		}
	}
	internal class TileSetConfig
	{
		public TileLayout TileLayout { get; set; }

		public int Width { get; set; }

		public int Height { get; set; }

		public int LayerCount { get; set; }

		public DateTime LastChangedDate { get; set; }

		public TileSetConfig()
		{
			TileLayout = default(TileLayout);
		}

		public bool Equals(TileSetConfig rhs)
		{
			return true & (Width == rhs.Width) & (Height == rhs.Height) & (LayerCount == rhs.LayerCount) & TileLayout.Equals(rhs.TileLayout);
		}
	}
	internal class NixelCodecConfiguration
	{
		public int CodecId { get; set; }

		public string CodecConfiguration { get; set; }
	}
	internal class NixelCodingGroupDescription
	{
		public Guid Id { get; set; }

		public NixelCodecConfiguration CodecConfig { get; set; }
	}
	internal class NixelContext
	{
		public TiledTopology TiledTopology { get; set; }

		public RasterTileDimension TileDimensions { get; set; }

		public ITiledRasterData TiledRasterData { get; set; }

		public ITiledBuildParameters TiledBuildParameters { get; set; }
	}
	public class ChannelMerging
	{
		public class ChannelMask
		{
			public string[] bitPatterns = new string[4];

			public string[] humanReadable = new string[4];
		}

		private const string AllChannels = "1111";

		public static bool IsCombinedMode(AssetPackingMode mode)
		{
			return mode != AssetPackingMode.None;
		}

		public static string GetChannelMask(DataType dataType, AssetPackingMode inputType, int subIndex)
		{
			if (inputType == AssetPackingMode.None)
			{
				return "1111";
			}
			Dictionary<AssetPackingMode, ChannelMask> allMasks = new Dictionary<AssetPackingMode, ChannelMask>();
			GetAllChannelMasks(dataType, ref allMasks);
			if (allMasks.ContainsKey(inputType))
			{
				return allMasks[inputType].bitPatterns[subIndex];
			}
			return "1111";
		}

		public static string GetChannelMaskHumanReadable(DataType dataType, AssetPackingMode inputType, int subIndex)
		{
			if (inputType == AssetPackingMode.None)
			{
				return GetDataTypeChannelNames(dataType);
			}
			Dictionary<AssetPackingMode, ChannelMask> allMasks = new Dictionary<AssetPackingMode, ChannelMask>();
			GetAllChannelMasks(dataType, ref allMasks);
			if (allMasks.ContainsKey(inputType))
			{
				return allMasks[inputType].humanReadable[subIndex];
			}
			return "1111";
		}

		public static bool isValidPackingModeForDataType(DataType dataType, AssetPackingMode inputType)
		{
			if (inputType == AssetPackingMode.None)
			{
				return true;
			}
			Dictionary<AssetPackingMode, ChannelMask> allMasks = new Dictionary<AssetPackingMode, ChannelMask>();
			GetAllChannelMasks(dataType, ref allMasks);
			return allMasks.ContainsKey(inputType);
		}

		public static string GetDataTypeChannelNames(DataType dataType)
		{
			switch (dataType)
			{
			case DataType.R8G8B8_SRGB:
			case DataType.R8G8B8_LINEAR:
			case DataType.R32G32B32:
			case DataType.R32G32B32_FLOAT:
			case DataType.R16G16B16_FLOAT:
				return "RGB";
			case DataType.R8G8B8A8_SRGB:
			case DataType.R8G8B8A8_LINEAR:
			case DataType.R32G32B32A32:
			case DataType.R32G32B32A32_FLOAT:
			case DataType.R16G16B16A16_FLOAT:
				return "RGBA";
			case DataType.X8Y8:
			case DataType.X16Y16:
				return "XY";
			case DataType.X8:
			case DataType.X16:
			case DataType.X32:
			case DataType.X32_FLOAT:
				return "X";
			case DataType.X8Y8Z0_TANGENT:
			case DataType.X8Y8Z8:
			case DataType.X16Y16Z16:
			case DataType.X32Y32:
			case DataType.X32Y32_FLOAT:
			case DataType.X32Y32Z32:
			case DataType.X32Y32Z32_FLOAT:
				return "XYZ";
			case DataType.X8Y8Z8W8:
			case DataType.X16Y16Z16W16:
			case DataType.X32Y32Z32W32:
			case DataType.X32Y32Z32W32_FLOAT:
				return "XYZW";
			default:
				return "XYZW";
			}
		}

		public static int GetChannelCount(AssetPackingMode packing, DataType dataType, int LayerIndex, int subIdx = 0)
		{
			if (packing == AssetPackingMode.None)
			{
				return DataTypeInfo.GetNumChannels(dataType);
			}
			switch (dataType)
			{
			case DataType.R8G8B8_SRGB:
			case DataType.R8G8B8_LINEAR:
				if (packing == AssetPackingMode.Combined3)
				{
					return 1;
				}
				return 0;
			case DataType.R8G8B8A8_SRGB:
			case DataType.R8G8B8A8_LINEAR:
				return packing switch
				{
					AssetPackingMode.Combined4 => 1, 
					AssetPackingMode.Combined => subIdx switch
					{
						0 => 3, 
						1 => 1, 
						_ => 0, 
					}, 
					_ => 0, 
				};
			case DataType.X8Y8:
				if (packing == AssetPackingMode.Combined)
				{
					return subIdx switch
					{
						0 => 1, 
						1 => 1, 
						_ => 0, 
					};
				}
				return 0;
			case DataType.X8Y8Z8:
				if (packing == AssetPackingMode.Combined3)
				{
					if (subIdx >= 0 && subIdx <= 3)
					{
						return 1;
					}
					return 0;
				}
				return 0;
			case DataType.X8Y8Z8W8:
				if (packing == AssetPackingMode.Combined4)
				{
					if (subIdx >= 0 && subIdx <= 4)
					{
						return 1;
					}
					return 0;
				}
				return 0;
			default:
				return 0;
			}
		}

		public static void GetAllChannelMasks(DataType dataType, ref Dictionary<AssetPackingMode, ChannelMask> allMasks)
		{
			switch (dataType)
			{
			case DataType.R8G8B8A8_SRGB:
			case DataType.R8G8B8A8_LINEAR:
			{
				ChannelMask channelMask5 = new ChannelMask();
				channelMask5.bitPatterns = new string[4] { "1110", "0001", "0000", "0000" };
				channelMask5.humanReadable = new string[4] { "RGB", "A", null, null };
				allMasks.Add(AssetPackingMode.Combined, channelMask5);
				ChannelMask channelMask6 = new ChannelMask();
				channelMask6.bitPatterns = new string[4] { "1000", "0100", "0010", "0001" };
				channelMask6.humanReadable = new string[4] { "R", "G", "B", "A" };
				allMasks.Add(AssetPackingMode.Combined4, channelMask6);
				break;
			}
			case DataType.R8G8B8_SRGB:
			case DataType.R8G8B8_LINEAR:
			{
				ChannelMask channelMask4 = new ChannelMask();
				channelMask4.bitPatterns = new string[4] { "1000", "0100", "0010", "0000" };
				channelMask4.humanReadable = new string[4] { "R", "G", "B", null };
				allMasks.Add(AssetPackingMode.Combined3, channelMask4);
				break;
			}
			case DataType.X8Y8:
			{
				ChannelMask channelMask3 = new ChannelMask();
				channelMask3.bitPatterns = new string[4] { "1000", "0100", "0000", "0000" };
				channelMask3.humanReadable = new string[4] { "X", "Y", null, null };
				allMasks.Add(AssetPackingMode.Combined, channelMask3);
				break;
			}
			case DataType.X8Y8Z8:
			{
				ChannelMask channelMask2 = new ChannelMask();
				channelMask2.bitPatterns = new string[4] { "1000", "0100", "0010", "0000" };
				channelMask2.humanReadable = new string[4] { "X", "Y", "Z", null };
				allMasks.Add(AssetPackingMode.Combined3, channelMask2);
				break;
			}
			case DataType.X8Y8Z8W8:
			{
				ChannelMask channelMask = new ChannelMask();
				channelMask.bitPatterns = new string[4] { "1000", "0100", "0010", "0001" };
				channelMask.humanReadable = new string[4] { "X", "Y", "Z", "W" };
				allMasks.Add(AssetPackingMode.Combined4, channelMask);
				break;
			}
			case DataType.X8Y8Z0_TANGENT:
			case DataType.X8:
				break;
			}
		}

		public static AssetPackingMode UpdatePackingMode(DataType dataType, AssetPackingMode mode, int validTextures)
		{
			if (isValidPackingModeForDataType(dataType, mode))
			{
				return mode;
			}
			Dictionary<AssetPackingMode, ChannelMask> allMasks = new Dictionary<AssetPackingMode, ChannelMask>();
			GetAllChannelMasks(dataType, ref allMasks);
			if (allMasks.Count == 1)
			{
				return allMasks.ElementAt(0).Key;
			}
			if (mode == AssetPackingMode.Combined3 && allMasks.ContainsKey(AssetPackingMode.Combined4))
			{
				return AssetPackingMode.Combined4;
			}
			if (mode == AssetPackingMode.Combined4 && allMasks.ContainsKey(AssetPackingMode.Combined3))
			{
				return AssetPackingMode.Combined3;
			}
			AssetPackingMode result = AssetPackingMode.None;
			foreach (KeyValuePair<AssetPackingMode, ChannelMask> item in allMasks)
			{
				if (item.Value.humanReadable.Count((string _mask) => _mask != null) <= validTextures)
				{
					result = item.Key;
				}
			}
			return result;
		}

		public static int GetMaxValidSubTextureIdx(AssetPackingMode mode)
		{
			return mode switch
			{
				AssetPackingMode.None => 0, 
				AssetPackingMode.Combined => 1, 
				AssetPackingMode.Combined3 => 2, 
				AssetPackingMode.Combined4 => 3, 
				_ => 0, 
			};
		}
	}
	public class CombinedTextureSource
	{
		public class Item
		{
			public string Source;

			public int SubIndex;

			public Item(string _source, int _subindex)
			{
				Source = _source;
				SubIndex = _subindex;
			}
		}

		public List<Item> Sources;

		public CombinedTextureSource()
		{
			Sources = new List<Item>();
		}

		public string GetDefaultPath()
		{
			if (Sources == null || Sources.Count < 1)
			{
				throw new InvalidProgramStateException("TextureSource is empty");
			}
			return Sources[0].Source;
		}

		public void AddSource(string path, int subIndex)
		{
			Sources.Add(new Item(path, subIndex));
		}

		public static bool operator !=(CombinedTextureSource a, CombinedTextureSource b)
		{
			return !(a == b);
		}

		public static bool operator ==(CombinedTextureSource a, CombinedTextureSource b)
		{
			if ((object)a == b)
			{
				return true;
			}
			if ((object)a == null || (object)b == null)
			{
				return false;
			}
			if (a.Sources.Count != b.Sources.Count)
			{
				return false;
			}
			for (int i = 0; i < a.Sources.Count; i++)
			{
				if (a.Sources[i].Source != b.Sources[i].Source)
				{
					return false;
				}
				if (a.Sources[i].SubIndex != b.Sources[i].SubIndex)
				{
					return false;
				}
			}
			return true;
		}

		public override bool Equals(object rhs)
		{
			if (rhs == null)
			{
				return false;
			}
			if (!(rhs is CombinedTextureSource combinedTextureSource))
			{
				return false;
			}
			return this == combinedTextureSource;
		}

		public override int GetHashCode()
		{
			return Sources.GetHashCode();
		}
	}
	public class ImportAssetLayerTemplate
	{
		public string QualityProfile { get; set; }

		public Flip Flip { get; set; }

		public string[] Swizzle { get; set; }

		public string[] InvertChannels { get; set; }

		public CombinedTextureSource Source { get; set; }

		public AssetPackingMode PackingMode { get; set; }

		public TextureMipSourceType MipSourceType { get; set; }

		public ColorSpace ColorSpace { get; set; }

		public ImportAssetLayerTemplate()
		{
			Source = new CombinedTextureSource();
			Swizzle = new string[4];
			InvertChannels = new string[4];
			for (int i = 0; i < 4; i++)
			{
				Swizzle[i] = "";
				InvertChannels[i] = "";
			}
			PackingMode = AssetPackingMode.None;
		}
	}
	public class ImportAssetTemplate
	{
		public string Name { get; set; }

		public List<ImportAssetLayerTemplate> LayerTemplates { get; private set; }

		public AssetTilingMethod TilingMethod { get; set; }

		public AutoScalingMode AutoScalingMode { get; set; }

		public int TargetWidth { get; set; }

		public int TargetHeight { get; set; }

		public ImportAssetTemplate()
		{
			LayerTemplates = new List<ImportAssetLayerTemplate>();
		}
	}
	public class ImportAsset
	{
		public List<ImportAssetLayer> Layers { get; private set; }

		public string Name { get; set; }

		public AssetType Type { get; set; }

		public AssetTilingMethod TilingMethod { get; set; }

		public AutoScalingMode AutoScalingMode { get; set; }

		public int TargetWidth { get; set; }

		public int TargetHeight { get; set; }

		public bool Reimport { get; set; }

		public ImportAsset()
		{
			Layers = new List<ImportAssetLayer>();
		}

		public ImportAsset(string name, ImportAssetLayer[] layerAssets)
		{
			Name = name;
			Layers = new List<ImportAssetLayer>(layerAssets);
		}

		public void AddAssetLayer(ImportAssetLayer layer)
		{
			Layers.Add(layer);
		}
	}
	public class ImportGTex
	{
		public string Src { get; set; }
	}
	public class ImportAssetLayer
	{
		public CombinedTextureSource Source { get; set; }

		public string QualityProfile { get; set; }

		public string[] Swizzle { get; set; }

		public string[] InvertChannels { get; set; }

		public Flip Flip { get; set; }

		internal string Resize { get; set; }

		public int TargetWidth { get; set; }

		public int TargetHeight { get; set; }

		public AssetLayerResizeMode ResizeMode { get; set; }

		public TextureMipSourceType MipSourceType { get; set; }

		public AssetPackingMode PackingMode { get; set; }

		public ColorSpace ColorSpace { get; set; }

		public ImportAssetLayer()
		{
			Source = new CombinedTextureSource();
			Swizzle = new string[4];
			InvertChannels = new string[4];
			for (int i = 0; i < 4; i++)
			{
				Swizzle[i] = "";
				InvertChannels[i] = "";
			}
			PackingMode = AssetPackingMode.None;
		}
	}
	public struct TextureChange
	{
		public Guid AssetId { get; internal set; }

		public string AssetName { get; internal set; }

		public string Source { get; internal set; }

		public int Layer { get; internal set; }

		public TextureChangeType ChangeType { get; internal set; }
	}
	public class Texture : ICloneable
	{
		public string Source { get; internal set; }

		public int Row { get; internal set; }

		public int Column { get; internal set; }

		public int SubIndex { get; internal set; }

		public int Width { get; internal set; }

		public int Height { get; internal set; }

		public int Face { get; internal set; }

		public int NumChannels { get; internal set; }

		public DateTime LastChangedDate { get; internal set; }

		public object Clone()
		{
			return MemberwiseClone();
		}
	}
	public class AssetLayer : ICloneable
	{
		public int LayerIndex { get; private set; }

		public List<Texture> Textures { get; internal set; }

		public AssetPackingMode PackingMode { get; set; }

		public string QualityProfile { get; set; }

		public string[] Swizzle { get; set; }

		public string[] InvertChannels { get; set; }

		public Flip Flip { get; set; }

		internal string Resize { get; set; }

		public int TargetWidth { get; set; }

		public int TargetHeight { get; set; }

		public AssetLayerResizeMode ResizeMode { get; set; }

		public TextureMipSourceType MipSourceType { get; set; }

		public TextureType[] TextureType { get; set; }

		public ColorSpace ColorSpace { get; set; }

		public AssetLayer(int layerIndex)
		{
			LayerIndex = layerIndex;
			Textures = new List<Texture>();
			TextureType = new TextureType[4];
			Swizzle = new string[4];
			InvertChannels = new string[4];
			for (int i = 0; i < 4; i++)
			{
				Swizzle[i] = "";
				InvertChannels[i] = "";
				TextureType[i] = GrBuildLib.TextureType.Unknown;
			}
			PackingMode = AssetPackingMode.None;
		}

		public object Clone()
		{
			AssetLayer assetLayer = (AssetLayer)MemberwiseClone();
			if (Textures != null)
			{
				assetLayer.Textures = new List<Texture>();
				{
					foreach (Texture texture in Textures)
					{
						assetLayer.Textures.Add((Texture)texture.Clone());
					}
					return assetLayer;
				}
			}
			return assetLayer;
		}

		public bool IsEmpty()
		{
			return Textures.Count == 0;
		}
	}
	public class Asset : ICloneable
	{
		public Guid Id { get; internal set; }

		public string AssetGroupId { get; internal set; }

		public AssetType Type { get; set; }

		public List<AssetLayer> AssetLayers { get; internal set; }

		public string Name { get; internal set; }

		public string NameIOFriendly => AssetTools.GetIOFriendlyAssetName(Name);

		public int Width { get; internal set; }

		public int Height { get; internal set; }

		public int Face { get; set; }

		public AssetTilingMethod TilingMethod { get; set; }

		public AutoScalingMode AutoScalingMode { get; set; }

		public int TargetWidth { get; set; }

		public int TargetHeight { get; set; }

		public UDimSettings[] UDimSettings { get; internal set; }

		public Asset()
		{
			AssetLayers = new List<AssetLayer>();
			UDimSettings = new UDimSettings[4];
			for (int i = 0; i < 4; i++)
			{
				UDimSettings[i] = null;
			}
		}

		public object Clone()
		{
			Asset asset = (Asset)MemberwiseClone();
			if (AssetLayers != null)
			{
				asset.AssetLayers = new List<AssetLayer>();
				foreach (AssetLayer assetLayer in AssetLayers)
				{
					asset.AssetLayers.Add((AssetLayer)assetLayer.Clone());
				}
			}
			for (int i = 0; i < 4; i++)
			{
				if (UDimSettings[i] != null)
				{
					asset.UDimSettings[i] = (UDimSettings)UDimSettings[i].Clone();
				}
			}
			return asset;
		}
	}
	public class AssetGroup
	{
		public string Name { get; internal set; }

		public List<Guid> Assets { get; private set; }
	}
	public class UDimSettings : ICloneable
	{
		public int UTiles { get; internal set; }

		public int VTiles { get; internal set; }

		public int UTileOffset { get; internal set; }

		public int VTileOffset { get; internal set; }

		public int MaxUTiles { get; set; }

		public UDimSettings()
		{
			UTiles = 0;
			VTiles = 0;
			UTileOffset = 0;
			VTileOffset = 0;
			MaxUTiles = 10;
		}

		public object Clone()
		{
			return MemberwiseClone();
		}

		public bool IsEqual(UDimSettings other)
		{
			return true & (UTiles == other.UTiles) & (VTiles == other.VTiles) & (UTileOffset == other.UTileOffset) & (VTileOffset == other.VTileOffset) & (MaxUTiles == other.MaxUTiles);
		}

		public static UDimSettings Merge(UDimSettings a, UDimSettings b)
		{
			if (a == null && b == null)
			{
				return null;
			}
			if (a != null && b == null)
			{
				return a.Clone() as UDimSettings;
			}
			if (a == null && b != null)
			{
				return b.Clone() as UDimSettings;
			}
			return new UDimSettings
			{
				MaxUTiles = Math.Max(a.MaxUTiles, b.MaxUTiles),
				UTileOffset = Math.Min(a.UTileOffset, b.UTileOffset),
				VTileOffset = Math.Min(a.VTileOffset, b.VTileOffset),
				UTiles = Math.Max(a.UTiles, b.UTiles),
				VTiles = Math.Max(a.VTiles, b.VTiles)
			};
		}
	}
	public class ImportScript
	{
		public LayerConfig LayerConfig { get; set; }

		public List<ImportAsset> ImportAssets { get; private set; }

		public ImportScript()
		{
			ImportAssets = new List<ImportAsset>();
		}
	}
	internal class TileFilePreprocessorProcess : ITileFilePreprocessorProcess, IPipelineProcess
	{
		private struct DriveSpaceRequirement
		{
			public ulong min;

			public ulong max;
		}

		private struct DriveLowSpaceInfo
		{
			public ulong min;

			public ulong max;

			public ulong space;

			public string drive;
		}

		private TileSetConfig tileSetConfig;

		private PipelineProcessResult latestResult;

		public ProjectBuilder ProjectBuilder { get; private set; }

		public PipelineProcessResult LatestResult => latestResult;

		public bool HasRun { get; private set; }

		public DateTime LastRun { get; private set; }

		public TileFilePreprocessorProcess(ProjectBuilder builder)
		{
			ProjectBuilder = builder;
		}

		public PipelineProcessResult PreProcess()
		{
			Project activeProject = ProjectBuilder.ActiveProject;
			uint maximumAnisotropy = activeProject.BuildConfiguration.MaximumAnisotropy;
			TilingMode tilingMode = activeProject.BuildConfiguration.TilingMode;
			latestResult = PipelineProcessResult.Failed;
			if (activeProject.LayerConfiguration.Layers.Count > Constants.MaxLayers)
			{
				TileFilePreprocessorIssue buildIssue = new TileFilePreprocessorIssue("The number of layers (" + activeProject.LayerConfiguration.Layers.Count + ") may not exceed " + Constants.MaxLayers + "! Please reduce the number of layers by splitting the layers over multiple tile sets.");
				ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileFilePreprocessor, buildIssue);
				return latestResult;
			}
			if (maximumAnisotropy < 0 || (maximumAnisotropy != 0 && (maximumAnisotropy & (maximumAnisotropy - 1)) != 0))
			{
				TileFileInvalidParameterIssue buildIssue2 = new TileFileInvalidParameterIssue("Maximum Anisotropy", "the value must be a power of 2");
				ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileFilePreprocessor, buildIssue2);
				return latestResult;
			}
			if (maximumAnisotropy > 16)
			{
				TileFileInvalidParameterIssue buildIssue3 = new TileFileInvalidParameterIssue("Maximum Anisotropy", "may not exceed 16");
				ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileFilePreprocessor, buildIssue3);
				return latestResult;
			}
			uint tileWidth = activeProject.BuildConfiguration.TileWidth;
			uint tileHeight = activeProject.BuildConfiguration.TileHeight;
			if (tilingMode == TilingMode.Software)
			{
				if (tileWidth != 0 && (tileWidth + 2 * maximumAnisotropy) % 16u != 0)
				{
					TileFileInvalidParameterIssue buildIssue4 = new TileFileInvalidParameterIssue("TileWidth", "TileWidth + 2 * MaximumAnisotropy must be a multiple of 16");
					ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileFilePreprocessor, buildIssue4);
					return latestResult;
				}
				if (tileHeight != 0 && (tileHeight + 2 * maximumAnisotropy) % 16u != 0)
				{
					TileFileInvalidParameterIssue buildIssue5 = new TileFileInvalidParameterIssue("TileHeight", "TileHeight + 2 * MaximumAnisotropy must be a multiple of 16");
					ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileFilePreprocessor, buildIssue5);
					return latestResult;
				}
			}
			latestResult = PipelineProcessResult.Success;
			return latestResult;
		}

		public PipelineProcessResult Process()
		{
			ProjectBuilder.ProgressTracker.StartTask(SlowTask.TileFilePreTaskProcess);
			_ = DateTime.Now;
			ProjectBuilder.logger.LogTitle("Preprocessing tile file...", Logger.Verbosity.Normal);
			Project activeProject = ProjectBuilder.ActiveProject;
			if (activeProject.LayerConfiguration == null)
			{
				latestResult = PipelineProcessResult.Failed;
				return LatestResult;
			}
			bool tileSizeWasOverridden = false;
			tileSetConfig = CreateTileSetConfig(ref tileSizeWasOverridden);
			if (tileSizeWasOverridden)
			{
				string message = $"Custom tile size could not be set ({activeProject.BuildConfiguration.TileWidth}x{activeProject.BuildConfiguration.TileHeight}). The license on this machine enforces a tile size of {Constants.FixedTileSize.X}x{Constants.FixedTileSize.Y}. Please upgrade your license if you require a different tile size.";
				ProjectBuilder.logger.LogConsole(message, Logger.Verbosity.Quiet);
			}
			UpdateState();
			PredictDiskSpace();
			ProjectBuilder.logger.LogMessage("Tile size: " + tileSetConfig.TileLayout.tileWidth + "x" + tileSetConfig.TileLayout.tileHeight + " pixels", Logger.Verbosity.Detailed);
			ProjectBuilder.logger.LogMessage("Border size: " + tileSetConfig.TileLayout.borderSize + " pixels", Logger.Verbosity.Detailed);
			HasRun = true;
			LastRun = DateTimeManagement.Now();
			latestResult = PipelineProcessResult.Success;
			ProjectBuilder.ProgressTracker.EndTask(SlowTask.TileFilePreTaskProcess);
			return latestResult;
		}

		private void UpdateState()
		{
			BuildState state = ProjectBuilder.State;
			if (state.TileSetConfiguration == null || !state.TileSetConfiguration.Equals(tileSetConfig))
			{
				state.TileSetConfiguration = tileSetConfig;
			}
		}

		private TileSetConfig CreateTileSetConfig(ref bool tileSizeWasOverridden)
		{
			TileSetConfig tileSetConfig = new TileSetConfig();
			Project activeProject = ProjectBuilder.ActiveProject;
			TileLayout tileLayout = default(TileLayout);
			tileSetConfig.LayerCount = activeProject.LayerConfiguration.Layers.Count;
			uint tileSize = Defaults.TileSize;
			if (activeProject.BuildConfiguration.TilingMode == TilingMode.Software)
			{
				tileLayout.borderSize = activeProject.BuildConfiguration.MaximumAnisotropy;
				tileLayout.tileWidth = tileSize;
				tileLayout.tileHeight = tileSize;
				if ((tileLayout.tileWidth + 2 * tileLayout.borderSize) % 16u != 0)
				{
					tileLayout.tileWidth += 16 - (tileLayout.tileWidth + 2 * tileLayout.borderSize) % 16u;
				}
				if ((tileLayout.tileHeight + 2 * tileLayout.borderSize) % 16u != 0)
				{
					tileLayout.tileHeight += 16 - (tileLayout.tileHeight + 2 * tileLayout.borderSize) % 16u;
				}
			}
			tileSetConfig.TileLayout = tileLayout;
			tileSetConfig.LastChangedDate = DateTimeManagement.Now();
			bool flag = Constants.FixedTileSize.Y > 0;
			if (activeProject.BuildConfiguration.TileHeight != 0 || flag)
			{
				tileLayout = tileSetConfig.TileLayout;
				if (flag)
				{
					tileLayout.tileHeight = (uint)Constants.FixedTileSize.Y;
					if (Constants.FixedTileSize.Y != (int)activeProject.BuildConfiguration.TileHeight && activeProject.BuildConfiguration.TileHeight != 0)
					{
						tileSizeWasOverridden = true;
					}
				}
				else
				{
					tileLayout.tileHeight = activeProject.BuildConfiguration.TileHeight;
				}
				tileSetConfig.TileLayout = tileLayout;
			}
			bool flag2 = Constants.FixedTileSize.X > 0;
			if (activeProject.BuildConfiguration.TileWidth != 0 || flag2)
			{
				tileLayout = tileSetConfig.TileLayout;
				if (flag2)
				{
					tileLayout.tileWidth = (uint)Constants.FixedTileSize.X;
					if (Constants.FixedTileSize.X != (int)activeProject.BuildConfiguration.TileWidth && activeProject.BuildConfiguration.TileWidth != 0)
					{
						tileSizeWasOverridden = true;
					}
				}
				else
				{
					tileLayout.tileWidth = activeProject.BuildConfiguration.TileWidth;
				}
				tileSetConfig.TileLayout = tileLayout;
			}
			return tileSetConfig;
		}

		private void UpdateMinMaxSpace(Dictionary<string, DriveSpaceRequirement> dictionary, string key, ulong incrementMin, ulong incrementMax)
		{
			if (dictionary.ContainsKey(key))
			{
				DriveSpaceRequirement value = dictionary[key];
				value.max += incrementMax;
				value.min += incrementMin;
				dictionary[key] = value;
			}
			else
			{
				DriveSpaceRequirement value2 = default(DriveSpaceRequirement);
				value2.min = incrementMin;
				value2.max = incrementMax;
				dictionary.Add(key, value2);
			}
		}

		private void PredictDiskSpace()
		{
			uint tileHeight = tileSetConfig.TileLayout.tileHeight;
			uint tileWidth = tileSetConfig.TileLayout.tileWidth;
			Project activeProject = ProjectBuilder.ActiveProject;
			uint count = (uint)activeProject.LayerConfiguration.Layers.Count;
			ulong num = (tileHeight + 2 * tileSetConfig.TileLayout.borderSize) * (tileWidth + 2 * tileSetConfig.TileLayout.borderSize);
			ulong num2 = 0uL;
			for (int i = 0; i < count; i++)
			{
				ulong num3 = (ulong)DataTypeInfo.GetPixelSize(activeProject.LayerConfiguration.Layers[i].DataType) * num;
				num2 += num3;
			}
			ulong num4 = 0uL;
			foreach (Asset value in ProjectBuilder.ActiveProject.Assets.Values)
			{
				int num5 = ExtraMath.NextPowerOfTwo(value.Width);
				int num6 = ExtraMath.NextPowerOfTwo(value.Height);
				int num7 = ExtraMath.Log2(Math.Max(num5, num6));
				for (int j = 0; j < num7; j++)
				{
					uint num8 = (uint)num5 >> j;
					uint num9 = (uint)num6 >> j;
					uint num10 = Math.Max(1u, num8 / tileWidth);
					uint num11 = Math.Max(1u, num9 / tileHeight);
					num4 += num10 * num11;
				}
			}
			Dictionary<string, DriveSpaceRequirement> dictionary = new Dictionary<string, DriveSpaceRequirement>();
			ulong num12 = num2 * num4;
			string pathRoot = Paths.GetPathRoot(ProjectBuilder.StagingDirectory);
			UpdateMinMaxSpace(dictionary, pathRoot, num12, num12);
			ulong incrementMin = (ulong)((double)num12 * 0.25);
			ulong incrementMax = num12;
			string pathRoot2 = Paths.GetPathRoot(ProjectBuilder.ActiveProject.BuildConfiguration.SoupOutputDirectory);
			UpdateMinMaxSpace(dictionary, pathRoot2, incrementMin, incrementMax);
			ulong num13 = (ulong)((double)num12 * 0.3);
			string pathRoot3 = Paths.GetPathRoot(ProjectBuilder.ActiveProject.BuildConfiguration.OutputDirectory);
			UpdateMinMaxSpace(dictionary, pathRoot3, num13, num13);
			List<DriveLowSpaceInfo> list = new List<DriveLowSpaceInfo>();
			foreach (string key in dictionary.Keys)
			{
				DriveSpaceRequirement driveSpaceRequirement = dictionary[key];
				ulong max = driveSpaceRequirement.max;
				ulong freeBytesAvailable = 0uL;
				DiskManagement.GetFreeDiskSpace(key, ref freeBytesAvailable);
				if (freeBytesAvailable < max)
				{
					DriveLowSpaceInfo item = default(DriveLowSpaceInfo);
					item.min = driveSpaceRequirement.min;
					item.max = driveSpaceRequirement.max;
					item.drive = key;
					item.space = freeBytesAvailable;
					list.Add(item);
				}
			}
			bool flag = false;
			if (list.Count <= 0)
			{
				return;
			}
			string text = string.Empty;
			for (int k = 0; k < list.Count; k++)
			{
				DriveLowSpaceInfo driveLowSpaceInfo = list[k];
				if (driveLowSpaceInfo.min == driveLowSpaceInfo.max)
				{
					flag = true;
					text += $"Drive '{driveLowSpaceInfo.drive}' has {Various.FormatBytes((long)driveLowSpaceInfo.space)} available, requires a minimum of {Various.FormatBytes((long)driveLowSpaceInfo.min)}";
				}
				else if (driveLowSpaceInfo.space < driveLowSpaceInfo.min)
				{
					flag = true;
					text += $"Drive '{driveLowSpaceInfo.drive}' has {Various.FormatBytes((long)driveLowSpaceInfo.space)} available, requires between {Various.FormatBytes((long)driveLowSpaceInfo.min)} and {Various.FormatBytes((long)driveLowSpaceInfo.max)}";
				}
				else if (driveLowSpaceInfo.space < driveLowSpaceInfo.max)
				{
					text += $"Drive '{driveLowSpaceInfo.drive}' has {Various.FormatBytes((long)driveLowSpaceInfo.space)} available, could potentially require between {Various.FormatBytes((long)driveLowSpaceInfo.min)} and {Various.FormatBytes((long)driveLowSpaceInfo.max)}";
				}
				text += ((k != list.Count - 1) ? ", " : string.Empty);
			}
			if (flag)
			{
				string innerMessage = "Not enough free disk space available! Details: " + text;
				ProjectBuilder.BuildReportingHandler.OnError(BuildProcess.TileFilePreprocessor, new DiskSpaceIssue(innerMessage));
			}
			else
			{
				string innerMessage2 = "Potentially not enough free disk space available! Details: " + text;
				ProjectBuilder.BuildReportingHandler.OnWarning(BuildProcess.TileFilePreprocessor, new DiskSpaceIssue(innerMessage2));
			}
		}

		public PipelineProcessResult PostProcess(PipelineProcessResult processResult)
		{
			return PipelineProcessResult.Success;
		}
	}
	internal class BuilderSummary
	{
		public DateTime LastChangedDate { get; set; }

		public bool AutoPageSize { get; set; }

		public int PageSize { get; set; }

		public TargetDisk TargetDisk { get; set; }

		public uint BlockSize { get; set; }

		public string PagesDirectory { get; set; }

		public PagingStrategy PagingStrategy { get; set; }

		public Guid GtsGuid { get; set; }

		public BuilderSummary()
		{
			PagesDirectory = "";
		}
	}
	internal class TileSetBuilderProcess : ITileSetBuilderProcess, IPipelineProcess
	{
		private List<SoupedAsset> newAssets;

		private List<SoupedAsset> changedAssets;

		private List<BuildAsset> deletedAssets;

		private PipelineProcessResult latestResult;

		private string GtsFilename { get; set; }

		private string GtsTempFilename { get; set; }

		public ProjectBuilder ProjectBuilder { get; private set; }

		public PipelineProcessResult LatestResult => latestResult;

		public bool HasRun { get; private set; }

		public DateTime LastRun { get; private set; }

		public TileSetBuilderProcess(ProjectBuilder builder)
		{
			ProjectBuilder = builder;
			newAssets = new List<SoupedAsset>();
			changedAssets = new List<SoupedAsset>();
			deletedAssets = new List<BuildAsset>();
		}

		public PipelineProcessResult PreProcess()
		{
			if (ProjectBuilder.NoGTSBuilding)
			{
				return PipelineProcessResult.Success;
			}
			Project activeProject = ProjectBuilder.ActiveProject;
			string pagesDirectory = ProjectBuilder.ActiveProject.BuildConfiguration.PagesDirectory;
			if (pagesDirectory != null && pagesDirectory.Length != 0 && (pagesDirectory.IndexOfAny(new char[2] { '.', ':' }) != -1 || pagesDirectory[0] == '\\' || pagesDirectory[0] == '/'))
			{
				string innerMessage = "Invalid pages directory, make sure the pages directory is a relative path to a folder residing in the GTS output file folder, and does not start with '.\\' or './'. For example, use paths such as \"pages\" or \"SomeDir/SomeOtherDir\". Please change the pages directory and build your project";
				ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileSetBuilder, new TileSetBuilderIssue(innerMessage));
				latestResult = PipelineProcessResult.Failed;
				return latestResult;
			}
			string text = Path.Combine(new string[3]
			{
				ProjectBuilder.StagingConfigurationDirectory,
				Constants.StageDirName,
				ProjectBuilder.ActiveProject.Name
			});
			if (!DeleteIntermediateFiles())
			{
				string innerMessage2 = "Unable to clean old leftover files from the temporary GTS staging directory \"" + text + "\", please check the permissions on the directory and make sure no other process is using that directory";
				ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileSetBuilder, new TileSetBuilderIssue(innerMessage2));
				latestResult = PipelineProcessResult.Failed;
				return latestResult;
			}
			try
			{
				if (!Directory.Exists(text))
				{
					Directory.CreateDirectory(text);
				}
			}
			catch (Exception ex)
			{
				string innerMessage3 = "Unable to create staging directory, please make sure access to \"" + text + "\" is granted. Detailed error: '" + ex.Message + "'";
				ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileSetBuilder, new TileSetBuilderIssue(innerMessage3));
				latestResult = PipelineProcessResult.Failed;
				return latestResult;
			}
			GtsFilename = "";
			try
			{
				GtsFilename = activeProject.BuildConfiguration.GetGtsFileName();
				if (!Directory.Exists(activeProject.BuildConfiguration.OutputDirectory))
				{
					Directory.CreateDirectory(activeProject.BuildConfiguration.OutputDirectory);
				}
			}
			catch (Exception ex2)
			{
				string innerMessage4 = "Unable to create or open the output directory '" + activeProject.BuildConfiguration.OutputDirectory + "'. Detailed error: '" + ex2.Message + "', please update the output directory and build your project";
				ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileSetBuilder, new TileSetBuilderIssue(innerMessage4));
				latestResult = PipelineProcessResult.Failed;
				return latestResult;
			}
			GtsTempFilename = Path.Combine(text, activeProject.BuildConfiguration.OutputFilename);
			string text2 = Path.Combine(text, pagesDirectory);
			if (pagesDirectory.Length != 0 && !Directory.Exists(text2))
			{
				try
				{
					Directory.CreateDirectory(text2);
				}
				catch (Exception ex3)
				{
					string innerMessage5 = "Unable to create the temporary pages directory: '" + text2 + "'. Detailed error: '" + ex3.Message + "', please update the pages directory and build your project";
					ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileSetBuilder, new TileSetBuilderIssue(innerMessage5));
					latestResult = PipelineProcessResult.Failed;
					return latestResult;
				}
			}
			string text3 = Path.Combine(ProjectBuilder.ActiveProject.BuildConfiguration.OutputDirectory, pagesDirectory);
			if (pagesDirectory.Length != 0 && !Directory.Exists(text3))
			{
				try
				{
					Directory.CreateDirectory(text3);
				}
				catch (Exception ex4)
				{
					string innerMessage6 = "Unable to create the output pages directory: '" + text3 + "'. Detailed error: '" + ex4.Message + "', please update the pages directory and build your project";
					ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileSetBuilder, new TileSetBuilderIssue(innerMessage6));
					latestResult = PipelineProcessResult.Failed;
					return latestResult;
				}
			}
			PagingStrategy pagingStrategy = ProfileLoader.ResolvePagingStrategy(ProjectBuilder.ActiveProject.BuildConfiguration.PagingStrategy, ProjectBuilder.ActiveProject.BuildProfile);
			if (!ProfileLoader.IsValidPagingStrategy(pagingStrategy, ProjectBuilder.ActiveProject.BuildProfile))
			{
				string innerMessage7 = string.Concat("Paging strategy '", pagingStrategy, "' is unavailable in current build profile. Please select a different paging strategy.");
				ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileSetBuilder, new TileSetBuilderIssue(innerMessage7));
				latestResult = PipelineProcessResult.Failed;
				return latestResult;
			}
			return PipelineProcessResult.Success;
		}

		public PipelineProcessResult Process()
		{
			ProjectBuilder.ProgressTracker.StartTask(SlowTask.TileFileBuildProcess);
			if (!ProjectBuilder.NoGTSBuilding)
			{
				_ = ProjectBuilder.ActiveProject;
				DateTime now = DateTime.Now;
				ProjectBuilder.logger.LogTitle("Building GTS file...", Logger.Verbosity.Normal);
				if (!Build())
				{
					latestResult = PipelineProcessResult.Failed;
					return latestResult;
				}
				ProjectBuilder.State.Update(AssetChangeType.MetaData);
				LastRun = DateTimeManagement.Now();
				HasRun = true;
				if (ProjectBuilder.ProfilingEnabled)
				{
					double num = Math.Truncate((DateTime.Now - now).TotalMilliseconds) / 1000.0;
					ProjectBuilder.logger.LogConsole("Done, elapsed time: " + num + " s", Logger.Verbosity.Quiet);
				}
			}
			latestResult = PipelineProcessResult.Success;
			ProjectBuilder.ProgressTracker.EndTask(SlowTask.TileFileBuildProcess);
			return latestResult;
		}

		public PipelineProcessResult PostProcess(PipelineProcessResult processResult)
		{
			return PipelineProcessResult.Success;
		}

		private bool Build()
		{
			_ = ProjectBuilder.ActiveProject;
			bool checkGTSBuildMode = true;
			if (ProjectBuilder.State.BuildRequired(checkGTSBuildMode, ProjectBuilder.ActiveBuildingMode, out var _))
			{
				try
				{
					return BuildGts();
				}
				catch (Exception ex)
				{
					string innerMessage = "Unable to build tile set file '" + GtsFilename + "', detailed error: '" + ex.Message + "', please make sure the file isn't locked and then build your project";
					ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileSetBuilder, new TileSetBuilderIssue(innerMessage));
					return false;
				}
			}
			return true;
		}

		private bool GetSoupFileDescriptor(Asset asset, out SoupFileDescriptor desc)
		{
			desc = new SoupFileDescriptor();
			string soupFilePath = BuildState.GetSoupFilePath(ProjectBuilder.ActiveProject, asset);
			if (!File.Exists(soupFilePath))
			{
				return false;
			}
			desc.SoupFilename = soupFilePath;
			return true;
		}

		private List<SoupFileDescriptor> GetSoupFileDescriptors()
		{
			List<SoupFileDescriptor> list = new List<SoupFileDescriptor>();
			foreach (Asset value in ProjectBuilder.ActiveProject.Assets.Values)
			{
				if (AssetTools.IsRootAsset(ProjectBuilder.ActiveProject, value))
				{
					if (GetSoupFileDescriptor(value, out var desc))
					{
						list.Add(desc);
						continue;
					}
					string innerMessage = "Failed to find GTEX for asset '" + value.Name + "'.";
					ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileSetBuilder, new TileSetBuilderIssue(innerMessage));
				}
			}
			return list;
		}

		private bool BuildGts()
		{
			List<SoupFileDescriptor> soupFileDescriptors = GetSoupFileDescriptors();
			SoupCollectionInfo soupCollectionInfo = new SoupCollectionInfo();
			soupCollectionInfo.Collect(ProjectBuilder, soupFileDescriptors);
			if (!SoupFileAtlasser.Atlas(new Int2((int)soupCollectionInfo.TileDim.width, (int)soupCollectionInfo.TileDim.height), soupCollectionInfo.SoupFileInfos, out var packedAssets, out var packedSize))
			{
				string innerMessage = "Failed to atlas soup files.";
				ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileSetBuilder, new TileSetBuilderIssue(innerMessage));
				return false;
			}
			if (packedAssets.Count == 0)
			{
				string innerMessage2 = "No soup files were found in the atlas.";
				ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileSetBuilder, new TileSetBuilderIssue(innerMessage2));
				return false;
			}
			if (ITileFileFactory.CreateTileSoupCollection(out var soupFileCollection) != 0)
			{
				ITileFileFactory.GetLastError(out var errorInfo);
				string buildErrorMessage = Errors.GetBuildErrorMessage(errorInfo);
				ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileSetBuilder, new TileSetBuilderIssue(buildErrorMessage));
				return false;
			}
			foreach (PackedSoupFileInfo item in packedAssets)
			{
				PackedSoupFile psf = NixelTools.CreatePackedSoupFile(ProjectBuilder, item);
				soupFileCollection.Add(psf);
			}
			string rasterFileName = NixelContextManager.GetRasterFileName(ProjectBuilder, Constants.SharedMipRasterFilename);
			string rasterFileIndexName = NixelContextManager.GetRasterFileIndexName(rasterFileName);
			if (File.Exists(rasterFileName) && !Paths.DeleteFile(rasterFileName))
			{
				string innerMessage3 = $"File '{rasterFileName}' is locked. Build cannot proceed. Please make sure this file can be accessed by the builder.";
				ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileSetBuilder, new TileSetBuilderIssue(innerMessage3));
				return false;
			}
			if (File.Exists(rasterFileIndexName) && !Paths.DeleteFile(rasterFileIndexName))
			{
				string innerMessage4 = $"File '{rasterFileIndexName}' is locked. Build cannot proceed. Please make sure this file can be accessed by the builder.";
				ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileSetBuilder, new TileSetBuilderIssue(innerMessage4));
				return false;
			}
			RebuilderSettings rebuilderSettings = default(RebuilderSettings);
			rebuilderSettings.gtsFilename = GtsTempFilename;
			rebuilderSettings.pagesDirectoryPath = ProjectBuilder.ActiveProject.BuildConfiguration.PagesDirectory;
			rebuilderSettings.sharedMipRasterFilename = rasterFileName;
			rebuilderSettings.useRedirection = ProjectBuilder.EnableRedirection;
			rebuilderSettings.useMipStripping = ProjectBuilder.EnableMipStripping;
			rebuilderSettings.buildGTSForGTex = ProjectBuilder.ActiveBuildingMode == BuildMode.BuildForGTex;
			ITileSetRebuilder tileSetRebuilder;
			Nixel.Error error = ITileFileFactory.CreateTileSetRebuilder(out tileSetRebuilder);
			if (error != 0)
			{
				ITileFileFactory.GetLastError(out var errorInfo2);
				string buildErrorMessage2 = Errors.GetBuildErrorMessage(errorInfo2);
				ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileSetBuilder, new TileSetBuilderIssue(buildErrorMessage2));
				return false;
			}
			try
			{
				byte[] array = soupCollectionInfo.BuildMetadata(ProjectBuilder, packedAssets);
				GCHandle gCHandle = GCHandle.Alloc(array, GCHandleType.Pinned);
				tileSetRebuilder.SetMetaData(gCHandle.AddrOfPinnedObject(), (uint)array.Length);
				gCHandle.Free();
			}
			catch
			{
				string innerMessage5 = "Error creating metadata. Something went wrong. Cube map face count != 6?";
				ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileSetBuilder, new TileSetBuilderIssue(innerMessage5));
				return false;
			}
			TileSetConfig tileSetConfig = NixelContextManager.CreateTileSetConfig(ProjectBuilder);
			RasterTileDimension dimensions = default(RasterTileDimension);
			TiledTopology tiledTopology = NixelContextManager.CreateTiledTopology(ProjectBuilder, tileSetConfig.TileLayout, packedSize.X, packedSize.Y, out dimensions);
			ITiledBuildParameters tiledBuildParameters = null;
			if (ProjectBuilder.EnableSharedMipGeneration)
			{
				ITileFileFactory.CreateTiledBuildParameters(tiledTopology, out tiledBuildParameters);
				int count = ProjectBuilder.ActiveProject.LayerConfiguration.Layers.Count;
				CodingGroupManager[] array2 = new CodingGroupManager[count];
				for (int i = 0; i < count; i++)
				{
					LayerDescription layerDescription = ProjectBuilder.ActiveProject.LayerConfiguration.Layers[i];
					ProfileLoader.LoadCodingProfile(layerDescription.CodingProfile, out var profile);
					array2[i] = new CodingGroupManager(i, layerDescription.DataType, profile);
					array2[i].AddCodingGroup(layerDescription.QualityProfile);
					array2[i].RegisterCodingGroups(tiledBuildParameters);
				}
			}
			uint pageSize = ProjectBuilder.ActiveProject.BuildConfiguration.PageSize;
			uint blockSize = ProjectBuilder.ActiveProject.BuildConfiguration.BlockSize;
			uint targetDisk = (uint)ProjectBuilder.ActiveProject.BuildConfiguration.TargetDisk;
			using (TileSetBuilderProgressTracker buildProgressTracker = new TileSetBuilderProgressTracker(ProjectBuilder.ProgressTracker, ProjectBuilder.logger))
			{
				tileSetRebuilder.SetBuildProgressTracker(buildProgressTracker);
				PagingSettings pagingSettings = default(PagingSettings);
				pagingSettings.autoPagesize = pageSize == 0;
				pagingSettings.blockSize = blockSize;
				pagingSettings.pagesize = pageSize;
				pagingSettings.targetDisk = targetDisk;
				pagingSettings.pagingStrategy = (int)ProfileLoader.ResolvePagingStrategy(ProjectBuilder.ActiveProject.BuildConfiguration.PagingStrategy, ProjectBuilder.ActiveProject.BuildProfile);
				error = tileSetRebuilder.Begin(rebuilderSettings);
				if (error != 0)
				{
					ITileFileFactory.GetLastError(out var errorInfo3);
					string buildErrorMessage3 = Errors.GetBuildErrorMessage(errorInfo3);
					ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileSetBuilder, new TileSetBuilderIssue(buildErrorMessage3));
					return false;
				}
				error = tileSetRebuilder.Rebuild(rebuilderSettings, pagingSettings, soupFileCollection, tiledBuildParameters);
			}
			if (error != 0)
			{
				ITileFileFactory.GetLastError(out var errorInfo4);
				string buildErrorMessage4 = Errors.GetBuildErrorMessage(errorInfo4);
				ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileSetBuilder, new TileSetBuilderIssue(buildErrorMessage4));
				return false;
			}
			tileSetRebuilder.GetBuildReport(out var report);
			ulong num = report.slack / 1024uL;
			ulong num2 = 0uL;
			if (report.numPages != 0 && report.pageSize != 0)
			{
				num2 = report.slack * 100 / (ulong)((long)report.numPages * (long)report.pageSize);
			}
			ProjectBuilder.logger.LogMessage("GTS GUID: " + ((Guid)report.guid).ToString(), Logger.Verbosity.Normal);
			ProjectBuilder.logger.LogMessage("Page size: " + report.pageSize, Logger.Verbosity.Normal);
			ProjectBuilder.logger.LogMessage("Page file count: " + report.numPageFiles, Logger.Verbosity.Normal);
			ProjectBuilder.logger.LogMessage("Slack: " + num.ToString() + " KiB (" + num2 + "%)", Logger.Verbosity.Normal);
			BuilderSummary builderSummary = new BuilderSummary();
			builderSummary.AutoPageSize = pageSize == 0;
			builderSummary.PageSize = (int)report.pageSize;
			builderSummary.PagingStrategy = ProfileLoader.ResolvePagingStrategy(ProjectBuilder.ActiveProject.BuildConfiguration.PagingStrategy, ProjectBuilder.ActiveProject.BuildProfile);
			builderSummary.PagesDirectory = ProjectBuilder.ActiveProject.BuildConfiguration.PagesDirectory;
			builderSummary.BlockSize = ProjectBuilder.ActiveProject.BuildConfiguration.BlockSize;
			builderSummary.GtsGuid = report.guid;
			builderSummary.TargetDisk = ProjectBuilder.ActiveProject.BuildConfiguration.TargetDisk;
			try
			{
				builderSummary.LastChangedDate = DateTimeManagement.Round(File.GetLastWriteTime(GtsTempFilename));
			}
			catch (Exception ex)
			{
				string innerMessage6 = "Unable to read tile set file after it has been built, detailed error: '" + ex.Message + "', please build your project";
				ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileSetBuilder, new TileSetBuilderIssue(innerMessage6));
				return false;
			}
			try
			{
				GTSBuilderTools.MoveGTS(GtsTempFilename, GtsFilename, !ProjectBuilder.NoPatching);
			}
			catch (GtsMoveException ex2)
			{
				ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileSetBuilder, new TileSetBuilderIssue(ex2.Message));
				return false;
			}
			Paths.DeleteFile(rasterFileName);
			Paths.DeleteFile(rasterFileIndexName);
			ProjectBuilder.State.BuilderSummary = builderSummary;
			UpdateStateBuildAssets(packedAssets, builderSummary.LastChangedDate);
			soupFileCollection.Dispose();
			tileSetRebuilder.Dispose();
			return true;
		}

		private void UpdateStateBuildAssets(List<PackedSoupFileInfo> packedSoupFiles, DateTime buildTime)
		{
			ProjectBuilder.State.BuildAssets.Clear();
			foreach (PackedSoupFileInfo packedSoupFile in packedSoupFiles)
			{
				if (packedSoupFile.SoupFileInfo.SoupState == null)
				{
					continue;
				}
				foreach (SoupedAsset value in packedSoupFile.SoupFileInfo.SoupState.SoupedAssets.Values)
				{
					BuildAsset buildAsset = new BuildAsset();
					buildAsset.AssetId = value.AssetId;
					buildAsset.BuildDate = buildTime;
					buildAsset.Height = value.Height;
					buildAsset.Width = value.Width;
					buildAsset.X = value.X;
					buildAsset.Y = value.Y;
					buildAsset.GTexLastChangeDate = value.SoupedDate;
					ProjectBuilder.State.BuildAssets.Add(buildAsset.AssetId, buildAsset);
				}
			}
		}

		public bool DeleteIntermediateFiles()
		{
			bool flag = true;
			string text = Path.Combine(new string[3]
			{
				ProjectBuilder.StagingConfigurationDirectory,
				Constants.StageDirName,
				ProjectBuilder.ActiveProject.Name
			});
			try
			{
				if (Directory.Exists(text))
				{
					Paths.DeleteDirectory(text, recursive: true);
				}
			}
			catch
			{
				flag = false;
			}
			if (!flag)
			{
				string innerMessage = "Unable to delete the temporary builder staging directory \"" + text + "\", make sure the folder isn't locked or being used by another process, then rebuild the project.";
				ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileSetBuilder, new GeneralIssue(innerMessage));
			}
			return flag;
		}

		public bool DeleteOutputFiles()
		{
			bool flag = true;
			Project activeProject = ProjectBuilder.ActiveProject;
			string gtsFileName = activeProject.BuildConfiguration.GetGtsFileName();
			if (File.Exists(gtsFileName))
			{
				if (GTSBuilderTools.GetGTPFiles(gtsFileName, out var gtpFilenames, out var gtsType))
				{
					if (gtsType == TileFileType.GTS_WITH_GTP)
					{
						foreach (string item in gtpFilenames)
						{
							string path = Path.Combine(Path.GetFullPath(activeProject.BuildConfiguration.OutputDirectory), item);
							if (File.Exists(path))
							{
								try
								{
									File.Delete(path);
								}
								catch
								{
									flag = false;
								}
							}
						}
					}
				}
				else
				{
					flag = false;
				}
				if (flag)
				{
					try
					{
						File.Delete(gtsFileName);
					}
					catch
					{
						flag = false;
					}
				}
			}
			if (!flag)
			{
				string innerMessage = "Unable to delete alle tile set files for tile set \"" + gtsFileName + "\", make sure the files aren't locked or being used by another process.";
				ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileSetBuilder, new GeneralIssue(innerMessage));
			}
			return flag;
		}

		public bool DeleteSerializedFiles()
		{
			if (!DeleteIntermediateFiles())
			{
				return false;
			}
			if (!DeleteOutputFiles())
			{
				return false;
			}
			return true;
		}
	}
	internal class TileSetBuilderProgressTracker : IBuildProgressTracker
	{
		private int tileCount;

		private int progressPercent;

		private ProgressTracker<SlowTask> tracker;

		private Logger logger;

		public TileSetBuilderProgressTracker(ProgressTracker<SlowTask> tracker, Logger logger)
		{
			tileCount = 0;
			progressPercent = 0;
			this.tracker = tracker;
			this.logger = logger;
		}

		public override void ProcessedTile(LayerTileId tid, uint tileCountInPass)
		{
			tileCount++;
			double d = (double)tileCount * 100.0 / (double)tileCountInPass;
			if (Math.Floor(d) > (double)progressPercent)
			{
				progressPercent = (int)Math.Floor(d);
				logger.PrintProgress(progressPercent + "%", tileCount == tileCountInPass, Logger.Verbosity.Normal);
				tracker.UpdateProgress(1L, tileCountInPass, tileCount);
			}
		}

		public override void StartingPass(BuildPass buildPass)
		{
			if (buildPass == BuildPass.SharedMipMipMapping)
			{
				logger.LogMessage("Building shared mip data...", Logger.Verbosity.Normal);
			}
			if (buildPass == BuildPass.WriteEncode)
			{
				logger.LogMessage("Writing tile set files...", Logger.Verbosity.Normal);
			}
			if (buildPass == BuildPass.FinishPaging)
			{
				logger.LogMessage("Finishing writing gtp files...", Logger.Verbosity.Normal);
			}
			if (buildPass == BuildPass.RedirectionMappingSetup)
			{
				logger.LogMessage("Setting up redirection map...", Logger.Verbosity.Detailed);
			}
			if (buildPass == BuildPass.RedirectionMapping)
			{
				logger.LogMessage("Building redirection map...", Logger.Verbosity.Detailed);
			}
		}
	}
	internal class SoupFileDescriptor
	{
		public string SoupFilename { get; set; }
	}
	internal class SoupBuilderSummary
	{
		public DateTime LastChangedDate { get; set; }

		public Guid SoupId { get; set; }
	}
	internal enum SoupBuildType
	{
		NoBuild,
		FullBuild,
		IncrementalBuild
	}
	internal class TileSoupBuilder
	{
		private PipelineProcessResult latestResult;

		public ProjectBuilder ProjectBuilder { get; private set; }

		private static CodingProfile[] CodingProfiles { get; set; }

		public PipelineProcessResult LatestResult => latestResult;

		public bool HasRun { get; private set; }

		public DateTime LastRun { get; private set; }

		public TileSoupBuilder(ProjectBuilder builder)
		{
			ProjectBuilder = builder;
		}

		private bool PreProcessAsset(Asset a)
		{
			Project activeProject = ProjectBuilder.ActiveProject;
			if (activeProject.LayerConfiguration == null || activeProject.LayerConfiguration.Layers.Count == 0)
			{
				return true;
			}
			int count = activeProject.LayerConfiguration.Layers.Count;
			CodingProfiles = new CodingProfile[count];
			for (int i = 0; i < count; i++)
			{
				LayerDescription layerDescription = activeProject.LayerConfiguration.Layers[i];
				string text = ProjectBuilder.ActiveProject.LayerConfiguration.Layers[i].CodingProfile;
				if (string.IsNullOrEmpty(text))
				{
					ProfileLoader.LoadBuildProfile(ProjectBuilder.ActiveProject.BuildProfile, out var profile);
					text = (layerDescription.CodingProfile = profile.DefaultCodingProfiles[layerDescription.DataType]);
				}
				if (ProfileLoader.LoadCodingProfile(text, out var profile2) != 0)
				{
					string innerMessage = "Unable to load coding profile, detailed error: '" + ProfileLoader.LastError + "', please choose one of the included coding profiles";
					ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.Coder, new CoderCodingProfileIssue(text, innerMessage));
					return false;
				}
				CodingProfiles[i] = profile2;
			}
			return true;
		}

		public bool ProcessAsset(Asset asset, TileSoupBuilderProgressTracker tracker, NixelContextManager nixelContextManager)
		{
			if (!PreProcessAsset(asset))
			{
				return false;
			}
			if (ProjectBuilder.ActiveProject.LayerConfiguration == null)
			{
				return false;
			}
			if (AssetTools.IsRootAsset(ProjectBuilder.ActiveProject, asset) && !ProjectBuilder.Canceled && !BuildSoup(asset, tracker, nixelContextManager))
			{
				return false;
			}
			return true;
		}

		private bool BuildSoup(Asset asset, TileSoupBuilderProgressTracker tracker, NixelContextManager nixelContextManager)
		{
			if (asset == null)
			{
				return true;
			}
			if (ProjectBuilder.ActiveProject.ImportSummary.FailedAssetUpdates.FindAll((Asset x) => x.Id.Equals(asset.Id)).Count != 0)
			{
				return true;
			}
			NixelContext context = nixelContextManager.GetContext(asset.Id);
			if (context == null)
			{
				return true;
			}
			if (context.TiledTopology.numLevels == 0)
			{
				string innerMessage = "No topology set";
				ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileSoupBuilder, new TileSoupBuilderIssue(asset.Name, innerMessage));
				return false;
			}
			if (context.TileDimensions.height == 0)
			{
				string innerMessage2 = "No tile dimensions set";
				ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileSoupBuilder, new TileSoupBuilderIssue(asset.Name, innerMessage2));
				return false;
			}
			if (context.TiledRasterData == null)
			{
				string innerMessage3 = "No data to code";
				ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileSoupBuilder, new TileSoupBuilderIssue(asset.Name, innerMessage3));
				return false;
			}
			int count = ProjectBuilder.ActiveProject.LayerConfiguration.Layers.Count;
			int i = 0;
			try
			{
				ProjectBuilder.State.LayerFixedTexFormats = new FixedTexFormat[count];
				ProjectBuilder.logger.LogMessage("Quality levels:", Logger.Verbosity.Detailed);
				for (i = 0; i < count; i++)
				{
					ProjectBuilder.ActiveProject.LayerConfiguration.Layers[i].QualityProfile.ToLowerInvariant();
					CodingProfile codingProfile = CodingProfiles[i];
					SetCodingConfigs(context, ProjectBuilder.ActiveProject.LayerConfiguration, asset, i, codingProfile, out var layerFixedTexFormat, out var resetToDefault);
					if (resetToDefault)
					{
						AssetLayer assetLayer = asset.AssetLayers[i];
						DataType dataType = ProjectBuilder.ActiveProject.LayerConfiguration.Layers[i].DataType;
						string innerMessage4 = $"The quality profile '{assetLayer.QualityProfile.ToString()}' for asset '{asset.Name}' on layer '{i}' is not available for data type '{dataType.ToString()}' in the coding profile '{CodingProfiles[i].Name}'. Please change the quality profile or select a compatible coding profile. The quality profile will be set to 'default' and building will continue.";
						if (ProjectBuilder.BuildReportingHandler.OnError(BuildProcess.Coder, new CoderIssue(innerMessage4)) == ErrorAction.Stop)
						{
							throw new IncompatibleQualityProfileException();
						}
					}
					if (layerFixedTexFormat == FixedTexFormat.Invalid)
					{
						string innerMessage5 = "Internal error: Invalid fixed tex format";
						ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileSoupBuilder, new TileSoupBuilderIssue(asset.Name, innerMessage5));
						throw new FatalException();
					}
					ProjectBuilder.State.LayerFixedTexFormats[i] = layerFixedTexFormat;
				}
			}
			catch (FatalException)
			{
				return false;
			}
			catch (IncompatibleQualityProfileException)
			{
				AssetLayer assetLayer2 = asset.AssetLayers[i];
				DataType dataType2 = ProjectBuilder.ActiveProject.LayerConfiguration.Layers[i].DataType;
				string innerMessage6 = $"The quality profile '{assetLayer2.QualityProfile.ToString()}' for asset '{asset.Name}' on layer '{i}' is not available for data type '{dataType2.ToString()}' in the coding profile '{CodingProfiles[i].Name}'. Please change the quality profile or select a compatible coding profile. The quality profile will be set to 'default' and building will continue.";
				ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.Coder, new CoderIssue(innerMessage6));
				return false;
			}
			catch (GrBuildException ex3)
			{
				ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.Coder, new CoderIssue(ex3.Message));
				return false;
			}
			List<int> identicalLayers;
			switch (GetSoupBuildTypeRequired(asset, ProjectBuilder, out identicalLayers))
			{
			case SoupBuildType.NoBuild:
				ProjectBuilder.logger.LogMessage("No changes to encode.", Logger.Verbosity.Detailed);
				return true;
			case SoupBuildType.FullBuild:
				return IncrementalBuildSoup(context, asset, tracker, incremental: false, null);
			case SoupBuildType.IncrementalBuild:
				return IncrementalBuildSoup(context, asset, tracker, incremental: true, identicalLayers);
			default:
				return false;
			}
		}

		internal static SoupBuildType GetSoupBuildTypeRequired(Asset asset, ProjectBuilder builder, out List<int> identicalLayers)
		{
			identicalLayers = new List<int>();
			if (asset == null)
			{
				return SoupBuildType.NoBuild;
			}
			_ = builder.ActiveProject;
			if (builder.State.CodeRequired(asset))
			{
				if (!builder.NoPatching && builder.State.PartialCodingPossible(asset, out identicalLayers))
				{
					if (identicalLayers.Count > 0)
					{
						return SoupBuildType.IncrementalBuild;
					}
					return SoupBuildType.FullBuild;
				}
				return SoupBuildType.FullBuild;
			}
			return SoupBuildType.NoBuild;
		}

		private bool IncrementalBuildSoup(NixelContext nixelContext, Asset asset, TileSoupBuilderProgressTracker tracker, bool incremental, List<int> layersToCopy)
		{
			Project activeProject = ProjectBuilder.ActiveProject;
			if (asset == null)
			{
				throw new AssetNotFoundException(asset.Id);
			}
			ProjectBuilder.logger.LogMessage("Full code required", Logger.Verbosity.Detailed);
			string soupOutputDirectory = activeProject.BuildConfiguration.SoupOutputDirectory;
			string soupDirectory = BuildState.GetSoupDirectory(activeProject, asset);
			string soupStagingDirectory = BuildState.GetSoupStagingDirectory(ProjectBuilder, asset);
			try
			{
				if (!Directory.Exists(soupDirectory))
				{
					Directory.CreateDirectory(soupDirectory);
				}
			}
			catch (Exception ex)
			{
				string innerMessage = "Error creating gtex directory '" + soupDirectory + "', detailed message: '" + ex.Message + "' make sure access is granted to '" + soupOutputDirectory + "' and this project isn't used in another process";
				ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileSoupBuilder, new TileSoupBuilderIssue(asset.Name, innerMessage));
				return false;
			}
			try
			{
				if (!Directory.Exists(soupStagingDirectory))
				{
					Directory.CreateDirectory(soupStagingDirectory);
				}
			}
			catch (Exception ex2)
			{
				string innerMessage2 = "Error creating gtex staging directory '" + soupStagingDirectory + "', detailed message: '" + ex2.Message + "' make sure access is granted to '" + soupStagingDirectory + "' and this project isn't used in another process";
				ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileSoupBuilder, new TileSoupBuilderIssue(asset.Name, innerMessage2));
				return false;
			}
			string soupStagingFileName = BuildState.GetSoupStagingFileName(ProjectBuilder, asset);
			string soupFilePath = BuildState.GetSoupFilePath(activeProject, asset);
			bool flag = File.Exists(soupFilePath);
			if (incremental && !flag)
			{
				incremental = false;
			}
			if (!incremental)
			{
				DeleteStagingSoupFile(ProjectBuilder, asset);
				if (!DeleteSoupFile(ProjectBuilder, asset))
				{
					return false;
				}
			}
			bool enableUniformCoding = ProjectBuilder.EnableUniformCoding;
			BuildHeader buildHeader = default(BuildHeader);
			buildHeader.guid = GraphineGuid.NewGuid();
			for (int i = 0; i < activeProject.LayerConfiguration.Layers.Count; i++)
			{
				ProfileLoader.LoadCodingProfile(activeProject.LayerConfiguration.Layers[i].CodingProfile, out var profile);
				bool enable = enableUniformCoding && profile.UniformCodecAvailable;
				NixelContextManager.EnableUniformCoding(nixelContext, i, enable);
			}
			ITileSoupBuilder tileSoupBuilder;
			Nixel.Error error = ITileFileFactory.CreateTileSoupBuilder(nixelContext.TiledRasterData, nixelContext.TiledBuildParameters, buildHeader, out tileSoupBuilder);
			if (error != 0)
			{
				ITileFileFactory.GetLastError(out var errorInfo);
				string buildErrorMessage = Errors.GetBuildErrorMessage(errorInfo);
				ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileSoupBuilder, new TileSoupBuilderCodeIssue(asset.Name, buildErrorMessage));
				return false;
			}
			ILayerIndexCollection outLayerIndexCollection = null;
			if (incremental)
			{
				error = ITileFileFactory.CreateLayerIndexCollection(out outLayerIndexCollection);
				if (error != 0)
				{
					ITileFileFactory.GetLastError(out var errorInfo2);
					string buildErrorMessage2 = Errors.GetBuildErrorMessage(errorInfo2);
					ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileSetBuilder, new TileSetBuilderIssue(buildErrorMessage2));
					return false;
				}
				foreach (int item in layersToCopy)
				{
					outLayerIndexCollection.Add(item);
				}
			}
			BuildState.SoupState soupState = ProjectBuilder.State.FindAssetSoupState(asset.Id);
			if (soupState == null)
			{
				soupState = ProjectBuilder.State.CreateAssetSoupState(activeProject, asset.Id);
			}
			soupState.LayerConfig = activeProject.LayerConfiguration;
			soupState.TileLayout = new TileLayout(activeProject.BuildConfiguration.TileWidth, activeProject.BuildConfiguration.TileHeight, activeProject.BuildConfiguration.MaximumAnisotropy);
			soupState.SoupedAssets.Clear();
			soupState.Assets.Clear();
			BuildState.CompositeState compositeState = ProjectBuilder.State.FindAssetCompositeState(asset.Id);
			if (compositeState != null)
			{
				foreach (CompositedAsset composited in compositeState.CompositedList)
				{
					SoupedAsset soupedAsset = new SoupedAsset();
					UpdateSoupedAsset(composited, ref soupedAsset);
					soupState.SoupedAssets.Add(soupedAsset.AssetId, soupedAsset);
					soupState.Assets.Add(soupedAsset.AssetId, activeProject.Assets[soupedAsset.AssetId]);
				}
			}
			SoupBuilderSummary soupBuilderSummary = new SoupBuilderSummary();
			soupBuilderSummary.LastChangedDate = DateTimeManagement.Now();
			soupState.SoupBuilderSummary = soupBuilderSummary;
			if (!SetMetaData(nixelContext, asset))
			{
				return false;
			}
			foreach (SoupedAsset value in soupState.SoupedAssets.Values)
			{
				GenerateThumbnails(value, nixelContext);
			}
			using (CodecLogger codecLogger = new CodecLogger())
			{
				using BuildCallback buildCallback = new BuildCallback(codecLogger, ProjectBuilder.logger, ProjectBuilder);
				tileSoupBuilder.SetBuildProgressTracker(tracker);
				tileSoupBuilder.SetCodecLogger(codecLogger);
				tileSoupBuilder.SetBuildCallback(buildCallback);
				SoupBuilderSettings soupBuilderSettings = default(SoupBuilderSettings);
				if (incremental)
				{
					soupBuilderSettings.soupFilename = soupStagingFileName + "_patched";
					soupBuilderSettings.patchMode = true;
					soupBuilderSettings.soupPatchSourceFilename = soupFilePath;
				}
				else
				{
					soupBuilderSettings.soupFilename = soupStagingFileName;
					soupBuilderSettings.patchMode = false;
				}
				error = tileSoupBuilder.Build(soupBuilderSettings, NixelContextManager.BuildMode, outLayerIndexCollection);
			}
			if (error != 0)
			{
				ITileFileFactory.GetLastError(out var errorInfo3);
				string buildErrorMessage3 = Errors.GetBuildErrorMessage(errorInfo3);
				ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileSoupBuilder, new TileSoupBuilderCodeIssue(asset.Name, buildErrorMessage3));
				DeleteSoupFile(ProjectBuilder, soupStagingFileName);
				return false;
			}
			tileSoupBuilder.Dispose();
			outLayerIndexCollection?.Dispose();
			string source = soupStagingFileName;
			string destination = soupFilePath;
			if (incremental)
			{
				source = soupStagingFileName + "_patched";
			}
			if (!FileTools.MoveFile(source, destination))
			{
				string innerMessage3 = "Failed to move '" + soupStagingFileName + "' to '" + soupFilePath + "'. Make sure the file isn't locked or being used by another process, then rebuild the project.";
				ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileSoupBuilder, new GeneralIssue(innerMessage3));
			}
			return true;
		}

		private void SetCodingConfigs(NixelContext ncontext, LayerConfig layerConfig, Asset asset, int layer, CodingProfile codingProfile, out FixedTexFormat layerFixedTexFormat, out bool resetToDefault)
		{
			resetToDefault = false;
			NixelContextManager.CreateTiledBuildParameters(ncontext);
			string text = GetCorrectQualityLevelForAsset(asset, layer);
			DataType dataType = layerConfig.Layers[layer].DataType;
			CodingGroupManager codingGroupManager = new CodingGroupManager(layer, dataType, codingProfile);
			if (string.IsNullOrEmpty(text) || text.ToLowerInvariant() == "default")
			{
				text = ProjectBuilder.ActiveProject.LayerConfiguration.Layers[layer].QualityProfile.ToLowerInvariant();
			}
			if (text.ToLowerInvariant() == "default")
			{
				foreach (DefaultQualitySetting defaultQualitySetting in codingProfile.DefaultQualitySettings)
				{
					if (defaultQualitySetting.DataTypes.Contains(layerConfig.Layers[layer].DataType))
					{
						text = defaultQualitySetting.QualityProfile;
					}
				}
			}
			if (!ProfileLoader.IsValidQualityProfile(text, codingProfile, dataType))
			{
				text = "default";
				resetToDefault = true;
			}
			ProjectBuilder.logger.LogMessage("Layer " + layer + ": " + text, Logger.Verbosity.Detailed);
			codingGroupManager.AddCodingGroup(text);
			if (ProjectBuilder.EnableUniformCoding)
			{
				codingGroupManager.AddCodingGroup("uniform");
			}
			codingGroupManager.RegisterCodingGroups(ncontext);
			for (uint num = 0u; num < ncontext.TiledTopology.numLevels; num++)
			{
				for (uint num2 = 0u; num2 < ncontext.TiledTopology.GetLevelHeight(num); num2++)
				{
					for (uint num3 = 0u; num3 < ncontext.TiledTopology.GetLevelWidth(num); num3++)
					{
						LayerTileId tid = new LayerTileId(num3, num2, num, (uint)layer);
						int num4 = codingGroupManager.FindCodingGroupNixelIndex(layer, text);
						if (num4 >= 0)
						{
							ncontext.TiledBuildParameters.SetTileLayerCodingGroup(tid, num4);
						}
					}
				}
			}
			layerFixedTexFormat = codingGroupManager.LayerFixedTexFormat;
		}

		private string GetCorrectQualityLevelForAsset(Asset asset, int layer)
		{
			string qualityProfile = asset.AssetLayers[layer].QualityProfile;
			if (string.IsNullOrEmpty(qualityProfile) || qualityProfile.ToLowerInvariant() == "default")
			{
				return "default";
			}
			return qualityProfile;
		}

		private void UpdateSoupedAsset(CompositedAsset compositedAsset, ref SoupedAsset soupedAsset)
		{
			soupedAsset.AssetId = compositedAsset.AssetId;
			soupedAsset.TilingMethod = compositedAsset.TilingMethod;
			soupedAsset.Width = compositedAsset.Width;
			soupedAsset.Height = compositedAsset.Height;
			soupedAsset.X = compositedAsset.X;
			soupedAsset.Y = compositedAsset.Y;
			soupedAsset.Layers = new List<SoupedAssetLayer>();
			for (int i = 0; i < compositedAsset.Layers.Count; i++)
			{
				soupedAsset.Layers.Add(new SoupedAssetLayer());
				soupedAsset.Layers[i].Textures = new List<SoupedTexture>();
				soupedAsset.Layers[i].FixedTexFormat = ProjectBuilder.State.LayerFixedTexFormats[i];
				soupedAsset.Layers[i].Thumbnail = compositedAsset.Layers[i].Thumbnail;
			}
			for (int j = 0; j < compositedAsset.Layers.Count; j++)
			{
				soupedAsset.Layers[j].Textures.Clear();
				for (int k = 0; k < compositedAsset.Layers[j].Textures.Count; k++)
				{
					CompositedTexture compositedTexture = compositedAsset.Layers[j].Textures[k];
					SoupedTexture item = new SoupedTexture(compositedTexture.X, compositedTexture.Y, compositedTexture.Width, compositedTexture.Height, DateTimeManagement.Now());
					soupedAsset.Layers[j].Textures.Add(item);
				}
			}
			soupedAsset.SoupedDate = DateTimeManagement.Now();
		}

		private bool SetMetaData(NixelContext context, Asset asset)
		{
			try
			{
				byte[] array = Metadata.CreateSoupMetaData(ProjectBuilder, asset);
				GCHandle gCHandle = GCHandle.Alloc(array, GCHandleType.Pinned);
				context.TiledBuildParameters.SetMetadata(gCHandle.AddrOfPinnedObject(), (uint)array.Length);
				gCHandle.Free();
			}
			catch
			{
				string innerMessage = "Error creating metadata. Something went wrong. Cube map face count != 6?";
				ProjectBuilder.BuildReportingHandler.OnFatalError(BuildProcess.TileSetBuilder, new TileSetBuilderIssue(innerMessage));
				return false;
			}
			return true;
		}

		private void GenerateThumbnails(SoupedAsset sasset, NixelContext context)
		{
			int num = 0;
			foreach (SoupedAssetLayer layer in sasset.Layers)
			{
				GenerateThumbnail(layer.Thumbnail, num, context);
				num++;
			}
		}

		private void GenerateThumbnail(Guid thumbnail, int layerIndex, NixelContext context)
		{
			if (thumbnail == Guid.Empty)
			{
				return;
			}
			FixedTexFormat fixedTexFormat = ProjectBuilder.State.LayerFixedTexFormats[layerIndex];
			Graphine.Core.TextureFormat compressedFormat = Graphine.Core.TextureFormat.COUNT;
			switch (fixedTexFormat)
			{
			case FixedTexFormat.BC1:
				compressedFormat = Graphine.Core.TextureFormat.BC1;
				break;
			case FixedTexFormat.BC2:
				throw new Exception("BC2 was not supported by the Granite Graphics system as of writing this code.");
			case FixedTexFormat.BC3:
				compressedFormat = Graphine.Core.TextureFormat.BC3;
				break;
			case FixedTexFormat.BC4:
				compressedFormat = Graphine.Core.TextureFormat.BC4;
				break;
			case FixedTexFormat.BC5:
				compressedFormat = Graphine.Core.TextureFormat.BC5;
				break;
			case FixedTexFormat.BC6:
				compressedFormat = Graphine.Core.TextureFormat.BC6;
				break;
			case FixedTexFormat.BC7:
				compressedFormat = Graphine.Core.TextureFormat.BC7;
				break;
			case FixedTexFormat.ASTC4X4:
				compressedFormat = Graphine.Core.TextureFormat.ASTC4X4;
				break;
			case FixedTexFormat.ASTC8X8:
				compressedFormat = Graphine.Core.TextureFormat.ASTC8X8;
				break;
			}
			uint thumbnailNumLevels = context.TiledRasterData.GetThumbnailNumLevels(thumbnail);
			if (thumbnailNumLevels == 0)
			{
				throw new UnspecifiedException("Could not find the thumbnail in the raster data", Error.InvalidProjectState);
			}
			IntPtr[] array = new IntPtr[thumbnailNumLevels];
			uint width = 0u;
			uint height = 0u;
			DataType inputFormat = DataType.UNKNOWN;
			for (uint num = 0u; num < thumbnailNumLevels; num++)
			{
				array[num] = context.TiledRasterData.GetThumbnailData(thumbnail, num, out var outWidth, out var outHeight, out var outDataType);
				if (array[num] == IntPtr.Zero)
				{
					throw new UnspecifiedException("Could not find the thumbnail data in the raster data", Error.InvalidProjectState);
				}
				if (num == 0)
				{
					width = outWidth;
					height = outHeight;
					inputFormat = outDataType;
				}
			}
			if (context.TiledBuildParameters.SetThumbnail(thumbnail, width, height, thumbnailNumLevels, inputFormat, array, compressedFormat) == Nixel.Error.Ok)
			{
				return;
			}
			throw new Exception("Error Setting thumbnail on the tile soup");
		}

		public static bool DeleteStagingSoupFile(ProjectBuilder builder, Asset asset)
		{
			string soupStagingFileName = BuildState.GetSoupStagingFileName(builder, asset);
			return DeleteSoupFile(builder, soupStagingFileName);
		}

		public static bool DeleteSoupFile(ProjectBuilder builder, Asset asset)
		{
			string soupFilePath = BuildState.GetSoupFilePath(builder.ActiveProject, asset);
			return DeleteSoupFile(builder, soupFilePath);
		}

		public static bool DeleteSoupFile(ProjectBuilder builder, string soupFilePath)
		{
			bool result = true;
			if (File.Exists(soupFilePath))
			{
				try
				{
					File.Delete(soupFilePath);
					return result;
				}
				catch (Exception ex)
				{
					string innerMessage = "Failed to delete gtex file '" + soupFilePath + "' due to the following error: " + ex.Message + ". Make sure the file isn't locked or being used by another process, then rebuild the project.";
					builder.BuildReportingHandler.OnFatalError(BuildProcess.TileSoupBuilder, new GeneralIssue(innerMessage));
					return false;
				}
			}
			return result;
		}

		public static bool DeleteSerializedFiles(ProjectBuilder builder, List<Asset> assets)
		{
			bool result = true;
			_ = builder.ActiveProject.BuildConfiguration.SoupOutputDirectory;
			foreach (Asset asset in assets)
			{
				if (!DeleteSoupFile(builder, asset))
				{
					result = false;
				}
			}
			return result;
		}

		public PipelineProcessResult PostProcess(PipelineProcessResult processResult)
		{
			return PipelineProcessResult.Success;
		}
	}
	internal class CodecLogger : ICodecLogger
	{
		private enum LogType
		{
			Message,
			Warning,
			Error
		}

		private class LogItem
		{
			public string Message { get; set; }

			public LogType Type { get; set; }

			public LogItem(LogType type, string message)
			{
				Message = message;
				Type = type;
			}
		}

		private List<LogItem> messages = new List<LogItem>();

		public void Clear()
		{
			messages.Clear();
		}

		public List<string> GetErrors()
		{
			return (from y in messages.FindAll((LogItem x) => x.Type == LogType.Error)
				select y.Message).ToList();
		}

		public List<string> GetWarnings()
		{
			return (from y in messages.FindAll((LogItem x) => x.Type == LogType.Warning)
				select y.Message).ToList();
		}

		public List<string> GetMessages()
		{
			return (from y in messages.FindAll((LogItem x) => x.Type == LogType.Message)
				select y.Message).ToList();
		}

		public List<string> GetAll()
		{
			return messages.Select((LogItem x) => x.Message).ToList();
		}

		public override void LogMessage(CodecLogInfo logInfo, string message)
		{
			messages.Add(new LogItem(LogType.Message, logInfo.codec + "Message: " + message));
		}

		public override void LogError(CodecLogInfo logInfo, string error)
		{
			messages.Add(new LogItem(LogType.Error, logInfo.codec + " Error: " + error));
		}

		public override void LogWarning(CodecLogInfo logInfo, string warning)
		{
			messages.Add(new LogItem(LogType.Warning, logInfo.codec + " Warning: " + warning));
		}
	}
	internal class BuildCallback : IBuildCallback
	{
		private CodecLogger codecLogger;

		private Logger logger;

		private ProjectBuilder builder;

		public BuildCallback(CodecLogger codecLogger, Logger defaultLogger, ProjectBuilder builder)
		{
			this.codecLogger = codecLogger;
			logger = defaultLogger;
			this.builder = builder;
		}

		public override void OnTileStart(LayerTileId tid)
		{
			codecLogger.Clear();
		}

		public override BuildAction OnTileCompleted(LayerTileId tid)
		{
			if (codecLogger.GetErrors().Count > 0)
			{
				logger.LogConsole("", Logger.Verbosity.Normal);
				string text = "";
				foreach (string item in codecLogger.GetAll())
				{
					text = text + item + " ";
				}
				string innerMessage = "Codec errors occurred on tile X:" + tid.x + " Y:" + tid.y + " Level:" + tid.level + " : " + text;
				builder.BuildReportingHandler.OnFatalError(BuildProcess.TileSetBuilder, new TileSetBuilderIssue(innerMessage));
				return BuildAction.Stop;
			}
			if (codecLogger.GetAll().Count > 0)
			{
				logger.LogConsole("", Logger.Verbosity.Detailed);
				string text2 = "";
				foreach (string item2 in codecLogger.GetAll())
				{
					text2 = text2 + item2 + " ";
				}
				string innerMessage2 = "Codec messages logged on tile X:" + tid.x + " Y:" + tid.y + " Level:" + tid.level + " : " + text2;
				builder.BuildReportingHandler.OnFatalError(BuildProcess.TileSetBuilder, new TileSetBuilderIssue(innerMessage2));
				return BuildAction.Stop;
			}
			return BuildAction.Continue;
		}

		public override BuildAction OnTileFailed(LayerTileId tid, Nixel.Error errorCode)
		{
			logger.LogConsole("", Logger.Verbosity.Normal);
			string text = "";
			foreach (string item in codecLogger.GetAll())
			{
				text = text + item + " ";
			}
			string innerMessage = "Tile code failed on tile X:" + tid.x + " Y:" + tid.y + " Level:" + tid.level + ". Code: " + errorCode.ToString() + ". Detailed codec messages: " + text;
			builder.BuildReportingHandler.OnFatalError(BuildProcess.TileSetBuilder, new TileSetBuilderIssue(innerMessage));
			return BuildAction.Stop;
		}
	}
	internal class TileSoupBuilderProgressTracker : IBuildProgressTracker
	{
		private uint totalTileCount;

		private uint tileCount;

		private int progressPercent;

		private ProjectBuilder builder;

		private ProgressTracker<SlowTask> tracker;

		private string logMessage;

		public TileSoupBuilderProgressTracker(TargetConfiguration config, ProgressTracker<SlowTask> tracker, ProjectBuilder builder, uint totalTileCount, Asset asset, int assetCount, int currentAsset)
		{
			tileCount = 0u;
			progressPercent = 0;
			this.tracker = tracker;
			this.builder = builder;
			this.totalTileCount = totalTileCount;
			logMessage = "{0}%";
			builder.ProgressTracker.StartAsset(asset, currentAsset, assetCount);
		}

		public void SetCurrentLogLine(string logMessage)
		{
			this.logMessage = logMessage;
		}

		public override void StartingPass(BuildPass buildPass)
		{
			if (builder.ProfilingEnabled)
			{
				builder.logger.LogConsole(buildPass.ToString(), Logger.Verbosity.Quiet);
			}
		}

		public override void ProcessedTile(LayerTileId tid, uint tileCountInPass)
		{
			tileCount++;
			double d = (double)tileCount * 100.0 / (double)totalTileCount;
			if (Math.Floor(d) > (double)progressPercent)
			{
				string message = string.Format(logMessage, progressPercent.ToString());
				progressPercent = (int)Math.Floor(d);
				builder.logger.PrintProgress(message, isLast: false, Logger.Verbosity.Normal);
			}
			tracker.UpdateProgress(1L, totalTileCount, tileCount);
		}
	}
	internal class UpgradeCodingProfiles
	{
		private enum QP
		{
			Low,
			Medium,
			High,
			Uncompressed,
			Lossless,
			Default
		}

		private class CPUpgradeHelper
		{
			private class ConvertEntry
			{
				public QP QualityProfile { get; set; }

				public List<DataType> DataTypes { get; private set; }

				public string NewCodingProfile { get; set; }

				public QP NewQualityProfile { get; set; }

				public ConvertEntry(string newCP, QP newQP, QP qp, DataType[] types)
				{
					DataTypes = new List<DataType>(types);
					QualityProfile = qp;
					NewCodingProfile = newCP;
					NewQualityProfile = newQP;
				}
			}

			private class DefaultsEntry
			{
				public QP QualityProfile { get; set; }

				public List<DataType> DataTypes { get; private set; }

				public DefaultsEntry(QP qp, DataType[] types)
				{
					DataTypes = new List<DataType>(types);
					QualityProfile = qp;
				}
			}

			private List<ConvertEntry> List { get; set; }

			private string DefaultNewCodingProfile { get; set; }

			private List<DefaultsEntry> DefaultsList { get; set; }

			public static CPUpgradeHelper HighCompression
			{
				get
				{
					ConvertEntry[] a = new ConvertEntry[5]
					{
						new ConvertEntry("Lossless", QP.Default, QP.Lossless, new DataType[10]
						{
							DataType.R8G8B8A8_LINEAR,
							DataType.R8G8B8A8_SRGB,
							DataType.R8G8B8_LINEAR,
							DataType.R8G8B8_SRGB,
							DataType.X8Y8Z0_TANGENT,
							DataType.X8Y8Z8,
							DataType.R32G32B32_FLOAT,
							DataType.R16G16B16_FLOAT,
							DataType.R32G32B32A32_FLOAT,
							DataType.R16G16B16A16_FLOAT
						}),
						new ConvertEntry("Granite", QP.High, QP.High, new DataType[8]
						{
							DataType.R8G8B8A8_LINEAR,
							DataType.R8G8B8A8_SRGB,
							DataType.R8G8B8_LINEAR,
							DataType.R8G8B8_SRGB,
							DataType.X8Y8Z0_TANGENT,
							DataType.X8,
							DataType.X8Y8,
							DataType.R16G16B16_FLOAT
						}),
						new ConvertEntry("Granite", QP.Medium, QP.Medium, new DataType[8]
						{
							DataType.R8G8B8A8_LINEAR,
							DataType.R8G8B8A8_SRGB,
							DataType.R8G8B8_LINEAR,
							DataType.R8G8B8_SRGB,
							DataType.X8Y8Z0_TANGENT,
							DataType.X8,
							DataType.X8Y8,
							DataType.R16G16B16_FLOAT
						}),
						new ConvertEntry("Granite", QP.Low, QP.Low, new DataType[8]
						{
							DataType.R8G8B8A8_LINEAR,
							DataType.R8G8B8A8_SRGB,
							DataType.R8G8B8_LINEAR,
							DataType.R8G8B8_SRGB,
							DataType.X8Y8Z0_TANGENT,
							DataType.X8,
							DataType.X8Y8,
							DataType.R16G16B16_FLOAT
						}),
						new ConvertEntry("Lossless", QP.Default, QP.Uncompressed, new DataType[6]
						{
							DataType.R8G8B8A8_LINEAR,
							DataType.R8G8B8A8_SRGB,
							DataType.R8G8B8_LINEAR,
							DataType.R8G8B8_SRGB,
							DataType.X8Y8Z0_TANGENT,
							DataType.X8Y8Z8
						})
					};
					DefaultsEntry[] d = new DefaultsEntry[2]
					{
						new DefaultsEntry(QP.Medium, new DataType[8]
						{
							DataType.R8G8B8A8_LINEAR,
							DataType.R8G8B8A8_SRGB,
							DataType.R8G8B8_LINEAR,
							DataType.R8G8B8_SRGB,
							DataType.X8Y8Z0_TANGENT,
							DataType.X8Y8,
							DataType.X8,
							DataType.R16G16B16_FLOAT
						}),
						new DefaultsEntry(QP.Lossless, new DataType[4]
						{
							DataType.R16G16B16A16_FLOAT,
							DataType.R32G32B32A32_FLOAT,
							DataType.R32G32B32_FLOAT,
							DataType.X8Y8Z8
						})
					};
					return new CPUpgradeHelper(a, "default", d);
				}
			}

			public static CPUpgradeHelper HighQuality_DirectX11
			{
				get
				{
					ConvertEntry[] a = new ConvertEntry[15]
					{
						new ConvertEntry("Lossless", QP.Default, QP.Lossless, new DataType[8]
						{
							DataType.R8G8B8A8_LINEAR,
							DataType.R8G8B8A8_SRGB,
							DataType.R8G8B8_LINEAR,
							DataType.R8G8B8_SRGB,
							DataType.R32G32B32_FLOAT,
							DataType.R16G16B16_FLOAT,
							DataType.R32G32B32A32_FLOAT,
							DataType.R16G16B16A16_FLOAT
						}),
						new ConvertEntry("BC7", QP.Default, QP.High, new DataType[5]
						{
							DataType.R8G8B8A8_LINEAR,
							DataType.R8G8B8A8_SRGB,
							DataType.R8G8B8_LINEAR,
							DataType.R8G8B8_SRGB,
							DataType.X8Y8Z8
						}),
						new ConvertEntry("BC4", QP.Default, QP.High, new DataType[1] { DataType.X8 }),
						new ConvertEntry("BC5", QP.Default, QP.High, new DataType[2]
						{
							DataType.X8Y8Z0_TANGENT,
							DataType.X8Y8
						}),
						new ConvertEntry("BC6", QP.Default, QP.High, new DataType[1] { DataType.R16G16B16_FLOAT }),
						new ConvertEntry("BC7", QP.Default, QP.Medium, new DataType[2]
						{
							DataType.R8G8B8A8_LINEAR,
							DataType.R8G8B8A8_SRGB
						}),
						new ConvertEntry("BC1", QP.Default, QP.Medium, new DataType[3]
						{
							DataType.R8G8B8_LINEAR,
							DataType.R8G8B8_SRGB,
							DataType.X8Y8Z8
						}),
						new ConvertEntry("BC4", QP.Default, QP.Medium, new DataType[1] { DataType.X8 }),
						new ConvertEntry("BC5", QP.Default, QP.Medium, new DataType[2]
						{
							DataType.X8Y8Z0_TANGENT,
							DataType.X8Y8
						}),
						new ConvertEntry("BC6", QP.Default, QP.Medium, new DataType[1] { DataType.R16G16B16_FLOAT }),
						new ConvertEntry("BC3", QP.Default, QP.Low, new DataType[2]
						{
							DataType.R8G8B8A8_LINEAR,
							DataType.R8G8B8A8_SRGB
						}),
						new ConvertEntry("BC1", QP.Default, QP.Low, new DataType[5]
						{
							DataType.R8G8B8_LINEAR,
							DataType.R8G8B8_SRGB,
							DataType.X8Y8Z8,
							DataType.X8Y8Z0_TANGENT,
							DataType.X8Y8
						}),
						new ConvertEntry("BC4", QP.Default, QP.Low, new DataType[1] { DataType.X8 }),
						new ConvertEntry("BC6", QP.Default, QP.Low, new DataType[1] { DataType.R16G16B16_FLOAT }),
						new ConvertEntry("Lossless", QP.Default, QP.Uncompressed, new DataType[5]
						{
							DataType.R8G8B8A8_LINEAR,
							DataType.R8G8B8A8_SRGB,
							DataType.R8G8B8_LINEAR,
							DataType.R8G8B8_SRGB,
							DataType.X8Y8Z0_TANGENT
						})
					};
					DefaultsEntry[] d = new DefaultsEntry[2]
					{
						new DefaultsEntry(QP.Medium, new DataType[9]
						{
							DataType.R8G8B8A8_LINEAR,
							DataType.R8G8B8A8_SRGB,
							DataType.R8G8B8_LINEAR,
							DataType.R8G8B8_SRGB,
							DataType.X8Y8Z0_TANGENT,
							DataType.X8Y8Z8,
							DataType.X8Y8,
							DataType.X8,
							DataType.R16G16B16_FLOAT
						}),
						new DefaultsEntry(QP.Lossless, new DataType[3]
						{
							DataType.R16G16B16A16_FLOAT,
							DataType.R32G32B32A32_FLOAT,
							DataType.R32G32B32_FLOAT
						})
					};
					return new CPUpgradeHelper(a, "default", d);
				}
			}

			public static CPUpgradeHelper HighQuality_DirectX9
			{
				get
				{
					ConvertEntry[] a = new ConvertEntry[11]
					{
						new ConvertEntry("Lossless", QP.Default, QP.Lossless, new DataType[8]
						{
							DataType.R8G8B8A8_LINEAR,
							DataType.R8G8B8A8_SRGB,
							DataType.R8G8B8_LINEAR,
							DataType.R8G8B8_SRGB,
							DataType.R32G32B32_FLOAT,
							DataType.R16G16B16_FLOAT,
							DataType.R32G32B32A32_FLOAT,
							DataType.R16G16B16A16_FLOAT
						}),
						new ConvertEntry("BC3", QP.Default, QP.High, new DataType[4]
						{
							DataType.R8G8B8A8_LINEAR,
							DataType.R8G8B8A8_SRGB,
							DataType.X8Y8Z0_TANGENT,
							DataType.X8Y8
						}),
						new ConvertEntry("Granite", QP.High, QP.High, new DataType[1] { DataType.X8 }),
						new ConvertEntry("BC1", QP.Default, QP.High, new DataType[3]
						{
							DataType.R8G8B8_LINEAR,
							DataType.R8G8B8_SRGB,
							DataType.X8Y8Z8
						}),
						new ConvertEntry("BC3", QP.Default, QP.Medium, new DataType[4]
						{
							DataType.R8G8B8A8_LINEAR,
							DataType.R8G8B8A8_SRGB,
							DataType.X8Y8Z0_TANGENT,
							DataType.X8Y8
						}),
						new ConvertEntry("BC1", QP.Default, QP.Medium, new DataType[3]
						{
							DataType.R8G8B8_LINEAR,
							DataType.R8G8B8_SRGB,
							DataType.X8Y8Z8
						}),
						new ConvertEntry("Granite", QP.Medium, QP.Medium, new DataType[1] { DataType.X8 }),
						new ConvertEntry("BC3", QP.Default, QP.Low, new DataType[2]
						{
							DataType.R8G8B8A8_LINEAR,
							DataType.R8G8B8A8_SRGB
						}),
						new ConvertEntry("BC1", QP.Default, QP.Low, new DataType[5]
						{
							DataType.R8G8B8_LINEAR,
							DataType.R8G8B8_SRGB,
							DataType.X8Y8Z8,
							DataType.X8Y8Z0_TANGENT,
							DataType.X8Y8
						}),
						new ConvertEntry("Granite", QP.Low, QP.Low, new DataType[1] { DataType.X8 }),
						new ConvertEntry("Lossless", QP.Default, QP.Uncompressed, new DataType[5]
						{
							DataType.R8G8B8A8_LINEAR,
							DataType.R8G8B8A8_SRGB,
							DataType.R8G8B8_LINEAR,
							DataType.R8G8B8_SRGB,
							DataType.X8Y8Z0_TANGENT
						})
					};
					DefaultsEntry[] d = new DefaultsEntry[2]
					{
						new DefaultsEntry(QP.Medium, new DataType[8]
						{
							DataType.R8G8B8A8_LINEAR,
							DataType.R8G8B8A8_SRGB,
							DataType.R8G8B8_LINEAR,
							DataType.R8G8B8_SRGB,
							DataType.X8Y8Z0_TANGENT,
							DataType.X8Y8Z8,
							DataType.X8Y8,
							DataType.X8
						}),
						new DefaultsEntry(QP.Lossless, new DataType[4]
						{
							DataType.R16G16B16A16_FLOAT,
							DataType.R32G32B32A32_FLOAT,
							DataType.R32G32B32_FLOAT,
							DataType.R16G16B16_FLOAT
						})
					};
					return new CPUpgradeHelper(a, "default", d);
				}
			}

			private CPUpgradeHelper(ConvertEntry[] a, string defaultNewCodingProfile, DefaultsEntry[] d)
			{
				List = new List<ConvertEntry>(a);
				DefaultNewCodingProfile = defaultNewCodingProfile;
				DefaultsList = new List<DefaultsEntry>(d);
			}

			public void Find(QP qp, DataType datatype, out string newCodingProfile, out string newQualityProfile)
			{
				if (qp == QP.Default)
				{
					List<DefaultsEntry> list = DefaultsList.FindAll((DefaultsEntry x) => x.DataTypes.Contains(datatype));
					if (list.Count > 0)
					{
						qp = list[0].QualityProfile;
					}
				}
				List<ConvertEntry> list2 = List.FindAll((ConvertEntry x) => x.DataTypes.Contains(datatype) && x.QualityProfile == qp);
				if (list2.Count != 1)
				{
					newCodingProfile = DefaultNewCodingProfile;
					newQualityProfile = "default";
				}
				newCodingProfile = list2[0].NewCodingProfile;
				newQualityProfile = GetQualityProfileString(list2[0].NewQualityProfile);
			}
		}

		private static string OldStyleDefaultCodingProfileFromBuildProfile(string buildProfile)
		{
			if (buildProfile.Equals("default"))
			{
				return "default";
			}
			if (buildProfile.Equals("DirectX11.2_TiledResources"))
			{
				return "HighQuality_DirectX11";
			}
			if (buildProfile.Equals("DirectX11"))
			{
				return "HighQuality_DirectX11";
			}
			if (buildProfile.Equals("DirectX9"))
			{
				return "HighQuality_DirectX9";
			}
			return "default";
		}

		private static bool IsValidOldCodingProfile(string name)
		{
			return new string[4] { "default", "HighQuality_DirectX11", "HighQuality_DirectX11", "HighQuality_DirectX9" }.Contains(name, StringComparer.OrdinalIgnoreCase);
		}

		private static QP GetQualityProfile(string name)
		{
			if (name.Equals("low", StringComparison.OrdinalIgnoreCase))
			{
				return QP.Low;
			}
			if (name.Equals("medium", StringComparison.OrdinalIgnoreCase))
			{
				return QP.Medium;
			}
			if (name.Equals("high", StringComparison.OrdinalIgnoreCase))
			{
				return QP.High;
			}
			if (name.Equals("uncompressed", StringComparison.OrdinalIgnoreCase))
			{
				return QP.Uncompressed;
			}
			if (name.Equals("lossless", StringComparison.OrdinalIgnoreCase))
			{
				return QP.Lossless;
			}
			return QP.Default;
		}

		private static string GetQualityProfileString(QP qp)
		{
			return qp switch
			{
				QP.Default => "default", 
				QP.High => "high", 
				QP.Medium => "medium", 
				QP.Lossless => "lossless", 
				QP.Low => "low", 
				QP.Uncompressed => "uncompressed", 
				_ => "default", 
			};
		}

		private static void UpgradeCodingProfile(DataType datatype, string oldProfile, string qualityProfile, out string newCodingProfile, out string newQualityProfile)
		{
			QP qualityProfile2 = GetQualityProfile(qualityProfile);
			if (oldProfile.Equals("default", StringComparison.OrdinalIgnoreCase) || oldProfile.Equals("HighCompression", StringComparison.OrdinalIgnoreCase))
			{
				CPUpgradeHelper.HighCompression.Find(qualityProfile2, datatype, out newCodingProfile, out newQualityProfile);
				return;
			}
			if (oldProfile.Equals("HighQuality_DirectX11", StringComparison.OrdinalIgnoreCase))
			{
				CPUpgradeHelper.HighQuality_DirectX11.Find(qualityProfile2, datatype, out newCodingProfile, out newQualityProfile);
				return;
			}
			if (oldProfile.Equals("HighQuality_DirectX9", StringComparison.OrdinalIgnoreCase))
			{
				CPUpgradeHelper.HighQuality_DirectX9.Find(qualityProfile2, datatype, out newCodingProfile, out newQualityProfile);
				return;
			}
			newCodingProfile = "Granite";
			newQualityProfile = "default";
		}

		private static string FindActiveQualityProfile(Project project, int layer)
		{
			foreach (Asset value in project.Assets.Values)
			{
				string qualityProfile = value.AssetLayers[layer].QualityProfile;
				if (!string.IsNullOrEmpty(qualityProfile) && !qualityProfile.Equals("default", StringComparison.OrdinalIgnoreCase))
				{
					return qualityProfile;
				}
			}
			return project.LayerConfiguration.Layers[layer].QualityProfile;
		}

		public static void UpgradeLayerCodingProfile(Project project, int layer)
		{
			LayerDescription layerDescription = project.LayerConfiguration.Layers[layer];
			string empty = string.Empty;
			if (!string.IsNullOrEmpty(project.BuildConfiguration.DepricatedCodingProfile))
			{
				empty = project.BuildConfiguration.DepricatedCodingProfile;
				if (!IsValidOldCodingProfile(empty))
				{
					empty = "default";
				}
			}
			else
			{
				empty = OldStyleDefaultCodingProfileFromBuildProfile(project.BuildProfile);
			}
			UpgradeCodingProfile(qualityProfile: FindActiveQualityProfile(project, layer), datatype: layerDescription.DataType, oldProfile: empty, newCodingProfile: out var newCodingProfile, newQualityProfile: out var newQualityProfile);
			layerDescription.CodingProfile = newCodingProfile;
			layerDescription.QualityProfile = newQualityProfile;
		}

		public static Dictionary<DataType, string> SetupDeprectedDefaultCodingProfiles(string buildProfileName)
		{
			Dictionary<DataType, string> dictionary = new Dictionary<DataType, string>();
			string value = "default";
			if (buildProfileName.Equals("default", StringComparison.OrdinalIgnoreCase))
			{
				value = "highcompression";
			}
			else if (buildProfileName.Equals("DirectX11", StringComparison.OrdinalIgnoreCase))
			{
				value = "highquality_directx11";
			}
			else if (buildProfileName.Equals("DirectX9", StringComparison.OrdinalIgnoreCase))
			{
				value = "highquality_directx9";
			}
			foreach (DataType item in System.Enum.GetValues(typeof(DataType)).Cast<DataType>())
			{
				dictionary.Add(item, value);
			}
			return dictionary;
		}
	}
	public class Version
	{
		public int Minor { get; private set; }

		public int Major { get; private set; }

		public Version(int major, int minor)
		{
			Major = major;
			Minor = minor;
		}

		public bool IsMajorCompatible(Version v)
		{
			return Major == v.Major;
		}

		public bool IsMinorCompatible(Version v)
		{
			if (Major == v.Major)
			{
				return Minor == v.Minor;
			}
			return false;
		}

		public bool IsNewer(Version v)
		{
			if (Major <= v.Major)
			{
				if (Major == v.Major)
				{
					return Minor > v.Minor;
				}
				return false;
			}
			return true;
		}

		public override string ToString()
		{
			return string.Format("{0}.{1}", new object[2] { Major, Minor });
		}

		public static Version Parse(string s)
		{
			string[] array = s.Split('.');
			int result = 0;
			int result2 = 0;
			if (array.Length != 0)
			{
				int.TryParse(array[0], out result);
			}
			if (array.Length > 1)
			{
				int.TryParse(array[1], out result2);
			}
			return new Version(result, result2);
		}

		public static int Compare(Version v1, Version v2)
		{
			if (v1.Major < v2.Major)
			{
				return -1;
			}
			if (v1.Major == v2.Major)
			{
				if (v1.Minor < v2.Minor)
				{
					return -1;
				}
				if (v1.Minor == v2.Minor)
				{
					return 0;
				}
				return 1;
			}
			return 1;
		}
	}
	internal static class XMLEngine
	{
		private static class XMLEngineTools
		{
			public static void ReadBuildConfig(XmlNode buildConfigNode, out BuildConfiguration buildConfig)
			{
				buildConfig = new BuildConfiguration();
				XmlNode xmlNode = buildConfigNode.SelectSingleNode("OutputDirectory");
				if (xmlNode == null)
				{
					throw new GrMissingNodeException("OutputDirectory", buildConfigNode);
				}
				buildConfig.OutputDirectory = xmlNode.InnerText;
				xmlNode = buildConfigNode.SelectSingleNode("SoupOutputDirectory");
				if (xmlNode != null)
				{
					buildConfig.SoupOutputDirectory = xmlNode.InnerText;
				}
				xmlNode = buildConfigNode.SelectSingleNode("OutputType");
				if (xmlNode == null)
				{
					throw new GrMissingNodeException("OutputType", buildConfigNode);
				}
				buildConfig.OutputType = xmlNode.InnerText;
				xmlNode = buildConfigNode.SelectSingleNode("OutputName");
				if (xmlNode == null)
				{
					throw new GrMissingNodeException("OutputName", buildConfigNode);
				}
				buildConfig.OutputFilename = xmlNode.InnerText;
				xmlNode = buildConfigNode.SelectSingleNode("WarningLevel");
				if (xmlNode == null)
				{
					throw new GrMissingNodeException("WraningLevel", buildConfigNode);
				}
				buildConfig.WarningLevel = XMLParsingTools.ParseUIntInner(xmlNode);
				xmlNode = buildConfigNode.SelectSingleNode("LogFile");
				if (xmlNode == null)
				{
					throw new GrMissingNodeException("LogFile", buildConfigNode);
				}
				buildConfig.LogFile = xmlNode.InnerText;
				xmlNode = buildConfigNode.SelectSingleNode("TilingMode");
				if (xmlNode == null)
				{
					throw new GrMissingNodeException("TilingMode", buildConfigNode);
				}
				TilingMode value = TilingMode.Software;
				if (!XMLParsingTools.ParseEnumInner<TilingMode>(xmlNode, out value))
				{
					throw new GrInvalidParseNodeException("TilingMode", xmlNode);
				}
				buildConfig.TilingMode = value;
				xmlNode = buildConfigNode.SelectSingleNode("MaximumAnisotropy");
				if (xmlNode == null)
				{
					throw new GrMissingNodeException("MaximumAnisotropy", buildConfigNode);
				}
				buildConfig.MaximumAnisotropy = XMLParsingTools.ParseUIntInner(xmlNode);
				buildConfig.PagesDirectory = "";
				xmlNode = buildConfigNode.SelectSingleNode("PagesDirectory");
				if (xmlNode != null)
				{
					buildConfig.PagesDirectory = xmlNode.InnerText;
				}
				xmlNode = buildConfigNode.SelectSingleNode("CustomPageSize");
				if (xmlNode != null)
				{
					buildConfig.PageSize = XMLParsingTools.ParseUIntInner(xmlNode);
				}
				xmlNode = buildConfigNode.SelectSingleNode("CustomTargetDisk");
				if (xmlNode != null && XMLParsingTools.ParseEnumInner<TargetDisk>(xmlNode, out var value2))
				{
					buildConfig.TargetDisk = value2;
				}
				xmlNode = buildConfigNode.SelectSingleNode("CustomBlockSize");
				if (xmlNode != null)
				{
					buildConfig.BlockSize = XMLParsingTools.ParseUIntInner(xmlNode);
				}
				xmlNode = buildConfigNode.SelectSingleNode("CustomTileWidth");
				if (xmlNode != null)
				{
					buildConfig.TileWidth = XMLParsingTools.ParseUIntInner(xmlNode);
				}
				xmlNode = buildConfigNode.SelectSingleNode("CustomTileHeight");
				if (xmlNode != null)
				{
					buildConfig.TileHeight = XMLParsingTools.ParseUIntInner(xmlNode);
				}
				xmlNode = buildConfigNode.SelectSingleNode("CodingProfile");
				if (xmlNode != null)
				{
					buildConfig.DepricatedCodingProfile = xmlNode.InnerText;
				}
				xmlNode = buildConfigNode.SelectSingleNode("PagingStrategy");
				if (xmlNode != null && XMLParsingTools.ParseEnumInner<PagingStrategy>(xmlNode, out var value3))
				{
					buildConfig.PagingStrategy = value3;
				}
			}

			public static void WriteBuildConfig(BuildConfiguration buildConfig, string xpath, ref XmlDocument document)
			{
				if (buildConfig != null)
				{
					XmlNode xmlNode = document.CreateElement("BuildConfig");
					document.SelectSingleNode(xpath).AppendChild(xmlNode);
					XmlNode xmlNode2 = document.CreateElement("OutputDirectory");
					xmlNode2.InnerText = buildConfig.OutputDirectory;
					xmlNode.AppendChild(xmlNode2);
					XmlNode xmlNode3 = document.CreateElement("SoupOutputDirectory");
					xmlNode3.InnerText = buildConfig.SoupOutputDirectory;
					xmlNode.AppendChild(xmlNode3);
					XmlNode xmlNode4 = document.CreateElement("OutputType");
					xmlNode4.InnerText = buildConfig.OutputType;
					xmlNode.AppendChild(xmlNode4);
					XmlNode xmlNode5 = document.CreateElement("OutputName");
					xmlNode5.InnerText = buildConfig.OutputFilename;
					xmlNode.AppendChild(xmlNode5);
					XmlNode xmlNode6 = document.CreateElement("WarningLevel");
					xmlNode6.InnerText = buildConfig.WarningLevel.ToString();
					xmlNode.AppendChild(xmlNode6);
					XmlNode xmlNode7 = document.CreateElement("LogFile");
					xmlNode7.InnerText = buildConfig.LogFile;
					xmlNode.AppendChild(xmlNode7);
					XmlNode xmlNode8 = document.CreateElement("TilingMode");
					xmlNode8.InnerText = buildConfig.TilingMode.ToString();
					xmlNode.AppendChild(xmlNode8);
					XmlNode xmlNode9 = document.CreateElement("MaximumAnisotropy");
					xmlNode9.InnerText = buildConfig.MaximumAnisotropy.ToString();
					xmlNode.AppendChild(xmlNode9);
					if (buildConfig.PagesDirectory != null && buildConfig.PagesDirectory.Length != 0)
					{
						XmlNode xmlNode10 = document.CreateElement("PagesDirectory");
						xmlNode10.InnerText = buildConfig.PagesDirectory;
						xmlNode.AppendChild(xmlNode10);
					}
					XmlNode xmlNode11 = document.CreateElement("CustomPageSize");
					xmlNode11.InnerText = buildConfig.PageSize.ToString();
					xmlNode.AppendChild(xmlNode11);
					XmlNode xmlNode12 = document.CreateElement("CustomTargetDisk");
					xmlNode12.InnerText = buildConfig.TargetDisk.ToString();
					xmlNode.AppendChild(xmlNode12);
					XmlNode xmlNode13 = document.CreateElement("CustomBlockSize");
					xmlNode13.InnerText = buildConfig.BlockSize.ToString();
					xmlNode.AppendChild(xmlNode13);
					XmlNode xmlNode14 = document.CreateElement("CustomTileWidth");
					xmlNode14.InnerText = buildConfig.TileWidth.ToString();
					xmlNode.AppendChild(xmlNode14);
					XmlNode xmlNode15 = document.CreateElement("CustomTileHeight");
					xmlNode15.InnerText = buildConfig.TileHeight.ToString();
					xmlNode.AppendChild(xmlNode15);
					XmlNode xmlNode16 = document.CreateElement("PagingStrategy");
					xmlNode16.InnerText = buildConfig.PagingStrategy.ToString();
					xmlNode.AppendChild(xmlNode16);
				}
			}

			public static void ReadCodingProfile(XmlNode codingProfileNode, out CodingProfile profile)
			{
				profile = new CodingProfile();
				profile.QualityProfiles = new List<QualityProfile>();
				profile.DefaultQualitySettings = new List<DefaultQualitySetting>();
				if (codingProfileNode.Attributes["Name"] == null)
				{
					throw new GrMissingAttributeException("Name", codingProfileNode);
				}
				profile.Name = codingProfileNode.Attributes["Name"].Value;
				if (codingProfileNode.Attributes["DisplayName"] == null)
				{
					throw new GrMissingAttributeException("DisplayName", codingProfileNode);
				}
				profile.DisplayName = codingProfileNode.Attributes["DisplayName"].Value;
				foreach (XmlNode item in codingProfileNode.SelectNodes("DefaultQualitySettings/DefaultQuality"))
				{
					DefaultQualitySetting defaultQualitySetting = new DefaultQualitySetting();
					if (item.Attributes["QualityProfile"] == null)
					{
						throw new GrMissingAttributeException("QualityProfile", item);
					}
					defaultQualitySetting.QualityProfile = item.Attributes["QualityProfile"].Value;
					defaultQualitySetting.DataTypes = new List<DataType>();
					foreach (XmlNode item2 in item.SelectNodes("DataTypes/DataType"))
					{
						if (!XMLParsingTools.ParseEnumInner<DataType>(item2, out var value))
						{
							throw new GrInvalidParseNodeException("DataType", item2);
						}
						defaultQualitySetting.DataTypes.Add(value);
					}
					profile.DefaultQualitySettings.Add(defaultQualitySetting);
				}
				foreach (XmlNode item3 in codingProfileNode.SelectNodes("QualityProfile"))
				{
					QualityProfile qualityProfile = new QualityProfile();
					if (item3.Attributes["Name"] == null)
					{
						throw new GrMissingAttributeException("Name", item3);
					}
					qualityProfile.Name = item3.Attributes["Name"].Value;
					if (item3.Attributes["Priority"] == null)
					{
						throw new GrMissingAttributeException("Priority", item3);
					}
					qualityProfile.Priority = XMLParsingTools.ParseUIntAttribute("Priority", item3);
					if (item3.Attributes["Hidden"] != null)
					{
						qualityProfile.Hidden = XMLParsingTools.ParseBoolAttribute("Hidden", item3);
					}
					qualityProfile.CodingConfigs = new List<CodingConfig>();
					foreach (XmlNode item4 in item3.SelectNodes("CodingConfig"))
					{
						CodingConfig codingConfig = new CodingConfig();
						codingConfig.DataTypes = new List<DataType>();
						foreach (XmlNode item5 in item4.SelectNodes("DataTypes/DataType"))
						{
							if (!XMLParsingTools.ParseEnumInner<DataType>(item5, out var value2))
							{
								throw new GrInvalidParseNodeException("DataType", item4);
							}
							codingConfig.DataTypes.Add(value2);
						}
						XmlNode xmlNode4 = item4.SelectSingleNode("Codec");
						if (xmlNode4 == null)
						{
							throw new GrMissingNodeException("Codec", item4);
						}
						if (xmlNode4.Attributes["Id"] == null)
						{
							throw new GrMissingAttributeException("Id", xmlNode4);
						}
						codingConfig.CodecId = XMLParsingTools.ParseIntAttribute("Id", xmlNode4);
						if (xmlNode4.SelectSingleNode("Configuration") == null)
						{
							throw new GrMissingNodeException("Configuration", xmlNode4);
						}
						codingConfig.CodecConfiguration = xmlNode4.SelectSingleNode("Configuration").InnerText;
						qualityProfile.CodingConfigs.Add(codingConfig);
					}
					profile.QualityProfiles.Add(qualityProfile);
				}
			}

			public static void ReadBuildProfile(XmlNode profileNode, out BuildProfile profile)
			{
				profile = new BuildProfile();
				if (profileNode.Attributes["Name"] != null)
				{
					profile.Name = profileNode.Attributes["Name"].Value;
				}
				if (profileNode.Attributes["DisplayName"] != null)
				{
					profile.DisplayName = profileNode.Attributes["DisplayName"].Value;
				}
				if (profileNode.Attributes["Description"] != null)
				{
					profile.Description = profileNode.Attributes["Description"].Value;
				}
				XmlNode xmlNode = profileNode.SelectSingleNode("TargetDisk");
				if (xmlNode != null)
				{
					if (!XMLParsingTools.ParseEnumInner<TargetDisk>(xmlNode, out var value))
					{
						throw new GrInvalidParseNodeException("TargetDisk", xmlNode);
					}
					profile.TargetDisk = value;
				}
				XmlNode xmlNode2 = profileNode.SelectSingleNode("BlockSize");
				if (xmlNode2 != null)
				{
					profile.BlockSize = XMLParsingTools.ParseUIntInner(xmlNode2);
				}
				XmlNode xmlNode3 = profileNode.SelectSingleNode("TileSize");
				if (xmlNode3 != null)
				{
					profile.TileSize = XMLParsingTools.ParseUIntInner(xmlNode3);
				}
				XmlNode xmlNode4 = profileNode.SelectSingleNode("Anisotropy");
				if (xmlNode4 != null)
				{
					profile.Anisotropy = XMLParsingTools.ParseUIntInner(xmlNode4);
				}
				XmlNode xmlNode5 = profileNode.SelectSingleNode("TilingMode");
				if (xmlNode5 != null)
				{
					if (!XMLParsingTools.ParseEnumInner<TilingMode>(xmlNode5, out var value2))
					{
						throw new GrInvalidParseNodeException("TilingMode", xmlNode5);
					}
					profile.TilingMode = value2;
				}
				profile.AvailableCodingProfiles = new List<string>();
				XmlNode xmlNode6 = profileNode.SelectSingleNode("AvailableCodingProfiles");
				if (xmlNode6 != null)
				{
					foreach (XmlNode item in xmlNode6.SelectNodes("CodingProfile"))
					{
						bool flag = false;
						if (item.Attributes["deprecated"] != null)
						{
							flag = XMLParsingTools.ParseBoolAttribute("deprecated", item);
						}
						if (!flag || (flag && Constants.AllowDeprecatedCodingProfiles))
						{
							profile.AvailableCodingProfiles.Add(item.InnerText);
						}
					}
				}
				profile.AvailablePagingStrategies = new List<PagingStrategy>();
				XmlNode xmlNode8 = profileNode.SelectSingleNode("AvailablePagingStrategies");
				if (xmlNode8 != null)
				{
					List<PagingStrategy> values = new List<PagingStrategy>();
					if (XMLParsingTools.ParseEnumNodeList(xmlNode8, "PagingStrategy", out values))
					{
						profile.AvailablePagingStrategies = values;
					}
					if (XMLParsingTools.ParseEnumAttribute<PagingStrategy>(xmlNode8, "DefaultMapsTo", out var value3))
					{
						profile.DefaultPagingStrategyMapsTo = value3;
					}
				}
				profile.DefaultCodingProfiles = new Dictionary<DataType, string>();
				XmlNode xmlNode9 = profileNode.SelectSingleNode("DefaultCodingProfiles");
				if (xmlNode9 == null)
				{
					return;
				}
				if (Constants.AllowDeprecatedCodingProfiles)
				{
					profile.DefaultCodingProfiles = UpgradeCodingProfiles.SetupDeprectedDefaultCodingProfiles(profile.Name);
					return;
				}
				foreach (XmlNode item2 in xmlNode9.SelectNodes("DefaultCodingProfile"))
				{
					if (!XMLParsingTools.ParseEnumAttribute<DataType>(item2, "dataType", out var value4))
					{
						throw new GrInvalidParseAttributeException("dataType", item2);
					}
					profile.DefaultCodingProfiles.Add(value4, item2.InnerText);
				}
			}

			public static void ReadLayerConfig(XmlNode layerConfigNode, out LayerConfig layerConfig)
			{
				XmlNodeList xmlNodeList = layerConfigNode.SelectNodes("LayerDescription");
				layerConfig = new LayerConfig();
				foreach (XmlNode item in xmlNodeList)
				{
					if (item.Attributes["DataType"] == null)
					{
						throw new GrMissingAttributeException("DataType", item);
					}
					LayerDescription layerDescription = new LayerDescription();
					if (!XMLParsingTools.ParseEnumAttribute<DataType>(item, "DataType", out var value))
					{
						throw new GrInvalidParseAttributeException("DataType", item);
					}
					layerDescription.DataType = value;
					if (item.Attributes["QualityProfile"] != null)
					{
						layerDescription.QualityProfile = item.Attributes["QualityProfile"].Value;
					}
					if (item.Attributes["CompressionFormat"] != null)
					{
						layerDescription.CodingProfile = item.Attributes["CompressionFormat"].Value;
					}
					if (item.Attributes["QualityLevel"] != null)
					{
						layerDescription.QualityProfile = item.Attributes["QualityLevel"].Value;
					}
					if (item.Attributes["Name"] != null)
					{
						layerDescription.LayerName = item.Attributes["Name"].Value;
					}
					if (item.Attributes["DefaultColor"] != null)
					{
						layerDescription.DefaultColor = item.Attributes["DefaultColor"].Value;
					}
					layerConfig.Layers.Add(layerDescription);
				}
			}

			public static void WriteLayerConfig(LayerConfig layerConfig, string xpath, ref XmlDocument document)
			{
				if (layerConfig == null || layerConfig.Layers == null || layerConfig.Layers.Count == 0)
				{
					return;
				}
				XmlNode xmlNode = document.CreateElement("LayerConfig");
				document.SelectSingleNode(xpath).AppendChild(xmlNode);
				foreach (LayerDescription layer in layerConfig.Layers)
				{
					XmlElement xmlElement = document.CreateElement("LayerDescription");
					if (layer.LayerName != null)
					{
						xmlElement.SetAttribute("Name", layer.LayerName);
					}
					xmlElement.SetAttribute("CompressionFormat", layer.CodingProfile);
					xmlElement.SetAttribute("QualityProfile", layer.QualityProfile);
					xmlElement.SetAttribute("DataType", layer.DataType.ToString());
					xmlElement.SetAttribute("DefaultColor", (layer.DefaultColor != null) ? layer.DefaultColor.ToString() : string.Empty);
					xmlNode.AppendChild(xmlElement);
				}
			}

			public static void ReadImportedAssets(XmlNode importedAssetsNode, out Dictionary<Guid, Asset> importedAssets)
			{
				importedAssets = new Dictionary<Guid, Asset>();
				foreach (XmlNode item in importedAssetsNode.SelectNodes("Asset"))
				{
					Asset asset = new Asset();
					if (item.Attributes["Name"] == null)
					{
						throw new GrMissingAttributeException("Name", item);
					}
					asset.Name = item.Attributes["Name"].Value;
					if (item.Attributes["GUID"] == null)
					{
						throw new GrMissingAttributeException("GUID", item);
					}
					try
					{
						asset.Id = XMLParsingTools.ParseGuidAttribute("GUID", item);
					}
					catch (Exception)
					{
						throw new GrInvalidParseAttributeException("GUID", item);
					}
					if (item.Attributes["Width"] == null)
					{
						throw new GrMissingAttributeException("Width", item);
					}
					if (item.Attributes["Height"] == null)
					{
						throw new GrMissingAttributeException("Height", item);
					}
					asset.Width = XMLParsingTools.ParseIntAttribute("Width", item);
					asset.Height = XMLParsingTools.ParseIntAttribute("Height", item);
					if (item.Attributes["TargetWidth"] != null)
					{
						asset.TargetWidth = XMLParsingTools.ParseIntAttribute("TargetWidth", item);
					}
					if (item.Attributes["TargetHeight"] != null)
					{
						asset.TargetHeight = XMLParsingTools.ParseIntAttribute("TargetHeight", item);
					}
					if (item.Attributes["Face"] != null)
					{
						asset.Face = XMLParsingTools.ParseIntAttribute("Face", item);
					}
					AssetTilingMethod value;
					if (item.Attributes["AssetBorder"] != null || item.Attributes["BorderMethod"] != null)
					{
						asset.TilingMethod = ConvertDeprecatedAssetBorder(item.Attributes["AssetBorder"], item.Attributes["BorderMethod"]);
					}
					else if (item.Attributes["TilingMethod"] != null && XMLParsingTools.ParseEnumAttribute<AssetTilingMethod>(item, "TilingMethod", out value))
					{
						asset.TilingMethod = value;
					}
					AutoScalingMode autoScalingMode = AutoScalingMode.None;
					if (item.Attributes["AutoScalingMode"] != null && XMLParsingTools.ParseEnumAttribute<AutoScalingMode>(item, "AutoScalingMode", out var value2))
					{
						autoScalingMode = value2;
					}
					asset.AutoScalingMode = autoScalingMode;
					asset.AssetGroupId = string.Empty;
					if (item.Attributes["GroupId"] != null)
					{
						try
						{
							asset.AssetGroupId = item.Attributes["GroupId"].Value;
						}
						catch (Exception)
						{
							throw new GrInvalidParseAttributeException("GroupId", item);
						}
					}
					if (item.Attributes["Type"] != null && XMLParsingTools.ParseEnumAttribute<AssetType>(item, "Type", out var value3))
					{
						asset.Type = value3;
					}
					for (int i = 0; i < 4; i++)
					{
						string text = "UTiles";
						string text2 = "VTiles";
						string text3 = "MaxUTiles";
						string text4 = "UTileOffset";
						string text5 = "VTileOffset";
						if (i > 0)
						{
							text += i + 1;
							text2 += i + 1;
							text3 += i + 1;
							text4 += i + 1;
							text5 += i + 1;
						}
						if (item.Attributes[text] != null || item.Attributes[text2] != null || item.Attributes[text3] != null)
						{
							if (item.Attributes[text] == null || item.Attributes[text2] == null || item.Attributes[text3] == null)
							{
								throw new GrMissingAttributeException(text + ", " + text2 + " or " + text3, item);
							}
							asset.UDimSettings[i] = new UDimSettings();
							asset.UDimSettings[i].UTiles = XMLParsingTools.ParseIntAttribute(text, item);
							asset.UDimSettings[i].VTiles = XMLParsingTools.ParseIntAttribute(text2, item);
							asset.UDimSettings[i].MaxUTiles = XMLParsingTools.ParseIntAttribute(text3, item);
							if (item.Attributes[text4] != null)
							{
								asset.UDimSettings[i].UTileOffset = XMLParsingTools.ParseIntAttribute(text4, item);
							}
							else
							{
								asset.UDimSettings[i].UTileOffset = 0;
							}
							if (item.Attributes[text5] != null)
							{
								asset.UDimSettings[i].VTileOffset = XMLParsingTools.ParseIntAttribute(text5, item);
							}
							else
							{
								asset.UDimSettings[i].VTileOffset = 0;
							}
						}
					}
					XmlNode xmlNode2 = item.SelectSingleNode("Layers");
					if (xmlNode2 == null)
					{
						throw new GrMissingNodeException("Layers", item);
					}
					XmlNodeList xmlNodeList = xmlNode2.SelectNodes("Layer");
					if (xmlNodeList.Count == 0)
					{
						throw new GrMissingNodeException("Layer", xmlNode2);
					}
					for (int j = 0; j < xmlNodeList.Count; j++)
					{
						XmlNode xmlNode3 = xmlNodeList[j];
						AssetLayer assetLayer = new AssetLayer(j);
						if (xmlNode3.Attributes["QualityProfile"] != null)
						{
							assetLayer.QualityProfile = xmlNode3.Attributes["QualityProfile"].Value;
						}
						if (xmlNode3.Attributes["QualityLevel"] != null)
						{
							assetLayer.QualityProfile = xmlNode3.Attributes["QualityLevel"].Value;
						}
						if (XMLParsingTools.ParseEnumAttribute<Flip>(xmlNode3, "Flip", out var value4))
						{
							assetLayer.Flip = value4;
						}
						for (int k = 0; k < 4; k++)
						{
							string text6 = "Swizzle";
							if (k > 0)
							{
								text6 += k + 1;
							}
							if (xmlNode3.Attributes[text6] != null)
							{
								assetLayer.Swizzle[k] = xmlNode3.Attributes[text6].Value;
							}
							else
							{
								assetLayer.Swizzle[k] = "";
							}
						}
						for (int l = 0; l < 4; l++)
						{
							string text7 = "InvertChannels";
							if (l > 0)
							{
								text7 += l + 1;
							}
							if (xmlNode3.Attributes[text7] != null)
							{
								assetLayer.InvertChannels[l] = xmlNode3.Attributes[text7].Value;
							}
							else
							{
								assetLayer.InvertChannels[l] = "";
							}
						}
						if (xmlNode3.Attributes["Resize"] != null)
						{
							assetLayer.Resize = xmlNode3.Attributes["Resize"].Value;
						}
						if (xmlNode3.Attributes["TargetWidth"] != null)
						{
							assetLayer.TargetWidth = XMLParsingTools.ParseIntAttribute("TargetWidth", xmlNode3);
						}
						if (xmlNode3.Attributes["TargetHeight"] != null)
						{
							assetLayer.TargetHeight = XMLParsingTools.ParseIntAttribute("TargetHeight", xmlNode3);
						}
						if (xmlNode3.Attributes["ResizeMode"] != null && XMLParsingTools.ParseEnumAttribute<AssetLayerResizeMode>(xmlNode3, "ResizeMode", out var value5))
						{
							assetLayer.ResizeMode = value5;
						}
						if (xmlNode3.Attributes["MipSource"] != null)
						{
							XMLParsingTools.ParseEnumAttribute<TextureMipSourceType>(xmlNode3, "MipSource", out var value6);
							assetLayer.MipSourceType = value6;
						}
						for (int m = 0; m < 4; m++)
						{
							string text8 = "TextureType";
							if (m > 0)
							{
								text8 += m + 1;
							}
							if (xmlNode3.Attributes[text8] != null)
							{
								XMLParsingTools.ParseEnumAttribute<TextureType>(xmlNode3, text8, out var value7);
								assetLayer.TextureType[m] = value7;
							}
						}
						if (xmlNode3.Attributes["AssetPackingMode"] != null)
						{
							XMLParsingTools.ParseEnumAttribute<AssetPackingMode>(xmlNode3, "AssetPackingMode", out var value8);
							assetLayer.PackingMode = value8;
						}
						if (xmlNode3.Attributes["ColorSpace"] != null)
						{
							XMLParsingTools.ParseEnumAttribute<ColorSpace>(xmlNode3, "ColorSpace", out var value9);
							assetLayer.ColorSpace = value9;
						}
						foreach (XmlNode item2 in (xmlNode3.SelectSingleNode("Textures") ?? throw new GrMissingNodeException("Textures", xmlNode3)).SelectNodes("Texture"))
						{
							Texture texture = new Texture();
							if (item2.Attributes["Src"] == null)
							{
								throw new GrMissingAttributeException("Src", item2);
							}
							texture.Source = Paths.CleanupURIFilePath(item2.Attributes["Src"].Value);
							if (item2.Attributes["LastChangeDate"] == null)
							{
								throw new GrMissingAttributeException("LastChangeDate", item2);
							}
							texture.LastChangedDate = XMLParsingTools.ParseDateAttribute("LastChangeDate", item2);
							if (item2.Attributes["Row"] != null)
							{
								texture.Row = XMLParsingTools.ParseIntAttribute("Row", item2);
							}
							if (item2.Attributes["Column"] != null)
							{
								texture.Column = XMLParsingTools.ParseIntAttribute("Column", item2);
							}
							if (item2.Attributes["SubIndex"] != null)
							{
								texture.SubIndex = XMLParsingTools.ParseIntAttribute("SubIndex", item2);
							}
							else
							{
								texture.SubIndex = 0;
							}
							if (item2.Attributes["Width"] != null)
							{
								texture.Width = XMLParsingTools.ParseIntAttribute("Width", item2);
							}
							if (item2.Attributes["Height"] != null)
							{
								texture.Height = XMLParsingTools.ParseIntAttribute("Height", item2);
							}
							if (item2.Attributes["ArrayIndex"] != null)
							{
								texture.Face = XMLParsingTools.ParseIntAttribute("ArrayIndex", item2);
							}
							if (item2.Attributes["NumChannels"] != null)
							{
								texture.NumChannels = XMLParsingTools.ParseIntAttribute("NumChannels", item2);
							}
							assetLayer.Textures.Add(texture);
						}
						asset.AssetLayers.Add(assetLayer);
					}
					importedAssets.Add(asset.Id, asset);
				}
			}

			public static void WriteImportedAssets(Dictionary<Guid, Asset> importedAssets, string xpath, ref XmlDocument document)
			{
				if (importedAssets == null || importedAssets.Count() == 0)
				{
					return;
				}
				XmlNode xmlNode = document.CreateElement("ImportedAssets");
				document.SelectSingleNode(xpath).AppendChild(xmlNode);
				foreach (Asset value in importedAssets.Values)
				{
					XmlElement xmlElement = document.CreateElement("Asset");
					xmlElement.SetAttribute("Name", value.Name);
					xmlElement.SetAttribute("GUID", "{" + value.Id.ToString() + "}");
					xmlElement.SetAttribute("Width", value.Width.ToString());
					xmlElement.SetAttribute("Height", value.Height.ToString());
					xmlElement.SetAttribute("TargetWidth", value.TargetWidth.ToString());
					xmlElement.SetAttribute("TargetHeight", value.TargetHeight.ToString());
					xmlElement.SetAttribute("AutoScalingMode", value.AutoScalingMode.ToString());
					if (value.Type == AssetType.CubeMap)
					{
						xmlElement.SetAttribute("Face", value.Face.ToString());
					}
					xmlElement.SetAttribute("TilingMethod", value.TilingMethod.ToString());
					if (value.AssetGroupId != null && !value.AssetGroupId.Equals(string.Empty))
					{
						xmlElement.SetAttribute("GroupId", value.AssetGroupId);
					}
					xmlElement.SetAttribute("Type", value.Type.ToString());
					for (int i = 0; i < 4; i++)
					{
						if (value.UDimSettings[i] != null)
						{
							string text = "UTiles";
							string text2 = "VTiles";
							string text3 = "MaxUTiles";
							string text4 = "UTileOffset";
							string text5 = "VTileOffset";
							if (i > 0)
							{
								text += i + 1;
								text2 += i + 1;
								text3 += i + 1;
								text4 += i + 1;
								text5 += i + 1;
							}
							xmlElement.SetAttribute(text, value.UDimSettings[i].UTiles.ToString());
							xmlElement.SetAttribute(text2, value.UDimSettings[i].VTiles.ToString());
							xmlElement.SetAttribute(text3, value.UDimSettings[i].MaxUTiles.ToString());
							xmlElement.SetAttribute(text4, value.UDimSettings[i].UTileOffset.ToString());
							xmlElement.SetAttribute(text5, value.UDimSettings[i].VTileOffset.ToString());
						}
					}
					XmlElement xmlElement2 = document.CreateElement("Layers");
					foreach (AssetLayer assetLayer in value.AssetLayers)
					{
						XmlElement xmlElement3 = document.CreateElement("Layer");
						xmlElement3.SetAttribute("QualityProfile", assetLayer.QualityProfile);
						for (int j = 0; j < 4; j++)
						{
							string text6 = "Swizzle";
							if (j > 0)
							{
								text6 += j + 1;
							}
							if (!string.IsNullOrEmpty(assetLayer.Swizzle[j]))
							{
								xmlElement3.SetAttribute(text6, assetLayer.Swizzle[j]);
							}
						}
						for (int k = 0; k < 4; k++)
						{
							string text7 = "InvertChannels";
							if (k > 0)
							{
								text7 += k + 1;
							}
							if (!string.IsNullOrEmpty(assetLayer.InvertChannels[k]))
							{
								xmlElement3.SetAttribute(text7, assetLayer.InvertChannels[k]);
							}
						}
						xmlElement3.SetAttribute("Flip", assetLayer.Flip.ToString());
						if (assetLayer.Resize != null)
						{
							xmlElement3.SetAttribute("Resize", assetLayer.Resize);
						}
						xmlElement3.SetAttribute("TargetWidth", assetLayer.TargetWidth.ToString());
						xmlElement3.SetAttribute("TargetHeight", assetLayer.TargetHeight.ToString());
						xmlElement3.SetAttribute("ResizeMode", assetLayer.ResizeMode.ToString());
						xmlElement3.SetAttribute("MipSource", assetLayer.MipSourceType.ToString());
						for (int l = 0; l < 4; l++)
						{
							string text8 = "TextureType";
							if (l > 0)
							{
								text8 += l + 1;
							}
							if (assetLayer.TextureType[l] != 0)
							{
								xmlElement3.SetAttribute(text8, assetLayer.TextureType[l].ToString());
							}
						}
						if (assetLayer.ColorSpace != 0)
						{
							xmlElement3.SetAttribute("ColorSpace", assetLayer.ColorSpace.ToString());
						}
						XmlElement xmlElement4 = document.CreateElement("Textures");
						bool flag = assetLayer.Textures.Count > 1;
						foreach (Texture texture in assetLayer.Textures)
						{
							XmlElement xmlElement5 = document.CreateElement("Texture");
							xmlElement5.SetAttribute("Src", texture.Source);
							if (flag)
							{
								xmlElement5.SetAttribute("Row", texture.Row.ToString());
								xmlElement5.SetAttribute("Column", texture.Column.ToString());
							}
							xmlElement5.SetAttribute("SubIndex", texture.SubIndex.ToString());
							xmlElement5.SetAttribute("Width", texture.Width.ToString());
							xmlElement5.SetAttribute("Height", texture.Height.ToString());
							xmlElement5.SetAttribute("ArrayIndex", texture.Face.ToString());
							xmlElement5.SetAttribute("LastChangeDate", DateTimeManagement.SerializeDateTimeToString(texture.LastChangedDate));
							xmlElement5.SetAttribute("NumChannels", texture.NumChannels.ToString());
							xmlElement4.AppendChild(xmlElement5);
						}
						xmlElement3.SetAttribute("AssetPackingMode", assetLayer.PackingMode.ToString());
						xmlElement3.AppendChild(xmlElement4);
						xmlElement2.AppendChild(xmlElement3);
					}
					xmlElement.AppendChild(xmlElement2);
					xmlNode.AppendChild(xmlElement);
				}
			}

			public static void WriteImportAssets(List<ImportAsset> importAssets, string xpath, ref XmlDocument document)
			{
				if (importAssets == null || importAssets.Count() == 0)
				{
					return;
				}
				XmlNode xmlNode = document.CreateElement("Imports");
				document.SelectSingleNode(xpath).AppendChild(xmlNode);
				foreach (ImportAsset importAsset in importAssets)
				{
					XmlElement xmlElement = document.CreateElement("Import");
					xmlElement.SetAttribute("Name", importAsset.Name);
					xmlElement.SetAttribute("Type", importAsset.Type.ToString());
					xmlElement.SetAttribute("TilingMethod", importAsset.TilingMethod.ToString());
					xmlElement.SetAttribute("AutoScalingMode", importAsset.AutoScalingMode.ToString());
					xmlElement.SetAttribute("TargetWidth", importAsset.TargetWidth.ToString());
					xmlElement.SetAttribute("TargetHeight", importAsset.TargetHeight.ToString());
					foreach (ImportAssetLayer layer in importAsset.Layers)
					{
						XmlElement xmlElement2 = document.CreateElement("LayerTexture");
						xmlElement2.SetAttribute("QualityProfile", layer.QualityProfile);
						for (int i = 0; i < 4; i++)
						{
							string text = "Swizzle";
							if (i > 0)
							{
								text += i + 1;
							}
							if (!string.IsNullOrEmpty(layer.Swizzle[i]))
							{
								xmlElement2.SetAttribute(text, layer.Swizzle[i]);
							}
						}
						for (int j = 0; j < 4; j++)
						{
							string text2 = "InvertChannels";
							if (j > 0)
							{
								text2 += j + 1;
							}
							if (!string.IsNullOrEmpty(layer.InvertChannels[j]))
							{
								xmlElement2.SetAttribute(text2, layer.InvertChannels[j]);
							}
						}
						xmlElement2.SetAttribute("Flip", layer.Flip.ToString());
						foreach (CombinedTextureSource.Item source in layer.Source.Sources)
						{
							if (!string.IsNullOrEmpty(source.Source))
							{
								string text3 = "Src";
								if (source.SubIndex != 0)
								{
									text3 += source.SubIndex + 1;
								}
								xmlElement2.SetAttribute(text3, source.Source);
							}
						}
						xmlElement2.SetAttribute("AssetPackingMode", layer.PackingMode.ToString());
						if (layer.Resize != null)
						{
							xmlElement2.SetAttribute("Resize", layer.Resize);
						}
						xmlElement2.SetAttribute("TargetWidth", layer.TargetWidth.ToString());
						xmlElement2.SetAttribute("TargetHeight", layer.TargetHeight.ToString());
						xmlElement2.SetAttribute("ResizeMode", layer.ResizeMode.ToString());
						xmlElement2.SetAttribute("MipSource", layer.MipSourceType.ToString());
						if (layer.ColorSpace != 0)
						{
							xmlElement2.SetAttribute("ColorSpace", layer.ColorSpace.ToString());
						}
						xmlElement.AppendChild(xmlElement2);
					}
					xmlNode.AppendChild(xmlElement);
				}
			}

			public static void ReadTileLayout(XmlNode tileLayoutNode, out TileLayout outTileLayout)
			{
				if (tileLayoutNode.Attributes["Width"] == null || tileLayoutNode.Attributes["Height"] == null || tileLayoutNode.Attributes["Border"] == null)
				{
					throw new GrMissingAttributeException("Width, Height or Border", tileLayoutNode);
				}
				TileLayout tileLayout = default(TileLayout);
				tileLayout.tileWidth = XMLParsingTools.ParseUIntAttribute("Width", tileLayoutNode);
				tileLayout.tileHeight = XMLParsingTools.ParseUIntAttribute("Height", tileLayoutNode);
				tileLayout.borderSize = XMLParsingTools.ParseUIntAttribute("Border", tileLayoutNode);
				outTileLayout = tileLayout;
			}

			public static void WriteTileLayout(TileLayout tileLayout, string xpath, ref XmlDocument document)
			{
				TileLayout tileLayout2 = TileLayout.ResolveDefaults(tileLayout);
				XmlElement xmlElement = document.CreateElement("TileLayout");
				xmlElement.SetAttribute("Width", tileLayout2.tileWidth.ToString());
				xmlElement.SetAttribute("Height", tileLayout2.tileHeight.ToString());
				xmlElement.SetAttribute("Border", tileLayout2.borderSize.ToString());
				document.SelectSingleNode(xpath).AppendChild(xmlElement);
			}

			public static void ReadTileSetConfig(XmlNode tileSetConfigNode, out TileSetConfig tileSetConfig)
			{
				tileSetConfig = new TileSetConfig();
				if (tileSetConfigNode.Attributes["LastChangedDate"] == null)
				{
					throw new GrMissingAttributeException("LastChangedDate", tileSetConfigNode);
				}
				tileSetConfig.LastChangedDate = XMLParsingTools.ParseDateAttribute("LastChangedDate", tileSetConfigNode);
				XmlNode tileLayoutNode = tileSetConfigNode.SelectSingleNode("TileLayout") ?? throw new GrMissingNodeException("TileLayout", tileSetConfigNode);
				TileLayout outTileLayout = default(TileLayout);
				ReadTileLayout(tileLayoutNode, out outTileLayout);
				tileSetConfig.TileLayout = outTileLayout;
				XmlNode xmlNode = tileSetConfigNode.SelectSingleNode("Width");
				if (xmlNode != null)
				{
					tileSetConfig.Width = XMLParsingTools.ParseIntInner(xmlNode);
				}
				XmlNode xmlNode2 = tileSetConfigNode.SelectSingleNode("Height");
				if (xmlNode2 != null)
				{
					tileSetConfig.Height = XMLParsingTools.ParseIntInner(xmlNode2);
				}
				XmlNode xmlNode3 = tileSetConfigNode.SelectSingleNode("Layers");
				if (xmlNode3 != null)
				{
					tileSetConfig.LayerCount = XMLParsingTools.ParseIntInner(xmlNode3);
				}
			}

			public static void WriteTileSetConfig(TileSetConfig tileSetConfig, string xpath, ref XmlDocument document)
			{
				if (tileSetConfig != null)
				{
					XmlElement xmlElement = document.CreateElement("TileSetConfig");
					document.SelectSingleNode(xpath).AppendChild(xmlElement);
					xmlElement.SetAttribute("LastChangedDate", DateTimeManagement.SerializeDateTimeToString(tileSetConfig.LastChangedDate));
					WriteTileLayout(tileSetConfig.TileLayout, "/BuildState/TileSetConfig", ref document);
					XmlNode xmlNode = document.CreateElement("Width");
					xmlNode.InnerText = tileSetConfig.Width.ToString();
					xmlElement.AppendChild(xmlNode);
					XmlNode xmlNode2 = document.CreateElement("Height");
					xmlNode2.InnerText = tileSetConfig.Height.ToString();
					xmlElement.AppendChild(xmlNode2);
					XmlNode xmlNode3 = document.CreateElement("Layers");
					xmlNode3.InnerText = tileSetConfig.LayerCount.ToString();
					xmlElement.AppendChild(xmlNode3);
				}
			}

			public static void ReadPackedAssets(XmlNode packedAssetsNode, out PackingSummary packingSummary, out List<PackedAsset> packedAssets)
			{
				if (packedAssetsNode.Attributes["PackedWidth"] == null || packedAssetsNode.Attributes["PackedHeight"] == null || packedAssetsNode.Attributes["LastChangedDate"] == null)
				{
					throw new GrMissingAttributeException("PackedWidth, PackedHeight or LastChangedDate", packedAssetsNode);
				}
				packingSummary = new PackingSummary();
				packingSummary.PackedWidth = XMLParsingTools.ParseIntAttribute("PackedWidth", packedAssetsNode);
				packingSummary.PackedHeight = XMLParsingTools.ParseIntAttribute("PackedHeight", packedAssetsNode);
				packingSummary.LastChangedDate = XMLParsingTools.ParseDateAttribute("LastChangedDate", packedAssetsNode);
				packedAssets = new List<PackedAsset>();
				foreach (XmlNode item in packedAssetsNode.SelectNodes("PackedAsset"))
				{
					PackedAsset packedAsset = new PackedAsset();
					if (item.Attributes["GUID"] == null || item.Attributes["X"] == null || item.Attributes["Y"] == null || item.Attributes["Width"] == null || item.Attributes["Height"] == null || item.Attributes["PackedDate"] == null)
					{
						throw new GrMissingAttributeException("GUID, X, Y, Width, Height or PackedDate", item);
					}
					packedAsset.X = XMLParsingTools.ParseIntAttribute("X", item);
					packedAsset.Y = XMLParsingTools.ParseIntAttribute("Y", item);
					packedAsset.Width = XMLParsingTools.ParseIntAttribute("Width", item);
					packedAsset.Height = XMLParsingTools.ParseIntAttribute("Height", item);
					packedAsset.AssetId = XMLParsingTools.ParseGuidAttribute("GUID", item);
					packedAsset.PackedDate = XMLParsingTools.ParseDateAttribute("PackedDate", item);
					packedAssets.Add(packedAsset);
				}
			}

			public static void WritePackedAssets(PackingSummary packingSummary, List<PackedAsset> packedAssets, string xpath, ref XmlDocument document)
			{
				if (packingSummary == null || packedAssets == null || packedAssets.Count() == 0)
				{
					return;
				}
				XmlElement xmlElement = document.CreateElement("PackedAssets");
				document.SelectSingleNode(xpath).AppendChild(xmlElement);
				xmlElement.SetAttribute("PackedWidth", packingSummary.PackedWidth.ToString());
				xmlElement.SetAttribute("PackedHeight", packingSummary.PackedHeight.ToString());
				xmlElement.SetAttribute("LastChangedDate", DateTimeManagement.SerializeDateTimeToString(packingSummary.LastChangedDate));
				foreach (PackedAsset packedAsset in packedAssets)
				{
					XmlElement xmlElement2 = document.CreateElement("PackedAsset");
					xmlElement2.SetAttribute("GUID", "{" + packedAsset.AssetId.ToString() + "}");
					xmlElement2.SetAttribute("PackedDate", DateTimeManagement.SerializeDateTimeToString(packedAsset.PackedDate));
					xmlElement2.SetAttribute("X", packedAsset.X.ToString());
					xmlElement2.SetAttribute("Y", packedAsset.Y.ToString());
					xmlElement2.SetAttribute("Width", packedAsset.Width.ToString());
					xmlElement2.SetAttribute("Height", packedAsset.Height.ToString());
					xmlElement.AppendChild(xmlElement2);
				}
			}

			public static void ReadCompositor(XmlNode compositorNode, out CompositorSummary summary, out List<CompositedAsset> composited)
			{
				if (compositorNode.Attributes["LastChangedDate"] == null)
				{
					throw new GrMissingAttributeException("LastChangedDate", compositorNode);
				}
				summary = new CompositorSummary();
				summary.LastChangedDate = XMLParsingTools.ParseDateAttribute("LastChangedDate", compositorNode);
				composited = new List<CompositedAsset>();
				foreach (XmlNode item in compositorNode.SelectNodes("SetAsset"))
				{
					if (item.Attributes["GUID"] == null || item.Attributes["X"] == null || item.Attributes["Y"] == null || item.Attributes["Width"] == null || item.Attributes["Height"] == null || item.Attributes["CompositedDate"] == null)
					{
						throw new GrMissingAttributeException("GUID, X, Y, Width, Height or CompositedDate", item);
					}
					CompositedAsset compositedAsset = new CompositedAsset();
					compositedAsset.X = XMLParsingTools.ParseIntAttribute("X", item);
					compositedAsset.Y = XMLParsingTools.ParseIntAttribute("Y", item);
					compositedAsset.Width = XMLParsingTools.ParseIntAttribute("Width", item);
					compositedAsset.Height = XMLParsingTools.ParseIntAttribute("Height", item);
					compositedAsset.AssetId = XMLParsingTools.ParseGuidAttribute("GUID", item);
					compositedAsset.CompositedDate = XMLParsingTools.ParseDateAttribute("CompositedDate", item);
					AssetTilingMethod value;
					if (item.Attributes["AssetBorder"] != null || item.Attributes["BorderMethod"] != null)
					{
						compositedAsset.TilingMethod = ConvertDeprecatedAssetBorder(item.Attributes["AssetBorder"], item.Attributes["BorderMethod"]);
					}
					else if (item.Attributes["TilingMethod"] != null && XMLParsingTools.ParseEnumAttribute<AssetTilingMethod>(item, "TilingMethod", out value))
					{
						compositedAsset.TilingMethod = value;
					}
					if (item.SelectNodes("Layer").Count == 0)
					{
						throw new GrMissingNodeException("Layer", item);
					}
					compositedAsset.Layers = new List<CompositedAssetLayer>();
					foreach (XmlNode item2 in item.SelectNodes("Layer"))
					{
						CompositedAssetLayer compositedAssetLayer = new CompositedAssetLayer();
						compositedAssetLayer.Textures = new List<CompositedTexture>();
						foreach (XmlNode item3 in item2.SelectNodes("CompositedTexture"))
						{
							if (item3.Attributes["X"] == null || item3.Attributes["Y"] == null || item3.Attributes["Width"] == null || item3.Attributes["Height"] == null || item3.Attributes["CompositedDate"] == null)
							{
								throw new GrMissingAttributeException("X, Y, Width, Height or CompositedDate", item3);
							}
							int x = XMLParsingTools.ParseIntAttribute("X", item3);
							int y = XMLParsingTools.ParseIntAttribute("Y", item3);
							int width = XMLParsingTools.ParseIntAttribute("Width", item3);
							int height = XMLParsingTools.ParseIntAttribute("Height", item3);
							DateTime time = XMLParsingTools.ParseDateAttribute("CompositedDate", item3);
							compositedAssetLayer.Textures.Add(new CompositedTexture(x, y, width, height, time));
						}
						compositedAssetLayer.Thumbnail = XMLParsingTools.ParseGuidAttribute("Thumbnail", item2);
						compositedAsset.Layers.Add(compositedAssetLayer);
					}
					composited.Add(compositedAsset);
				}
			}

			public static void WriteCompositor(CompositorSummary summary, List<CompositedAsset> composited, string xpath, ref XmlDocument document)
			{
				if (composited == null || composited.Count() == 0 || summary == null)
				{
					return;
				}
				XmlElement xmlElement = document.CreateElement("Compositor");
				document.SelectSingleNode(xpath).AppendChild(xmlElement);
				xmlElement.SetAttribute("LastChangedDate", DateTimeManagement.SerializeDateTimeToString(summary.LastChangedDate));
				foreach (CompositedAsset item in composited)
				{
					XmlElement xmlElement2 = document.CreateElement("SetAsset");
					xmlElement2.SetAttribute("GUID", "{" + item.AssetId.ToString() + "}");
					xmlElement2.SetAttribute("CompositedDate", DateTimeManagement.SerializeDateTimeToString(item.CompositedDate));
					xmlElement2.SetAttribute("X", item.X.ToString());
					xmlElement2.SetAttribute("Y", item.Y.ToString());
					xmlElement2.SetAttribute("Width", item.Width.ToString());
					xmlElement2.SetAttribute("Height", item.Height.ToString());
					xmlElement2.SetAttribute("TilingMethod", item.TilingMethod.ToString());
					xmlElement.AppendChild(xmlElement2);
					foreach (CompositedAssetLayer layer in item.Layers)
					{
						XmlElement xmlElement3 = document.CreateElement("Layer");
						xmlElement2.AppendChild(xmlElement3);
						xmlElement3.SetAttribute("Thumbnail", layer.Thumbnail.ToString());
						foreach (CompositedTexture texture in layer.Textures)
						{
							XmlElement xmlElement4 = document.CreateElement("CompositedTexture");
							xmlElement4.SetAttribute("X", texture.X.ToString());
							xmlElement4.SetAttribute("Y", texture.Y.ToString());
							xmlElement4.SetAttribute("Width", texture.Width.ToString());
							xmlElement4.SetAttribute("Height", texture.Height.ToString());
							xmlElement4.SetAttribute("CompositedDate", DateTimeManagement.SerializeDateTimeToString(texture.LastChangedDate));
							xmlElement3.AppendChild(xmlElement4);
						}
					}
				}
			}

			public static void ReadBuilder(XmlNode builderNode, out BuilderSummary summary, out Dictionary<Guid, BuildAsset> buildAssets)
			{
				if (builderNode.Attributes["LastChangedDate"] == null || builderNode.Attributes["PageSize"] == null || builderNode.Attributes["PagesDirectory"] == null)
				{
					throw new GrMissingAttributeException("LastChangedDate, PageSize or PagesDirectory", builderNode);
				}
				summary = new BuilderSummary();
				summary.PageSize = XMLParsingTools.ParseIntAttribute("PageSize", builderNode);
				summary.PagesDirectory = builderNode.Attributes["PagesDirectory"].Value;
				summary.LastChangedDate = XMLParsingTools.ParseDateAttribute("LastChangedDate", builderNode);
				summary.AutoPageSize = XMLParsingTools.ParseBoolAttribute("AutoPageSize", builderNode);
				if (builderNode.Attributes["PagingStrategy"] != null && XMLParsingTools.ParseEnumAttribute<PagingStrategy>(builderNode, "PagingStrategy", out var value))
				{
					summary.PagingStrategy = value;
				}
				if (builderNode.Attributes["BlockSize"] != null)
				{
					summary.BlockSize = XMLParsingTools.ParseUIntAttribute("BlockSize", builderNode);
				}
				if (builderNode.Attributes["GtsGUID"] != null)
				{
					summary.GtsGuid = XMLParsingTools.ParseGuidAttribute("GtsGUID", builderNode);
				}
				if (builderNode.Attributes["TargetDisk"] != null)
				{
					XMLParsingTools.ParseEnumAttribute<TargetDisk>(builderNode, "TargetDisk", out var value2);
					summary.TargetDisk = value2;
				}
				buildAssets = new Dictionary<Guid, BuildAsset>();
				foreach (XmlNode item in builderNode.SelectNodes("BuildAsset"))
				{
					if (item.Attributes["GUID"] == null || item.Attributes["X"] == null || item.Attributes["Y"] == null || item.Attributes["Width"] == null || item.Attributes["Height"] == null || item.Attributes["BuildDate"] == null)
					{
						throw new GrMissingAttributeException("GUID, X, Y, Width, Height or BuildDate", item);
					}
					BuildAsset buildAsset = new BuildAsset();
					buildAsset.X = XMLParsingTools.ParseIntAttribute("X", item);
					buildAsset.Y = XMLParsingTools.ParseIntAttribute("Y", item);
					buildAsset.Width = XMLParsingTools.ParseIntAttribute("Width", item);
					buildAsset.Height = XMLParsingTools.ParseIntAttribute("Height", item);
					buildAsset.AssetId = XMLParsingTools.ParseGuidAttribute("GUID", item);
					buildAsset.BuildDate = XMLParsingTools.ParseDateAttribute("BuildDate", item);
					if (item.Attributes["GTexLastChangeDate"] != null)
					{
						buildAsset.GTexLastChangeDate = XMLParsingTools.ParseDateAttribute("GTexLastChangeDate", item);
					}
					buildAssets.Add(buildAsset.AssetId, buildAsset);
				}
			}

			public static void WriteBuilder(BuilderSummary summary, Dictionary<Guid, BuildAsset> buildAssets, string xpath, ref XmlDocument document)
			{
				if (summary == null || summary.LastChangedDate == default(DateTime))
				{
					return;
				}
				XmlElement xmlElement = document.CreateElement("TileSetBuilder");
				document.SelectSingleNode(xpath).AppendChild(xmlElement);
				xmlElement.SetAttribute("LastChangedDate", DateTimeManagement.SerializeDateTimeToString(summary.LastChangedDate));
				xmlElement.SetAttribute("AutoPageSize", summary.AutoPageSize.ToString());
				xmlElement.SetAttribute("PageSize", summary.PageSize.ToString());
				xmlElement.SetAttribute("PagingStrategy", summary.PagingStrategy.ToString());
				xmlElement.SetAttribute("PagesDirectory", summary.PagesDirectory);
				xmlElement.SetAttribute("BlockSize", summary.BlockSize.ToString());
				xmlElement.SetAttribute("GtsGUID", "{" + summary.GtsGuid.ToString() + "}");
				xmlElement.SetAttribute("TargetDisk", summary.TargetDisk.ToString());
				foreach (BuildAsset value in buildAssets.Values)
				{
					XmlElement xmlElement2 = document.CreateElement("BuildAsset");
					xmlElement2.SetAttribute("GUID", "{" + value.AssetId.ToString() + "}");
					xmlElement2.SetAttribute("BuildDate", DateTimeManagement.SerializeDateTimeToString(value.BuildDate));
					xmlElement2.SetAttribute("X", value.X.ToString());
					xmlElement2.SetAttribute("Y", value.Y.ToString());
					xmlElement2.SetAttribute("Width", value.Width.ToString());
					xmlElement2.SetAttribute("Height", value.Height.ToString());
					xmlElement2.SetAttribute("GTexLastChangeDate", DateTimeManagement.SerializeDateTimeToString(value.GTexLastChangeDate));
					xmlElement.AppendChild(xmlElement2);
				}
			}

			public static void WriteSoupedAssets(SoupBuilderSummary summary, IEnumerable<SoupedAsset> soupedAssets, string xpath, ref XmlDocument document)
			{
				if (summary == null || soupedAssets == null || soupedAssets.Count() == 0)
				{
					return;
				}
				XmlElement xmlElement = document.CreateElement("TileSoupBuilder");
				document.SelectSingleNode(xpath).AppendChild(xmlElement);
				xmlElement.SetAttribute("LastChangedDate", DateTimeManagement.SerializeDateTimeToString(summary.LastChangedDate));
				foreach (SoupedAsset soupedAsset in soupedAssets)
				{
					XmlElement xmlElement2 = document.CreateElement("SoupedAsset");
					xmlElement2.SetAttribute("GUID", "{" + soupedAsset.AssetId.ToString() + "}");
					xmlElement2.SetAttribute("SoupedDate", DateTimeManagement.SerializeDateTimeToString(soupedAsset.SoupedDate));
					xmlElement2.SetAttribute("X", soupedAsset.X.ToString());
					xmlElement2.SetAttribute("Y", soupedAsset.Y.ToString());
					xmlElement2.SetAttribute("Width", soupedAsset.Width.ToString());
					xmlElement2.SetAttribute("Height", soupedAsset.Height.ToString());
					xmlElement2.SetAttribute("TilingMethod", soupedAsset.TilingMethod.ToString());
					xmlElement.AppendChild(xmlElement2);
					foreach (SoupedAssetLayer layer in soupedAsset.Layers)
					{
						XmlElement xmlElement3 = document.CreateElement("Layer");
						xmlElement2.AppendChild(xmlElement3);
						xmlElement3.SetAttribute("Thumbnail", layer.Thumbnail.ToString());
						xmlElement3.SetAttribute("FixedTexFormat", layer.FixedTexFormat.ToString());
						foreach (SoupedTexture texture in layer.Textures)
						{
							XmlElement xmlElement4 = document.CreateElement("SoupedTexture");
							xmlElement4.SetAttribute("X", texture.X.ToString());
							xmlElement4.SetAttribute("Y", texture.Y.ToString());
							xmlElement4.SetAttribute("Width", texture.Width.ToString());
							xmlElement4.SetAttribute("Height", texture.Height.ToString());
							xmlElement4.SetAttribute("SoupedDate", DateTimeManagement.SerializeDateTimeToString(texture.LastChangedDate));
							xmlElement3.AppendChild(xmlElement4);
						}
					}
				}
			}

			public static void ReadSoupedAssets(XmlNode soupedAssetsNode, out SoupBuilderSummary summary, out Dictionary<Guid, SoupedAsset> soupedAssets)
			{
				soupedAssets = new Dictionary<Guid, SoupedAsset>();
				if (soupedAssetsNode.Attributes["LastChangedDate"] == null)
				{
					throw new GrMissingAttributeException("LastChangedDate", soupedAssetsNode);
				}
				summary = new SoupBuilderSummary();
				summary.LastChangedDate = XMLParsingTools.ParseDateAttribute("LastChangedDate", soupedAssetsNode);
				foreach (XmlNode item in soupedAssetsNode.SelectNodes("SoupedAsset"))
				{
					if (item.Attributes["GUID"] == null || item.Attributes["X"] == null || item.Attributes["Y"] == null || item.Attributes["Width"] == null || item.Attributes["Height"] == null || item.Attributes["SoupedDate"] == null)
					{
						throw new GrMissingAttributeException("GUID, X, Y, Width, Height or SoupedDate", item);
					}
					SoupedAsset soupedAsset = new SoupedAsset();
					soupedAsset.X = XMLParsingTools.ParseIntAttribute("X", item);
					soupedAsset.Y = XMLParsingTools.ParseIntAttribute("Y", item);
					soupedAsset.Width = XMLParsingTools.ParseIntAttribute("Width", item);
					soupedAsset.Height = XMLParsingTools.ParseIntAttribute("Height", item);
					soupedAsset.AssetId = XMLParsingTools.ParseGuidAttribute("GUID", item);
					soupedAsset.SoupedDate = XMLParsingTools.ParseDateAttribute("SoupedDate", item);
					AssetTilingMethod value;
					if (item.Attributes["AssetBorder"] != null || item.Attributes["BorderMethod"] != null)
					{
						soupedAsset.TilingMethod = ConvertDeprecatedAssetBorder(item.Attributes["AssetBorder"], item.Attributes["BorderMethod"]);
					}
					else if (item.Attributes["TilingMethod"] != null && XMLParsingTools.ParseEnumAttribute<AssetTilingMethod>(item, "TilingMethod", out value))
					{
						soupedAsset.TilingMethod = value;
					}
					soupedAsset.Layers = new List<SoupedAssetLayer>();
					foreach (XmlNode item2 in item.SelectNodes("Layer"))
					{
						SoupedAssetLayer soupedAssetLayer = new SoupedAssetLayer();
						soupedAssetLayer.Thumbnail = XMLParsingTools.ParseGuidAttribute("Thumbnail", item2);
						if (XMLParsingTools.ParseEnumAttribute<FixedTexFormat>(item2, "FixedTexFormat", out var value2))
						{
							soupedAssetLayer.FixedTexFormat = value2;
						}
						soupedAssetLayer.Textures = new List<SoupedTexture>();
						foreach (XmlNode item3 in item2.SelectNodes("SoupedTexture"))
						{
							if (item3.Attributes["X"] == null || item3.Attributes["Y"] == null || item3.Attributes["Width"] == null || item3.Attributes["Height"] == null || item3.Attributes["SoupedDate"] == null)
							{
								throw new GrMissingAttributeException("X, Y, Width, Height or SoupedDate", item3);
							}
							int x = XMLParsingTools.ParseIntAttribute("X", item3);
							int y = XMLParsingTools.ParseIntAttribute("Y", item3);
							int width = XMLParsingTools.ParseIntAttribute("Width", item3);
							int height = XMLParsingTools.ParseIntAttribute("Height", item3);
							DateTime time = XMLParsingTools.ParseDateAttribute("SoupedDate", item3);
							soupedAssetLayer.Textures.Add(new SoupedTexture(x, y, width, height, time));
						}
						soupedAsset.Layers.Add(soupedAssetLayer);
					}
					soupedAssets.Add(soupedAsset.AssetId, soupedAsset);
				}
			}
		}

		public static void ReadProject(string filename, out Project project, ProjectBuilder builder)
		{
			ConfigXmlDocument configXmlDocument = new ConfigXmlDocument();
			configXmlDocument.Load(filename);
			project = new Project(builder);
			if (configXmlDocument.SelectSingleNode("/Project") == null)
			{
				throw new GrMissingNodeException("Project");
			}
			XmlNode xmlNode = configXmlDocument.SelectSingleNode("/Project");
			if (xmlNode != null && xmlNode.Attributes["Name"] != null)
			{
				project.Name = xmlNode.Attributes["Name"].Value;
			}
			if (xmlNode != null && xmlNode.Attributes["Guid"] != null)
			{
				project.Id = XMLParsingTools.ParseGuidAttribute("Guid", xmlNode);
			}
			if (xmlNode != null && xmlNode.Attributes["BuildProfile"] != null)
			{
				project.BuildProfile = xmlNode.Attributes["BuildProfile"].Value;
			}
			XmlNode xmlNode2 = configXmlDocument.SelectSingleNode("/Project");
			if (xmlNode2 != null && xmlNode2.Attributes["GrBuildVersion"] != null)
			{
				project.Version = Version.Parse(xmlNode2.Attributes["GrBuildVersion"].Value);
				Version projectCompatibilityVersion = Constants.Version.ProjectCompatibilityVersion;
				if (!projectCompatibilityVersion.IsMajorCompatible(project.Version))
				{
					throw new GrInvalidProjectCompatibilityVersionException(project.Version, projectCompatibilityVersion);
				}
			}
			XmlNode xmlNode3 = configXmlDocument.SelectSingleNode("/Project/LayerConfig");
			if (xmlNode3 != null)
			{
				XMLEngineTools.ReadLayerConfig(xmlNode3, out var layerConfig);
				project.LayerConfiguration = layerConfig;
			}
			XmlNode xmlNode4 = configXmlDocument.SelectSingleNode("/Project/BuildConfig");
			if (xmlNode4 != null)
			{
				XMLEngineTools.ReadBuildConfig(xmlNode4, out var buildConfig);
				project.BuildConfiguration = buildConfig;
			}
			XmlNode xmlNode5 = configXmlDocument.SelectSingleNode("/Project/ImportedAssets");
			if (xmlNode5 != null)
			{
				XMLEngineTools.ReadImportedAssets(xmlNode5, out var importedAssets);
				project.Assets = importedAssets;
			}
		}

		public static void WriteProject(string filename, Project project)
		{
			XmlDocument document = new XmlDocument();
			document.AppendChild(document.CreateXmlDeclaration("1.0", "UTF-8", null));
			XmlElement xmlElement = document.CreateElement("Project");
			xmlElement.SetAttribute("Name", project.Name);
			xmlElement.SetAttribute("Guid", project.Id.ToString());
			xmlElement.SetAttribute("GrBuildVersion", Constants.Version.ProjectCompatibilityVersion.ToString());
			xmlElement.SetAttribute("BuildProfile", project.BuildProfile);
			document.AppendChild(xmlElement);
			XMLEngineTools.WriteBuildConfig(project.BuildConfiguration, "/Project", ref document);
			XMLEngineTools.WriteLayerConfig(project.LayerConfiguration, "/Project", ref document);
			XMLEngineTools.WriteImportedAssets(project.Assets, "/Project", ref document);
			filename.Replace("\\", "/");
			document.Save(filename);
		}

		public static string WriteProjectToString(Project project)
		{
			StringWriter stringWriter = new StringWriter();
			XmlTextWriter w = new XmlTextWriter(stringWriter)
			{
				Formatting = Formatting.Indented
			};
			XmlDocument document = new XmlDocument();
			document.AppendChild(document.CreateXmlDeclaration("1.0", "UTF-8", null));
			XmlElement xmlElement = document.CreateElement("Project");
			xmlElement.SetAttribute("Name", project.Name);
			xmlElement.SetAttribute("Guid", project.Id.ToString());
			xmlElement.SetAttribute("GrBuildVersion", Constants.Version.ProjectCompatibilityVersion.ToString());
			xmlElement.SetAttribute("BuildProfile", project.BuildProfile);
			document.AppendChild(xmlElement);
			XMLEngineTools.WriteBuildConfig(project.BuildConfiguration, "/Project", ref document);
			XMLEngineTools.WriteLayerConfig(project.LayerConfiguration, "/Project", ref document);
			XMLEngineTools.WriteImportedAssets(project.Assets, "/Project", ref document);
			document.WriteTo(w);
			return stringWriter.ToString();
		}

		public static void ReadSoupState(string soupStateXml, out BuildState.SoupState soupState)
		{
			soupState = new BuildState.SoupState();
			ConfigXmlDocument configXmlDocument = new ConfigXmlDocument();
			configXmlDocument.LoadXml(soupStateXml);
			XmlNode xmlNode = configXmlDocument.SelectSingleNode("/BuildState");
			if (xmlNode != null && xmlNode.Attributes["ProjectGuid"] != null)
			{
				soupState.ProjectId = XMLParsingTools.ParseGuidAttribute("ProjectGuid", xmlNode);
			}
			Guid assetId = Guid.Empty;
			XmlNode xmlNode2 = configXmlDocument.SelectSingleNode("/BuildState");
			if (xmlNode2 != null && xmlNode2.Attributes["AssetGuid"] != null)
			{
				assetId = XMLParsingTools.ParseGuidAttribute("AssetGuid", xmlNode2);
			}
			if (assetId.Equals(Guid.Empty))
			{
				return;
			}
			soupState.AssetId = assetId;
			XmlNode xmlNode3 = configXmlDocument.SelectSingleNode("/BuildState/TileSoupBuilder");
			if (xmlNode3 != null)
			{
				XMLEngineTools.ReadSoupedAssets(xmlNode3, out var summary, out var soupedAssets);
				foreach (Guid key in soupedAssets.Keys)
				{
					soupState.SoupedAssets.Add(key, soupedAssets[key]);
				}
				soupState.SoupBuilderSummary = summary;
			}
			XmlNode xmlNode4 = configXmlDocument.SelectSingleNode("/BuildState/ImportedAssets");
			if (xmlNode4 != null)
			{
				XMLEngineTools.ReadImportedAssets(xmlNode4, out var importedAssets);
				foreach (Guid key2 in importedAssets.Keys)
				{
					soupState.Assets.Add(key2, importedAssets[key2]);
				}
			}
			XmlNode xmlNode5 = configXmlDocument.SelectSingleNode("/BuildState/LayerConfig");
			if (xmlNode5 != null)
			{
				XMLEngineTools.ReadLayerConfig(xmlNode5, out var layerConfig);
				soupState.LayerConfig = layerConfig;
			}
			XmlNode xmlNode6 = configXmlDocument.SelectSingleNode("/BuildState/TileLayout");
			if (xmlNode6 != null)
			{
				TileLayout outTileLayout = default(TileLayout);
				XMLEngineTools.ReadTileLayout(xmlNode6, out outTileLayout);
				soupState.TileLayout = outTileLayout;
			}
		}

		public static void ReadCompositeBuildState(string filename, out BuildState.CompositeState compState)
		{
			compState = new BuildState.CompositeState();
			ConfigXmlDocument configXmlDocument = new ConfigXmlDocument();
			configXmlDocument.Load(filename);
			Guid assetId = Guid.Empty;
			XmlNode xmlNode = configXmlDocument.SelectSingleNode("/BuildState");
			if (xmlNode != null && xmlNode.Attributes["AssetGuid"] != null)
			{
				assetId = XMLParsingTools.ParseGuidAttribute("AssetGuid", xmlNode);
			}
			if (assetId.Equals(Guid.Empty))
			{
				return;
			}
			compState.XMLFileName = filename;
			compState.AssetId = assetId;
			XmlNode xmlNode2 = configXmlDocument.SelectSingleNode("/BuildState/PackedAssets");
			if (xmlNode2 != null)
			{
				XMLEngineTools.ReadPackedAssets(xmlNode2, out var packingSummary, out var packedAssets);
				compState.PackingSummary = packingSummary;
				compState.PackedAssets = packedAssets;
			}
			XmlNode xmlNode3 = configXmlDocument.SelectSingleNode("/BuildState/ImportedAssets");
			if (xmlNode3 != null)
			{
				XMLEngineTools.ReadImportedAssets(xmlNode3, out var importedAssets);
				foreach (Guid key in importedAssets.Keys)
				{
					compState.Assets.Add(key, importedAssets[key]);
				}
			}
			XmlNode xmlNode4 = configXmlDocument.SelectSingleNode("/BuildState/TileSetConfig");
			if (xmlNode4 != null)
			{
				XMLEngineTools.ReadTileSetConfig(xmlNode4, out var tileSetConfig);
				compState.TileSetConfig = tileSetConfig;
			}
			XmlNode xmlNode5 = configXmlDocument.SelectSingleNode("/BuildState/Compositor");
			if (xmlNode5 != null)
			{
				XMLEngineTools.ReadCompositor(xmlNode5, out var summary, out var composited);
				compState.CompositorSummary = summary;
				compState.CompositedList = composited;
			}
			XmlNode xmlNode6 = configXmlDocument.SelectSingleNode("/BuildState/LayerConfig");
			if (xmlNode6 != null)
			{
				XMLEngineTools.ReadLayerConfig(xmlNode6, out var layerConfig);
				compState.LayerConfig = layerConfig;
			}
		}

		public static void ReadBuildState(ProjectBuilder builder, string filename, List<string> compositeStateFilenames, List<string> soupFilenames, out BuildState state)
		{
			ConfigXmlDocument configXmlDocument = new ConfigXmlDocument();
			configXmlDocument.Load(filename);
			state = new BuildState(builder);
			if (configXmlDocument.SelectSingleNode("/BuildState") == null)
			{
				throw new GrMissingNodeException("BuildState");
			}
			XmlNode xmlNode = configXmlDocument.SelectSingleNode("/BuildState");
			if (xmlNode != null && xmlNode.Attributes["ProjectGuid"] != null)
			{
				state.ProjectId = XMLParsingTools.ParseGuidAttribute("ProjectGuid", xmlNode);
			}
			XmlNode xmlNode2 = configXmlDocument.SelectSingleNode("/BuildState");
			if (xmlNode2 != null && xmlNode2.Attributes["GrBuildVersion"] != null)
			{
				state.ProjectVersion = Version.Parse(xmlNode2.Attributes["GrBuildVersion"].Value);
				Version projectCompatibilityVersion = Constants.Version.ProjectCompatibilityVersion;
				if (!projectCompatibilityVersion.IsMajorCompatible(state.ProjectVersion))
				{
					throw new GrInvalidProjectCompatibilityVersionException(state.ProjectVersion, projectCompatibilityVersion);
				}
			}
			foreach (string soupFilename in soupFilenames)
			{
				try
				{
					if (File.Exists(soupFilename))
					{
						SoupTools.ReadSoupStateAndRegisterWithBuildState(builder, soupFilename, state);
					}
				}
				catch
				{
				}
			}
			foreach (string compositeStateFilename in compositeStateFilenames)
			{
				try
				{
					if (File.Exists(compositeStateFilename))
					{
						ReadCompositeBuildState(compositeStateFilename, out var compState);
						state.CompositeStates[compState.AssetId] = compState;
					}
				}
				catch
				{
				}
			}
			XmlNode xmlNode3 = configXmlDocument.SelectSingleNode("/BuildState/TileSetBuilder");
			if (xmlNode3 != null)
			{
				XMLEngineTools.ReadBuilder(xmlNode3, out var summary, out var buildAssets);
				state.BuilderSummary = summary;
				state.BuildAssets = buildAssets;
			}
		}

		public static void WriteBuildState(string filename, BuildState state)
		{
			XmlDocument document = new XmlDocument();
			document.AppendChild(document.CreateXmlDeclaration("1.0", "UTF-8", null));
			XmlElement xmlElement = document.CreateElement("BuildState");
			xmlElement.SetAttribute("ProjectGuid", state.ProjectId.ToString());
			xmlElement.SetAttribute("GrBuildVersion", Constants.Version.ProjectCompatibilityVersion.ToString());
			document.AppendChild(xmlElement);
			XMLEngineTools.WriteLayerConfig(state.LayerConfiguration2, "/BuildState", ref document);
			XMLEngineTools.WriteBuilder(state.BuilderSummary, state.BuildAssets, "/BuildState", ref document);
			filename.Replace("\\", "/");
			document.Save(filename);
		}

		public static string WriteSoupStateToString(BuildState state, Asset asset)
		{
			XmlDocument document = new XmlDocument();
			document.AppendChild(document.CreateXmlDeclaration("1.0", "UTF-8", null));
			XmlElement xmlElement = document.CreateElement("BuildState");
			xmlElement.SetAttribute("ProjectGuid", state.ProjectId.ToString());
			xmlElement.SetAttribute("GrBuildVersion", Constants.Version.ProjectCompatibilityVersion.ToString());
			xmlElement.SetAttribute("AssetGuid", asset.Id.ToString());
			document.AppendChild(xmlElement);
			BuildState.SoupState soupState = state.FindAssetSoupState(asset.Id);
			XMLEngineTools.WriteLayerConfig(soupState.LayerConfig, "/BuildState", ref document);
			XMLEngineTools.WriteTileLayout(soupState.TileLayout, "/BuildState", ref document);
			XMLEngineTools.WriteSoupedAssets(soupState.SoupBuilderSummary, soupState.SoupedAssets.Values, "/BuildState", ref document);
			XMLEngineTools.WriteImportedAssets(soupState.Assets, "/BuildState", ref document);
			using StringWriter stringWriter = new StringWriter();
			using XmlWriter xmlWriter = XmlWriter.Create(stringWriter);
			document.WriteTo(xmlWriter);
			xmlWriter.Flush();
			return stringWriter.GetStringBuilder().ToString();
		}

		public static void WriteBuildStateComposer(string filename, BuildState state, Asset asset)
		{
			BuildState.CompositeState compositeState = state.FindAssetCompositeState(asset.Id);
			if (compositeState != null)
			{
				XmlDocument document = new XmlDocument();
				document.AppendChild(document.CreateXmlDeclaration("1.0", "UTF-8", null));
				XmlElement xmlElement = document.CreateElement("BuildState");
				xmlElement.SetAttribute("ProjectGuid", state.ProjectId.ToString());
				xmlElement.SetAttribute("GrBuildVersion", Constants.Version.ProjectCompatibilityVersion.ToString());
				xmlElement.SetAttribute("AssetGuid", asset.Id.ToString());
				document.AppendChild(xmlElement);
				XMLEngineTools.WritePackedAssets(compositeState.PackingSummary, compositeState.PackedAssets, "/BuildState", ref document);
				XMLEngineTools.WriteLayerConfig(compositeState.LayerConfig, "/BuildState", ref document);
				XMLEngineTools.WriteTileSetConfig(compositeState.TileSetConfig, "/BuildState", ref document);
				XMLEngineTools.WriteImportedAssets(compositeState.Assets, "/BuildState", ref document);
				XMLEngineTools.WriteCompositor(compositeState.CompositorSummary, compositeState.CompositedList, "/BuildState", ref document);
				if (state.AssetBuiltIncrementally(asset.Id))
				{
					xmlElement.SetAttribute("BuildMode", "Incremental");
				}
				filename.Replace("\\", "/");
				document.Save(filename);
			}
		}

		private static AssetTilingMethod ConvertDeprecatedAssetBorder(XmlAttribute assetBorder, XmlAttribute assetBorderMethod)
		{
			if (assetBorder != null && assetBorderMethod != null)
			{
				int result = 0;
				if (int.TryParse(assetBorder.Value, out result) && result > 0)
				{
					string text = assetBorderMethod.Value.ToLower();
					if (text.Equals("repeat"))
					{
						return AssetTilingMethod.Repeat;
					}
					if (text.Equals("clamp"))
					{
						return AssetTilingMethod.Clamp;
					}
				}
			}
			return AssetTilingMethod.None;
		}

		private static ImportAsset ReadImportAssetNode(XmlNode importNode)
		{
			if (importNode.Attributes["Name"] == null)
			{
				throw new GrMissingAttributeException("Name", importNode);
			}
			ImportAsset importAsset = new ImportAsset();
			importAsset.Name = importNode.Attributes["Name"].Value;
			AssetTilingMethod value;
			if (importNode.Attributes["AssetBorder"] != null || importNode.Attributes["BorderMethod"] != null)
			{
				importAsset.TilingMethod = ConvertDeprecatedAssetBorder(importNode.Attributes["AssetBorder"], importNode.Attributes["BorderMethod"]);
			}
			else if (importNode.Attributes["TilingMethod"] != null && XMLParsingTools.ParseEnumAttribute<AssetTilingMethod>(importNode, "TilingMethod", out value))
			{
				importAsset.TilingMethod = value;
			}
			AutoScalingMode autoScalingMode = AutoScalingMode.None;
			if (importNode.Attributes["AutoScalingMode"] != null && XMLParsingTools.ParseEnumAttribute<AutoScalingMode>(importNode, "AutoScalingMode", out var value2))
			{
				autoScalingMode = value2;
			}
			importAsset.AutoScalingMode = autoScalingMode;
			if (importNode.Attributes["TargetWidth"] != null)
			{
				importAsset.TargetWidth = XMLParsingTools.ParseIntAttribute("TargetWidth", importNode);
			}
			if (importNode.Attributes["TargetHeight"] != null)
			{
				importAsset.TargetHeight = XMLParsingTools.ParseIntAttribute("TargetHeight", importNode);
			}
			if (XMLParsingTools.ParseEnumAttribute<AssetType>(importNode, "Type", out var value3))
			{
				importAsset.Type = value3;
			}
			foreach (XmlNode item in importNode.SelectNodes("LayerTexture"))
			{
				ImportAssetLayer importAssetLayer = new ImportAssetLayer();
				if (item.Attributes["QualityProfile"] != null)
				{
					importAssetLayer.QualityProfile = item.Attributes["QualityProfile"].Value;
				}
				if (item.Attributes["QualityLevel"] != null)
				{
					importAssetLayer.QualityProfile = item.Attributes["QualityLevel"].Value;
				}
				for (int i = 0; i < 4; i++)
				{
					string text = "Swizzle";
					if (i > 0)
					{
						text += i + 1;
					}
					if (item.Attributes[text] != null)
					{
						importAssetLayer.Swizzle[i] = item.Attributes[text].Value;
					}
					else
					{
						importAssetLayer.Swizzle[i] = "";
					}
				}
				for (int j = 0; j < 4; j++)
				{
					string text2 = "InvertChannels";
					if (j > 0)
					{
						text2 += j + 1;
					}
					if (item.Attributes[text2] != null)
					{
						importAssetLayer.InvertChannels[j] = item.Attributes[text2].Value;
					}
					else
					{
						importAssetLayer.InvertChannels[j] = "";
					}
				}
				if (XMLParsingTools.ParseEnumAttribute<Flip>(item, "Flip", out var value4))
				{
					importAssetLayer.Flip = value4;
				}
				if (item.Attributes["Resize"] != null)
				{
					importAssetLayer.Resize = item.Attributes["Resize"].Value;
				}
				if (item.Attributes["TargetWidth"] != null)
				{
					importAssetLayer.TargetWidth = XMLParsingTools.ParseIntAttribute("TargetWidth", item);
				}
				if (item.Attributes["TargetHeight"] != null)
				{
					importAssetLayer.TargetHeight = XMLParsingTools.ParseIntAttribute("TargetHeight", item);
				}
				if (item.Attributes["ResizeMode"] != null && XMLParsingTools.ParseEnumAttribute<AssetLayerResizeMode>(item, "ResizeMode", out var value5))
				{
					importAssetLayer.ResizeMode = value5;
				}
				bool flag = false;
				if (item.Attributes["AssetPackingMode"] != null && XMLParsingTools.ParseEnumAttribute<AssetPackingMode>(item, "AssetPackingMode", out var value6))
				{
					importAssetLayer.PackingMode = value6;
					flag = true;
				}
				for (int k = 0; k < 4; k++)
				{
					string text3 = "Src";
					if (k > 0)
					{
						text3 += k + 1;
					}
					if (item.Attributes[text3] != null)
					{
						if (k > 0 && !flag)
						{
							throw new GrMissingAttributeException("AssetPackingMode", item);
						}
						string path = Paths.CleanupURIFilePath(item.Attributes[text3].Value);
						importAssetLayer.Source.AddSource(path, k);
					}
				}
				if (item.Attributes["MipSource"] != null && XMLParsingTools.ParseEnumAttribute<TextureMipSourceType>(item, "MipSource", out var value7))
				{
					importAssetLayer.MipSourceType = value7;
				}
				if (item.Attributes["ColorSpace"] != null && XMLParsingTools.ParseEnumAttribute<ColorSpace>(item, "ColorSpace", out var value8))
				{
					importAssetLayer.ColorSpace = value8;
				}
				importAsset.Layers.Add(importAssetLayer);
			}
			return importAsset;
		}

		private static void ReadGTexImportNode(XmlNode importNode, out ImportGTex gtexImport)
		{
			if (importNode.Attributes["Src"] == null)
			{
				throw new GrMissingAttributeException("Src", importNode);
			}
			gtexImport = new ImportGTex();
			gtexImport.Src = importNode.Attributes["Src"].Value;
		}

		public static void ReadAssets(string filename, out LayerConfig layerConfig, out List<ImportAsset> assets, out List<ImportAssetTemplate> assetImportTemplates, out List<ImportGTex> gtexImports)
		{
			ConfigXmlDocument configXmlDocument = new ConfigXmlDocument();
			assets = new List<ImportAsset>();
			gtexImports = new List<ImportGTex>();
			layerConfig = null;
			assetImportTemplates = new List<ImportAssetTemplate>();
			try
			{
				configXmlDocument.Load(filename);
			}
			catch (XmlException e)
			{
				throw new GrGeneralXmlException(e);
			}
			catch (Exception ex)
			{
				throw ex;
			}
			XmlNode xmlNode = (configXmlDocument.SelectSingleNode("/AssetImport") ?? throw new GrMissingNodeException("AssetImport")).SelectSingleNode("LayerConfig");
			if (xmlNode == null)
			{
				layerConfig = null;
			}
			else
			{
				XMLEngineTools.ReadLayerConfig(xmlNode, out layerConfig);
			}
			XmlNodeList xmlNodeList = configXmlDocument.SelectNodes("/AssetImport/ImportTemplates/ImportTemplate");
			if (xmlNodeList.Count > 0)
			{
				assetImportTemplates = new List<ImportAssetTemplate>();
				foreach (XmlNode item2 in xmlNodeList)
				{
					ImportAssetTemplate importAssetTemplate = new ImportAssetTemplate();
					if (item2.Attributes["Name"] == null)
					{
						throw new GrMissingAttributeException("Name", item2);
					}
					importAssetTemplate.Name = item2.Attributes["Name"].Value;
					AssetTilingMethod value;
					if (item2.Attributes["AssetBorder"] != null || item2.Attributes["BorderMethod"] != null)
					{
						importAssetTemplate.TilingMethod = ConvertDeprecatedAssetBorder(item2.Attributes["AssetBorder"], item2.Attributes["BorderMethod"]);
					}
					else if (item2.Attributes["TilingMethod"] != null && XMLParsingTools.ParseEnumAttribute<AssetTilingMethod>(item2, "TilingMethod", out value))
					{
						importAssetTemplate.TilingMethod = value;
					}
					AutoScalingMode autoScalingMode = AutoScalingMode.None;
					if (item2.Attributes["AutoScalingMode"] != null && XMLParsingTools.ParseEnumAttribute<AutoScalingMode>(item2, "AutoScalingMode", out var value2))
					{
						autoScalingMode = value2;
					}
					importAssetTemplate.AutoScalingMode = autoScalingMode;
					if (item2.Attributes["TargetWidth"] != null)
					{
						importAssetTemplate.TargetWidth = XMLParsingTools.ParseIntAttribute("TargetWidth", item2);
					}
					if (item2.Attributes["TargetHeight"] != null)
					{
						importAssetTemplate.TargetHeight = XMLParsingTools.ParseIntAttribute("TargetHeight", item2);
					}
					foreach (XmlNode item3 in item2.SelectNodes("LayerTextureTemplate"))
					{
						ImportAssetLayerTemplate importAssetLayerTemplate = new ImportAssetLayerTemplate();
						if (item3.Attributes["QualityLevel"] != null)
						{
							importAssetLayerTemplate.QualityProfile = item3.Attributes["QualityLevel"].Value;
						}
						if (item3.Attributes["QualityProfile"] != null)
						{
							importAssetLayerTemplate.QualityProfile = item3.Attributes["QualityProfile"].Value;
						}
						if (XMLParsingTools.ParseEnumAttribute<Flip>(item3, "Flip", out var value3))
						{
							importAssetLayerTemplate.Flip = value3;
						}
						if (item3.Attributes["Swizzle"] != null)
						{
							importAssetLayerTemplate.Swizzle[0] = item3.Attributes["Swizzle"].Value;
						}
						else
						{
							importAssetLayerTemplate.Swizzle[0] = "";
						}
						if (item3.Attributes["Swizzle2"] != null)
						{
							importAssetLayerTemplate.Swizzle[1] = item3.Attributes["Swizzle2"].Value;
						}
						else
						{
							importAssetLayerTemplate.Swizzle[1] = "";
						}
						if (item3.Attributes["InvertChannels"] != null)
						{
							importAssetLayerTemplate.InvertChannels[0] = item3.Attributes["InvertChannels"].Value;
						}
						else
						{
							importAssetLayerTemplate.InvertChannels[0] = "";
						}
						if (item3.Attributes["InvertChannels2"] != null)
						{
							importAssetLayerTemplate.InvertChannels[1] = item3.Attributes["InvertChannels2"].Value;
						}
						else
						{
							importAssetLayerTemplate.InvertChannels[1] = "";
						}
						bool flag = false;
						if (item3.Attributes["AssetPackingMode"] != null && XMLParsingTools.ParseEnumAttribute<AssetPackingMode>(item3, "AssetPackingMode", out var value4))
						{
							importAssetLayerTemplate.PackingMode = value4;
							flag = true;
						}
						for (int i = 0; i < 4; i++)
						{
							string text = "Src";
							if (i > 0)
							{
								text += i + 1;
							}
							if (item3.Attributes[text] != null)
							{
								if (i > 0 && !flag)
								{
									throw new GrMissingAttributeException("AssetPackingMode", item3);
								}
								string path = Paths.CleanupURIFilePath(item3.Attributes[text].Value);
								importAssetLayerTemplate.Source.AddSource(path, i);
							}
						}
						if (item3.Attributes["MipSource"] != null)
						{
							XMLParsingTools.ParseEnumAttribute<TextureMipSourceType>(item3, "MipSource", out var value5);
							importAssetLayerTemplate.MipSourceType = value5;
						}
						if (item3.Attributes["ColorSpace"] != null)
						{
							XMLParsingTools.ParseEnumAttribute<ColorSpace>(item3, "ColorSpace", out var value6);
							importAssetLayerTemplate.ColorSpace = value6;
						}
						importAssetTemplate.LayerTemplates.Add(importAssetLayerTemplate);
					}
					assetImportTemplates.Add(importAssetTemplate);
				}
			}
			assets = new List<ImportAsset>();
			XmlNodeList xmlNodeList2 = configXmlDocument.SelectNodes("/AssetImport/Imports/Import");
			if (xmlNodeList2.Count > 0)
			{
				foreach (XmlNode item4 in xmlNodeList2)
				{
					ImportAsset item = ReadImportAssetNode(item4);
					assets.Add(item);
				}
			}
			XmlNodeList xmlNodeList3 = configXmlDocument.SelectNodes("/AssetImport/GTexImports/GTexImport");
			if (xmlNodeList3.Count <= 0)
			{
				return;
			}
			foreach (XmlNode item5 in xmlNodeList3)
			{
				ReadGTexImportNode(item5, out var gtexImport);
				gtexImports.Add(gtexImport);
			}
		}

		public static void ReadCodingProfile(string codingProfileXmlFilename, out CodingProfile profile)
		{
			ConfigXmlDocument configXmlDocument = new ConfigXmlDocument();
			configXmlDocument.Load(codingProfileXmlFilename);
			XMLEngineTools.ReadCodingProfile(configXmlDocument.SelectSingleNode("CodingProfile") ?? throw new GrMissingNodeException("CodingProfile"), out profile);
		}

		public static void ReadCodingProfileFromString(string codingProfilesXmlString, out CodingProfile profile)
		{
			ConfigXmlDocument configXmlDocument = new ConfigXmlDocument();
			configXmlDocument.LoadXml(codingProfilesXmlString);
			XMLEngineTools.ReadCodingProfile(configXmlDocument.SelectSingleNode("CodingProfile") ?? throw new GrMissingNodeException("CodingProfile"), out profile);
		}

		public static void ReadBuildProfile(string xmlFilename, out BuildProfile profile)
		{
			profile = null;
			ConfigXmlDocument configXmlDocument = new ConfigXmlDocument();
			configXmlDocument.Load(xmlFilename);
			XMLEngineTools.ReadBuildProfile(configXmlDocument.SelectSingleNode("BuildProfile") ?? throw new GrMissingNodeException("BuildProfile"), out profile);
		}

		public static void ReadBuildProfileFromString(string xmlProfile, out BuildProfile profile)
		{
			profile = null;
			ConfigXmlDocument configXmlDocument = new ConfigXmlDocument();
			configXmlDocument.LoadXml(xmlProfile);
			XMLEngineTools.ReadBuildProfile(configXmlDocument.SelectSingleNode("BuildProfile") ?? throw new GrMissingNodeException("BuildProfile"), out profile);
		}

		public static void WriteImportScript(string filename, ImportScript script)
		{
			XmlDocument document = new XmlDocument();
			document.AppendChild(document.CreateXmlDeclaration("1.0", "UTF-8", null));
			XmlElement newChild = document.CreateElement("AssetImport");
			document.AppendChild(newChild);
			XMLEngineTools.WriteLayerConfig(script.LayerConfig, "/AssetImport", ref document);
			XMLEngineTools.WriteImportAssets(script.ImportAssets, "/AssetImport", ref document);
			filename.Replace("\\", "/");
			document.Save(filename);
		}

		public static void ReadSolution(string filename, out Solution solution)
		{
			ConfigXmlDocument configXmlDocument = new ConfigXmlDocument();
			configXmlDocument.Load(filename);
			solution = new Solution();
			XmlNode xmlNode = configXmlDocument.SelectSingleNode("/Solution");
			if (xmlNode == null)
			{
				throw new GrMissingNodeException("Solution");
			}
			if (xmlNode.Attributes["Name"] != null)
			{
				solution.Name = xmlNode.Attributes["Name"].Value;
			}
			if (xmlNode.Attributes["Guid"] != null)
			{
				solution.Id = XMLParsingTools.ParseGuidAttribute("Guid", xmlNode);
			}
			if (xmlNode.Attributes["Version"] != null)
			{
				Version version = Version.Parse(xmlNode.Attributes["Version"].Value);
				Version projectCompatibilityVersion = Constants.Version.ProjectCompatibilityVersion;
				if (!projectCompatibilityVersion.IsMajorCompatible(version))
				{
					throw new GrInvalidProjectCompatibilityVersionException(version, projectCompatibilityVersion);
				}
			}
			if (configXmlDocument.SelectSingleNode("/Solution/Projects") != null)
			{
				string directoryName = Paths.GetDirectoryName(filename);
				ReadSolutionProjects(configXmlDocument, out var solutionProjects, directoryName);
				solution.Projects = solutionProjects;
			}
		}

		public static void WriteSolution(string filename, Solution solution)
		{
			XmlDocument xmlDocument = new XmlDocument();
			xmlDocument.AppendChild(xmlDocument.CreateXmlDeclaration("1.0", "UTF-8", null));
			XmlElement xmlElement = xmlDocument.CreateElement("Solution");
			xmlElement.SetAttribute("Name", solution.Name);
			xmlElement.SetAttribute("Guid", solution.Id.ToString());
			xmlElement.SetAttribute("Version", Constants.Version.ProjectCompatibilityVersion.ToString());
			XmlElement xmlElement2 = xmlDocument.CreateElement("Projects");
			WriteSolutionProjects(solution.Projects, xmlElement2, xmlDocument);
			xmlElement.AppendChild(xmlElement2);
			xmlDocument.AppendChild(xmlElement);
			filename.Replace("\\", "/");
			xmlDocument.Save(filename);
		}

		private static void WriteSolutionProjects(Dictionary<Guid, SolutionProjectDecriptor> solutionProjects, XmlNode projectsNode, XmlDocument document)
		{
			if (solutionProjects == null || solutionProjects.Count() == 0)
			{
				return;
			}
			foreach (SolutionProjectDecriptor value in solutionProjects.Values)
			{
				XmlElement xmlElement = document.CreateElement("Project");
				xmlElement.SetAttribute("Id", "{" + value.Id.ToString() + "}");
				xmlElement.SetAttribute("Name", value.Name);
				xmlElement.SetAttribute("Path", value.FilePath);
				projectsNode.AppendChild(xmlElement);
			}
		}

		private static void ReadSolutionProjects(XmlDocument document, out Dictionary<Guid, SolutionProjectDecriptor> solutionProjects, string solutionDir)
		{
			solutionProjects = new Dictionary<Guid, SolutionProjectDecriptor>();
			if (document.SelectSingleNode("/Solution/Projects") == null)
			{
				throw new GrMissingNodeException("Projects");
			}
			XmlNodeList xmlNodeList = document.SelectNodes("/Solution/Projects/Project");
			if (xmlNodeList.Count <= 0)
			{
				return;
			}
			foreach (XmlNode item in xmlNodeList)
			{
				SolutionProjectDecriptor solutionProjectDecriptor = new SolutionProjectDecriptor();
				if (item.Attributes["Id"] == null)
				{
					throw new GrMissingAttributeException("Id", item);
				}
				solutionProjectDecriptor.Id = XMLParsingTools.ParseGuidAttribute("Id", item);
				if (item.Attributes["Name"] == null)
				{
					throw new GrMissingAttributeException("Name", item);
				}
				solutionProjectDecriptor.Name = item.Attributes["Name"].Value;
				if (item.Attributes["Path"] == null)
				{
					throw new GrMissingAttributeException("Path", item);
				}
				solutionProjectDecriptor.FilePath = item.Attributes["Path"].Value;
				try
				{
					string absolutePath = Paths.GetAbsolutePath(solutionDir, solutionProjectDecriptor.FilePath);
					solutionProjectDecriptor.Id = ReadProjectGuid(absolutePath);
				}
				catch
				{
				}
				solutionProjects.Add(solutionProjectDecriptor.Id, solutionProjectDecriptor);
			}
		}

		public static Version ReadProjectVersion(string filename)
		{
			ConfigXmlDocument configXmlDocument = new ConfigXmlDocument();
			configXmlDocument.Load(filename);
			XmlNode xmlNode = configXmlDocument.SelectSingleNode("/Project");
			if (xmlNode == null)
			{
				throw new GrMissingNodeException("Project");
			}
			if (xmlNode.Attributes["GrBuildVersion"] == null)
			{
				throw new GrMissingAttributeException("GrBuildVersion", xmlNode);
			}
			return Version.Parse(xmlNode.Attributes["GrBuildVersion"].Value);
		}

		public static Guid ReadProjectGuid(string filename)
		{
			ConfigXmlDocument configXmlDocument = new ConfigXmlDocument();
			configXmlDocument.Load(filename);
			XmlNode xmlNode = configXmlDocument.SelectSingleNode("/Project");
			if (xmlNode == null)
			{
				throw new GrMissingNodeException("Project");
			}
			if (xmlNode.Attributes["Guid"] == null)
			{
				throw new GrMissingAttributeException("Guid", xmlNode);
			}
			return XMLParsingTools.ParseGuidAttribute("Guid", xmlNode);
		}
	}
}
namespace GrBuildLib.Properties
{
	[GeneratedCode("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
	[DebuggerNonUserCode]
	[CompilerGenerated]
	internal class Resources
	{
		private static ResourceManager resourceMan;

		private static CultureInfo resourceCulture;

		[EditorBrowsable(EditorBrowsableState.Advanced)]
		internal static ResourceManager ResourceManager
		{
			get
			{
				if (resourceMan == null)
				{
					resourceMan = new ResourceManager("GrBuildLib.Properties.Resources", typeof(Resources).Assembly);
				}
				return resourceMan;
			}
		}

		[EditorBrowsable(EditorBrowsableState.Advanced)]
		internal static CultureInfo Culture
		{
			get
			{
				return resourceCulture;
			}
			set
			{
				resourceCulture = value;
			}
		}

		internal static string ImportValidation => ResourceManager.GetString("ImportValidation", resourceCulture);

		internal static string ProjectValidation => ResourceManager.GetString("ProjectValidation", resourceCulture);

		internal Resources()
		{
		}
	}
}
namespace GrBuildLib.Tools
{
	internal class Collections
	{
		public static bool ChangeDictionaryKey<TKey, TValue>(Dictionary<TKey, TValue> dictionary, TKey oldKey, TKey newKey)
		{
			try
			{
				TValue value = dictionary[oldKey];
				dictionary.Remove(oldKey);
				dictionary.Add(newKey, value);
				return true;
			}
			catch
			{
				return false;
			}
		}
	}
	public class DateTimeManagement
	{
		private static string oldTimeFormat = "dd-MM-yyyy hh:mm:ss.fff tt zzz";

		private static string timeFormat = "dd-MM-yyyy hh:mm:ss.fffffff tt zzz";

		public static bool SameTimeMs(DateTime rhs, DateTime lhs)
		{
			try
			{
				if (new TimeSpan(Math.Abs(rhs.Ticks - lhs.Ticks)).TotalMilliseconds < 1.0)
				{
					return true;
				}
			}
			catch
			{
			}
			return false;
		}

		public static DateTime Round(DateTime dateTime)
		{
			return DeserializeDateTimeFromString(SerializeDateTimeToString(dateTime));
		}

		public static DateTime Now()
		{
			return Round(DateTime.Now);
		}

		public static string SerializeDateTimeToString(DateTime time)
		{
			return time.ToString(timeFormat, CultureInfo.InvariantCulture);
		}

		public static DateTime DeserializeDateTimeFromString(string timeString)
		{
			try
			{
				return DateTime.ParseExact(timeString, timeFormat, CultureInfo.InvariantCulture);
			}
			catch
			{
				return DateTime.ParseExact(timeString, oldTimeFormat, CultureInfo.InvariantCulture);
			}
		}
	}
	public class Errors
	{
		public static string GetBuildErrorMessage(ErrorInfo errorInfo)
		{
			Nixel.Error code = (Nixel.Error)errorInfo.code;
			string result = "";
			switch (code)
			{
			case Nixel.Error.Pagesize:
				result = "Page size is too small, please change the page size parameter and build the project, set the page size to 0 for auto page size calculation";
				break;
			case Nixel.Error.IoBadPath:
				result = "An internal IO path is bad, detailed message: '" + errorInfo.message + "', please try to build your project in another directory";
				break;
			case Nixel.Error.IoFileNotFound:
				result = "An internal file was not found, detailed message: '" + errorInfo.message + "', please rebuild your project";
				break;
			case Nixel.Error.IoDiskFull:
				result = "An internal IO error occurred, detailed message: '" + errorInfo.message + "'. Please make sure you have enough disk space and then rebuild your project";
				break;
			case Nixel.Error.IoAccessDenied:
				result = "An internal IO error occurred, detailed message: '" + errorInfo.message + "'. Please make sure no other processes are using the project folder and then rebuild your project";
				break;
			case Nixel.Error.IoLocked:
				result = "An internal IO error occurred, detailed message: '" + errorInfo.message + "'. Please make sure the project folder isn't locked and then rebuild your project";
				break;
			case Nixel.Error.IoUnknown:
				result = "An internal IO error occurred, detailed message: '" + errorInfo.message + "'. Please make sure no other processes are using the project folder, the project folder isn't locked and you have enough disk space then rebuild your project";
				break;
			case Nixel.Error.InvalidCodecParamter:
			case Nixel.Error.BlockCodingError:
			case Nixel.Error.InvalidCodecConfiguration:
			case Nixel.Error.CodecIOError:
			case Nixel.Error.NotEnoughChannels:
			case Nixel.Error.TranscoderLoadFailed:
				result = "An error occurred while coding the data, detailed message '" + errorInfo.message + "'please review the documentation on coding profiles. You might be trying to code data with incompatible parameters. Please rebuild your project";
				break;
			case Nixel.Error.InvalidCodingGroupIndex:
				result = "There was a problem on setting the coding parameters, please rebuild the project";
				break;
			case Nixel.Error.OutOfMemory:
				result = "An internal object could not be allocated due to memory limitations, please make sure your system meets the memory requirements and rebuild your project";
				break;
			case Nixel.Error.InvalidLayerData:
				result = "There was a problem with compositing the data, detailed message: '" + errorInfo.message + "', please rebuild your project";
				break;
			case Nixel.Error.InvalidPageFile:
			case Nixel.Error.InvalidGtsFile:
			case Nixel.Error.InvalidSoupFile:
			case Nixel.Error.InvalidSoupIndex:
			case Nixel.Error.InvalidSoupCoding:
			case Nixel.Error.InvalidCacheFile:
			case Nixel.Error.InvalidRasterIndex:
			case Nixel.Error.InvalidHeader:
			case Nixel.Error.InvalidVersion:
				result = "An internal file is in an invalid state, detailed message: '" + errorInfo.message + "', please rebuild your project";
				break;
			case Nixel.Error.MissingSoupCoding:
			case Nixel.Error.MissingSoupIndex:
			case Nixel.Error.MissingRasterIndex:
			case Nixel.Error.MissingSoupFile:
				result = "An internal file is missing, detailed message: " + errorInfo.message + "', please rebuild your project";
				break;
			default:
				result = "An internal error occurred, please rebuild the project. If this problem persists please contact Graphine with the following information: " + errorInfo.function + ":" + errorInfo.line + " " + errorInfo.message + ", code: " + code;
				break;
			case Nixel.Error.Ok:
				break;
			}
			return result;
		}
	}
	public class Paths
	{
		public static string DepricatedGetRelativePath(string basePath, string absPath)
		{
			string fullPath = Path.GetFullPath(absPath);
			string text = Path.GetFullPath(basePath);
			Uri uri = new Uri(fullPath);
			if (!text.EndsWith(Path.DirectorySeparatorChar.ToString()))
			{
				text += Path.DirectorySeparatorChar;
			}
			Uri uri2 = new Uri(text).MakeRelativeUri(uri);
			if (uri2.IsAbsoluteUri)
			{
				return Uri.UnescapeDataString(uri2.LocalPath.Replace('/', Path.DirectorySeparatorChar));
			}
			return Uri.UnescapeDataString(uri2.ToString().Replace('/', Path.DirectorySeparatorChar));
		}

		public static bool IsAbsolutePath(string path)
		{
			if (Path.IsPathRooted(path))
			{
				return !Path.GetPathRoot(path).Equals(Path.DirectorySeparatorChar.ToString(), StringComparison.Ordinal);
			}
			return false;
		}

		[DllImport("shlwapi.dll", CharSet = CharSet.Unicode)]
		protected static extern bool PathRelativePathTo(StringBuilder lpszDst, string from, uint attrFrom, string to, uint attrTo);

		public static string GetRelativePathForDirectory(string basePath, string absPath)
		{
			if (!IsAbsolutePath(absPath))
			{
				absPath = Path.Combine(basePath, absPath);
			}
			string text = Path.GetFullPath(absPath);
			string text2 = Path.GetFullPath(basePath);
			if (!text2.EndsWith(Path.DirectorySeparatorChar.ToString()))
			{
				text2 += Path.DirectorySeparatorChar;
			}
			if (!text.EndsWith(Path.DirectorySeparatorChar.ToString()))
			{
				text += Path.DirectorySeparatorChar;
			}
			StringBuilder stringBuilder = new StringBuilder(1024);
			if (PathRelativePathTo(stringBuilder, text2, 0u, text, 0u))
			{
				return stringBuilder.ToString();
			}
			return DepricatedGetRelativePath(basePath, absPath);
		}

		public static string GetRelativePathForFile(string basePath, string absPath)
		{
			if (!IsAbsolutePath(absPath))
			{
				absPath = Path.Combine(basePath, absPath);
			}
			string fullPath = Path.GetFullPath(absPath);
			string text = Path.GetFullPath(basePath);
			if (!text.EndsWith(Path.DirectorySeparatorChar.ToString()))
			{
				text += Path.DirectorySeparatorChar;
			}
			StringBuilder stringBuilder = new StringBuilder(1024);
			if (PathRelativePathTo(stringBuilder, text, 0u, fullPath, 0u))
			{
				return stringBuilder.ToString();
			}
			return DepricatedGetRelativePath(basePath, absPath);
		}

		public static string GetAbsolutePath(string basePath, string relativePath)
		{
			return Path.Combine(basePath, relativePath);
		}

		public static string PathAddTrailingSlash(string path)
		{
			if (string.IsNullOrEmpty(path))
			{
				return string.Empty;
			}
			if (path.EndsWith("\\"))
			{
				return path;
			}
			return path + "\\";
		}

		internal static Stream GetResourceStream(string folderName, string filename)
		{
			return Assembly.GetExecutingAssembly().GetManifestResourceStream("GrBuildLib." + folderName + "." + filename);
		}

		internal static string GetResourceString(string folderName, string filename)
		{
			Stream manifestResourceStream = Assembly.GetExecutingAssembly().GetManifestResourceStream("GrBuildLib." + folderName + "." + filename);
			if (manifestResourceStream == null)
			{
				return null;
			}
			return new StreamReader(manifestResourceStream).ReadToEnd();
		}

		internal static void GetResourceFiles(string folderName, string extension, out List<string> names, out List<string> fullpaths, Predicate<string> nameFilter = null)
		{
			names = new List<string>();
			fullpaths = new List<string>();
			string[] manifestResourceNames = Assembly.GetExecutingAssembly().GetManifestResourceNames();
			string text = "GrBuildLib." + folderName;
			string[] array = manifestResourceNames;
			foreach (string text2 in array)
			{
				if (text2.StartsWith(text) && text2.EndsWith(extension))
				{
					string text3 = text2.Substring(text.Length + 1, text2.Length - text.Length - extension.Length - 2);
					if (nameFilter == null || !nameFilter(text3))
					{
						fullpaths.Add(text2);
						names.Add(text3);
					}
				}
			}
		}

		public static bool IsValidFilename(string filename)
		{
			try
			{
				if (filename == null)
				{
					return false;
				}
				if (filename.Length == 0)
				{
					return false;
				}
				if (filename.IndexOfAny(Path.GetInvalidPathChars()) >= 0)
				{
					return false;
				}
				if (Path.GetFileName(filename).Length == 0)
				{
					return false;
				}
				if (Directory.GetParent(Path.GetFullPath(filename)) == null)
				{
					return false;
				}
			}
			catch
			{
				return false;
			}
			return true;
		}

		public static bool IsValidDirectory(string folderPath)
		{
			try
			{
				if (folderPath == null)
				{
					return false;
				}
				if (folderPath.Length == 0)
				{
					return false;
				}
				if (folderPath.IndexOfAny(Path.GetInvalidPathChars()) >= 0)
				{
					return false;
				}
				if (Path.GetFullPath(folderPath).Length == 0)
				{
					return false;
				}
			}
			catch
			{
				return false;
			}
			return true;
		}

		public static string CleanupURIFilePath(string path)
		{
			if (path.StartsWith("file:\\\\"))
			{
				try
				{
					Uri uri = new Uri(path);
					if (uri.IsAbsoluteUri)
					{
						return uri.LocalPath;
					}
					return path;
				}
				catch
				{
					return path;
				}
			}
			return path;
		}

		public static bool DeleteFile(string filename)
		{
			try
			{
				File.Delete(filename);
			}
			catch
			{
				return false;
			}
			return true;
		}

		public static string GetDirectoryName(string filename)
		{
			string directoryName = Path.GetDirectoryName(filename);
			if (directoryName == null)
			{
				return filename;
			}
			return directoryName;
		}

		public static void DeleteDirectory(string path, bool recursive)
		{
			Directory.Delete(path, recursive);
			for (int i = 1; i <= 6; i++)
			{
				Thread.Sleep(i * i);
				if (!Directory.Exists(path))
				{
					return;
				}
			}
			throw new IOException("Unable to delete folder '" + path + "'. Deletion succeeded but folder still exists.");
		}

		public static void CreateDirectory(string path)
		{
			if (!Directory.Exists(path))
			{
				Directory.CreateDirectory(path);
			}
		}

		public static string GetPathRoot(string path)
		{
			return Path.GetPathRoot(Path.GetFullPath(path));
		}
	}
	public class PatternScanner
	{
		public struct TextureFile
		{
			public string Filename { get; set; }

			public int X { get; set; }

			public int Y { get; set; }

			public int SubIndex { get; set; }

			public int Level { get; set; }

			public int Face { get; set; }
		}

		public struct PatternRange
		{
			public int MinCol { get; set; }

			public int MaxCol { get; set; }

			public int MinRow { get; set; }

			public int MaxRow { get; set; }

			public int GetTiledWidth()
			{
				return MaxCol - MinCol + 1;
			}

			public int GetTiledHeight()
			{
				return MaxRow - MinRow + 1;
			}

			public int GetUdimWidth()
			{
				return MaxCol + 1;
			}

			public int GetUdimHeight()
			{
				return MaxRow + 1;
			}
		}

		public class TextureFileCollection
		{
			public List<TextureFile> TextureFiles { get; set; }

			public PatternRange Range { get; set; }

			public int NumberOfTextures { get; set; }

			public int UDimDetectedUTiles { get; set; }

			public bool HasMipFiles { get; set; }

			public bool HasFaceFiles { get; set; }

			public TextureFileCollection()
			{
				TextureFiles = new List<TextureFile>();
			}
		}

		private static string xPattern = "@x|%x|%\\+x|%\\w\\dx|%\\w\\d\\+x";

		private static string yPattern = "@y|%y|%\\+y|%\\w\\dy|%\\w\\d\\+y";

		public static string uPattern = "%u|%\\d+u";

		public static string cubemapPattern = "%c|%\\d+c";

		public static string mipPattern = "%m|%\\d+m";

		public static bool IsPattern(string filename)
		{
			bool flag = Regex.IsMatch(filename, xPattern, RegexOptions.IgnoreCase);
			bool flag2 = Regex.IsMatch(filename, yPattern, RegexOptions.IgnoreCase);
			Match match = Regex.Match(filename, xPattern + "|" + yPattern, RegexOptions.IgnoreCase);
			int num = 0;
			while (match.Success)
			{
				num++;
				match = match.NextMatch();
			}
			if (flag && flag2)
			{
				return num == 2;
			}
			return false;
		}

		public static bool IsPatternUDim(string filename)
		{
			return Regex.IsMatch(filename, uPattern, RegexOptions.IgnoreCase);
		}

		public static bool IsPatternCubeMap(string filename)
		{
			return Regex.IsMatch(filename, cubemapPattern, RegexOptions.IgnoreCase);
		}

		public static bool ScanTiledTemplate(string filename, out TextureFileCollection textureFiles, out int rows, out int columns)
		{
			textureFiles = new TextureFileCollection();
			rows = 0;
			columns = 0;
			Match match = Regex.Match(filename, xPattern, RegexOptions.IgnoreCase);
			Match match2 = Regex.Match(filename, yPattern, RegexOptions.IgnoreCase);
			if (!match.Success || !match2.Success)
			{
				return false;
			}
			int num = 0;
			int i;
			string result;
			for (i = 0; FillPatternString(match2.Value, i, out result); i++)
			{
				string result2;
				for (num = 0; FillPatternString(match.Value, num, out result2); num++)
				{
					string text = filename.Replace(match.Value, result2);
					text = text.Replace(match2.Value, result);
					if (!File.Exists(text))
					{
						break;
					}
					TextureFile item = default(TextureFile);
					item.Filename = text;
					item.X = num;
					item.Y = i;
					textureFiles.TextureFiles.Add(item);
				}
				if (num == 0)
				{
					break;
				}
			}
			if (textureFiles.TextureFiles.Count == 0)
			{
				return false;
			}
			rows = i;
			columns = textureFiles.TextureFiles.Count / rows;
			if (textureFiles.TextureFiles.Count != rows * columns)
			{
				return false;
			}
			PatternRange range = default(PatternRange);
			range.MinCol = 0;
			range.MaxCol = columns - 1;
			range.MinRow = 0;
			range.MaxRow = rows - 1;
			textureFiles.Range = range;
			textureFiles.NumberOfTextures = columns * rows;
			return true;
		}

		public static bool ScanUDimTemplate(string filename, out TextureFileCollection textureFiles, out int rows, out int cols, out int detectedUDimPatchWidth)
		{
			textureFiles = new TextureFileCollection();
			rows = 0;
			cols = 0;
			int num = 0;
			int num2 = 0;
			detectedUDimPatchWidth = 0;
			Match match = Regex.Match(filename, uPattern);
			if (!match.Success)
			{
				return false;
			}
			num = 10;
			detectedUDimPatchWidth = 10;
			num2 = Constants.MaxUDimVerticalPatches;
			if (match.Value.Length >= 3)
			{
				num2 = int.Parse(match.Value.Substring(1, match.Value.Length - 2));
			}
			int num3 = int.MaxValue;
			int num4 = int.MinValue;
			int num5 = int.MaxValue;
			int num6 = int.MinValue;
			for (int i = 0; i < num2; i++)
			{
				for (int j = 0; j < num; j++)
				{
					if (GetUdimNumberString(j, i, num, num2, out var result))
					{
						string text = filename.Replace(match.Value, result);
						if (File.Exists(text))
						{
							TextureFile item = default(TextureFile);
							item.Filename = text;
							item.X = j;
							item.Y = i;
							textureFiles.TextureFiles.Add(item);
							num3 = Math.Min(num3, j);
							num5 = Math.Min(num5, i);
							num4 = Math.Max(num4, j);
							num6 = Math.Max(num6, i);
						}
					}
				}
			}
			if (textureFiles.TextureFiles.Count == 0)
			{
				return false;
			}
			rows = num6 + 1;
			cols = num4 + 1;
			PatternRange range = default(PatternRange);
			range.MinCol = num3;
			range.MaxCol = num4;
			range.MinRow = num5;
			range.MaxRow = num6;
			textureFiles.Range = range;
			textureFiles.UDimDetectedUTiles = detectedUDimPatchWidth;
			textureFiles.NumberOfTextures = textureFiles.TextureFiles.Count;
			return true;
		}

		public static bool GetPatternFilenamesMipmap(string filename, out TextureFileCollection textureFiles)
		{
			textureFiles = new TextureFileCollection();
			Match match = Regex.Match(filename, mipPattern, RegexOptions.IgnoreCase);
			if (!match.Success)
			{
				return false;
			}
			for (int i = 0; i < 24; i++)
			{
				string newValue = i.ToString("00");
				string text = filename.Replace(match.Value, newValue);
				if (File.Exists(text))
				{
					TextureFile item = default(TextureFile);
					item.Filename = text;
					item.X = 0;
					item.Y = 0;
					item.Face = 0;
					item.Level = i;
					textureFiles.TextureFiles.Add(item);
				}
			}
			return textureFiles.TextureFiles.Count > 0;
		}

		private static bool FillPatternString(string pattern, int num, out string result)
		{
			result = "";
			if (num < 0)
			{
				return false;
			}
			if (!Regex.IsMatch(pattern, xPattern + "|" + yPattern))
			{
				return false;
			}
			if (pattern.Contains("@"))
			{
				if (pattern.Length != 2)
				{
					return false;
				}
				if (num > 25 || num < 0)
				{
					return false;
				}
				char c = 'A';
				for (int i = 0; i < num; i++)
				{
					c = (char)(c + 1);
				}
				result = c.ToString();
			}
			else
			{
				int num2 = 1;
				if (pattern.Length > 3)
				{
					num2 = int.Parse(pattern[2].ToString());
				}
				if (pattern.Length == 3 || pattern.Length == 5)
				{
					num++;
				}
				string text = "";
				if (pattern.Length > 3)
				{
					text = new string(pattern[1], num2 - num.ToString().Length);
				}
				result = text + num;
			}
			return true;
		}

		public static bool GetUdimNumberString(int tileU, int tileV, int numTilesOnAxisX, int numTilesOnAxisY, out string result)
		{
			result = "";
			if (tileU < 0 || tileV < 0 || tileU >= numTilesOnAxisX || tileV >= numTilesOnAxisY)
			{
				return false;
			}
			result = (1000 + (tileU + 1) + tileV * numTilesOnAxisX).ToString();
			return true;
		}
	}
	public class NixelTools
	{
		public static void GetNixelVersion(out Version version, out string buildInfo)
		{
			ITileFileFactory.GetLibraryVersion(out var info);
			version = new Version(info.major, info.minor);
			buildInfo = $"Compiled by {info.buildUser}@{info.buildHost} from {info.buildGitBranch}/{info.buildGitHash}";
		}

		public static bool CheckDlls()
		{
			try
			{
				DataTypeInfo.GetChannelSize(DataType.R8G8B8_SRGB);
			}
			catch (Exception innerException)
			{
				throw new InvalidDllException("GrCoreToolsCPP.dll", innerException);
			}
			try
			{
				BinPacking.PackingOptions options = default(BinPacking.PackingOptions);
				options.width = 0;
				options.height = 0;
				options.allowRotation = 0;
				BinPacking.BeginPacking(ref options);
			}
			catch (Exception innerException2)
			{
				throw new InvalidDllException("BinPacking.dll", innerException2);
			}
			try
			{
				if (ITileFileFactory.CreateTiledBuildParameters(new TiledTopology(1u, 1u, 1u), out var tiledBuildParameters) == Nixel.Error.Ok)
				{
					tiledBuildParameters.Dispose();
				}
			}
			catch (Exception innerException3)
			{
				throw new InvalidDllException("NixelWrapperCPP.dll", innerException3);
			}
			try
			{
				ImageFactory.Create(out var image);
				image.Dispose();
			}
			catch (Exception innerException4)
			{
				throw new InvalidDllException("GrimWrapperCPP.dll", innerException4);
			}
			return true;
		}

		public static string ReadWCharUnicodeString(byte[] array)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(array.Length);
			Marshal.Copy(array, 0, intPtr, array.Length);
			string result = Marshal.PtrToStringUni(intPtr);
			Marshal.FreeHGlobal(intPtr);
			return result;
		}

		internal static PackedSoupFile CreatePackedSoupFile(ProjectBuilder builder, PackedSoupFileInfo info)
		{
			PackedSoupFile result = default(PackedSoupFile);
			result.packedX = (uint)info.X;
			result.packedY = (uint)info.Y;
			result.packedWidth = (uint)info.Width;
			result.packedHeight = (uint)info.Height;
			result.soupFilePath = info.SoupFileInfo.SoupFileDescriptor.SoupFilename;
			result.assetName = Path.GetFileNameWithoutExtension(result.soupFilePath);
			string absolutePath = Paths.GetAbsolutePath(builder.GetProjectPath(), result.soupFilePath);
			string outputDirectory = builder.ActiveProject.BuildConfiguration.OutputDirectory;
			result.relativeSoupFilePath = Paths.GetRelativePathForFile(outputDirectory, absolutePath);
			return result;
		}
	}
	public class FileScanner
	{
		public List<string> FoundFiles { get; private set; }

		public void Scan(string path, string pattern)
		{
			bool recursive = true;
			Scan(path, pattern, recursive);
		}

		public void Scan(string path, string pattern, bool recursive)
		{
			FoundFiles = new List<string>();
			try
			{
				string[] files = Directory.GetFiles(path, pattern, recursive ? SearchOption.AllDirectories : SearchOption.TopDirectoryOnly);
				FoundFiles.AddRange(files);
			}
			catch
			{
			}
		}
	}
	public class Various
	{
		public static Size MaxSize(Size x, Size y)
		{
			return new Size(Math.Max(x.Width, y.Width), Math.Max(x.Height, y.Height));
		}

		public static Size MaxSize(IEnumerable<Size> list)
		{
			Size size = Size.Empty;
			foreach (Size item in list)
			{
				size = MaxSize(size, item);
			}
			return size;
		}

		public static string FormatBytes(long size)
		{
			string[] array = new string[7] { "B", "KB", "MB", "GB", "TB", "PB", "EB" };
			if (size == 0L)
			{
				return "0" + array[0];
			}
			long num = Math.Abs(size);
			int num2 = Convert.ToInt32(Math.Floor(Math.Log(num, 1024.0)));
			double num3 = Math.Round((double)num / Math.Pow(1024.0, num2), 1);
			return (double)Math.Sign(size) * num3 + " " + array[num2];
		}

		public static bool NameEquals(string s1, string s2)
		{
			if (s1 == null && s2 == null)
			{
				return true;
			}
			if (s1 == null || s2 == null)
			{
				return false;
			}
			return s1.ToLowerInvariant().Equals(s2.ToLowerInvariant());
		}
	}
	public class XMLValidator
	{
		public class XMLValidationResult
		{
			public bool Valid => Errors.Count == 0;

			public List<string> Errors { get; internal set; }

			public List<string> Warnings { get; internal set; }

			public XMLValidationResult()
			{
				Warnings = new List<string>();
				Errors = new List<string>();
			}

			public override string ToString()
			{
				string text = "";
				if (Errors != null)
				{
					foreach (string error in Errors)
					{
						text = text + error + " ";
					}
				}
				if (Warnings != null)
				{
					foreach (string warning in Warnings)
					{
						text = text + "Warning: " + warning + " ";
					}
					return text;
				}
				return text;
			}
		}

		private int currentLine;

		public XMLValidationResult ValidationResult { get; private set; }

		public XMLValidator()
		{
			ValidationResult = new XMLValidationResult();
		}

		public void ValidationHandler(object sender, ValidationEventArgs args)
		{
			if (args.Severity == XmlSeverityType.Warning)
			{
				ValidationResult.Warnings.Add(args.Message + " Line: " + currentLine);
			}
			else
			{
				ValidationResult.Errors.Add(args.Message + " Line: " + currentLine);
			}
		}

		public bool ValidateXMLFile(string XMLFilename)
		{
			try
			{
				new ConfigXmlDocument().Load(XMLFilename);
			}
			catch (Exception ex)
			{
				throw ex;
			}
			return true;
		}

		public bool ValidateXMLFile(string XMLFilename, string XSDString)
		{
			ValidationResult = new XMLValidationResult();
			currentLine = 0;
			if (!File.Exists(XMLFilename))
			{
				throw new FileNotFoundException("The XML file could not be found.");
			}
			try
			{
				XmlTextReader xmlTextReader = null;
				XmlSchemaCollection xmlSchemaCollection = null;
				XmlValidatingReader xmlValidatingReader = null;
				xmlTextReader = new XmlTextReader(new StringReader(XSDString));
				xmlSchemaCollection = new XmlSchemaCollection();
				string ns = null;
				xmlSchemaCollection.Add(ns, xmlTextReader);
				xmlValidatingReader = new XmlValidatingReader(XmlReader.Create(XMLFilename));
				xmlValidatingReader.Schemas.Add(xmlSchemaCollection);
				xmlValidatingReader.ValidationType = ValidationType.Schema;
				xmlValidatingReader.ValidationEventHandler += ValidationHandler;
				while (xmlValidatingReader.Read())
				{
					currentLine = xmlValidatingReader.LineNumber;
				}
				xmlValidatingReader.Close();
			}
			catch (XmlException ex)
			{
				ValidationResult.Errors.Add(ex.Message);
			}
			catch (Exception ex2)
			{
				ValidationResult.Errors.Add("General error: " + ex2.Message);
			}
			return ValidationResult.Valid;
		}
	}
	public class XMLParsingTools
	{
		private static bool ParseEnum<T>(string value, out T result)
		{
			try
			{
				result = (T)System.Enum.Parse(typeof(T), value, ignoreCase: true);
				return true;
			}
			catch (Exception)
			{
				result = default(T);
			}
			return false;
		}

		public static bool ParseEnumAttribute<T>(XmlNode node, string attrName, out T value)
		{
			if (node != null && node.Attributes[attrName] != null)
			{
				if (!ParseEnum<T>(node.Attributes[attrName].Value, out var result))
				{
					throw new GrInvalidParseAttributeException(attrName, node);
				}
				value = result;
				return true;
			}
			value = default(T);
			return false;
		}

		public static bool ParseEnumInner<T>(XmlNode node, out T value)
		{
			if (node != null && !string.IsNullOrEmpty(node.InnerText))
			{
				if (!ParseEnum<T>(node.InnerText, out var result))
				{
					throw new GrInvalidParseNodeException(node.Name, node);
				}
				value = result;
				return true;
			}
			value = default(T);
			return false;
		}

		public static bool ParseEnumNodeList<T>(XmlNode listNode, string listItemNodeName, out List<T> values)
		{
			values = new List<T>();
			if (listNode == null)
			{
				return false;
			}
			foreach (XmlNode item in listNode.SelectNodes(listItemNodeName))
			{
				if (!ParseEnumInner<T>(item, out var value))
				{
					throw new GrInvalidParseNodeException(item.Name, listNode);
				}
				values.Add(value);
			}
			return true;
		}

		public static Guid ParseGuidAttribute(string attribute, XmlNode node)
		{
			try
			{
				return new Guid(node.Attributes[attribute].Value);
			}
			catch
			{
				throw new GrInvalidParseAttributeException(attribute, node);
			}
		}

		public static DateTime ParseDateAttribute(string attribute, XmlNode node)
		{
			try
			{
				return DateTimeManagement.DeserializeDateTimeFromString(node.Attributes[attribute].Value);
			}
			catch
			{
				throw new GrInvalidParseAttributeException(attribute, node);
			}
		}

		public static int ParseIntInner(XmlNode node)
		{
			try
			{
				return int.Parse(node.InnerXml);
			}
			catch
			{
				throw new GrInvalidParseNodeException(node.Name, node);
			}
		}

		public static int ParseIntAttribute(string attribute, XmlNode node)
		{
			try
			{
				return int.Parse(node.Attributes[attribute].Value);
			}
			catch
			{
				throw new GrInvalidParseAttributeException(attribute, node);
			}
		}

		public static uint ParseUIntInner(XmlNode node)
		{
			try
			{
				return uint.Parse(node.InnerXml);
			}
			catch
			{
				throw new GrInvalidParseNodeException(node.Name, node);
			}
		}

		public static uint ParseUIntAttribute(string attribute, XmlNode node)
		{
			try
			{
				return uint.Parse(node.Attributes[attribute].Value);
			}
			catch
			{
				throw new GrInvalidParseAttributeException(attribute, node);
			}
		}

		public static bool ParseBoolAttribute(string attribute, XmlNode node)
		{
			try
			{
				return bool.Parse(node.Attributes[attribute].Value);
			}
			catch
			{
				throw new GrInvalidParseAttributeException(attribute, node);
			}
		}
	}
}
namespace GrBuildLib.Tools.Internal
{
	internal class Memory
	{
		public static void MemSet(byte[] array, byte value)
		{
			if (array != null)
			{
				int i = 0;
				int num = Math.Min(4096, array.Length);
				while (i < num)
				{
					array[i++] = value;
				}
				for (num = array.Length; i < num; i += 4096)
				{
					Buffer.BlockCopy(array, 0, array, i, Math.Min(4096, num - i));
				}
			}
		}

		[DllImport("kernel32.dll")]
		private static extern void CopyMemory(IntPtr dest, IntPtr src, uint count);

		public static void ReplicateData(IntPtr dest, IntPtr src, int size, int count)
		{
			IntPtr intPtr = dest;
			for (int i = 0; i < count; i++)
			{
				CopyMemory(intPtr, src, (uint)size);
				intPtr = IntPtr.Add(intPtr, size);
			}
		}
	}
}
