
// C:\WINDOWS\assembly\GAC_MSIL\System.Core\3.5.0.0__b77a5c561934e089\System.Core.dll
// System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089
// Global type: <Module>
// Architecture: AnyCPU (64-bit preferred)
// Runtime: v2.0.50727
// This assembly is signed with a strong name key.
// Hash algorithm: SHA1
// Public key: 00000000000000000400000000000000

using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Deployment.Internal;
using System.Diagnostics;
using System.Diagnostics.Eventing;
using System.Diagnostics.Eventing.Reader;
using System.Globalization;
using System.IO;
using System.Linq.Expressions;
using System.Numeric;
using System.Reflection;
using System.Reflection.Emit;
using System.Resources;
using System.Runtime.CompilerServices;
using System.Runtime.ConstrainedExecution;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.ComTypes;
using System.Runtime.Serialization;
using System.Security;
using System.Security.AccessControl;
using System.Security.Cryptography;
using System.Security.Cryptography.Pkcs;
using System.Security.Cryptography.X509Certificates;
using System.Security.Cryptography.Xml;
using System.Security.Permissions;
using System.Security.Principal;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml;
using System.Xml.XPath;
using Microsoft.Contracts;
using Microsoft.Win32;
using Microsoft.Win32.SafeHandles;

[assembly: AssemblyDelaySign(true)]
[assembly: SecurityCritical]
[assembly: AssemblyProduct("Microsoft® .NET Framework")]
[assembly: AssemblyCopyright("© Microsoft Corporation.  All rights reserved.")]
[assembly: AssemblyFileVersion("3.5.30729.9141")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: AssemblyInformationalVersion("3.5.30729.9141")]
[assembly: SatelliteContractVersion("3.5.0.0")]
[assembly: NeutralResourcesLanguage("en-US")]
[assembly: AssemblyKeyFile("f:\\dd\\tools\\devdiv\\EcmaPublicKey.snk")]
[assembly: StringFreezing]
[assembly: DefaultDependency(LoadHint.Always)]
[assembly: InternalsVisibleTo("Dlinq.Unittests, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")]
[assembly: ComVisible(false)]
[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: AllowPartiallyTrustedCallers]
[assembly: CLSCompliant(true)]
[assembly: AssemblyTitle("System.Core.dll")]
[assembly: AssemblyDescription("System.Core.dll")]
[assembly: AssemblyDefaultAlias("System.Core.dll")]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
[assembly: AssemblyVersion("3.5.0.0")]
[module: UnverifiableCode]
namespace Microsoft.Contracts
{
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Event, AllowMultiple = false, Inherited = true)]
	internal sealed class PureAttribute : Attribute
	{
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple = false, Inherited = false)]
	internal sealed class ContractClassAttribute : Attribute
	{
		private Type _typeWithContracts;

		public Type Type => _typeWithContracts;

		public ContractClassAttribute(Type t)
		{
			_typeWithContracts = t;
		}
	}
	[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
	internal sealed class InvariantMethodAttribute : Attribute
	{
	}
	[AttributeUsage(AttributeTargets.Assembly)]
	internal sealed class RuntimeContractsAttribute : Attribute
	{
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = false, Inherited = false)]
	internal sealed class ImmutableAttribute : Attribute
	{
	}
	[AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Constructor | AttributeTargets.Method | AttributeTargets.Property)]
	internal sealed class VerifyAttribute : Attribute
	{
		private bool _value;

		public bool Value => _value;

		public VerifyAttribute()
		{
			_value = true;
		}

		public VerifyAttribute(bool value)
		{
			_value = value;
		}
	}
	internal static class Contract
	{
		[Serializable]
		public sealed class PreconditionException : Exception
		{
			public PreconditionException()
				: this("Precondition failed.")
			{
			}

			public PreconditionException(string s)
				: base(s)
			{
			}

			public PreconditionException(string s, Exception inner)
				: base(s, inner)
			{
			}

			private PreconditionException(SerializationInfo info, StreamingContext context)
				: base(info, context)
			{
			}
		}

		[Serializable]
		public sealed class PostconditionException : Exception
		{
			public PostconditionException()
				: this("Postcondition failed.")
			{
			}

			public PostconditionException(string s)
				: base(s)
			{
			}

			public PostconditionException(string s, Exception inner)
				: base(s, inner)
			{
			}

			private PostconditionException(SerializationInfo info, StreamingContext context)
				: base(info, context)
			{
			}
		}

		[Serializable]
		public sealed class InvariantException : Exception
		{
			public InvariantException()
			{
			}

			public InvariantException(string s)
				: base(s)
			{
			}

			public InvariantException(string s, Exception inner)
				: base(s, inner)
			{
			}

			private InvariantException(SerializationInfo info, StreamingContext context)
				: base(info, context)
			{
			}
		}

		[Serializable]
		public sealed class AssertionException : Exception
		{
			public AssertionException()
			{
			}

			public AssertionException(string s)
				: base(s)
			{
			}

			public AssertionException(string s, Exception inner)
				: base(s, inner)
			{
			}

			private AssertionException(SerializationInfo info, StreamingContext context)
				: base(info, context)
			{
			}
		}

		[Serializable]
		public sealed class AssumptionException : Exception
		{
			public AssumptionException()
			{
			}

			public AssumptionException(string s)
				: base(s)
			{
			}

			public AssumptionException(string s, Exception inner)
				: base(s, inner)
			{
			}

			private AssumptionException(SerializationInfo info, StreamingContext context)
				: base(info, context)
			{
			}
		}

		[Conditional("DEBUG")]
		[Pure]
		public static void Assume(bool b)
		{
		}

		[Pure]
		[Conditional("DEBUG")]
		public static void Assume(bool b, string message)
		{
			if (!b)
			{
				throw new AssumptionException(message);
			}
		}

		[Conditional("DEBUG")]
		[Pure]
		public static void Assert(bool b)
		{
		}

		[Pure]
		[Conditional("DEBUG")]
		public static void Assert(bool b, string message)
		{
		}

		[Pure]
		public static void Requires(bool b)
		{
			if (!b)
			{
				throw new PreconditionException();
			}
		}

		[Pure]
		public static void Requires(Exception x)
		{
			if (x != null)
			{
				throw x;
			}
		}

		[Conditional("DEBUG")]
		[Pure]
		public static void DebugRequires(bool b)
		{
		}

		[Pure]
		[Conditional("USE_SPECSHARP_ASSEMBLY_REWRITER")]
		public static void Ensures(bool b)
		{
			_ = "This method will be modified to the following after rewriting:" + "if (!b) throw new PostConditionException();";
		}

		[Pure]
		[Conditional("USE_SPECSHARP_ASSEMBLY_REWRITER")]
		public static void Throws<E>() where E : Exception
		{
		}

		[Pure]
		[Conditional("USE_SPECSHARP_ASSEMBLY_REWRITER")]
		public static void ThrowsEnsures<E>(bool b) where E : Exception
		{
			_ = "This method will be modified to the following after rewriting:" + "if (!b) throw new PostconditionException();";
		}

		[Conditional("USE_SPECSHARP_ASSEMBLY_REWRITER")]
		[Pure]
		public static void AssertOnReturn(bool b)
		{
			_ = "This method will be modified to the following after rewriting:" + "if (!b) throw new AssertionException();";
		}

		[Conditional("USE_SPECSHARP_ASSEMBLY_REWRITER")]
		[Pure]
		public static void AssertOnException<E>(bool b) where E : Exception
		{
			_ = "This method will be modified to the following after rewriting:" + "if (!b) throw new AssertionException();";
		}

		[Pure]
		public static T Result<T>()
		{
			return default(T);
		}

		[Pure]
		public static T Parameter<T>(out T t)
		{
			t = default(T);
			return t;
		}

		[Pure]
		public static T Old<T>(T t)
		{
			return t;
		}

		[Pure]
		[Conditional("USE_SPECSHARP_ASSEMBLY_REWRITER")]
		public static void Invariant(bool b)
		{
			_ = "This method will be modified to the following after rewriting:" + "if (!b) throw new InvariantException();";
		}

		public static bool ForAll(int lo, int hi, Predicate<int> p)
		{
			Requires(lo <= hi);
			Requires(p != null);
			for (int i = lo; i < hi; i++)
			{
				if (!p(i))
				{
					return false;
				}
			}
			return true;
		}

		public static bool Exists(int lo, int hi, Predicate<int> p)
		{
			Requires(lo <= hi);
			Requires(p != null);
			for (int i = lo; i < hi; i++)
			{
				if (p(i))
				{
					return true;
				}
			}
			return false;
		}

		[Pure]
		public static void RewriterEnsures(bool b)
		{
			if (!b)
			{
				throw new PostconditionException();
			}
		}

		[Pure]
		public static void RewriterInvariant(bool b)
		{
			if (!b)
			{
				throw new InvariantException();
			}
		}
	}
}
namespace System.Diagnostics.Eventing
{
	[StructLayout(LayoutKind.Explicit, Size = 16)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public struct EventDescriptor
	{
		[FieldOffset(0)]
		private ushort m_id;

		[FieldOffset(2)]
		private byte m_version;

		[FieldOffset(3)]
		private byte m_channel;

		[FieldOffset(4)]
		private byte m_level;

		[FieldOffset(5)]
		private byte m_opcode;

		[FieldOffset(6)]
		private ushort m_task;

		[FieldOffset(8)]
		private long m_keywords;

		public int EventId => m_id;

		public byte Version => m_version;

		public byte Channel => m_channel;

		public byte Level => m_level;

		public byte Opcode => m_opcode;

		public int Task => m_task;

		public long Keywords => m_keywords;

		public EventDescriptor(int id, byte version, byte channel, byte level, byte opcode, int task, long keywords)
		{
			if (id < 0)
			{
				throw new ArgumentOutOfRangeException("id", SR.GetString("ArgumentOutOfRange_NeedNonNegNum"));
			}
			if (id > 65535)
			{
				throw new ArgumentOutOfRangeException("id", SR.GetString("ArgumentOutOfRange_NeedValidId", 1, ushort.MaxValue));
			}
			m_id = (ushort)id;
			m_version = version;
			m_channel = channel;
			m_level = level;
			m_opcode = opcode;
			m_keywords = keywords;
			if (task < 0)
			{
				throw new ArgumentOutOfRangeException("task", SR.GetString("ArgumentOutOfRange_NeedNonNegNum"));
			}
			if (task > 65535)
			{
				throw new ArgumentOutOfRangeException("task", SR.GetString("ArgumentOutOfRange_NeedValidId", 1, ushort.MaxValue));
			}
			m_task = (ushort)task;
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class EventProvider : IDisposable
	{
		public enum WriteEventErrorCode
		{
			NoError,
			NoFreeBuffers,
			EventTooBig
		}

		[StructLayout(LayoutKind.Explicit, Size = 16)]
		private struct EventData
		{
			[FieldOffset(0)]
			internal ulong DataPointer;

			[FieldOffset(8)]
			internal uint Size;

			[FieldOffset(12)]
			internal int Reserved;
		}

		private enum ActivityControl : uint
		{
			EVENT_ACTIVITY_CTRL_GET_ID = 1u,
			EVENT_ACTIVITY_CTRL_SET_ID,
			EVENT_ACTIVITY_CTRL_CREATE_ID,
			EVENT_ACTIVITY_CTRL_GET_SET_ID,
			EVENT_ACTIVITY_CTRL_CREATE_SET_ID
		}

		private const int s_basicTypeAllocationBufferSize = 16;

		private const int s_etwMaxMumberArguments = 32;

		private const int s_etwAPIMaxStringCount = 8;

		private const int s_maxEventDataDescriptors = 128;

		private const int s_traceEventMaximumSize = 65482;

		private const int s_traceEventMaximumStringSize = 32724;

		private Microsoft.Win32.UnsafeNativeMethods.EtwEnableCallback m_etwCallback;

		private long m_regHandle;

		private byte m_level;

		private long m_anyKeywordMask;

		private long m_allKeywordMask;

		private int m_enabled;

		private Guid m_providerId;

		private int m_disposed;

		private static LocalDataStoreSlot s_returnCodeSlot;

		private static bool s_platformNotSupported = Environment.OSVersion.Version.Major < 6;

		[SecurityCritical]
		[PermissionSet(SecurityAction.Demand, Unrestricted = true)]
		public EventProvider(Guid providerGuid)
		{
			m_providerId = providerGuid;
			s_returnCodeSlot = Thread.AllocateDataSlot();
			Thread.SetData(s_returnCodeSlot, 0);
			EtwRegister();
		}

		[SecurityCritical]
		private unsafe void EtwRegister()
		{
			if (s_platformNotSupported)
			{
				throw new PlatformNotSupportedException(SR.GetString("NotSupported_DownLevelVista"));
			}
			m_etwCallback = EtwEnableCallBack;
			uint num = Microsoft.Win32.UnsafeNativeMethods.EventRegister(ref m_providerId, m_etwCallback, null, ref m_regHandle);
			if (num != 0)
			{
				throw new Win32Exception((int)num);
			}
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		[SecurityCritical]
		[SecurityTreatAsSafe]
		protected virtual void Dispose(bool disposing)
		{
			if (m_disposed != 1 && Interlocked.Exchange(ref m_disposed, 1) == 0)
			{
				m_enabled = 0;
				Deregister();
			}
		}

		public virtual void Close()
		{
			Dispose();
		}

		~EventProvider()
		{
			Dispose(disposing: false);
		}

		[SecurityCritical]
		private void Deregister()
		{
			if (m_regHandle != 0)
			{
				Microsoft.Win32.UnsafeNativeMethods.EventUnregister(m_regHandle);
				m_regHandle = 0L;
			}
		}

		[SecurityCritical]
		private unsafe void EtwEnableCallBack([In] ref Guid sourceId, [In] int isEnabled, [In] byte setLevel, [In] long anyKeyword, [In] long allKeyword, [In] void* filterData, [In] void* callbackContext)
		{
			m_enabled = isEnabled;
			m_level = setLevel;
			m_anyKeywordMask = anyKeyword;
			m_allKeywordMask = allKeyword;
		}

		public bool IsEnabled()
		{
			if (m_enabled == 0)
			{
				return false;
			}
			return true;
		}

		public bool IsEnabled(byte level, long keywords)
		{
			if (m_enabled == 0)
			{
				return false;
			}
			if ((level <= m_level || m_level == 0) && (keywords == 0 || ((keywords & m_anyKeywordMask) != 0 && (keywords & m_allKeywordMask) == m_allKeywordMask)))
			{
				return true;
			}
			return false;
		}

		public static WriteEventErrorCode GetLastWriteEventError()
		{
			object data = Thread.GetData(s_returnCodeSlot);
			if (data == null)
			{
				return WriteEventErrorCode.NoError;
			}
			return (WriteEventErrorCode)(int)data;
		}

		private static void SetLastError(int error)
		{
			switch (error)
			{
			case 234:
			case 534:
				Thread.SetData(s_returnCodeSlot, 2);
				break;
			case 8:
				Thread.SetData(s_returnCodeSlot, 1);
				break;
			}
		}

		[SecurityCritical]
		private unsafe static string EncodeObject(ref object data, EventData* dataDescriptor, byte* dataBuffer)
		{
			dataDescriptor->Reserved = 0;
			if (data is string text)
			{
				dataDescriptor->Size = (uint)((text.Length + 1) * 2);
				return text;
			}
			if (data is IntPtr)
			{
				dataDescriptor->Size = (uint)sizeof(IntPtr);
				*(IntPtr*)dataBuffer = (IntPtr)data;
				dataDescriptor->DataPointer = (ulong)dataBuffer;
			}
			else if (data is int)
			{
				dataDescriptor->Size = 4u;
				*(int*)dataBuffer = (int)data;
				dataDescriptor->DataPointer = (ulong)dataBuffer;
			}
			else if (data is long)
			{
				dataDescriptor->Size = 8u;
				*(long*)dataBuffer = (long)data;
				dataDescriptor->DataPointer = (ulong)dataBuffer;
			}
			else if (data is uint)
			{
				dataDescriptor->Size = 4u;
				*(uint*)dataBuffer = (uint)data;
				dataDescriptor->DataPointer = (ulong)dataBuffer;
			}
			else if (data is ulong)
			{
				dataDescriptor->Size = 8u;
				*(ulong*)dataBuffer = (ulong)data;
				dataDescriptor->DataPointer = (ulong)dataBuffer;
			}
			else if (data is char)
			{
				dataDescriptor->Size = 2u;
				*(char*)dataBuffer = (char)data;
				dataDescriptor->DataPointer = (ulong)dataBuffer;
			}
			else if (data is byte)
			{
				dataDescriptor->Size = 1u;
				*dataBuffer = (byte)data;
				dataDescriptor->DataPointer = (ulong)dataBuffer;
			}
			else if (data is short)
			{
				dataDescriptor->Size = 2u;
				*(short*)dataBuffer = (short)data;
				dataDescriptor->DataPointer = (ulong)dataBuffer;
			}
			else if (data is sbyte)
			{
				dataDescriptor->Size = 1u;
				*dataBuffer = (byte)(sbyte)data;
				dataDescriptor->DataPointer = (ulong)dataBuffer;
			}
			else if (data is ushort)
			{
				dataDescriptor->Size = 2u;
				*(ushort*)dataBuffer = (ushort)data;
				dataDescriptor->DataPointer = (ulong)dataBuffer;
			}
			else if (data is float)
			{
				dataDescriptor->Size = 4u;
				*(float*)dataBuffer = (float)data;
				dataDescriptor->DataPointer = (ulong)dataBuffer;
			}
			else if (data is double)
			{
				dataDescriptor->Size = 8u;
				*(double*)dataBuffer = (double)data;
				dataDescriptor->DataPointer = (ulong)dataBuffer;
			}
			else if (data is bool)
			{
				dataDescriptor->Size = 1u;
				*dataBuffer = (((bool)data) ? ((byte)1) : ((byte)0));
				dataDescriptor->DataPointer = (ulong)dataBuffer;
			}
			else if (data is Guid)
			{
				dataDescriptor->Size = (uint)sizeof(Guid);
				*(Guid*)dataBuffer = (Guid)data;
				dataDescriptor->DataPointer = (ulong)dataBuffer;
			}
			else if (data is decimal)
			{
				dataDescriptor->Size = 16u;
				*(decimal*)dataBuffer = (decimal)data;
				dataDescriptor->DataPointer = (ulong)dataBuffer;
			}
			else
			{
				if (!(data is bool))
				{
					string text2 = data.ToString();
					dataDescriptor->Size = (uint)((text2.Length + 1) * 2);
					return text2;
				}
				dataDescriptor->Size = 1u;
				*dataBuffer = (((bool)data) ? ((byte)1) : ((byte)0));
				dataDescriptor->DataPointer = (ulong)dataBuffer;
			}
			return null;
		}

		[SecurityCritical]
		public unsafe bool WriteMessageEvent(string eventMessage, byte eventLevel, long eventKeywords)
		{
			int num = 0;
			if (eventMessage == null)
			{
				throw new ArgumentNullException("eventMessage");
			}
			if (IsEnabled(eventLevel, eventKeywords))
			{
				if (eventMessage.Length > 32724)
				{
					Thread.SetData(s_returnCodeSlot, 2);
					return false;
				}
				fixed (char* message = eventMessage)
				{
					num = (int)Microsoft.Win32.UnsafeNativeMethods.EventWriteString(m_regHandle, eventLevel, eventKeywords, message);
				}
				if (num != 0)
				{
					SetLastError(num);
					return false;
				}
			}
			return true;
		}

		public bool WriteMessageEvent(string eventMessage)
		{
			return WriteMessageEvent(eventMessage, 0, 0L);
		}

		[SecurityCritical]
		public unsafe bool WriteEvent(ref EventDescriptor eventDescriptor, params object[] eventPayload)
		{
			uint num = 0u;
			if (IsEnabled(eventDescriptor.Level, eventDescriptor.Keywords))
			{
				int num2 = 0;
				if (eventPayload == null || eventPayload.Length == 0 || eventPayload.Length == 1)
				{
					string text = null;
					byte* dataBuffer = stackalloc byte[16];
					EventData eventData = default(EventData);
					eventData.Size = 0u;
					if (eventPayload != null && eventPayload.Length != 0)
					{
						text = EncodeObject(ref eventPayload[0], &eventData, dataBuffer);
						num2 = 1;
					}
					if (eventData.Size > 65482)
					{
						Thread.SetData(s_returnCodeSlot, 2);
						return false;
					}
					if (text == null)
					{
						num = ((num2 != 0) ? Microsoft.Win32.UnsafeNativeMethods.EventWrite(m_regHandle, ref eventDescriptor, (uint)num2, &eventData) : Microsoft.Win32.UnsafeNativeMethods.EventWrite(m_regHandle, ref eventDescriptor, 0u, null));
					}
					else
					{
						fixed (char* ptr = text)
						{
							eventData.DataPointer = (ulong)ptr;
							num = Microsoft.Win32.UnsafeNativeMethods.EventWrite(m_regHandle, ref eventDescriptor, (uint)num2, &eventData);
						}
					}
				}
				else
				{
					num2 = eventPayload.Length;
					if (num2 > 32)
					{
						throw new ArgumentOutOfRangeException("eventPayload", SR.GetString("ArgumentOutOfRange_MaxArgExceeded", 32));
					}
					uint num3 = 0u;
					int num4 = 0;
					int[] array = new int[8];
					string[] array2 = new string[8];
					EventData* ptr2 = (EventData*)stackalloc byte[sizeof(EventData) * num2];
					EventData* ptr3 = ptr2;
					byte* ptr4 = stackalloc byte[16 * num2];
					byte* ptr5 = ptr4;
					for (int i = 0; i < eventPayload.Length; i++)
					{
						if (eventPayload[i] == null)
						{
							continue;
						}
						string text2 = EncodeObject(ref eventPayload[i], ptr3, ptr5);
						ptr5 += 16;
						num3 += ptr3->Size;
						ptr3++;
						if (text2 != null)
						{
							if (num4 >= 8)
							{
								throw new ArgumentOutOfRangeException("eventPayload", SR.GetString("ArgumentOutOfRange_MaxStringsExceeded", 8));
							}
							array2[num4] = text2;
							array[num4] = i;
							num4++;
						}
					}
					if (num3 > 65482)
					{
						Thread.SetData(s_returnCodeSlot, 2);
						return false;
					}
					fixed (char* ptr6 = array2[0])
					{
						fixed (char* ptr7 = array2[1])
						{
							fixed (char* ptr8 = array2[2])
							{
								fixed (char* ptr9 = array2[3])
								{
									fixed (char* ptr10 = array2[4])
									{
										fixed (char* ptr11 = array2[5])
										{
											fixed (char* ptr12 = array2[6])
											{
												fixed (char* ptr13 = array2[7])
												{
													ptr3 = ptr2;
													if (array2[0] != null)
													{
														ptr3[array[0]].DataPointer = (ulong)ptr6;
													}
													if (array2[1] != null)
													{
														ptr3[array[1]].DataPointer = (ulong)ptr7;
													}
													if (array2[2] != null)
													{
														ptr3[array[2]].DataPointer = (ulong)ptr8;
													}
													if (array2[3] != null)
													{
														ptr3[array[3]].DataPointer = (ulong)ptr9;
													}
													if (array2[4] != null)
													{
														ptr3[array[4]].DataPointer = (ulong)ptr10;
													}
													if (array2[5] != null)
													{
														ptr3[array[5]].DataPointer = (ulong)ptr11;
													}
													if (array2[6] != null)
													{
														ptr3[array[6]].DataPointer = (ulong)ptr12;
													}
													if (array2[7] != null)
													{
														ptr3[array[7]].DataPointer = (ulong)ptr13;
													}
													num = Microsoft.Win32.UnsafeNativeMethods.EventWrite(m_regHandle, ref eventDescriptor, (uint)num2, ptr2);
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
			if (num != 0)
			{
				SetLastError((int)num);
				return false;
			}
			return true;
		}

		[SecurityCritical]
		public unsafe bool WriteEvent(ref EventDescriptor eventDescriptor, string data)
		{
			uint num = 0u;
			if (data == null)
			{
				throw new ArgumentNullException("dataString");
			}
			if (IsEnabled(eventDescriptor.Level, eventDescriptor.Keywords))
			{
				if (data.Length > 32724)
				{
					Thread.SetData(s_returnCodeSlot, 2);
					return false;
				}
				EventData eventData = default(EventData);
				eventData.Size = (uint)((data.Length + 1) * 2);
				eventData.Reserved = 0;
				fixed (char* ptr = data)
				{
					eventData.DataPointer = (ulong)ptr;
					num = Microsoft.Win32.UnsafeNativeMethods.EventWrite(m_regHandle, ref eventDescriptor, 1u, &eventData);
				}
			}
			if (num != 0)
			{
				SetLastError((int)num);
				return false;
			}
			return true;
		}

		[SecurityCritical]
		protected unsafe bool WriteEvent(ref EventDescriptor eventDescriptor, int dataCount, IntPtr data)
		{
			uint num = 0u;
			num = Microsoft.Win32.UnsafeNativeMethods.EventWrite(m_regHandle, ref eventDescriptor, (uint)dataCount, (void*)data);
			if (num != 0)
			{
				SetLastError((int)num);
				return false;
			}
			return true;
		}

		[SecurityCritical]
		public unsafe bool WriteTransferEvent(ref EventDescriptor eventDescriptor, Guid relatedActivityId, params object[] eventPayload)
		{
			uint num = 0u;
			if (IsEnabled(eventDescriptor.Level, eventDescriptor.Keywords))
			{
				Guid activityId = GetActivityId();
				if (eventPayload != null && eventPayload.Length != 0)
				{
					int num2 = eventPayload.Length;
					if (num2 > 32)
					{
						throw new ArgumentOutOfRangeException("eventPayload", SR.GetString("ArgumentOutOfRange_MaxArgExceeded", 32));
					}
					uint num3 = 0u;
					int num4 = 0;
					int[] array = new int[8];
					string[] array2 = new string[8];
					EventData* ptr = (EventData*)stackalloc byte[sizeof(EventData) * num2];
					EventData* ptr2 = ptr;
					byte* ptr3 = stackalloc byte[16 * num2];
					byte* ptr4 = ptr3;
					for (int i = 0; i < eventPayload.Length; i++)
					{
						if (eventPayload[i] == null)
						{
							continue;
						}
						string text = EncodeObject(ref eventPayload[i], ptr2, ptr4);
						ptr4 += 16;
						num3 += ptr2->Size;
						ptr2++;
						if (text != null)
						{
							if (num4 >= 8)
							{
								throw new ArgumentOutOfRangeException("eventPayload", SR.GetString("ArgumentOutOfRange_MaxStringsExceeded", 8));
							}
							array2[num4] = text;
							array[num4] = i;
							num4++;
						}
					}
					if (num3 > 65482)
					{
						Thread.SetData(s_returnCodeSlot, 2);
						return false;
					}
					fixed (char* ptr5 = array2[0])
					{
						fixed (char* ptr6 = array2[1])
						{
							fixed (char* ptr7 = array2[2])
							{
								fixed (char* ptr8 = array2[3])
								{
									fixed (char* ptr9 = array2[4])
									{
										fixed (char* ptr10 = array2[5])
										{
											fixed (char* ptr11 = array2[6])
											{
												fixed (char* ptr12 = array2[7])
												{
													ptr2 = ptr;
													if (array2[0] != null)
													{
														ptr2[array[0]].DataPointer = (ulong)ptr5;
													}
													if (array2[1] != null)
													{
														ptr2[array[1]].DataPointer = (ulong)ptr6;
													}
													if (array2[2] != null)
													{
														ptr2[array[2]].DataPointer = (ulong)ptr7;
													}
													if (array2[3] != null)
													{
														ptr2[array[3]].DataPointer = (ulong)ptr8;
													}
													if (array2[4] != null)
													{
														ptr2[array[4]].DataPointer = (ulong)ptr9;
													}
													if (array2[5] != null)
													{
														ptr2[array[5]].DataPointer = (ulong)ptr10;
													}
													if (array2[6] != null)
													{
														ptr2[array[6]].DataPointer = (ulong)ptr11;
													}
													if (array2[7] != null)
													{
														ptr2[array[7]].DataPointer = (ulong)ptr12;
													}
													num = Microsoft.Win32.UnsafeNativeMethods.EventWriteTransfer(m_regHandle, ref eventDescriptor, ref activityId, ref relatedActivityId, (uint)num2, ptr);
												}
											}
										}
									}
								}
							}
						}
					}
				}
				else
				{
					num = Microsoft.Win32.UnsafeNativeMethods.EventWriteTransfer(m_regHandle, ref eventDescriptor, ref activityId, ref relatedActivityId, 0u, null);
				}
			}
			if (num != 0)
			{
				SetLastError((int)num);
				return false;
			}
			return true;
		}

		[SecurityCritical]
		protected unsafe bool WriteTransferEvent(ref EventDescriptor eventDescriptor, Guid relatedActivityId, int dataCount, IntPtr data)
		{
			uint num = 0u;
			Guid activityId = GetActivityId();
			num = Microsoft.Win32.UnsafeNativeMethods.EventWriteTransfer(m_regHandle, ref eventDescriptor, ref activityId, ref relatedActivityId, (uint)dataCount, (void*)data);
			if (num != 0)
			{
				SetLastError((int)num);
				return false;
			}
			return true;
		}

		[SecurityCritical]
		private static Guid GetActivityId()
		{
			object obj = Trace.CorrelationManager.ActivityId;
			if (obj != null)
			{
				return (Guid)obj;
			}
			return Guid.Empty;
		}

		[SecurityCritical]
		public static void SetActivityId(ref Guid id)
		{
			Microsoft.Win32.UnsafeNativeMethods.EventActivityIdControl(2, ref id);
		}

		[SecurityCritical]
		public static Guid CreateActivityId()
		{
			Guid ActivityId = default(Guid);
			Microsoft.Win32.UnsafeNativeMethods.EventActivityIdControl(3, ref ActivityId);
			return ActivityId;
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class EventProviderTraceListener : TraceListener
	{
		private const string s_nullStringValue = "null";

		private const string s_nullStringComaValue = "null,";

		private const string s_nullCStringValue = ": null";

		private const string s_activityIdString = "activityId=";

		private const string s_relatedActivityIdString = "relatedActivityId=";

		private const string s_callStackString = " : CallStack:";

		private const string s_optionDelimiter = "delimiter";

		private const uint s_keyWordMask = 4294967040u;

		private const int s_defaultPayloadSize = 512;

		private EventProvider m_provider;

		private string m_delimiter = ";";

		private int m_initializedDelim;

		private object m_Lock = new object();

		public string Delimiter
		{
			get
			{
				if (m_initializedDelim == 0)
				{
					lock (m_Lock)
					{
						if (m_initializedDelim == 0)
						{
							if (base.Attributes.ContainsKey("delimiter"))
							{
								m_delimiter = base.Attributes["delimiter"];
							}
							m_initializedDelim = 1;
						}
					}
					if (m_delimiter == null)
					{
						throw new ArgumentNullException("Delimiter");
					}
					if (m_delimiter.Length == 0)
					{
						throw new ArgumentException(SR.GetString("Argument_NeedNonemptyDelimiter"));
					}
				}
				return m_delimiter;
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("Delimiter");
				}
				if (value.Length == 0)
				{
					throw new ArgumentException(SR.GetString("Argument_NeedNonemptyDelimiter"));
				}
				lock (m_Lock)
				{
					m_delimiter = value;
					m_initializedDelim = 1;
				}
			}
		}

		public sealed override bool IsThreadSafe => true;

		protected override string[] GetSupportedAttributes()
		{
			return new string[1] { "delimiter" };
		}

		public EventProviderTraceListener(string providerId)
		{
			InitProvider(providerId);
		}

		public EventProviderTraceListener(string providerId, string name)
			: base(name)
		{
			InitProvider(providerId);
		}

		public EventProviderTraceListener(string providerId, string name, string delimiter)
			: base(name)
		{
			if (delimiter == null)
			{
				throw new ArgumentNullException("delimiter");
			}
			if (delimiter.Length == 0)
			{
				throw new ArgumentException(SR.GetString("Argument_NeedNonemptyDelimiter"));
			}
			m_delimiter = delimiter;
			m_initializedDelim = 1;
			InitProvider(providerId);
		}

		private void InitProvider(string providerId)
		{
			Guid providerGuid = new Guid(providerId);
			m_provider = new EventProvider(providerGuid);
		}

		public sealed override void Flush()
		{
		}

		public override void Close()
		{
			m_provider.Close();
		}

		public sealed override void Write(string message)
		{
			if (m_provider.IsEnabled())
			{
				m_provider.WriteMessageEvent(message, 8, 0L);
			}
		}

		public sealed override void WriteLine(string message)
		{
			Write(message);
		}

		public sealed override void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, object data)
		{
			if (m_provider.IsEnabled() && (base.Filter == null || base.Filter.ShouldTrace(eventCache, source, eventType, id, null, null, null, null)))
			{
				StringBuilder stringBuilder = new StringBuilder(512);
				if (data != null)
				{
					stringBuilder.Append(data.ToString());
				}
				else
				{
					stringBuilder.Append(": null");
				}
				if (eventCache != null && (base.TraceOutputOptions & TraceOptions.Callstack) != 0)
				{
					stringBuilder.Append(" : CallStack:");
					stringBuilder.Append(eventCache.Callstack);
					m_provider.WriteMessageEvent(stringBuilder.ToString(), (byte)eventType, (long)eventType & 0xFFFFFF00L);
				}
				else
				{
					m_provider.WriteMessageEvent(stringBuilder.ToString(), (byte)eventType, (long)eventType & 0xFFFFFF00L);
				}
			}
		}

		public sealed override void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, params object[] data)
		{
			if (!m_provider.IsEnabled() || (base.Filter != null && !base.Filter.ShouldTrace(eventCache, source, eventType, id, null, null, null, null)))
			{
				return;
			}
			StringBuilder stringBuilder = new StringBuilder(512);
			if (data != null && data.Length > 0)
			{
				int i;
				for (i = 0; i < data.Length - 1; i++)
				{
					if (data[i] != null)
					{
						stringBuilder.Append(data[i].ToString());
						stringBuilder.Append(Delimiter);
					}
					else
					{
						stringBuilder.Append("null,");
					}
				}
				if (data[i] != null)
				{
					stringBuilder.Append(data[i].ToString());
				}
				else
				{
					stringBuilder.Append("null");
				}
			}
			else
			{
				stringBuilder.Append("null");
			}
			if (eventCache != null && (base.TraceOutputOptions & TraceOptions.Callstack) != 0)
			{
				stringBuilder.Append(" : CallStack:");
				stringBuilder.Append(eventCache.Callstack);
				m_provider.WriteMessageEvent(stringBuilder.ToString(), (byte)eventType, (long)eventType & 0xFFFFFF00L);
			}
			else
			{
				m_provider.WriteMessageEvent(stringBuilder.ToString(), (byte)eventType, (long)eventType & 0xFFFFFF00L);
			}
		}

		public sealed override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id)
		{
			if (m_provider.IsEnabled() && (base.Filter == null || base.Filter.ShouldTrace(eventCache, source, eventType, id, null, null, null, null)))
			{
				if (eventCache != null && (base.TraceOutputOptions & TraceOptions.Callstack) != 0)
				{
					m_provider.WriteMessageEvent(" : CallStack:" + eventCache.Callstack, (byte)eventType, (long)eventType & 0xFFFFFF00L);
				}
				else
				{
					m_provider.WriteMessageEvent(string.Empty, (byte)eventType, (long)eventType & 0xFFFFFF00L);
				}
			}
		}

		public sealed override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message)
		{
			if (m_provider.IsEnabled() && (base.Filter == null || base.Filter.ShouldTrace(eventCache, source, eventType, id, null, null, null, null)))
			{
				StringBuilder stringBuilder = new StringBuilder(512);
				stringBuilder.Append(message);
				if (eventCache != null && (base.TraceOutputOptions & TraceOptions.Callstack) != 0)
				{
					stringBuilder.Append(" : CallStack:");
					stringBuilder.Append(eventCache.Callstack);
					m_provider.WriteMessageEvent(stringBuilder.ToString(), (byte)eventType, (long)eventType & 0xFFFFFF00L);
				}
				else
				{
					m_provider.WriteMessageEvent(stringBuilder.ToString(), (byte)eventType, (long)eventType & 0xFFFFFF00L);
				}
			}
		}

		public sealed override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, params object[] args)
		{
			if (!m_provider.IsEnabled() || (base.Filter != null && !base.Filter.ShouldTrace(eventCache, source, eventType, id, null, null, null, null)))
			{
				return;
			}
			if (args == null)
			{
				if (eventCache != null && (base.TraceOutputOptions & TraceOptions.Callstack) != 0)
				{
					m_provider.WriteMessageEvent(format + " : CallStack:" + eventCache.Callstack, (byte)eventType, (long)eventType & 0xFFFFFF00L);
				}
				else
				{
					m_provider.WriteMessageEvent(format, (byte)eventType, (long)eventType & 0xFFFFFF00L);
				}
			}
			else if (eventCache != null && (base.TraceOutputOptions & TraceOptions.Callstack) != 0)
			{
				m_provider.WriteMessageEvent(string.Format(CultureInfo.InvariantCulture, format, args) + " : CallStack:" + eventCache.Callstack, (byte)eventType, (long)eventType & 0xFFFFFF00L);
			}
			else
			{
				m_provider.WriteMessageEvent(string.Format(CultureInfo.InvariantCulture, format, args), (byte)eventType, (long)eventType & 0xFFFFFF00L);
			}
		}

		public override void Fail(string message, string detailMessage)
		{
			StringBuilder stringBuilder = new StringBuilder(message);
			if (detailMessage != null)
			{
				stringBuilder.Append(" ");
				stringBuilder.Append(detailMessage);
			}
			TraceEvent(null, null, TraceEventType.Error, 0, stringBuilder.ToString());
		}

		[SecurityCritical]
		public sealed override void TraceTransfer(TraceEventCache eventCache, string source, int id, string message, Guid relatedActivityId)
		{
			if (m_provider.IsEnabled())
			{
				StringBuilder stringBuilder = new StringBuilder(512);
				object obj = Trace.CorrelationManager.ActivityId;
				if (obj != null)
				{
					Guid guid = (Guid)obj;
					stringBuilder.Append("activityId=");
					stringBuilder.Append(guid.ToString());
					stringBuilder.Append(Delimiter);
				}
				stringBuilder.Append("relatedActivityId=");
				stringBuilder.Append(relatedActivityId.ToString());
				stringBuilder.Append(Delimiter + message);
				if (eventCache != null && (base.TraceOutputOptions & TraceOptions.Callstack) != 0)
				{
					stringBuilder.Append(" : CallStack:");
					stringBuilder.Append(eventCache.Callstack);
					m_provider.WriteMessageEvent(stringBuilder.ToString(), 0, 4096L);
				}
				else
				{
					m_provider.WriteMessageEvent(stringBuilder.ToString(), 0, 4096L);
				}
			}
		}
	}
}
namespace System.Management.Instrumentation
{
	[AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class ManagementEntityAttribute : Attribute
	{
		private string _nounName;

		private bool _isExternalClass;

		private bool _isSingleton;

		public string Name
		{
			get
			{
				return _nounName;
			}
			set
			{
				_nounName = value;
			}
		}

		public bool External
		{
			get
			{
				return _isExternalClass;
			}
			set
			{
				_isExternalClass = value;
			}
		}

		public bool Singleton
		{
			get
			{
				return _isSingleton;
			}
			set
			{
				_isSingleton = value;
			}
		}
	}
	public enum ManagementHostingModel
	{
		Decoupled,
		NetworkService,
		LocalService,
		LocalSystem
	}
	[AttributeUsage(AttributeTargets.Assembly)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class WmiConfigurationAttribute : Attribute
	{
		private string _Scope;

		private string _SecurityRestriction;

		private string _NamespaceSecurity;

		private ManagementHostingModel _HostingModel;

		private string _HostingGroup;

		private bool _IdentifyLevel = true;

		public string SecurityRestriction
		{
			get
			{
				return _SecurityRestriction;
			}
			set
			{
				_SecurityRestriction = value;
			}
		}

		public string NamespaceSecurity
		{
			get
			{
				return _NamespaceSecurity;
			}
			set
			{
				_NamespaceSecurity = value;
			}
		}

		public bool IdentifyLevel
		{
			get
			{
				return _IdentifyLevel;
			}
			set
			{
				_IdentifyLevel = value;
			}
		}

		public ManagementHostingModel HostingModel
		{
			get
			{
				return _HostingModel;
			}
			set
			{
				_HostingModel = value;
			}
		}

		public string HostingGroup
		{
			get
			{
				return _HostingGroup;
			}
			set
			{
				_HostingGroup = value;
			}
		}

		public string Scope => _Scope;

		public WmiConfigurationAttribute(string scope)
		{
			string text = scope;
			if (text != null)
			{
				text = text.Replace('/', '\\');
			}
			if (text == null || text.Length == 0)
			{
				text = "root\\default";
			}
			bool flag = true;
			string[] array = text.Split('\\');
			foreach (string text2 in array)
			{
				if (text2.Length != 0 && (!flag || string.Compare(text2, "root", StringComparison.OrdinalIgnoreCase) == 0) && Regex.Match(text2, "^[a-z,A-Z]").Success && !Regex.Match(text2, "_$").Success)
				{
					_ = Regex.Match(text2, "[^a-z,A-Z,0-9,_,\\u0080-\\uFFFF]").Success;
				}
				flag = false;
			}
			_Scope = text;
		}
	}
	[AttributeUsage(AttributeTargets.All)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public abstract class ManagementMemberAttribute : Attribute
	{
		private string _Name;

		public string Name
		{
			get
			{
				return _Name;
			}
			set
			{
				_Name = value;
			}
		}
	}
	[AttributeUsage(AttributeTargets.Constructor | AttributeTargets.Method, AllowMultiple = false)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public abstract class ManagementNewInstanceAttribute : ManagementMemberAttribute
	{
	}
	[AttributeUsage(AttributeTargets.Constructor | AttributeTargets.Method, AllowMultiple = false)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class ManagementBindAttribute : ManagementNewInstanceAttribute
	{
		private Type _schema;

		public Type Schema
		{
			get
			{
				return _schema;
			}
			set
			{
				_schema = value;
			}
		}
	}
	[AttributeUsage(AttributeTargets.Constructor | AttributeTargets.Method, AllowMultiple = false)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class ManagementCreateAttribute : ManagementNewInstanceAttribute
	{
	}
	[AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class ManagementRemoveAttribute : ManagementMemberAttribute
	{
		private Type _schema;

		public Type Schema
		{
			get
			{
				return _schema;
			}
			set
			{
				_schema = value;
			}
		}
	}
	[AttributeUsage(AttributeTargets.Constructor | AttributeTargets.Method, AllowMultiple = false)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class ManagementEnumeratorAttribute : ManagementNewInstanceAttribute
	{
		private Type _schema;

		public Type Schema
		{
			get
			{
				return _schema;
			}
			set
			{
				_schema = value;
			}
		}
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class ManagementProbeAttribute : ManagementMemberAttribute
	{
		private Type _schema;

		public Type Schema
		{
			get
			{
				return _schema;
			}
			set
			{
				_schema = value;
			}
		}
	}
	[AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class ManagementTaskAttribute : ManagementMemberAttribute
	{
		private Type _schema;

		public Type Schema
		{
			get
			{
				return _schema;
			}
			set
			{
				_schema = value;
			}
		}
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class ManagementKeyAttribute : ManagementMemberAttribute
	{
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter, AllowMultiple = false)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class ManagementReferenceAttribute : Attribute
	{
		private string _Type;

		public string Type
		{
			get
			{
				return _Type;
			}
			set
			{
				_Type = value;
			}
		}
	}
	public enum ManagementConfigurationType
	{
		Apply,
		OnCommit
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class ManagementConfigurationAttribute : ManagementMemberAttribute
	{
		private ManagementConfigurationType updateMode;

		private Type _schema;

		public ManagementConfigurationType Mode
		{
			get
			{
				return updateMode;
			}
			set
			{
				updateMode = value;
			}
		}

		public Type Schema
		{
			get
			{
				return _schema;
			}
			set
			{
				_schema = value;
			}
		}

		public ManagementConfigurationAttribute()
		{
			updateMode = ManagementConfigurationType.Apply;
		}
	}
	[AttributeUsage(AttributeTargets.Method)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class ManagementCommitAttribute : ManagementMemberAttribute
	{
	}
	[AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class ManagementNameAttribute : Attribute
	{
		private string _Name;

		public string Name => _Name;

		public ManagementNameAttribute(string name)
		{
			_Name = name;
		}
	}
	[Serializable]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class InstrumentationBaseException : Exception
	{
		public InstrumentationBaseException()
		{
		}

		public InstrumentationBaseException(string message)
			: base(message)
		{
		}

		public InstrumentationBaseException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		protected InstrumentationBaseException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}
	}
	[Serializable]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class InstrumentationException : InstrumentationBaseException
	{
		public InstrumentationException()
		{
		}

		public InstrumentationException(string message)
			: base(message)
		{
		}

		public InstrumentationException(Exception innerException)
			: base(null, innerException)
		{
		}

		public InstrumentationException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		protected InstrumentationException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}
	}
	[Serializable]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class InstanceNotFoundException : InstrumentationException
	{
		public InstanceNotFoundException()
		{
		}

		public InstanceNotFoundException(string message)
			: base(message)
		{
		}

		public InstanceNotFoundException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		protected InstanceNotFoundException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}
	}
}
namespace System.Diagnostics.Eventing.Reader
{
	[Serializable]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class EventBookmark : ISerializable
	{
		private string bookmark;

		internal string BookmarkText => bookmark;

		internal EventBookmark(string bookmarkText)
		{
			if (bookmarkText == null)
			{
				throw new ArgumentNullException("bookmarkText");
			}
			bookmark = bookmarkText;
		}

		protected EventBookmark(SerializationInfo info, StreamingContext context)
		{
			if (info == null)
			{
				throw new ArgumentNullException("info");
			}
			bookmark = info.GetString("BookmarkText");
		}

		[SecurityCritical]
		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
		void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
		{
			GetObjectData(info, context);
		}

		[SecurityCritical]
		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
		protected virtual void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			if (info == null)
			{
				throw new ArgumentNullException("info");
			}
			info.AddValue("BookmarkText", bookmark);
		}
	}
	public enum EventLogType
	{
		Administrative,
		Operational,
		Analytical,
		Debug
	}
	public enum EventLogIsolation
	{
		Application,
		System,
		Custom
	}
	public enum EventLogMode
	{
		Circular,
		AutoBackup,
		Retain
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class EventLogConfiguration : IDisposable
	{
		private EventLogHandle handle = EventLogHandle.Zero;

		private EventLogSession session;

		private string channelName;

		public string LogName => channelName;

		public EventLogType LogType => (EventLogType)(uint)NativeWrapper.EvtGetChannelConfigProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId.EvtChannelConfigType);

		public EventLogIsolation LogIsolation => (EventLogIsolation)(uint)NativeWrapper.EvtGetChannelConfigProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId.EvtChannelConfigIsolation);

		public bool IsEnabled
		{
			get
			{
				return (bool)NativeWrapper.EvtGetChannelConfigProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId.EvtChannelConfigEnabled);
			}
			set
			{
				NativeWrapper.EvtSetChannelConfigProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId.EvtChannelConfigEnabled, value);
			}
		}

		public bool IsClassicLog => (bool)NativeWrapper.EvtGetChannelConfigProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId.EvtChannelConfigClassicEventlog);

		public string SecurityDescriptor
		{
			get
			{
				return (string)NativeWrapper.EvtGetChannelConfigProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId.EvtChannelConfigAccess);
			}
			set
			{
				NativeWrapper.EvtSetChannelConfigProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId.EvtChannelConfigAccess, value);
			}
		}

		public string LogFilePath
		{
			get
			{
				return (string)NativeWrapper.EvtGetChannelConfigProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId.EvtChannelLoggingConfigLogFilePath);
			}
			set
			{
				NativeWrapper.EvtSetChannelConfigProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId.EvtChannelLoggingConfigLogFilePath, value);
			}
		}

		public long MaximumSizeInBytes
		{
			get
			{
				return (long)(ulong)NativeWrapper.EvtGetChannelConfigProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId.EvtChannelLoggingConfigMaxSize);
			}
			set
			{
				NativeWrapper.EvtSetChannelConfigProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId.EvtChannelLoggingConfigMaxSize, value);
			}
		}

		public EventLogMode LogMode
		{
			get
			{
				object obj = NativeWrapper.EvtGetChannelConfigProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId.EvtChannelLoggingConfigRetention);
				object obj2 = NativeWrapper.EvtGetChannelConfigProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId.EvtChannelLoggingConfigAutoBackup);
				bool flag = obj != null && (bool)obj;
				if (obj2 != null && (bool)obj2)
				{
					return EventLogMode.AutoBackup;
				}
				if (flag)
				{
					return EventLogMode.Retain;
				}
				return EventLogMode.Circular;
			}
			set
			{
				switch (value)
				{
				case EventLogMode.Circular:
					NativeWrapper.EvtSetChannelConfigProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId.EvtChannelLoggingConfigAutoBackup, false);
					NativeWrapper.EvtSetChannelConfigProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId.EvtChannelLoggingConfigRetention, false);
					break;
				case EventLogMode.AutoBackup:
					NativeWrapper.EvtSetChannelConfigProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId.EvtChannelLoggingConfigAutoBackup, true);
					NativeWrapper.EvtSetChannelConfigProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId.EvtChannelLoggingConfigRetention, true);
					break;
				case EventLogMode.Retain:
					NativeWrapper.EvtSetChannelConfigProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId.EvtChannelLoggingConfigAutoBackup, false);
					NativeWrapper.EvtSetChannelConfigProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId.EvtChannelLoggingConfigRetention, true);
					break;
				}
			}
		}

		public string OwningProviderName => (string)NativeWrapper.EvtGetChannelConfigProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId.EvtChannelConfigOwningPublisher);

		public IEnumerable<string> ProviderNames => (string[])NativeWrapper.EvtGetChannelConfigProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId.EvtChannelPublisherList);

		public int? ProviderLevel
		{
			get
			{
				return (int?)(uint?)NativeWrapper.EvtGetChannelConfigProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId.EvtChannelPublishingConfigLevel);
			}
			set
			{
				NativeWrapper.EvtSetChannelConfigProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId.EvtChannelPublishingConfigLevel, value);
			}
		}

		public long? ProviderKeywords
		{
			get
			{
				return (long?)(ulong?)NativeWrapper.EvtGetChannelConfigProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId.EvtChannelPublishingConfigKeywords);
			}
			set
			{
				NativeWrapper.EvtSetChannelConfigProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId.EvtChannelPublishingConfigKeywords, value);
			}
		}

		public int? ProviderBufferSize => (int?)(uint?)NativeWrapper.EvtGetChannelConfigProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId.EvtChannelPublishingConfigBufferSize);

		public int? ProviderMinimumNumberOfBuffers => (int?)(uint?)NativeWrapper.EvtGetChannelConfigProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId.EvtChannelPublishingConfigMinBuffers);

		public int? ProviderMaximumNumberOfBuffers => (int?)(uint?)NativeWrapper.EvtGetChannelConfigProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId.EvtChannelPublishingConfigMaxBuffers);

		public int? ProviderLatency => (int?)(uint?)NativeWrapper.EvtGetChannelConfigProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId.EvtChannelPublishingConfigLatency);

		public Guid? ProviderControlGuid => (Guid?)NativeWrapper.EvtGetChannelConfigProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId.EvtChannelPublishingConfigControlGuid);

		public EventLogConfiguration(string logName)
			: this(logName, null)
		{
		}

		[SecurityCritical]
		public EventLogConfiguration(string logName, EventLogSession session)
		{
			EventLogPermissionHolder.GetEventLogPermission().Demand();
			if (session == null)
			{
				session = EventLogSession.GlobalSession;
			}
			this.session = session;
			channelName = logName;
			handle = NativeWrapper.EvtOpenChannelConfig(this.session.Handle, channelName, 0);
		}

		public void SaveChanges()
		{
			NativeWrapper.EvtSaveChannelConfig(handle, 0);
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		[SecurityTreatAsSafe]
		[SecurityCritical]
		protected virtual void Dispose(bool disposing)
		{
			if (disposing)
			{
				EventLogPermissionHolder.GetEventLogPermission().Demand();
			}
			if (handle != null && !handle.IsInvalid)
			{
				handle.Dispose();
			}
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class EventLogLink
	{
		private string channelName;

		private bool isImported;

		private string displayName;

		private uint channelId;

		private bool dataReady;

		private ProviderMetadata pmReference;

		private object syncObject;

		public string LogName
		{
			get
			{
				PrepareData();
				return channelName;
			}
		}

		public bool IsImported
		{
			get
			{
				PrepareData();
				return isImported;
			}
		}

		public string DisplayName
		{
			get
			{
				PrepareData();
				return displayName;
			}
		}

		internal uint ChannelId => channelId;

		internal EventLogLink(uint channelId, ProviderMetadata pmReference)
		{
			this.channelId = channelId;
			this.pmReference = pmReference;
			syncObject = new object();
		}

		internal EventLogLink(string channelName, bool isImported, string displayName, uint channelId)
		{
			this.channelName = channelName;
			this.isImported = isImported;
			this.displayName = displayName;
			this.channelId = channelId;
			dataReady = true;
			syncObject = new object();
		}

		private void PrepareData()
		{
			if (dataReady)
			{
				return;
			}
			lock (syncObject)
			{
				if (dataReady)
				{
					return;
				}
				IEnumerable<EventLogLink> logLinks = pmReference.LogLinks;
				channelName = null;
				isImported = false;
				displayName = null;
				dataReady = true;
				foreach (EventLogLink item in logLinks)
				{
					if (item.ChannelId == channelId)
					{
						channelName = item.LogName;
						isImported = item.IsImported;
						displayName = item.DisplayName;
						dataReady = true;
						break;
					}
				}
			}
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class EventLogStatus
	{
		private string channelName;

		private int win32ErrorCode;

		public string LogName => channelName;

		public int StatusCode => win32ErrorCode;

		internal EventLogStatus(string channelName, int win32ErrorCode)
		{
			this.channelName = channelName;
			this.win32ErrorCode = win32ErrorCode;
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class EventProperty
	{
		private object value;

		public object Value => value;

		internal EventProperty(object value)
		{
			this.value = value;
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class EventLogPropertySelector : IDisposable
	{
		private EventLogHandle renderContextHandleValues;

		internal EventLogHandle Handle => renderContextHandleValues;

		[SecurityCritical]
		public EventLogPropertySelector(IEnumerable<string> propertyQueries)
		{
			EventLogPermissionHolder.GetEventLogPermission().Demand();
			if (propertyQueries == null)
			{
				throw new ArgumentNullException("propertyQueries");
			}
			string[] array;
			if (propertyQueries is ICollection<string> collection)
			{
				array = new string[collection.Count];
				collection.CopyTo(array, 0);
			}
			else
			{
				List<string> list = new List<string>(propertyQueries);
				array = list.ToArray();
			}
			renderContextHandleValues = NativeWrapper.EvtCreateRenderContext(array.Length, array, Microsoft.Win32.UnsafeNativeMethods.EvtRenderContextFlags.EvtRenderContextValues);
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		[SecurityTreatAsSafe]
		[SecurityCritical]
		protected virtual void Dispose(bool disposing)
		{
			if (disposing)
			{
				EventLogPermissionHolder.GetEventLogPermission().Demand();
			}
			if (renderContextHandleValues != null && !renderContextHandleValues.IsInvalid)
			{
				renderContextHandleValues.Dispose();
			}
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public abstract class EventRecord : IDisposable
	{
		public abstract int Id { get; }

		public abstract byte? Version { get; }

		public abstract byte? Level { get; }

		public abstract int? Task { get; }

		public abstract short? Opcode { get; }

		public abstract long? Keywords { get; }

		public abstract long? RecordId { get; }

		public abstract string ProviderName { get; }

		public abstract Guid? ProviderId { get; }

		public abstract string LogName { get; }

		public abstract int? ProcessId { get; }

		public abstract int? ThreadId { get; }

		public abstract string MachineName { get; }

		public abstract SecurityIdentifier UserId { get; }

		public abstract DateTime? TimeCreated { get; }

		public abstract Guid? ActivityId { get; }

		public abstract Guid? RelatedActivityId { get; }

		public abstract int? Qualifiers { get; }

		public abstract string LevelDisplayName { get; }

		public abstract string OpcodeDisplayName { get; }

		public abstract string TaskDisplayName { get; }

		public abstract IEnumerable<string> KeywordsDisplayNames { get; }

		public abstract EventBookmark Bookmark { get; }

		public abstract IList<EventProperty> Properties { get; }

		public abstract string FormatDescription();

		public abstract string FormatDescription(IEnumerable<object> values);

		public abstract string ToXml();

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		protected virtual void Dispose(bool disposing)
		{
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class EventKeyword
	{
		private long value;

		private string name;

		private string displayName;

		private bool dataReady;

		private ProviderMetadata pmReference;

		private object syncObject;

		public string Name
		{
			get
			{
				PrepareData();
				return name;
			}
		}

		public long Value => value;

		public string DisplayName
		{
			get
			{
				PrepareData();
				return displayName;
			}
		}

		internal EventKeyword(long value, ProviderMetadata pmReference)
		{
			this.value = value;
			this.pmReference = pmReference;
			syncObject = new object();
		}

		internal EventKeyword(string name, long value, string displayName)
		{
			this.value = value;
			this.name = name;
			this.displayName = displayName;
			dataReady = true;
			syncObject = new object();
		}

		internal void PrepareData()
		{
			if (dataReady)
			{
				return;
			}
			lock (syncObject)
			{
				if (dataReady)
				{
					return;
				}
				IEnumerable<EventKeyword> keywords = pmReference.Keywords;
				name = null;
				displayName = null;
				dataReady = true;
				foreach (EventKeyword item in keywords)
				{
					if (item.Value == value)
					{
						name = item.Name;
						displayName = item.DisplayName;
						break;
					}
				}
			}
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class EventLevel
	{
		private int value;

		private string name;

		private string displayName;

		private bool dataReady;

		private ProviderMetadata pmReference;

		private object syncObject;

		public string Name
		{
			get
			{
				PrepareData();
				return name;
			}
		}

		public int Value => value;

		public string DisplayName
		{
			get
			{
				PrepareData();
				return displayName;
			}
		}

		internal EventLevel(int value, ProviderMetadata pmReference)
		{
			this.value = value;
			this.pmReference = pmReference;
			syncObject = new object();
		}

		internal EventLevel(string name, int value, string displayName)
		{
			this.value = value;
			this.name = name;
			this.displayName = displayName;
			dataReady = true;
			syncObject = new object();
		}

		internal void PrepareData()
		{
			if (dataReady)
			{
				return;
			}
			lock (syncObject)
			{
				if (dataReady)
				{
					return;
				}
				IEnumerable<EventLevel> levels = pmReference.Levels;
				name = null;
				displayName = null;
				dataReady = true;
				foreach (EventLevel item in levels)
				{
					if (item.Value == value)
					{
						name = item.Name;
						displayName = item.DisplayName;
						break;
					}
				}
			}
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class EventLogRecord : EventRecord
	{
		private const int SYSTEM_PROPERTY_COUNT = 18;

		[SecurityTreatAsSafe]
		private EventLogHandle handle;

		private EventLogSession session;

		private NativeWrapper.SystemProperties systemProperties;

		private string containerChannel;

		private int[] matchedQueryIds;

		private object syncObject;

		private string levelName;

		private string taskName;

		private string opcodeName;

		private IEnumerable<string> keywordsNames;

		private bool levelNameReady;

		private bool taskNameReady;

		private bool opcodeNameReady;

		private ProviderMetadataCachedInformation cachedMetadataInformation;

		internal EventLogHandle Handle
		{
			[SecurityTreatAsSafe]
			get
			{
				return handle;
			}
		}

		public override int Id
		{
			get
			{
				PrepareSystemData();
				if (!((int?)systemProperties.Id).HasValue)
				{
					return 0;
				}
				return systemProperties.Id.Value;
			}
		}

		public override byte? Version
		{
			get
			{
				PrepareSystemData();
				return systemProperties.Version;
			}
		}

		public override int? Qualifiers
		{
			get
			{
				PrepareSystemData();
				return systemProperties.Qualifiers;
			}
		}

		public override byte? Level
		{
			get
			{
				PrepareSystemData();
				return systemProperties.Level;
			}
		}

		public override int? Task
		{
			get
			{
				PrepareSystemData();
				return systemProperties.Task;
			}
		}

		public override short? Opcode
		{
			get
			{
				PrepareSystemData();
				return systemProperties.Opcode;
			}
		}

		public override long? Keywords
		{
			get
			{
				PrepareSystemData();
				return (long?)systemProperties.Keywords;
			}
		}

		public override long? RecordId
		{
			get
			{
				PrepareSystemData();
				return (long?)systemProperties.RecordId;
			}
		}

		public override string ProviderName
		{
			get
			{
				PrepareSystemData();
				return systemProperties.ProviderName;
			}
		}

		public override Guid? ProviderId
		{
			get
			{
				PrepareSystemData();
				return systemProperties.ProviderId;
			}
		}

		public override string LogName
		{
			get
			{
				PrepareSystemData();
				return systemProperties.ChannelName;
			}
		}

		public override int? ProcessId
		{
			get
			{
				PrepareSystemData();
				return (int?)systemProperties.ProcessId;
			}
		}

		public override int? ThreadId
		{
			get
			{
				PrepareSystemData();
				return (int?)systemProperties.ThreadId;
			}
		}

		public override string MachineName
		{
			get
			{
				PrepareSystemData();
				return systemProperties.ComputerName;
			}
		}

		public override SecurityIdentifier UserId
		{
			get
			{
				PrepareSystemData();
				return systemProperties.UserId;
			}
		}

		public override DateTime? TimeCreated
		{
			get
			{
				PrepareSystemData();
				return systemProperties.TimeCreated;
			}
		}

		public override Guid? ActivityId
		{
			get
			{
				PrepareSystemData();
				return systemProperties.ActivityId;
			}
		}

		public override Guid? RelatedActivityId
		{
			get
			{
				PrepareSystemData();
				return systemProperties.RelatedActivityId;
			}
		}

		public string ContainerLog
		{
			get
			{
				if (containerChannel != null)
				{
					return containerChannel;
				}
				lock (syncObject)
				{
					if (containerChannel == null)
					{
						containerChannel = (string)NativeWrapper.EvtGetEventInfo(Handle, Microsoft.Win32.UnsafeNativeMethods.EvtEventPropertyId.EvtEventPath);
					}
					return containerChannel;
				}
			}
		}

		public IEnumerable<int> MatchedQueryIds
		{
			get
			{
				if (matchedQueryIds != null)
				{
					return matchedQueryIds;
				}
				lock (syncObject)
				{
					if (matchedQueryIds == null)
					{
						matchedQueryIds = (int[])NativeWrapper.EvtGetEventInfo(Handle, Microsoft.Win32.UnsafeNativeMethods.EvtEventPropertyId.EvtEventQueryIDs);
					}
					return matchedQueryIds;
				}
			}
		}

		public override EventBookmark Bookmark
		{
			[SecurityTreatAsSafe]
			[SecurityCritical]
			get
			{
				EventLogPermissionHolder.GetEventLogPermission().Demand();
				EventLogHandle eventLogHandle = NativeWrapper.EvtCreateBookmark(null);
				NativeWrapper.EvtUpdateBookmark(eventLogHandle, handle);
				string bookmarkText = NativeWrapper.EvtRenderBookmark(eventLogHandle);
				return new EventBookmark(bookmarkText);
			}
		}

		public override string LevelDisplayName
		{
			get
			{
				if (levelNameReady)
				{
					return levelName;
				}
				lock (syncObject)
				{
					if (!levelNameReady)
					{
						levelNameReady = true;
						levelName = cachedMetadataInformation.GetLevelDisplayName(ProviderName, handle);
					}
					return levelName;
				}
			}
		}

		public override string OpcodeDisplayName
		{
			get
			{
				lock (syncObject)
				{
					if (!opcodeNameReady)
					{
						opcodeNameReady = true;
						opcodeName = cachedMetadataInformation.GetOpcodeDisplayName(ProviderName, handle);
					}
					return opcodeName;
				}
			}
		}

		public override string TaskDisplayName
		{
			get
			{
				if (taskNameReady)
				{
					return taskName;
				}
				lock (syncObject)
				{
					if (!taskNameReady)
					{
						taskNameReady = true;
						taskName = cachedMetadataInformation.GetTaskDisplayName(ProviderName, handle);
					}
					return taskName;
				}
			}
		}

		public override IEnumerable<string> KeywordsDisplayNames
		{
			get
			{
				if (keywordsNames != null)
				{
					return keywordsNames;
				}
				lock (syncObject)
				{
					if (keywordsNames == null)
					{
						keywordsNames = cachedMetadataInformation.GetKeywordDisplayNames(ProviderName, handle);
					}
					return keywordsNames;
				}
			}
		}

		public override IList<EventProperty> Properties
		{
			get
			{
				session.SetupUserContext();
				IList<object> list = NativeWrapper.EvtRenderBufferWithContextUserOrValues(session.renderContextHandleUser, handle);
				List<EventProperty> list2 = new List<EventProperty>();
				foreach (object item in list)
				{
					list2.Add(new EventProperty(item));
				}
				return list2;
			}
		}

		[SecurityTreatAsSafe]
		internal EventLogRecord(EventLogHandle handle, EventLogSession session, ProviderMetadataCachedInformation cachedMetadataInfo)
		{
			cachedMetadataInformation = cachedMetadataInfo;
			this.handle = handle;
			this.session = session;
			systemProperties = new NativeWrapper.SystemProperties();
			syncObject = new object();
		}

		internal void PrepareSystemData()
		{
			if (systemProperties.filled)
			{
				return;
			}
			session.SetupSystemContext();
			lock (syncObject)
			{
				if (!systemProperties.filled)
				{
					NativeWrapper.EvtRenderBufferWithContextSystem(session.renderContextHandleSystem, handle, Microsoft.Win32.UnsafeNativeMethods.EvtRenderFlags.EvtRenderEventValues, systemProperties, 18);
					systemProperties.filled = true;
				}
			}
		}

		public override string FormatDescription()
		{
			return cachedMetadataInformation.GetFormatDescription(ProviderName, handle);
		}

		public override string FormatDescription(IEnumerable<object> values)
		{
			if (values == null)
			{
				return FormatDescription();
			}
			string[] array = new string[0];
			int num = 0;
			foreach (object value in values)
			{
				if (array.Length == num)
				{
					Array.Resize(ref array, num + 1);
				}
				array[num] = value.ToString();
				num++;
			}
			return cachedMetadataInformation.GetFormatDescription(ProviderName, handle, array);
		}

		public IList<object> GetPropertyValues(EventLogPropertySelector propertySelector)
		{
			if (propertySelector == null)
			{
				throw new ArgumentNullException("propertySelector");
			}
			return NativeWrapper.EvtRenderBufferWithContextUserOrValues(propertySelector.Handle, handle);
		}

		[SecurityTreatAsSafe]
		[SecurityCritical]
		public override string ToXml()
		{
			EventLogPermissionHolder.GetEventLogPermission().Demand();
			StringBuilder stringBuilder = new StringBuilder(2000);
			NativeWrapper.EvtRender(EventLogHandle.Zero, handle, Microsoft.Win32.UnsafeNativeMethods.EvtRenderFlags.EvtRenderEventXml, stringBuilder);
			return stringBuilder.ToString();
		}

		[SecurityTreatAsSafe]
		[SecurityCritical]
		protected override void Dispose(bool disposing)
		{
			try
			{
				if (disposing)
				{
					EventLogPermissionHolder.GetEventLogPermission().Demand();
				}
				if (handle != null && !handle.IsInvalid)
				{
					handle.Dispose();
				}
			}
			finally
			{
				base.Dispose(disposing);
			}
		}

		[SecurityCritical]
		internal static EventLogHandle GetBookmarkHandleFromBookmark(EventBookmark bookmark)
		{
			if (bookmark == null)
			{
				return EventLogHandle.Zero;
			}
			return NativeWrapper.EvtCreateBookmark(bookmark.BookmarkText);
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class EventLogReader : IDisposable
	{
		private EventLogQuery eventQuery;

		private int batchSize;

		private EventLogHandle handle;

		private IntPtr[] eventsBuffer;

		private int currentIndex;

		private int eventCount;

		private bool isEof;

		private ProviderMetadataCachedInformation cachedMetadataInformation;

		public int BatchSize
		{
			get
			{
				return batchSize;
			}
			set
			{
				if (value < 1)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				batchSize = value;
			}
		}

		public IList<EventLogStatus> LogStatus
		{
			[SecurityCritical]
			get
			{
				EventLogPermissionHolder.GetEventLogPermission().Demand();
				List<EventLogStatus> list = null;
				string[] array = null;
				int[] array2 = null;
				EventLogHandle eventLogHandle = handle;
				if (eventLogHandle.IsInvalid)
				{
					throw new InvalidOperationException();
				}
				array = (string[])NativeWrapper.EvtGetQueryInfo(eventLogHandle, Microsoft.Win32.UnsafeNativeMethods.EvtQueryPropertyId.EvtQueryNames);
				array2 = (int[])NativeWrapper.EvtGetQueryInfo(eventLogHandle, Microsoft.Win32.UnsafeNativeMethods.EvtQueryPropertyId.EvtQueryStatuses);
				if (array.Length != array2.Length)
				{
					throw new InvalidOperationException();
				}
				list = new List<EventLogStatus>(array.Length);
				for (int i = 0; i < array.Length; i++)
				{
					EventLogStatus item = new EventLogStatus(array[i], array2[i]);
					list.Add(item);
				}
				return list.AsReadOnly();
			}
		}

		public EventLogReader(string path)
			: this(new EventLogQuery(path, PathType.LogName), null)
		{
		}

		public EventLogReader(string path, PathType pathType)
			: this(new EventLogQuery(path, pathType), null)
		{
		}

		public EventLogReader(EventLogQuery eventQuery)
			: this(eventQuery, null)
		{
		}

		[SecurityCritical]
		public EventLogReader(EventLogQuery eventQuery, EventBookmark bookmark)
		{
			if (eventQuery == null)
			{
				throw new ArgumentNullException("eventQuery");
			}
			string logfile = null;
			if (eventQuery.ThePathType == PathType.FilePath)
			{
				logfile = eventQuery.Path;
			}
			cachedMetadataInformation = new ProviderMetadataCachedInformation(eventQuery.Session, logfile, 50);
			this.eventQuery = eventQuery;
			batchSize = 64;
			eventsBuffer = new IntPtr[batchSize];
			int num = 0;
			num = ((this.eventQuery.ThePathType != PathType.LogName) ? (num | 2) : (num | 1));
			if (this.eventQuery.ReverseDirection)
			{
				num |= 0x200;
			}
			if (this.eventQuery.TolerateQueryErrors)
			{
				num |= 0x1000;
			}
			EventLogPermissionHolder.GetEventLogPermission().Demand();
			handle = NativeWrapper.EvtQuery(this.eventQuery.Session.Handle, this.eventQuery.Path, this.eventQuery.Query, num);
			EventLogHandle bookmarkHandleFromBookmark = EventLogRecord.GetBookmarkHandleFromBookmark(bookmark);
			if (!bookmarkHandleFromBookmark.IsInvalid)
			{
				using (bookmarkHandleFromBookmark)
				{
					NativeWrapper.EvtSeek(handle, 1L, bookmarkHandleFromBookmark, 0, Microsoft.Win32.UnsafeNativeMethods.EvtSeekFlags.EvtSeekRelativeToBookmark);
				}
			}
		}

		[SecurityCritical]
		private bool GetNextBatch(TimeSpan ts)
		{
			int timeout = ((!(ts == TimeSpan.MaxValue)) ? ((int)ts.TotalMilliseconds) : (-1));
			if (batchSize != eventsBuffer.Length)
			{
				eventsBuffer = new IntPtr[batchSize];
			}
			int returned = 0;
			if (!NativeWrapper.EvtNext(handle, batchSize, eventsBuffer, timeout, 0, ref returned))
			{
				eventCount = 0;
				currentIndex = 0;
				return false;
			}
			currentIndex = 0;
			eventCount = returned;
			return true;
		}

		public EventRecord ReadEvent()
		{
			return ReadEvent(TimeSpan.MaxValue);
		}

		[SecurityCritical]
		public EventRecord ReadEvent(TimeSpan timeout)
		{
			EventLogPermissionHolder.GetEventLogPermission().Demand();
			if (isEof)
			{
				throw new InvalidOperationException();
			}
			if (currentIndex >= eventCount)
			{
				GetNextBatch(timeout);
				if (currentIndex >= eventCount)
				{
					isEof = true;
					return null;
				}
			}
			EventLogRecord result = new EventLogRecord(new EventLogHandle(eventsBuffer[currentIndex], ownsHandle: true), eventQuery.Session, cachedMetadataInformation);
			currentIndex++;
			return result;
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		[SecurityCritical]
		[SecurityTreatAsSafe]
		protected virtual void Dispose(bool disposing)
		{
			if (disposing)
			{
				EventLogPermissionHolder.GetEventLogPermission().Demand();
			}
			while (currentIndex < eventCount)
			{
				NativeWrapper.EvtClose(eventsBuffer[currentIndex]);
				currentIndex++;
			}
			if (handle != null && !handle.IsInvalid)
			{
				handle.Dispose();
			}
		}

		[SecurityCritical]
		internal void SeekReset()
		{
			while (currentIndex < eventCount)
			{
				NativeWrapper.EvtClose(eventsBuffer[currentIndex]);
				currentIndex++;
			}
			currentIndex = 0;
			eventCount = 0;
			isEof = false;
		}

		[SecurityCritical]
		internal void SeekCommon(long offset)
		{
			offset -= eventCount - currentIndex;
			SeekReset();
			NativeWrapper.EvtSeek(handle, offset, EventLogHandle.Zero, 0, Microsoft.Win32.UnsafeNativeMethods.EvtSeekFlags.EvtSeekRelativeToCurrent);
		}

		public void Seek(EventBookmark bookmark)
		{
			Seek(bookmark, 0L);
		}

		[SecurityCritical]
		public void Seek(EventBookmark bookmark, long offset)
		{
			if (bookmark == null)
			{
				throw new ArgumentNullException("bookmark");
			}
			EventLogPermissionHolder.GetEventLogPermission().Demand();
			SeekReset();
			using EventLogHandle bookmark2 = EventLogRecord.GetBookmarkHandleFromBookmark(bookmark);
			NativeWrapper.EvtSeek(handle, offset, bookmark2, 0, Microsoft.Win32.UnsafeNativeMethods.EvtSeekFlags.EvtSeekRelativeToBookmark);
		}

		[SecurityCritical]
		public void Seek(SeekOrigin origin, long offset)
		{
			EventLogPermissionHolder.GetEventLogPermission().Demand();
			switch (origin)
			{
			case SeekOrigin.Begin:
				SeekReset();
				NativeWrapper.EvtSeek(handle, offset, EventLogHandle.Zero, 0, Microsoft.Win32.UnsafeNativeMethods.EvtSeekFlags.EvtSeekRelativeToFirst);
				break;
			case SeekOrigin.End:
				SeekReset();
				NativeWrapper.EvtSeek(handle, offset, EventLogHandle.Zero, 0, Microsoft.Win32.UnsafeNativeMethods.EvtSeekFlags.EvtSeekRelativeToLast);
				break;
			case SeekOrigin.Current:
				if (offset >= 0)
				{
					if (currentIndex + offset < eventCount)
					{
						for (int i = currentIndex; i < currentIndex + offset; i++)
						{
							NativeWrapper.EvtClose(eventsBuffer[i]);
						}
						currentIndex = (int)(currentIndex + offset);
					}
					else
					{
						SeekCommon(offset);
					}
				}
				else if (currentIndex + offset >= 0)
				{
					SeekCommon(offset);
				}
				else
				{
					SeekCommon(offset);
				}
				break;
			}
		}

		public void CancelReading()
		{
			NativeWrapper.EvtCancel(handle);
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class EventLogWatcher : IDisposable
	{
		private EventLogQuery eventQuery;

		private EventBookmark bookmark;

		private bool readExistingEvents;

		private EventLogHandle handle;

		private IntPtr[] eventsBuffer;

		private int numEventsInBuffer;

		private bool isSubscribing;

		private int callbackThreadId;

		private AutoResetEvent subscriptionWaitHandle;

		private AutoResetEvent unregisterDoneHandle;

		private RegisteredWaitHandle registeredWaitHandle;

		private ProviderMetadataCachedInformation cachedMetadataInformation;

		private Exception asyncException;

		public bool Enabled
		{
			get
			{
				return isSubscribing;
			}
			set
			{
				if (value && !isSubscribing)
				{
					StartSubscribing();
				}
				else if (!value && isSubscribing)
				{
					StopSubscribing();
				}
			}
		}

		public event EventHandler<EventRecordWrittenEventArgs> EventRecordWritten;

		public EventLogWatcher(string path)
			: this(new EventLogQuery(path, PathType.LogName), null, readExistingEvents: false)
		{
		}

		public EventLogWatcher(EventLogQuery eventQuery)
			: this(eventQuery, null, readExistingEvents: false)
		{
		}

		public EventLogWatcher(EventLogQuery eventQuery, EventBookmark bookmark)
			: this(eventQuery, bookmark, readExistingEvents: false)
		{
		}

		public EventLogWatcher(EventLogQuery eventQuery, EventBookmark bookmark, bool readExistingEvents)
		{
			if (eventQuery == null)
			{
				throw new ArgumentNullException("eventQuery");
			}
			if (bookmark != null)
			{
				readExistingEvents = false;
			}
			this.eventQuery = eventQuery;
			this.readExistingEvents = readExistingEvents;
			if (this.eventQuery.ReverseDirection)
			{
				throw new InvalidOperationException();
			}
			eventsBuffer = new IntPtr[64];
			cachedMetadataInformation = new ProviderMetadataCachedInformation(eventQuery.Session, null, 50);
			this.bookmark = bookmark;
		}

		[SecurityCritical]
		[SecurityTreatAsSafe]
		internal void StopSubscribing()
		{
			EventLogPermissionHolder.GetEventLogPermission().Demand();
			isSubscribing = false;
			if (registeredWaitHandle != null)
			{
				registeredWaitHandle.Unregister(unregisterDoneHandle);
				if (callbackThreadId != Thread.CurrentThread.ManagedThreadId && unregisterDoneHandle != null)
				{
					unregisterDoneHandle.WaitOne();
				}
				registeredWaitHandle = null;
			}
			if (unregisterDoneHandle != null)
			{
				unregisterDoneHandle.Close();
				unregisterDoneHandle = null;
			}
			if (subscriptionWaitHandle != null)
			{
				subscriptionWaitHandle.Close();
				subscriptionWaitHandle = null;
			}
			for (int i = 0; i < numEventsInBuffer; i++)
			{
				if (eventsBuffer[i] != IntPtr.Zero)
				{
					NativeWrapper.EvtClose(eventsBuffer[i]);
					ref IntPtr reference = ref eventsBuffer[i];
					reference = IntPtr.Zero;
				}
			}
			numEventsInBuffer = 0;
			if (handle != null && !handle.IsInvalid)
			{
				handle.Dispose();
			}
		}

		[SecurityTreatAsSafe]
		[SecurityCritical]
		internal void StartSubscribing()
		{
			if (isSubscribing)
			{
				throw new InvalidOperationException();
			}
			int num = 0;
			num = ((bookmark != null) ? (num | 3) : ((!readExistingEvents) ? (num | 1) : (num | 2)));
			if (eventQuery.TolerateQueryErrors)
			{
				num |= 0x1000;
			}
			EventLogPermissionHolder.GetEventLogPermission().Demand();
			callbackThreadId = -1;
			unregisterDoneHandle = new AutoResetEvent(initialState: false);
			subscriptionWaitHandle = new AutoResetEvent(initialState: false);
			EventLogHandle bookmarkHandleFromBookmark = EventLogRecord.GetBookmarkHandleFromBookmark(bookmark);
			using (bookmarkHandleFromBookmark)
			{
				handle = NativeWrapper.EvtSubscribe(eventQuery.Session.Handle, subscriptionWaitHandle.SafeWaitHandle, eventQuery.Path, eventQuery.Query, bookmarkHandleFromBookmark, IntPtr.Zero, IntPtr.Zero, num);
			}
			isSubscribing = true;
			RequestEvents();
			registeredWaitHandle = ThreadPool.RegisterWaitForSingleObject(subscriptionWaitHandle, SubscribedEventsAvailableCallback, null, -1, executeOnlyOnce: false);
		}

		internal void SubscribedEventsAvailableCallback(object state, bool timedOut)
		{
			callbackThreadId = Thread.CurrentThread.ManagedThreadId;
			try
			{
				RequestEvents();
			}
			finally
			{
				callbackThreadId = -1;
			}
		}

		[SecurityCritical]
		[SecurityTreatAsSafe]
		private void RequestEvents()
		{
			EventLogPermissionHolder.GetEventLogPermission().Demand();
			asyncException = null;
			bool flag = false;
			while (isSubscribing)
			{
				try
				{
					flag = NativeWrapper.EvtNext(handle, eventsBuffer.Length, eventsBuffer, 0, 0, ref numEventsInBuffer);
					if (!flag)
					{
						break;
					}
				}
				catch (Exception ex)
				{
					Exception ex2 = (asyncException = ex);
				}
				HandleEventsRequestCompletion();
				if (!flag)
				{
					break;
				}
			}
		}

		private void IssueCallback(EventRecordWrittenEventArgs eventArgs)
		{
			if (this.EventRecordWritten != null)
			{
				this.EventRecordWritten(this, eventArgs);
			}
		}

		[SecurityCritical]
		private void HandleEventsRequestCompletion()
		{
			if (asyncException != null)
			{
				EventRecordWrittenEventArgs eventArgs = new EventRecordWrittenEventArgs(asyncException);
				IssueCallback(eventArgs);
			}
			for (int i = 0; i < numEventsInBuffer; i++)
			{
				if (!isSubscribing)
				{
					break;
				}
				EventLogRecord record = new EventLogRecord(new EventLogHandle(eventsBuffer[i], ownsHandle: true), eventQuery.Session, cachedMetadataInformation);
				EventRecordWrittenEventArgs eventArgs2 = new EventRecordWrittenEventArgs(record);
				ref IntPtr reference = ref eventsBuffer[i];
				reference = IntPtr.Zero;
				IssueCallback(eventArgs2);
			}
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		[SecurityCritical]
		[SecurityTreatAsSafe]
		protected virtual void Dispose(bool disposing)
		{
			if (disposing)
			{
				StopSubscribing();
				return;
			}
			for (int i = 0; i < numEventsInBuffer; i++)
			{
				if (eventsBuffer[i] != IntPtr.Zero)
				{
					NativeWrapper.EvtClose(eventsBuffer[i]);
					ref IntPtr reference = ref eventsBuffer[i];
					reference = IntPtr.Zero;
				}
			}
			numEventsInBuffer = 0;
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class EventRecordWrittenEventArgs : EventArgs
	{
		private EventRecord record;

		private Exception exception;

		public EventRecord EventRecord => record;

		public Exception EventException => exception;

		internal EventRecordWrittenEventArgs(EventLogRecord record)
		{
			this.record = record;
		}

		internal EventRecordWrittenEventArgs(Exception exception)
		{
			this.exception = exception;
		}
	}
	public class EventLogQuery
	{
		private string query;

		private string path;

		private EventLogSession session;

		private PathType pathType;

		private bool tolerateErrors;

		private bool reverseDirection;

		public EventLogSession Session
		{
			get
			{
				return session;
			}
			set
			{
				session = value;
			}
		}

		public bool TolerateQueryErrors
		{
			get
			{
				return tolerateErrors;
			}
			set
			{
				tolerateErrors = value;
			}
		}

		public bool ReverseDirection
		{
			get
			{
				return reverseDirection;
			}
			set
			{
				reverseDirection = value;
			}
		}

		internal string Path => path;

		internal PathType ThePathType => pathType;

		internal string Query => query;

		public EventLogQuery(string path, PathType pathType)
			: this(path, pathType, null)
		{
		}

		public EventLogQuery(string path, PathType pathType, string query)
		{
			session = EventLogSession.GlobalSession;
			this.path = path;
			this.pathType = pathType;
			if (query == null)
			{
				if (path == null)
				{
					throw new ArgumentNullException("path");
				}
			}
			else
			{
				this.query = query;
			}
		}
	}
	[SecurityTreatAsSafe]
	[SecurityCritical(SecurityCriticalScope.Everything)]
	internal sealed class EventLogHandle : SafeHandle
	{
		public override bool IsInvalid
		{
			get
			{
				if (!base.IsClosed)
				{
					return handle == IntPtr.Zero;
				}
				return true;
			}
		}

		public static EventLogHandle Zero => new EventLogHandle();

		private EventLogHandle()
			: base(IntPtr.Zero, ownsHandle: true)
		{
		}

		internal EventLogHandle(IntPtr handle, bool ownsHandle)
			: base(IntPtr.Zero, ownsHandle)
		{
			SetHandle(handle);
		}

		protected override bool ReleaseHandle()
		{
			NativeWrapper.EvtClose(handle);
			handle = IntPtr.Zero;
			return true;
		}
	}
	internal class EventLogPermissionHolder
	{
		public static EventLogPermission GetEventLogPermission()
		{
			EventLogPermission eventLogPermission = new EventLogPermission();
			EventLogPermissionEntry value = new EventLogPermissionEntry(EventLogPermissionAccess.Administer, ".");
			eventLogPermission.PermissionEntries.Add(value);
			return eventLogPermission;
		}
	}
	public enum SessionAuthentication
	{
		Default,
		Negotiate,
		Kerberos,
		Ntlm
	}
	public enum PathType
	{
		LogName = 1,
		FilePath
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class EventLogSession : IDisposable
	{
		internal EventLogHandle renderContextHandleSystem = EventLogHandle.Zero;

		internal EventLogHandle renderContextHandleUser = EventLogHandle.Zero;

		private object syncObject;

		private string server;

		private string user;

		private string domain;

		private SessionAuthentication logOnType;

		private EventLogHandle handle = EventLogHandle.Zero;

		private static EventLogSession globalSession = new EventLogSession();

		internal EventLogHandle Handle => handle;

		public static EventLogSession GlobalSession => globalSession;

		[SecurityTreatAsSafe]
		[SecurityCritical]
		internal void SetupSystemContext()
		{
			EventLogPermissionHolder.GetEventLogPermission().Demand();
			if (!renderContextHandleSystem.IsInvalid)
			{
				return;
			}
			lock (syncObject)
			{
				if (renderContextHandleSystem.IsInvalid)
				{
					renderContextHandleSystem = NativeWrapper.EvtCreateRenderContext(0, null, Microsoft.Win32.UnsafeNativeMethods.EvtRenderContextFlags.EvtRenderContextSystem);
				}
			}
		}

		[SecurityCritical]
		[SecurityTreatAsSafe]
		internal void SetupUserContext()
		{
			EventLogPermissionHolder.GetEventLogPermission().Demand();
			lock (syncObject)
			{
				if (renderContextHandleUser.IsInvalid)
				{
					renderContextHandleUser = NativeWrapper.EvtCreateRenderContext(0, null, Microsoft.Win32.UnsafeNativeMethods.EvtRenderContextFlags.EvtRenderContextUser);
				}
			}
		}

		[SecurityCritical]
		public EventLogSession()
		{
			EventLogPermissionHolder.GetEventLogPermission().Demand();
			syncObject = new object();
		}

		public EventLogSession(string server)
			: this(server, null, null, null, SessionAuthentication.Default)
		{
		}

		[SecurityCritical]
		public EventLogSession(string server, string domain, string user, SecureString password, SessionAuthentication logOnType)
		{
			EventLogPermissionHolder.GetEventLogPermission().Demand();
			if (server == null)
			{
				server = "localhost";
			}
			syncObject = new object();
			this.server = server;
			this.domain = domain;
			this.user = user;
			this.logOnType = logOnType;
			Microsoft.Win32.UnsafeNativeMethods.EvtRpcLogin login = new Microsoft.Win32.UnsafeNativeMethods.EvtRpcLogin
			{
				Server = this.server,
				User = this.user,
				Domain = this.domain,
				Flags = (int)this.logOnType,
				Password = CoTaskMemUnicodeSafeHandle.Zero
			};
			try
			{
				if (password != null)
				{
					login.Password.SetMemory(Marshal.SecureStringToCoTaskMemUnicode(password));
				}
				handle = NativeWrapper.EvtOpenSession(Microsoft.Win32.UnsafeNativeMethods.EvtLoginClass.EvtRpcLogin, ref login, 0, 0);
			}
			finally
			{
				login.Password.Close();
			}
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		[SecurityTreatAsSafe]
		[SecurityCritical]
		protected virtual void Dispose(bool disposing)
		{
			if (disposing)
			{
				if (this == globalSession)
				{
					throw new InvalidOperationException();
				}
				EventLogPermissionHolder.GetEventLogPermission().Demand();
			}
			if (renderContextHandleSystem != null && !renderContextHandleSystem.IsInvalid)
			{
				renderContextHandleSystem.Dispose();
			}
			if (renderContextHandleUser != null && !renderContextHandleUser.IsInvalid)
			{
				renderContextHandleUser.Dispose();
			}
			if (handle != null && !handle.IsInvalid)
			{
				handle.Dispose();
			}
		}

		public void CancelCurrentOperations()
		{
			NativeWrapper.EvtCancel(handle);
		}

		[SecurityCritical]
		public IEnumerable<string> GetProviderNames()
		{
			EventLogPermissionHolder.GetEventLogPermission().Demand();
			List<string> list = new List<string>(100);
			using EventLogHandle eventLogHandle = NativeWrapper.EvtOpenProviderEnum(Handle, 0);
			bool finish = false;
			do
			{
				string item = NativeWrapper.EvtNextPublisherId(eventLogHandle, ref finish);
				if (!finish)
				{
					list.Add(item);
				}
			}
			while (!finish);
			return list;
		}

		[SecurityCritical]
		public IEnumerable<string> GetLogNames()
		{
			EventLogPermissionHolder.GetEventLogPermission().Demand();
			List<string> list = new List<string>(100);
			using EventLogHandle eventLogHandle = NativeWrapper.EvtOpenChannelEnum(Handle, 0);
			bool finish = false;
			do
			{
				string item = NativeWrapper.EvtNextChannelPath(eventLogHandle, ref finish);
				if (!finish)
				{
					list.Add(item);
				}
			}
			while (!finish);
			return list;
		}

		public EventLogInformation GetLogInformation(string logName, PathType pathType)
		{
			if (logName == null)
			{
				throw new ArgumentNullException("logName");
			}
			return new EventLogInformation(this, logName, pathType);
		}

		public void ExportLog(string path, PathType pathType, string query, string targetFilePath)
		{
			ExportLog(path, pathType, query, targetFilePath, tolerateQueryErrors: false);
		}

		public void ExportLog(string path, PathType pathType, string query, string targetFilePath, bool tolerateQueryErrors)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			if (targetFilePath == null)
			{
				throw new ArgumentNullException("targetFilePath");
			}
			Microsoft.Win32.UnsafeNativeMethods.EvtExportLogFlags evtExportLogFlags = pathType switch
			{
				PathType.LogName => Microsoft.Win32.UnsafeNativeMethods.EvtExportLogFlags.EvtExportLogChannelPath, 
				PathType.FilePath => Microsoft.Win32.UnsafeNativeMethods.EvtExportLogFlags.EvtExportLogFilePath, 
				_ => throw new ArgumentOutOfRangeException("pathType"), 
			};
			if (!tolerateQueryErrors)
			{
				NativeWrapper.EvtExportLog(Handle, path, query, targetFilePath, (int)evtExportLogFlags);
			}
			else
			{
				NativeWrapper.EvtExportLog(Handle, path, query, targetFilePath, (int)(evtExportLogFlags | Microsoft.Win32.UnsafeNativeMethods.EvtExportLogFlags.EvtExportLogTolerateQueryErrors));
			}
		}

		public void ExportLogAndMessages(string path, PathType pathType, string query, string targetFilePath)
		{
			ExportLogAndMessages(path, pathType, query, targetFilePath, tolerateQueryErrors: false, CultureInfo.CurrentCulture);
		}

		public void ExportLogAndMessages(string path, PathType pathType, string query, string targetFilePath, bool tolerateQueryErrors, CultureInfo targetCultureInfo)
		{
			if (targetCultureInfo == null)
			{
				targetCultureInfo = CultureInfo.CurrentCulture;
			}
			ExportLog(path, pathType, query, targetFilePath, tolerateQueryErrors);
			NativeWrapper.EvtArchiveExportedLog(Handle, targetFilePath, targetCultureInfo.LCID, 0);
		}

		public void ClearLog(string logName)
		{
			ClearLog(logName, null);
		}

		public void ClearLog(string logName, string backupPath)
		{
			if (logName == null)
			{
				throw new ArgumentNullException("logName");
			}
			NativeWrapper.EvtClearLog(Handle, logName, backupPath, 0);
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class EventMetadata
	{
		private long id;

		private byte version;

		private byte channelId;

		private byte level;

		private short opcode;

		private int task;

		private long keywords;

		private string template;

		private string description;

		private ProviderMetadata pmReference;

		public long Id => id;

		public byte Version => version;

		public EventLogLink LogLink => new EventLogLink(channelId, pmReference);

		public EventLevel Level => new EventLevel(level, pmReference);

		public EventOpcode Opcode => new EventOpcode(opcode, pmReference);

		public EventTask Task => new EventTask(task, pmReference);

		public IEnumerable<EventKeyword> Keywords
		{
			get
			{
				List<EventKeyword> list = new List<EventKeyword>();
				ulong num = (ulong)keywords;
				ulong num2 = 9223372036854775808uL;
				for (int i = 0; i < 64; i++)
				{
					if ((num & num2) != 0)
					{
						list.Add(new EventKeyword((long)num2, pmReference));
					}
					num2 >>= 1;
				}
				return list;
			}
		}

		public string Template => template;

		public string Description => description;

		internal EventMetadata(uint id, byte version, byte channelId, byte level, byte opcode, short task, long keywords, string template, string description, ProviderMetadata pmReference)
		{
			this.id = id;
			this.version = version;
			this.channelId = channelId;
			this.level = level;
			this.opcode = opcode;
			this.task = task;
			this.keywords = keywords;
			this.template = template;
			this.description = description;
			this.pmReference = pmReference;
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class EventOpcode
	{
		private int value;

		private string name;

		private string displayName;

		private bool dataReady;

		private ProviderMetadata pmReference;

		private object syncObject;

		public string Name
		{
			get
			{
				PrepareData();
				return name;
			}
		}

		public int Value => value;

		public string DisplayName
		{
			get
			{
				PrepareData();
				return displayName;
			}
		}

		internal EventOpcode(int value, ProviderMetadata pmReference)
		{
			this.value = value;
			this.pmReference = pmReference;
			syncObject = new object();
		}

		internal EventOpcode(string name, int value, string displayName)
		{
			this.value = value;
			this.name = name;
			this.displayName = displayName;
			dataReady = true;
			syncObject = new object();
		}

		internal void PrepareData()
		{
			lock (syncObject)
			{
				if (dataReady)
				{
					return;
				}
				IEnumerable<EventOpcode> opcodes = pmReference.Opcodes;
				name = null;
				displayName = null;
				dataReady = true;
				foreach (EventOpcode item in opcodes)
				{
					if (item.Value == value)
					{
						name = item.Name;
						displayName = item.DisplayName;
						dataReady = true;
						break;
					}
				}
			}
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class EventTask
	{
		private int value;

		private string name;

		private string displayName;

		private Guid guid;

		private bool dataReady;

		private ProviderMetadata pmReference;

		private object syncObject;

		public string Name
		{
			get
			{
				PrepareData();
				return name;
			}
		}

		public int Value => value;

		public string DisplayName
		{
			get
			{
				PrepareData();
				return displayName;
			}
		}

		public Guid EventGuid
		{
			get
			{
				PrepareData();
				return guid;
			}
		}

		internal EventTask(int value, ProviderMetadata pmReference)
		{
			this.value = value;
			this.pmReference = pmReference;
			syncObject = new object();
		}

		internal EventTask(string name, int value, string displayName, Guid guid)
		{
			this.value = value;
			this.name = name;
			this.displayName = displayName;
			this.guid = guid;
			dataReady = true;
			syncObject = new object();
		}

		internal void PrepareData()
		{
			lock (syncObject)
			{
				if (dataReady)
				{
					return;
				}
				IEnumerable<EventTask> tasks = pmReference.Tasks;
				name = null;
				displayName = null;
				guid = Guid.Empty;
				dataReady = true;
				foreach (EventTask item in tasks)
				{
					if (item.Value == value)
					{
						name = item.Name;
						displayName = item.DisplayName;
						guid = item.EventGuid;
						dataReady = true;
						break;
					}
				}
			}
		}
	}
	[Serializable]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class EventLogException : Exception, ISerializable
	{
		private int errorCode;

		public override string Message
		{
			[SecurityCritical]
			get
			{
				EventLogPermissionHolder.GetEventLogPermission().Demand();
				Win32Exception ex = new Win32Exception(errorCode);
				return ex.Message;
			}
		}

		internal static void Throw(int errorCode)
		{
			switch (errorCode)
			{
			case 2:
			case 3:
			case 15002:
			case 15007:
			case 15027:
			case 15028:
				throw new EventLogNotFoundException(errorCode);
			case 13:
			case 15005:
				throw new EventLogInvalidDataException(errorCode);
			case 1223:
			case 1818:
				throw new OperationCanceledException();
			case 15037:
				throw new EventLogProviderDisabledException(errorCode);
			case 5:
				throw new UnauthorizedAccessException();
			case 15011:
			case 15012:
				throw new EventLogReadingException(errorCode);
			default:
				throw new EventLogException(errorCode);
			}
		}

		public EventLogException()
		{
		}

		public EventLogException(string message)
			: base(message)
		{
		}

		public EventLogException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		protected EventLogException(SerializationInfo serializationInfo, StreamingContext streamingContext)
			: base(serializationInfo, streamingContext)
		{
		}

		protected EventLogException(int errorCode)
		{
			this.errorCode = errorCode;
		}

		[SecurityCritical]
		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
		public override void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			if (info == null)
			{
				throw new ArgumentNullException("info");
			}
			info.AddValue("errorCode", errorCode);
			base.GetObjectData(info, context);
		}
	}
	[Serializable]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class EventLogNotFoundException : EventLogException
	{
		public EventLogNotFoundException()
		{
		}

		public EventLogNotFoundException(string message)
			: base(message)
		{
		}

		public EventLogNotFoundException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		protected EventLogNotFoundException(SerializationInfo serializationInfo, StreamingContext streamingContext)
			: base(serializationInfo, streamingContext)
		{
		}

		internal EventLogNotFoundException(int errorCode)
			: base(errorCode)
		{
		}
	}
	[Serializable]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class EventLogReadingException : EventLogException
	{
		public EventLogReadingException()
		{
		}

		public EventLogReadingException(string message)
			: base(message)
		{
		}

		public EventLogReadingException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		protected EventLogReadingException(SerializationInfo serializationInfo, StreamingContext streamingContext)
			: base(serializationInfo, streamingContext)
		{
		}

		internal EventLogReadingException(int errorCode)
			: base(errorCode)
		{
		}
	}
	[Serializable]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class EventLogProviderDisabledException : EventLogException
	{
		public EventLogProviderDisabledException()
		{
		}

		public EventLogProviderDisabledException(string message)
			: base(message)
		{
		}

		public EventLogProviderDisabledException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		protected EventLogProviderDisabledException(SerializationInfo serializationInfo, StreamingContext streamingContext)
			: base(serializationInfo, streamingContext)
		{
		}

		internal EventLogProviderDisabledException(int errorCode)
			: base(errorCode)
		{
		}
	}
	[Serializable]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class EventLogInvalidDataException : EventLogException
	{
		public EventLogInvalidDataException()
		{
		}

		public EventLogInvalidDataException(string message)
			: base(message)
		{
		}

		public EventLogInvalidDataException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		protected EventLogInvalidDataException(SerializationInfo serializationInfo, StreamingContext streamingContext)
			: base(serializationInfo, streamingContext)
		{
		}

		internal EventLogInvalidDataException(int errorCode)
			: base(errorCode)
		{
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class EventLogInformation
	{
		private DateTime? creationTime;

		private DateTime? lastAccessTime;

		private DateTime? lastWriteTime;

		private long? fileSize;

		private int? fileAttributes;

		private long? recordCount;

		private long? oldestRecordNumber;

		private bool? isLogFull;

		public DateTime? CreationTime => creationTime;

		public DateTime? LastAccessTime => lastAccessTime;

		public DateTime? LastWriteTime => lastWriteTime;

		public long? FileSize => fileSize;

		public int? Attributes => fileAttributes;

		public long? RecordCount => recordCount;

		public long? OldestRecordNumber => oldestRecordNumber;

		public bool? IsLogFull => isLogFull;

		[SecurityTreatAsSafe]
		[SecurityCritical]
		internal EventLogInformation(EventLogSession session, string channelName, PathType pathType)
		{
			EventLogPermissionHolder.GetEventLogPermission().Demand();
			EventLogHandle eventLogHandle = NativeWrapper.EvtOpenLog(session.Handle, channelName, pathType);
			using (eventLogHandle)
			{
				creationTime = (DateTime?)NativeWrapper.EvtGetLogInfo(eventLogHandle, Microsoft.Win32.UnsafeNativeMethods.EvtLogPropertyId.EvtLogCreationTime);
				lastAccessTime = (DateTime?)NativeWrapper.EvtGetLogInfo(eventLogHandle, Microsoft.Win32.UnsafeNativeMethods.EvtLogPropertyId.EvtLogLastAccessTime);
				lastWriteTime = (DateTime?)NativeWrapper.EvtGetLogInfo(eventLogHandle, Microsoft.Win32.UnsafeNativeMethods.EvtLogPropertyId.EvtLogLastWriteTime);
				fileSize = (long?)(ulong?)NativeWrapper.EvtGetLogInfo(eventLogHandle, Microsoft.Win32.UnsafeNativeMethods.EvtLogPropertyId.EvtLogFileSize);
				fileAttributes = (int?)(uint?)NativeWrapper.EvtGetLogInfo(eventLogHandle, Microsoft.Win32.UnsafeNativeMethods.EvtLogPropertyId.EvtLogAttributes);
				recordCount = (long?)(ulong?)NativeWrapper.EvtGetLogInfo(eventLogHandle, Microsoft.Win32.UnsafeNativeMethods.EvtLogPropertyId.EvtLogNumberOfLogRecords);
				oldestRecordNumber = (long?)(ulong?)NativeWrapper.EvtGetLogInfo(eventLogHandle, Microsoft.Win32.UnsafeNativeMethods.EvtLogPropertyId.EvtLogOldestRecordNumber);
				isLogFull = (bool?)NativeWrapper.EvtGetLogInfo(eventLogHandle, Microsoft.Win32.UnsafeNativeMethods.EvtLogPropertyId.EvtLogFull);
			}
		}
	}
	internal class NativeWrapper
	{
		[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
		public class SystemProperties
		{
			public bool filled;

			public ushort? Id = null;

			public byte? Version = null;

			public ushort? Qualifiers = null;

			public byte? Level = null;

			public ushort? Task = null;

			public byte? Opcode = null;

			public ulong? Keywords = null;

			public ulong? RecordId = null;

			public string ProviderName;

			public Guid? ProviderId = null;

			public string ChannelName;

			public uint? ProcessId = null;

			public uint? ThreadId = null;

			public string ComputerName;

			public SecurityIdentifier UserId;

			public DateTime? TimeCreated = null;

			public Guid? ActivityId = null;

			public Guid? RelatedActivityId = null;
		}

		private static bool s_platformNotSupported = Environment.OSVersion.Version.Major < 6;

		[SecurityCritical]
		public static EventLogHandle EvtQuery(EventLogHandle session, string path, string query, int flags)
		{
			if (s_platformNotSupported)
			{
				throw new PlatformNotSupportedException();
			}
			EventLogHandle eventLogHandle = Microsoft.Win32.UnsafeNativeMethods.EvtQuery(session, path, query, flags);
			int lastWin32Error = Marshal.GetLastWin32Error();
			if (eventLogHandle.IsInvalid)
			{
				EventLogException.Throw(lastWin32Error);
			}
			return eventLogHandle;
		}

		[SecurityCritical]
		public static void EvtSeek(EventLogHandle resultSet, long position, EventLogHandle bookmark, int timeout, Microsoft.Win32.UnsafeNativeMethods.EvtSeekFlags flags)
		{
			bool flag = Microsoft.Win32.UnsafeNativeMethods.EvtSeek(resultSet, position, bookmark, timeout, flags);
			int lastWin32Error = Marshal.GetLastWin32Error();
			if (!flag)
			{
				EventLogException.Throw(lastWin32Error);
			}
		}

		[SecurityCritical]
		public static EventLogHandle EvtSubscribe(EventLogHandle session, SafeWaitHandle signalEvent, string path, string query, EventLogHandle bookmark, IntPtr context, IntPtr callback, int flags)
		{
			if (s_platformNotSupported)
			{
				throw new PlatformNotSupportedException();
			}
			EventLogHandle eventLogHandle = Microsoft.Win32.UnsafeNativeMethods.EvtSubscribe(session, signalEvent, path, query, bookmark, context, callback, flags);
			int lastWin32Error = Marshal.GetLastWin32Error();
			if (eventLogHandle.IsInvalid)
			{
				EventLogException.Throw(lastWin32Error);
			}
			return eventLogHandle;
		}

		[SecurityCritical]
		public static bool EvtNext(EventLogHandle queryHandle, int eventSize, IntPtr[] events, int timeout, int flags, ref int returned)
		{
			bool flag = Microsoft.Win32.UnsafeNativeMethods.EvtNext(queryHandle, eventSize, events, timeout, flags, ref returned);
			int lastWin32Error = Marshal.GetLastWin32Error();
			if (!flag && lastWin32Error != 259)
			{
				EventLogException.Throw(lastWin32Error);
			}
			return lastWin32Error == 0;
		}

		[SecurityTreatAsSafe]
		[SecurityCritical]
		public static void EvtCancel(EventLogHandle handle)
		{
			EventLogPermissionHolder.GetEventLogPermission().Demand();
			if (!Microsoft.Win32.UnsafeNativeMethods.EvtCancel(handle))
			{
				int lastWin32Error = Marshal.GetLastWin32Error();
				EventLogException.Throw(lastWin32Error);
			}
		}

		[SecurityCritical]
		public static void EvtClose(IntPtr handle)
		{
			Microsoft.Win32.UnsafeNativeMethods.EvtClose(handle);
		}

		[SecurityCritical]
		public static EventLogHandle EvtOpenProviderMetadata(EventLogHandle session, string ProviderId, string logFilePath, int locale, int flags)
		{
			if (s_platformNotSupported)
			{
				throw new PlatformNotSupportedException();
			}
			EventLogHandle eventLogHandle = Microsoft.Win32.UnsafeNativeMethods.EvtOpenPublisherMetadata(session, ProviderId, logFilePath, 0, flags);
			int lastWin32Error = Marshal.GetLastWin32Error();
			if (eventLogHandle.IsInvalid)
			{
				EventLogException.Throw(lastWin32Error);
			}
			return eventLogHandle;
		}

		[SecurityCritical]
		public static int EvtGetObjectArraySize(EventLogHandle objectArray)
		{
			int objectArraySize;
			bool flag = Microsoft.Win32.UnsafeNativeMethods.EvtGetObjectArraySize(objectArray, out objectArraySize);
			int lastWin32Error = Marshal.GetLastWin32Error();
			if (!flag)
			{
				EventLogException.Throw(lastWin32Error);
			}
			return objectArraySize;
		}

		[SecurityCritical]
		public static EventLogHandle EvtOpenEventMetadataEnum(EventLogHandle ProviderMetadata, int flags)
		{
			EventLogHandle eventLogHandle = Microsoft.Win32.UnsafeNativeMethods.EvtOpenEventMetadataEnum(ProviderMetadata, flags);
			int lastWin32Error = Marshal.GetLastWin32Error();
			if (eventLogHandle.IsInvalid)
			{
				EventLogException.Throw(lastWin32Error);
			}
			return eventLogHandle;
		}

		[SecurityCritical]
		public static EventLogHandle EvtNextEventMetadata(EventLogHandle eventMetadataEnum, int flags)
		{
			EventLogHandle eventLogHandle = Microsoft.Win32.UnsafeNativeMethods.EvtNextEventMetadata(eventMetadataEnum, flags);
			int lastWin32Error = Marshal.GetLastWin32Error();
			if (eventLogHandle.IsInvalid)
			{
				if (lastWin32Error != 259)
				{
					EventLogException.Throw(lastWin32Error);
				}
				return null;
			}
			return eventLogHandle;
		}

		[SecurityCritical]
		public static EventLogHandle EvtOpenChannelEnum(EventLogHandle session, int flags)
		{
			if (s_platformNotSupported)
			{
				throw new PlatformNotSupportedException();
			}
			EventLogHandle eventLogHandle = Microsoft.Win32.UnsafeNativeMethods.EvtOpenChannelEnum(session, flags);
			int lastWin32Error = Marshal.GetLastWin32Error();
			if (eventLogHandle.IsInvalid)
			{
				EventLogException.Throw(lastWin32Error);
			}
			return eventLogHandle;
		}

		[SecurityCritical]
		public static EventLogHandle EvtOpenProviderEnum(EventLogHandle session, int flags)
		{
			if (s_platformNotSupported)
			{
				throw new PlatformNotSupportedException();
			}
			EventLogHandle eventLogHandle = Microsoft.Win32.UnsafeNativeMethods.EvtOpenPublisherEnum(session, flags);
			int lastWin32Error = Marshal.GetLastWin32Error();
			if (eventLogHandle.IsInvalid)
			{
				EventLogException.Throw(lastWin32Error);
			}
			return eventLogHandle;
		}

		[SecurityCritical]
		public static EventLogHandle EvtOpenChannelConfig(EventLogHandle session, string channelPath, int flags)
		{
			if (s_platformNotSupported)
			{
				throw new PlatformNotSupportedException();
			}
			EventLogHandle eventLogHandle = Microsoft.Win32.UnsafeNativeMethods.EvtOpenChannelConfig(session, channelPath, flags);
			int lastWin32Error = Marshal.GetLastWin32Error();
			if (eventLogHandle.IsInvalid)
			{
				EventLogException.Throw(lastWin32Error);
			}
			return eventLogHandle;
		}

		[SecurityCritical]
		[SecurityTreatAsSafe]
		public static void EvtSaveChannelConfig(EventLogHandle channelConfig, int flags)
		{
			EventLogPermissionHolder.GetEventLogPermission().Demand();
			bool flag = Microsoft.Win32.UnsafeNativeMethods.EvtSaveChannelConfig(channelConfig, flags);
			int lastWin32Error = Marshal.GetLastWin32Error();
			if (!flag)
			{
				EventLogException.Throw(lastWin32Error);
			}
		}

		[SecurityCritical]
		public static EventLogHandle EvtOpenLog(EventLogHandle session, string path, PathType flags)
		{
			if (s_platformNotSupported)
			{
				throw new PlatformNotSupportedException();
			}
			EventLogHandle eventLogHandle = Microsoft.Win32.UnsafeNativeMethods.EvtOpenLog(session, path, flags);
			int lastWin32Error = Marshal.GetLastWin32Error();
			if (eventLogHandle.IsInvalid)
			{
				EventLogException.Throw(lastWin32Error);
			}
			return eventLogHandle;
		}

		[SecurityCritical]
		[SecurityTreatAsSafe]
		public static void EvtExportLog(EventLogHandle session, string channelPath, string query, string targetFilePath, int flags)
		{
			if (s_platformNotSupported)
			{
				throw new PlatformNotSupportedException();
			}
			EventLogPermissionHolder.GetEventLogPermission().Demand();
			bool flag = Microsoft.Win32.UnsafeNativeMethods.EvtExportLog(session, channelPath, query, targetFilePath, flags);
			int lastWin32Error = Marshal.GetLastWin32Error();
			if (!flag)
			{
				EventLogException.Throw(lastWin32Error);
			}
		}

		[SecurityCritical]
		[SecurityTreatAsSafe]
		public static void EvtArchiveExportedLog(EventLogHandle session, string logFilePath, int locale, int flags)
		{
			if (s_platformNotSupported)
			{
				throw new PlatformNotSupportedException();
			}
			EventLogPermissionHolder.GetEventLogPermission().Demand();
			bool flag = Microsoft.Win32.UnsafeNativeMethods.EvtArchiveExportedLog(session, logFilePath, locale, flags);
			int lastWin32Error = Marshal.GetLastWin32Error();
			if (!flag)
			{
				EventLogException.Throw(lastWin32Error);
			}
		}

		[SecurityTreatAsSafe]
		[SecurityCritical]
		public static void EvtClearLog(EventLogHandle session, string channelPath, string targetFilePath, int flags)
		{
			if (s_platformNotSupported)
			{
				throw new PlatformNotSupportedException();
			}
			EventLogPermissionHolder.GetEventLogPermission().Demand();
			bool flag = Microsoft.Win32.UnsafeNativeMethods.EvtClearLog(session, channelPath, targetFilePath, flags);
			int lastWin32Error = Marshal.GetLastWin32Error();
			if (!flag)
			{
				EventLogException.Throw(lastWin32Error);
			}
		}

		[SecurityCritical]
		public static EventLogHandle EvtCreateRenderContext(int valuePathsCount, string[] valuePaths, Microsoft.Win32.UnsafeNativeMethods.EvtRenderContextFlags flags)
		{
			if (s_platformNotSupported)
			{
				throw new PlatformNotSupportedException();
			}
			EventLogHandle eventLogHandle = Microsoft.Win32.UnsafeNativeMethods.EvtCreateRenderContext(valuePathsCount, valuePaths, flags);
			int lastWin32Error = Marshal.GetLastWin32Error();
			if (eventLogHandle.IsInvalid)
			{
				EventLogException.Throw(lastWin32Error);
			}
			return eventLogHandle;
		}

		[SecurityCritical]
		public static void EvtRender(EventLogHandle context, EventLogHandle eventHandle, Microsoft.Win32.UnsafeNativeMethods.EvtRenderFlags flags, StringBuilder buffer)
		{
			if (s_platformNotSupported)
			{
				throw new PlatformNotSupportedException();
			}
			int buffUsed;
			int propCount;
			bool flag = Microsoft.Win32.UnsafeNativeMethods.EvtRender(context, eventHandle, flags, buffer.Capacity, buffer, out buffUsed, out propCount);
			int lastWin32Error = Marshal.GetLastWin32Error();
			if (!flag)
			{
				if (lastWin32Error == 122)
				{
					buffer.Capacity = buffUsed;
					flag = Microsoft.Win32.UnsafeNativeMethods.EvtRender(context, eventHandle, flags, buffer.Capacity, buffer, out buffUsed, out propCount);
					lastWin32Error = Marshal.GetLastWin32Error();
				}
				if (!flag)
				{
					EventLogException.Throw(lastWin32Error);
				}
			}
		}

		[SecurityCritical]
		public static EventLogHandle EvtOpenSession(Microsoft.Win32.UnsafeNativeMethods.EvtLoginClass loginClass, ref Microsoft.Win32.UnsafeNativeMethods.EvtRpcLogin login, int timeout, int flags)
		{
			if (s_platformNotSupported)
			{
				throw new PlatformNotSupportedException();
			}
			EventLogHandle eventLogHandle = Microsoft.Win32.UnsafeNativeMethods.EvtOpenSession(loginClass, ref login, timeout, flags);
			int lastWin32Error = Marshal.GetLastWin32Error();
			if (eventLogHandle.IsInvalid)
			{
				EventLogException.Throw(lastWin32Error);
			}
			return eventLogHandle;
		}

		[SecurityCritical]
		public static EventLogHandle EvtCreateBookmark(string bookmarkXml)
		{
			if (s_platformNotSupported)
			{
				throw new PlatformNotSupportedException();
			}
			EventLogHandle eventLogHandle = Microsoft.Win32.UnsafeNativeMethods.EvtCreateBookmark(bookmarkXml);
			int lastWin32Error = Marshal.GetLastWin32Error();
			if (eventLogHandle.IsInvalid)
			{
				EventLogException.Throw(lastWin32Error);
			}
			return eventLogHandle;
		}

		[SecurityCritical]
		public static void EvtUpdateBookmark(EventLogHandle bookmark, EventLogHandle eventHandle)
		{
			bool flag = Microsoft.Win32.UnsafeNativeMethods.EvtUpdateBookmark(bookmark, eventHandle);
			int lastWin32Error = Marshal.GetLastWin32Error();
			if (!flag)
			{
				EventLogException.Throw(lastWin32Error);
			}
		}

		[SecurityCritical]
		[SecurityTreatAsSafe]
		public static object EvtGetEventInfo(EventLogHandle handle, Microsoft.Win32.UnsafeNativeMethods.EvtEventPropertyId enumType)
		{
			IntPtr intPtr = IntPtr.Zero;
			EventLogPermissionHolder.GetEventLogPermission().Demand();
			try
			{
				bool flag = Microsoft.Win32.UnsafeNativeMethods.EvtGetEventInfo(handle, enumType, 0, IntPtr.Zero, out var bufferUsed);
				int lastWin32Error = Marshal.GetLastWin32Error();
				if (!flag && lastWin32Error != 0 && lastWin32Error != 122)
				{
					EventLogException.Throw(lastWin32Error);
				}
				intPtr = Marshal.AllocHGlobal(bufferUsed);
				flag = Microsoft.Win32.UnsafeNativeMethods.EvtGetEventInfo(handle, enumType, bufferUsed, intPtr, out bufferUsed);
				lastWin32Error = Marshal.GetLastWin32Error();
				if (!flag)
				{
					EventLogException.Throw(lastWin32Error);
				}
				Microsoft.Win32.UnsafeNativeMethods.EvtVariant val = (Microsoft.Win32.UnsafeNativeMethods.EvtVariant)Marshal.PtrToStructure(intPtr, typeof(Microsoft.Win32.UnsafeNativeMethods.EvtVariant));
				return ConvertToObject(val);
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
		}

		[SecurityCritical]
		public static object EvtGetQueryInfo(EventLogHandle handle, Microsoft.Win32.UnsafeNativeMethods.EvtQueryPropertyId enumType)
		{
			IntPtr intPtr = IntPtr.Zero;
			int bufferRequired = 0;
			try
			{
				bool flag = Microsoft.Win32.UnsafeNativeMethods.EvtGetQueryInfo(handle, enumType, 0, IntPtr.Zero, ref bufferRequired);
				int lastWin32Error = Marshal.GetLastWin32Error();
				if (!flag && lastWin32Error != 122)
				{
					EventLogException.Throw(lastWin32Error);
				}
				intPtr = Marshal.AllocHGlobal(bufferRequired);
				flag = Microsoft.Win32.UnsafeNativeMethods.EvtGetQueryInfo(handle, enumType, bufferRequired, intPtr, ref bufferRequired);
				lastWin32Error = Marshal.GetLastWin32Error();
				if (!flag)
				{
					EventLogException.Throw(lastWin32Error);
				}
				Microsoft.Win32.UnsafeNativeMethods.EvtVariant val = (Microsoft.Win32.UnsafeNativeMethods.EvtVariant)Marshal.PtrToStructure(intPtr, typeof(Microsoft.Win32.UnsafeNativeMethods.EvtVariant));
				return ConvertToObject(val);
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
		}

		[SecurityCritical]
		[SecurityTreatAsSafe]
		public static object EvtGetPublisherMetadataProperty(EventLogHandle pmHandle, Microsoft.Win32.UnsafeNativeMethods.EvtPublisherMetadataPropertyId thePropertyId)
		{
			IntPtr intPtr = IntPtr.Zero;
			EventLogPermissionHolder.GetEventLogPermission().Demand();
			try
			{
				bool flag = Microsoft.Win32.UnsafeNativeMethods.EvtGetPublisherMetadataProperty(pmHandle, thePropertyId, 0, 0, IntPtr.Zero, out var publisherMetadataPropertyBufferUsed);
				int lastWin32Error = Marshal.GetLastWin32Error();
				if (!flag && lastWin32Error != 122)
				{
					EventLogException.Throw(lastWin32Error);
				}
				intPtr = Marshal.AllocHGlobal(publisherMetadataPropertyBufferUsed);
				flag = Microsoft.Win32.UnsafeNativeMethods.EvtGetPublisherMetadataProperty(pmHandle, thePropertyId, 0, publisherMetadataPropertyBufferUsed, intPtr, out publisherMetadataPropertyBufferUsed);
				lastWin32Error = Marshal.GetLastWin32Error();
				if (!flag)
				{
					EventLogException.Throw(lastWin32Error);
				}
				Microsoft.Win32.UnsafeNativeMethods.EvtVariant val = (Microsoft.Win32.UnsafeNativeMethods.EvtVariant)Marshal.PtrToStructure(intPtr, typeof(Microsoft.Win32.UnsafeNativeMethods.EvtVariant));
				return ConvertToObject(val);
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
		}

		[SecurityCritical]
		internal static EventLogHandle EvtGetPublisherMetadataPropertyHandle(EventLogHandle pmHandle, Microsoft.Win32.UnsafeNativeMethods.EvtPublisherMetadataPropertyId thePropertyId)
		{
			IntPtr intPtr = IntPtr.Zero;
			try
			{
				bool flag = Microsoft.Win32.UnsafeNativeMethods.EvtGetPublisherMetadataProperty(pmHandle, thePropertyId, 0, 0, IntPtr.Zero, out var publisherMetadataPropertyBufferUsed);
				int lastWin32Error = Marshal.GetLastWin32Error();
				if (!flag && lastWin32Error != 122)
				{
					EventLogException.Throw(lastWin32Error);
				}
				intPtr = Marshal.AllocHGlobal(publisherMetadataPropertyBufferUsed);
				flag = Microsoft.Win32.UnsafeNativeMethods.EvtGetPublisherMetadataProperty(pmHandle, thePropertyId, 0, publisherMetadataPropertyBufferUsed, intPtr, out publisherMetadataPropertyBufferUsed);
				lastWin32Error = Marshal.GetLastWin32Error();
				if (!flag)
				{
					EventLogException.Throw(lastWin32Error);
				}
				Microsoft.Win32.UnsafeNativeMethods.EvtVariant val = (Microsoft.Win32.UnsafeNativeMethods.EvtVariant)Marshal.PtrToStructure(intPtr, typeof(Microsoft.Win32.UnsafeNativeMethods.EvtVariant));
				return ConvertToSafeHandle(val);
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
		}

		[SecurityCritical]
		public static string EvtFormatMessage(EventLogHandle handle, uint msgId)
		{
			if (s_platformNotSupported)
			{
				throw new PlatformNotSupportedException();
			}
			StringBuilder stringBuilder = new StringBuilder(null);
			bool flag = Microsoft.Win32.UnsafeNativeMethods.EvtFormatMessage(handle, EventLogHandle.Zero, msgId, 0, null, Microsoft.Win32.UnsafeNativeMethods.EvtFormatMessageFlags.EvtFormatMessageId, 0, stringBuilder, out var bufferUsed);
			int lastWin32Error = Marshal.GetLastWin32Error();
			if (!flag)
			{
				switch (lastWin32Error)
				{
				case 15027:
					return null;
				default:
					EventLogException.Throw(lastWin32Error);
					break;
				case 122:
				case 15029:
					break;
				}
			}
			stringBuilder.EnsureCapacity(bufferUsed);
			flag = Microsoft.Win32.UnsafeNativeMethods.EvtFormatMessage(handle, EventLogHandle.Zero, msgId, 0, null, Microsoft.Win32.UnsafeNativeMethods.EvtFormatMessageFlags.EvtFormatMessageId, bufferUsed, stringBuilder, out bufferUsed);
			lastWin32Error = Marshal.GetLastWin32Error();
			if (!flag)
			{
				switch (lastWin32Error)
				{
				case 15027:
					return null;
				default:
					if (lastWin32Error == 15029)
					{
						return null;
					}
					EventLogException.Throw(lastWin32Error);
					break;
				case 15029:
					break;
				}
			}
			return stringBuilder.ToString();
		}

		[SecurityCritical]
		public static object EvtGetObjectArrayProperty(EventLogHandle objArrayHandle, int index, int thePropertyId)
		{
			IntPtr intPtr = IntPtr.Zero;
			try
			{
				bool flag = Microsoft.Win32.UnsafeNativeMethods.EvtGetObjectArrayProperty(objArrayHandle, thePropertyId, index, 0, 0, IntPtr.Zero, out var propertyValueBufferUsed);
				int lastWin32Error = Marshal.GetLastWin32Error();
				if (!flag && lastWin32Error != 122)
				{
					EventLogException.Throw(lastWin32Error);
				}
				intPtr = Marshal.AllocHGlobal(propertyValueBufferUsed);
				flag = Microsoft.Win32.UnsafeNativeMethods.EvtGetObjectArrayProperty(objArrayHandle, thePropertyId, index, 0, propertyValueBufferUsed, intPtr, out propertyValueBufferUsed);
				lastWin32Error = Marshal.GetLastWin32Error();
				if (!flag)
				{
					EventLogException.Throw(lastWin32Error);
				}
				Microsoft.Win32.UnsafeNativeMethods.EvtVariant val = (Microsoft.Win32.UnsafeNativeMethods.EvtVariant)Marshal.PtrToStructure(intPtr, typeof(Microsoft.Win32.UnsafeNativeMethods.EvtVariant));
				return ConvertToObject(val);
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
		}

		[SecurityCritical]
		public static object EvtGetEventMetadataProperty(EventLogHandle handle, Microsoft.Win32.UnsafeNativeMethods.EvtEventMetadataPropertyId enumType)
		{
			IntPtr intPtr = IntPtr.Zero;
			try
			{
				bool flag = Microsoft.Win32.UnsafeNativeMethods.EvtGetEventMetadataProperty(handle, enumType, 0, 0, IntPtr.Zero, out var eventMetadataPropertyBufferUsed);
				int lastWin32Error = Marshal.GetLastWin32Error();
				if (!flag && lastWin32Error != 122)
				{
					EventLogException.Throw(lastWin32Error);
				}
				intPtr = Marshal.AllocHGlobal(eventMetadataPropertyBufferUsed);
				flag = Microsoft.Win32.UnsafeNativeMethods.EvtGetEventMetadataProperty(handle, enumType, 0, eventMetadataPropertyBufferUsed, intPtr, out eventMetadataPropertyBufferUsed);
				lastWin32Error = Marshal.GetLastWin32Error();
				if (!flag)
				{
					EventLogException.Throw(lastWin32Error);
				}
				Microsoft.Win32.UnsafeNativeMethods.EvtVariant val = (Microsoft.Win32.UnsafeNativeMethods.EvtVariant)Marshal.PtrToStructure(intPtr, typeof(Microsoft.Win32.UnsafeNativeMethods.EvtVariant));
				return ConvertToObject(val);
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
		}

		[SecurityTreatAsSafe]
		[SecurityCritical]
		public static object EvtGetChannelConfigProperty(EventLogHandle handle, Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId enumType)
		{
			IntPtr intPtr = IntPtr.Zero;
			EventLogPermissionHolder.GetEventLogPermission().Demand();
			try
			{
				bool flag = Microsoft.Win32.UnsafeNativeMethods.EvtGetChannelConfigProperty(handle, enumType, 0, 0, IntPtr.Zero, out var propertyValueBufferUsed);
				int lastWin32Error = Marshal.GetLastWin32Error();
				if (!flag && lastWin32Error != 122)
				{
					EventLogException.Throw(lastWin32Error);
				}
				intPtr = Marshal.AllocHGlobal(propertyValueBufferUsed);
				flag = Microsoft.Win32.UnsafeNativeMethods.EvtGetChannelConfigProperty(handle, enumType, 0, propertyValueBufferUsed, intPtr, out propertyValueBufferUsed);
				lastWin32Error = Marshal.GetLastWin32Error();
				if (!flag)
				{
					EventLogException.Throw(lastWin32Error);
				}
				Microsoft.Win32.UnsafeNativeMethods.EvtVariant val = (Microsoft.Win32.UnsafeNativeMethods.EvtVariant)Marshal.PtrToStructure(intPtr, typeof(Microsoft.Win32.UnsafeNativeMethods.EvtVariant));
				return ConvertToObject(val);
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
		}

		[SecurityCritical]
		[SecurityTreatAsSafe]
		public static void EvtSetChannelConfigProperty(EventLogHandle handle, Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId enumType, object val)
		{
			EventLogPermissionHolder.GetEventLogPermission().Demand();
			Microsoft.Win32.UnsafeNativeMethods.EvtVariant propertyValue = default(Microsoft.Win32.UnsafeNativeMethods.EvtVariant);
			CoTaskMemSafeHandle coTaskMemSafeHandle = new CoTaskMemSafeHandle();
			using (coTaskMemSafeHandle)
			{
				if (val != null)
				{
					switch (enumType)
					{
					case Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId.EvtChannelConfigEnabled:
						propertyValue.Type = 13u;
						if ((bool)val)
						{
							propertyValue.Bool = 1u;
						}
						else
						{
							propertyValue.Bool = 0u;
						}
						break;
					case Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId.EvtChannelConfigAccess:
						propertyValue.Type = 1u;
						coTaskMemSafeHandle.SetMemory(Marshal.StringToCoTaskMemAuto((string)val));
						propertyValue.StringVal = coTaskMemSafeHandle.GetMemory();
						break;
					case Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId.EvtChannelLoggingConfigLogFilePath:
						propertyValue.Type = 1u;
						coTaskMemSafeHandle.SetMemory(Marshal.StringToCoTaskMemAuto((string)val));
						propertyValue.StringVal = coTaskMemSafeHandle.GetMemory();
						break;
					case Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId.EvtChannelLoggingConfigMaxSize:
						propertyValue.Type = 10u;
						propertyValue.ULong = (ulong)(long)val;
						break;
					case Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId.EvtChannelPublishingConfigLevel:
						propertyValue.Type = 8u;
						propertyValue.UInteger = (uint)(int)val;
						break;
					case Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId.EvtChannelPublishingConfigKeywords:
						propertyValue.Type = 10u;
						propertyValue.ULong = (ulong)(long)val;
						break;
					case Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId.EvtChannelLoggingConfigRetention:
						propertyValue.Type = 13u;
						if ((bool)val)
						{
							propertyValue.Bool = 1u;
						}
						else
						{
							propertyValue.Bool = 0u;
						}
						break;
					case Microsoft.Win32.UnsafeNativeMethods.EvtChannelConfigPropertyId.EvtChannelLoggingConfigAutoBackup:
						propertyValue.Type = 13u;
						if ((bool)val)
						{
							propertyValue.Bool = 1u;
						}
						else
						{
							propertyValue.Bool = 0u;
						}
						break;
					default:
						throw new InvalidOperationException();
					}
				}
				else
				{
					propertyValue.Type = 0u;
				}
				bool flag = Microsoft.Win32.UnsafeNativeMethods.EvtSetChannelConfigProperty(handle, enumType, 0, ref propertyValue);
				int lastWin32Error = Marshal.GetLastWin32Error();
				if (!flag)
				{
					EventLogException.Throw(lastWin32Error);
				}
			}
		}

		[SecurityCritical]
		public static string EvtNextChannelPath(EventLogHandle handle, ref bool finish)
		{
			StringBuilder stringBuilder = new StringBuilder(null);
			bool flag = Microsoft.Win32.UnsafeNativeMethods.EvtNextChannelPath(handle, 0, stringBuilder, out var channelPathBufferUsed);
			int lastWin32Error = Marshal.GetLastWin32Error();
			if (!flag)
			{
				switch (lastWin32Error)
				{
				case 259:
					finish = true;
					return null;
				default:
					EventLogException.Throw(lastWin32Error);
					break;
				case 122:
					break;
				}
			}
			stringBuilder.EnsureCapacity(channelPathBufferUsed);
			flag = Microsoft.Win32.UnsafeNativeMethods.EvtNextChannelPath(handle, channelPathBufferUsed, stringBuilder, out channelPathBufferUsed);
			lastWin32Error = Marshal.GetLastWin32Error();
			if (!flag)
			{
				EventLogException.Throw(lastWin32Error);
			}
			return stringBuilder.ToString();
		}

		[SecurityCritical]
		public static string EvtNextPublisherId(EventLogHandle handle, ref bool finish)
		{
			StringBuilder stringBuilder = new StringBuilder(null);
			bool flag = Microsoft.Win32.UnsafeNativeMethods.EvtNextPublisherId(handle, 0, stringBuilder, out var publisherIdBufferUsed);
			int lastWin32Error = Marshal.GetLastWin32Error();
			if (!flag)
			{
				switch (lastWin32Error)
				{
				case 259:
					finish = true;
					return null;
				default:
					EventLogException.Throw(lastWin32Error);
					break;
				case 122:
					break;
				}
			}
			stringBuilder.EnsureCapacity(publisherIdBufferUsed);
			flag = Microsoft.Win32.UnsafeNativeMethods.EvtNextPublisherId(handle, publisherIdBufferUsed, stringBuilder, out publisherIdBufferUsed);
			lastWin32Error = Marshal.GetLastWin32Error();
			if (!flag)
			{
				EventLogException.Throw(lastWin32Error);
			}
			return stringBuilder.ToString();
		}

		[SecurityCritical]
		public static object EvtGetLogInfo(EventLogHandle handle, Microsoft.Win32.UnsafeNativeMethods.EvtLogPropertyId enumType)
		{
			IntPtr intPtr = IntPtr.Zero;
			try
			{
				bool flag = Microsoft.Win32.UnsafeNativeMethods.EvtGetLogInfo(handle, enumType, 0, IntPtr.Zero, out var propertyValueBufferUsed);
				int lastWin32Error = Marshal.GetLastWin32Error();
				if (!flag && lastWin32Error != 122)
				{
					EventLogException.Throw(lastWin32Error);
				}
				intPtr = Marshal.AllocHGlobal(propertyValueBufferUsed);
				flag = Microsoft.Win32.UnsafeNativeMethods.EvtGetLogInfo(handle, enumType, propertyValueBufferUsed, intPtr, out propertyValueBufferUsed);
				lastWin32Error = Marshal.GetLastWin32Error();
				if (!flag)
				{
					EventLogException.Throw(lastWin32Error);
				}
				Microsoft.Win32.UnsafeNativeMethods.EvtVariant val = (Microsoft.Win32.UnsafeNativeMethods.EvtVariant)Marshal.PtrToStructure(intPtr, typeof(Microsoft.Win32.UnsafeNativeMethods.EvtVariant));
				return ConvertToObject(val);
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
		}

		[SecurityTreatAsSafe]
		[SecurityCritical]
		public static void EvtRenderBufferWithContextSystem(EventLogHandle contextHandle, EventLogHandle eventHandle, Microsoft.Win32.UnsafeNativeMethods.EvtRenderFlags flag, SystemProperties systemProperties, int SYSTEM_PROPERTY_COUNT)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			EventLogPermissionHolder.GetEventLogPermission().Demand();
			try
			{
				if (!Microsoft.Win32.UnsafeNativeMethods.EvtRender(contextHandle, eventHandle, flag, 0, IntPtr.Zero, out var buffUsed, out var propCount))
				{
					int lastWin32Error = Marshal.GetLastWin32Error();
					if (lastWin32Error != 122)
					{
						EventLogException.Throw(lastWin32Error);
					}
				}
				intPtr = Marshal.AllocHGlobal(buffUsed);
				bool flag2 = Microsoft.Win32.UnsafeNativeMethods.EvtRender(contextHandle, eventHandle, flag, buffUsed, intPtr, out buffUsed, out propCount);
				int lastWin32Error2 = Marshal.GetLastWin32Error();
				if (!flag2)
				{
					EventLogException.Throw(lastWin32Error2);
				}
				if (propCount != SYSTEM_PROPERTY_COUNT)
				{
					throw new InvalidOperationException("We do not have " + SYSTEM_PROPERTY_COUNT + " variants given for the  UnsafeNativeMethods.EvtRenderFlags.EvtRenderEventValues flag. (System Properties)");
				}
				zero = intPtr;
				for (int i = 0; i < propCount; i++)
				{
					Microsoft.Win32.UnsafeNativeMethods.EvtVariant evtVariant = (Microsoft.Win32.UnsafeNativeMethods.EvtVariant)Marshal.PtrToStructure(zero, typeof(Microsoft.Win32.UnsafeNativeMethods.EvtVariant));
					switch (i)
					{
					case 0:
						systemProperties.ProviderName = (string)ConvertToObject(evtVariant, Microsoft.Win32.UnsafeNativeMethods.EvtVariantType.EvtVarTypeString);
						break;
					case 1:
						systemProperties.ProviderId = (Guid?)ConvertToObject(evtVariant, Microsoft.Win32.UnsafeNativeMethods.EvtVariantType.EvtVarTypeGuid);
						break;
					case 2:
						systemProperties.Id = (ushort?)ConvertToObject(evtVariant, Microsoft.Win32.UnsafeNativeMethods.EvtVariantType.EvtVarTypeUInt16);
						break;
					case 3:
						systemProperties.Qualifiers = (ushort?)ConvertToObject(evtVariant, Microsoft.Win32.UnsafeNativeMethods.EvtVariantType.EvtVarTypeUInt16);
						break;
					case 4:
						systemProperties.Level = (byte?)ConvertToObject(evtVariant, Microsoft.Win32.UnsafeNativeMethods.EvtVariantType.EvtVarTypeByte);
						break;
					case 5:
						systemProperties.Task = (ushort?)ConvertToObject(evtVariant, Microsoft.Win32.UnsafeNativeMethods.EvtVariantType.EvtVarTypeUInt16);
						break;
					case 6:
						systemProperties.Opcode = (byte?)ConvertToObject(evtVariant, Microsoft.Win32.UnsafeNativeMethods.EvtVariantType.EvtVarTypeByte);
						break;
					case 7:
						systemProperties.Keywords = (ulong?)ConvertToObject(evtVariant, Microsoft.Win32.UnsafeNativeMethods.EvtVariantType.EvtVarTypeHexInt64);
						break;
					case 8:
						systemProperties.TimeCreated = (DateTime?)ConvertToObject(evtVariant, Microsoft.Win32.UnsafeNativeMethods.EvtVariantType.EvtVarTypeFileTime);
						break;
					case 9:
						systemProperties.RecordId = (ulong?)ConvertToObject(evtVariant, Microsoft.Win32.UnsafeNativeMethods.EvtVariantType.EvtVarTypeUInt64);
						break;
					case 10:
						systemProperties.ActivityId = (Guid?)ConvertToObject(evtVariant, Microsoft.Win32.UnsafeNativeMethods.EvtVariantType.EvtVarTypeGuid);
						break;
					case 11:
						systemProperties.RelatedActivityId = (Guid?)ConvertToObject(evtVariant, Microsoft.Win32.UnsafeNativeMethods.EvtVariantType.EvtVarTypeGuid);
						break;
					case 12:
						systemProperties.ProcessId = (uint?)ConvertToObject(evtVariant, Microsoft.Win32.UnsafeNativeMethods.EvtVariantType.EvtVarTypeUInt32);
						break;
					case 13:
						systemProperties.ThreadId = (uint?)ConvertToObject(evtVariant, Microsoft.Win32.UnsafeNativeMethods.EvtVariantType.EvtVarTypeUInt32);
						break;
					case 14:
						systemProperties.ChannelName = (string)ConvertToObject(evtVariant, Microsoft.Win32.UnsafeNativeMethods.EvtVariantType.EvtVarTypeString);
						break;
					case 15:
						systemProperties.ComputerName = (string)ConvertToObject(evtVariant, Microsoft.Win32.UnsafeNativeMethods.EvtVariantType.EvtVarTypeString);
						break;
					case 16:
						systemProperties.UserId = (SecurityIdentifier)ConvertToObject(evtVariant, Microsoft.Win32.UnsafeNativeMethods.EvtVariantType.EvtVarTypeSid);
						break;
					case 17:
						systemProperties.Version = (byte?)ConvertToObject(evtVariant, Microsoft.Win32.UnsafeNativeMethods.EvtVariantType.EvtVarTypeByte);
						break;
					}
					zero = new IntPtr((long)zero + Marshal.SizeOf(evtVariant));
				}
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
		}

		[SecurityCritical]
		[SecurityTreatAsSafe]
		public static IList<object> EvtRenderBufferWithContextUserOrValues(EventLogHandle contextHandle, EventLogHandle eventHandle)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			Microsoft.Win32.UnsafeNativeMethods.EvtRenderFlags flags = Microsoft.Win32.UnsafeNativeMethods.EvtRenderFlags.EvtRenderEventValues;
			EventLogPermissionHolder.GetEventLogPermission().Demand();
			try
			{
				if (!Microsoft.Win32.UnsafeNativeMethods.EvtRender(contextHandle, eventHandle, flags, 0, IntPtr.Zero, out var buffUsed, out var propCount))
				{
					int lastWin32Error = Marshal.GetLastWin32Error();
					if (lastWin32Error != 122)
					{
						EventLogException.Throw(lastWin32Error);
					}
				}
				intPtr = Marshal.AllocHGlobal(buffUsed);
				bool flag = Microsoft.Win32.UnsafeNativeMethods.EvtRender(contextHandle, eventHandle, flags, buffUsed, intPtr, out buffUsed, out propCount);
				int lastWin32Error2 = Marshal.GetLastWin32Error();
				if (!flag)
				{
					EventLogException.Throw(lastWin32Error2);
				}
				List<object> list = new List<object>(propCount);
				if (propCount > 0)
				{
					zero = intPtr;
					for (int i = 0; i < propCount; i++)
					{
						Microsoft.Win32.UnsafeNativeMethods.EvtVariant evtVariant = (Microsoft.Win32.UnsafeNativeMethods.EvtVariant)Marshal.PtrToStructure(zero, typeof(Microsoft.Win32.UnsafeNativeMethods.EvtVariant));
						list.Add(ConvertToObject(evtVariant));
						zero = new IntPtr((long)zero + Marshal.SizeOf(evtVariant));
					}
				}
				return list;
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
		}

		[SecurityTreatAsSafe]
		[SecurityCritical]
		public static string EvtFormatMessageRenderName(EventLogHandle pmHandle, EventLogHandle eventHandle, Microsoft.Win32.UnsafeNativeMethods.EvtFormatMessageFlags flag)
		{
			EventLogPermissionHolder.GetEventLogPermission().Demand();
			StringBuilder stringBuilder = new StringBuilder(null);
			bool flag2 = Microsoft.Win32.UnsafeNativeMethods.EvtFormatMessage(pmHandle, eventHandle, 0u, 0, null, flag, 0, stringBuilder, out var bufferUsed);
			int lastWin32Error = Marshal.GetLastWin32Error();
			if (!flag2 && lastWin32Error != 15029)
			{
				switch (lastWin32Error)
				{
				case 1815:
				case 15027:
				case 15028:
				case 15033:
				case 15100:
					return null;
				}
				if (lastWin32Error != 122)
				{
					EventLogException.Throw(lastWin32Error);
				}
			}
			stringBuilder.EnsureCapacity(bufferUsed);
			flag2 = Microsoft.Win32.UnsafeNativeMethods.EvtFormatMessage(pmHandle, eventHandle, 0u, 0, null, flag, bufferUsed, stringBuilder, out bufferUsed);
			lastWin32Error = Marshal.GetLastWin32Error();
			if (!flag2 && lastWin32Error != 15029)
			{
				switch (lastWin32Error)
				{
				case 1815:
				case 15027:
				case 15028:
				case 15033:
				case 15100:
					return null;
				}
				EventLogException.Throw(lastWin32Error);
			}
			return stringBuilder.ToString();
		}

		[SecurityCritical]
		[SecurityTreatAsSafe]
		public static IEnumerable<string> EvtFormatMessageRenderKeywords(EventLogHandle pmHandle, EventLogHandle eventHandle, Microsoft.Win32.UnsafeNativeMethods.EvtFormatMessageFlags flag)
		{
			EventLogPermissionHolder.GetEventLogPermission().Demand();
			IntPtr intPtr = IntPtr.Zero;
			try
			{
				List<string> list = new List<string>();
				bool flag2 = Microsoft.Win32.UnsafeNativeMethods.EvtFormatMessageBuffer(pmHandle, eventHandle, 0u, 0, IntPtr.Zero, flag, 0, IntPtr.Zero, out var bufferUsed);
				int lastWin32Error = Marshal.GetLastWin32Error();
				if (!flag2)
				{
					switch (lastWin32Error)
					{
					case 1815:
					case 15027:
					case 15028:
					case 15033:
					case 15100:
						return list.AsReadOnly();
					}
					if (lastWin32Error != 122)
					{
						EventLogException.Throw(lastWin32Error);
					}
				}
				intPtr = Marshal.AllocHGlobal(bufferUsed * 2);
				flag2 = Microsoft.Win32.UnsafeNativeMethods.EvtFormatMessageBuffer(pmHandle, eventHandle, 0u, 0, IntPtr.Zero, flag, bufferUsed, intPtr, out bufferUsed);
				lastWin32Error = Marshal.GetLastWin32Error();
				if (!flag2)
				{
					switch (lastWin32Error)
					{
					case 1815:
					case 15027:
					case 15028:
					case 15033:
					case 15100:
						return list;
					}
					EventLogException.Throw(lastWin32Error);
				}
				IntPtr intPtr2 = intPtr;
				while (true)
				{
					string text = Marshal.PtrToStringAuto(intPtr2);
					if (string.IsNullOrEmpty(text))
					{
						break;
					}
					list.Add(text);
					intPtr2 = new IntPtr((long)intPtr2 + text.Length * 2 + 2);
				}
				return list.AsReadOnly();
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
		}

		[SecurityCritical]
		public static string EvtRenderBookmark(EventLogHandle eventHandle)
		{
			IntPtr intPtr = IntPtr.Zero;
			Microsoft.Win32.UnsafeNativeMethods.EvtRenderFlags flags = Microsoft.Win32.UnsafeNativeMethods.EvtRenderFlags.EvtRenderBookmark;
			try
			{
				bool flag = Microsoft.Win32.UnsafeNativeMethods.EvtRender(EventLogHandle.Zero, eventHandle, flags, 0, IntPtr.Zero, out var buffUsed, out var propCount);
				int lastWin32Error = Marshal.GetLastWin32Error();
				if (!flag && lastWin32Error != 122)
				{
					EventLogException.Throw(lastWin32Error);
				}
				intPtr = Marshal.AllocHGlobal(buffUsed);
				flag = Microsoft.Win32.UnsafeNativeMethods.EvtRender(EventLogHandle.Zero, eventHandle, flags, buffUsed, intPtr, out buffUsed, out propCount);
				lastWin32Error = Marshal.GetLastWin32Error();
				if (!flag)
				{
					EventLogException.Throw(lastWin32Error);
				}
				return Marshal.PtrToStringAuto(intPtr);
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
		}

		[SecurityCritical]
		[SecurityTreatAsSafe]
		public static string EvtFormatMessageFormatDescription(EventLogHandle handle, EventLogHandle eventHandle, string[] values)
		{
			if (s_platformNotSupported)
			{
				throw new PlatformNotSupportedException();
			}
			EventLogPermissionHolder.GetEventLogPermission().Demand();
			Microsoft.Win32.UnsafeNativeMethods.EvtStringVariant[] array = new Microsoft.Win32.UnsafeNativeMethods.EvtStringVariant[values.Length];
			for (int i = 0; i < values.Length; i++)
			{
				array[i].Type = 1u;
				array[i].StringVal = values[i];
			}
			StringBuilder stringBuilder = new StringBuilder(null);
			bool flag = Microsoft.Win32.UnsafeNativeMethods.EvtFormatMessage(handle, eventHandle, uint.MaxValue, values.Length, array, Microsoft.Win32.UnsafeNativeMethods.EvtFormatMessageFlags.EvtFormatMessageEvent, 0, stringBuilder, out var bufferUsed);
			int lastWin32Error = Marshal.GetLastWin32Error();
			if (!flag && lastWin32Error != 15029)
			{
				switch (lastWin32Error)
				{
				case 1815:
				case 15027:
				case 15028:
				case 15033:
				case 15100:
					return null;
				}
				if (lastWin32Error != 122)
				{
					EventLogException.Throw(lastWin32Error);
				}
			}
			stringBuilder.EnsureCapacity(bufferUsed);
			flag = Microsoft.Win32.UnsafeNativeMethods.EvtFormatMessage(handle, eventHandle, uint.MaxValue, values.Length, array, Microsoft.Win32.UnsafeNativeMethods.EvtFormatMessageFlags.EvtFormatMessageEvent, bufferUsed, stringBuilder, out bufferUsed);
			lastWin32Error = Marshal.GetLastWin32Error();
			if (!flag)
			{
				switch (lastWin32Error)
				{
				case 15027:
					return null;
				default:
					EventLogException.Throw(lastWin32Error);
					break;
				case 15029:
					break;
				}
			}
			return stringBuilder.ToString();
		}

		[SecurityCritical]
		private static object ConvertToObject(Microsoft.Win32.UnsafeNativeMethods.EvtVariant val)
		{
			switch (val.Type)
			{
			case 8u:
				return val.UInteger;
			case 7u:
				return val.Integer;
			case 6u:
				return val.UShort;
			case 5u:
				return val.SByte;
			case 4u:
				return val.UInt8;
			case 3u:
				return val.SByte;
			case 10u:
				return val.ULong;
			case 9u:
				return val.Long;
			case 21u:
				return val.ULong;
			case 20u:
				return val.Integer;
			case 12u:
				return val.Double;
			case 0u:
				return null;
			case 13u:
				if (val.Bool != 0)
				{
					return true;
				}
				return false;
			case 14u:
				return ConvertToBinaryArray(val);
			case 1u:
				return ConvertToString(val);
			case 2u:
				return ConvertToAnsiString(val);
			case 19u:
				return ConvertToSid(val);
			case 15u:
				return ConvertToGuid(val);
			case 32u:
				return ConvertToSafeHandle(val);
			case 17u:
				return ConvertFileTimeToDateTime(val);
			case 136u:
				return ConvertToIntArray(val);
			case 129u:
				return ConvertToStringArray(val);
			default:
				throw new EventLogInvalidDataException();
			}
		}

		[SecurityCritical]
		public static object ConvertToObject(Microsoft.Win32.UnsafeNativeMethods.EvtVariant val, Microsoft.Win32.UnsafeNativeMethods.EvtVariantType desiredType)
		{
			if (val.Type == 0)
			{
				return null;
			}
			if ((ulong)val.Type != (ulong)desiredType)
			{
				throw new EventLogInvalidDataException();
			}
			return ConvertToObject(val);
		}

		[SecurityCritical]
		public static string ConvertToString(Microsoft.Win32.UnsafeNativeMethods.EvtVariant val)
		{
			if (val.Type != 1)
			{
				throw new EventLogInvalidDataException();
			}
			if (val.StringVal == IntPtr.Zero)
			{
				return string.Empty;
			}
			return Marshal.PtrToStringAuto(val.StringVal);
		}

		[SecurityCritical]
		public static string ConvertToAnsiString(Microsoft.Win32.UnsafeNativeMethods.EvtVariant val)
		{
			if (val.Type != 2)
			{
				throw new EventLogInvalidDataException();
			}
			if (val.AnsiString == IntPtr.Zero)
			{
				return string.Empty;
			}
			return Marshal.PtrToStringAuto(val.AnsiString);
		}

		[SecurityCritical]
		public static SecurityIdentifier ConvertToSid(Microsoft.Win32.UnsafeNativeMethods.EvtVariant val)
		{
			if (val.Type != 19)
			{
				throw new EventLogInvalidDataException();
			}
			if (val.SidVal == IntPtr.Zero)
			{
				return null;
			}
			return new SecurityIdentifier(val.SidVal);
		}

		[SecurityCritical]
		public static Guid ConvertToGuid(Microsoft.Win32.UnsafeNativeMethods.EvtVariant val)
		{
			if (val.Type != 15)
			{
				throw new EventLogInvalidDataException();
			}
			if (val.GuidReference == IntPtr.Zero)
			{
				return Guid.Empty;
			}
			return (Guid)Marshal.PtrToStructure(val.GuidReference, typeof(Guid));
		}

		[SecurityCritical]
		public static DateTime ConvertFileTimeToDateTime(Microsoft.Win32.UnsafeNativeMethods.EvtVariant val)
		{
			if (val.Type != 17)
			{
				throw new EventLogInvalidDataException();
			}
			return DateTime.FromFileTime((long)val.FileTime);
		}

		[SecurityCritical]
		public static EventLogHandle ConvertToSafeHandle(Microsoft.Win32.UnsafeNativeMethods.EvtVariant val)
		{
			if (val.Type != 32)
			{
				throw new EventLogInvalidDataException();
			}
			if (val.Handle == IntPtr.Zero)
			{
				return EventLogHandle.Zero;
			}
			return new EventLogHandle(val.Handle, ownsHandle: true);
		}

		[SecurityCritical]
		public static int[] ConvertToIntArray(Microsoft.Win32.UnsafeNativeMethods.EvtVariant val)
		{
			if (val.Type != 136)
			{
				throw new EventLogInvalidDataException();
			}
			if (val.Reference == IntPtr.Zero)
			{
				return new int[0];
			}
			IntPtr reference = val.Reference;
			int[] array = new int[val.Count];
			Marshal.Copy(reference, array, 0, (int)val.Count);
			return array;
		}

		[SecurityCritical]
		public static byte[] ConvertToBinaryArray(Microsoft.Win32.UnsafeNativeMethods.EvtVariant val)
		{
			if (val.Type != 14)
			{
				throw new EventLogInvalidDataException();
			}
			if (val.Binary == IntPtr.Zero)
			{
				return new byte[0];
			}
			IntPtr binary = val.Binary;
			byte[] array = new byte[val.Count];
			Marshal.Copy(binary, array, 0, (int)val.Count);
			return array;
		}

		[SecurityCritical]
		public static string[] ConvertToStringArray(Microsoft.Win32.UnsafeNativeMethods.EvtVariant val)
		{
			if (val.Type != 129)
			{
				throw new EventLogInvalidDataException();
			}
			if (val.Reference == IntPtr.Zero)
			{
				return new string[0];
			}
			IntPtr reference = val.Reference;
			IntPtr[] array = new IntPtr[val.Count];
			Marshal.Copy(reference, array, 0, (int)val.Count);
			string[] array2 = new string[val.Count];
			for (int i = 0; i < val.Count; i++)
			{
				array2[i] = Marshal.PtrToStringAuto(array[i]);
			}
			return array2;
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class ProviderMetadata : IDisposable
	{
		internal enum ObjectTypeName
		{
			Level,
			Opcode,
			Task,
			Keyword
		}

		private EventLogHandle handle = EventLogHandle.Zero;

		private EventLogHandle defaultProviderHandle = EventLogHandle.Zero;

		private EventLogSession session;

		private string providerName;

		private CultureInfo cultureInfo;

		private string logFilePath;

		private IList<EventLevel> levels;

		private IList<EventOpcode> opcodes;

		private IList<EventTask> tasks;

		private IList<EventKeyword> keywords;

		private IList<EventLevel> standardLevels;

		private IList<EventOpcode> standardOpcodes;

		private IList<EventTask> standardTasks;

		private IList<EventKeyword> standardKeywords;

		private IList<EventLogLink> channelReferences;

		private object syncObject;

		internal EventLogHandle Handle => handle;

		public string Name => providerName;

		public Guid Id => (Guid)NativeWrapper.EvtGetPublisherMetadataProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtPublisherMetadataPropertyId.EvtPublisherMetadataPublisherGuid);

		public string MessageFilePath => (string)NativeWrapper.EvtGetPublisherMetadataProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtPublisherMetadataPropertyId.EvtPublisherMetadataMessageFilePath);

		public string ResourceFilePath => (string)NativeWrapper.EvtGetPublisherMetadataProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtPublisherMetadataPropertyId.EvtPublisherMetadataResourceFilePath);

		public string ParameterFilePath => (string)NativeWrapper.EvtGetPublisherMetadataProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtPublisherMetadataPropertyId.EvtPublisherMetadataParameterFilePath);

		public Uri HelpLink
		{
			get
			{
				string text = (string)NativeWrapper.EvtGetPublisherMetadataProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtPublisherMetadataPropertyId.EvtPublisherMetadataHelpLink);
				if (text == null || text.Length == 0)
				{
					return null;
				}
				return new Uri(text);
			}
		}

		private uint ProviderMessageID => (uint)NativeWrapper.EvtGetPublisherMetadataProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtPublisherMetadataPropertyId.EvtPublisherMetadataPublisherMessageID);

		public string DisplayName
		{
			[SecurityCritical]
			get
			{
				uint providerMessageID = ProviderMessageID;
				if (providerMessageID == uint.MaxValue)
				{
					return null;
				}
				EventLogPermissionHolder.GetEventLogPermission().Demand();
				return NativeWrapper.EvtFormatMessage(handle, providerMessageID);
			}
		}

		public IList<EventLogLink> LogLinks
		{
			[SecurityCritical]
			get
			{
				EventLogHandle eventLogHandle = EventLogHandle.Zero;
				try
				{
					lock (syncObject)
					{
						if (channelReferences != null)
						{
							return channelReferences;
						}
						EventLogPermissionHolder.GetEventLogPermission().Demand();
						eventLogHandle = NativeWrapper.EvtGetPublisherMetadataPropertyHandle(handle, Microsoft.Win32.UnsafeNativeMethods.EvtPublisherMetadataPropertyId.EvtPublisherMetadataChannelReferences);
						int num = NativeWrapper.EvtGetObjectArraySize(eventLogHandle);
						List<EventLogLink> list = new List<EventLogLink>(num);
						for (int i = 0; i < num; i++)
						{
							string text = (string)NativeWrapper.EvtGetObjectArrayProperty(eventLogHandle, i, 7);
							uint channelId = (uint)NativeWrapper.EvtGetObjectArrayProperty(eventLogHandle, i, 9);
							uint num2 = (uint)NativeWrapper.EvtGetObjectArrayProperty(eventLogHandle, i, 10);
							bool flag = num2 == 1;
							int num3 = (int)(uint)NativeWrapper.EvtGetObjectArrayProperty(eventLogHandle, i, 11);
							string text2 = ((num3 != -1) ? NativeWrapper.EvtFormatMessage(handle, (uint)num3) : null);
							if (text2 == null && flag)
							{
								num3 = ((string.Compare(text, "Application", StringComparison.OrdinalIgnoreCase) == 0) ? 256 : ((string.Compare(text, "System", StringComparison.OrdinalIgnoreCase) == 0) ? 258 : ((string.Compare(text, "Security", StringComparison.OrdinalIgnoreCase) != 0) ? (-1) : 257)));
								if (num3 != -1)
								{
									if (defaultProviderHandle.IsInvalid)
									{
										defaultProviderHandle = NativeWrapper.EvtOpenProviderMetadata(session.Handle, null, null, cultureInfo.LCID, 0);
									}
									text2 = NativeWrapper.EvtFormatMessage(defaultProviderHandle, (uint)num3);
								}
							}
							list.Add(new EventLogLink(text, flag, text2, channelId));
						}
						channelReferences = list.AsReadOnly();
					}
					return channelReferences;
				}
				finally
				{
					eventLogHandle.Close();
				}
			}
		}

		public IList<EventLevel> Levels
		{
			get
			{
				lock (syncObject)
				{
					if (levels != null)
					{
						return levels;
					}
					List<EventLevel> list = (List<EventLevel>)GetProviderListProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtPublisherMetadataPropertyId.EvtPublisherMetadataLevels);
					levels = list.AsReadOnly();
				}
				return levels;
			}
		}

		public IList<EventOpcode> Opcodes
		{
			get
			{
				lock (syncObject)
				{
					if (opcodes != null)
					{
						return opcodes;
					}
					List<EventOpcode> list = (List<EventOpcode>)GetProviderListProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtPublisherMetadataPropertyId.EvtPublisherMetadataOpcodes);
					opcodes = list.AsReadOnly();
				}
				return opcodes;
			}
		}

		public IList<EventKeyword> Keywords
		{
			get
			{
				lock (syncObject)
				{
					if (keywords != null)
					{
						return keywords;
					}
					List<EventKeyword> list = (List<EventKeyword>)GetProviderListProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtPublisherMetadataPropertyId.EvtPublisherMetadataKeywords);
					keywords = list.AsReadOnly();
				}
				return keywords;
			}
		}

		public IList<EventTask> Tasks
		{
			get
			{
				lock (syncObject)
				{
					if (tasks != null)
					{
						return tasks;
					}
					List<EventTask> list = (List<EventTask>)GetProviderListProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtPublisherMetadataPropertyId.EvtPublisherMetadataTasks);
					tasks = list.AsReadOnly();
				}
				return tasks;
			}
		}

		public IEnumerable<EventMetadata> Events
		{
			[SecurityCritical]
			get
			{
				EventLogPermissionHolder.GetEventLogPermission().Demand();
				List<EventMetadata> list = new List<EventMetadata>();
				EventLogHandle eventLogHandle = NativeWrapper.EvtOpenEventMetadataEnum(handle, 0);
				using (eventLogHandle)
				{
					while (true)
					{
						EventLogHandle eventLogHandle2 = (eventLogHandle2 = NativeWrapper.EvtNextEventMetadata(eventLogHandle, 0));
						if (eventLogHandle2 == null)
						{
							break;
						}
						using (eventLogHandle2)
						{
							uint id = (uint)NativeWrapper.EvtGetEventMetadataProperty(eventLogHandle2, Microsoft.Win32.UnsafeNativeMethods.EvtEventMetadataPropertyId.EventMetadataEventID);
							byte version = (byte)(uint)NativeWrapper.EvtGetEventMetadataProperty(eventLogHandle2, Microsoft.Win32.UnsafeNativeMethods.EvtEventMetadataPropertyId.EventMetadataEventVersion);
							byte channelId = (byte)(uint)NativeWrapper.EvtGetEventMetadataProperty(eventLogHandle2, Microsoft.Win32.UnsafeNativeMethods.EvtEventMetadataPropertyId.EventMetadataEventChannel);
							byte level = (byte)(uint)NativeWrapper.EvtGetEventMetadataProperty(eventLogHandle2, Microsoft.Win32.UnsafeNativeMethods.EvtEventMetadataPropertyId.EventMetadataEventLevel);
							byte opcode = (byte)(uint)NativeWrapper.EvtGetEventMetadataProperty(eventLogHandle2, Microsoft.Win32.UnsafeNativeMethods.EvtEventMetadataPropertyId.EventMetadataEventOpcode);
							short task = (short)(uint)NativeWrapper.EvtGetEventMetadataProperty(eventLogHandle2, Microsoft.Win32.UnsafeNativeMethods.EvtEventMetadataPropertyId.EventMetadataEventTask);
							long num = (long)(ulong)NativeWrapper.EvtGetEventMetadataProperty(eventLogHandle2, Microsoft.Win32.UnsafeNativeMethods.EvtEventMetadataPropertyId.EventMetadataEventKeyword);
							string template = (string)NativeWrapper.EvtGetEventMetadataProperty(eventLogHandle2, Microsoft.Win32.UnsafeNativeMethods.EvtEventMetadataPropertyId.EventMetadataEventTemplate);
							int num2 = (int)(uint)NativeWrapper.EvtGetEventMetadataProperty(eventLogHandle2, Microsoft.Win32.UnsafeNativeMethods.EvtEventMetadataPropertyId.EventMetadataEventMessageID);
							string description = ((num2 != -1) ? NativeWrapper.EvtFormatMessage(handle, (uint)num2) : null);
							EventMetadata item = new EventMetadata(id, version, channelId, level, opcode, task, num, template, description, this);
							list.Add(item);
						}
					}
					return list.AsReadOnly();
				}
			}
		}

		public ProviderMetadata(string providerName)
			: this(providerName, null, null, null)
		{
		}

		public ProviderMetadata(string providerName, EventLogSession session, CultureInfo targetCultureInfo)
			: this(providerName, session, targetCultureInfo, null)
		{
		}

		[SecurityCritical]
		[SecurityTreatAsSafe]
		internal ProviderMetadata(string providerName, EventLogSession session, CultureInfo targetCultureInfo, string logFilePath)
		{
			EventLogPermissionHolder.GetEventLogPermission().Demand();
			if (targetCultureInfo == null)
			{
				targetCultureInfo = CultureInfo.CurrentCulture;
			}
			if (session == null)
			{
				session = EventLogSession.GlobalSession;
			}
			this.session = session;
			this.providerName = providerName;
			cultureInfo = targetCultureInfo;
			this.logFilePath = logFilePath;
			handle = NativeWrapper.EvtOpenProviderMetadata(this.session.Handle, this.providerName, this.logFilePath, cultureInfo.LCID, 0);
			syncObject = new object();
		}

		internal string FindStandardLevelDisplayName(string name, uint value)
		{
			if (standardLevels == null)
			{
				standardLevels = (List<EventLevel>)GetProviderListProperty(defaultProviderHandle, Microsoft.Win32.UnsafeNativeMethods.EvtPublisherMetadataPropertyId.EvtPublisherMetadataLevels);
			}
			foreach (EventLevel standardLevel in standardLevels)
			{
				if (standardLevel.Name == name && standardLevel.Value == value)
				{
					return standardLevel.DisplayName;
				}
			}
			return null;
		}

		internal string FindStandardOpcodeDisplayName(string name, uint value)
		{
			if (standardOpcodes == null)
			{
				standardOpcodes = (List<EventOpcode>)GetProviderListProperty(defaultProviderHandle, Microsoft.Win32.UnsafeNativeMethods.EvtPublisherMetadataPropertyId.EvtPublisherMetadataOpcodes);
			}
			foreach (EventOpcode standardOpcode in standardOpcodes)
			{
				if (standardOpcode.Name == name && standardOpcode.Value == value)
				{
					return standardOpcode.DisplayName;
				}
			}
			return null;
		}

		internal string FindStandardKeywordDisplayName(string name, long value)
		{
			if (standardKeywords == null)
			{
				standardKeywords = (List<EventKeyword>)GetProviderListProperty(defaultProviderHandle, Microsoft.Win32.UnsafeNativeMethods.EvtPublisherMetadataPropertyId.EvtPublisherMetadataKeywords);
			}
			foreach (EventKeyword standardKeyword in standardKeywords)
			{
				if (standardKeyword.Name == name && standardKeyword.Value == value)
				{
					return standardKeyword.DisplayName;
				}
			}
			return null;
		}

		internal string FindStandardTaskDisplayName(string name, uint value)
		{
			if (standardTasks == null)
			{
				standardTasks = (List<EventTask>)GetProviderListProperty(defaultProviderHandle, Microsoft.Win32.UnsafeNativeMethods.EvtPublisherMetadataPropertyId.EvtPublisherMetadataTasks);
			}
			foreach (EventTask standardTask in standardTasks)
			{
				if (standardTask.Name == name && standardTask.Value == value)
				{
					return standardTask.DisplayName;
				}
			}
			return null;
		}

		[SecurityTreatAsSafe]
		[SecurityCritical]
		internal object GetProviderListProperty(EventLogHandle providerHandle, Microsoft.Win32.UnsafeNativeMethods.EvtPublisherMetadataPropertyId metadataProperty)
		{
			EventLogHandle eventLogHandle = EventLogHandle.Zero;
			EventLogPermissionHolder.GetEventLogPermission().Demand();
			try
			{
				List<EventLevel> list = null;
				List<EventOpcode> list2 = null;
				List<EventKeyword> list3 = null;
				List<EventTask> list4 = null;
				eventLogHandle = NativeWrapper.EvtGetPublisherMetadataPropertyHandle(providerHandle, metadataProperty);
				int num = NativeWrapper.EvtGetObjectArraySize(eventLogHandle);
				Microsoft.Win32.UnsafeNativeMethods.EvtPublisherMetadataPropertyId thePropertyId;
				Microsoft.Win32.UnsafeNativeMethods.EvtPublisherMetadataPropertyId thePropertyId2;
				Microsoft.Win32.UnsafeNativeMethods.EvtPublisherMetadataPropertyId thePropertyId3;
				ObjectTypeName objectTypeName;
				switch (metadataProperty)
				{
				case Microsoft.Win32.UnsafeNativeMethods.EvtPublisherMetadataPropertyId.EvtPublisherMetadataLevels:
					thePropertyId = Microsoft.Win32.UnsafeNativeMethods.EvtPublisherMetadataPropertyId.EvtPublisherMetadataLevelName;
					thePropertyId2 = Microsoft.Win32.UnsafeNativeMethods.EvtPublisherMetadataPropertyId.EvtPublisherMetadataLevelValue;
					thePropertyId3 = Microsoft.Win32.UnsafeNativeMethods.EvtPublisherMetadataPropertyId.EvtPublisherMetadataLevelMessageID;
					objectTypeName = ObjectTypeName.Level;
					list = new List<EventLevel>(num);
					break;
				case Microsoft.Win32.UnsafeNativeMethods.EvtPublisherMetadataPropertyId.EvtPublisherMetadataOpcodes:
					thePropertyId = Microsoft.Win32.UnsafeNativeMethods.EvtPublisherMetadataPropertyId.EvtPublisherMetadataOpcodeName;
					thePropertyId2 = Microsoft.Win32.UnsafeNativeMethods.EvtPublisherMetadataPropertyId.EvtPublisherMetadataOpcodeValue;
					thePropertyId3 = Microsoft.Win32.UnsafeNativeMethods.EvtPublisherMetadataPropertyId.EvtPublisherMetadataOpcodeMessageID;
					objectTypeName = ObjectTypeName.Opcode;
					list2 = new List<EventOpcode>(num);
					break;
				case Microsoft.Win32.UnsafeNativeMethods.EvtPublisherMetadataPropertyId.EvtPublisherMetadataKeywords:
					thePropertyId = Microsoft.Win32.UnsafeNativeMethods.EvtPublisherMetadataPropertyId.EvtPublisherMetadataKeywordName;
					thePropertyId2 = Microsoft.Win32.UnsafeNativeMethods.EvtPublisherMetadataPropertyId.EvtPublisherMetadataKeywordValue;
					thePropertyId3 = Microsoft.Win32.UnsafeNativeMethods.EvtPublisherMetadataPropertyId.EvtPublisherMetadataKeywordMessageID;
					objectTypeName = ObjectTypeName.Keyword;
					list3 = new List<EventKeyword>(num);
					break;
				case Microsoft.Win32.UnsafeNativeMethods.EvtPublisherMetadataPropertyId.EvtPublisherMetadataTasks:
					thePropertyId = Microsoft.Win32.UnsafeNativeMethods.EvtPublisherMetadataPropertyId.EvtPublisherMetadataTaskName;
					thePropertyId2 = Microsoft.Win32.UnsafeNativeMethods.EvtPublisherMetadataPropertyId.EvtPublisherMetadataTaskValue;
					thePropertyId3 = Microsoft.Win32.UnsafeNativeMethods.EvtPublisherMetadataPropertyId.EvtPublisherMetadataTaskMessageID;
					objectTypeName = ObjectTypeName.Task;
					list4 = new List<EventTask>(num);
					break;
				default:
					return null;
				}
				for (int i = 0; i < num; i++)
				{
					string name = (string)NativeWrapper.EvtGetObjectArrayProperty(eventLogHandle, i, (int)thePropertyId);
					uint num2 = 0u;
					long value = 0L;
					if (objectTypeName != ObjectTypeName.Keyword)
					{
						num2 = (uint)NativeWrapper.EvtGetObjectArrayProperty(eventLogHandle, i, (int)thePropertyId2);
					}
					else
					{
						value = (long)(ulong)NativeWrapper.EvtGetObjectArrayProperty(eventLogHandle, i, (int)thePropertyId2);
					}
					int num3 = (int)(uint)NativeWrapper.EvtGetObjectArrayProperty(eventLogHandle, i, (int)thePropertyId3);
					string displayName = null;
					if (num3 == -1)
					{
						if (providerHandle != defaultProviderHandle)
						{
							if (defaultProviderHandle.IsInvalid)
							{
								defaultProviderHandle = NativeWrapper.EvtOpenProviderMetadata(session.Handle, null, null, cultureInfo.LCID, 0);
							}
							displayName = objectTypeName switch
							{
								ObjectTypeName.Level => FindStandardLevelDisplayName(name, num2), 
								ObjectTypeName.Opcode => FindStandardOpcodeDisplayName(name, num2 >> 16), 
								ObjectTypeName.Keyword => FindStandardKeywordDisplayName(name, value), 
								ObjectTypeName.Task => FindStandardTaskDisplayName(name, num2), 
								_ => null, 
							};
						}
					}
					else
					{
						displayName = NativeWrapper.EvtFormatMessage(providerHandle, (uint)num3);
					}
					switch (objectTypeName)
					{
					case ObjectTypeName.Level:
						list.Add(new EventLevel(name, (int)num2, displayName));
						break;
					case ObjectTypeName.Opcode:
						list2.Add(new EventOpcode(name, (int)(num2 >> 16), displayName));
						break;
					case ObjectTypeName.Keyword:
						list3.Add(new EventKeyword(name, value, displayName));
						break;
					case ObjectTypeName.Task:
					{
						Guid guid = (Guid)NativeWrapper.EvtGetObjectArrayProperty(eventLogHandle, i, 18);
						list4.Add(new EventTask(name, (int)num2, displayName, guid));
						break;
					}
					default:
						return null;
					}
				}
				return objectTypeName switch
				{
					ObjectTypeName.Level => list, 
					ObjectTypeName.Opcode => list2, 
					ObjectTypeName.Keyword => list3, 
					ObjectTypeName.Task => list4, 
					_ => null, 
				};
			}
			finally
			{
				eventLogHandle.Close();
			}
		}

		internal void CheckReleased()
		{
			lock (syncObject)
			{
				GetProviderListProperty(handle, Microsoft.Win32.UnsafeNativeMethods.EvtPublisherMetadataPropertyId.EvtPublisherMetadataTasks);
			}
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		[SecurityCritical]
		[SecurityTreatAsSafe]
		protected virtual void Dispose(bool disposing)
		{
			if (disposing)
			{
				EventLogPermissionHolder.GetEventLogPermission().Demand();
			}
			if (handle != null && !handle.IsInvalid)
			{
				handle.Dispose();
			}
		}
	}
	internal class ProviderMetadataCachedInformation
	{
		private class ProviderMetadataId
		{
			private string providerName;

			private CultureInfo cultureInfo;

			public string ProviderName => providerName;

			public CultureInfo TheCultureInfo => cultureInfo;

			public ProviderMetadataId(string providerName, CultureInfo cultureInfo)
			{
				this.providerName = providerName;
				this.cultureInfo = cultureInfo;
			}

			public override bool Equals(object obj)
			{
				if (!(obj is ProviderMetadataId providerMetadataId))
				{
					return false;
				}
				if (providerName.Equals(providerMetadataId.providerName) && cultureInfo == providerMetadataId.cultureInfo)
				{
					return true;
				}
				return false;
			}

			public override int GetHashCode()
			{
				return providerName.GetHashCode() ^ cultureInfo.GetHashCode();
			}
		}

		private class CacheItem
		{
			private ProviderMetadata pm;

			private DateTime theTime;

			public DateTime TheTime
			{
				get
				{
					return theTime;
				}
				set
				{
					theTime = value;
				}
			}

			public ProviderMetadata ProviderMetadata => pm;

			public CacheItem(ProviderMetadata pm)
			{
				this.pm = pm;
				theTime = DateTime.Now;
			}
		}

		private Dictionary<ProviderMetadataId, CacheItem> cache;

		private int maximumCacheSize;

		private EventLogSession session;

		private string logfile;

		public ProviderMetadataCachedInformation(EventLogSession session, string logfile, int maximumCacheSize)
		{
			this.session = session;
			this.logfile = logfile;
			cache = new Dictionary<ProviderMetadataId, CacheItem>();
			this.maximumCacheSize = maximumCacheSize;
		}

		private bool IsCacheFull()
		{
			return cache.Count == maximumCacheSize;
		}

		private bool IsProviderinCache(ProviderMetadataId key)
		{
			return cache.ContainsKey(key);
		}

		private void DeleteCacheEntry(ProviderMetadataId key)
		{
			if (IsProviderinCache(key))
			{
				CacheItem cacheItem = cache[key];
				cache.Remove(key);
				cacheItem.ProviderMetadata.Dispose();
			}
		}

		private void AddCacheEntry(ProviderMetadataId key, ProviderMetadata pm)
		{
			if (IsCacheFull())
			{
				FlushOldestEntry();
			}
			CacheItem value = new CacheItem(pm);
			cache.Add(key, value);
		}

		private void FlushOldestEntry()
		{
			double num = -10.0;
			DateTime now = DateTime.Now;
			ProviderMetadataId providerMetadataId = null;
			foreach (KeyValuePair<ProviderMetadataId, CacheItem> item in cache)
			{
				TimeSpan timeSpan = now.Subtract(item.Value.TheTime);
				if (timeSpan.TotalMilliseconds >= num)
				{
					num = timeSpan.TotalMilliseconds;
					providerMetadataId = item.Key;
				}
			}
			if (providerMetadataId != null)
			{
				DeleteCacheEntry(providerMetadataId);
			}
		}

		private static void UpdateCacheValueInfoForHit(CacheItem cacheItem)
		{
			cacheItem.TheTime = DateTime.Now;
		}

		private ProviderMetadata GetProviderMetadata(ProviderMetadataId key)
		{
			if (!IsProviderinCache(key))
			{
				ProviderMetadata providerMetadata;
				try
				{
					providerMetadata = new ProviderMetadata(key.ProviderName, session, key.TheCultureInfo, logfile);
				}
				catch (EventLogNotFoundException)
				{
					providerMetadata = new ProviderMetadata(key.ProviderName, session, key.TheCultureInfo);
				}
				AddCacheEntry(key, providerMetadata);
				return providerMetadata;
			}
			CacheItem cacheItem = cache[key];
			ProviderMetadata providerMetadata2 = cacheItem.ProviderMetadata;
			try
			{
				providerMetadata2.CheckReleased();
				UpdateCacheValueInfoForHit(cacheItem);
				return providerMetadata2;
			}
			catch (EventLogException)
			{
				DeleteCacheEntry(key);
				try
				{
					providerMetadata2 = new ProviderMetadata(key.ProviderName, session, key.TheCultureInfo, logfile);
				}
				catch (EventLogNotFoundException)
				{
					providerMetadata2 = new ProviderMetadata(key.ProviderName, session, key.TheCultureInfo);
				}
				AddCacheEntry(key, providerMetadata2);
				return providerMetadata2;
			}
		}

		[SecurityTreatAsSafe]
		public string GetFormatDescription(string ProviderName, EventLogHandle eventHandle)
		{
			lock (this)
			{
				ProviderMetadataId key = new ProviderMetadataId(ProviderName, CultureInfo.CurrentCulture);
				try
				{
					ProviderMetadata providerMetadata = GetProviderMetadata(key);
					return NativeWrapper.EvtFormatMessageRenderName(providerMetadata.Handle, eventHandle, Microsoft.Win32.UnsafeNativeMethods.EvtFormatMessageFlags.EvtFormatMessageEvent);
				}
				catch (EventLogNotFoundException)
				{
					return null;
				}
			}
		}

		public string GetFormatDescription(string ProviderName, EventLogHandle eventHandle, string[] values)
		{
			lock (this)
			{
				ProviderMetadataId key = new ProviderMetadataId(ProviderName, CultureInfo.CurrentCulture);
				ProviderMetadata providerMetadata = GetProviderMetadata(key);
				try
				{
					return NativeWrapper.EvtFormatMessageFormatDescription(providerMetadata.Handle, eventHandle, values);
				}
				catch (EventLogNotFoundException)
				{
					return null;
				}
			}
		}

		[SecurityTreatAsSafe]
		public string GetLevelDisplayName(string ProviderName, [SecurityTreatAsSafe] EventLogHandle eventHandle)
		{
			lock (this)
			{
				ProviderMetadataId key = new ProviderMetadataId(ProviderName, CultureInfo.CurrentCulture);
				ProviderMetadata providerMetadata = GetProviderMetadata(key);
				return NativeWrapper.EvtFormatMessageRenderName(providerMetadata.Handle, eventHandle, Microsoft.Win32.UnsafeNativeMethods.EvtFormatMessageFlags.EvtFormatMessageLevel);
			}
		}

		[SecurityTreatAsSafe]
		public string GetOpcodeDisplayName(string ProviderName, [SecurityTreatAsSafe] EventLogHandle eventHandle)
		{
			lock (this)
			{
				ProviderMetadataId key = new ProviderMetadataId(ProviderName, CultureInfo.CurrentCulture);
				ProviderMetadata providerMetadata = GetProviderMetadata(key);
				return NativeWrapper.EvtFormatMessageRenderName(providerMetadata.Handle, eventHandle, Microsoft.Win32.UnsafeNativeMethods.EvtFormatMessageFlags.EvtFormatMessageOpcode);
			}
		}

		[SecurityTreatAsSafe]
		public string GetTaskDisplayName(string ProviderName, [SecurityTreatAsSafe] EventLogHandle eventHandle)
		{
			lock (this)
			{
				ProviderMetadataId key = new ProviderMetadataId(ProviderName, CultureInfo.CurrentCulture);
				ProviderMetadata providerMetadata = GetProviderMetadata(key);
				return NativeWrapper.EvtFormatMessageRenderName(providerMetadata.Handle, eventHandle, Microsoft.Win32.UnsafeNativeMethods.EvtFormatMessageFlags.EvtFormatMessageTask);
			}
		}

		[SecurityTreatAsSafe]
		public IEnumerable<string> GetKeywordDisplayNames(string ProviderName, [SecurityTreatAsSafe] EventLogHandle eventHandle)
		{
			lock (this)
			{
				ProviderMetadataId key = new ProviderMetadataId(ProviderName, CultureInfo.CurrentCulture);
				ProviderMetadata providerMetadata = GetProviderMetadata(key);
				return NativeWrapper.EvtFormatMessageRenderKeywords(providerMetadata.Handle, eventHandle, Microsoft.Win32.UnsafeNativeMethods.EvtFormatMessageFlags.EvtFormatMessageKeyword);
			}
		}
	}
	[SecurityCritical(SecurityCriticalScope.Everything)]
	internal sealed class CoTaskMemUnicodeSafeHandle : SafeHandle
	{
		public override bool IsInvalid
		{
			get
			{
				if (!base.IsClosed)
				{
					return handle == IntPtr.Zero;
				}
				return true;
			}
		}

		public static CoTaskMemUnicodeSafeHandle Zero => new CoTaskMemUnicodeSafeHandle();

		internal CoTaskMemUnicodeSafeHandle()
			: base(IntPtr.Zero, ownsHandle: true)
		{
		}

		internal CoTaskMemUnicodeSafeHandle(IntPtr handle, bool ownsHandle)
			: base(IntPtr.Zero, ownsHandle)
		{
			SetHandle(handle);
		}

		internal void SetMemory(IntPtr handle)
		{
			SetHandle(handle);
		}

		internal IntPtr GetMemory()
		{
			return handle;
		}

		protected override bool ReleaseHandle()
		{
			Marshal.ZeroFreeCoTaskMemUnicode(handle);
			handle = IntPtr.Zero;
			return true;
		}
	}
	[SecurityCritical(SecurityCriticalScope.Everything)]
	internal sealed class CoTaskMemSafeHandle : SafeHandle
	{
		public override bool IsInvalid
		{
			get
			{
				if (!base.IsClosed)
				{
					return handle == IntPtr.Zero;
				}
				return true;
			}
		}

		public static CoTaskMemSafeHandle Zero => new CoTaskMemSafeHandle();

		internal CoTaskMemSafeHandle()
			: base(IntPtr.Zero, ownsHandle: true)
		{
		}

		internal void SetMemory(IntPtr handle)
		{
			SetHandle(handle);
		}

		internal IntPtr GetMemory()
		{
			return handle;
		}

		protected override bool ReleaseHandle()
		{
			Marshal.FreeCoTaskMem(handle);
			handle = IntPtr.Zero;
			return true;
		}
	}
	public enum StandardEventLevel
	{
		LogAlways,
		Critical,
		Error,
		Warning,
		Informational,
		Verbose
	}
	public enum StandardEventTask
	{
		None
	}
	public enum StandardEventOpcode
	{
		Info = 0,
		Start = 1,
		Stop = 2,
		DataCollectionStart = 3,
		DataCollectionStop = 4,
		Extension = 5,
		Reply = 6,
		Resume = 7,
		Suspend = 8,
		Send = 9,
		Receive = 240
	}
	[Flags]
	public enum StandardEventKeywords : long
	{
		None = 0L,
		WdiContext = 0x2000000000000L,
		WdiDiagnostic = 0x4000000000000L,
		Sqm = 0x8000000000000L,
		AuditFailure = 0x10000000000000L,
		AuditSuccess = 0x20000000000000L,
		CorrelationHint = 0x10000000000000L,
		EventLogClassic = 0x80000000000000L
	}
}
namespace System
{
	public delegate void Action();
	public delegate void Action<T1, T2>(T1 arg1, T2 arg2);
	public delegate void Action<T1, T2, T3>(T1 arg1, T2 arg2, T3 arg3);
	public delegate void Action<T1, T2, T3, T4>(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
	public delegate TResult Func<TResult>();
	public delegate TResult Func<T, TResult>(T arg);
	public delegate TResult Func<T1, T2, TResult>(T1 arg1, T2 arg2);
	public delegate TResult Func<T1, T2, T3, TResult>(T1 arg1, T2 arg2, T3 arg3);
	public delegate TResult Func<T1, T2, T3, T4, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
}
namespace System.Linq.Expressions
{
	public enum ExpressionType
	{
		Add,
		AddChecked,
		And,
		AndAlso,
		ArrayLength,
		ArrayIndex,
		Call,
		Coalesce,
		Conditional,
		Constant,
		Convert,
		ConvertChecked,
		Divide,
		Equal,
		ExclusiveOr,
		GreaterThan,
		GreaterThanOrEqual,
		Invoke,
		Lambda,
		LeftShift,
		LessThan,
		LessThanOrEqual,
		ListInit,
		MemberAccess,
		MemberInit,
		Modulo,
		Multiply,
		MultiplyChecked,
		Negate,
		UnaryPlus,
		NegateChecked,
		New,
		NewArrayInit,
		NewArrayBounds,
		Not,
		NotEqual,
		Or,
		OrElse,
		Parameter,
		Power,
		Quote,
		RightShift,
		Subtract,
		SubtractChecked,
		TypeAs,
		TypeIs
	}
	public abstract class Expression
	{
		private ExpressionType nodeType;

		private Type type;

		private static Type[] lambdaTypes = new Type[2]
		{
			typeof(Expression),
			typeof(IEnumerable<ParameterExpression>)
		};

		private static readonly Type[] funcTypes = new Type[5]
		{
			typeof(Func<>),
			typeof(Func<, >),
			typeof(Func<, , >),
			typeof(Func<, , , >),
			typeof(Func<, , , , >)
		};

		private static readonly Type[] actionTypes = new Type[5]
		{
			typeof(Action),
			typeof(Action<>),
			typeof(Action<, >),
			typeof(Action<, , >),
			typeof(Action<, , , >)
		};

		public ExpressionType NodeType => nodeType;

		public Type Type => type;

		protected Expression(ExpressionType nodeType, Type type)
		{
			this.nodeType = nodeType;
			this.type = type;
		}

		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder();
			BuildString(stringBuilder);
			return stringBuilder.ToString();
		}

		internal virtual void BuildString(StringBuilder builder)
		{
			if (builder == null)
			{
				throw Error.ArgumentNull("builder");
			}
			builder.Append("[");
			builder.Append(nodeType.ToString());
			builder.Append("]");
		}

		public static BinaryExpression Add(Expression left, Expression right)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			if (left.Type == right.Type && IsArithmetic(left.Type))
			{
				return new BinaryExpression(ExpressionType.Add, left, right, left.Type);
			}
			return GetUserDefinedBinaryOperatorOrThrow(ExpressionType.Add, "op_Addition", left, right, liftToNull: true);
		}

		public static BinaryExpression Add(Expression left, Expression right, MethodInfo method)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			if (method == null)
			{
				return Add(left, right);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.Add, left, right, method, liftToNull: true);
		}

		public static BinaryExpression AddChecked(Expression left, Expression right)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			if (left.Type == right.Type && IsArithmetic(left.Type))
			{
				return new BinaryExpression(ExpressionType.AddChecked, left, right, left.Type);
			}
			return GetUserDefinedBinaryOperatorOrThrow(ExpressionType.AddChecked, "op_Addition", left, right, liftToNull: false);
		}

		public static BinaryExpression AddChecked(Expression left, Expression right, MethodInfo method)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			if (method == null)
			{
				return AddChecked(left, right);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.AddChecked, left, right, method, liftToNull: true);
		}

		public static BinaryExpression And(Expression left, Expression right)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			if (left.Type == right.Type && IsIntegerOrBool(left.Type))
			{
				return new BinaryExpression(ExpressionType.And, left, right, left.Type);
			}
			return GetUserDefinedBinaryOperatorOrThrow(ExpressionType.And, "op_BitwiseAnd", left, right, liftToNull: true);
		}

		public static BinaryExpression And(Expression left, Expression right, MethodInfo method)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			if (method == null)
			{
				return And(left, right);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.And, left, right, method, liftToNull: true);
		}

		public static BinaryExpression AndAlso(Expression left, Expression right)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			if (left.Type == right.Type && IsBool(left.Type))
			{
				return new BinaryExpression(ExpressionType.AndAlso, left, right, left.Type);
			}
			MethodInfo userDefinedBinaryOperator = GetUserDefinedBinaryOperator(ExpressionType.AndAlso, left.Type, right.Type, "op_BitwiseAnd");
			if (userDefinedBinaryOperator != null)
			{
				ValidateUserDefinedConditionalLogicOperator(ExpressionType.AndAlso, left.Type, right.Type, userDefinedBinaryOperator);
				Type type = ((IsNullableType(left.Type) && userDefinedBinaryOperator.ReturnType == GetNonNullableType(left.Type)) ? left.Type : userDefinedBinaryOperator.ReturnType);
				return new BinaryExpression(ExpressionType.AndAlso, left, right, userDefinedBinaryOperator, type);
			}
			throw Error.BinaryOperatorNotDefined(ExpressionType.AndAlso, left.Type, right.Type);
		}

		public static BinaryExpression AndAlso(Expression left, Expression right, MethodInfo method)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			if (method == null)
			{
				return AndAlso(left, right);
			}
			ValidateUserDefinedConditionalLogicOperator(ExpressionType.AndAlso, left.Type, right.Type, method);
			Type type = ((IsNullableType(left.Type) && method.ReturnType == GetNonNullableType(left.Type)) ? left.Type : method.ReturnType);
			return new BinaryExpression(ExpressionType.AndAlso, left, right, method, type);
		}

		public static BinaryExpression ArrayIndex(Expression array, Expression index)
		{
			if (array == null)
			{
				throw Error.ArgumentNull("array");
			}
			if (index == null)
			{
				throw Error.ArgumentNull("index");
			}
			if (index.Type != typeof(int))
			{
				throw Error.ArgumentMustBeArrayIndexType();
			}
			if (!array.Type.IsArray)
			{
				throw Error.ArgumentMustBeArray();
			}
			if (array.Type.GetArrayRank() != 1)
			{
				throw Error.IncorrectNumberOfIndexes();
			}
			return new BinaryExpression(ExpressionType.ArrayIndex, array, index, array.Type.GetElementType());
		}

		public static MethodCallExpression ArrayIndex(Expression array, params Expression[] indexes)
		{
			return ArrayIndex(array, (IEnumerable<Expression>)indexes);
		}

		public static MethodCallExpression ArrayIndex(Expression array, IEnumerable<Expression> indexes)
		{
			if (array == null)
			{
				throw Error.ArgumentNull("array");
			}
			if (indexes == null)
			{
				throw Error.ArgumentNull("indexes");
			}
			if (!array.Type.IsArray)
			{
				throw Error.ArgumentMustBeArray();
			}
			ReadOnlyCollection<Expression> readOnlyCollection = indexes.ToReadOnlyCollection();
			if (array.Type.GetArrayRank() != readOnlyCollection.Count)
			{
				throw Error.IncorrectNumberOfIndexes();
			}
			foreach (Expression item in readOnlyCollection)
			{
				if (item.Type != typeof(int))
				{
					throw Error.ArgumentMustBeArrayIndexType();
				}
			}
			MethodInfo method = array.Type.GetMethod("Get", BindingFlags.Instance | BindingFlags.Public);
			return Call(array, method, readOnlyCollection);
		}

		public static UnaryExpression ArrayLength(Expression array)
		{
			if (array == null)
			{
				throw Error.ArgumentNull("array");
			}
			if (!array.Type.IsArray || !AreAssignable(typeof(Array), array.Type))
			{
				throw Error.ArgumentMustBeArray();
			}
			if (array.Type.GetArrayRank() != 1)
			{
				throw Error.ArgumentMustBeSingleDimensionalArrayType();
			}
			return new UnaryExpression(ExpressionType.ArrayLength, array, typeof(int));
		}

		public static MemberAssignment Bind(MemberInfo member, Expression expression)
		{
			if (member == null)
			{
				throw Error.ArgumentNull("member");
			}
			if (expression == null)
			{
				throw Error.ArgumentNull("expression");
			}
			ValidateSettableFieldOrPropertyMember(member, out var memberType);
			if (!AreAssignable(memberType, expression.Type))
			{
				throw Error.ArgumentTypesMustMatch();
			}
			return new MemberAssignment(member, expression);
		}

		private static PropertyInfo GetProperty(MethodInfo mi)
		{
			Type declaringType = mi.DeclaringType;
			BindingFlags bindingFlags = BindingFlags.Public | BindingFlags.NonPublic;
			bindingFlags |= (mi.IsStatic ? BindingFlags.Static : BindingFlags.Instance);
			PropertyInfo[] properties = declaringType.GetProperties(bindingFlags);
			PropertyInfo[] array = properties;
			foreach (PropertyInfo propertyInfo in array)
			{
				if (propertyInfo.CanRead && CheckMethod(mi, propertyInfo.GetGetMethod(nonPublic: true)))
				{
					return propertyInfo;
				}
				if (propertyInfo.CanWrite && CheckMethod(mi, propertyInfo.GetSetMethod(nonPublic: true)))
				{
					return propertyInfo;
				}
			}
			throw Error.MethodNotPropertyAccessor(mi.DeclaringType, mi.Name);
		}

		private static bool CheckMethod(MethodInfo method, MethodInfo propertyMethod)
		{
			if (method == propertyMethod)
			{
				return true;
			}
			Type declaringType = method.DeclaringType;
			if (declaringType.IsInterface && method.Name == propertyMethod.Name && declaringType.GetMethod(method.Name) == propertyMethod)
			{
				return true;
			}
			return false;
		}

		public static MemberAssignment Bind(MethodInfo propertyAccessor, Expression expression)
		{
			if (propertyAccessor == null)
			{
				throw Error.ArgumentNull("propertyAccessor");
			}
			if (expression == null)
			{
				throw Error.ArgumentNull("expression");
			}
			ValidateMethodInfo(propertyAccessor);
			return Bind(GetProperty(propertyAccessor), expression);
		}

		public static MethodCallExpression Call(MethodInfo method, params Expression[] arguments)
		{
			return Call(null, method, arguments.ToReadOnlyCollection());
		}

		public static MethodCallExpression Call(Expression instance, MethodInfo method, params Expression[] arguments)
		{
			return Call(instance, method, arguments.ToReadOnlyCollection());
		}

		public static MethodCallExpression Call(Expression instance, MethodInfo method, IEnumerable<Expression> arguments)
		{
			ReadOnlyCollection<Expression> arguments2 = arguments.ToReadOnlyCollection();
			ValidateCallArgs(instance, method, ref arguments2);
			return new MethodCallExpression(ExpressionType.Call, method, instance, arguments2);
		}

		public static MethodCallExpression Call(Expression instance, MethodInfo method)
		{
			return Call(instance, method, (Expression[])null);
		}

		private static void ValidateCallArgs(Expression instance, MethodInfo method, ref ReadOnlyCollection<Expression> arguments)
		{
			if (method == null)
			{
				throw Error.ArgumentNull("method");
			}
			if (arguments == null)
			{
				throw Error.ArgumentNull("arguments");
			}
			ValidateMethodInfo(method);
			if (!method.IsStatic)
			{
				if (instance == null)
				{
					throw Error.ArgumentNull("instance");
				}
				ValidateCallInstanceType(instance.Type, method);
			}
			ValidateArgumentTypes(method, ref arguments);
		}

		private static void ValidateCallInstanceType(Type instanceType, MethodInfo method)
		{
			if (AreReferenceAssignable(method.DeclaringType, instanceType))
			{
				return;
			}
			if (instanceType.IsValueType)
			{
				if (AreReferenceAssignable(method.DeclaringType, typeof(object)) || AreReferenceAssignable(method.DeclaringType, typeof(ValueType)) || (instanceType.IsEnum && AreReferenceAssignable(method.DeclaringType, typeof(Enum))))
				{
					return;
				}
				if (method.DeclaringType.IsInterface)
				{
					Type[] interfaces = instanceType.GetInterfaces();
					foreach (Type src in interfaces)
					{
						if (AreReferenceAssignable(method.DeclaringType, src))
						{
							return;
						}
					}
				}
			}
			throw Error.MethodNotDefinedForType(method, instanceType);
		}

		private static void ValidateArgumentTypes(MethodInfo method, ref ReadOnlyCollection<Expression> arguments)
		{
			ParameterInfo[] parameters = method.GetParameters();
			if (parameters.Length > 0)
			{
				if (parameters.Length != arguments.Count)
				{
					throw Error.IncorrectNumberOfMethodCallArguments(method);
				}
				List<Expression> list = null;
				int i = 0;
				for (int num = parameters.Length; i < num; i++)
				{
					Expression expression = arguments[i];
					ParameterInfo parameterInfo = parameters[i];
					if (expression == null)
					{
						throw Error.ArgumentNull("arguments");
					}
					Type type = parameterInfo.ParameterType;
					if (type.IsByRef)
					{
						type = type.GetElementType();
					}
					ValidateType(type);
					if (!AreReferenceAssignable(type, expression.Type))
					{
						if (!IsSameOrSubclass(typeof(Expression), type) || !AreAssignable(type, expression.GetType()))
						{
							throw Error.ExpressionTypeDoesNotMatchMethodParameter(expression.Type, type, method);
						}
						expression = Quote(expression);
					}
					if (list == null && expression != arguments[i])
					{
						list = new List<Expression>(arguments.Count);
						for (int j = 0; j < i; j++)
						{
							list.Add(arguments[j]);
						}
					}
					list?.Add(expression);
				}
				if (list != null)
				{
					arguments = list.ToReadOnlyCollection();
				}
			}
			else if (arguments.Count > 0)
			{
				throw Error.IncorrectNumberOfMethodCallArguments(method);
			}
		}

		public static MethodCallExpression Call(Expression instance, string methodName, Type[] typeArguments, params Expression[] arguments)
		{
			if (instance == null)
			{
				throw Error.ArgumentNull("instance");
			}
			if (methodName == null)
			{
				throw Error.ArgumentNull("methodName");
			}
			if (arguments == null)
			{
				arguments = new Expression[0];
			}
			BindingFlags flags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy;
			return Call(instance, FindMethod(instance.Type, methodName, typeArguments, arguments, flags), arguments);
		}

		public static MethodCallExpression Call(Type type, string methodName, Type[] typeArguments, params Expression[] arguments)
		{
			if (type == null)
			{
				throw Error.ArgumentNull("type");
			}
			if (methodName == null)
			{
				throw Error.ArgumentNull("methodName");
			}
			if (arguments == null)
			{
				arguments = new Expression[0];
			}
			BindingFlags flags = BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy;
			return Call(null, FindMethod(type, methodName, typeArguments, arguments, flags), arguments);
		}

		private static MethodInfo FindMethod(Type type, string methodName, Type[] typeArgs, Expression[] args, BindingFlags flags)
		{
			MemberInfo[] array = type.FindMembers(MemberTypes.Method, flags, Type.FilterNameIgnoreCase, methodName);
			if (array == null || array.Length == 0)
			{
				throw Error.MethodDoesNotExistOnType(methodName, type);
			}
			MethodInfo method;
			int num = FindBestMethod(array.Cast<MethodInfo>(), typeArgs, args, out method);
			if (num == 0)
			{
				throw Error.MethodWithArgsDoesNotExistOnType(methodName, type);
			}
			if (num > 1)
			{
				throw Error.MethodWithMoreThanOneMatch(methodName, type);
			}
			return method;
		}

		private static int FindBestMethod(IEnumerable<MethodInfo> methods, Type[] typeArgs, Expression[] args, out MethodInfo method)
		{
			int num = 0;
			method = null;
			foreach (MethodInfo method2 in methods)
			{
				MethodInfo methodInfo = ApplyTypeArgs(method2, typeArgs);
				if (methodInfo != null && IsCompatible(methodInfo, args))
				{
					if (method == null || (!method.IsPublic && methodInfo.IsPublic))
					{
						method = methodInfo;
						num = 1;
					}
					else if (method.IsPublic == methodInfo.IsPublic)
					{
						num++;
					}
				}
			}
			return num;
		}

		private static MethodInfo ApplyTypeArgs(MethodInfo m, Type[] typeArgs)
		{
			if (typeArgs == null || typeArgs.Length == 0)
			{
				if (!m.IsGenericMethodDefinition)
				{
					return m;
				}
			}
			else if (m.IsGenericMethodDefinition && m.GetGenericArguments().Length == typeArgs.Length)
			{
				return m.MakeGenericMethod(typeArgs);
			}
			return null;
		}

		private static bool IsCompatible(MethodInfo m, Expression[] args)
		{
			ParameterInfo[] parameters = m.GetParameters();
			if (parameters.Length != args.Length)
			{
				return false;
			}
			for (int i = 0; i < args.Length; i++)
			{
				Expression expression = args[i];
				if (expression == null)
				{
					throw Error.ArgumentNull("argument");
				}
				Type src = expression.Type;
				Type type = parameters[i].ParameterType;
				if (type.IsByRef)
				{
					type = type.GetElementType();
				}
				if (!AreReferenceAssignable(type, src) && (!IsSameOrSubclass(typeof(Expression), type) || !AreAssignable(type, expression.GetType())))
				{
					return false;
				}
			}
			return true;
		}

		public static BinaryExpression Coalesce(Expression left, Expression right, LambdaExpression conversion)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			if (conversion == null)
			{
				return Coalesce(left, right);
			}
			if (left.Type.IsValueType && !IsNullableType(left.Type))
			{
				throw Error.CoalesceUsedOnNonNullType();
			}
			Type type = conversion.Type;
			MethodInfo method = type.GetMethod("Invoke");
			if (method.ReturnType == typeof(void))
			{
				throw Error.UserDefinedOperatorMustNotBeVoid(conversion);
			}
			ParameterInfo[] parameters = method.GetParameters();
			if (parameters.Length != 1)
			{
				throw Error.IncorrectNumberOfMethodCallArguments(conversion);
			}
			if (method.ReturnType != right.Type)
			{
				throw Error.OperandTypesDoNotMatchParameters(ExpressionType.Coalesce, conversion.ToString());
			}
			if (!ParameterIsAssignable(parameters[0], GetNonNullableType(left.Type)) && !ParameterIsAssignable(parameters[0], left.Type))
			{
				throw Error.OperandTypesDoNotMatchParameters(ExpressionType.Coalesce, conversion.ToString());
			}
			return new BinaryExpression(ExpressionType.Coalesce, left, right, conversion, right.Type);
		}

		public static BinaryExpression Coalesce(Expression left, Expression right)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			Type type = ValidateCoalesceArgTypes(left.Type, right.Type);
			return new BinaryExpression(ExpressionType.Coalesce, left, right, type);
		}

		public static ConditionalExpression Condition(Expression test, Expression ifTrue, Expression ifFalse)
		{
			if (test == null)
			{
				throw Error.ArgumentNull("test");
			}
			if (ifTrue == null)
			{
				throw Error.ArgumentNull("ifTrue");
			}
			if (ifFalse == null)
			{
				throw Error.ArgumentNull("ifFalse");
			}
			if (test.Type != typeof(bool))
			{
				throw Error.ArgumentMustBeBoolean();
			}
			ValidateSameArgTypes(ifTrue.Type, ifFalse.Type);
			return new ConditionalExpression(test, ifTrue, ifFalse, ifTrue.Type);
		}

		public static ConstantExpression Constant(object value)
		{
			Type type = ((value != null) ? value.GetType() : typeof(object));
			return Constant(value, type);
		}

		public static ConstantExpression Constant(object value, Type type)
		{
			if (type == null)
			{
				throw Error.ArgumentNull("type");
			}
			if (value == null && type.IsValueType && !IsNullableType(type))
			{
				throw Error.ArgumentTypesMustMatch();
			}
			if (value != null && !AreAssignable(type, value.GetType()))
			{
				throw Error.ArgumentTypesMustMatch();
			}
			return new ConstantExpression(value, type);
		}

		private static bool HasIdentityPrimitiveOrNullableConversion(Type source, Type dest)
		{
			if (source == dest)
			{
				return true;
			}
			if (IsNullableType(source) && dest == GetNonNullableType(source))
			{
				return true;
			}
			if (IsNullableType(dest) && source == GetNonNullableType(dest))
			{
				return true;
			}
			if (IsConvertible(source) && IsConvertible(dest) && GetNonNullableType(dest) != typeof(bool))
			{
				return true;
			}
			return false;
		}

		private static bool HasReferenceConversion(Type source, Type dest)
		{
			Type nonNullableType = GetNonNullableType(source);
			Type nonNullableType2 = GetNonNullableType(dest);
			if (AreAssignable(nonNullableType, nonNullableType2))
			{
				return true;
			}
			if (AreAssignable(nonNullableType2, nonNullableType))
			{
				return true;
			}
			if (source.IsInterface || dest.IsInterface)
			{
				return true;
			}
			if (source == typeof(object) || dest == typeof(object))
			{
				return true;
			}
			return false;
		}

		public static UnaryExpression Convert(Expression expression, Type type)
		{
			if (expression == null)
			{
				throw Error.ArgumentNull("expression");
			}
			if (type == null)
			{
				throw Error.ArgumentNull("type");
			}
			if (HasIdentityPrimitiveOrNullableConversion(expression.Type, type) || HasReferenceConversion(expression.Type, type))
			{
				return new UnaryExpression(ExpressionType.Convert, expression, type);
			}
			return GetUserDefinedCoercionOrThrow(ExpressionType.Convert, expression, type);
		}

		public static UnaryExpression Convert(Expression expression, Type type, MethodInfo method)
		{
			if (expression == null)
			{
				throw Error.ArgumentNull("expression");
			}
			if (method == null)
			{
				return Convert(expression, type);
			}
			return GetMethodBasedCoercionOperator(ExpressionType.Convert, expression, type, method);
		}

		public static UnaryExpression ConvertChecked(Expression expression, Type type)
		{
			if (expression == null)
			{
				throw Error.ArgumentNull("expression");
			}
			if (type == null)
			{
				throw Error.ArgumentNull("type");
			}
			if (HasIdentityPrimitiveOrNullableConversion(expression.Type, type))
			{
				return new UnaryExpression(ExpressionType.ConvertChecked, expression, type);
			}
			if (HasReferenceConversion(expression.Type, type))
			{
				return new UnaryExpression(ExpressionType.Convert, expression, type);
			}
			return GetUserDefinedCoercionOrThrow(ExpressionType.ConvertChecked, expression, type);
		}

		public static UnaryExpression ConvertChecked(Expression expression, Type type, MethodInfo method)
		{
			if (expression == null)
			{
				throw Error.ArgumentNull("expression");
			}
			if (method == null)
			{
				return ConvertChecked(expression, type);
			}
			return GetMethodBasedCoercionOperator(ExpressionType.ConvertChecked, expression, type, method);
		}

		public static BinaryExpression Divide(Expression left, Expression right)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			if (left.Type == right.Type && IsArithmetic(left.Type))
			{
				return new BinaryExpression(ExpressionType.Divide, left, right, left.Type);
			}
			return GetUserDefinedBinaryOperatorOrThrow(ExpressionType.Divide, "op_Division", left, right, liftToNull: true);
		}

		public static BinaryExpression Divide(Expression left, Expression right, MethodInfo method)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			if (method == null)
			{
				return Divide(left, right);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.Divide, left, right, method, liftToNull: true);
		}

		public static BinaryExpression Equal(Expression left, Expression right)
		{
			return Equal(left, right, liftToNull: false, null);
		}

		public static BinaryExpression Equal(Expression left, Expression right, bool liftToNull, MethodInfo method)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			if (method == null)
			{
				return GetEqualityComparisonOperator(ExpressionType.Equal, "op_Equality", left, right, liftToNull);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.Equal, left, right, method, liftToNull);
		}

		public static BinaryExpression ExclusiveOr(Expression left, Expression right)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			if (left.Type == right.Type && IsIntegerOrBool(left.Type))
			{
				return new BinaryExpression(ExpressionType.ExclusiveOr, left, right, left.Type);
			}
			return GetUserDefinedBinaryOperatorOrThrow(ExpressionType.ExclusiveOr, "op_ExclusiveOr", left, right, liftToNull: true);
		}

		public static BinaryExpression ExclusiveOr(Expression left, Expression right, MethodInfo method)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			if (method == null)
			{
				return ExclusiveOr(left, right);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.ExclusiveOr, left, right, method, liftToNull: true);
		}

		public static MemberExpression Field(Expression expression, FieldInfo field)
		{
			if (field == null)
			{
				throw Error.ArgumentNull("field");
			}
			if (!field.IsStatic)
			{
				if (expression == null)
				{
					throw Error.ArgumentNull("expression");
				}
				if (!AreReferenceAssignable(field.DeclaringType, expression.Type))
				{
					throw Error.FieldNotDefinedForType(field, expression.Type);
				}
			}
			return new MemberExpression(expression, field, field.FieldType);
		}

		public static MemberExpression Field(Expression expression, string fieldName)
		{
			if (expression == null)
			{
				throw Error.ArgumentNull("expression");
			}
			FieldInfo field = expression.Type.GetField(fieldName, BindingFlags.IgnoreCase | BindingFlags.Instance | BindingFlags.Public | BindingFlags.FlattenHierarchy);
			if (field == null)
			{
				field = expression.Type.GetField(fieldName, BindingFlags.IgnoreCase | BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy);
			}
			if (field == null)
			{
				throw Error.FieldNotDefinedForType(fieldName, expression.Type);
			}
			return Field(expression, field);
		}

		public static BinaryExpression GreaterThanOrEqual(Expression left, Expression right)
		{
			return GreaterThanOrEqual(left, right, liftToNull: false, null);
		}

		public static BinaryExpression GreaterThanOrEqual(Expression left, Expression right, bool liftToNull, MethodInfo method)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			if (method == null)
			{
				return GetComparisonOperator(ExpressionType.GreaterThanOrEqual, "op_GreaterThanOrEqual", left, right, liftToNull);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.GreaterThanOrEqual, left, right, method, liftToNull);
		}

		public static BinaryExpression GreaterThan(Expression left, Expression right)
		{
			return GreaterThan(left, right, liftToNull: false, null);
		}

		public static BinaryExpression GreaterThan(Expression left, Expression right, bool liftToNull, MethodInfo method)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			if (method == null)
			{
				return GetComparisonOperator(ExpressionType.GreaterThan, "op_GreaterThan", left, right, liftToNull);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.GreaterThan, left, right, method, liftToNull);
		}

		public static InvocationExpression Invoke(Expression expression, params Expression[] arguments)
		{
			return Invoke(expression, arguments.ToReadOnlyCollection());
		}

		public static InvocationExpression Invoke(Expression expression, IEnumerable<Expression> arguments)
		{
			if (expression == null)
			{
				throw Error.ArgumentNull("expression");
			}
			Type type = expression.Type;
			if (type == typeof(Delegate))
			{
				throw Error.ExpressionTypeNotInvocable(type);
			}
			if (!AreAssignable(typeof(Delegate), expression.Type))
			{
				Type type2 = TypeHelper.FindGenericType(typeof(Expression<>), expression.Type);
				if (type2 == null)
				{
					throw Error.ExpressionTypeNotInvocable(expression.Type);
				}
				type = type2.GetGenericArguments()[0];
			}
			MethodInfo method = type.GetMethod("Invoke");
			ParameterInfo[] parameters = method.GetParameters();
			ReadOnlyCollection<Expression> readOnlyCollection = arguments.ToReadOnlyCollection();
			if (parameters.Length > 0)
			{
				if (readOnlyCollection.Count != parameters.Length)
				{
					throw Error.IncorrectNumberOfLambdaArguments();
				}
				List<Expression> list = null;
				int i = 0;
				for (int count = readOnlyCollection.Count; i < count; i++)
				{
					Expression expression2 = readOnlyCollection[i];
					ParameterInfo parameterInfo = parameters[i];
					if (expression2 == null)
					{
						throw Error.ArgumentNull("arguments");
					}
					Type type3 = parameterInfo.ParameterType;
					if (type3.IsByRef)
					{
						type3 = type3.GetElementType();
					}
					if (!AreReferenceAssignable(type3, expression2.Type))
					{
						if (!IsSameOrSubclass(typeof(Expression), type3) || !AreAssignable(type3, expression2.GetType()))
						{
							throw Error.ExpressionTypeDoesNotMatchParameter(expression2.Type, type3);
						}
						expression2 = Quote(expression2);
					}
					if (list == null && expression2 != readOnlyCollection[i])
					{
						list = new List<Expression>(readOnlyCollection.Count);
						for (int j = 0; j < i; j++)
						{
							list.Add(readOnlyCollection[j]);
						}
					}
					list?.Add(expression2);
				}
				if (list != null)
				{
					readOnlyCollection = list.ToReadOnlyCollection();
				}
			}
			else if (readOnlyCollection.Count > 0)
			{
				throw Error.IncorrectNumberOfLambdaArguments();
			}
			return new InvocationExpression(expression, method.ReturnType, readOnlyCollection);
		}

		public static Expression<TDelegate> Lambda<TDelegate>(Expression body, params ParameterExpression[] parameters)
		{
			return Lambda<TDelegate>(body, parameters.ToReadOnlyCollection());
		}

		public static Expression<TDelegate> Lambda<TDelegate>(Expression body, IEnumerable<ParameterExpression> parameters)
		{
			if (body == null)
			{
				throw Error.ArgumentNull("body");
			}
			ReadOnlyCollection<ParameterExpression> parameters2 = parameters.ToReadOnlyCollection();
			ValidateLambdaArgs(typeof(TDelegate), ref body, parameters2);
			return new Expression<TDelegate>(body, parameters2);
		}

		public static LambdaExpression Lambda(Type delegateType, Expression body, params ParameterExpression[] parameters)
		{
			return Lambda(delegateType, body, parameters.ToReadOnlyCollection());
		}

		public static LambdaExpression Lambda(Type delegateType, Expression body, IEnumerable<ParameterExpression> parameters)
		{
			if (delegateType == null)
			{
				throw Error.ArgumentNull("delegateType");
			}
			if (body == null)
			{
				throw Error.ArgumentNull("body");
			}
			ReadOnlyCollection<ParameterExpression> readOnlyCollection = parameters.ToReadOnlyCollection();
			ValidateLambdaArgs(delegateType, ref body, readOnlyCollection);
			MethodInfo method = typeof(Expression).GetMethod("Lambda", BindingFlags.Static | BindingFlags.Public, null, lambdaTypes, null);
			MethodInfo methodInfo = method.MakeGenericMethod(delegateType);
			return (LambdaExpression)methodInfo.Invoke(null, new object[2] { body, readOnlyCollection });
		}

		public static LambdaExpression Lambda(Expression body, params ParameterExpression[] parameters)
		{
			if (body == null)
			{
				throw Error.ArgumentNull("body");
			}
			bool flag = body.Type == typeof(void);
			int num = ((parameters != null) ? parameters.Length : 0);
			Type[] array = new Type[num + ((!flag) ? 1 : 0)];
			for (int i = 0; i < num; i++)
			{
				if (parameters[i] == null)
				{
					throw Error.ArgumentNull("parameter");
				}
				array[i] = parameters[i].Type;
			}
			Type delegateType;
			if (flag)
			{
				delegateType = GetActionType(array);
			}
			else
			{
				array[num] = body.Type;
				delegateType = GetFuncType(array);
			}
			return Lambda(delegateType, body, parameters);
		}

		public static Type GetFuncType(params Type[] typeArgs)
		{
			if (typeArgs == null)
			{
				throw Error.ArgumentNull("typeArgs");
			}
			if (typeArgs.Length < 1 || typeArgs.Length > 5)
			{
				throw Error.IncorrectNumberOfTypeArgsForFunc();
			}
			return funcTypes[typeArgs.Length - 1].MakeGenericType(typeArgs);
		}

		public static Type GetActionType(params Type[] typeArgs)
		{
			if (typeArgs == null)
			{
				throw Error.ArgumentNull("typeArgs");
			}
			if (typeArgs.Length >= actionTypes.Length)
			{
				throw Error.IncorrectNumberOfTypeArgsForAction();
			}
			if (typeArgs.Length == 0)
			{
				return actionTypes[typeArgs.Length];
			}
			return actionTypes[typeArgs.Length].MakeGenericType(typeArgs);
		}

		private static void ValidateLambdaArgs(Type delegateType, ref Expression body, ReadOnlyCollection<ParameterExpression> parameters)
		{
			if (delegateType == null)
			{
				throw Error.ArgumentNull("delegateType");
			}
			if (body == null)
			{
				throw Error.ArgumentNull("body");
			}
			if (!AreAssignable(typeof(Delegate), delegateType) || delegateType == typeof(Delegate))
			{
				throw Error.LambdaTypeMustBeDerivedFromSystemDelegate();
			}
			MethodInfo method = delegateType.GetMethod("Invoke");
			ParameterInfo[] parameters2 = method.GetParameters();
			if (parameters2.Length > 0)
			{
				if (parameters2.Length != parameters.Count)
				{
					throw Error.IncorrectNumberOfLambdaDeclarationParameters();
				}
				int i = 0;
				for (int num = parameters2.Length; i < num; i++)
				{
					Expression expression = parameters[i];
					ParameterInfo parameterInfo = parameters2[i];
					if (expression == null)
					{
						throw Error.ArgumentNull("parameters");
					}
					Type parameterType = parameterInfo.ParameterType;
					if (parameterType.IsByRef || expression.Type.IsByRef)
					{
						throw Error.ExpressionMayNotContainByrefParameters();
					}
					if (!AreReferenceAssignable(expression.Type, parameterType))
					{
						throw Error.ParameterExpressionNotValidAsDelegate(expression.Type, parameterType);
					}
				}
			}
			else if (parameters.Count > 0)
			{
				throw Error.IncorrectNumberOfLambdaDeclarationParameters();
			}
			if (method.ReturnType != typeof(void) && !AreReferenceAssignable(method.ReturnType, body.Type))
			{
				if (!IsSameOrSubclass(typeof(Expression), method.ReturnType) || !AreAssignable(method.ReturnType, body.GetType()))
				{
					throw Error.ExpressionTypeDoesNotMatchReturn(body.Type, method.ReturnType);
				}
				body = Quote(body);
			}
		}

		public static BinaryExpression LeftShift(Expression left, Expression right)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			if (IsInteger(left.Type) && GetNonNullableType(right.Type) == typeof(int))
			{
				return new BinaryExpression(ExpressionType.LeftShift, left, right, left.Type);
			}
			return GetUserDefinedBinaryOperatorOrThrow(ExpressionType.LeftShift, "op_LeftShift", left, right, liftToNull: true);
		}

		public static BinaryExpression LeftShift(Expression left, Expression right, MethodInfo method)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			if (method == null)
			{
				return LeftShift(left, right);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.LeftShift, left, right, method, liftToNull: true);
		}

		public static BinaryExpression LessThan(Expression left, Expression right)
		{
			return LessThan(left, right, liftToNull: false, null);
		}

		public static BinaryExpression LessThan(Expression left, Expression right, bool liftToNull, MethodInfo method)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			if (method == null)
			{
				return GetComparisonOperator(ExpressionType.LessThan, "op_LessThan", left, right, liftToNull);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.LessThan, left, right, method, liftToNull);
		}

		public static BinaryExpression LessThanOrEqual(Expression left, Expression right)
		{
			return LessThanOrEqual(left, right, liftToNull: false, null);
		}

		public static BinaryExpression LessThanOrEqual(Expression left, Expression right, bool liftToNull, MethodInfo method)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			if (method == null)
			{
				return GetComparisonOperator(ExpressionType.LessThanOrEqual, "op_LessThanOrEqual", left, right, liftToNull);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.LessThanOrEqual, left, right, method, liftToNull);
		}

		internal static void ValidateLift(IEnumerable<ParameterExpression> parameters, IEnumerable<Expression> arguments)
		{
			ReadOnlyCollection<ParameterExpression> readOnlyCollection = parameters.ToReadOnlyCollection();
			ReadOnlyCollection<Expression> readOnlyCollection2 = arguments.ToReadOnlyCollection();
			if (readOnlyCollection.Count != readOnlyCollection2.Count)
			{
				throw Error.IncorrectNumberOfIndexes();
			}
			int i = 0;
			for (int count = readOnlyCollection.Count; i < count; i++)
			{
				if (!AreReferenceAssignable(readOnlyCollection[i].Type, GetNonNullableType(readOnlyCollection2[i].Type)))
				{
					throw Error.ArgumentTypesMustMatch();
				}
			}
		}

		public static ListInitExpression ListInit(NewExpression newExpression, params Expression[] initializers)
		{
			if (newExpression == null)
			{
				throw Error.ArgumentNull("newExpression");
			}
			if (initializers == null)
			{
				throw Error.ArgumentNull("initializers");
			}
			return ListInit(newExpression, (IEnumerable<Expression>)initializers);
		}

		public static ListInitExpression ListInit(NewExpression newExpression, IEnumerable<Expression> initializers)
		{
			if (newExpression == null)
			{
				throw Error.ArgumentNull("newExpression");
			}
			if (initializers == null)
			{
				throw Error.ArgumentNull("initializers");
			}
			if (!initializers.Any())
			{
				throw Error.ListInitializerWithZeroMembers();
			}
			MethodInfo addMethod = FindMethod(newExpression.Type, "Add", null, new Expression[1] { initializers.First() }, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			return ListInit(newExpression, addMethod, initializers);
		}

		public static ListInitExpression ListInit(NewExpression newExpression, MethodInfo addMethod, params Expression[] initializers)
		{
			if (newExpression == null)
			{
				throw Error.ArgumentNull("newExpression");
			}
			if (initializers == null)
			{
				throw Error.ArgumentNull("initializers");
			}
			if (addMethod == null)
			{
				return ListInit(newExpression, (IEnumerable<Expression>)initializers);
			}
			return ListInit(newExpression, addMethod, (IEnumerable<Expression>)initializers);
		}

		public static ListInitExpression ListInit(NewExpression newExpression, MethodInfo addMethod, IEnumerable<Expression> initializers)
		{
			if (newExpression == null)
			{
				throw Error.ArgumentNull("newExpression");
			}
			if (initializers == null)
			{
				throw Error.ArgumentNull("initializers");
			}
			if (!initializers.Any())
			{
				throw Error.ListInitializerWithZeroMembers();
			}
			if (addMethod == null)
			{
				return ListInit(newExpression, initializers);
			}
			List<ElementInit> list = new List<ElementInit>();
			foreach (Expression initializer in initializers)
			{
				list.Add(ElementInit(addMethod, initializer));
			}
			return ListInit(newExpression, list);
		}

		public static ListInitExpression ListInit(NewExpression newExpression, params ElementInit[] initializers)
		{
			if (newExpression == null)
			{
				throw Error.ArgumentNull("newExpression");
			}
			if (initializers == null)
			{
				throw Error.ArgumentNull("initializers");
			}
			return ListInit(newExpression, initializers.ToReadOnlyCollection());
		}

		public static ListInitExpression ListInit(NewExpression newExpression, IEnumerable<ElementInit> initializers)
		{
			if (newExpression == null)
			{
				throw Error.ArgumentNull("newExpression");
			}
			if (initializers == null)
			{
				throw Error.ArgumentNull("initializers");
			}
			if (!initializers.Any())
			{
				throw Error.ListInitializerWithZeroMembers();
			}
			ReadOnlyCollection<ElementInit> initializers2 = initializers.ToReadOnlyCollection();
			ValidateListInitArgs(newExpression.Type, initializers2);
			return new ListInitExpression(newExpression, initializers2);
		}

		public static ElementInit ElementInit(MethodInfo addMethod, params Expression[] arguments)
		{
			return ElementInit(addMethod, (IEnumerable<Expression>)arguments);
		}

		public static ElementInit ElementInit(MethodInfo addMethod, IEnumerable<Expression> arguments)
		{
			if (addMethod == null)
			{
				throw Error.ArgumentNull("addMethod");
			}
			if (arguments == null)
			{
				throw Error.ArgumentNull("arguments");
			}
			ValidateElementInitAddMethodInfo(addMethod);
			ReadOnlyCollection<Expression> arguments2 = arguments.ToReadOnlyCollection();
			ValidateArgumentTypes(addMethod, ref arguments2);
			return new ElementInit(addMethod, arguments2);
		}

		public static MemberListBinding ListBind(MemberInfo member, params ElementInit[] initializers)
		{
			if (member == null)
			{
				throw Error.ArgumentNull("member");
			}
			if (initializers == null)
			{
				throw Error.ArgumentNull("initializers");
			}
			return ListBind(member, initializers.ToReadOnlyCollection());
		}

		public static MemberListBinding ListBind(MemberInfo member, IEnumerable<ElementInit> initializers)
		{
			if (member == null)
			{
				throw Error.ArgumentNull("member");
			}
			if (initializers == null)
			{
				throw Error.ArgumentNull("initializers");
			}
			ValidateGettableFieldOrPropertyMember(member, out var memberType);
			ReadOnlyCollection<ElementInit> initializers2 = initializers.ToReadOnlyCollection();
			ValidateListInitArgs(memberType, initializers2);
			return new MemberListBinding(member, initializers2);
		}

		public static MemberListBinding ListBind(MethodInfo propertyAccessor, params ElementInit[] initializers)
		{
			if (propertyAccessor == null)
			{
				throw Error.ArgumentNull("propertyAccessor");
			}
			if (initializers == null)
			{
				throw Error.ArgumentNull("initializers");
			}
			return ListBind(propertyAccessor, initializers.ToReadOnlyCollection());
		}

		public static MemberListBinding ListBind(MethodInfo propertyAccessor, IEnumerable<ElementInit> initializers)
		{
			if (propertyAccessor == null)
			{
				throw Error.ArgumentNull("propertyAccessor");
			}
			if (initializers == null)
			{
				throw Error.ArgumentNull("initializers");
			}
			return ListBind(GetProperty(propertyAccessor), initializers);
		}

		private static void ValidateListInitArgs(Type listType, ReadOnlyCollection<ElementInit> initializers)
		{
			if (!AreAssignable(typeof(IEnumerable), listType))
			{
				throw Error.TypeNotIEnumerable(listType);
			}
			int i = 0;
			for (int count = initializers.Count; i < count; i++)
			{
				ElementInit elementInit = initializers[i];
				if (elementInit == null)
				{
					throw Error.ArgumentNull("initializers");
				}
				ValidateCallInstanceType(listType, elementInit.AddMethod);
			}
		}

		public static MemberInitExpression MemberInit(NewExpression newExpression, params MemberBinding[] bindings)
		{
			if (newExpression == null)
			{
				throw Error.ArgumentNull("newExpression");
			}
			if (bindings == null)
			{
				throw Error.ArgumentNull("bindings");
			}
			return MemberInit(newExpression, bindings.ToReadOnlyCollection());
		}

		public static MemberInitExpression MemberInit(NewExpression newExpression, IEnumerable<MemberBinding> bindings)
		{
			if (newExpression == null)
			{
				throw Error.ArgumentNull("newExpression");
			}
			if (bindings == null)
			{
				throw Error.ArgumentNull("bindings");
			}
			ReadOnlyCollection<MemberBinding> bindings2 = bindings.ToReadOnlyCollection();
			ValidateMemberInitArgs(newExpression.Type, bindings2);
			return new MemberInitExpression(newExpression, bindings2);
		}

		public static MemberMemberBinding MemberBind(MemberInfo member, params MemberBinding[] bindings)
		{
			if (member == null)
			{
				throw Error.ArgumentNull("member");
			}
			if (bindings == null)
			{
				throw Error.ArgumentNull("bindings");
			}
			return MemberBind(member, bindings.ToReadOnlyCollection());
		}

		public static MemberMemberBinding MemberBind(MemberInfo member, IEnumerable<MemberBinding> bindings)
		{
			if (member == null)
			{
				throw Error.ArgumentNull("member");
			}
			if (bindings == null)
			{
				throw Error.ArgumentNull("bindings");
			}
			ReadOnlyCollection<MemberBinding> bindings2 = bindings.ToReadOnlyCollection();
			ValidateGettableFieldOrPropertyMember(member, out var memberType);
			ValidateMemberInitArgs(memberType, bindings2);
			return new MemberMemberBinding(member, bindings2);
		}

		public static MemberMemberBinding MemberBind(MethodInfo propertyAccessor, params MemberBinding[] bindings)
		{
			if (propertyAccessor == null)
			{
				throw Error.ArgumentNull("propertyAccessor");
			}
			return MemberBind(GetProperty(propertyAccessor), bindings);
		}

		public static MemberMemberBinding MemberBind(MethodInfo propertyAccessor, IEnumerable<MemberBinding> bindings)
		{
			if (propertyAccessor == null)
			{
				throw Error.ArgumentNull("propertyAccessor");
			}
			return MemberBind(GetProperty(propertyAccessor), bindings);
		}

		public static BinaryExpression Modulo(Expression left, Expression right)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			if (left.Type == right.Type && IsArithmetic(left.Type))
			{
				return new BinaryExpression(ExpressionType.Modulo, left, right, left.Type);
			}
			return GetUserDefinedBinaryOperatorOrThrow(ExpressionType.Modulo, "op_Modulus", left, right, liftToNull: true);
		}

		public static BinaryExpression Modulo(Expression left, Expression right, MethodInfo method)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			if (method == null)
			{
				return Modulo(left, right);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.Modulo, left, right, method, liftToNull: true);
		}

		public static BinaryExpression Multiply(Expression left, Expression right)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			if (left.Type == right.Type && IsArithmetic(left.Type))
			{
				return new BinaryExpression(ExpressionType.Multiply, left, right, left.Type);
			}
			return GetUserDefinedBinaryOperatorOrThrow(ExpressionType.Multiply, "op_Multiply", left, right, liftToNull: true);
		}

		public static BinaryExpression Multiply(Expression left, Expression right, MethodInfo method)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			if (method == null)
			{
				return Multiply(left, right);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.Multiply, left, right, method, liftToNull: true);
		}

		public static BinaryExpression MultiplyChecked(Expression left, Expression right)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			if (left.Type == right.Type && IsArithmetic(left.Type))
			{
				return new BinaryExpression(ExpressionType.MultiplyChecked, left, right, left.Type);
			}
			return GetUserDefinedBinaryOperatorOrThrow(ExpressionType.MultiplyChecked, "op_Multiply", left, right, liftToNull: true);
		}

		public static BinaryExpression MultiplyChecked(Expression left, Expression right, MethodInfo method)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			if (method == null)
			{
				return MultiplyChecked(left, right);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.MultiplyChecked, left, right, method, liftToNull: true);
		}

		public static UnaryExpression UnaryPlus(Expression expression)
		{
			if (expression == null)
			{
				throw Error.ArgumentNull("expression");
			}
			if (IsArithmetic(expression.Type))
			{
				return new UnaryExpression(ExpressionType.UnaryPlus, expression, expression.Type);
			}
			return GetUserDefinedUnaryOperatorOrThrow(ExpressionType.UnaryPlus, "op_UnaryPlus", expression);
		}

		public static UnaryExpression UnaryPlus(Expression expression, MethodInfo method)
		{
			if (expression == null)
			{
				throw Error.ArgumentNull("expression");
			}
			if (method == null)
			{
				return UnaryPlus(expression);
			}
			return GetMethodBasedUnaryOperator(ExpressionType.UnaryPlus, expression, method);
		}

		public static UnaryExpression Negate(Expression expression)
		{
			if (expression == null)
			{
				throw Error.ArgumentNull("expression");
			}
			if (IsArithmetic(expression.Type) && !IsUnSigned(expression.Type))
			{
				return new UnaryExpression(ExpressionType.Negate, expression, expression.Type);
			}
			return GetUserDefinedUnaryOperatorOrThrow(ExpressionType.Negate, "op_UnaryNegation", expression);
		}

		public static UnaryExpression Negate(Expression expression, MethodInfo method)
		{
			if (expression == null)
			{
				throw Error.ArgumentNull("expression");
			}
			if (method == null)
			{
				return Negate(expression);
			}
			return GetMethodBasedUnaryOperator(ExpressionType.Negate, expression, method);
		}

		public static UnaryExpression NegateChecked(Expression expression)
		{
			if (expression == null)
			{
				throw Error.ArgumentNull("expression");
			}
			if (IsArithmetic(expression.Type) && !IsUnSigned(expression.Type))
			{
				return new UnaryExpression(ExpressionType.NegateChecked, expression, expression.Type);
			}
			return GetUserDefinedUnaryOperatorOrThrow(ExpressionType.NegateChecked, "op_UnaryNegation", expression);
		}

		public static UnaryExpression NegateChecked(Expression expression, MethodInfo method)
		{
			if (expression == null)
			{
				throw Error.ArgumentNull("expression");
			}
			if (method == null)
			{
				return NegateChecked(expression);
			}
			return GetMethodBasedUnaryOperator(ExpressionType.NegateChecked, expression, method);
		}

		public static BinaryExpression NotEqual(Expression left, Expression right)
		{
			return NotEqual(left, right, liftToNull: false, null);
		}

		public static BinaryExpression NotEqual(Expression left, Expression right, bool liftToNull, MethodInfo method)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			if (method == null)
			{
				return GetEqualityComparisonOperator(ExpressionType.NotEqual, "op_Inequality", left, right, liftToNull);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.NotEqual, left, right, method, liftToNull);
		}

		public static NewExpression New(ConstructorInfo constructor, params Expression[] arguments)
		{
			return New(constructor, arguments.ToReadOnlyCollection());
		}

		public static NewExpression New(ConstructorInfo constructor, IEnumerable<Expression> arguments)
		{
			if (constructor == null)
			{
				throw Error.ArgumentNull("constructor");
			}
			ReadOnlyCollection<Expression> arguments2 = arguments.ToReadOnlyCollection();
			ValidateNewArgs(constructor.DeclaringType, constructor, ref arguments2);
			return new NewExpression(constructor.DeclaringType, constructor, arguments2);
		}

		public static NewExpression New(ConstructorInfo constructor, IEnumerable<Expression> arguments, IEnumerable<MemberInfo> members)
		{
			if (constructor == null)
			{
				throw Error.ArgumentNull("constructor");
			}
			ReadOnlyCollection<MemberInfo> members2 = members.ToReadOnlyCollection();
			ReadOnlyCollection<Expression> arguments2 = arguments.ToReadOnlyCollection();
			ValidateNewArgs(constructor, ref arguments2, members2);
			return new NewExpression(constructor.DeclaringType, constructor, arguments2, members2);
		}

		public static NewExpression New(ConstructorInfo constructor, IEnumerable<Expression> arguments, params MemberInfo[] members)
		{
			return New(constructor, arguments, members.ToReadOnlyCollection());
		}

		public static NewExpression New(ConstructorInfo constructor)
		{
			return New(constructor, ((IEnumerable<Expression>)null).ToReadOnlyCollection());
		}

		public static NewExpression New(Type type)
		{
			if (type == null)
			{
				throw Error.ArgumentNull("type");
			}
			if (type == typeof(void))
			{
				throw Error.ArgumentCannotBeOfTypeVoid();
			}
			ConstructorInfo constructorInfo = null;
			if (!type.IsValueType)
			{
				constructorInfo = type.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, Type.EmptyTypes, null);
				if (constructorInfo == null)
				{
					throw Error.TypeMissingDefaultConstructor(type);
				}
				return New(constructorInfo);
			}
			ReadOnlyCollection<Expression> arguments = ((IEnumerable<Expression>)null).ToReadOnlyCollection();
			return new NewExpression(type, null, arguments);
		}

		private static void ValidateNewArgs(ConstructorInfo constructor, ref ReadOnlyCollection<Expression> arguments, ReadOnlyCollection<MemberInfo> members)
		{
			ParameterInfo[] parameters;
			if ((parameters = constructor.GetParameters()).Length > 0)
			{
				if (arguments.Count != parameters.Length)
				{
					throw Error.IncorrectNumberOfConstructorArguments();
				}
				if (arguments.Count != members.Count)
				{
					throw Error.IncorrectNumberOfArgumentsForMembers();
				}
				List<Expression> list = null;
				int i = 0;
				for (int count = arguments.Count; i < count; i++)
				{
					Expression expression = arguments[i];
					if (expression == null)
					{
						throw Error.ArgumentNull("argument");
					}
					MemberInfo memberInfo = members[i];
					if (memberInfo == null)
					{
						throw Error.ArgumentNull("member");
					}
					if (memberInfo.DeclaringType != constructor.DeclaringType)
					{
						throw Error.ArgumentMemberNotDeclOnType(memberInfo.Name, constructor.DeclaringType.Name);
					}
					ValidateAnonymousTypeMember(memberInfo, out var memberType);
					if (!AreReferenceAssignable(expression.Type, memberType))
					{
						if (!IsSameOrSubclass(typeof(Expression), memberType) || !AreAssignable(memberType, expression.GetType()))
						{
							throw Error.ArgumentTypeDoesNotMatchMember(expression.Type, memberType);
						}
						expression = Quote(expression);
					}
					ParameterInfo parameterInfo = parameters[i];
					Type type = parameterInfo.ParameterType;
					if (type.IsByRef)
					{
						type = type.GetElementType();
					}
					if (!AreReferenceAssignable(type, expression.Type))
					{
						if (!IsSameOrSubclass(typeof(Expression), type) || !AreAssignable(type, expression.Type))
						{
							throw Error.ExpressionTypeDoesNotMatchConstructorParameter(expression.Type, type);
						}
						expression = Quote(expression);
					}
					if (list == null && expression != arguments[i])
					{
						list = new List<Expression>(arguments.Count);
						for (int j = 0; j < i; j++)
						{
							list.Add(arguments[j]);
						}
					}
					list?.Add(expression);
				}
				if (list != null)
				{
					arguments = list.ToReadOnlyCollection();
				}
			}
			else
			{
				if (arguments != null && arguments.Count > 0)
				{
					throw Error.IncorrectNumberOfConstructorArguments();
				}
				if (members != null && members.Count > 0)
				{
					throw Error.IncorrectNumberOfMembersForGivenConstructor();
				}
			}
		}

		private static void ValidateNewArgs(Type type, ConstructorInfo constructor, ref ReadOnlyCollection<Expression> arguments)
		{
			if (type == null)
			{
				throw Error.ArgumentNull("type");
			}
			if (!type.IsValueType && constructor == null)
			{
				throw Error.ArgumentNull("constructor");
			}
			ParameterInfo[] parameters;
			if (constructor != null && (parameters = constructor.GetParameters()).Length > 0)
			{
				if (arguments.Count != parameters.Length)
				{
					throw Error.IncorrectNumberOfConstructorArguments();
				}
				List<Expression> list = null;
				int i = 0;
				for (int count = arguments.Count; i < count; i++)
				{
					Expression expression = arguments[i];
					ParameterInfo parameterInfo = parameters[i];
					if (expression == null)
					{
						throw Error.ArgumentNull("arguments");
					}
					Type type2 = parameterInfo.ParameterType;
					if (type2.IsByRef)
					{
						type2 = type2.GetElementType();
					}
					if (!AreReferenceAssignable(type2, expression.Type))
					{
						if (!IsSameOrSubclass(typeof(Expression), type2) || !AreAssignable(type2, expression.GetType()))
						{
							throw Error.ExpressionTypeDoesNotMatchConstructorParameter(expression.Type, type2);
						}
						expression = Quote(expression);
					}
					if (list == null && expression != arguments[i])
					{
						list = new List<Expression>(arguments.Count);
						for (int j = 0; j < i; j++)
						{
							list.Add(arguments[j]);
						}
					}
					list?.Add(expression);
				}
				if (list != null)
				{
					arguments = list.ToReadOnlyCollection();
				}
			}
			else if (arguments != null && arguments.Count > 0)
			{
				throw Error.IncorrectNumberOfConstructorArguments();
			}
		}

		public static NewArrayExpression NewArrayBounds(Type type, params Expression[] bounds)
		{
			if (type == null)
			{
				throw Error.ArgumentNull("type");
			}
			if (bounds == null)
			{
				throw Error.ArgumentNull("bounds");
			}
			if (type.Equals(typeof(void)))
			{
				throw Error.ArgumentCannotBeOfTypeVoid();
			}
			return NewArrayBounds(type, bounds.ToReadOnlyCollection());
		}

		public static NewArrayExpression NewArrayBounds(Type type, IEnumerable<Expression> bounds)
		{
			if (type == null)
			{
				throw Error.ArgumentNull("type");
			}
			if (bounds == null)
			{
				throw Error.ArgumentNull("bounds");
			}
			if (type.Equals(typeof(void)))
			{
				throw Error.ArgumentCannotBeOfTypeVoid();
			}
			ReadOnlyCollection<Expression> readOnlyCollection = bounds.ToReadOnlyCollection();
			int i = 0;
			for (int count = readOnlyCollection.Count; i < count; i++)
			{
				Expression expression = readOnlyCollection[i];
				if (expression == null)
				{
					throw Error.ArgumentNull("bounds");
				}
				ValidateIntegerArg(expression.Type);
			}
			return new NewArrayExpression(ExpressionType.NewArrayBounds, type.MakeArrayType(readOnlyCollection.Count), readOnlyCollection);
		}

		public static NewArrayExpression NewArrayInit(Type type, params Expression[] initializers)
		{
			if (type == null)
			{
				throw Error.ArgumentNull("type");
			}
			if (initializers == null)
			{
				throw Error.ArgumentNull("initializers");
			}
			if (type.Equals(typeof(void)))
			{
				throw Error.ArgumentCannotBeOfTypeVoid();
			}
			return NewArrayInit(type, initializers.ToReadOnlyCollection());
		}

		public static NewArrayExpression NewArrayInit(Type type, IEnumerable<Expression> initializers)
		{
			if (type == null)
			{
				throw Error.ArgumentNull("type");
			}
			if (initializers == null)
			{
				throw Error.ArgumentNull("initializers");
			}
			if (type.Equals(typeof(void)))
			{
				throw Error.ArgumentCannotBeOfTypeVoid();
			}
			ReadOnlyCollection<Expression> readOnlyCollection = initializers.ToReadOnlyCollection();
			List<Expression> list = null;
			int i = 0;
			for (int count = readOnlyCollection.Count; i < count; i++)
			{
				Expression expression = readOnlyCollection[i];
				if (expression == null)
				{
					throw Error.ArgumentNull("initializers");
				}
				if (!AreReferenceAssignable(type, expression.Type))
				{
					if (!IsSameOrSubclass(typeof(Expression), type) || !AreAssignable(type, expression.GetType()))
					{
						throw Error.ExpressionTypeCannotInitializeArrayType(expression.Type, type);
					}
					expression = Quote(expression);
				}
				if (list == null && expression != readOnlyCollection[i])
				{
					list = new List<Expression>(readOnlyCollection.Count);
					for (int j = 0; j < i; j++)
					{
						list.Add(readOnlyCollection[j]);
					}
				}
				list?.Add(expression);
			}
			if (list != null)
			{
				readOnlyCollection = list.ToReadOnlyCollection();
			}
			return new NewArrayExpression(ExpressionType.NewArrayInit, type.MakeArrayType(), readOnlyCollection);
		}

		private static void ValidateSettableFieldOrPropertyMember(MemberInfo member, out Type memberType)
		{
			if (!(member is FieldInfo fieldInfo))
			{
				if (!(member is PropertyInfo propertyInfo))
				{
					throw Error.ArgumentMustBeFieldInfoOrPropertInfo();
				}
				if (!propertyInfo.CanWrite)
				{
					throw Error.PropertyDoesNotHaveSetter(propertyInfo);
				}
				memberType = propertyInfo.PropertyType;
			}
			else
			{
				memberType = fieldInfo.FieldType;
			}
		}

		private static void ValidateAnonymousTypeMember(MemberInfo member, out Type memberType)
		{
			switch (member.MemberType)
			{
			case MemberTypes.Field:
			{
				FieldInfo fieldInfo = member as FieldInfo;
				if (fieldInfo.IsStatic)
				{
					throw Error.ArgumentMustBeInstanceMember();
				}
				memberType = fieldInfo.FieldType;
				break;
			}
			case MemberTypes.Property:
			{
				PropertyInfo propertyInfo = member as PropertyInfo;
				if (!propertyInfo.CanRead)
				{
					throw Error.PropertyDoesNotHaveGetter(propertyInfo);
				}
				if (propertyInfo.GetGetMethod().IsStatic)
				{
					throw Error.ArgumentMustBeInstanceMember();
				}
				memberType = propertyInfo.PropertyType;
				break;
			}
			case MemberTypes.Method:
			{
				MethodInfo methodInfo = member as MethodInfo;
				if (methodInfo.IsStatic)
				{
					throw Error.ArgumentMustBeInstanceMember();
				}
				memberType = methodInfo.ReturnType;
				break;
			}
			default:
				throw Error.ArgumentMustBeFieldInfoOrPropertInfoOrMethod();
			}
		}

		private static void ValidateGettableFieldOrPropertyMember(MemberInfo member, out Type memberType)
		{
			if (!(member is FieldInfo fieldInfo))
			{
				if (!(member is PropertyInfo propertyInfo))
				{
					throw Error.ArgumentMustBeFieldInfoOrPropertInfo();
				}
				if (!propertyInfo.CanRead)
				{
					throw Error.PropertyDoesNotHaveGetter(propertyInfo);
				}
				memberType = propertyInfo.PropertyType;
			}
			else
			{
				memberType = fieldInfo.FieldType;
			}
		}

		private static void ValidateMemberInitArgs(Type type, ReadOnlyCollection<MemberBinding> bindings)
		{
			int i = 0;
			for (int count = bindings.Count; i < count; i++)
			{
				MemberBinding memberBinding = bindings[i];
				if (!AreAssignable(memberBinding.Member.DeclaringType, type))
				{
					throw Error.NotAMemberOfType(memberBinding.Member.Name, type);
				}
			}
		}

		public static UnaryExpression Not(Expression expression)
		{
			if (expression == null)
			{
				throw Error.ArgumentNull("expression");
			}
			if (IsIntegerOrBool(expression.Type))
			{
				return new UnaryExpression(ExpressionType.Not, expression, expression.Type);
			}
			UnaryExpression userDefinedUnaryOperator = GetUserDefinedUnaryOperator(ExpressionType.Not, "op_LogicalNot", expression);
			if (userDefinedUnaryOperator != null)
			{
				return userDefinedUnaryOperator;
			}
			return GetUserDefinedUnaryOperatorOrThrow(ExpressionType.Not, "op_OnesComplement", expression);
		}

		public static UnaryExpression Not(Expression expression, MethodInfo method)
		{
			if (expression == null)
			{
				throw Error.ArgumentNull("expression");
			}
			if (method == null)
			{
				return Not(expression);
			}
			return GetMethodBasedUnaryOperator(ExpressionType.Not, expression, method);
		}

		public static BinaryExpression Or(Expression left, Expression right)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			if (left.Type == right.Type && IsIntegerOrBool(left.Type))
			{
				return new BinaryExpression(ExpressionType.Or, left, right, left.Type);
			}
			return GetUserDefinedBinaryOperatorOrThrow(ExpressionType.Or, "op_BitwiseOr", left, right, liftToNull: true);
		}

		public static BinaryExpression Or(Expression left, Expression right, MethodInfo method)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			if (method == null)
			{
				return Or(left, right);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.Or, left, right, method, liftToNull: true);
		}

		public static BinaryExpression OrElse(Expression left, Expression right)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			if (left.Type == right.Type && IsBool(left.Type))
			{
				return new BinaryExpression(ExpressionType.OrElse, left, right, left.Type);
			}
			MethodInfo userDefinedBinaryOperator = GetUserDefinedBinaryOperator(ExpressionType.OrElse, left.Type, right.Type, "op_BitwiseOr");
			if (userDefinedBinaryOperator != null)
			{
				ValidateUserDefinedConditionalLogicOperator(ExpressionType.OrElse, left.Type, right.Type, userDefinedBinaryOperator);
				Type type = ((IsNullableType(left.Type) && userDefinedBinaryOperator.ReturnType == GetNonNullableType(left.Type)) ? left.Type : userDefinedBinaryOperator.ReturnType);
				return new BinaryExpression(ExpressionType.OrElse, left, right, userDefinedBinaryOperator, type);
			}
			throw Error.BinaryOperatorNotDefined(ExpressionType.OrElse, left.Type, right.Type);
		}

		public static BinaryExpression OrElse(Expression left, Expression right, MethodInfo method)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			if (method == null)
			{
				return OrElse(left, right);
			}
			ValidateUserDefinedConditionalLogicOperator(ExpressionType.OrElse, left.Type, right.Type, method);
			Type type = ((IsNullableType(left.Type) && method.ReturnType == GetNonNullableType(left.Type)) ? left.Type : method.ReturnType);
			return new BinaryExpression(ExpressionType.OrElse, left, right, method, type);
		}

		public static ParameterExpression Parameter(Type type, string name)
		{
			if (type == null)
			{
				throw Error.ArgumentNull("type");
			}
			if (type == typeof(void))
			{
				throw Error.ArgumentCannotBeOfTypeVoid();
			}
			return new ParameterExpression(type, name);
		}

		public static BinaryExpression Power(Expression left, Expression right)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			Type typeFromHandle = typeof(Math);
			MethodInfo method = typeFromHandle.GetMethod("Pow", BindingFlags.Static | BindingFlags.Public);
			if (method == null)
			{
				throw Error.BinaryOperatorNotDefined(ExpressionType.Power, left.Type, right.Type);
			}
			return Power(left, right, method);
		}

		public static BinaryExpression Power(Expression left, Expression right, MethodInfo method)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			if (method == null)
			{
				return Power(left, right);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.Power, left, right, method, liftToNull: true);
		}

		public static MemberExpression Property(Expression expression, PropertyInfo property)
		{
			if (property == null)
			{
				throw Error.ArgumentNull("property");
			}
			if (!property.CanRead)
			{
				throw Error.PropertyDoesNotHaveGetter(property);
			}
			if (!property.GetGetMethod(nonPublic: true).IsStatic)
			{
				if (expression == null)
				{
					throw Error.ArgumentNull("expression");
				}
				if (!AreReferenceAssignable(property.DeclaringType, expression.Type))
				{
					throw Error.PropertyNotDefinedForType(property, expression.Type);
				}
			}
			return new MemberExpression(expression, property, property.PropertyType);
		}

		public static MemberExpression Property(Expression expression, MethodInfo propertyAccessor)
		{
			if (propertyAccessor == null)
			{
				throw Error.ArgumentNull("propertyAccessor");
			}
			ValidateMethodInfo(propertyAccessor);
			return Property(expression, GetProperty(propertyAccessor));
		}

		public static MemberExpression Property(Expression expression, string propertyName)
		{
			if (expression == null)
			{
				throw Error.ArgumentNull("expression");
			}
			PropertyInfo property = expression.Type.GetProperty(propertyName, BindingFlags.IgnoreCase | BindingFlags.Instance | BindingFlags.Public | BindingFlags.FlattenHierarchy);
			if (property == null)
			{
				property = expression.Type.GetProperty(propertyName, BindingFlags.IgnoreCase | BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy);
			}
			if (property == null)
			{
				throw Error.PropertyNotDefinedForType(propertyName, expression.Type);
			}
			return Property(expression, property);
		}

		public static MemberExpression PropertyOrField(Expression expression, string propertyOrFieldName)
		{
			if (expression == null)
			{
				throw Error.ArgumentNull("expression");
			}
			PropertyInfo property = expression.Type.GetProperty(propertyOrFieldName, BindingFlags.IgnoreCase | BindingFlags.Instance | BindingFlags.Public | BindingFlags.FlattenHierarchy);
			if (property != null)
			{
				return Property(expression, property);
			}
			FieldInfo field = expression.Type.GetField(propertyOrFieldName, BindingFlags.IgnoreCase | BindingFlags.Instance | BindingFlags.Public | BindingFlags.FlattenHierarchy);
			if (field != null)
			{
				return Field(expression, field);
			}
			property = expression.Type.GetProperty(propertyOrFieldName, BindingFlags.IgnoreCase | BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy);
			if (property != null)
			{
				return Property(expression, property);
			}
			field = expression.Type.GetField(propertyOrFieldName, BindingFlags.IgnoreCase | BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy);
			if (field != null)
			{
				return Field(expression, field);
			}
			throw Error.NotAMemberOfType(propertyOrFieldName, expression.Type);
		}

		public static UnaryExpression Quote(Expression expression)
		{
			if (expression == null)
			{
				throw Error.ArgumentNull("expression");
			}
			return new UnaryExpression(ExpressionType.Quote, expression, expression.GetType());
		}

		public static BinaryExpression RightShift(Expression left, Expression right)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			if (IsInteger(left.Type) && GetNonNullableType(right.Type) == typeof(int))
			{
				return new BinaryExpression(ExpressionType.RightShift, left, right, left.Type);
			}
			return GetUserDefinedBinaryOperatorOrThrow(ExpressionType.RightShift, "op_RightShift", left, right, liftToNull: true);
		}

		public static BinaryExpression RightShift(Expression left, Expression right, MethodInfo method)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			if (method == null)
			{
				return RightShift(left, right);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.RightShift, left, right, method, liftToNull: true);
		}

		public static BinaryExpression Subtract(Expression left, Expression right)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			if (left.Type == right.Type && IsArithmetic(left.Type))
			{
				return new BinaryExpression(ExpressionType.Subtract, left, right, left.Type);
			}
			return GetUserDefinedBinaryOperatorOrThrow(ExpressionType.Subtract, "op_Subtraction", left, right, liftToNull: true);
		}

		public static BinaryExpression Subtract(Expression left, Expression right, MethodInfo method)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			if (method == null)
			{
				return Subtract(left, right);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.Subtract, left, right, method, liftToNull: true);
		}

		public static BinaryExpression SubtractChecked(Expression left, Expression right)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			if (left.Type == right.Type && IsArithmetic(left.Type))
			{
				return new BinaryExpression(ExpressionType.SubtractChecked, left, right, left.Type);
			}
			return GetUserDefinedBinaryOperatorOrThrow(ExpressionType.SubtractChecked, "op_Subtraction", left, right, liftToNull: true);
		}

		public static BinaryExpression SubtractChecked(Expression left, Expression right, MethodInfo method)
		{
			if (left == null)
			{
				throw Error.ArgumentNull("left");
			}
			if (right == null)
			{
				throw Error.ArgumentNull("right");
			}
			if (method == null)
			{
				return SubtractChecked(left, right);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.SubtractChecked, left, right, method, liftToNull: true);
		}

		public static UnaryExpression TypeAs(Expression expression, Type type)
		{
			if (expression == null)
			{
				throw Error.ArgumentNull("expression");
			}
			if (type == null)
			{
				throw Error.ArgumentNull("type");
			}
			if (type.IsValueType && !IsNullableType(type))
			{
				throw Error.IncorrectTypeForTypeAs(type);
			}
			return new UnaryExpression(ExpressionType.TypeAs, expression, type);
		}

		public static TypeBinaryExpression TypeIs(Expression expression, Type type)
		{
			if (expression == null)
			{
				throw Error.ArgumentNull("expression");
			}
			if (type == null)
			{
				throw Error.ArgumentNull("type");
			}
			return new TypeBinaryExpression(ExpressionType.TypeIs, expression, type, typeof(bool));
		}

		public static UnaryExpression MakeUnary(ExpressionType unaryType, Expression operand, Type type)
		{
			return MakeUnary(unaryType, operand, type, null);
		}

		public static UnaryExpression MakeUnary(ExpressionType unaryType, Expression operand, Type type, MethodInfo method)
		{
			return unaryType switch
			{
				ExpressionType.Negate => Negate(operand, method), 
				ExpressionType.NegateChecked => NegateChecked(operand, method), 
				ExpressionType.Not => Not(operand, method), 
				ExpressionType.ArrayLength => ArrayLength(operand), 
				ExpressionType.Convert => Convert(operand, type, method), 
				ExpressionType.ConvertChecked => ConvertChecked(operand, type, method), 
				ExpressionType.TypeAs => TypeAs(operand, type), 
				ExpressionType.Quote => Quote(operand), 
				_ => throw Error.UnhandledUnary(unaryType), 
			};
		}

		public static BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right)
		{
			return MakeBinary(binaryType, left, right, liftToNull: false, null);
		}

		public static BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right, bool liftToNull, MethodInfo method)
		{
			return MakeBinary(binaryType, left, right, liftToNull, method, null);
		}

		public static BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right, bool liftToNull, MethodInfo method, LambdaExpression conversion)
		{
			return binaryType switch
			{
				ExpressionType.Add => Add(left, right, method), 
				ExpressionType.AddChecked => AddChecked(left, right, method), 
				ExpressionType.Subtract => Subtract(left, right, method), 
				ExpressionType.SubtractChecked => SubtractChecked(left, right, method), 
				ExpressionType.Multiply => Multiply(left, right, method), 
				ExpressionType.MultiplyChecked => MultiplyChecked(left, right, method), 
				ExpressionType.Divide => Divide(left, right, method), 
				ExpressionType.Modulo => Modulo(left, right, method), 
				ExpressionType.Power => Power(left, right, method), 
				ExpressionType.And => And(left, right, method), 
				ExpressionType.AndAlso => AndAlso(left, right), 
				ExpressionType.Or => Or(left, right, method), 
				ExpressionType.OrElse => OrElse(left, right), 
				ExpressionType.LessThan => LessThan(left, right, liftToNull, method), 
				ExpressionType.LessThanOrEqual => LessThanOrEqual(left, right, liftToNull, method), 
				ExpressionType.GreaterThan => GreaterThan(left, right, liftToNull, method), 
				ExpressionType.GreaterThanOrEqual => GreaterThanOrEqual(left, right, liftToNull, method), 
				ExpressionType.Equal => Equal(left, right, liftToNull, method), 
				ExpressionType.NotEqual => NotEqual(left, right, liftToNull, method), 
				ExpressionType.ExclusiveOr => ExclusiveOr(left, right, method), 
				ExpressionType.Coalesce => Coalesce(left, right, conversion), 
				ExpressionType.ArrayIndex => ArrayIndex(left, right), 
				ExpressionType.RightShift => RightShift(left, right, method), 
				ExpressionType.LeftShift => LeftShift(left, right, method), 
				_ => throw Error.UnhandledBinary(binaryType), 
			};
		}

		public static MemberExpression MakeMemberAccess(Expression expression, MemberInfo member)
		{
			if (member == null)
			{
				throw Error.ArgumentNull("member");
			}
			if (member is FieldInfo field)
			{
				return Field(expression, field);
			}
			if (member is PropertyInfo property)
			{
				return Property(expression, property);
			}
			throw Error.MemberNotFieldOrProperty(member);
		}

		private static BinaryExpression GetEqualityComparisonOperator(ExpressionType binaryType, string opName, Expression left, Expression right, bool liftToNull)
		{
			if (left.Type == right.Type && (IsNumeric(left.Type) || left.Type == typeof(object)))
			{
				if (IsNullableType(left.Type) && liftToNull)
				{
					return new BinaryExpression(binaryType, left, right, typeof(bool?));
				}
				return new BinaryExpression(binaryType, left, right, typeof(bool));
			}
			BinaryExpression userDefinedBinaryOperator = GetUserDefinedBinaryOperator(binaryType, opName, left, right, liftToNull);
			if (userDefinedBinaryOperator != null)
			{
				return userDefinedBinaryOperator;
			}
			if (HasBuiltInEqualityOperator(left.Type, right.Type) || IsNullComparison(left, right))
			{
				if (IsNullableType(left.Type) && liftToNull)
				{
					return new BinaryExpression(binaryType, left, right, typeof(bool?));
				}
				return new BinaryExpression(binaryType, left, right, typeof(bool));
			}
			throw Error.BinaryOperatorNotDefined(binaryType, left.Type, right.Type);
		}

		private static bool IsNullComparison(Expression left, Expression right)
		{
			if (!IsNullConstant(left) || IsNullConstant(right) || !IsNullableType(right.Type))
			{
				if (IsNullConstant(right) && !IsNullConstant(left))
				{
					return IsNullableType(left.Type);
				}
				return false;
			}
			return true;
		}

		private static bool HasBuiltInEqualityOperator(Type left, Type right)
		{
			if (left.IsInterface && !right.IsValueType)
			{
				return true;
			}
			if (right.IsInterface && !left.IsValueType)
			{
				return true;
			}
			if (!left.IsValueType && !right.IsValueType && (AreReferenceAssignable(left, right) || AreReferenceAssignable(right, left)))
			{
				return true;
			}
			if (left != right)
			{
				return false;
			}
			Type nonNullableType = GetNonNullableType(left);
			if (nonNullableType == typeof(bool) || IsNumeric(nonNullableType) || nonNullableType.IsEnum)
			{
				return true;
			}
			return false;
		}

		private static BinaryExpression GetComparisonOperator(ExpressionType binaryType, string opName, Expression left, Expression right, bool liftToNull)
		{
			if (left.Type == right.Type && IsNumeric(left.Type))
			{
				if (IsNullableType(left.Type) && liftToNull)
				{
					return new BinaryExpression(binaryType, left, right, typeof(bool?));
				}
				return new BinaryExpression(binaryType, left, right, typeof(bool));
			}
			return GetUserDefinedBinaryOperatorOrThrow(binaryType, opName, left, right, liftToNull);
		}

		private static UnaryExpression GetUserDefinedCoercionOrThrow(ExpressionType coercionType, Expression expression, Type convertToType)
		{
			UnaryExpression userDefinedCoercion = GetUserDefinedCoercion(coercionType, expression, convertToType);
			if (userDefinedCoercion != null)
			{
				return userDefinedCoercion;
			}
			throw Error.CoercionOperatorNotDefined(expression.Type, convertToType);
		}

		private static UnaryExpression GetUserDefinedCoercion(ExpressionType coercionType, Expression expression, Type convertToType)
		{
			Type nonNullableType = GetNonNullableType(expression.Type);
			Type nonNullableType2 = GetNonNullableType(convertToType);
			MethodInfo[] methods = nonNullableType.GetMethods(BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
			MethodInfo methodInfo = FindConversionOperator(methods, expression.Type, convertToType);
			if (methodInfo != null)
			{
				return new UnaryExpression(coercionType, expression, methodInfo, convertToType);
			}
			MethodInfo[] methods2 = nonNullableType2.GetMethods(BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
			methodInfo = FindConversionOperator(methods2, expression.Type, convertToType);
			if (methodInfo != null)
			{
				return new UnaryExpression(coercionType, expression, methodInfo, convertToType);
			}
			if (nonNullableType != expression.Type || nonNullableType2 != convertToType)
			{
				methodInfo = FindConversionOperator(methods, nonNullableType, nonNullableType2);
				if (methodInfo == null)
				{
					methodInfo = FindConversionOperator(methods2, nonNullableType, nonNullableType2);
				}
				if (methodInfo != null)
				{
					return new UnaryExpression(coercionType, expression, methodInfo, convertToType);
				}
			}
			return null;
		}

		private static MethodInfo FindConversionOperator(MethodInfo[] methods, Type typeFrom, Type typeTo)
		{
			foreach (MethodInfo methodInfo in methods)
			{
				if ((!(methodInfo.Name != "op_Implicit") || !(methodInfo.Name != "op_Explicit")) && methodInfo.ReturnType == typeTo)
				{
					ParameterInfo[] parameters = methodInfo.GetParameters();
					if (parameters[0].ParameterType == typeFrom)
					{
						return methodInfo;
					}
				}
			}
			return null;
		}

		private static UnaryExpression GetUserDefinedUnaryOperatorOrThrow(ExpressionType unaryType, string name, Expression operand)
		{
			UnaryExpression userDefinedUnaryOperator = GetUserDefinedUnaryOperator(unaryType, name, operand);
			if (userDefinedUnaryOperator != null)
			{
				ValidateParamswithOperandsOrThrow(userDefinedUnaryOperator.Method.GetParameters()[0].ParameterType, operand.Type, unaryType, name);
				return userDefinedUnaryOperator;
			}
			throw Error.UnaryOperatorNotDefined(unaryType, operand.Type);
		}

		private static UnaryExpression GetUserDefinedUnaryOperator(ExpressionType unaryType, string name, Expression operand)
		{
			Type type = operand.Type;
			Type[] array = new Type[1] { type };
			Type nonNullableType = GetNonNullableType(type);
			MethodInfo method = nonNullableType.GetMethod(name, BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, array, null);
			if (method != null)
			{
				return new UnaryExpression(unaryType, operand, method, method.ReturnType);
			}
			if (IsNullableType(type))
			{
				array[0] = nonNullableType;
				method = nonNullableType.GetMethod(name, BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, array, null);
				if (method != null && method.ReturnType.IsValueType && !IsNullableType(method.ReturnType))
				{
					return new UnaryExpression(unaryType, operand, method, GetNullableType(method.ReturnType));
				}
			}
			return null;
		}

		private static void ValidateParamswithOperandsOrThrow(Type paramType, Type operandType, ExpressionType exprType, string name)
		{
			if (IsNullableType(paramType) && !IsNullableType(operandType))
			{
				throw Error.OperandTypesDoNotMatchParameters(exprType, name);
			}
		}

		private static BinaryExpression GetUserDefinedBinaryOperatorOrThrow(ExpressionType binaryType, string name, Expression left, Expression right, bool liftToNull)
		{
			BinaryExpression userDefinedBinaryOperator = GetUserDefinedBinaryOperator(binaryType, name, left, right, liftToNull);
			if (userDefinedBinaryOperator != null)
			{
				ValidateParamswithOperandsOrThrow(userDefinedBinaryOperator.Method.GetParameters()[0].ParameterType, left.Type, binaryType, name);
				ValidateParamswithOperandsOrThrow(userDefinedBinaryOperator.Method.GetParameters()[1].ParameterType, right.Type, binaryType, name);
				return userDefinedBinaryOperator;
			}
			throw Error.BinaryOperatorNotDefined(binaryType, left.Type, right.Type);
		}

		private static MethodInfo GetUserDefinedBinaryOperator(ExpressionType binaryType, Type leftType, Type rightType, string name)
		{
			Type[] types = new Type[2] { leftType, rightType };
			Type nonNullableType = GetNonNullableType(leftType);
			Type nonNullableType2 = GetNonNullableType(rightType);
			BindingFlags bindingAttr = BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic;
			MethodInfo methodInfo = nonNullableType.GetMethod(name, bindingAttr, null, types, null);
			if (methodInfo == null)
			{
				methodInfo = nonNullableType2.GetMethod(name, bindingAttr, null, types, null);
			}
			if (IsLiftingConditionalLogicalOperator(leftType, rightType, methodInfo, binaryType))
			{
				methodInfo = GetUserDefinedBinaryOperator(binaryType, nonNullableType, nonNullableType2, name);
			}
			return methodInfo;
		}

		private static bool IsLiftingConditionalLogicalOperator(Type left, Type right, MethodInfo method, ExpressionType binaryType)
		{
			if (IsNullableType(right) && IsNullableType(left) && method == null)
			{
				if (binaryType != ExpressionType.AndAlso)
				{
					return binaryType == ExpressionType.OrElse;
				}
				return true;
			}
			return false;
		}

		private static BinaryExpression GetUserDefinedBinaryOperator(ExpressionType binaryType, string name, Expression left, Expression right, bool liftToNull)
		{
			MethodInfo userDefinedBinaryOperator = GetUserDefinedBinaryOperator(binaryType, left.Type, right.Type, name);
			if (userDefinedBinaryOperator != null)
			{
				return new BinaryExpression(binaryType, left, right, userDefinedBinaryOperator, userDefinedBinaryOperator.ReturnType);
			}
			if (IsNullableType(left.Type) && IsNullableType(right.Type))
			{
				Type nonNullableType = GetNonNullableType(left.Type);
				Type nonNullableType2 = GetNonNullableType(right.Type);
				userDefinedBinaryOperator = GetUserDefinedBinaryOperator(binaryType, nonNullableType, nonNullableType2, name);
				if (userDefinedBinaryOperator != null && userDefinedBinaryOperator.ReturnType.IsValueType && !IsNullableType(userDefinedBinaryOperator.ReturnType))
				{
					if (userDefinedBinaryOperator.ReturnType != typeof(bool) || liftToNull)
					{
						return new BinaryExpression(binaryType, left, right, userDefinedBinaryOperator, GetNullableType(userDefinedBinaryOperator.ReturnType));
					}
					return new BinaryExpression(binaryType, left, right, userDefinedBinaryOperator, typeof(bool));
				}
			}
			return null;
		}

		private static void ValidateOperator(MethodInfo method)
		{
			ValidateMethodInfo(method);
			if (!method.IsStatic)
			{
				throw Error.UserDefinedOperatorMustBeStatic(method);
			}
			if (method.ReturnType == typeof(void))
			{
				throw Error.UserDefinedOperatorMustNotBeVoid(method);
			}
		}

		private static void ValidateUserDefinedConditionalLogicOperator(ExpressionType nodeType, Type left, Type right, MethodInfo method)
		{
			ValidateOperator(method);
			ParameterInfo[] parameters = method.GetParameters();
			if (parameters.Length != 2)
			{
				throw Error.IncorrectNumberOfMethodCallArguments(method);
			}
			if (!ParameterIsAssignable(parameters[0], left) && (!IsNullableType(left) || !ParameterIsAssignable(parameters[0], GetNonNullableType(left))))
			{
				throw Error.OperandTypesDoNotMatchParameters(nodeType, method.Name);
			}
			if (!ParameterIsAssignable(parameters[1], right) && (!IsNullableType(right) || !ParameterIsAssignable(parameters[1], GetNonNullableType(right))))
			{
				throw Error.OperandTypesDoNotMatchParameters(nodeType, method.Name);
			}
			if (parameters[0].ParameterType != parameters[1].ParameterType)
			{
				throw Error.LogicalOperatorMustHaveConsistentTypes(nodeType, method.Name);
			}
			if (method.ReturnType != parameters[0].ParameterType)
			{
				throw Error.LogicalOperatorMustHaveConsistentTypes(nodeType, method.Name);
			}
			if (IsValidLiftedConditionalLogicalOperator(left, right, parameters))
			{
				left = GetNonNullableType(left);
				right = GetNonNullableType(left);
			}
			Type[] types = new Type[1] { parameters[0].ParameterType };
			MethodInfo method2 = method.DeclaringType.GetMethod("op_True", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, types, null);
			MethodInfo method3 = method.DeclaringType.GetMethod("op_False", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, types, null);
			if (method2 == null || method3 == null)
			{
				throw Error.LogicalOperatorMustHaveBooleanOperators(nodeType, method.Name);
			}
			if (method2.ReturnType != typeof(bool))
			{
				throw Error.LogicalOperatorMustHaveBooleanOperators(nodeType, method.Name);
			}
			if (method3.ReturnType != typeof(bool))
			{
				throw Error.LogicalOperatorMustHaveBooleanOperators(nodeType, method.Name);
			}
		}

		private static bool IsValidLiftedConditionalLogicalOperator(Type left, Type right, ParameterInfo[] pms)
		{
			if (left == right && IsNullableType(right))
			{
				return pms[1].ParameterType == GetNonNullableType(right);
			}
			return false;
		}

		private static UnaryExpression GetMethodBasedCoercionOperator(ExpressionType unaryType, Expression operand, Type convertToType, MethodInfo method)
		{
			ValidateOperator(method);
			ParameterInfo[] parameters = method.GetParameters();
			if (parameters.Length != 1)
			{
				throw Error.IncorrectNumberOfMethodCallArguments(method);
			}
			if (ParameterIsAssignable(parameters[0], operand.Type) && method.ReturnType == convertToType)
			{
				return new UnaryExpression(unaryType, operand, method, method.ReturnType);
			}
			if ((IsNullableType(operand.Type) || IsNullableType(convertToType)) && ParameterIsAssignable(parameters[0], GetNonNullableType(operand.Type)) && method.ReturnType == GetNonNullableType(convertToType))
			{
				return new UnaryExpression(unaryType, operand, method, convertToType);
			}
			throw Error.OperandTypesDoNotMatchParameters(unaryType, method.Name);
		}

		private static UnaryExpression GetMethodBasedUnaryOperator(ExpressionType unaryType, Expression operand, MethodInfo method)
		{
			ValidateOperator(method);
			ParameterInfo[] parameters = method.GetParameters();
			if (parameters.Length != 1)
			{
				throw Error.IncorrectNumberOfMethodCallArguments(method);
			}
			if (ParameterIsAssignable(parameters[0], operand.Type))
			{
				ValidateParamswithOperandsOrThrow(parameters[0].ParameterType, operand.Type, unaryType, method.Name);
				return new UnaryExpression(unaryType, operand, method, method.ReturnType);
			}
			if (IsNullableType(operand.Type) && ParameterIsAssignable(parameters[0], GetNonNullableType(operand.Type)) && method.ReturnType.IsValueType && !IsNullableType(method.ReturnType))
			{
				return new UnaryExpression(unaryType, operand, method, GetNullableType(method.ReturnType));
			}
			throw Error.OperandTypesDoNotMatchParameters(unaryType, method.Name);
		}

		private static BinaryExpression GetMethodBasedBinaryOperator(ExpressionType binaryType, Expression left, Expression right, MethodInfo method, bool liftToNull)
		{
			ValidateOperator(method);
			ParameterInfo[] parameters = method.GetParameters();
			if (parameters.Length != 2)
			{
				throw Error.IncorrectNumberOfMethodCallArguments(method);
			}
			if (ParameterIsAssignable(parameters[0], left.Type) && ParameterIsAssignable(parameters[1], right.Type))
			{
				ValidateParamswithOperandsOrThrow(parameters[0].ParameterType, left.Type, binaryType, method.Name);
				ValidateParamswithOperandsOrThrow(parameters[1].ParameterType, right.Type, binaryType, method.Name);
				return new BinaryExpression(binaryType, left, right, method, method.ReturnType);
			}
			if (IsNullableType(left.Type) && IsNullableType(right.Type) && ParameterIsAssignable(parameters[0], GetNonNullableType(left.Type)) && ParameterIsAssignable(parameters[1], GetNonNullableType(right.Type)) && method.ReturnType.IsValueType && !IsNullableType(method.ReturnType))
			{
				if (method.ReturnType != typeof(bool) || liftToNull)
				{
					return new BinaryExpression(binaryType, left, right, method, GetNullableType(method.ReturnType));
				}
				return new BinaryExpression(binaryType, left, right, method, typeof(bool));
			}
			throw Error.OperandTypesDoNotMatchParameters(binaryType, method.Name);
		}

		private static bool ParameterIsAssignable(ParameterInfo pi, Type argType)
		{
			Type type = pi.ParameterType;
			if (type.IsByRef)
			{
				type = type.GetElementType();
			}
			return AreReferenceAssignable(type, argType);
		}

		private static void ValidateIntegerArg(Type type)
		{
			if (!IsInteger(type))
			{
				throw Error.ArgumentMustBeInteger();
			}
		}

		private static void ValidateIntegerOrBoolArg(Type type)
		{
			if (!IsIntegerOrBool(type))
			{
				throw Error.ArgumentMustBeIntegerOrBoolean();
			}
		}

		private static void ValidateNumericArg(Type type)
		{
			if (!IsNumeric(type))
			{
				throw Error.ArgumentMustBeNumeric();
			}
		}

		private static void ValidateConvertibleArg(Type type)
		{
			if (!IsConvertible(type))
			{
				throw Error.ArgumentMustBeConvertible();
			}
		}

		private static void ValidateBoolArg(Type type)
		{
			if (!IsBool(type))
			{
				throw Error.ArgumentMustBeBoolean();
			}
		}

		private static Type ValidateCoalesceArgTypes(Type left, Type right)
		{
			Type nonNullableType = GetNonNullableType(left);
			if (left.IsValueType && !IsNullableType(left))
			{
				throw Error.CoalesceUsedOnNonNullType();
			}
			if (IsNullableType(left) && IsImplicitlyConvertible(right, nonNullableType))
			{
				return nonNullableType;
			}
			if (IsImplicitlyConvertible(right, left))
			{
				return left;
			}
			if (IsImplicitlyConvertible(nonNullableType, right))
			{
				return right;
			}
			throw Error.ArgumentTypesMustMatch();
		}

		private static void ValidateSameArgTypes(Type left, Type right)
		{
			if (left != right)
			{
				throw Error.ArgumentTypesMustMatch();
			}
		}

		private static void ValidateElementInitAddMethodInfo(MethodInfo addMethod)
		{
			ValidateMethodInfo(addMethod);
			if (addMethod.GetParameters().Length == 0)
			{
				throw Error.ElementInitializerMethodWithZeroArgs();
			}
			if (!addMethod.Name.Equals("Add", StringComparison.OrdinalIgnoreCase))
			{
				throw Error.ElementInitializerMethodNotAdd();
			}
			if (addMethod.IsStatic)
			{
				throw Error.ElementInitializerMethodStatic();
			}
			ParameterInfo[] parameters = addMethod.GetParameters();
			foreach (ParameterInfo parameterInfo in parameters)
			{
				if (parameterInfo.ParameterType.IsByRef)
				{
					throw Error.ElementInitializerMethodNoRefOutParam(parameterInfo.Name, addMethod.Name);
				}
			}
		}

		private static void ValidateMethodInfo(MethodInfo method)
		{
			if (method.IsGenericMethodDefinition)
			{
				throw Error.MethodIsGeneric(method);
			}
			if (method.ContainsGenericParameters)
			{
				throw Error.MethodContainsGenericParameters(method);
			}
		}

		private static void ValidateType(Type type)
		{
			if (type.IsGenericTypeDefinition)
			{
				throw Error.TypeIsGeneric(type);
			}
			if (type.ContainsGenericParameters)
			{
				throw Error.TypeContainsGenericParameters(type);
			}
		}

		internal static Type GetNullableType(Type type)
		{
			if (type == null)
			{
				throw Error.ArgumentNull("type");
			}
			if (type.IsValueType && !IsNullableType(type))
			{
				return typeof(Nullable<>).MakeGenericType(type);
			}
			return type;
		}

		private static bool IsSameOrSubclass(Type type, Type subType)
		{
			if (type != subType)
			{
				return subType.IsSubclassOf(type);
			}
			return true;
		}

		private static bool AreReferenceAssignable(Type dest, Type src)
		{
			if (dest == src)
			{
				return true;
			}
			if (!dest.IsValueType && !src.IsValueType && AreAssignable(dest, src))
			{
				return true;
			}
			return false;
		}

		private static bool AreAssignable(Type dest, Type src)
		{
			if (dest == src)
			{
				return true;
			}
			if (dest.IsAssignableFrom(src))
			{
				return true;
			}
			if (dest.IsArray && src.IsArray && dest.GetArrayRank() == src.GetArrayRank() && AreReferenceAssignable(dest.GetElementType(), src.GetElementType()))
			{
				return true;
			}
			if (src.IsArray && dest.IsGenericType && (dest.GetGenericTypeDefinition() == typeof(IEnumerable<>) || dest.GetGenericTypeDefinition() == typeof(IList<>) || dest.GetGenericTypeDefinition() == typeof(ICollection<>)) && dest.GetGenericArguments()[0] == src.GetElementType())
			{
				return true;
			}
			return false;
		}

		internal static bool IsNullableType(Type type)
		{
			if (type.IsGenericType)
			{
				return type.GetGenericTypeDefinition() == typeof(Nullable<>);
			}
			return false;
		}

		internal static Type GetNonNullableType(Type type)
		{
			if (IsNullableType(type))
			{
				type = type.GetGenericArguments()[0];
			}
			return type;
		}

		private static bool IsNullConstant(Expression expr)
		{
			if (!(expr is ConstantExpression constantExpression))
			{
				return false;
			}
			return constantExpression.Value == null;
		}

		private static bool IsUnSigned(Type type)
		{
			type = GetNonNullableType(type);
			if (type.IsEnum)
			{
				return false;
			}
			switch (Type.GetTypeCode(type))
			{
			case TypeCode.UInt16:
			case TypeCode.UInt32:
			case TypeCode.UInt64:
				return true;
			default:
				return false;
			}
		}

		private static bool IsArithmetic(Type type)
		{
			type = GetNonNullableType(type);
			if (type.IsEnum)
			{
				return false;
			}
			switch (Type.GetTypeCode(type))
			{
			case TypeCode.Int16:
			case TypeCode.UInt16:
			case TypeCode.Int32:
			case TypeCode.UInt32:
			case TypeCode.Int64:
			case TypeCode.UInt64:
			case TypeCode.Single:
			case TypeCode.Double:
				return true;
			default:
				return false;
			}
		}

		private static bool IsNumeric(Type type)
		{
			type = GetNonNullableType(type);
			if (type.IsEnum)
			{
				return false;
			}
			switch (Type.GetTypeCode(type))
			{
			case TypeCode.Char:
			case TypeCode.SByte:
			case TypeCode.Byte:
			case TypeCode.Int16:
			case TypeCode.UInt16:
			case TypeCode.Int32:
			case TypeCode.UInt32:
			case TypeCode.Int64:
			case TypeCode.UInt64:
			case TypeCode.Single:
			case TypeCode.Double:
				return true;
			default:
				return false;
			}
		}

		private static bool IsImplicitlyConvertible(Type source, Type destination)
		{
			if (!IsIdentityConversion(source, destination) && !IsImplicitNumericConversion(source, destination) && !IsImplicitReferenceConversion(source, destination) && !IsImplicitBoxingConversion(source, destination))
			{
				return IsImplicitNullableConversion(source, destination);
			}
			return true;
		}

		private static bool IsIdentityConversion(Type source, Type destination)
		{
			return source == destination;
		}

		private static bool IsImplicitNumericConversion(Type source, Type destination)
		{
			TypeCode typeCode = Type.GetTypeCode(source);
			TypeCode typeCode2 = Type.GetTypeCode(destination);
			switch (typeCode)
			{
			case TypeCode.SByte:
				switch (typeCode2)
				{
				case TypeCode.Int16:
				case TypeCode.Int32:
				case TypeCode.Int64:
				case TypeCode.Single:
				case TypeCode.Double:
				case TypeCode.Decimal:
					return true;
				default:
					return false;
				}
			case TypeCode.Byte:
				switch (typeCode2)
				{
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
				case TypeCode.UInt32:
				case TypeCode.Int64:
				case TypeCode.UInt64:
				case TypeCode.Single:
				case TypeCode.Double:
				case TypeCode.Decimal:
					return true;
				default:
					return false;
				}
			case TypeCode.Int16:
				switch (typeCode2)
				{
				case TypeCode.Int32:
				case TypeCode.Int64:
				case TypeCode.Single:
				case TypeCode.Double:
				case TypeCode.Decimal:
					return true;
				default:
					return false;
				}
			case TypeCode.UInt16:
				switch (typeCode2)
				{
				case TypeCode.Int32:
				case TypeCode.UInt32:
				case TypeCode.Int64:
				case TypeCode.UInt64:
				case TypeCode.Single:
				case TypeCode.Double:
				case TypeCode.Decimal:
					return true;
				default:
					return false;
				}
			case TypeCode.Int32:
				switch (typeCode2)
				{
				case TypeCode.Int64:
				case TypeCode.Single:
				case TypeCode.Double:
				case TypeCode.Decimal:
					return true;
				default:
					return false;
				}
			case TypeCode.UInt32:
				switch (typeCode2)
				{
				case TypeCode.UInt32:
				case TypeCode.UInt64:
				case TypeCode.Single:
				case TypeCode.Double:
				case TypeCode.Decimal:
					return true;
				default:
					return false;
				}
			case TypeCode.Int64:
			case TypeCode.UInt64:
				switch (typeCode2)
				{
				case TypeCode.Single:
				case TypeCode.Double:
				case TypeCode.Decimal:
					return true;
				default:
					return false;
				}
			case TypeCode.Char:
				switch (typeCode2)
				{
				case TypeCode.UInt16:
				case TypeCode.Int32:
				case TypeCode.UInt32:
				case TypeCode.Int64:
				case TypeCode.UInt64:
				case TypeCode.Single:
				case TypeCode.Double:
				case TypeCode.Decimal:
					return true;
				default:
					return false;
				}
			case TypeCode.Single:
				return typeCode2 == TypeCode.Double;
			default:
				return false;
			}
		}

		private static bool IsImplicitReferenceConversion(Type source, Type destination)
		{
			return AreAssignable(destination, source);
		}

		private static bool IsImplicitBoxingConversion(Type source, Type destination)
		{
			if (source.IsValueType && (destination == typeof(object) || destination == typeof(ValueType)))
			{
				return true;
			}
			if (source.IsEnum && destination == typeof(Enum))
			{
				return true;
			}
			return false;
		}

		private static bool IsImplicitNullableConversion(Type source, Type destination)
		{
			if (IsNullableType(destination))
			{
				return IsImplicitlyConvertible(GetNonNullableType(source), GetNonNullableType(destination));
			}
			return false;
		}

		private static bool IsConvertible(Type type)
		{
			type = GetNonNullableType(type);
			if (type.IsEnum)
			{
				return true;
			}
			switch (Type.GetTypeCode(type))
			{
			case TypeCode.Boolean:
			case TypeCode.Char:
			case TypeCode.SByte:
			case TypeCode.Byte:
			case TypeCode.Int16:
			case TypeCode.UInt16:
			case TypeCode.Int32:
			case TypeCode.UInt32:
			case TypeCode.Int64:
			case TypeCode.UInt64:
			case TypeCode.Single:
			case TypeCode.Double:
				return true;
			default:
				return false;
			}
		}

		private static bool IsInteger(Type type)
		{
			type = GetNonNullableType(type);
			if (type.IsEnum)
			{
				return false;
			}
			switch (Type.GetTypeCode(type))
			{
			case TypeCode.SByte:
			case TypeCode.Byte:
			case TypeCode.Int16:
			case TypeCode.UInt16:
			case TypeCode.Int32:
			case TypeCode.UInt32:
			case TypeCode.Int64:
			case TypeCode.UInt64:
				return true;
			default:
				return false;
			}
		}

		private static bool IsIntegerOrBool(Type type)
		{
			type = GetNonNullableType(type);
			if (type.IsEnum)
			{
				return false;
			}
			switch (Type.GetTypeCode(type))
			{
			case TypeCode.Boolean:
			case TypeCode.SByte:
			case TypeCode.Byte:
			case TypeCode.Int16:
			case TypeCode.UInt16:
			case TypeCode.Int32:
			case TypeCode.UInt32:
			case TypeCode.Int64:
			case TypeCode.UInt64:
				return true;
			default:
				return false;
			}
		}

		private static bool IsBool(Type type)
		{
			type = GetNonNullableType(type);
			return type == typeof(bool);
		}
	}
	public sealed class BinaryExpression : Expression
	{
		private Expression left;

		private Expression right;

		private MethodInfo method;

		private LambdaExpression conversion;

		public Expression Left => left;

		public Expression Right => right;

		public MethodInfo Method => method;

		public LambdaExpression Conversion => conversion;

		public bool IsLifted
		{
			get
			{
				if (base.NodeType == ExpressionType.Coalesce)
				{
					return false;
				}
				bool flag = Expression.IsNullableType(left.Type);
				if (method != null)
				{
					if (flag)
					{
						return method.GetParameters()[0].ParameterType != left.Type;
					}
					return false;
				}
				return flag;
			}
		}

		public bool IsLiftedToNull
		{
			get
			{
				if (IsLifted)
				{
					return Expression.IsNullableType(base.Type);
				}
				return false;
			}
		}

		internal BinaryExpression(ExpressionType nt, Expression left, Expression right, Type type)
			: this(nt, left, right, null, null, type)
		{
		}

		internal BinaryExpression(ExpressionType nt, Expression left, Expression right, MethodInfo method, Type type)
			: this(nt, left, right, method, null, type)
		{
		}

		internal BinaryExpression(ExpressionType nt, Expression left, Expression right, LambdaExpression conversion, Type type)
			: this(nt, left, right, null, conversion, type)
		{
		}

		internal BinaryExpression(ExpressionType nt, Expression left, Expression right, MethodInfo method, LambdaExpression conversion, Type type)
			: base(nt, type)
		{
			this.left = left;
			this.right = right;
			this.method = method;
			this.conversion = conversion;
		}

		internal override void BuildString(StringBuilder builder)
		{
			if (builder == null)
			{
				throw Error.ArgumentNull("builder");
			}
			ExpressionType expressionType = base.NodeType;
			if (expressionType == ExpressionType.ArrayIndex)
			{
				left.BuildString(builder);
				builder.Append("[");
				right.BuildString(builder);
				builder.Append("]");
				return;
			}
			string @operator = GetOperator();
			if (@operator != null)
			{
				builder.Append("(");
				left.BuildString(builder);
				builder.Append(" ");
				builder.Append(@operator);
				builder.Append(" ");
				right.BuildString(builder);
				builder.Append(")");
			}
			else
			{
				builder.Append(base.NodeType);
				builder.Append("(");
				left.BuildString(builder);
				builder.Append(", ");
				right.BuildString(builder);
				builder.Append(")");
			}
		}

		private string GetOperator()
		{
			switch (base.NodeType)
			{
			case ExpressionType.Add:
			case ExpressionType.AddChecked:
				return "+";
			case ExpressionType.Subtract:
			case ExpressionType.SubtractChecked:
				return "-";
			case ExpressionType.Multiply:
			case ExpressionType.MultiplyChecked:
				return "*";
			case ExpressionType.Divide:
				return "/";
			case ExpressionType.Modulo:
				return "%";
			case ExpressionType.Power:
				return "^";
			case ExpressionType.And:
				if (base.Type == typeof(bool) || base.Type == typeof(bool?))
				{
					return "And";
				}
				return "&";
			case ExpressionType.AndAlso:
				return "&&";
			case ExpressionType.Or:
				if (base.Type == typeof(bool) || base.Type == typeof(bool?))
				{
					return "Or";
				}
				return "|";
			case ExpressionType.OrElse:
				return "||";
			case ExpressionType.LessThan:
				return "<";
			case ExpressionType.LessThanOrEqual:
				return "<=";
			case ExpressionType.GreaterThan:
				return ">";
			case ExpressionType.GreaterThanOrEqual:
				return ">=";
			case ExpressionType.Equal:
				return "=";
			case ExpressionType.NotEqual:
				return "!=";
			case ExpressionType.Coalesce:
				return "??";
			case ExpressionType.RightShift:
				return ">>";
			case ExpressionType.LeftShift:
				return "<<";
			case ExpressionType.ExclusiveOr:
				return "^";
			default:
				return null;
			}
		}
	}
	public sealed class ConditionalExpression : Expression
	{
		private Expression test;

		private Expression ifTrue;

		private Expression ifFalse;

		public Expression Test => test;

		public Expression IfTrue => ifTrue;

		public Expression IfFalse => ifFalse;

		internal ConditionalExpression(Expression test, Expression ifTrue, Expression ifFalse, Type type)
			: base(ExpressionType.Conditional, type)
		{
			this.test = test;
			this.ifTrue = ifTrue;
			this.ifFalse = ifFalse;
		}

		internal override void BuildString(StringBuilder builder)
		{
			if (builder == null)
			{
				throw Error.ArgumentNull("builder");
			}
			builder.Append("IIF(");
			test.BuildString(builder);
			builder.Append(", ");
			ifTrue.BuildString(builder);
			builder.Append(", ");
			ifFalse.BuildString(builder);
			builder.Append(")");
		}
	}
	public enum MemberBindingType
	{
		Assignment,
		MemberBinding,
		ListBinding
	}
	public abstract class MemberBinding
	{
		private MemberBindingType type;

		private MemberInfo member;

		public MemberBindingType BindingType => type;

		public MemberInfo Member => member;

		protected MemberBinding(MemberBindingType type, MemberInfo member)
		{
			this.type = type;
			this.member = member;
		}

		internal abstract void BuildString(StringBuilder builder);

		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder();
			BuildString(stringBuilder);
			return stringBuilder.ToString();
		}
	}
	public sealed class MemberAssignment : MemberBinding
	{
		private Expression expression;

		public Expression Expression => expression;

		internal MemberAssignment(MemberInfo member, Expression expression)
			: base(MemberBindingType.Assignment, member)
		{
			this.expression = expression;
		}

		internal override void BuildString(StringBuilder builder)
		{
			if (builder == null)
			{
				throw Error.ArgumentNull("builder");
			}
			builder.Append(base.Member.Name);
			builder.Append(" = ");
			expression.BuildString(builder);
		}
	}
	public sealed class MemberMemberBinding : MemberBinding
	{
		private ReadOnlyCollection<MemberBinding> bindings;

		public ReadOnlyCollection<MemberBinding> Bindings => bindings;

		internal MemberMemberBinding(MemberInfo member, ReadOnlyCollection<MemberBinding> bindings)
			: base(MemberBindingType.MemberBinding, member)
		{
			this.bindings = bindings;
		}

		internal override void BuildString(StringBuilder builder)
		{
			builder.Append(base.Member.Name);
			builder.Append(" = {");
			int i = 0;
			for (int count = bindings.Count; i < count; i++)
			{
				if (i > 0)
				{
					builder.Append(", ");
				}
				bindings[i].BuildString(builder);
			}
			builder.Append("}");
		}
	}
	public sealed class MemberListBinding : MemberBinding
	{
		private ReadOnlyCollection<ElementInit> initializers;

		public ReadOnlyCollection<ElementInit> Initializers => initializers;

		internal MemberListBinding(MemberInfo member, ReadOnlyCollection<ElementInit> initializers)
			: base(MemberBindingType.ListBinding, member)
		{
			this.initializers = initializers;
		}

		internal override void BuildString(StringBuilder builder)
		{
			builder.Append(base.Member.Name);
			builder.Append(" = {");
			int i = 0;
			for (int count = initializers.Count; i < count; i++)
			{
				if (i > 0)
				{
					builder.Append(", ");
				}
				initializers[i].BuildString(builder);
			}
			builder.Append("}");
		}
	}
	public sealed class ElementInit
	{
		private MethodInfo addMethod;

		private ReadOnlyCollection<Expression> arguments;

		public MethodInfo AddMethod => addMethod;

		public ReadOnlyCollection<Expression> Arguments => arguments;

		internal ElementInit(MethodInfo addMethod, ReadOnlyCollection<Expression> arguments)
		{
			this.addMethod = addMethod;
			this.arguments = arguments;
		}

		internal void BuildString(StringBuilder builder)
		{
			builder.Append(AddMethod);
			builder.Append("(");
			bool flag = true;
			foreach (Expression argument in arguments)
			{
				if (flag)
				{
					flag = false;
				}
				else
				{
					builder.Append(",");
				}
				argument.BuildString(builder);
			}
			builder.Append(")");
		}

		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder();
			BuildString(stringBuilder);
			return stringBuilder.ToString();
		}
	}
	public sealed class ConstantExpression : Expression
	{
		private object value;

		public object Value => value;

		internal ConstantExpression(object value, Type type)
			: base(ExpressionType.Constant, type)
		{
			this.value = value;
		}

		internal override void BuildString(StringBuilder builder)
		{
			if (builder == null)
			{
				throw Error.ArgumentNull("builder");
			}
			if (value != null)
			{
				if (value is string)
				{
					builder.Append("\"");
					builder.Append(value);
					builder.Append("\"");
				}
				else if (value.ToString() == value.GetType().ToString())
				{
					builder.Append("value(");
					builder.Append(value);
					builder.Append(")");
				}
				else
				{
					builder.Append(value);
				}
			}
			else
			{
				builder.Append("null");
			}
		}
	}
	public sealed class InvocationExpression : Expression
	{
		private ReadOnlyCollection<Expression> arguments;

		private Expression lambda;

		public Expression Expression => lambda;

		public ReadOnlyCollection<Expression> Arguments => arguments;

		internal InvocationExpression(Expression lambda, Type returnType, ReadOnlyCollection<Expression> arguments)
			: base(ExpressionType.Invoke, returnType)
		{
			this.lambda = lambda;
			this.arguments = arguments;
		}

		internal override void BuildString(StringBuilder builder)
		{
			builder.Append("Invoke(");
			lambda.BuildString(builder);
			int i = 0;
			for (int count = arguments.Count; i < count; i++)
			{
				builder.Append(",");
				arguments[i].BuildString(builder);
			}
			builder.Append(")");
		}
	}
	public class LambdaExpression : Expression
	{
		private ReadOnlyCollection<ParameterExpression> parameters;

		private Expression body;

		public Expression Body => body;

		public ReadOnlyCollection<ParameterExpression> Parameters => parameters;

		internal LambdaExpression(Expression body, Type type, ReadOnlyCollection<ParameterExpression> parameters)
			: base(ExpressionType.Lambda, type)
		{
			this.body = body;
			this.parameters = parameters;
		}

		internal override void BuildString(StringBuilder builder)
		{
			if (Parameters.Count == 1)
			{
				Parameters[0].BuildString(builder);
			}
			else
			{
				builder.Append("(");
				int i = 0;
				for (int count = Parameters.Count; i < count; i++)
				{
					if (i > 0)
					{
						builder.Append(", ");
					}
					Parameters[i].BuildString(builder);
				}
				builder.Append(")");
			}
			builder.Append(" => ");
			body.BuildString(builder);
		}

		public Delegate Compile()
		{
			ExpressionCompiler expressionCompiler = new ExpressionCompiler();
			return expressionCompiler.Compile(this);
		}
	}
	public sealed class Expression<TDelegate> : LambdaExpression
	{
		internal Expression(Expression body, ReadOnlyCollection<ParameterExpression> parameters)
			: base(body, typeof(TDelegate), parameters)
		{
		}

		public new TDelegate Compile()
		{
			return (TDelegate)(object)base.Compile();
		}
	}
	public sealed class MemberExpression : Expression
	{
		private Expression expr;

		private MemberInfo member;

		public Expression Expression => expr;

		public MemberInfo Member => member;

		internal MemberExpression(Expression expression, MemberInfo member, Type type)
			: base(ExpressionType.MemberAccess, type)
		{
			expr = expression;
			this.member = member;
		}

		internal override void BuildString(StringBuilder builder)
		{
			if (builder == null)
			{
				throw Error.ArgumentNull("builder");
			}
			if (expr != null)
			{
				expr.BuildString(builder);
			}
			else
			{
				builder.Append(member.DeclaringType.Name);
			}
			builder.Append(".");
			builder.Append(member.Name);
		}
	}
	public sealed class MethodCallExpression : Expression
	{
		private MethodInfo method;

		private Expression obj;

		private ReadOnlyCollection<Expression> arguments;

		public MethodInfo Method => method;

		public Expression Object => obj;

		public ReadOnlyCollection<Expression> Arguments => arguments;

		internal MethodCallExpression(ExpressionType type, MethodInfo method, Expression obj, ReadOnlyCollection<Expression> arguments)
			: base(type, method.ReturnType)
		{
			this.obj = obj;
			this.method = method;
			this.arguments = arguments;
		}

		internal override void BuildString(StringBuilder builder)
		{
			if (builder == null)
			{
				throw Error.ArgumentNull("builder");
			}
			int num = 0;
			Expression expression = obj;
			if (Attribute.GetCustomAttribute(method, typeof(ExtensionAttribute)) != null)
			{
				num = 1;
				expression = arguments[0];
			}
			if (expression != null)
			{
				expression.BuildString(builder);
				builder.Append(".");
			}
			builder.Append(method.Name);
			builder.Append("(");
			int i = num;
			for (int count = arguments.Count; i < count; i++)
			{
				if (i > num)
				{
					builder.Append(", ");
				}
				arguments[i].BuildString(builder);
			}
			builder.Append(")");
		}
	}
	public sealed class NewExpression : Expression
	{
		private ConstructorInfo constructor;

		private ReadOnlyCollection<Expression> arguments;

		private ReadOnlyCollection<MemberInfo> members;

		public ConstructorInfo Constructor => constructor;

		public ReadOnlyCollection<Expression> Arguments => arguments;

		public ReadOnlyCollection<MemberInfo> Members => members;

		internal NewExpression(Type type, ConstructorInfo constructor, ReadOnlyCollection<Expression> arguments)
			: base(ExpressionType.New, type)
		{
			this.constructor = constructor;
			this.arguments = arguments;
		}

		internal NewExpression(Type type, ConstructorInfo constructor, ReadOnlyCollection<Expression> arguments, ReadOnlyCollection<MemberInfo> members)
			: base(ExpressionType.New, type)
		{
			this.constructor = constructor;
			this.arguments = arguments;
			this.members = members;
		}

		private static PropertyInfo GetPropertyNoThrow(MethodInfo method)
		{
			if (method == null)
			{
				return null;
			}
			Type declaringType = method.DeclaringType;
			BindingFlags bindingFlags = BindingFlags.Public | BindingFlags.NonPublic;
			bindingFlags |= (method.IsStatic ? BindingFlags.Static : BindingFlags.Instance);
			PropertyInfo[] properties = declaringType.GetProperties(bindingFlags);
			PropertyInfo[] array = properties;
			foreach (PropertyInfo propertyInfo in array)
			{
				if (propertyInfo.CanRead && method == propertyInfo.GetGetMethod(nonPublic: true))
				{
					return propertyInfo;
				}
				if (propertyInfo.CanWrite && method == propertyInfo.GetSetMethod(nonPublic: true))
				{
					return propertyInfo;
				}
			}
			return null;
		}

		internal override void BuildString(StringBuilder builder)
		{
			Type type = ((constructor != null) ? constructor.DeclaringType : (type = base.Type));
			builder.Append("new ");
			int count = arguments.Count;
			builder.Append(type.Name);
			builder.Append("(");
			if (count > 0)
			{
				for (int i = 0; i < count; i++)
				{
					if (i > 0)
					{
						builder.Append(", ");
					}
					if (members != null)
					{
						PropertyInfo propertyInfo = null;
						if (members[i].MemberType == MemberTypes.Method && (propertyInfo = GetPropertyNoThrow((MethodInfo)members[i])) != null)
						{
							builder.Append(propertyInfo.Name);
						}
						else
						{
							builder.Append(members[i].Name);
						}
						builder.Append(" = ");
					}
					arguments[i].BuildString(builder);
				}
			}
			builder.Append(")");
		}
	}
	public sealed class NewArrayExpression : Expression
	{
		private ReadOnlyCollection<Expression> expressions;

		public ReadOnlyCollection<Expression> Expressions => expressions;

		internal NewArrayExpression(ExpressionType eType, Type type, ReadOnlyCollection<Expression> expressions)
			: base(eType, type)
		{
			this.expressions = expressions;
		}

		internal override void BuildString(StringBuilder builder)
		{
			switch (base.NodeType)
			{
			case ExpressionType.NewArrayBounds:
			{
				builder.Append("new ");
				builder.Append(base.Type.ToString());
				builder.Append("(");
				int j = 0;
				for (int count2 = expressions.Count; j < count2; j++)
				{
					if (j > 0)
					{
						builder.Append(", ");
					}
					expressions[j].BuildString(builder);
				}
				builder.Append(")");
				break;
			}
			case ExpressionType.NewArrayInit:
			{
				builder.Append("new ");
				builder.Append("[] {");
				int i = 0;
				for (int count = expressions.Count; i < count; i++)
				{
					if (i > 0)
					{
						builder.Append(", ");
					}
					expressions[i].BuildString(builder);
				}
				builder.Append("}");
				break;
			}
			}
		}
	}
	public sealed class MemberInitExpression : Expression
	{
		private NewExpression newExpression;

		private ReadOnlyCollection<MemberBinding> bindings;

		public NewExpression NewExpression => newExpression;

		public ReadOnlyCollection<MemberBinding> Bindings => bindings;

		internal MemberInitExpression(NewExpression newExpression, ReadOnlyCollection<MemberBinding> bindings)
			: base(ExpressionType.MemberInit, newExpression.Type)
		{
			this.newExpression = newExpression;
			this.bindings = bindings;
		}

		internal override void BuildString(StringBuilder builder)
		{
			if (newExpression.Arguments.Count == 0 && newExpression.Type.Name.Contains("<"))
			{
				builder.Append("new");
			}
			else
			{
				newExpression.BuildString(builder);
			}
			builder.Append(" {");
			int i = 0;
			for (int count = bindings.Count; i < count; i++)
			{
				MemberBinding memberBinding = bindings[i];
				if (i > 0)
				{
					builder.Append(", ");
				}
				memberBinding.BuildString(builder);
			}
			builder.Append("}");
		}
	}
	public sealed class ListInitExpression : Expression
	{
		private NewExpression newExpression;

		private ReadOnlyCollection<ElementInit> initializers;

		public NewExpression NewExpression => newExpression;

		public ReadOnlyCollection<ElementInit> Initializers => initializers;

		internal ListInitExpression(NewExpression newExpression, ReadOnlyCollection<ElementInit> initializers)
			: base(ExpressionType.ListInit, newExpression.Type)
		{
			this.newExpression = newExpression;
			this.initializers = initializers;
		}

		internal override void BuildString(StringBuilder builder)
		{
			newExpression.BuildString(builder);
			builder.Append(" {");
			int i = 0;
			for (int count = initializers.Count; i < count; i++)
			{
				if (i > 0)
				{
					builder.Append(", ");
				}
				initializers[i].BuildString(builder);
			}
			builder.Append("}");
		}
	}
	public sealed class ParameterExpression : Expression
	{
		private string name;

		public string Name => name;

		internal ParameterExpression(Type type, string name)
			: base(ExpressionType.Parameter, type)
		{
			this.name = name;
		}

		internal override void BuildString(StringBuilder builder)
		{
			if (builder == null)
			{
				throw Error.ArgumentNull("builder");
			}
			if (name != null)
			{
				builder.Append(name);
			}
			else
			{
				builder.Append("<param>");
			}
		}
	}
	public sealed class TypeBinaryExpression : Expression
	{
		private Expression expression;

		private Type typeop;

		public Expression Expression => expression;

		public Type TypeOperand => typeop;

		internal TypeBinaryExpression(ExpressionType nt, Expression expression, Type typeop, Type resultType)
			: base(nt, resultType)
		{
			this.expression = expression;
			this.typeop = typeop;
		}

		internal override void BuildString(StringBuilder builder)
		{
			if (builder == null)
			{
				throw Error.ArgumentNull("builder");
			}
			builder.Append("(");
			expression.BuildString(builder);
			builder.Append(" Is ");
			builder.Append(typeop.Name);
			builder.Append(")");
		}
	}
	public sealed class UnaryExpression : Expression
	{
		private Expression operand;

		private MethodInfo method;

		public Expression Operand => operand;

		public MethodInfo Method => method;

		public bool IsLifted
		{
			get
			{
				if (base.NodeType == ExpressionType.TypeAs || base.NodeType == ExpressionType.Quote)
				{
					return false;
				}
				bool flag = Expression.IsNullableType(operand.Type);
				bool flag2 = Expression.IsNullableType(base.Type);
				if (method != null)
				{
					if (!flag || method.GetParameters()[0].ParameterType == operand.Type)
					{
						if (flag2)
						{
							return method.ReturnType != base.Type;
						}
						return false;
					}
					return true;
				}
				if (!flag)
				{
					return flag2;
				}
				return true;
			}
		}

		public bool IsLiftedToNull
		{
			get
			{
				if (IsLifted)
				{
					return Expression.IsNullableType(base.Type);
				}
				return false;
			}
		}

		internal UnaryExpression(ExpressionType nt, Expression operand, Type type)
			: this(nt, operand, null, type)
		{
		}

		internal UnaryExpression(ExpressionType nt, Expression operand, MethodInfo method, Type type)
			: base(nt, type)
		{
			this.operand = operand;
			this.method = method;
		}

		internal override void BuildString(StringBuilder builder)
		{
			if (builder == null)
			{
				throw Error.ArgumentNull("builder");
			}
			switch (base.NodeType)
			{
			case ExpressionType.TypeAs:
				builder.Append("(");
				operand.BuildString(builder);
				builder.Append(" As ");
				builder.Append(base.Type.Name);
				builder.Append(")");
				break;
			case ExpressionType.Not:
				builder.Append("Not");
				builder.Append("(");
				operand.BuildString(builder);
				builder.Append(")");
				break;
			case ExpressionType.Negate:
			case ExpressionType.NegateChecked:
				builder.Append("-");
				operand.BuildString(builder);
				break;
			case ExpressionType.UnaryPlus:
				builder.Append("+");
				operand.BuildString(builder);
				break;
			case ExpressionType.Quote:
				operand.BuildString(builder);
				break;
			default:
				builder.Append(base.NodeType);
				builder.Append("(");
				operand.BuildString(builder);
				builder.Append(")");
				break;
			}
		}
	}
	internal static class ReadOnlyCollectionExtensions
	{
		private static class DefaultReadOnlyCollection<T>
		{
			private static ReadOnlyCollection<T> _defaultCollection;

			internal static ReadOnlyCollection<T> Empty
			{
				get
				{
					if (_defaultCollection == null)
					{
						_defaultCollection = new ReadOnlyCollection<T>(new T[0]);
					}
					return _defaultCollection;
				}
			}
		}

		internal static ReadOnlyCollection<T> ToReadOnlyCollection<T>(this IEnumerable<T> sequence)
		{
			if (sequence == null)
			{
				return DefaultReadOnlyCollection<T>.Empty;
			}
			if (sequence is ReadOnlyCollection<T> result)
			{
				return result;
			}
			return new ReadOnlyCollection<T>(sequence.ToArray());
		}
	}
	internal class ExpressionCompiler
	{
		internal class LambdaInfo
		{
			internal LambdaExpression Lambda;

			internal List<LambdaInfo> Lambdas;

			internal MethodInfo Method;

			internal Dictionary<ParameterExpression, int> HoistedLocals;

			internal LambdaInfo(LambdaExpression lambda, MethodInfo method, Dictionary<ParameterExpression, int> hoistedLocals, List<LambdaInfo> lambdas)
			{
				Lambda = lambda;
				Method = method;
				HoistedLocals = hoistedLocals;
				Lambdas = lambdas;
			}
		}

		private class CompileScope
		{
			internal CompileScope Parent;

			internal LambdaExpression Lambda;

			internal Dictionary<ParameterExpression, LocalBuilder> Locals;

			internal Dictionary<ParameterExpression, int> HoistedLocals;

			internal LocalBuilder HoistedLocalsVar;

			internal CompileScope(CompileScope parent, LambdaExpression lambda)
			{
				Parent = parent;
				Lambda = lambda;
				Locals = new Dictionary<ParameterExpression, LocalBuilder>();
				HoistedLocals = new Dictionary<ParameterExpression, int>();
			}
		}

		private enum StackType
		{
			Value,
			Address
		}

		private class Hoister : ExpressionVisitor
		{
			private CompileScope expressionScope;

			private LambdaExpression current;

			private List<ParameterExpression> locals;

			internal Hoister()
			{
			}

			internal void Hoist(CompileScope scope)
			{
				expressionScope = scope;
				current = scope.Lambda;
				locals = new List<ParameterExpression>(scope.Lambda.Parameters);
				Visit(scope.Lambda.Body);
			}

			internal override Expression VisitParameter(ParameterExpression p)
			{
				if (locals.Contains(p) && expressionScope.Lambda != current && !expressionScope.HoistedLocals.ContainsKey(p))
				{
					expressionScope.HoistedLocals.Add(p, expressionScope.HoistedLocals.Count);
				}
				return p;
			}

			internal override Expression VisitInvocation(InvocationExpression iv)
			{
				if (expressionScope.Lambda == current)
				{
					if (iv.Expression.NodeType == ExpressionType.Lambda)
					{
						LambdaExpression lambdaExpression = (LambdaExpression)iv.Expression;
						locals.AddRange(lambdaExpression.Parameters);
					}
					else if (iv.Expression.NodeType == ExpressionType.Quote && iv.Expression.Type.IsSubclassOf(typeof(LambdaExpression)))
					{
						LambdaExpression lambdaExpression2 = (LambdaExpression)((UnaryExpression)iv.Expression).Operand;
						locals.AddRange(lambdaExpression2.Parameters);
					}
				}
				return base.VisitInvocation(iv);
			}

			internal override Expression VisitLambda(LambdaExpression l)
			{
				LambdaExpression lambdaExpression = current;
				current = l;
				Visit(l.Body);
				current = lambdaExpression;
				return l;
			}
		}

		private struct WriteBack
		{
			public LocalBuilder loc;

			public Expression arg;

			public WriteBack(LocalBuilder loc, Expression arg)
			{
				this.loc = loc;
				this.arg = arg;
			}
		}

		private List<LambdaInfo> lambdas;

		private List<object> globals;

		private CompileScope scope;

		internal ExpressionCompiler()
		{
			lambdas = new List<LambdaInfo>();
			globals = new List<object>();
		}

		public D Compile<D>(Expression<D> lambda)
		{
			if (!typeof(Delegate).IsAssignableFrom(typeof(D)))
			{
				throw Error.TypeParameterIsNotDelegate(typeof(D));
			}
			return (D)(object)Compile((LambdaExpression)lambda);
		}

		public Delegate Compile(LambdaExpression lambda)
		{
			return CompileDynamicLambda(lambda);
		}

		private Delegate CompileDynamicLambda(LambdaExpression lambda)
		{
			lambdas = new List<LambdaInfo>();
			globals = new List<object>();
			int index = GenerateLambda(lambda);
			LambdaInfo lambdaInfo = lambdas[index];
			ExecutionScope target = new ExecutionScope(null, lambdaInfo, globals.ToArray(), null);
			return ((DynamicMethod)lambdaInfo.Method).CreateDelegate(lambda.Type, target);
		}

		private static void GenerateLoadExecutionScope(ILGenerator gen)
		{
			gen.Emit(OpCodes.Ldarg_0);
		}

		private void GenerateLoadHoistedLocals(ILGenerator gen)
		{
			gen.Emit(OpCodes.Ldloc, scope.HoistedLocalsVar);
		}

		private int GenerateLambda(LambdaExpression lambda)
		{
			scope = new CompileScope(scope, lambda);
			MethodInfo method = lambda.Type.GetMethod("Invoke");
			new Hoister().Hoist(scope);
			DynamicMethod dynamicMethod = new DynamicMethod("lambda_method", method.ReturnType, GetParameterTypes(method), restrictedSkipVisibility: true);
			ILGenerator iLGenerator = dynamicMethod.GetILGenerator();
			MethodInfo method2 = dynamicMethod;
			GenerateInitHoistedLocals(iLGenerator);
			Generate(iLGenerator, lambda.Body, StackType.Value);
			if (method.ReturnType == typeof(void) && lambda.Body.Type != typeof(void))
			{
				iLGenerator.Emit(OpCodes.Pop);
			}
			iLGenerator.Emit(OpCodes.Ret);
			int count = lambdas.Count;
			lambdas.Add(new LambdaInfo(lambda, method2, scope.HoistedLocals, lambdas));
			scope = scope.Parent;
			return count;
		}

		private void GenerateInitHoistedLocals(ILGenerator gen)
		{
			if (scope.HoistedLocals.Count == 0)
			{
				return;
			}
			scope.HoistedLocalsVar = gen.DeclareLocal(typeof(object[]));
			GenerateLoadExecutionScope(gen);
			gen.Emit(OpCodes.Callvirt, typeof(ExecutionScope).GetMethod("CreateHoistedLocals", BindingFlags.Instance | BindingFlags.Public));
			gen.Emit(OpCodes.Stloc, scope.HoistedLocalsVar);
			int count = scope.Lambda.Parameters.Count;
			for (int i = 0; i < count; i++)
			{
				ParameterExpression p = scope.Lambda.Parameters[i];
				if (IsHoisted(p))
				{
					PrepareInitLocal(gen, p);
					GenerateArgAccess(gen, i + 1, StackType.Value);
					GenerateInitLocal(gen, p);
				}
			}
		}

		private bool IsHoisted(ParameterExpression p)
		{
			return scope.HoistedLocals.ContainsKey(p);
		}

		private void PrepareInitLocal(ILGenerator gen, ParameterExpression p)
		{
			if (scope.HoistedLocals.TryGetValue(p, out var value))
			{
				GenerateLoadHoistedLocals(gen);
				GenerateConstInt(gen, value);
			}
			else
			{
				LocalBuilder value2 = gen.DeclareLocal(p.Type);
				scope.Locals.Add(p, value2);
			}
		}

		private static Type MakeStrongBoxType(Type type)
		{
			return typeof(StrongBox<>).MakeGenericType(type);
		}

		private void GenerateInitLocal(ILGenerator gen, ParameterExpression p)
		{
			if (scope.HoistedLocals.TryGetValue(p, out var _))
			{
				Type type = MakeStrongBoxType(p.Type);
				ConstructorInfo constructor = type.GetConstructor(new Type[1] { p.Type });
				gen.Emit(OpCodes.Newobj, constructor);
				gen.Emit(OpCodes.Stelem_Ref);
			}
			else
			{
				if (!scope.Locals.TryGetValue(p, out var value2))
				{
					throw Error.NotSupported();
				}
				gen.Emit(OpCodes.Stloc, value2);
			}
		}

		private Type[] GetParameterTypes(MethodInfo mi)
		{
			ParameterInfo[] parameters = mi.GetParameters();
			Type[] array = new Type[parameters.Length + 1];
			int i = 0;
			for (int num = parameters.Length; i < num; i++)
			{
				array[i + 1] = parameters[i].ParameterType;
			}
			array[0] = typeof(ExecutionScope);
			return array;
		}

		private StackType Generate(ILGenerator gen, Expression node, StackType ask)
		{
			switch (node.NodeType)
			{
			case ExpressionType.ArrayLength:
			case ExpressionType.Negate:
			case ExpressionType.UnaryPlus:
			case ExpressionType.NegateChecked:
			case ExpressionType.Not:
			case ExpressionType.TypeAs:
				return GenerateUnary(gen, (UnaryExpression)node, ask);
			case ExpressionType.Add:
			case ExpressionType.AddChecked:
			case ExpressionType.And:
			case ExpressionType.AndAlso:
			case ExpressionType.ArrayIndex:
			case ExpressionType.Coalesce:
			case ExpressionType.Divide:
			case ExpressionType.Equal:
			case ExpressionType.ExclusiveOr:
			case ExpressionType.GreaterThan:
			case ExpressionType.GreaterThanOrEqual:
			case ExpressionType.LeftShift:
			case ExpressionType.LessThan:
			case ExpressionType.LessThanOrEqual:
			case ExpressionType.Modulo:
			case ExpressionType.Multiply:
			case ExpressionType.MultiplyChecked:
			case ExpressionType.NotEqual:
			case ExpressionType.Or:
			case ExpressionType.OrElse:
			case ExpressionType.Power:
			case ExpressionType.RightShift:
			case ExpressionType.Subtract:
			case ExpressionType.SubtractChecked:
				return GenerateBinary(gen, (BinaryExpression)node, ask);
			case ExpressionType.TypeIs:
				GenerateTypeIs(gen, (TypeBinaryExpression)node);
				return StackType.Value;
			case ExpressionType.Constant:
				return GenerateConstant(gen, (ConstantExpression)node, ask);
			case ExpressionType.Conditional:
				return GenerateConditional(gen, (ConditionalExpression)node);
			case ExpressionType.Parameter:
				return GenerateParameterAccess(gen, (ParameterExpression)node, ask);
			case ExpressionType.MemberAccess:
				return GenerateMemberAccess(gen, (MemberExpression)node, ask);
			case ExpressionType.Call:
				return GenerateMethodCall(gen, (MethodCallExpression)node, ask);
			case ExpressionType.Lambda:
				GenerateCreateDelegate(gen, (LambdaExpression)node);
				return StackType.Value;
			case ExpressionType.Convert:
			case ExpressionType.ConvertChecked:
				GenerateConvert(gen, (UnaryExpression)node);
				return StackType.Value;
			case ExpressionType.New:
				return GenerateNew(gen, (NewExpression)node, ask);
			case ExpressionType.NewArrayInit:
			case ExpressionType.NewArrayBounds:
				GenerateNewArray(gen, (NewArrayExpression)node);
				return StackType.Value;
			case ExpressionType.ListInit:
				return GenerateListInit(gen, (ListInitExpression)node);
			case ExpressionType.MemberInit:
				return GenerateMemberInit(gen, (MemberInitExpression)node);
			case ExpressionType.Invoke:
				return GenerateInvoke(gen, (InvocationExpression)node, ask);
			case ExpressionType.Quote:
				GenerateQuote(gen, (UnaryExpression)node);
				return StackType.Value;
			default:
				throw Error.UnhandledExpressionType(node.NodeType);
			}
		}

		private StackType GenerateNew(ILGenerator gen, NewExpression nex, StackType ask)
		{
			LocalBuilder local = null;
			if (nex.Type.IsValueType)
			{
				local = gen.DeclareLocal(nex.Type);
			}
			if (nex.Constructor != null)
			{
				ParameterInfo[] parameters = nex.Constructor.GetParameters();
				GenerateArgs(gen, parameters, nex.Arguments);
				gen.Emit(OpCodes.Newobj, nex.Constructor);
				if (nex.Type.IsValueType)
				{
					gen.Emit(OpCodes.Stloc, local);
				}
			}
			else if (nex.Type.IsValueType)
			{
				gen.Emit(OpCodes.Ldloca, local);
				gen.Emit(OpCodes.Initobj, nex.Type);
			}
			else
			{
				ConstructorInfo constructor = nex.Type.GetConstructor(Type.EmptyTypes);
				gen.Emit(OpCodes.Newobj, constructor);
			}
			if (nex.Type.IsValueType)
			{
				return ReturnFromLocal(gen, ask, local);
			}
			return StackType.Value;
		}

		private StackType GenerateInvoke(ILGenerator gen, InvocationExpression invoke, StackType ask)
		{
			LambdaExpression lambdaExpression = ((invoke.Expression.NodeType == ExpressionType.Quote) ? ((LambdaExpression)((UnaryExpression)invoke.Expression).Operand) : (invoke.Expression as LambdaExpression));
			if (lambdaExpression != null)
			{
				int i = 0;
				for (int count = invoke.Arguments.Count; i < count; i++)
				{
					ParameterExpression p = lambdaExpression.Parameters[i];
					PrepareInitLocal(gen, p);
					Generate(gen, invoke.Arguments[i], StackType.Value);
					GenerateInitLocal(gen, p);
				}
				return Generate(gen, lambdaExpression.Body, ask);
			}
			Expression expression = invoke.Expression;
			if (typeof(LambdaExpression).IsAssignableFrom(expression.Type))
			{
				expression = Expression.Call(expression, expression.Type.GetMethod("Compile", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic));
			}
			expression = Expression.Call(expression, expression.Type.GetMethod("Invoke"), invoke.Arguments);
			return Generate(gen, expression, ask);
		}

		private void GenerateQuote(ILGenerator gen, UnaryExpression quote)
		{
			GenerateLoadExecutionScope(gen);
			int iGlobal = AddGlobal(typeof(Expression), quote.Operand);
			GenerateGlobalAccess(gen, iGlobal, typeof(Expression), StackType.Value);
			if (scope.HoistedLocalsVar != null)
			{
				GenerateLoadHoistedLocals(gen);
			}
			else
			{
				gen.Emit(OpCodes.Ldnull);
			}
			MethodInfo method = typeof(ExecutionScope).GetMethod("IsolateExpression", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			gen.Emit(OpCodes.Callvirt, method);
			Type type = quote.Operand.GetType();
			if (type != typeof(Expression))
			{
				gen.Emit(OpCodes.Castclass, type);
			}
		}

		private void GenerateBinding(ILGenerator gen, MemberBinding binding, Type objectType)
		{
			switch (binding.BindingType)
			{
			case MemberBindingType.Assignment:
				GenerateMemberAssignment(gen, (MemberAssignment)binding, objectType);
				break;
			case MemberBindingType.ListBinding:
				GenerateMemberListBinding(gen, (MemberListBinding)binding);
				break;
			case MemberBindingType.MemberBinding:
				GenerateMemberMemberBinding(gen, (MemberMemberBinding)binding);
				break;
			default:
				throw Error.UnknownBindingType();
			}
		}

		private void GenerateMemberAssignment(ILGenerator gen, MemberAssignment binding, Type objectType)
		{
			Generate(gen, binding.Expression, StackType.Value);
			if (binding.Member is FieldInfo field)
			{
				gen.Emit(OpCodes.Stfld, field);
				return;
			}
			PropertyInfo propertyInfo = binding.Member as PropertyInfo;
			MethodInfo setMethod = propertyInfo.GetSetMethod(nonPublic: true);
			if (propertyInfo != null)
			{
				if (UseVirtual(setMethod))
				{
					if (objectType.IsValueType)
					{
						gen.Emit(OpCodes.Constrained, objectType);
					}
					gen.Emit(OpCodes.Callvirt, setMethod);
				}
				else
				{
					gen.Emit(OpCodes.Call, setMethod);
				}
				return;
			}
			throw Error.UnhandledBinding();
		}

		private void GenerateMemberMemberBinding(ILGenerator gen, MemberMemberBinding binding)
		{
			Type memberType = GetMemberType(binding.Member);
			if (binding.Member is PropertyInfo && memberType.IsValueType)
			{
				throw Error.CannotAutoInitializeValueTypeMemberThroughProperty(binding.Member);
			}
			StackType stackType = (memberType.IsValueType ? StackType.Address : StackType.Value);
			StackType stackType2 = GenerateMemberAccess(gen, binding.Member, stackType);
			if (stackType2 != stackType && memberType.IsValueType)
			{
				LocalBuilder local = gen.DeclareLocal(memberType);
				gen.Emit(OpCodes.Stloc, local);
				gen.Emit(OpCodes.Ldloca, local);
			}
			if (binding.Bindings.Count == 0)
			{
				gen.Emit(OpCodes.Pop);
			}
			else
			{
				GenerateMemberInit(gen, binding.Bindings, keepOnStack: false, memberType);
			}
		}

		private void GenerateMemberListBinding(ILGenerator gen, MemberListBinding binding)
		{
			Type memberType = GetMemberType(binding.Member);
			if (binding.Member is PropertyInfo && memberType.IsValueType)
			{
				throw Error.CannotAutoInitializeValueTypeElementThroughProperty(binding.Member);
			}
			StackType ask = (memberType.IsValueType ? StackType.Address : StackType.Value);
			StackType stackType = GenerateMemberAccess(gen, binding.Member, ask);
			if (stackType != StackType.Address && memberType.IsValueType)
			{
				LocalBuilder local = gen.DeclareLocal(memberType);
				gen.Emit(OpCodes.Stloc, local);
				gen.Emit(OpCodes.Ldloca, local);
			}
			GenerateListInit(gen, binding.Initializers, keepOnStack: false, memberType);
		}

		private StackType GenerateMemberInit(ILGenerator gen, MemberInitExpression init)
		{
			Generate(gen, init.NewExpression, StackType.Value);
			LocalBuilder localBuilder = null;
			if (init.NewExpression.Type.IsValueType && init.Bindings.Count > 0)
			{
				localBuilder = gen.DeclareLocal(init.NewExpression.Type);
				gen.Emit(OpCodes.Stloc, localBuilder);
				gen.Emit(OpCodes.Ldloca, localBuilder);
			}
			GenerateMemberInit(gen, init.Bindings, localBuilder == null, init.NewExpression.Type);
			if (localBuilder != null)
			{
				gen.Emit(OpCodes.Ldloc, localBuilder);
			}
			return StackType.Value;
		}

		private void GenerateMemberInit(ILGenerator gen, ReadOnlyCollection<MemberBinding> bindings, bool keepOnStack, Type objectType)
		{
			int i = 0;
			for (int count = bindings.Count; i < count; i++)
			{
				if (keepOnStack || i < count - 1)
				{
					gen.Emit(OpCodes.Dup);
				}
				GenerateBinding(gen, bindings[i], objectType);
			}
		}

		private StackType GenerateListInit(ILGenerator gen, ListInitExpression init)
		{
			Generate(gen, init.NewExpression, StackType.Value);
			LocalBuilder localBuilder = null;
			if (init.NewExpression.Type.IsValueType)
			{
				localBuilder = gen.DeclareLocal(init.NewExpression.Type);
				gen.Emit(OpCodes.Stloc, localBuilder);
				gen.Emit(OpCodes.Ldloca, localBuilder);
			}
			GenerateListInit(gen, init.Initializers, localBuilder == null, init.NewExpression.Type);
			if (localBuilder != null)
			{
				gen.Emit(OpCodes.Ldloc, localBuilder);
			}
			return StackType.Value;
		}

		private void GenerateListInit(ILGenerator gen, ReadOnlyCollection<ElementInit> initializers, bool keepOnStack, Type objectType)
		{
			int i = 0;
			for (int count = initializers.Count; i < count; i++)
			{
				if (keepOnStack || i < count - 1)
				{
					gen.Emit(OpCodes.Dup);
				}
				GenerateMethodCall(gen, initializers[i].AddMethod, initializers[i].Arguments, objectType);
				if (initializers[i].AddMethod.ReturnType != typeof(void))
				{
					gen.Emit(OpCodes.Pop);
				}
			}
		}

		private Type GetMemberType(MemberInfo member)
		{
			if (member is FieldInfo fieldInfo)
			{
				return fieldInfo.FieldType;
			}
			if (member is PropertyInfo propertyInfo)
			{
				return propertyInfo.PropertyType;
			}
			throw Error.MemberNotFieldOrProperty(member);
		}

		private void GenerateNewArray(ILGenerator gen, NewArrayExpression nex)
		{
			Type elementType = nex.Type.GetElementType();
			if (nex.NodeType == ExpressionType.NewArrayInit)
			{
				GenerateConstInt(gen, nex.Expressions.Count);
				gen.Emit(OpCodes.Newarr, elementType);
				int i = 0;
				for (int count = nex.Expressions.Count; i < count; i++)
				{
					gen.Emit(OpCodes.Dup);
					GenerateConstInt(gen, i);
					Generate(gen, nex.Expressions[i], StackType.Value);
					GenerateArrayAssign(gen, elementType);
				}
				return;
			}
			Type[] array = new Type[nex.Expressions.Count];
			int j = 0;
			for (int num = array.Length; j < num; j++)
			{
				array[j] = typeof(int);
			}
			int k = 0;
			for (int count2 = nex.Expressions.Count; k < count2; k++)
			{
				Expression expression = nex.Expressions[k];
				Generate(gen, expression, StackType.Value);
				if (expression.Type != typeof(int))
				{
					GenerateConvertToType(gen, expression.Type, typeof(int), isChecked: true);
				}
			}
			if (nex.Expressions.Count > 1)
			{
				int[] lengths = new int[nex.Expressions.Count];
				ConstructorInfo constructor = Array.CreateInstance(elementType, lengths).GetType().GetConstructor(array);
				gen.Emit(OpCodes.Newobj, constructor);
			}
			else
			{
				gen.Emit(OpCodes.Newarr, elementType);
			}
		}

		private void GenerateConvert(ILGenerator gen, UnaryExpression u)
		{
			if (u.Method != null)
			{
				if (u.IsLifted && (!u.Type.IsValueType || !u.Operand.Type.IsValueType))
				{
					ParameterInfo[] parameters = u.Method.GetParameters();
					Type parameterType = parameters[0].ParameterType;
					if (parameterType.IsByRef)
					{
						parameterType = parameterType.GetElementType();
					}
					Expression node = Expression.Convert(Expression.Call(null, u.Method, Expression.Convert(u.Operand, parameters[0].ParameterType)), u.Type);
					Generate(gen, node, StackType.Value);
				}
				else
				{
					GenerateUnaryMethod(gen, u, StackType.Value);
				}
			}
			else
			{
				Generate(gen, u.Operand, StackType.Value);
				GenerateConvertToType(gen, u.Operand.Type, u.Type, u.NodeType == ExpressionType.ConvertChecked);
			}
		}

		private void GenerateCreateDelegate(ILGenerator gen, LambdaExpression lambda)
		{
			int value = GenerateLambda(lambda);
			GenerateLoadExecutionScope(gen);
			GenerateConstInt(gen, value);
			if (scope.HoistedLocalsVar != null)
			{
				GenerateLoadHoistedLocals(gen);
			}
			else
			{
				gen.Emit(OpCodes.Ldnull);
			}
			gen.Emit(OpCodes.Callvirt, typeof(ExecutionScope).GetMethod("CreateDelegate", BindingFlags.Instance | BindingFlags.Public));
			gen.Emit(OpCodes.Castclass, lambda.Type);
		}

		private StackType GenerateMethodCall(ILGenerator gen, MethodCallExpression mc, StackType ask)
		{
			StackType result = StackType.Value;
			MethodInfo method = mc.Method;
			if (!mc.Method.IsStatic)
			{
				StackType stackType = (mc.Object.Type.IsValueType ? StackType.Address : StackType.Value);
				StackType stackType2 = Generate(gen, mc.Object, stackType);
				if (stackType2 != stackType)
				{
					LocalBuilder local = gen.DeclareLocal(mc.Object.Type);
					gen.Emit(OpCodes.Stloc, local);
					gen.Emit(OpCodes.Ldloca, local);
				}
				if (ask == StackType.Address && mc.Object.Type.IsArray && method == mc.Object.Type.GetMethod("Get", BindingFlags.Instance | BindingFlags.Public))
				{
					method = mc.Object.Type.GetMethod("Address", BindingFlags.Instance | BindingFlags.Public);
					result = StackType.Address;
				}
			}
			GenerateMethodCall(gen, method, mc.Arguments, (mc.Object == null) ? null : mc.Object.Type);
			return result;
		}

		private void GenerateMethodCall(ILGenerator gen, MethodInfo mi, ReadOnlyCollection<Expression> args, Type objectType)
		{
			ParameterInfo[] parameters = mi.GetParameters();
			List<WriteBack> list = GenerateArgs(gen, parameters, args);
			OpCode opCode = (UseVirtual(mi) ? OpCodes.Callvirt : OpCodes.Call);
			if (opCode == OpCodes.Callvirt && objectType.IsValueType)
			{
				gen.Emit(OpCodes.Constrained, objectType);
			}
			if (mi.CallingConvention == CallingConventions.VarArgs)
			{
				Type[] array = new Type[args.Count];
				int i = 0;
				for (int num = array.Length; i < num; i++)
				{
					array[i] = args[i].Type;
				}
				gen.EmitCall(opCode, mi, array);
			}
			else
			{
				gen.Emit(opCode, mi);
			}
			foreach (WriteBack item in list)
			{
				GenerateWriteBack(gen, item);
			}
		}

		private List<WriteBack> GenerateArgs(ILGenerator gen, ParameterInfo[] pis, ReadOnlyCollection<Expression> args)
		{
			List<WriteBack> list = new List<WriteBack>();
			int i = 0;
			for (int num = pis.Length; i < num; i++)
			{
				ParameterInfo parameterInfo = pis[i];
				Expression expression = args[i];
				StackType stackType = (parameterInfo.ParameterType.IsByRef ? StackType.Address : StackType.Value);
				StackType stackType2 = Generate(gen, expression, stackType);
				if (stackType == StackType.Address && stackType2 != StackType.Address)
				{
					LocalBuilder localBuilder = gen.DeclareLocal(expression.Type);
					gen.Emit(OpCodes.Stloc, localBuilder);
					gen.Emit(OpCodes.Ldloca, localBuilder);
					if (args[i] is MemberExpression)
					{
						list.Add(new WriteBack(localBuilder, args[i]));
					}
				}
			}
			return list;
		}

		private StackType GenerateLift(ILGenerator gen, ExpressionType nodeType, Type resultType, MethodCallExpression mc, IEnumerable<ParameterExpression> parameters, IEnumerable<Expression> arguments)
		{
			ReadOnlyCollection<ParameterExpression> readOnlyCollection = parameters.ToReadOnlyCollection();
			ReadOnlyCollection<Expression> readOnlyCollection2 = arguments.ToReadOnlyCollection();
			switch (nodeType)
			{
			default:
			{
				Label label4 = gen.DefineLabel();
				Label label5 = gen.DefineLabel();
				LocalBuilder local4 = gen.DeclareLocal(typeof(bool));
				int j = 0;
				for (int count2 = readOnlyCollection.Count; j < count2; j++)
				{
					ParameterExpression p2 = readOnlyCollection[j];
					Expression expression2 = readOnlyCollection2[j];
					if (IsNullable(expression2.Type))
					{
						PrepareInitLocal(gen, p2);
						if (Generate(gen, expression2, StackType.Address) == StackType.Value)
						{
							LocalBuilder local5 = gen.DeclareLocal(expression2.Type);
							gen.Emit(OpCodes.Stloc, local5);
							gen.Emit(OpCodes.Ldloca, local5);
						}
						gen.Emit(OpCodes.Dup);
						GenerateHasValue(gen, expression2.Type);
						gen.Emit(OpCodes.Ldc_I4_0);
						gen.Emit(OpCodes.Ceq);
						gen.Emit(OpCodes.Stloc, local4);
						GenerateGetValueOrDefault(gen, expression2.Type);
						GenerateInitLocal(gen, p2);
					}
					else
					{
						PrepareInitLocal(gen, p2);
						Generate(gen, expression2, StackType.Value);
						if (!expression2.Type.IsValueType)
						{
							gen.Emit(OpCodes.Dup);
							gen.Emit(OpCodes.Ldnull);
							gen.Emit(OpCodes.Ceq);
							gen.Emit(OpCodes.Stloc, local4);
						}
						GenerateInitLocal(gen, p2);
					}
					gen.Emit(OpCodes.Ldloc, local4);
					gen.Emit(OpCodes.Brtrue, label5);
				}
				Generate(gen, mc, StackType.Value);
				if (IsNullable(resultType) && resultType != mc.Type)
				{
					ConstructorInfo constructor2 = resultType.GetConstructor(new Type[1] { mc.Type });
					gen.Emit(OpCodes.Newobj, constructor2);
				}
				gen.Emit(OpCodes.Br_S, label4);
				gen.MarkLabel(label5);
				if (resultType == Expression.GetNullableType(mc.Type))
				{
					if (resultType.IsValueType)
					{
						LocalBuilder local6 = gen.DeclareLocal(resultType);
						gen.Emit(OpCodes.Ldloca, local6);
						gen.Emit(OpCodes.Initobj, resultType);
						gen.Emit(OpCodes.Ldloc, local6);
					}
					else
					{
						gen.Emit(OpCodes.Ldnull);
					}
				}
				else
				{
					switch (nodeType)
					{
					case ExpressionType.GreaterThan:
					case ExpressionType.GreaterThanOrEqual:
					case ExpressionType.LessThan:
					case ExpressionType.LessThanOrEqual:
						gen.Emit(OpCodes.Ldc_I4_0);
						break;
					}
				}
				gen.MarkLabel(label4);
				return StackType.Value;
			}
			case ExpressionType.Equal:
			case ExpressionType.NotEqual:
				if (resultType != Expression.GetNullableType(mc.Type))
				{
					Label label = gen.DefineLabel();
					Label label2 = gen.DefineLabel();
					Label label3 = gen.DefineLabel();
					LocalBuilder local = gen.DeclareLocal(typeof(bool));
					LocalBuilder local2 = gen.DeclareLocal(typeof(bool));
					gen.Emit(OpCodes.Ldc_I4_0);
					gen.Emit(OpCodes.Stloc, local);
					gen.Emit(OpCodes.Ldc_I4_1);
					gen.Emit(OpCodes.Stloc, local2);
					int i = 0;
					for (int count = readOnlyCollection.Count; i < count; i++)
					{
						ParameterExpression p = readOnlyCollection[i];
						Expression expression = readOnlyCollection2[i];
						PrepareInitLocal(gen, p);
						if (IsNullable(expression.Type))
						{
							if (Generate(gen, expression, StackType.Address) == StackType.Value)
							{
								LocalBuilder local3 = gen.DeclareLocal(expression.Type);
								gen.Emit(OpCodes.Stloc, local3);
								gen.Emit(OpCodes.Ldloca, local3);
							}
							gen.Emit(OpCodes.Dup);
							GenerateHasValue(gen, expression.Type);
							gen.Emit(OpCodes.Ldc_I4_0);
							gen.Emit(OpCodes.Ceq);
							gen.Emit(OpCodes.Dup);
							gen.Emit(OpCodes.Ldloc, local);
							gen.Emit(OpCodes.Or);
							gen.Emit(OpCodes.Stloc, local);
							gen.Emit(OpCodes.Ldloc, local2);
							gen.Emit(OpCodes.And);
							gen.Emit(OpCodes.Stloc, local2);
							GenerateGetValueOrDefault(gen, expression.Type);
						}
						else
						{
							Generate(gen, expression, StackType.Value);
							if (!expression.Type.IsValueType)
							{
								gen.Emit(OpCodes.Dup);
								gen.Emit(OpCodes.Ldnull);
								gen.Emit(OpCodes.Ceq);
								gen.Emit(OpCodes.Dup);
								gen.Emit(OpCodes.Ldloc, local);
								gen.Emit(OpCodes.Or);
								gen.Emit(OpCodes.Stloc, local);
								gen.Emit(OpCodes.Ldloc, local2);
								gen.Emit(OpCodes.And);
								gen.Emit(OpCodes.Stloc, local2);
							}
							else
							{
								gen.Emit(OpCodes.Ldc_I4_0);
								gen.Emit(OpCodes.Stloc, local2);
							}
						}
						GenerateInitLocal(gen, p);
					}
					gen.Emit(OpCodes.Ldloc, local2);
					gen.Emit(OpCodes.Brtrue, label2);
					gen.Emit(OpCodes.Ldloc, local);
					gen.Emit(OpCodes.Brtrue, label3);
					Generate(gen, mc, StackType.Value);
					if (IsNullable(resultType) && resultType != mc.Type)
					{
						ConstructorInfo constructor = resultType.GetConstructor(new Type[1] { mc.Type });
						gen.Emit(OpCodes.Newobj, constructor);
					}
					gen.Emit(OpCodes.Br_S, label);
					gen.MarkLabel(label2);
					bool flag = nodeType == ExpressionType.Equal;
					GenerateConstant(gen, Expression.Constant(flag), StackType.Value);
					gen.Emit(OpCodes.Br_S, label);
					gen.MarkLabel(label3);
					flag = nodeType == ExpressionType.NotEqual;
					GenerateConstant(gen, Expression.Constant(flag), StackType.Value);
					gen.MarkLabel(label);
					return StackType.Value;
				}
				goto default;
			}
		}

		private StackType GenerateMemberAccess(ILGenerator gen, MemberExpression m, StackType ask)
		{
			return GenerateMemberAccess(gen, m.Expression, m.Member, ask);
		}

		private StackType GenerateMemberAccess(ILGenerator gen, Expression expression, MemberInfo member, StackType ask)
		{
			if (member is FieldInfo fieldInfo)
			{
				if (!fieldInfo.IsStatic)
				{
					StackType stackType = (expression.Type.IsValueType ? StackType.Address : StackType.Value);
					StackType stackType2 = Generate(gen, expression, stackType);
					if (stackType2 != stackType)
					{
						LocalBuilder local = gen.DeclareLocal(expression.Type);
						gen.Emit(OpCodes.Stloc, local);
						gen.Emit(OpCodes.Ldloca, local);
					}
				}
				return GenerateMemberAccess(gen, member, ask);
			}
			if (member is PropertyInfo propertyInfo)
			{
				MethodInfo getMethod = propertyInfo.GetGetMethod(nonPublic: true);
				if (!getMethod.IsStatic)
				{
					StackType stackType3 = (expression.Type.IsValueType ? StackType.Address : StackType.Value);
					StackType stackType4 = Generate(gen, expression, stackType3);
					if (stackType4 != stackType3)
					{
						LocalBuilder local2 = gen.DeclareLocal(expression.Type);
						gen.Emit(OpCodes.Stloc, local2);
						gen.Emit(OpCodes.Ldloca, local2);
					}
				}
				return GenerateMemberAccess(gen, member, ask);
			}
			throw Error.UnhandledMemberAccess(member);
		}

		private void GenerateWriteBack(ILGenerator gen, WriteBack writeback)
		{
			if (writeback.arg is MemberExpression memberExpression)
			{
				GenerateMemberWriteBack(gen, memberExpression.Expression, memberExpression.Member, writeback.loc);
			}
		}

		private void GenerateMemberWriteBack(ILGenerator gen, Expression expression, MemberInfo member, LocalBuilder loc)
		{
			if (member is FieldInfo fieldInfo)
			{
				if (!fieldInfo.IsStatic)
				{
					StackType ask = (expression.Type.IsValueType ? StackType.Address : StackType.Value);
					Generate(gen, expression, ask);
					gen.Emit(OpCodes.Ldloc, loc);
					gen.Emit(OpCodes.Stfld, fieldInfo);
				}
				else
				{
					gen.Emit(OpCodes.Ldloc, loc);
					gen.Emit(OpCodes.Stsfld, fieldInfo);
				}
				return;
			}
			if (member is PropertyInfo propertyInfo)
			{
				MethodInfo setMethod = propertyInfo.GetSetMethod(nonPublic: true);
				if (setMethod != null)
				{
					if (!setMethod.IsStatic)
					{
						StackType ask2 = (expression.Type.IsValueType ? StackType.Address : StackType.Value);
						Generate(gen, expression, ask2);
					}
					gen.Emit(OpCodes.Ldloc, loc);
					gen.Emit(UseVirtual(setMethod) ? OpCodes.Callvirt : OpCodes.Call, setMethod);
				}
				return;
			}
			throw Error.UnhandledMemberAccess(member);
		}

		private bool UseVirtual(MethodInfo mi)
		{
			if (mi.IsStatic)
			{
				return false;
			}
			if (mi.DeclaringType.IsValueType)
			{
				return false;
			}
			return true;
		}

		private void GenerateFieldAccess(ILGenerator gen, FieldInfo fi, StackType ask)
		{
			StackType stackType;
			if (fi.IsLiteral)
			{
				stackType = GenerateConstant(gen, fi.FieldType, fi.GetRawConstantValue(), ask);
			}
			else
			{
				OpCode opcode;
				if (ask == StackType.Value || fi.IsInitOnly)
				{
					opcode = (fi.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld);
					stackType = StackType.Value;
				}
				else
				{
					opcode = (fi.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldflda);
					stackType = StackType.Address;
				}
				gen.Emit(opcode, fi);
			}
			if (ask == StackType.Address && stackType == StackType.Value)
			{
				LocalBuilder local = gen.DeclareLocal(fi.FieldType);
				gen.Emit(OpCodes.Stloc, local);
				gen.Emit(OpCodes.Ldloca, local);
			}
		}

		private StackType GenerateMemberAccess(ILGenerator gen, MemberInfo member, StackType ask)
		{
			if (member is FieldInfo fi)
			{
				GenerateFieldAccess(gen, fi, ask);
				return ask;
			}
			if (member is PropertyInfo propertyInfo)
			{
				MethodInfo getMethod = propertyInfo.GetGetMethod(nonPublic: true);
				gen.Emit(UseVirtual(getMethod) ? OpCodes.Callvirt : OpCodes.Call, getMethod);
				return StackType.Value;
			}
			throw Error.UnhandledMemberAccess(member);
		}

		private StackType GenerateParameterAccess(ILGenerator gen, ParameterExpression p, StackType ask)
		{
			if (scope.Locals.TryGetValue(p, out var value))
			{
				if (ask == StackType.Value)
				{
					gen.Emit(OpCodes.Ldloc, value);
				}
				else
				{
					gen.Emit(OpCodes.Ldloca, value);
				}
				return ask;
			}
			if (scope.HoistedLocals.TryGetValue(p, out var value2))
			{
				GenerateLoadHoistedLocals(gen);
				return GenerateHoistedLocalAccess(gen, value2, p.Type, ask);
			}
			int i = 0;
			for (int count = scope.Lambda.Parameters.Count; i < count; i++)
			{
				if (scope.Lambda.Parameters[i] == p)
				{
					return GenerateArgAccess(gen, i + 1, ask);
				}
			}
			GenerateLoadExecutionScope(gen);
			for (CompileScope parent = scope.Parent; parent != null; parent = parent.Parent)
			{
				if (parent.HoistedLocals.TryGetValue(p, out value2))
				{
					gen.Emit(OpCodes.Ldfld, typeof(ExecutionScope).GetField("Locals", BindingFlags.Instance | BindingFlags.Public));
					return GenerateHoistedLocalAccess(gen, value2, p.Type, ask);
				}
				gen.Emit(OpCodes.Ldfld, typeof(ExecutionScope).GetField("Parent", BindingFlags.Instance | BindingFlags.Public));
			}
			throw Error.LambdaParameterNotInScope();
		}

		private StackType GenerateConstant(ILGenerator gen, ConstantExpression c, StackType ask)
		{
			return GenerateConstant(gen, c.Type, c.Value, ask);
		}

		private StackType GenerateConstant(ILGenerator gen, Type type, object value, StackType ask)
		{
			if (value == null)
			{
				if (type.IsValueType)
				{
					LocalBuilder local = gen.DeclareLocal(type);
					gen.Emit(OpCodes.Ldloca, local);
					gen.Emit(OpCodes.Initobj, type);
					gen.Emit(OpCodes.Ldloc, local);
				}
				else
				{
					gen.Emit(OpCodes.Ldnull);
				}
			}
			else
			{
				switch (Type.GetTypeCode(type))
				{
				case TypeCode.Boolean:
					GenerateConstInt(gen, ((bool)value) ? 1 : 0);
					break;
				case TypeCode.SByte:
					GenerateConstInt(gen, (sbyte)value);
					gen.Emit(OpCodes.Conv_I1);
					break;
				case TypeCode.Int16:
					GenerateConstInt(gen, (short)value);
					gen.Emit(OpCodes.Conv_I2);
					break;
				case TypeCode.Int32:
					GenerateConstInt(gen, (int)value);
					break;
				case TypeCode.Int64:
					gen.Emit(OpCodes.Ldc_I8, (long)value);
					break;
				case TypeCode.Single:
					gen.Emit(OpCodes.Ldc_R4, (float)value);
					break;
				case TypeCode.Double:
					gen.Emit(OpCodes.Ldc_R8, (double)value);
					break;
				default:
				{
					int iGlobal = AddGlobal(type, value);
					return GenerateGlobalAccess(gen, iGlobal, type, ask);
				}
				}
			}
			return StackType.Value;
		}

		private StackType GenerateUnary(ILGenerator gen, UnaryExpression u, StackType ask)
		{
			if (u.Method != null)
			{
				return GenerateUnaryMethod(gen, u, ask);
			}
			if (u.NodeType == ExpressionType.NegateChecked && IsInteger(u.Operand.Type))
			{
				GenerateConstInt(gen, 0);
				GenerateConvertToType(gen, typeof(int), u.Operand.Type, isChecked: false);
				Generate(gen, u.Operand, StackType.Value);
				return GenerateBinaryOp(gen, ExpressionType.SubtractChecked, u.Operand.Type, u.Operand.Type, u.Type, liftedToNull: false, ask);
			}
			Generate(gen, u.Operand, StackType.Value);
			return GenerateUnaryOp(gen, u.NodeType, u.Operand.Type, u.Type, ask);
		}

		private static bool IsInteger(Type type)
		{
			type = GetNonNullableType(type);
			if (type.IsEnum)
			{
				return false;
			}
			switch (Type.GetTypeCode(type))
			{
			case TypeCode.SByte:
			case TypeCode.Byte:
			case TypeCode.Int16:
			case TypeCode.UInt16:
			case TypeCode.Int32:
			case TypeCode.UInt32:
			case TypeCode.Int64:
			case TypeCode.UInt64:
				return true;
			default:
				return false;
			}
		}

		private StackType GenerateUnaryMethod(ILGenerator gen, UnaryExpression u, StackType ask)
		{
			if (u.IsLifted)
			{
				ParameterExpression parameterExpression = Expression.Parameter(Expression.GetNonNullableType(u.Operand.Type), null);
				MethodCallExpression methodCallExpression = Expression.Call(null, u.Method, parameterExpression);
				Type nullableType = Expression.GetNullableType(methodCallExpression.Type);
				GenerateLift(gen, u.NodeType, nullableType, methodCallExpression, new ParameterExpression[1] { parameterExpression }, new Expression[1] { u.Operand });
				GenerateConvertToType(gen, nullableType, u.Type, isChecked: false);
				return StackType.Value;
			}
			MethodCallExpression node = Expression.Call(null, u.Method, u.Operand);
			return Generate(gen, node, ask);
		}

		private StackType GenerateConditional(ILGenerator gen, ConditionalExpression b)
		{
			Label label = gen.DefineLabel();
			Label label2 = gen.DefineLabel();
			Generate(gen, b.Test, StackType.Value);
			gen.Emit(OpCodes.Brfalse, label);
			Generate(gen, b.IfTrue, StackType.Value);
			gen.Emit(OpCodes.Br, label2);
			gen.MarkLabel(label);
			Generate(gen, b.IfFalse, StackType.Value);
			gen.MarkLabel(label2);
			return StackType.Value;
		}

		private void GenerateCoalesce(ILGenerator gen, BinaryExpression b)
		{
			if (IsNullable(b.Left.Type))
			{
				GenerateNullableCoalesce(gen, b);
				return;
			}
			if (b.Left.Type.IsValueType)
			{
				throw Error.CoalesceUsedOnNonNullType();
			}
			if (b.Conversion != null)
			{
				GenerateLambdaReferenceCoalesce(gen, b);
			}
			else if (b.Method != null)
			{
				GenerateUserDefinedReferenceCoalesce(gen, b);
			}
			else
			{
				GenerateReferenceCoalesceWithoutConversion(gen, b);
			}
		}

		private void GenerateNullableCoalesce(ILGenerator gen, BinaryExpression b)
		{
			LocalBuilder local = gen.DeclareLocal(b.Left.Type);
			Label label = gen.DefineLabel();
			Label label2 = gen.DefineLabel();
			Generate(gen, b.Left, StackType.Value);
			gen.Emit(OpCodes.Stloc, local);
			gen.Emit(OpCodes.Ldloca, local);
			GenerateHasValue(gen, b.Left.Type);
			gen.Emit(OpCodes.Brfalse, label);
			Type nonNullableType = GetNonNullableType(b.Left.Type);
			if (b.Method != null)
			{
				ParameterInfo[] parameters = b.Method.GetParameters();
				if (!parameters[0].ParameterType.IsAssignableFrom(b.Left.Type))
				{
					gen.Emit(OpCodes.Ldloca, local);
					GenerateGetValueOrDefault(gen, b.Left.Type);
				}
				else
				{
					gen.Emit(OpCodes.Ldloc, local);
				}
				gen.Emit(OpCodes.Call, b.Method);
			}
			else if (b.Conversion != null)
			{
				ParameterExpression parameterExpression = b.Conversion.Parameters[0];
				PrepareInitLocal(gen, parameterExpression);
				if (!parameterExpression.Type.IsAssignableFrom(b.Left.Type))
				{
					gen.Emit(OpCodes.Ldloca, local);
					GenerateGetValueOrDefault(gen, b.Left.Type);
				}
				else
				{
					gen.Emit(OpCodes.Ldloc, local);
				}
				GenerateInitLocal(gen, parameterExpression);
				Generate(gen, b.Conversion.Body, StackType.Value);
			}
			else if (b.Type != nonNullableType)
			{
				gen.Emit(OpCodes.Ldloca, local);
				GenerateGetValueOrDefault(gen, b.Left.Type);
				GenerateConvertToType(gen, nonNullableType, b.Type, isChecked: true);
			}
			else
			{
				gen.Emit(OpCodes.Ldloca, local);
				GenerateGetValueOrDefault(gen, b.Left.Type);
			}
			gen.Emit(OpCodes.Br, label2);
			gen.MarkLabel(label);
			Generate(gen, b.Right, StackType.Value);
			if (b.Right.Type != b.Type)
			{
				GenerateConvertToType(gen, b.Right.Type, b.Type, isChecked: true);
			}
			gen.MarkLabel(label2);
		}

		private void GenerateLambdaReferenceCoalesce(ILGenerator gen, BinaryExpression b)
		{
			Label label = gen.DefineLabel();
			Label label2 = gen.DefineLabel();
			Generate(gen, b.Left, StackType.Value);
			gen.Emit(OpCodes.Dup);
			gen.Emit(OpCodes.Ldnull);
			gen.Emit(OpCodes.Ceq);
			gen.Emit(OpCodes.Brfalse, label2);
			gen.Emit(OpCodes.Pop);
			Generate(gen, b.Right, StackType.Value);
			gen.Emit(OpCodes.Br, label);
			gen.MarkLabel(label2);
			ParameterExpression p = b.Conversion.Parameters[0];
			PrepareInitLocal(gen, p);
			GenerateInitLocal(gen, p);
			Generate(gen, b.Conversion.Body, StackType.Value);
			gen.MarkLabel(label);
		}

		private void GenerateUserDefinedReferenceCoalesce(ILGenerator gen, BinaryExpression b)
		{
			Label label = gen.DefineLabel();
			Label label2 = gen.DefineLabel();
			Generate(gen, b.Left, StackType.Value);
			gen.Emit(OpCodes.Dup);
			gen.Emit(OpCodes.Ldnull);
			gen.Emit(OpCodes.Ceq);
			gen.Emit(OpCodes.Brfalse, label2);
			gen.Emit(OpCodes.Pop);
			Generate(gen, b.Right, StackType.Value);
			gen.Emit(OpCodes.Br_S, label);
			gen.MarkLabel(label2);
			gen.Emit(OpCodes.Call, b.Method);
			gen.MarkLabel(label);
		}

		private void GenerateReferenceCoalesceWithoutConversion(ILGenerator gen, BinaryExpression b)
		{
			Label label = gen.DefineLabel();
			Label label2 = gen.DefineLabel();
			Generate(gen, b.Left, StackType.Value);
			gen.Emit(OpCodes.Dup);
			gen.Emit(OpCodes.Ldnull);
			gen.Emit(OpCodes.Ceq);
			gen.Emit(OpCodes.Brfalse, label2);
			gen.Emit(OpCodes.Pop);
			Generate(gen, b.Right, StackType.Value);
			if (b.Right.Type != b.Type)
			{
				gen.Emit(OpCodes.Castclass, b.Type);
			}
			gen.Emit(OpCodes.Br_S, label);
			gen.MarkLabel(label2);
			if (b.Left.Type != b.Type)
			{
				gen.Emit(OpCodes.Castclass, b.Type);
			}
			gen.MarkLabel(label);
		}

		private StackType GenerateUserdefinedLiftedAndAlso(ILGenerator gen, BinaryExpression b, StackType ask)
		{
			Type type = b.Left.Type;
			Type nonNullableType = GetNonNullableType(type);
			gen.DefineLabel();
			Label label = gen.DefineLabel();
			Label label2 = gen.DefineLabel();
			LocalBuilder local = gen.DeclareLocal(type);
			LocalBuilder local2 = gen.DeclareLocal(type);
			LocalBuilder local3 = gen.DeclareLocal(nonNullableType);
			LocalBuilder local4 = gen.DeclareLocal(nonNullableType);
			Generate(gen, b.Left, StackType.Value);
			gen.Emit(OpCodes.Stloc, local);
			Generate(gen, b.Right, StackType.Value);
			gen.Emit(OpCodes.Stloc, local2);
			gen.Emit(OpCodes.Ldloca, local);
			GenerateHasValue(gen, type);
			gen.Emit(OpCodes.Brfalse, label2);
			gen.Emit(OpCodes.Ldloca, local);
			GenerateGetValueOrDefault(gen, type);
			Type[] types = new Type[1] { nonNullableType };
			MethodInfo method = nonNullableType.GetMethod("op_False", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, types, null);
			gen.Emit(OpCodes.Call, method);
			gen.Emit(OpCodes.Brtrue, label2);
			gen.Emit(OpCodes.Ldloca, local2);
			GenerateHasValue(gen, type);
			gen.Emit(OpCodes.Brfalse, label);
			gen.Emit(OpCodes.Ldloca, local);
			GenerateGetValueOrDefault(gen, type);
			gen.Emit(OpCodes.Stloc, local3);
			gen.Emit(OpCodes.Ldloca, local2);
			GenerateGetValueOrDefault(gen, type);
			gen.Emit(OpCodes.Stloc, local4);
			types = new Type[2] { nonNullableType, nonNullableType };
			MethodInfo method2 = nonNullableType.GetMethod("op_BitwiseAnd", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, types, null);
			gen.Emit(OpCodes.Ldloc, local3);
			gen.Emit(OpCodes.Ldloc, local4);
			gen.Emit(OpCodes.Call, method2);
			if (method2.ReturnType != type)
			{
				GenerateConvertToType(gen, method2.ReturnType, type, isChecked: true);
			}
			gen.Emit(OpCodes.Stloc, local);
			gen.Emit(OpCodes.Br, label2);
			gen.MarkLabel(label);
			gen.Emit(OpCodes.Ldloc, local2);
			gen.Emit(OpCodes.Stloc, local);
			gen.MarkLabel(label2);
			return ReturnFromLocal(gen, ask, local);
		}

		private StackType GenerateLiftedAndAlso(ILGenerator gen, BinaryExpression b, StackType ask)
		{
			Type typeFromHandle = typeof(bool?);
			Label label = gen.DefineLabel();
			Label label2 = gen.DefineLabel();
			Label label3 = gen.DefineLabel();
			Label label4 = gen.DefineLabel();
			Label label5 = gen.DefineLabel();
			LocalBuilder local = gen.DeclareLocal(typeFromHandle);
			LocalBuilder local2 = gen.DeclareLocal(typeFromHandle);
			Generate(gen, b.Left, StackType.Value);
			gen.Emit(OpCodes.Stloc, local);
			gen.Emit(OpCodes.Ldloca, local);
			GenerateHasValue(gen, typeFromHandle);
			gen.Emit(OpCodes.Brfalse, label);
			gen.Emit(OpCodes.Ldloca, local);
			GenerateGetValueOrDefault(gen, typeFromHandle);
			gen.Emit(OpCodes.Ldc_I4_0);
			gen.Emit(OpCodes.Ceq);
			gen.Emit(OpCodes.Brtrue, label2);
			gen.MarkLabel(label);
			Generate(gen, b.Right, StackType.Value);
			gen.Emit(OpCodes.Stloc, local2);
			gen.Emit(OpCodes.Ldloca, local2);
			GenerateHasValue(gen, typeFromHandle);
			gen.Emit(OpCodes.Brfalse_S, label3);
			gen.Emit(OpCodes.Ldloca, local2);
			GenerateGetValueOrDefault(gen, typeFromHandle);
			gen.Emit(OpCodes.Ldc_I4_0);
			gen.Emit(OpCodes.Ceq);
			gen.Emit(OpCodes.Brtrue_S, label2);
			gen.Emit(OpCodes.Ldloca, local);
			GenerateHasValue(gen, typeFromHandle);
			gen.Emit(OpCodes.Brfalse, label3);
			gen.Emit(OpCodes.Ldc_I4_1);
			gen.Emit(OpCodes.Br_S, label4);
			gen.MarkLabel(label2);
			gen.Emit(OpCodes.Ldc_I4_0);
			gen.Emit(OpCodes.Br_S, label4);
			gen.MarkLabel(label4);
			ConstructorInfo constructor = typeFromHandle.GetConstructor(new Type[1] { typeof(bool) });
			gen.Emit(OpCodes.Newobj, constructor);
			gen.Emit(OpCodes.Stloc, local);
			gen.Emit(OpCodes.Br, label5);
			gen.MarkLabel(label3);
			gen.Emit(OpCodes.Ldloca, local);
			gen.Emit(OpCodes.Initobj, typeFromHandle);
			gen.MarkLabel(label5);
			return ReturnFromLocal(gen, ask, local);
		}

		private void GenerateMethodAndAlso(ILGenerator gen, BinaryExpression b)
		{
			Label label = gen.DefineLabel();
			Generate(gen, b.Left, StackType.Value);
			gen.Emit(OpCodes.Dup);
			Type parameterType = b.Method.GetParameters()[0].ParameterType;
			Type[] types = new Type[1] { parameterType };
			MethodInfo method = parameterType.GetMethod("op_False", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, types, null);
			gen.Emit(OpCodes.Call, method);
			gen.Emit(OpCodes.Brtrue, label);
			Generate(gen, b.Right, StackType.Value);
			gen.Emit(OpCodes.Call, b.Method);
			gen.MarkLabel(label);
		}

		private void GenerateUnliftedAndAlso(ILGenerator gen, BinaryExpression b)
		{
			Generate(gen, b.Left, StackType.Value);
			Label label = gen.DefineLabel();
			gen.Emit(OpCodes.Dup);
			gen.Emit(OpCodes.Brfalse, label);
			gen.Emit(OpCodes.Pop);
			Generate(gen, b.Right, StackType.Value);
			gen.MarkLabel(label);
		}

		private StackType GenerateAndAlso(ILGenerator gen, BinaryExpression b, StackType ask)
		{
			if (b.Method != null && !IsLiftedLogicalBinaryOperator(b.Left.Type, b.Right.Type, b.Method))
			{
				GenerateMethodAndAlso(gen, b);
			}
			else
			{
				if (b.Left.Type == typeof(bool?))
				{
					return GenerateLiftedAndAlso(gen, b, ask);
				}
				if (IsLiftedLogicalBinaryOperator(b.Left.Type, b.Right.Type, b.Method))
				{
					return GenerateUserdefinedLiftedAndAlso(gen, b, ask);
				}
				GenerateUnliftedAndAlso(gen, b);
			}
			return StackType.Value;
		}

		private static bool IsLiftedLogicalBinaryOperator(Type left, Type right, MethodInfo method)
		{
			if (right == left && IsNullable(left) && method != null)
			{
				return method.ReturnType == GetNonNullableType(left);
			}
			return false;
		}

		private StackType GenerateUserdefinedLiftedOrElse(ILGenerator gen, BinaryExpression b, StackType ask)
		{
			Type type = b.Left.Type;
			Type nonNullableType = GetNonNullableType(type);
			gen.DefineLabel();
			Label label = gen.DefineLabel();
			Label label2 = gen.DefineLabel();
			LocalBuilder local = gen.DeclareLocal(type);
			LocalBuilder local2 = gen.DeclareLocal(type);
			LocalBuilder local3 = gen.DeclareLocal(nonNullableType);
			LocalBuilder local4 = gen.DeclareLocal(nonNullableType);
			Generate(gen, b.Left, StackType.Value);
			gen.Emit(OpCodes.Stloc, local);
			Generate(gen, b.Right, StackType.Value);
			gen.Emit(OpCodes.Stloc, local2);
			gen.Emit(OpCodes.Ldloca, local);
			GenerateHasValue(gen, type);
			gen.Emit(OpCodes.Brfalse, label);
			gen.Emit(OpCodes.Ldloca, local);
			GenerateGetValueOrDefault(gen, type);
			Type[] types = new Type[1] { nonNullableType };
			MethodInfo method = nonNullableType.GetMethod("op_True", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, types, null);
			gen.Emit(OpCodes.Call, method);
			gen.Emit(OpCodes.Brtrue, label2);
			gen.Emit(OpCodes.Ldloca, local2);
			GenerateHasValue(gen, type);
			gen.Emit(OpCodes.Brfalse, label);
			gen.Emit(OpCodes.Ldloca, local);
			GenerateGetValueOrDefault(gen, type);
			gen.Emit(OpCodes.Stloc, local3);
			gen.Emit(OpCodes.Ldloca, local2);
			GenerateGetValueOrDefault(gen, type);
			gen.Emit(OpCodes.Stloc, local4);
			types = new Type[2] { nonNullableType, nonNullableType };
			MethodInfo method2 = nonNullableType.GetMethod("op_BitwiseOr", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, types, null);
			gen.Emit(OpCodes.Ldloc, local3);
			gen.Emit(OpCodes.Ldloc, local4);
			gen.Emit(OpCodes.Call, method2);
			if (method2.ReturnType != type)
			{
				GenerateConvertToType(gen, method2.ReturnType, type, isChecked: true);
			}
			gen.Emit(OpCodes.Stloc, local);
			gen.Emit(OpCodes.Br, label2);
			gen.MarkLabel(label);
			gen.Emit(OpCodes.Ldloc, local2);
			gen.Emit(OpCodes.Stloc, local);
			gen.MarkLabel(label2);
			return ReturnFromLocal(gen, ask, local);
		}

		private StackType GenerateLiftedOrElse(ILGenerator gen, BinaryExpression b, StackType ask)
		{
			Type typeFromHandle = typeof(bool?);
			Label label = gen.DefineLabel();
			Label label2 = gen.DefineLabel();
			Label label3 = gen.DefineLabel();
			Label label4 = gen.DefineLabel();
			Label label5 = gen.DefineLabel();
			LocalBuilder local = gen.DeclareLocal(typeFromHandle);
			LocalBuilder local2 = gen.DeclareLocal(typeFromHandle);
			Generate(gen, b.Left, StackType.Value);
			gen.Emit(OpCodes.Stloc, local);
			gen.Emit(OpCodes.Ldloca, local);
			GenerateHasValue(gen, typeFromHandle);
			gen.Emit(OpCodes.Brfalse, label);
			gen.Emit(OpCodes.Ldloca, local);
			GenerateGetValueOrDefault(gen, typeFromHandle);
			gen.Emit(OpCodes.Ldc_I4_0);
			gen.Emit(OpCodes.Ceq);
			gen.Emit(OpCodes.Brfalse, label2);
			gen.MarkLabel(label);
			Generate(gen, b.Right, StackType.Value);
			gen.Emit(OpCodes.Stloc, local2);
			gen.Emit(OpCodes.Ldloca, local2);
			GenerateHasValue(gen, typeFromHandle);
			gen.Emit(OpCodes.Brfalse_S, label3);
			gen.Emit(OpCodes.Ldloca, local2);
			GenerateGetValueOrDefault(gen, typeFromHandle);
			gen.Emit(OpCodes.Ldc_I4_0);
			gen.Emit(OpCodes.Ceq);
			gen.Emit(OpCodes.Brfalse_S, label2);
			gen.Emit(OpCodes.Ldloca, local);
			GenerateHasValue(gen, typeFromHandle);
			gen.Emit(OpCodes.Brfalse, label3);
			gen.Emit(OpCodes.Ldc_I4_0);
			gen.Emit(OpCodes.Br_S, label4);
			gen.MarkLabel(label2);
			gen.Emit(OpCodes.Ldc_I4_1);
			gen.Emit(OpCodes.Br_S, label4);
			gen.MarkLabel(label4);
			ConstructorInfo constructor = typeFromHandle.GetConstructor(new Type[1] { typeof(bool) });
			gen.Emit(OpCodes.Newobj, constructor);
			gen.Emit(OpCodes.Stloc, local);
			gen.Emit(OpCodes.Br, label5);
			gen.MarkLabel(label3);
			gen.Emit(OpCodes.Ldloca, local);
			gen.Emit(OpCodes.Initobj, typeFromHandle);
			gen.MarkLabel(label5);
			return ReturnFromLocal(gen, ask, local);
		}

		private void GenerateUnliftedOrElse(ILGenerator gen, BinaryExpression b)
		{
			Generate(gen, b.Left, StackType.Value);
			Label label = gen.DefineLabel();
			gen.Emit(OpCodes.Dup);
			gen.Emit(OpCodes.Brtrue, label);
			gen.Emit(OpCodes.Pop);
			Generate(gen, b.Right, StackType.Value);
			gen.MarkLabel(label);
		}

		private void GenerateMethodOrElse(ILGenerator gen, BinaryExpression b)
		{
			Label label = gen.DefineLabel();
			Generate(gen, b.Left, StackType.Value);
			gen.Emit(OpCodes.Dup);
			Type parameterType = b.Method.GetParameters()[0].ParameterType;
			Type[] types = new Type[1] { parameterType };
			MethodInfo method = parameterType.GetMethod("op_True", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, types, null);
			gen.Emit(OpCodes.Call, method);
			gen.Emit(OpCodes.Brtrue, label);
			Generate(gen, b.Right, StackType.Value);
			gen.Emit(OpCodes.Call, b.Method);
			gen.MarkLabel(label);
		}

		private StackType GenerateOrElse(ILGenerator gen, BinaryExpression b, StackType ask)
		{
			if (b.Method != null && !IsLiftedLogicalBinaryOperator(b.Left.Type, b.Right.Type, b.Method))
			{
				GenerateMethodOrElse(gen, b);
			}
			else
			{
				if (b.Left.Type == typeof(bool?))
				{
					return GenerateLiftedOrElse(gen, b, ask);
				}
				if (IsLiftedLogicalBinaryOperator(b.Left.Type, b.Right.Type, b.Method))
				{
					return GenerateUserdefinedLiftedOrElse(gen, b, ask);
				}
				GenerateUnliftedOrElse(gen, b);
			}
			return StackType.Value;
		}

		private static bool IsNullConstant(Expression e)
		{
			if (e.NodeType == ExpressionType.Constant)
			{
				return ((ConstantExpression)e).Value == null;
			}
			return false;
		}

		private StackType GenerateBinary(ILGenerator gen, BinaryExpression b, StackType ask)
		{
			switch (b.NodeType)
			{
			case ExpressionType.Coalesce:
				GenerateCoalesce(gen, b);
				return StackType.Value;
			case ExpressionType.AndAlso:
				return GenerateAndAlso(gen, b, ask);
			case ExpressionType.OrElse:
				return GenerateOrElse(gen, b, ask);
			default:
				if (b.Method != null)
				{
					return GenerateBinaryMethod(gen, b, ask);
				}
				if ((b.NodeType == ExpressionType.Equal || b.NodeType == ExpressionType.NotEqual) && (b.Type == typeof(bool) || b.Type == typeof(bool?)))
				{
					if (IsNullConstant(b.Left) && !IsNullConstant(b.Right) && IsNullable(b.Right.Type))
					{
						return GenerateNullEquality(gen, b.NodeType, b.Right, b.IsLiftedToNull);
					}
					if (IsNullConstant(b.Right) && !IsNullConstant(b.Left) && IsNullable(b.Left.Type))
					{
						return GenerateNullEquality(gen, b.NodeType, b.Left, b.IsLiftedToNull);
					}
				}
				Generate(gen, b.Left, StackType.Value);
				Generate(gen, b.Right, StackType.Value);
				return GenerateBinaryOp(gen, b.NodeType, b.Left.Type, b.Right.Type, b.Type, b.IsLiftedToNull, ask);
			}
		}

		private StackType GenerateNullEquality(ILGenerator gen, ExpressionType op, Expression e, bool isLiftedToNull)
		{
			Generate(gen, e, StackType.Value);
			if (isLiftedToNull)
			{
				gen.Emit(OpCodes.Pop);
				GenerateConstant(gen, Expression.Constant(null, typeof(bool?)), StackType.Value);
			}
			else
			{
				LocalBuilder local = gen.DeclareLocal(e.Type);
				gen.Emit(OpCodes.Stloc, local);
				gen.Emit(OpCodes.Ldloca, local);
				GenerateHasValue(gen, e.Type);
				if (op == ExpressionType.Equal)
				{
					gen.Emit(OpCodes.Ldc_I4_0);
					gen.Emit(OpCodes.Ceq);
				}
			}
			return StackType.Value;
		}

		private StackType GenerateBinaryMethod(ILGenerator gen, BinaryExpression b, StackType ask)
		{
			if (b.IsLifted)
			{
				ParameterExpression parameterExpression = Expression.Parameter(Expression.GetNonNullableType(b.Left.Type), null);
				ParameterExpression parameterExpression2 = Expression.Parameter(Expression.GetNonNullableType(b.Right.Type), null);
				MethodCallExpression methodCallExpression = Expression.Call(null, b.Method, parameterExpression, parameterExpression2);
				Type type = null;
				if (b.IsLiftedToNull)
				{
					type = Expression.GetNullableType(methodCallExpression.Type);
				}
				else
				{
					switch (b.NodeType)
					{
					case ExpressionType.Equal:
					case ExpressionType.GreaterThan:
					case ExpressionType.GreaterThanOrEqual:
					case ExpressionType.LessThan:
					case ExpressionType.LessThanOrEqual:
					case ExpressionType.NotEqual:
						if (methodCallExpression.Type != typeof(bool))
						{
							throw Error.ArgumentMustBeBoolean();
						}
						type = typeof(bool);
						break;
					default:
						type = Expression.GetNullableType(methodCallExpression.Type);
						break;
					}
				}
				IEnumerable<ParameterExpression> parameters = new ParameterExpression[2] { parameterExpression, parameterExpression2 };
				IEnumerable<Expression> arguments = new Expression[2] { b.Left, b.Right };
				Expression.ValidateLift(parameters, arguments);
				return GenerateLift(gen, b.NodeType, type, methodCallExpression, parameters, arguments);
			}
			MethodCallExpression node = Expression.Call(null, b.Method, b.Left, b.Right);
			return Generate(gen, node, ask);
		}

		private void GenerateTypeIs(ILGenerator gen, TypeBinaryExpression b)
		{
			Generate(gen, b.Expression, StackType.Value);
			if (b.Expression.Type == typeof(void))
			{
				gen.Emit(OpCodes.Ldc_I4_0);
				return;
			}
			if (b.Expression.Type.IsValueType)
			{
				gen.Emit(OpCodes.Box, b.Expression.Type);
			}
			gen.Emit(OpCodes.Isinst, b.TypeOperand);
			gen.Emit(OpCodes.Ldnull);
			gen.Emit(OpCodes.Cgt_Un);
		}

		private StackType GenerateHoistedLocalAccess(ILGenerator gen, int hoistIndex, Type type, StackType ask)
		{
			GenerateConstInt(gen, hoistIndex);
			gen.Emit(OpCodes.Ldelem_Ref);
			Type type2 = MakeStrongBoxType(type);
			gen.Emit(OpCodes.Castclass, type2);
			FieldInfo field = type2.GetField("Value", BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public);
			if (ask == StackType.Value)
			{
				gen.Emit(OpCodes.Ldfld, field);
			}
			else
			{
				gen.Emit(OpCodes.Ldflda, field);
			}
			return ask;
		}

		private StackType GenerateGlobalAccess(ILGenerator gen, int iGlobal, Type type, StackType ask)
		{
			GenerateLoadExecutionScope(gen);
			gen.Emit(OpCodes.Ldfld, typeof(ExecutionScope).GetField("Globals", BindingFlags.Instance | BindingFlags.Public));
			GenerateConstInt(gen, iGlobal);
			gen.Emit(OpCodes.Ldelem_Ref);
			Type type2 = MakeStrongBoxType(type);
			gen.Emit(OpCodes.Castclass, type2);
			FieldInfo field = type2.GetField("Value", BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public);
			if (ask == StackType.Value)
			{
				gen.Emit(OpCodes.Ldfld, field);
			}
			else
			{
				gen.Emit(OpCodes.Ldflda, field);
			}
			return ask;
		}

		private int AddGlobal(Type type, object value)
		{
			int count = globals.Count;
			globals.Add(Activator.CreateInstance(MakeStrongBoxType(type), value));
			return count;
		}

		private void GenerateCastToType(ILGenerator gen, Type typeFrom, Type typeTo)
		{
			if (!typeFrom.IsValueType && typeTo.IsValueType)
			{
				gen.Emit(OpCodes.Unbox_Any, typeTo);
			}
			else if (typeFrom.IsValueType && !typeTo.IsValueType)
			{
				gen.Emit(OpCodes.Box, typeFrom);
				if (typeTo != typeof(object))
				{
					gen.Emit(OpCodes.Castclass, typeTo);
				}
			}
			else
			{
				if (typeFrom.IsValueType || typeTo.IsValueType)
				{
					throw Error.InvalidCast(typeFrom, typeTo);
				}
				gen.Emit(OpCodes.Castclass, typeTo);
			}
		}

		private void GenerateNullableToNullableConversion(ILGenerator gen, Type typeFrom, Type typeTo, bool isChecked)
		{
			Label label = default(Label);
			Label label2 = default(Label);
			LocalBuilder localBuilder = null;
			LocalBuilder localBuilder2 = null;
			localBuilder = gen.DeclareLocal(typeFrom);
			gen.Emit(OpCodes.Stloc, localBuilder);
			localBuilder2 = gen.DeclareLocal(typeTo);
			gen.Emit(OpCodes.Ldloca, localBuilder);
			GenerateHasValue(gen, typeFrom);
			label = gen.DefineLabel();
			gen.Emit(OpCodes.Brfalse_S, label);
			gen.Emit(OpCodes.Ldloca, localBuilder);
			GenerateGetValueOrDefault(gen, typeFrom);
			Type nonNullableType = GetNonNullableType(typeFrom);
			Type nonNullableType2 = GetNonNullableType(typeTo);
			GenerateConvertToType(gen, nonNullableType, nonNullableType2, isChecked);
			ConstructorInfo constructor = typeTo.GetConstructor(new Type[1] { nonNullableType2 });
			gen.Emit(OpCodes.Newobj, constructor);
			gen.Emit(OpCodes.Stloc, localBuilder2);
			label2 = gen.DefineLabel();
			gen.Emit(OpCodes.Br_S, label2);
			gen.MarkLabel(label);
			gen.Emit(OpCodes.Ldloca, localBuilder2);
			gen.Emit(OpCodes.Initobj, typeTo);
			gen.MarkLabel(label2);
			gen.Emit(OpCodes.Ldloc, localBuilder2);
		}

		private void GenerateNonNullableToNullableConversion(ILGenerator gen, Type typeFrom, Type typeTo, bool isChecked)
		{
			LocalBuilder localBuilder = null;
			localBuilder = gen.DeclareLocal(typeTo);
			Type nonNullableType = GetNonNullableType(typeTo);
			GenerateConvertToType(gen, typeFrom, nonNullableType, isChecked);
			ConstructorInfo constructor = typeTo.GetConstructor(new Type[1] { nonNullableType });
			gen.Emit(OpCodes.Newobj, constructor);
			gen.Emit(OpCodes.Stloc, localBuilder);
			gen.Emit(OpCodes.Ldloc, localBuilder);
		}

		private void GenerateNullableToNonNullableConversion(ILGenerator gen, Type typeFrom, Type typeTo, bool isChecked)
		{
			if (typeTo.IsValueType)
			{
				GenerateNullableToNonNullableStructConversion(gen, typeFrom, typeTo, isChecked);
			}
			else
			{
				GenerateNullableToReferenceConversion(gen, typeFrom);
			}
		}

		private void GenerateNullableToNonNullableStructConversion(ILGenerator gen, Type typeFrom, Type typeTo, bool isChecked)
		{
			LocalBuilder localBuilder = null;
			localBuilder = gen.DeclareLocal(typeFrom);
			gen.Emit(OpCodes.Stloc, localBuilder);
			gen.Emit(OpCodes.Ldloca, localBuilder);
			GenerateGetValue(gen, typeFrom);
			Type nonNullableType = GetNonNullableType(typeFrom);
			GenerateConvertToType(gen, nonNullableType, typeTo, isChecked);
		}

		private void GenerateNullableToReferenceConversion(ILGenerator gen, Type typeFrom)
		{
			gen.Emit(OpCodes.Box, typeFrom);
		}

		private void GenerateNullableConversion(ILGenerator gen, Type typeFrom, Type typeTo, bool isChecked)
		{
			bool flag = IsNullable(typeFrom);
			bool flag2 = IsNullable(typeTo);
			if (flag && flag2)
			{
				GenerateNullableToNullableConversion(gen, typeFrom, typeTo, isChecked);
			}
			else if (flag)
			{
				GenerateNullableToNonNullableConversion(gen, typeFrom, typeTo, isChecked);
			}
			else
			{
				GenerateNonNullableToNullableConversion(gen, typeFrom, typeTo, isChecked);
			}
		}

		private void GenerateNumericConversion(ILGenerator gen, Type typeFrom, Type typeTo, bool isChecked)
		{
			bool flag = IsUnsigned(typeFrom);
			IsFloatingPoint(typeFrom);
			if (typeTo == typeof(float))
			{
				if (flag)
				{
					gen.Emit(OpCodes.Conv_R_Un);
				}
				gen.Emit(OpCodes.Conv_R4);
				return;
			}
			if (typeTo == typeof(double))
			{
				if (flag)
				{
					gen.Emit(OpCodes.Conv_R_Un);
				}
				gen.Emit(OpCodes.Conv_R8);
				return;
			}
			TypeCode typeCode = Type.GetTypeCode(typeTo);
			if (isChecked)
			{
				if (flag)
				{
					switch (typeCode)
					{
					case TypeCode.SByte:
						gen.Emit(OpCodes.Conv_Ovf_I1_Un);
						break;
					case TypeCode.Int16:
						gen.Emit(OpCodes.Conv_Ovf_I2_Un);
						break;
					case TypeCode.Int32:
						gen.Emit(OpCodes.Conv_Ovf_I4_Un);
						break;
					case TypeCode.Int64:
						gen.Emit(OpCodes.Conv_Ovf_I8_Un);
						break;
					case TypeCode.Byte:
						gen.Emit(OpCodes.Conv_Ovf_U1_Un);
						break;
					case TypeCode.Char:
					case TypeCode.UInt16:
						gen.Emit(OpCodes.Conv_Ovf_U2_Un);
						break;
					case TypeCode.UInt32:
						gen.Emit(OpCodes.Conv_Ovf_U4_Un);
						break;
					case TypeCode.UInt64:
						gen.Emit(OpCodes.Conv_Ovf_U8_Un);
						break;
					default:
						throw Error.UnhandledConvert(typeTo);
					}
				}
				else
				{
					switch (typeCode)
					{
					case TypeCode.SByte:
						gen.Emit(OpCodes.Conv_Ovf_I1);
						break;
					case TypeCode.Int16:
						gen.Emit(OpCodes.Conv_Ovf_I2);
						break;
					case TypeCode.Int32:
						gen.Emit(OpCodes.Conv_Ovf_I4);
						break;
					case TypeCode.Int64:
						gen.Emit(OpCodes.Conv_Ovf_I8);
						break;
					case TypeCode.Byte:
						gen.Emit(OpCodes.Conv_Ovf_U1);
						break;
					case TypeCode.Char:
					case TypeCode.UInt16:
						gen.Emit(OpCodes.Conv_Ovf_U2);
						break;
					case TypeCode.UInt32:
						gen.Emit(OpCodes.Conv_Ovf_U4);
						break;
					case TypeCode.UInt64:
						gen.Emit(OpCodes.Conv_Ovf_U8);
						break;
					default:
						throw Error.UnhandledConvert(typeTo);
					}
				}
			}
			else if (flag)
			{
				switch (typeCode)
				{
				case TypeCode.SByte:
				case TypeCode.Byte:
					gen.Emit(OpCodes.Conv_U1);
					break;
				case TypeCode.Char:
				case TypeCode.Int16:
				case TypeCode.UInt16:
					gen.Emit(OpCodes.Conv_U2);
					break;
				case TypeCode.Int32:
				case TypeCode.UInt32:
					gen.Emit(OpCodes.Conv_U4);
					break;
				case TypeCode.Int64:
				case TypeCode.UInt64:
					gen.Emit(OpCodes.Conv_U8);
					break;
				default:
					throw Error.UnhandledConvert(typeTo);
				}
			}
			else
			{
				switch (typeCode)
				{
				case TypeCode.SByte:
				case TypeCode.Byte:
					gen.Emit(OpCodes.Conv_I1);
					break;
				case TypeCode.Char:
				case TypeCode.Int16:
				case TypeCode.UInt16:
					gen.Emit(OpCodes.Conv_I2);
					break;
				case TypeCode.Int32:
				case TypeCode.UInt32:
					gen.Emit(OpCodes.Conv_I4);
					break;
				case TypeCode.Int64:
				case TypeCode.UInt64:
					gen.Emit(OpCodes.Conv_I8);
					break;
				default:
					throw Error.UnhandledConvert(typeTo);
				}
			}
		}

		private void GenerateConvertToType(ILGenerator gen, Type typeFrom, Type typeTo, bool isChecked)
		{
			if (typeFrom != typeTo)
			{
				bool flag = IsNullable(typeFrom);
				bool flag2 = IsNullable(typeTo);
				Type nonNullableType = GetNonNullableType(typeFrom);
				Type nonNullableType2 = GetNonNullableType(typeTo);
				if (typeFrom.IsInterface || typeTo.IsInterface || typeFrom == typeof(object) || typeTo == typeof(object))
				{
					GenerateCastToType(gen, typeFrom, typeTo);
				}
				else if (flag || flag2)
				{
					GenerateNullableConversion(gen, typeFrom, typeTo, isChecked);
				}
				else if ((!IsConvertible(typeFrom) || !IsConvertible(typeTo)) && (nonNullableType.IsAssignableFrom(nonNullableType2) || nonNullableType2.IsAssignableFrom(nonNullableType)))
				{
					GenerateCastToType(gen, typeFrom, typeTo);
				}
				else if (typeFrom.IsArray && typeTo.IsArray)
				{
					GenerateCastToType(gen, typeFrom, typeTo);
				}
				else
				{
					GenerateNumericConversion(gen, typeFrom, typeTo, isChecked);
				}
			}
		}

		private StackType ReturnFromLocal(ILGenerator gen, StackType ask, LocalBuilder local)
		{
			if (ask == StackType.Address)
			{
				gen.Emit(OpCodes.Ldloca, local);
			}
			else
			{
				gen.Emit(OpCodes.Ldloc, local);
			}
			return ask;
		}

		private StackType GenerateUnaryOp(ILGenerator gen, ExpressionType op, Type operandType, Type resultType, StackType ask)
		{
			bool flag = IsNullable(operandType);
			if (op == ExpressionType.ArrayLength)
			{
				gen.Emit(OpCodes.Ldlen);
				return StackType.Value;
			}
			if (flag)
			{
				switch (op)
				{
				case ExpressionType.Not:
					if (operandType == typeof(bool?))
					{
						gen.DefineLabel();
						Label label3 = gen.DefineLabel();
						LocalBuilder local2 = gen.DeclareLocal(operandType);
						gen.Emit(OpCodes.Stloc, local2);
						gen.Emit(OpCodes.Ldloca, local2);
						GenerateHasValue(gen, operandType);
						gen.Emit(OpCodes.Brfalse_S, label3);
						gen.Emit(OpCodes.Ldloca, local2);
						GenerateGetValueOrDefault(gen, operandType);
						Type nonNullableType2 = GetNonNullableType(operandType);
						GenerateUnaryOp(gen, op, nonNullableType2, typeof(bool), StackType.Value);
						ConstructorInfo constructor2 = resultType.GetConstructor(new Type[1] { typeof(bool) });
						gen.Emit(OpCodes.Newobj, constructor2);
						gen.Emit(OpCodes.Stloc, local2);
						gen.MarkLabel(label3);
						return ReturnFromLocal(gen, ask, local2);
					}
					goto case ExpressionType.Negate;
				case ExpressionType.Negate:
				case ExpressionType.UnaryPlus:
				case ExpressionType.NegateChecked:
				{
					Label label = gen.DefineLabel();
					Label label2 = gen.DefineLabel();
					LocalBuilder local = gen.DeclareLocal(operandType);
					gen.Emit(OpCodes.Stloc, local);
					gen.Emit(OpCodes.Ldloca, local);
					GenerateHasValue(gen, operandType);
					gen.Emit(OpCodes.Brfalse_S, label);
					gen.Emit(OpCodes.Ldloca, local);
					GenerateGetValueOrDefault(gen, operandType);
					Type nonNullableType = GetNonNullableType(resultType);
					GenerateUnaryOp(gen, op, nonNullableType, nonNullableType, StackType.Value);
					ConstructorInfo constructor = resultType.GetConstructor(new Type[1] { nonNullableType });
					gen.Emit(OpCodes.Newobj, constructor);
					gen.Emit(OpCodes.Stloc, local);
					gen.Emit(OpCodes.Br_S, label2);
					gen.MarkLabel(label);
					gen.Emit(OpCodes.Ldloca, local);
					gen.Emit(OpCodes.Initobj, resultType);
					gen.MarkLabel(label2);
					return ReturnFromLocal(gen, ask, local);
				}
				case ExpressionType.TypeAs:
					gen.Emit(OpCodes.Box, operandType);
					gen.Emit(OpCodes.Isinst, resultType);
					if (IsNullable(resultType))
					{
						gen.Emit(OpCodes.Unbox_Any, resultType);
					}
					return StackType.Value;
				default:
					throw Error.UnhandledUnary(op);
				}
			}
			switch (op)
			{
			case ExpressionType.Not:
				if (operandType == typeof(bool))
				{
					gen.Emit(OpCodes.Ldc_I4_0);
					gen.Emit(OpCodes.Ceq);
				}
				else
				{
					gen.Emit(OpCodes.Not);
				}
				break;
			case ExpressionType.UnaryPlus:
				gen.Emit(OpCodes.Nop);
				break;
			case ExpressionType.Negate:
			case ExpressionType.NegateChecked:
				gen.Emit(OpCodes.Neg);
				break;
			case ExpressionType.TypeAs:
				if (operandType.IsValueType)
				{
					gen.Emit(OpCodes.Box, operandType);
				}
				gen.Emit(OpCodes.Isinst, resultType);
				if (IsNullable(resultType))
				{
					gen.Emit(OpCodes.Unbox_Any, resultType);
				}
				break;
			default:
				throw Error.UnhandledUnary(op);
			}
			return StackType.Value;
		}

		private StackType GenerateLiftedBinaryArithmetic(ILGenerator gen, ExpressionType op, Type leftType, Type rightType, Type resultType, StackType ask)
		{
			bool flag = IsNullable(leftType);
			bool flag2 = IsNullable(rightType);
			Label label = gen.DefineLabel();
			Label label2 = gen.DefineLabel();
			LocalBuilder local = gen.DeclareLocal(leftType);
			LocalBuilder local2 = gen.DeclareLocal(rightType);
			LocalBuilder local3 = gen.DeclareLocal(resultType);
			gen.Emit(OpCodes.Stloc, local2);
			gen.Emit(OpCodes.Stloc, local);
			if (flag && flag2)
			{
				gen.Emit(OpCodes.Ldloca, local);
				GenerateHasValue(gen, leftType);
				gen.Emit(OpCodes.Ldloca, local2);
				GenerateHasValue(gen, rightType);
				gen.Emit(OpCodes.And);
				gen.Emit(OpCodes.Brfalse_S, label);
			}
			else if (flag)
			{
				gen.Emit(OpCodes.Ldloca, local);
				GenerateHasValue(gen, leftType);
				gen.Emit(OpCodes.Brfalse_S, label);
			}
			else if (flag2)
			{
				gen.Emit(OpCodes.Ldloca, local2);
				GenerateHasValue(gen, rightType);
				gen.Emit(OpCodes.Brfalse_S, label);
			}
			if (flag)
			{
				gen.Emit(OpCodes.Ldloca, local);
				GenerateGetValueOrDefault(gen, leftType);
			}
			else
			{
				gen.Emit(OpCodes.Ldloc, local);
			}
			if (flag2)
			{
				gen.Emit(OpCodes.Ldloca, local2);
				GenerateGetValueOrDefault(gen, rightType);
			}
			else
			{
				gen.Emit(OpCodes.Ldloc, local2);
			}
			GenerateBinaryOp(gen, op, GetNonNullableType(leftType), GetNonNullableType(rightType), GetNonNullableType(resultType), liftedToNull: false, StackType.Value);
			ConstructorInfo constructor = resultType.GetConstructor(new Type[1] { GetNonNullableType(resultType) });
			gen.Emit(OpCodes.Newobj, constructor);
			gen.Emit(OpCodes.Stloc, local3);
			gen.Emit(OpCodes.Br_S, label2);
			gen.MarkLabel(label);
			gen.Emit(OpCodes.Ldloca, local3);
			gen.Emit(OpCodes.Initobj, resultType);
			gen.MarkLabel(label2);
			return ReturnFromLocal(gen, ask, local3);
		}

		private StackType GenerateLiftedRelational(ILGenerator gen, ExpressionType op, Type leftType, Type rightType, Type resultType, bool liftedToNull, StackType ask)
		{
			Label label = gen.DefineLabel();
			Label label2 = gen.DefineLabel();
			Label label3 = gen.DefineLabel();
			LocalBuilder local = gen.DeclareLocal(leftType);
			LocalBuilder local2 = gen.DeclareLocal(rightType);
			gen.Emit(OpCodes.Stloc, local2);
			gen.Emit(OpCodes.Stloc, local);
			switch (op)
			{
			case ExpressionType.Equal:
				gen.Emit(OpCodes.Ldloca, local);
				GenerateHasValue(gen, leftType);
				gen.Emit(OpCodes.Ldc_I4_0);
				gen.Emit(OpCodes.Ceq);
				gen.Emit(OpCodes.Ldloca, local2);
				GenerateHasValue(gen, rightType);
				gen.Emit(OpCodes.Ldc_I4_0);
				gen.Emit(OpCodes.Ceq);
				gen.Emit(OpCodes.And);
				gen.Emit(OpCodes.Dup);
				if (liftedToNull)
				{
					gen.Emit(OpCodes.Brtrue_S, label);
				}
				else
				{
					gen.Emit(OpCodes.Brtrue_S, label2);
				}
				gen.Emit(OpCodes.Pop);
				gen.Emit(OpCodes.Ldloca, local);
				GenerateHasValue(gen, leftType);
				gen.Emit(OpCodes.Ldloca, local2);
				GenerateHasValue(gen, rightType);
				gen.Emit(OpCodes.And);
				gen.Emit(OpCodes.Dup);
				if (liftedToNull)
				{
					gen.Emit(OpCodes.Brfalse_S, label);
				}
				else
				{
					gen.Emit(OpCodes.Brfalse_S, label2);
				}
				gen.Emit(OpCodes.Pop);
				break;
			case ExpressionType.NotEqual:
				gen.Emit(OpCodes.Ldloca, local);
				GenerateHasValue(gen, leftType);
				gen.Emit(OpCodes.Ldloca, local2);
				GenerateHasValue(gen, rightType);
				gen.Emit(OpCodes.Or);
				gen.Emit(OpCodes.Dup);
				if (liftedToNull)
				{
					gen.Emit(OpCodes.Brfalse_S, label);
				}
				else
				{
					gen.Emit(OpCodes.Brfalse_S, label2);
				}
				gen.Emit(OpCodes.Pop);
				gen.Emit(OpCodes.Ldloca, local);
				GenerateHasValue(gen, leftType);
				gen.Emit(OpCodes.Ldc_I4_0);
				gen.Emit(OpCodes.Ceq);
				gen.Emit(OpCodes.Ldloca, local2);
				GenerateHasValue(gen, rightType);
				gen.Emit(OpCodes.Ldc_I4_0);
				gen.Emit(OpCodes.Ceq);
				gen.Emit(OpCodes.Or);
				gen.Emit(OpCodes.Dup);
				if (liftedToNull)
				{
					gen.Emit(OpCodes.Brtrue_S, label);
				}
				else
				{
					gen.Emit(OpCodes.Brtrue_S, label2);
				}
				gen.Emit(OpCodes.Pop);
				break;
			default:
				gen.Emit(OpCodes.Ldloca, local);
				GenerateHasValue(gen, leftType);
				gen.Emit(OpCodes.Ldloca, local2);
				GenerateHasValue(gen, rightType);
				gen.Emit(OpCodes.And);
				gen.Emit(OpCodes.Dup);
				if (liftedToNull)
				{
					gen.Emit(OpCodes.Brfalse_S, label);
				}
				else
				{
					gen.Emit(OpCodes.Brfalse_S, label2);
				}
				gen.Emit(OpCodes.Pop);
				break;
			}
			gen.Emit(OpCodes.Ldloca, local);
			GenerateGetValueOrDefault(gen, leftType);
			gen.Emit(OpCodes.Ldloca, local2);
			GenerateGetValueOrDefault(gen, rightType);
			StackType result = GenerateBinaryOp(gen, op, GetNonNullableType(leftType), GetNonNullableType(rightType), GetNonNullableType(resultType), liftedToNull: false, ask);
			gen.MarkLabel(label2);
			if (resultType != GetNonNullableType(resultType))
			{
				GenerateConvertToType(gen, GetNonNullableType(resultType), resultType, isChecked: true);
			}
			gen.Emit(OpCodes.Br, label3);
			gen.MarkLabel(label);
			gen.Emit(OpCodes.Pop);
			gen.Emit(OpCodes.Ldnull);
			gen.Emit(OpCodes.Unbox_Any, resultType);
			gen.MarkLabel(label3);
			return result;
		}

		private StackType GenerateLiftedBooleanAnd(ILGenerator gen, StackType ask)
		{
			Type typeFromHandle = typeof(bool?);
			Label label = gen.DefineLabel();
			Label label2 = gen.DefineLabel();
			Label label3 = gen.DefineLabel();
			Label label4 = gen.DefineLabel();
			Label label5 = gen.DefineLabel();
			LocalBuilder local = gen.DeclareLocal(typeFromHandle);
			LocalBuilder local2 = gen.DeclareLocal(typeFromHandle);
			gen.Emit(OpCodes.Stloc, local2);
			gen.Emit(OpCodes.Stloc, local);
			gen.Emit(OpCodes.Ldloca, local);
			GenerateHasValue(gen, typeFromHandle);
			gen.Emit(OpCodes.Brfalse, label);
			gen.Emit(OpCodes.Ldloca, local);
			GenerateGetValueOrDefault(gen, typeFromHandle);
			gen.Emit(OpCodes.Ldc_I4_0);
			gen.Emit(OpCodes.Ceq);
			gen.Emit(OpCodes.Brtrue, label2);
			gen.MarkLabel(label);
			gen.Emit(OpCodes.Ldloca, local2);
			GenerateHasValue(gen, typeFromHandle);
			gen.Emit(OpCodes.Brfalse_S, label3);
			gen.Emit(OpCodes.Ldloca, local2);
			GenerateGetValueOrDefault(gen, typeFromHandle);
			gen.Emit(OpCodes.Ldc_I4_0);
			gen.Emit(OpCodes.Ceq);
			gen.Emit(OpCodes.Brtrue_S, label2);
			gen.Emit(OpCodes.Ldloca, local);
			GenerateHasValue(gen, typeFromHandle);
			gen.Emit(OpCodes.Brfalse, label3);
			gen.Emit(OpCodes.Ldc_I4_1);
			gen.Emit(OpCodes.Br_S, label4);
			gen.MarkLabel(label2);
			gen.Emit(OpCodes.Ldc_I4_0);
			gen.Emit(OpCodes.Br_S, label4);
			gen.MarkLabel(label4);
			ConstructorInfo constructor = typeFromHandle.GetConstructor(new Type[1] { typeof(bool) });
			gen.Emit(OpCodes.Newobj, constructor);
			gen.Emit(OpCodes.Stloc, local);
			gen.Emit(OpCodes.Br, label5);
			gen.MarkLabel(label3);
			gen.Emit(OpCodes.Ldloca, local);
			gen.Emit(OpCodes.Initobj, typeFromHandle);
			gen.MarkLabel(label5);
			return ReturnFromLocal(gen, ask, local);
		}

		private StackType GenerateLiftedBooleanOr(ILGenerator gen, StackType ask)
		{
			Type typeFromHandle = typeof(bool?);
			Label label = gen.DefineLabel();
			Label label2 = gen.DefineLabel();
			Label label3 = gen.DefineLabel();
			Label label4 = gen.DefineLabel();
			Label label5 = gen.DefineLabel();
			LocalBuilder local = gen.DeclareLocal(typeFromHandle);
			LocalBuilder local2 = gen.DeclareLocal(typeFromHandle);
			gen.Emit(OpCodes.Stloc, local2);
			gen.Emit(OpCodes.Stloc, local);
			gen.Emit(OpCodes.Ldloca, local);
			GenerateHasValue(gen, typeFromHandle);
			gen.Emit(OpCodes.Brfalse, label);
			gen.Emit(OpCodes.Ldloca, local);
			GenerateGetValueOrDefault(gen, typeFromHandle);
			gen.Emit(OpCodes.Ldc_I4_0);
			gen.Emit(OpCodes.Ceq);
			gen.Emit(OpCodes.Brfalse, label2);
			gen.MarkLabel(label);
			gen.Emit(OpCodes.Ldloca, local2);
			GenerateHasValue(gen, typeFromHandle);
			gen.Emit(OpCodes.Brfalse_S, label3);
			gen.Emit(OpCodes.Ldloca, local2);
			GenerateGetValueOrDefault(gen, typeFromHandle);
			gen.Emit(OpCodes.Ldc_I4_0);
			gen.Emit(OpCodes.Ceq);
			gen.Emit(OpCodes.Brfalse_S, label2);
			gen.Emit(OpCodes.Ldloca, local);
			GenerateHasValue(gen, typeFromHandle);
			gen.Emit(OpCodes.Brfalse, label3);
			gen.Emit(OpCodes.Ldc_I4_0);
			gen.Emit(OpCodes.Br_S, label4);
			gen.MarkLabel(label2);
			gen.Emit(OpCodes.Ldc_I4_1);
			gen.Emit(OpCodes.Br_S, label4);
			gen.MarkLabel(label4);
			ConstructorInfo constructor = typeFromHandle.GetConstructor(new Type[1] { typeof(bool) });
			gen.Emit(OpCodes.Newobj, constructor);
			gen.Emit(OpCodes.Stloc, local);
			gen.Emit(OpCodes.Br, label5);
			gen.MarkLabel(label3);
			gen.Emit(OpCodes.Ldloca, local);
			gen.Emit(OpCodes.Initobj, typeFromHandle);
			gen.MarkLabel(label5);
			return ReturnFromLocal(gen, ask, local);
		}

		private StackType GenerateLiftedBinaryOp(ILGenerator gen, ExpressionType op, Type leftType, Type rightType, Type resultType, bool liftedToNull, StackType ask)
		{
			switch (op)
			{
			case ExpressionType.And:
				if (leftType == typeof(bool?))
				{
					return GenerateLiftedBooleanAnd(gen, ask);
				}
				return GenerateLiftedBinaryArithmetic(gen, op, leftType, rightType, resultType, ask);
			case ExpressionType.Or:
				if (leftType == typeof(bool?))
				{
					return GenerateLiftedBooleanOr(gen, ask);
				}
				return GenerateLiftedBinaryArithmetic(gen, op, leftType, rightType, resultType, ask);
			case ExpressionType.Add:
			case ExpressionType.AddChecked:
			case ExpressionType.Divide:
			case ExpressionType.ExclusiveOr:
			case ExpressionType.LeftShift:
			case ExpressionType.Modulo:
			case ExpressionType.Multiply:
			case ExpressionType.MultiplyChecked:
			case ExpressionType.RightShift:
			case ExpressionType.Subtract:
			case ExpressionType.SubtractChecked:
				return GenerateLiftedBinaryArithmetic(gen, op, leftType, rightType, resultType, ask);
			case ExpressionType.Equal:
			case ExpressionType.GreaterThan:
			case ExpressionType.GreaterThanOrEqual:
			case ExpressionType.LessThan:
			case ExpressionType.LessThanOrEqual:
			case ExpressionType.NotEqual:
				return GenerateLiftedRelational(gen, op, leftType, rightType, resultType, liftedToNull, ask);
			default:
				return StackType.Value;
			}
		}

		private static void GenerateUnliftedEquality(ILGenerator gen, ExpressionType op, Type type)
		{
			if (!type.IsPrimitive && type.IsValueType && !type.IsEnum)
			{
				throw Error.OperatorNotImplementedForType(op, type);
			}
			gen.Emit(OpCodes.Ceq);
			if (op == ExpressionType.NotEqual)
			{
				gen.Emit(OpCodes.Ldc_I4_0);
				gen.Emit(OpCodes.Ceq);
			}
		}

		private StackType GenerateUnliftedBinaryOp(ILGenerator gen, ExpressionType op, Type leftType, Type rightType)
		{
			if (op == ExpressionType.Equal || op == ExpressionType.NotEqual)
			{
				GenerateUnliftedEquality(gen, op, leftType);
				return StackType.Value;
			}
			if (!leftType.IsPrimitive)
			{
				throw Error.OperatorNotImplementedForType(op, leftType);
			}
			switch (op)
			{
			case ExpressionType.Add:
				gen.Emit(OpCodes.Add);
				break;
			case ExpressionType.AddChecked:
			{
				LocalBuilder local = gen.DeclareLocal(leftType);
				LocalBuilder local2 = gen.DeclareLocal(rightType);
				gen.Emit(OpCodes.Stloc, local2);
				gen.Emit(OpCodes.Stloc, local);
				gen.Emit(OpCodes.Ldloc, local);
				gen.Emit(OpCodes.Ldloc, local2);
				if (IsFloatingPoint(leftType))
				{
					gen.Emit(OpCodes.Add);
				}
				else if (IsUnsigned(leftType))
				{
					gen.Emit(OpCodes.Add_Ovf_Un);
				}
				else
				{
					gen.Emit(OpCodes.Add_Ovf);
				}
				break;
			}
			case ExpressionType.Subtract:
				gen.Emit(OpCodes.Sub);
				break;
			case ExpressionType.SubtractChecked:
			{
				LocalBuilder local3 = gen.DeclareLocal(leftType);
				LocalBuilder local4 = gen.DeclareLocal(rightType);
				gen.Emit(OpCodes.Stloc, local4);
				gen.Emit(OpCodes.Stloc, local3);
				gen.Emit(OpCodes.Ldloc, local3);
				gen.Emit(OpCodes.Ldloc, local4);
				if (IsFloatingPoint(leftType))
				{
					gen.Emit(OpCodes.Sub);
				}
				else if (IsUnsigned(leftType))
				{
					gen.Emit(OpCodes.Sub_Ovf_Un);
				}
				else
				{
					gen.Emit(OpCodes.Sub_Ovf);
				}
				break;
			}
			case ExpressionType.Multiply:
				gen.Emit(OpCodes.Mul);
				break;
			case ExpressionType.MultiplyChecked:
			{
				LocalBuilder local5 = gen.DeclareLocal(leftType);
				LocalBuilder local6 = gen.DeclareLocal(rightType);
				gen.Emit(OpCodes.Stloc, local6);
				gen.Emit(OpCodes.Stloc, local5);
				gen.Emit(OpCodes.Ldloc, local5);
				gen.Emit(OpCodes.Ldloc, local6);
				if (IsFloatingPoint(leftType))
				{
					gen.Emit(OpCodes.Mul);
				}
				else if (IsUnsigned(leftType))
				{
					gen.Emit(OpCodes.Mul_Ovf_Un);
				}
				else
				{
					gen.Emit(OpCodes.Mul_Ovf);
				}
				break;
			}
			case ExpressionType.Divide:
				if (IsUnsigned(leftType))
				{
					gen.Emit(OpCodes.Div_Un);
				}
				else
				{
					gen.Emit(OpCodes.Div);
				}
				break;
			case ExpressionType.Modulo:
				if (IsUnsigned(leftType))
				{
					gen.Emit(OpCodes.Rem_Un);
				}
				else
				{
					gen.Emit(OpCodes.Rem);
				}
				break;
			case ExpressionType.And:
			case ExpressionType.AndAlso:
				gen.Emit(OpCodes.And);
				break;
			case ExpressionType.Or:
			case ExpressionType.OrElse:
				gen.Emit(OpCodes.Or);
				break;
			case ExpressionType.LessThan:
				if (IsUnsigned(leftType))
				{
					gen.Emit(OpCodes.Clt_Un);
				}
				else
				{
					gen.Emit(OpCodes.Clt);
				}
				break;
			case ExpressionType.LessThanOrEqual:
			{
				Label label3 = gen.DefineLabel();
				Label label4 = gen.DefineLabel();
				if (IsUnsigned(leftType))
				{
					gen.Emit(OpCodes.Ble_Un_S, label3);
				}
				else
				{
					gen.Emit(OpCodes.Ble_S, label3);
				}
				gen.Emit(OpCodes.Ldc_I4_0);
				gen.Emit(OpCodes.Br_S, label4);
				gen.MarkLabel(label3);
				gen.Emit(OpCodes.Ldc_I4_1);
				gen.MarkLabel(label4);
				break;
			}
			case ExpressionType.GreaterThan:
				if (IsUnsigned(leftType))
				{
					gen.Emit(OpCodes.Cgt_Un);
				}
				else
				{
					gen.Emit(OpCodes.Cgt);
				}
				break;
			case ExpressionType.GreaterThanOrEqual:
			{
				Label label = gen.DefineLabel();
				Label label2 = gen.DefineLabel();
				if (IsUnsigned(leftType))
				{
					gen.Emit(OpCodes.Bge_Un_S, label);
				}
				else
				{
					gen.Emit(OpCodes.Bge_S, label);
				}
				gen.Emit(OpCodes.Ldc_I4_0);
				gen.Emit(OpCodes.Br_S, label2);
				gen.MarkLabel(label);
				gen.Emit(OpCodes.Ldc_I4_1);
				gen.MarkLabel(label2);
				break;
			}
			case ExpressionType.ExclusiveOr:
				gen.Emit(OpCodes.Xor);
				break;
			case ExpressionType.LeftShift:
			{
				Type nonNullableType2 = GetNonNullableType(rightType);
				if (nonNullableType2 != typeof(int))
				{
					GenerateConvertToType(gen, nonNullableType2, typeof(int), isChecked: true);
				}
				gen.Emit(OpCodes.Shl);
				break;
			}
			case ExpressionType.RightShift:
			{
				Type nonNullableType = GetNonNullableType(rightType);
				if (nonNullableType != typeof(int))
				{
					GenerateConvertToType(gen, nonNullableType, typeof(int), isChecked: true);
				}
				if (IsUnsigned(leftType))
				{
					gen.Emit(OpCodes.Shr_Un);
				}
				else
				{
					gen.Emit(OpCodes.Shr);
				}
				break;
			}
			default:
				throw Error.UnhandledBinary(op);
			}
			return StackType.Value;
		}

		private StackType GenerateBinaryOp(ILGenerator gen, ExpressionType op, Type leftType, Type rightType, Type resultType, bool liftedToNull, StackType ask)
		{
			bool flag = IsNullable(leftType);
			bool flag2 = IsNullable(rightType);
			switch (op)
			{
			case ExpressionType.ArrayIndex:
			{
				if (flag2)
				{
					LocalBuilder local = gen.DeclareLocal(rightType);
					gen.Emit(OpCodes.Stloc, local);
					gen.Emit(OpCodes.Ldloca, local);
					GenerateGetValue(gen, rightType);
				}
				Type nonNullableType = GetNonNullableType(rightType);
				if (nonNullableType != typeof(int))
				{
					GenerateConvertToType(gen, nonNullableType, typeof(int), isChecked: true);
				}
				return GenerateArrayAccess(gen, leftType.GetElementType(), ask);
			}
			case ExpressionType.Coalesce:
				throw Error.UnexpectedCoalesceOperator();
			default:
				if (flag)
				{
					return GenerateLiftedBinaryOp(gen, op, leftType, rightType, resultType, liftedToNull, ask);
				}
				return GenerateUnliftedBinaryOp(gen, op, leftType, rightType);
			}
		}

		private StackType GenerateArgAccess(ILGenerator gen, int iArg, StackType ask)
		{
			if (ask == StackType.Value)
			{
				switch (iArg)
				{
				case 0:
					gen.Emit(OpCodes.Ldarg_0);
					break;
				case 1:
					gen.Emit(OpCodes.Ldarg_1);
					break;
				case 2:
					gen.Emit(OpCodes.Ldarg_2);
					break;
				case 3:
					gen.Emit(OpCodes.Ldarg_3);
					break;
				default:
					if (iArg < 128)
					{
						gen.Emit(OpCodes.Ldarg_S, (byte)iArg);
					}
					else
					{
						gen.Emit(OpCodes.Ldarg, iArg);
					}
					break;
				}
			}
			else if (iArg < 128)
			{
				gen.Emit(OpCodes.Ldarga_S, (byte)iArg);
			}
			else
			{
				gen.Emit(OpCodes.Ldarga, iArg);
			}
			return ask;
		}

		private void GenerateConstInt(ILGenerator gen, int value)
		{
			switch (value)
			{
			case 0:
				gen.Emit(OpCodes.Ldc_I4_0);
				return;
			case 1:
				gen.Emit(OpCodes.Ldc_I4_1);
				return;
			case 2:
				gen.Emit(OpCodes.Ldc_I4_2);
				return;
			case 3:
				gen.Emit(OpCodes.Ldc_I4_3);
				return;
			case 4:
				gen.Emit(OpCodes.Ldc_I4_4);
				return;
			case 5:
				gen.Emit(OpCodes.Ldc_I4_5);
				return;
			case 6:
				gen.Emit(OpCodes.Ldc_I4_6);
				return;
			case 7:
				gen.Emit(OpCodes.Ldc_I4_7);
				return;
			case 8:
				gen.Emit(OpCodes.Ldc_I4_8);
				return;
			}
			if (value == -1)
			{
				gen.Emit(OpCodes.Ldc_I4_M1);
			}
			else if (value >= -127 && value < 128)
			{
				gen.Emit(OpCodes.Ldc_I4_S, (sbyte)value);
			}
			else
			{
				gen.Emit(OpCodes.Ldc_I4, value);
			}
		}

		private void GenerateArrayAssign(ILGenerator gen, Type type)
		{
			if (type.IsEnum)
			{
				gen.Emit(OpCodes.Stelem, type);
				return;
			}
			switch (Type.GetTypeCode(type))
			{
			case TypeCode.SByte:
			case TypeCode.Byte:
				gen.Emit(OpCodes.Stelem_I1);
				return;
			case TypeCode.Int16:
			case TypeCode.UInt16:
				gen.Emit(OpCodes.Stelem_I2);
				return;
			case TypeCode.Int32:
			case TypeCode.UInt32:
				gen.Emit(OpCodes.Stelem_I4);
				return;
			case TypeCode.Int64:
			case TypeCode.UInt64:
				gen.Emit(OpCodes.Stelem_I8);
				return;
			case TypeCode.Single:
				gen.Emit(OpCodes.Stelem_R4);
				return;
			case TypeCode.Double:
				gen.Emit(OpCodes.Stelem_R8);
				return;
			}
			if (type.IsValueType)
			{
				gen.Emit(OpCodes.Stelem, type);
			}
			else
			{
				gen.Emit(OpCodes.Stelem_Ref);
			}
		}

		private StackType GenerateArrayAccess(ILGenerator gen, Type type, StackType ask)
		{
			if (ask == StackType.Address)
			{
				gen.Emit(OpCodes.Ldelema, type);
			}
			else if (!type.IsValueType)
			{
				gen.Emit(OpCodes.Ldelem_Ref);
			}
			else if (type.IsEnum)
			{
				gen.Emit(OpCodes.Ldelem, type);
			}
			else
			{
				switch (Type.GetTypeCode(type))
				{
				case TypeCode.SByte:
					gen.Emit(OpCodes.Ldelem_I1);
					break;
				case TypeCode.Int16:
					gen.Emit(OpCodes.Ldelem_I2);
					break;
				case TypeCode.Int32:
					gen.Emit(OpCodes.Ldelem_I4);
					break;
				case TypeCode.Int64:
					gen.Emit(OpCodes.Ldelem_I8);
					break;
				case TypeCode.Single:
					gen.Emit(OpCodes.Ldelem_R4);
					break;
				case TypeCode.Double:
					gen.Emit(OpCodes.Ldelem_R8);
					break;
				default:
					gen.Emit(OpCodes.Ldelem, type);
					break;
				}
			}
			return ask;
		}

		private void GenerateHasValue(ILGenerator gen, Type nullableType)
		{
			MethodInfo method = nullableType.GetMethod("get_HasValue", BindingFlags.Instance | BindingFlags.Public);
			gen.Emit(OpCodes.Call, method);
		}

		private void GenerateGetValue(ILGenerator gen, Type nullableType)
		{
			MethodInfo method = nullableType.GetMethod("get_Value", BindingFlags.Instance | BindingFlags.Public);
			gen.Emit(OpCodes.Call, method);
		}

		private void GenerateGetValueOrDefault(ILGenerator gen, Type nullableType)
		{
			MethodInfo method = nullableType.GetMethod("GetValueOrDefault", Type.EmptyTypes);
			gen.Emit(OpCodes.Call, method);
		}

		private static bool IsNullable(Type type)
		{
			if (type.IsGenericType)
			{
				return type.GetGenericTypeDefinition() == typeof(Nullable<>);
			}
			return false;
		}

		private static Type GetNonNullableType(Type type)
		{
			if (IsNullable(type))
			{
				Type[] genericArguments = type.GetGenericArguments();
				return genericArguments[0];
			}
			return type;
		}

		private static bool IsConvertible(Type type)
		{
			type = GetNonNullableType(type);
			if (type.IsEnum)
			{
				return true;
			}
			switch (Type.GetTypeCode(type))
			{
			case TypeCode.Boolean:
			case TypeCode.Char:
			case TypeCode.SByte:
			case TypeCode.Byte:
			case TypeCode.Int16:
			case TypeCode.UInt16:
			case TypeCode.Int32:
			case TypeCode.UInt32:
			case TypeCode.Int64:
			case TypeCode.UInt64:
			case TypeCode.Single:
			case TypeCode.Double:
				return true;
			default:
				return false;
			}
		}

		private static bool IsUnsigned(Type type)
		{
			if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>))
			{
				type = type.GetGenericArguments()[0];
			}
			switch (Type.GetTypeCode(type))
			{
			case TypeCode.Char:
			case TypeCode.Byte:
			case TypeCode.UInt16:
			case TypeCode.UInt32:
			case TypeCode.UInt64:
				return true;
			default:
				return false;
			}
		}

		private static bool IsFloatingPoint(Type type)
		{
			if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>))
			{
				type = type.GetGenericArguments()[0];
			}
			switch (Type.GetTypeCode(type))
			{
			case TypeCode.Single:
			case TypeCode.Double:
				return true;
			default:
				return false;
			}
		}
	}
	internal abstract class ExpressionVisitor
	{
		internal ExpressionVisitor()
		{
		}

		internal virtual Expression Visit(Expression exp)
		{
			if (exp == null)
			{
				return exp;
			}
			switch (exp.NodeType)
			{
			case ExpressionType.ArrayLength:
			case ExpressionType.Convert:
			case ExpressionType.ConvertChecked:
			case ExpressionType.Negate:
			case ExpressionType.UnaryPlus:
			case ExpressionType.NegateChecked:
			case ExpressionType.Not:
			case ExpressionType.Quote:
			case ExpressionType.TypeAs:
				return VisitUnary((UnaryExpression)exp);
			case ExpressionType.Add:
			case ExpressionType.AddChecked:
			case ExpressionType.And:
			case ExpressionType.AndAlso:
			case ExpressionType.ArrayIndex:
			case ExpressionType.Coalesce:
			case ExpressionType.Divide:
			case ExpressionType.Equal:
			case ExpressionType.ExclusiveOr:
			case ExpressionType.GreaterThan:
			case ExpressionType.GreaterThanOrEqual:
			case ExpressionType.LeftShift:
			case ExpressionType.LessThan:
			case ExpressionType.LessThanOrEqual:
			case ExpressionType.Modulo:
			case ExpressionType.Multiply:
			case ExpressionType.MultiplyChecked:
			case ExpressionType.NotEqual:
			case ExpressionType.Or:
			case ExpressionType.OrElse:
			case ExpressionType.Power:
			case ExpressionType.RightShift:
			case ExpressionType.Subtract:
			case ExpressionType.SubtractChecked:
				return VisitBinary((BinaryExpression)exp);
			case ExpressionType.TypeIs:
				return VisitTypeIs((TypeBinaryExpression)exp);
			case ExpressionType.Conditional:
				return VisitConditional((ConditionalExpression)exp);
			case ExpressionType.Constant:
				return VisitConstant((ConstantExpression)exp);
			case ExpressionType.Parameter:
				return VisitParameter((ParameterExpression)exp);
			case ExpressionType.MemberAccess:
				return VisitMemberAccess((MemberExpression)exp);
			case ExpressionType.Call:
				return VisitMethodCall((MethodCallExpression)exp);
			case ExpressionType.Lambda:
				return VisitLambda((LambdaExpression)exp);
			case ExpressionType.New:
				return VisitNew((NewExpression)exp);
			case ExpressionType.NewArrayInit:
			case ExpressionType.NewArrayBounds:
				return VisitNewArray((NewArrayExpression)exp);
			case ExpressionType.Invoke:
				return VisitInvocation((InvocationExpression)exp);
			case ExpressionType.MemberInit:
				return VisitMemberInit((MemberInitExpression)exp);
			case ExpressionType.ListInit:
				return VisitListInit((ListInitExpression)exp);
			default:
				throw Error.UnhandledExpressionType(exp.NodeType);
			}
		}

		internal virtual MemberBinding VisitBinding(MemberBinding binding)
		{
			return binding.BindingType switch
			{
				MemberBindingType.Assignment => VisitMemberAssignment((MemberAssignment)binding), 
				MemberBindingType.MemberBinding => VisitMemberMemberBinding((MemberMemberBinding)binding), 
				MemberBindingType.ListBinding => VisitMemberListBinding((MemberListBinding)binding), 
				_ => throw Error.UnhandledBindingType(binding.BindingType), 
			};
		}

		internal virtual ElementInit VisitElementInitializer(ElementInit initializer)
		{
			ReadOnlyCollection<Expression> readOnlyCollection = VisitExpressionList(initializer.Arguments);
			if (readOnlyCollection != initializer.Arguments)
			{
				return Expression.ElementInit(initializer.AddMethod, readOnlyCollection);
			}
			return initializer;
		}

		internal virtual Expression VisitUnary(UnaryExpression u)
		{
			Expression expression = Visit(u.Operand);
			if (expression != u.Operand)
			{
				return Expression.MakeUnary(u.NodeType, expression, u.Type, u.Method);
			}
			return u;
		}

		internal virtual Expression VisitBinary(BinaryExpression b)
		{
			Expression expression = Visit(b.Left);
			Expression expression2 = Visit(b.Right);
			Expression expression3 = Visit(b.Conversion);
			if (expression != b.Left || expression2 != b.Right || expression3 != b.Conversion)
			{
				if (b.NodeType == ExpressionType.Coalesce && b.Conversion != null)
				{
					return Expression.Coalesce(expression, expression2, expression3 as LambdaExpression);
				}
				return Expression.MakeBinary(b.NodeType, expression, expression2, b.IsLiftedToNull, b.Method);
			}
			return b;
		}

		internal virtual Expression VisitTypeIs(TypeBinaryExpression b)
		{
			Expression expression = Visit(b.Expression);
			if (expression != b.Expression)
			{
				return Expression.TypeIs(expression, b.TypeOperand);
			}
			return b;
		}

		internal virtual Expression VisitConstant(ConstantExpression c)
		{
			return c;
		}

		internal virtual Expression VisitConditional(ConditionalExpression c)
		{
			Expression expression = Visit(c.Test);
			Expression expression2 = Visit(c.IfTrue);
			Expression expression3 = Visit(c.IfFalse);
			if (expression != c.Test || expression2 != c.IfTrue || expression3 != c.IfFalse)
			{
				return Expression.Condition(expression, expression2, expression3);
			}
			return c;
		}

		internal virtual Expression VisitParameter(ParameterExpression p)
		{
			return p;
		}

		internal virtual Expression VisitMemberAccess(MemberExpression m)
		{
			Expression expression = Visit(m.Expression);
			if (expression != m.Expression)
			{
				return Expression.MakeMemberAccess(expression, m.Member);
			}
			return m;
		}

		internal virtual Expression VisitMethodCall(MethodCallExpression m)
		{
			Expression expression = Visit(m.Object);
			IEnumerable<Expression> enumerable = VisitExpressionList(m.Arguments);
			if (expression != m.Object || enumerable != m.Arguments)
			{
				return Expression.Call(expression, m.Method, enumerable);
			}
			return m;
		}

		internal virtual ReadOnlyCollection<Expression> VisitExpressionList(ReadOnlyCollection<Expression> original)
		{
			List<Expression> list = null;
			int i = 0;
			for (int count = original.Count; i < count; i++)
			{
				Expression expression = Visit(original[i]);
				if (list != null)
				{
					list.Add(expression);
				}
				else if (expression != original[i])
				{
					list = new List<Expression>(count);
					for (int j = 0; j < i; j++)
					{
						list.Add(original[j]);
					}
					list.Add(expression);
				}
			}
			if (list != null)
			{
				return list.ToReadOnlyCollection();
			}
			return original;
		}

		internal virtual MemberAssignment VisitMemberAssignment(MemberAssignment assignment)
		{
			Expression expression = Visit(assignment.Expression);
			if (expression != assignment.Expression)
			{
				return Expression.Bind(assignment.Member, expression);
			}
			return assignment;
		}

		internal virtual MemberMemberBinding VisitMemberMemberBinding(MemberMemberBinding binding)
		{
			IEnumerable<MemberBinding> enumerable = VisitBindingList(binding.Bindings);
			if (enumerable != binding.Bindings)
			{
				return Expression.MemberBind(binding.Member, enumerable);
			}
			return binding;
		}

		internal virtual MemberListBinding VisitMemberListBinding(MemberListBinding binding)
		{
			IEnumerable<ElementInit> enumerable = VisitElementInitializerList(binding.Initializers);
			if (enumerable != binding.Initializers)
			{
				return Expression.ListBind(binding.Member, enumerable);
			}
			return binding;
		}

		internal virtual IEnumerable<MemberBinding> VisitBindingList(ReadOnlyCollection<MemberBinding> original)
		{
			List<MemberBinding> list = null;
			int i = 0;
			for (int count = original.Count; i < count; i++)
			{
				MemberBinding memberBinding = VisitBinding(original[i]);
				if (list != null)
				{
					list.Add(memberBinding);
				}
				else if (memberBinding != original[i])
				{
					list = new List<MemberBinding>(count);
					for (int j = 0; j < i; j++)
					{
						list.Add(original[j]);
					}
					list.Add(memberBinding);
				}
			}
			if (list != null)
			{
				return list;
			}
			return original;
		}

		internal virtual IEnumerable<ElementInit> VisitElementInitializerList(ReadOnlyCollection<ElementInit> original)
		{
			List<ElementInit> list = null;
			int i = 0;
			for (int count = original.Count; i < count; i++)
			{
				ElementInit elementInit = VisitElementInitializer(original[i]);
				if (list != null)
				{
					list.Add(elementInit);
				}
				else if (elementInit != original[i])
				{
					list = new List<ElementInit>(count);
					for (int j = 0; j < i; j++)
					{
						list.Add(original[j]);
					}
					list.Add(elementInit);
				}
			}
			if (list != null)
			{
				return list;
			}
			return original;
		}

		internal virtual Expression VisitLambda(LambdaExpression lambda)
		{
			Expression expression = Visit(lambda.Body);
			if (expression != lambda.Body)
			{
				return Expression.Lambda(lambda.Type, expression, lambda.Parameters);
			}
			return lambda;
		}

		internal virtual NewExpression VisitNew(NewExpression nex)
		{
			IEnumerable<Expression> enumerable = VisitExpressionList(nex.Arguments);
			if (enumerable != nex.Arguments)
			{
				if (nex.Members != null)
				{
					return Expression.New(nex.Constructor, enumerable, nex.Members);
				}
				return Expression.New(nex.Constructor, enumerable);
			}
			return nex;
		}

		internal virtual Expression VisitMemberInit(MemberInitExpression init)
		{
			NewExpression newExpression = VisitNew(init.NewExpression);
			IEnumerable<MemberBinding> enumerable = VisitBindingList(init.Bindings);
			if (newExpression != init.NewExpression || enumerable != init.Bindings)
			{
				return Expression.MemberInit(newExpression, enumerable);
			}
			return init;
		}

		internal virtual Expression VisitListInit(ListInitExpression init)
		{
			NewExpression newExpression = VisitNew(init.NewExpression);
			IEnumerable<ElementInit> enumerable = VisitElementInitializerList(init.Initializers);
			if (newExpression != init.NewExpression || enumerable != init.Initializers)
			{
				return Expression.ListInit(newExpression, enumerable);
			}
			return init;
		}

		internal virtual Expression VisitNewArray(NewArrayExpression na)
		{
			IEnumerable<Expression> enumerable = VisitExpressionList(na.Expressions);
			if (enumerable != na.Expressions)
			{
				if (na.NodeType == ExpressionType.NewArrayInit)
				{
					return Expression.NewArrayInit(na.Type.GetElementType(), enumerable);
				}
				return Expression.NewArrayBounds(na.Type.GetElementType(), enumerable);
			}
			return na;
		}

		internal virtual Expression VisitInvocation(InvocationExpression iv)
		{
			IEnumerable<Expression> enumerable = VisitExpressionList(iv.Arguments);
			Expression expression = Visit(iv.Expression);
			if (enumerable != iv.Arguments || expression != iv.Expression)
			{
				return Expression.Invoke(expression, enumerable);
			}
			return iv;
		}
	}
	internal static class Strings
	{
		internal static string OwningTeam => SR.GetString("OwningTeam");

		internal static string ArgumentMustBeArray => SR.GetString("ArgumentMustBeArray");

		internal static string ArgumentMustBeBoolean => SR.GetString("ArgumentMustBeBoolean");

		internal static string ArgumentMustBeComparable => SR.GetString("ArgumentMustBeComparable");

		internal static string ArgumentMustBeConvertible => SR.GetString("ArgumentMustBeConvertible");

		internal static string ArgumentMustBeFieldInfoOrPropertInfo => SR.GetString("ArgumentMustBeFieldInfoOrPropertInfo");

		internal static string ArgumentMustBeFieldInfoOrPropertInfoOrMethod => SR.GetString("ArgumentMustBeFieldInfoOrPropertInfoOrMethod");

		internal static string ArgumentMustBeInstanceMember => SR.GetString("ArgumentMustBeInstanceMember");

		internal static string ArgumentMustBeInteger => SR.GetString("ArgumentMustBeInteger");

		internal static string ArgumentMustBeInt32 => SR.GetString("ArgumentMustBeInt32");

		internal static string ArgumentMustBeCheckable => SR.GetString("ArgumentMustBeCheckable");

		internal static string ArgumentMustBeArrayIndexType => SR.GetString("ArgumentMustBeArrayIndexType");

		internal static string ArgumentMustBeIntegerOrBoolean => SR.GetString("ArgumentMustBeIntegerOrBoolean");

		internal static string ArgumentMustBeNumeric => SR.GetString("ArgumentMustBeNumeric");

		internal static string ArgumentMustBeSingleDimensionalArrayType => SR.GetString("ArgumentMustBeSingleDimensionalArrayType");

		internal static string ArgumentTypesMustMatch => SR.GetString("ArgumentTypesMustMatch");

		internal static string CoalesceUsedOnNonNullType => SR.GetString("CoalesceUsedOnNonNullType");

		internal static string IncorrectNumberOfIndexes => SR.GetString("IncorrectNumberOfIndexes");

		internal static string IncorrectNumberOfLambdaArguments => SR.GetString("IncorrectNumberOfLambdaArguments");

		internal static string IncorrectNumberOfLambdaDeclarationParameters => SR.GetString("IncorrectNumberOfLambdaDeclarationParameters");

		internal static string IncorrectNumberOfConstructorArguments => SR.GetString("IncorrectNumberOfConstructorArguments");

		internal static string IncorrectNumberOfMembersForGivenConstructor => SR.GetString("IncorrectNumberOfMembersForGivenConstructor");

		internal static string IncorrectNumberOfArgumentsForMembers => SR.GetString("IncorrectNumberOfArgumentsForMembers");

		internal static string LambdaParameterNotInScope => SR.GetString("LambdaParameterNotInScope");

		internal static string LambdaTypeMustBeDerivedFromSystemDelegate => SR.GetString("LambdaTypeMustBeDerivedFromSystemDelegate");

		internal static string ParameterNotCaptured => SR.GetString("ParameterNotCaptured");

		internal static string ListInitializerWithZeroMembers => SR.GetString("ListInitializerWithZeroMembers");

		internal static string ElementInitializerMethodNotAdd => SR.GetString("ElementInitializerMethodNotAdd");

		internal static string ElementInitializerMethodWithZeroArgs => SR.GetString("ElementInitializerMethodWithZeroArgs");

		internal static string ElementInitializerMethodStatic => SR.GetString("ElementInitializerMethodStatic");

		internal static string UnexpectedCoalesceOperator => SR.GetString("UnexpectedCoalesceOperator");

		internal static string UnhandledBinding => SR.GetString("UnhandledBinding");

		internal static string UnknownBindingType => SR.GetString("UnknownBindingType");

		internal static string IncorrectNumberOfTypeArgsForFunc => SR.GetString("IncorrectNumberOfTypeArgsForFunc");

		internal static string IncorrectNumberOfTypeArgsForAction => SR.GetString("IncorrectNumberOfTypeArgsForAction");

		internal static string ExpressionMayNotContainByrefParameters => SR.GetString("ExpressionMayNotContainByrefParameters");

		internal static string ArgumentCannotBeOfTypeVoid => SR.GetString("ArgumentCannotBeOfTypeVoid");

		internal static string UserDefinedOperatorMustBeStatic(object p0)
		{
			return SR.GetString("UserDefinedOperatorMustBeStatic", p0);
		}

		internal static string UserDefinedOperatorMustNotBeVoid(object p0)
		{
			return SR.GetString("UserDefinedOperatorMustNotBeVoid", p0);
		}

		internal static string CoercionOperatorNotDefined(object p0, object p1)
		{
			return SR.GetString("CoercionOperatorNotDefined", p0, p1);
		}

		internal static string UnaryOperatorNotDefined(object p0, object p1)
		{
			return SR.GetString("UnaryOperatorNotDefined", p0, p1);
		}

		internal static string BinaryOperatorNotDefined(object p0, object p1, object p2)
		{
			return SR.GetString("BinaryOperatorNotDefined", p0, p1, p2);
		}

		internal static string OperandTypesDoNotMatchParameters(object p0, object p1)
		{
			return SR.GetString("OperandTypesDoNotMatchParameters", p0, p1);
		}

		internal static string CannotAutoInitializeValueTypeElementThroughProperty(object p0)
		{
			return SR.GetString("CannotAutoInitializeValueTypeElementThroughProperty", p0);
		}

		internal static string CannotAutoInitializeValueTypeMemberThroughProperty(object p0)
		{
			return SR.GetString("CannotAutoInitializeValueTypeMemberThroughProperty", p0);
		}

		internal static string CannotCastTypeToType(object p0, object p1)
		{
			return SR.GetString("CannotCastTypeToType", p0, p1);
		}

		internal static string IncorrectTypeForTypeAs(object p0)
		{
			return SR.GetString("IncorrectTypeForTypeAs", p0);
		}

		internal static string ExpressionTypeCannotInitializeCollectionType(object p0, object p1)
		{
			return SR.GetString("ExpressionTypeCannotInitializeCollectionType", p0, p1);
		}

		internal static string ExpressionTypeCannotInitializeArrayType(object p0, object p1)
		{
			return SR.GetString("ExpressionTypeCannotInitializeArrayType", p0, p1);
		}

		internal static string ExpressionTypeDoesNotMatchArrayType(object p0, object p1)
		{
			return SR.GetString("ExpressionTypeDoesNotMatchArrayType", p0, p1);
		}

		internal static string ExpressionTypeDoesNotMatchConstructorParameter(object p0, object p1)
		{
			return SR.GetString("ExpressionTypeDoesNotMatchConstructorParameter", p0, p1);
		}

		internal static string ArgumentTypeDoesNotMatchMember(object p0, object p1)
		{
			return SR.GetString("ArgumentTypeDoesNotMatchMember", p0, p1);
		}

		internal static string ArgumentMemberNotDeclOnType(object p0, object p1)
		{
			return SR.GetString("ArgumentMemberNotDeclOnType", p0, p1);
		}

		internal static string ExpressionTypeDoesNotMatchMethodParameter(object p0, object p1, object p2)
		{
			return SR.GetString("ExpressionTypeDoesNotMatchMethodParameter", p0, p1, p2);
		}

		internal static string ExpressionTypeDoesNotMatchParameter(object p0, object p1)
		{
			return SR.GetString("ExpressionTypeDoesNotMatchParameter", p0, p1);
		}

		internal static string ExpressionTypeDoesNotMatchReturn(object p0, object p1)
		{
			return SR.GetString("ExpressionTypeDoesNotMatchReturn", p0, p1);
		}

		internal static string ExpressionTypeNotInvocable(object p0)
		{
			return SR.GetString("ExpressionTypeNotInvocable", p0);
		}

		internal static string FieldNotDefinedForType(object p0, object p1)
		{
			return SR.GetString("FieldNotDefinedForType", p0, p1);
		}

		internal static string IncorrectNumberOfMethodCallArguments(object p0)
		{
			return SR.GetString("IncorrectNumberOfMethodCallArguments", p0);
		}

		internal static string MemberNotFieldOrProperty(object p0)
		{
			return SR.GetString("MemberNotFieldOrProperty", p0);
		}

		internal static string MethodContainsGenericParameters(object p0)
		{
			return SR.GetString("MethodContainsGenericParameters", p0);
		}

		internal static string MethodIsGeneric(object p0)
		{
			return SR.GetString("MethodIsGeneric", p0);
		}

		internal static string MethodNotPropertyAccessor(object p0, object p1)
		{
			return SR.GetString("MethodNotPropertyAccessor", p0, p1);
		}

		internal static string PropertyDoesNotHaveGetter(object p0)
		{
			return SR.GetString("PropertyDoesNotHaveGetter", p0);
		}

		internal static string PropertyDoesNotHaveSetter(object p0)
		{
			return SR.GetString("PropertyDoesNotHaveSetter", p0);
		}

		internal static string NotAMemberOfType(object p0, object p1)
		{
			return SR.GetString("NotAMemberOfType", p0, p1);
		}

		internal static string OperatorNotImplementedForType(object p0, object p1)
		{
			return SR.GetString("OperatorNotImplementedForType", p0, p1);
		}

		internal static string ParameterExpressionNotValidAsDelegate(object p0, object p1)
		{
			return SR.GetString("ParameterExpressionNotValidAsDelegate", p0, p1);
		}

		internal static string PropertyNotDefinedForType(object p0, object p1)
		{
			return SR.GetString("PropertyNotDefinedForType", p0, p1);
		}

		internal static string MethodNotDefinedForType(object p0, object p1)
		{
			return SR.GetString("MethodNotDefinedForType", p0, p1);
		}

		internal static string TypeContainsGenericParameters(object p0)
		{
			return SR.GetString("TypeContainsGenericParameters", p0);
		}

		internal static string TypeIsGeneric(object p0)
		{
			return SR.GetString("TypeIsGeneric", p0);
		}

		internal static string TypeMissingDefaultConstructor(object p0)
		{
			return SR.GetString("TypeMissingDefaultConstructor", p0);
		}

		internal static string ElementInitializerMethodNoRefOutParam(object p0, object p1)
		{
			return SR.GetString("ElementInitializerMethodNoRefOutParam", p0, p1);
		}

		internal static string TypeNotIEnumerable(object p0)
		{
			return SR.GetString("TypeNotIEnumerable", p0);
		}

		internal static string TypeParameterIsNotDelegate(object p0)
		{
			return SR.GetString("TypeParameterIsNotDelegate", p0);
		}

		internal static string InvalidCast(object p0, object p1)
		{
			return SR.GetString("InvalidCast", p0, p1);
		}

		internal static string UnhandledCall(object p0)
		{
			return SR.GetString("UnhandledCall", p0);
		}

		internal static string UnhandledBinary(object p0)
		{
			return SR.GetString("UnhandledBinary", p0);
		}

		internal static string UnhandledBindingType(object p0)
		{
			return SR.GetString("UnhandledBindingType", p0);
		}

		internal static string UnhandledConvert(object p0)
		{
			return SR.GetString("UnhandledConvert", p0);
		}

		internal static string UnhandledConvertFromDecimal(object p0)
		{
			return SR.GetString("UnhandledConvertFromDecimal", p0);
		}

		internal static string UnhandledConvertToDecimal(object p0)
		{
			return SR.GetString("UnhandledConvertToDecimal", p0);
		}

		internal static string UnhandledExpressionType(object p0)
		{
			return SR.GetString("UnhandledExpressionType", p0);
		}

		internal static string UnhandledMemberAccess(object p0)
		{
			return SR.GetString("UnhandledMemberAccess", p0);
		}

		internal static string UnhandledUnary(object p0)
		{
			return SR.GetString("UnhandledUnary", p0);
		}

		internal static string LogicalOperatorMustHaveConsistentTypes(object p0, object p1)
		{
			return SR.GetString("LogicalOperatorMustHaveConsistentTypes", p0, p1);
		}

		internal static string LogicalOperatorMustHaveBooleanOperators(object p0, object p1)
		{
			return SR.GetString("LogicalOperatorMustHaveBooleanOperators", p0, p1);
		}

		internal static string MethodDoesNotExistOnType(object p0, object p1)
		{
			return SR.GetString("MethodDoesNotExistOnType", p0, p1);
		}

		internal static string MethodWithArgsDoesNotExistOnType(object p0, object p1)
		{
			return SR.GetString("MethodWithArgsDoesNotExistOnType", p0, p1);
		}

		internal static string MethodWithMoreThanOneMatch(object p0, object p1)
		{
			return SR.GetString("MethodWithMoreThanOneMatch", p0, p1);
		}
	}
	internal static class Error
	{
		internal static Exception UserDefinedOperatorMustBeStatic(object p0)
		{
			return new ArgumentException(Strings.UserDefinedOperatorMustBeStatic(p0));
		}

		internal static Exception UserDefinedOperatorMustNotBeVoid(object p0)
		{
			return new ArgumentException(Strings.UserDefinedOperatorMustNotBeVoid(p0));
		}

		internal static Exception CoercionOperatorNotDefined(object p0, object p1)
		{
			return new InvalidOperationException(Strings.CoercionOperatorNotDefined(p0, p1));
		}

		internal static Exception UnaryOperatorNotDefined(object p0, object p1)
		{
			return new InvalidOperationException(Strings.UnaryOperatorNotDefined(p0, p1));
		}

		internal static Exception BinaryOperatorNotDefined(object p0, object p1, object p2)
		{
			return new InvalidOperationException(Strings.BinaryOperatorNotDefined(p0, p1, p2));
		}

		internal static Exception OperandTypesDoNotMatchParameters(object p0, object p1)
		{
			return new InvalidOperationException(Strings.OperandTypesDoNotMatchParameters(p0, p1));
		}

		internal static Exception ArgumentMustBeArray()
		{
			return new ArgumentException(Strings.ArgumentMustBeArray);
		}

		internal static Exception ArgumentMustBeBoolean()
		{
			return new ArgumentException(Strings.ArgumentMustBeBoolean);
		}

		internal static Exception ArgumentMustBeComparable()
		{
			return new ArgumentException(Strings.ArgumentMustBeComparable);
		}

		internal static Exception ArgumentMustBeConvertible()
		{
			return new ArgumentException(Strings.ArgumentMustBeConvertible);
		}

		internal static Exception ArgumentMustBeFieldInfoOrPropertInfo()
		{
			return new ArgumentException(Strings.ArgumentMustBeFieldInfoOrPropertInfo);
		}

		internal static Exception ArgumentMustBeFieldInfoOrPropertInfoOrMethod()
		{
			return new ArgumentException(Strings.ArgumentMustBeFieldInfoOrPropertInfoOrMethod);
		}

		internal static Exception ArgumentMustBeInstanceMember()
		{
			return new ArgumentException(Strings.ArgumentMustBeInstanceMember);
		}

		internal static Exception ArgumentMustBeInteger()
		{
			return new ArgumentException(Strings.ArgumentMustBeInteger);
		}

		internal static Exception ArgumentMustBeInt32()
		{
			return new ArgumentException(Strings.ArgumentMustBeInt32);
		}

		internal static Exception ArgumentMustBeCheckable()
		{
			return new ArgumentException(Strings.ArgumentMustBeCheckable);
		}

		internal static Exception ArgumentMustBeArrayIndexType()
		{
			return new ArgumentException(Strings.ArgumentMustBeArrayIndexType);
		}

		internal static Exception ArgumentMustBeIntegerOrBoolean()
		{
			return new ArgumentException(Strings.ArgumentMustBeIntegerOrBoolean);
		}

		internal static Exception ArgumentMustBeNumeric()
		{
			return new ArgumentException(Strings.ArgumentMustBeNumeric);
		}

		internal static Exception ArgumentMustBeSingleDimensionalArrayType()
		{
			return new ArgumentException(Strings.ArgumentMustBeSingleDimensionalArrayType);
		}

		internal static Exception ArgumentTypesMustMatch()
		{
			return new ArgumentException(Strings.ArgumentTypesMustMatch);
		}

		internal static Exception CannotAutoInitializeValueTypeElementThroughProperty(object p0)
		{
			return new InvalidOperationException(Strings.CannotAutoInitializeValueTypeElementThroughProperty(p0));
		}

		internal static Exception CannotAutoInitializeValueTypeMemberThroughProperty(object p0)
		{
			return new InvalidOperationException(Strings.CannotAutoInitializeValueTypeMemberThroughProperty(p0));
		}

		internal static Exception CannotCastTypeToType(object p0, object p1)
		{
			return new ArgumentException(Strings.CannotCastTypeToType(p0, p1));
		}

		internal static Exception IncorrectTypeForTypeAs(object p0)
		{
			return new ArgumentException(Strings.IncorrectTypeForTypeAs(p0));
		}

		internal static Exception CoalesceUsedOnNonNullType()
		{
			return new InvalidOperationException(Strings.CoalesceUsedOnNonNullType);
		}

		internal static Exception ExpressionTypeCannotInitializeCollectionType(object p0, object p1)
		{
			return new InvalidOperationException(Strings.ExpressionTypeCannotInitializeCollectionType(p0, p1));
		}

		internal static Exception ExpressionTypeCannotInitializeArrayType(object p0, object p1)
		{
			return new InvalidOperationException(Strings.ExpressionTypeCannotInitializeArrayType(p0, p1));
		}

		internal static Exception ExpressionTypeDoesNotMatchArrayType(object p0, object p1)
		{
			return new InvalidOperationException(Strings.ExpressionTypeDoesNotMatchArrayType(p0, p1));
		}

		internal static Exception ExpressionTypeDoesNotMatchConstructorParameter(object p0, object p1)
		{
			return new ArgumentException(Strings.ExpressionTypeDoesNotMatchConstructorParameter(p0, p1));
		}

		internal static Exception ArgumentTypeDoesNotMatchMember(object p0, object p1)
		{
			return new ArgumentException(Strings.ArgumentTypeDoesNotMatchMember(p0, p1));
		}

		internal static Exception ArgumentMemberNotDeclOnType(object p0, object p1)
		{
			return new ArgumentException(Strings.ArgumentMemberNotDeclOnType(p0, p1));
		}

		internal static Exception ExpressionTypeDoesNotMatchMethodParameter(object p0, object p1, object p2)
		{
			return new ArgumentException(Strings.ExpressionTypeDoesNotMatchMethodParameter(p0, p1, p2));
		}

		internal static Exception ExpressionTypeDoesNotMatchParameter(object p0, object p1)
		{
			return new ArgumentException(Strings.ExpressionTypeDoesNotMatchParameter(p0, p1));
		}

		internal static Exception ExpressionTypeDoesNotMatchReturn(object p0, object p1)
		{
			return new ArgumentException(Strings.ExpressionTypeDoesNotMatchReturn(p0, p1));
		}

		internal static Exception ExpressionTypeNotInvocable(object p0)
		{
			return new ArgumentException(Strings.ExpressionTypeNotInvocable(p0));
		}

		internal static Exception FieldNotDefinedForType(object p0, object p1)
		{
			return new ArgumentException(Strings.FieldNotDefinedForType(p0, p1));
		}

		internal static Exception IncorrectNumberOfIndexes()
		{
			return new ArgumentException(Strings.IncorrectNumberOfIndexes);
		}

		internal static Exception IncorrectNumberOfLambdaArguments()
		{
			return new InvalidOperationException(Strings.IncorrectNumberOfLambdaArguments);
		}

		internal static Exception IncorrectNumberOfLambdaDeclarationParameters()
		{
			return new ArgumentException(Strings.IncorrectNumberOfLambdaDeclarationParameters);
		}

		internal static Exception IncorrectNumberOfMethodCallArguments(object p0)
		{
			return new ArgumentException(Strings.IncorrectNumberOfMethodCallArguments(p0));
		}

		internal static Exception IncorrectNumberOfConstructorArguments()
		{
			return new ArgumentException(Strings.IncorrectNumberOfConstructorArguments);
		}

		internal static Exception IncorrectNumberOfMembersForGivenConstructor()
		{
			return new ArgumentException(Strings.IncorrectNumberOfMembersForGivenConstructor);
		}

		internal static Exception IncorrectNumberOfArgumentsForMembers()
		{
			return new ArgumentException(Strings.IncorrectNumberOfArgumentsForMembers);
		}

		internal static Exception LambdaParameterNotInScope()
		{
			return new InvalidOperationException(Strings.LambdaParameterNotInScope);
		}

		internal static Exception LambdaTypeMustBeDerivedFromSystemDelegate()
		{
			return new ArgumentException(Strings.LambdaTypeMustBeDerivedFromSystemDelegate);
		}

		internal static Exception MemberNotFieldOrProperty(object p0)
		{
			return new ArgumentException(Strings.MemberNotFieldOrProperty(p0));
		}

		internal static Exception MethodContainsGenericParameters(object p0)
		{
			return new ArgumentException(Strings.MethodContainsGenericParameters(p0));
		}

		internal static Exception MethodIsGeneric(object p0)
		{
			return new ArgumentException(Strings.MethodIsGeneric(p0));
		}

		internal static Exception MethodNotPropertyAccessor(object p0, object p1)
		{
			return new ArgumentException(Strings.MethodNotPropertyAccessor(p0, p1));
		}

		internal static Exception PropertyDoesNotHaveGetter(object p0)
		{
			return new ArgumentException(Strings.PropertyDoesNotHaveGetter(p0));
		}

		internal static Exception PropertyDoesNotHaveSetter(object p0)
		{
			return new ArgumentException(Strings.PropertyDoesNotHaveSetter(p0));
		}

		internal static Exception NotAMemberOfType(object p0, object p1)
		{
			return new ArgumentException(Strings.NotAMemberOfType(p0, p1));
		}

		internal static Exception OperatorNotImplementedForType(object p0, object p1)
		{
			return new NotImplementedException(Strings.OperatorNotImplementedForType(p0, p1));
		}

		internal static Exception ParameterExpressionNotValidAsDelegate(object p0, object p1)
		{
			return new ArgumentException(Strings.ParameterExpressionNotValidAsDelegate(p0, p1));
		}

		internal static Exception ParameterNotCaptured()
		{
			return new ArgumentException(Strings.ParameterNotCaptured);
		}

		internal static Exception PropertyNotDefinedForType(object p0, object p1)
		{
			return new ArgumentException(Strings.PropertyNotDefinedForType(p0, p1));
		}

		internal static Exception MethodNotDefinedForType(object p0, object p1)
		{
			return new ArgumentException(Strings.MethodNotDefinedForType(p0, p1));
		}

		internal static Exception TypeContainsGenericParameters(object p0)
		{
			return new ArgumentException(Strings.TypeContainsGenericParameters(p0));
		}

		internal static Exception TypeIsGeneric(object p0)
		{
			return new ArgumentException(Strings.TypeIsGeneric(p0));
		}

		internal static Exception TypeMissingDefaultConstructor(object p0)
		{
			return new ArgumentException(Strings.TypeMissingDefaultConstructor(p0));
		}

		internal static Exception ListInitializerWithZeroMembers()
		{
			return new ArgumentException(Strings.ListInitializerWithZeroMembers);
		}

		internal static Exception ElementInitializerMethodNotAdd()
		{
			return new ArgumentException(Strings.ElementInitializerMethodNotAdd);
		}

		internal static Exception ElementInitializerMethodNoRefOutParam(object p0, object p1)
		{
			return new ArgumentException(Strings.ElementInitializerMethodNoRefOutParam(p0, p1));
		}

		internal static Exception ElementInitializerMethodWithZeroArgs()
		{
			return new ArgumentException(Strings.ElementInitializerMethodWithZeroArgs);
		}

		internal static Exception ElementInitializerMethodStatic()
		{
			return new ArgumentException(Strings.ElementInitializerMethodStatic);
		}

		internal static Exception TypeNotIEnumerable(object p0)
		{
			return new ArgumentException(Strings.TypeNotIEnumerable(p0));
		}

		internal static Exception TypeParameterIsNotDelegate(object p0)
		{
			return new InvalidOperationException(Strings.TypeParameterIsNotDelegate(p0));
		}

		internal static Exception UnexpectedCoalesceOperator()
		{
			return new InvalidOperationException(Strings.UnexpectedCoalesceOperator);
		}

		internal static Exception InvalidCast(object p0, object p1)
		{
			return new InvalidOperationException(Strings.InvalidCast(p0, p1));
		}

		internal static Exception UnhandledCall(object p0)
		{
			return new ArgumentException(Strings.UnhandledCall(p0));
		}

		internal static Exception UnhandledBinary(object p0)
		{
			return new ArgumentException(Strings.UnhandledBinary(p0));
		}

		internal static Exception UnhandledBinding()
		{
			return new ArgumentException(Strings.UnhandledBinding);
		}

		internal static Exception UnhandledBindingType(object p0)
		{
			return new ArgumentException(Strings.UnhandledBindingType(p0));
		}

		internal static Exception UnhandledConvert(object p0)
		{
			return new ArgumentException(Strings.UnhandledConvert(p0));
		}

		internal static Exception UnhandledConvertFromDecimal(object p0)
		{
			return new ArgumentException(Strings.UnhandledConvertFromDecimal(p0));
		}

		internal static Exception UnhandledConvertToDecimal(object p0)
		{
			return new ArgumentException(Strings.UnhandledConvertToDecimal(p0));
		}

		internal static Exception UnhandledExpressionType(object p0)
		{
			return new ArgumentException(Strings.UnhandledExpressionType(p0));
		}

		internal static Exception UnhandledMemberAccess(object p0)
		{
			return new ArgumentException(Strings.UnhandledMemberAccess(p0));
		}

		internal static Exception UnhandledUnary(object p0)
		{
			return new ArgumentException(Strings.UnhandledUnary(p0));
		}

		internal static Exception UnknownBindingType()
		{
			return new ArgumentException(Strings.UnknownBindingType);
		}

		internal static Exception LogicalOperatorMustHaveConsistentTypes(object p0, object p1)
		{
			return new ArgumentException(Strings.LogicalOperatorMustHaveConsistentTypes(p0, p1));
		}

		internal static Exception LogicalOperatorMustHaveBooleanOperators(object p0, object p1)
		{
			return new ArgumentException(Strings.LogicalOperatorMustHaveBooleanOperators(p0, p1));
		}

		internal static Exception MethodDoesNotExistOnType(object p0, object p1)
		{
			return new InvalidOperationException(Strings.MethodDoesNotExistOnType(p0, p1));
		}

		internal static Exception MethodWithArgsDoesNotExistOnType(object p0, object p1)
		{
			return new InvalidOperationException(Strings.MethodWithArgsDoesNotExistOnType(p0, p1));
		}

		internal static Exception MethodWithMoreThanOneMatch(object p0, object p1)
		{
			return new InvalidOperationException(Strings.MethodWithMoreThanOneMatch(p0, p1));
		}

		internal static Exception IncorrectNumberOfTypeArgsForFunc()
		{
			return new ArgumentException(Strings.IncorrectNumberOfTypeArgsForFunc);
		}

		internal static Exception IncorrectNumberOfTypeArgsForAction()
		{
			return new ArgumentException(Strings.IncorrectNumberOfTypeArgsForAction);
		}

		internal static Exception ExpressionMayNotContainByrefParameters()
		{
			return new ArgumentException(Strings.ExpressionMayNotContainByrefParameters);
		}

		internal static Exception ArgumentCannotBeOfTypeVoid()
		{
			return new ArgumentException(Strings.ArgumentCannotBeOfTypeVoid);
		}

		internal static Exception ArgumentNull(string paramName)
		{
			return new ArgumentNullException(paramName);
		}

		internal static Exception ArgumentOutOfRange(string paramName)
		{
			return new ArgumentOutOfRangeException(paramName);
		}

		internal static Exception NotImplemented()
		{
			return new NotImplementedException();
		}

		internal static Exception NotSupported()
		{
			return new NotSupportedException();
		}
	}
}
namespace System.Linq
{
	public interface IQueryable : IEnumerable
	{
		Expression Expression { get; }

		Type ElementType { get; }

		IQueryProvider Provider { get; }
	}
	public interface IQueryable<T> : IEnumerable<T>, IQueryable, IEnumerable
	{
	}
	public interface IQueryProvider
	{
		IQueryable CreateQuery(Expression expression);

		IQueryable<TElement> CreateQuery<TElement>(Expression expression);

		object Execute(Expression expression);

		TResult Execute<TResult>(Expression expression);
	}
	public interface IOrderedQueryable : IQueryable, IEnumerable
	{
	}
	public interface IOrderedQueryable<T> : IQueryable<T>, IEnumerable<T>, IOrderedQueryable, IQueryable, IEnumerable
	{
	}
	public static class Queryable
	{
		public static IQueryable<TElement> AsQueryable<TElement>(this IEnumerable<TElement> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (source is IQueryable<TElement>)
			{
				return (IQueryable<TElement>)source;
			}
			return new EnumerableQuery<TElement>(source);
		}

		public static IQueryable AsQueryable(this IEnumerable source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (source is IQueryable)
			{
				return (IQueryable)source;
			}
			Type type = TypeHelper.FindGenericType(typeof(IEnumerable<>), source.GetType());
			if (type == null)
			{
				throw Error.ArgumentNotIEnumerableGeneric("source");
			}
			return EnumerableQuery.Create(type.GetGenericArguments()[0], source);
		}

		public static IQueryable<TSource> Where<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return source.Provider.CreateQuery<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Quote(predicate)));
		}

		public static IQueryable<TSource> Where<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, int, bool>> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return source.Provider.CreateQuery<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Quote(predicate)));
		}

		public static IQueryable<TResult> OfType<TResult>(this IQueryable source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return (IQueryable<TResult>)source.Provider.CreateQuery(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TResult)), source.Expression));
		}

		public static IQueryable<TResult> Cast<TResult>(this IQueryable source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return (IQueryable<TResult>)source.Provider.CreateQuery(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TResult)), source.Expression));
		}

		public static IQueryable<TResult> Select<TSource, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, TResult>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.CreateQuery<TResult>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource), typeof(TResult)), source.Expression, Expression.Quote(selector)));
		}

		public static IQueryable<TResult> Select<TSource, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, int, TResult>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.CreateQuery<TResult>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource), typeof(TResult)), source.Expression, Expression.Quote(selector)));
		}

		public static IQueryable<TResult> SelectMany<TSource, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, IEnumerable<TResult>>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.CreateQuery<TResult>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource), typeof(TResult)), source.Expression, Expression.Quote(selector)));
		}

		public static IQueryable<TResult> SelectMany<TSource, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, int, IEnumerable<TResult>>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.CreateQuery<TResult>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource), typeof(TResult)), source.Expression, Expression.Quote(selector)));
		}

		public static IQueryable<TResult> SelectMany<TSource, TCollection, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, int, IEnumerable<TCollection>>> collectionSelector, Expression<Func<TSource, TCollection, TResult>> resultSelector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (collectionSelector == null)
			{
				throw Error.ArgumentNull("collectionSelector");
			}
			if (resultSelector == null)
			{
				throw Error.ArgumentNull("resultSelector");
			}
			return source.Provider.CreateQuery<TResult>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource), typeof(TCollection), typeof(TResult)), source.Expression, Expression.Quote(collectionSelector), Expression.Quote(resultSelector)));
		}

		public static IQueryable<TResult> SelectMany<TSource, TCollection, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, IEnumerable<TCollection>>> collectionSelector, Expression<Func<TSource, TCollection, TResult>> resultSelector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (collectionSelector == null)
			{
				throw Error.ArgumentNull("collectionSelector");
			}
			if (resultSelector == null)
			{
				throw Error.ArgumentNull("resultSelector");
			}
			return source.Provider.CreateQuery<TResult>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource), typeof(TCollection), typeof(TResult)), source.Expression, Expression.Quote(collectionSelector), Expression.Quote(resultSelector)));
		}

		private static Expression GetSourceExpression<TSource>(IEnumerable<TSource> source)
		{
			if (source is IQueryable<TSource> queryable)
			{
				return queryable.Expression;
			}
			return Expression.Constant(source, typeof(IEnumerable<TSource>));
		}

		public static IQueryable<TResult> Join<TOuter, TInner, TKey, TResult>(this IQueryable<TOuter> outer, IEnumerable<TInner> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TInner, TKey>> innerKeySelector, Expression<Func<TOuter, TInner, TResult>> resultSelector)
		{
			if (outer == null)
			{
				throw Error.ArgumentNull("outer");
			}
			if (inner == null)
			{
				throw Error.ArgumentNull("inner");
			}
			if (outerKeySelector == null)
			{
				throw Error.ArgumentNull("outerKeySelector");
			}
			if (innerKeySelector == null)
			{
				throw Error.ArgumentNull("innerKeySelector");
			}
			if (resultSelector == null)
			{
				throw Error.ArgumentNull("resultSelector");
			}
			return outer.Provider.CreateQuery<TResult>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TOuter), typeof(TInner), typeof(TKey), typeof(TResult)), outer.Expression, GetSourceExpression(inner), Expression.Quote(outerKeySelector), Expression.Quote(innerKeySelector), Expression.Quote(resultSelector)));
		}

		public static IQueryable<TResult> Join<TOuter, TInner, TKey, TResult>(this IQueryable<TOuter> outer, IEnumerable<TInner> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TInner, TKey>> innerKeySelector, Expression<Func<TOuter, TInner, TResult>> resultSelector, IEqualityComparer<TKey> comparer)
		{
			if (outer == null)
			{
				throw Error.ArgumentNull("outer");
			}
			if (inner == null)
			{
				throw Error.ArgumentNull("inner");
			}
			if (outerKeySelector == null)
			{
				throw Error.ArgumentNull("outerKeySelector");
			}
			if (innerKeySelector == null)
			{
				throw Error.ArgumentNull("innerKeySelector");
			}
			if (resultSelector == null)
			{
				throw Error.ArgumentNull("resultSelector");
			}
			return outer.Provider.CreateQuery<TResult>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TOuter), typeof(TInner), typeof(TKey), typeof(TResult)), outer.Expression, GetSourceExpression(inner), Expression.Quote(outerKeySelector), Expression.Quote(innerKeySelector), Expression.Quote(resultSelector), Expression.Constant(comparer, typeof(IEqualityComparer<TKey>))));
		}

		public static IQueryable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IQueryable<TOuter> outer, IEnumerable<TInner> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TInner, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<TInner>, TResult>> resultSelector)
		{
			if (outer == null)
			{
				throw Error.ArgumentNull("outer");
			}
			if (inner == null)
			{
				throw Error.ArgumentNull("inner");
			}
			if (outerKeySelector == null)
			{
				throw Error.ArgumentNull("outerKeySelector");
			}
			if (innerKeySelector == null)
			{
				throw Error.ArgumentNull("innerKeySelector");
			}
			if (resultSelector == null)
			{
				throw Error.ArgumentNull("resultSelector");
			}
			return outer.Provider.CreateQuery<TResult>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TOuter), typeof(TInner), typeof(TKey), typeof(TResult)), outer.Expression, GetSourceExpression(inner), Expression.Quote(outerKeySelector), Expression.Quote(innerKeySelector), Expression.Quote(resultSelector)));
		}

		public static IQueryable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IQueryable<TOuter> outer, IEnumerable<TInner> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TInner, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<TInner>, TResult>> resultSelector, IEqualityComparer<TKey> comparer)
		{
			if (outer == null)
			{
				throw Error.ArgumentNull("outer");
			}
			if (inner == null)
			{
				throw Error.ArgumentNull("inner");
			}
			if (outerKeySelector == null)
			{
				throw Error.ArgumentNull("outerKeySelector");
			}
			if (innerKeySelector == null)
			{
				throw Error.ArgumentNull("innerKeySelector");
			}
			if (resultSelector == null)
			{
				throw Error.ArgumentNull("resultSelector");
			}
			return outer.Provider.CreateQuery<TResult>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TOuter), typeof(TInner), typeof(TKey), typeof(TResult)), outer.Expression, GetSourceExpression(inner), Expression.Quote(outerKeySelector), Expression.Quote(innerKeySelector), Expression.Quote(resultSelector), Expression.Constant(comparer, typeof(IEqualityComparer<TKey>))));
		}

		public static IOrderedQueryable<TSource> OrderBy<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			return (IOrderedQueryable<TSource>)source.Provider.CreateQuery<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource), typeof(TKey)), source.Expression, Expression.Quote(keySelector)));
		}

		public static IOrderedQueryable<TSource> OrderBy<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, IComparer<TKey> comparer)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			return (IOrderedQueryable<TSource>)source.Provider.CreateQuery<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource), typeof(TKey)), source.Expression, Expression.Quote(keySelector), Expression.Constant(comparer, typeof(IComparer<TKey>))));
		}

		public static IOrderedQueryable<TSource> OrderByDescending<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			return (IOrderedQueryable<TSource>)source.Provider.CreateQuery<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource), typeof(TKey)), source.Expression, Expression.Quote(keySelector)));
		}

		public static IOrderedQueryable<TSource> OrderByDescending<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, IComparer<TKey> comparer)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			return (IOrderedQueryable<TSource>)source.Provider.CreateQuery<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource), typeof(TKey)), source.Expression, Expression.Quote(keySelector), Expression.Constant(comparer, typeof(IComparer<TKey>))));
		}

		public static IOrderedQueryable<TSource> ThenBy<TSource, TKey>(this IOrderedQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			return (IOrderedQueryable<TSource>)source.Provider.CreateQuery<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource), typeof(TKey)), source.Expression, Expression.Quote(keySelector)));
		}

		public static IOrderedQueryable<TSource> ThenBy<TSource, TKey>(this IOrderedQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, IComparer<TKey> comparer)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			return (IOrderedQueryable<TSource>)source.Provider.CreateQuery<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource), typeof(TKey)), source.Expression, Expression.Quote(keySelector), Expression.Constant(comparer, typeof(IComparer<TKey>))));
		}

		public static IOrderedQueryable<TSource> ThenByDescending<TSource, TKey>(this IOrderedQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			return (IOrderedQueryable<TSource>)source.Provider.CreateQuery<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource), typeof(TKey)), source.Expression, Expression.Quote(keySelector)));
		}

		public static IOrderedQueryable<TSource> ThenByDescending<TSource, TKey>(this IOrderedQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, IComparer<TKey> comparer)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			return (IOrderedQueryable<TSource>)source.Provider.CreateQuery<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource), typeof(TKey)), source.Expression, Expression.Quote(keySelector), Expression.Constant(comparer, typeof(IComparer<TKey>))));
		}

		public static IQueryable<TSource> Take<TSource>(this IQueryable<TSource> source, int count)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.CreateQuery<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Constant(count)));
		}

		public static IQueryable<TSource> TakeWhile<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return source.Provider.CreateQuery<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Quote(predicate)));
		}

		public static IQueryable<TSource> TakeWhile<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, int, bool>> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return source.Provider.CreateQuery<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Quote(predicate)));
		}

		public static IQueryable<TSource> Skip<TSource>(this IQueryable<TSource> source, int count)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.CreateQuery<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Constant(count)));
		}

		public static IQueryable<TSource> SkipWhile<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return source.Provider.CreateQuery<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Quote(predicate)));
		}

		public static IQueryable<TSource> SkipWhile<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, int, bool>> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return source.Provider.CreateQuery<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Quote(predicate)));
		}

		public static IQueryable<IGrouping<TKey, TSource>> GroupBy<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			return source.Provider.CreateQuery<IGrouping<TKey, TSource>>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource), typeof(TKey)), source.Expression, Expression.Quote(keySelector)));
		}

		public static IQueryable<IGrouping<TKey, TElement>> GroupBy<TSource, TKey, TElement>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TSource, TElement>> elementSelector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			if (elementSelector == null)
			{
				throw Error.ArgumentNull("elementSelector");
			}
			return source.Provider.CreateQuery<IGrouping<TKey, TElement>>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource), typeof(TKey), typeof(TElement)), source.Expression, Expression.Quote(keySelector), Expression.Quote(elementSelector)));
		}

		public static IQueryable<IGrouping<TKey, TSource>> GroupBy<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, IEqualityComparer<TKey> comparer)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			return source.Provider.CreateQuery<IGrouping<TKey, TSource>>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource), typeof(TKey)), source.Expression, Expression.Quote(keySelector), Expression.Constant(comparer, typeof(IEqualityComparer<TKey>))));
		}

		public static IQueryable<IGrouping<TKey, TElement>> GroupBy<TSource, TKey, TElement>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TSource, TElement>> elementSelector, IEqualityComparer<TKey> comparer)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			if (elementSelector == null)
			{
				throw Error.ArgumentNull("elementSelector");
			}
			return source.Provider.CreateQuery<IGrouping<TKey, TElement>>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource), typeof(TKey), typeof(TElement)), source.Expression, Expression.Quote(keySelector), Expression.Quote(elementSelector), Expression.Constant(comparer, typeof(IEqualityComparer<TKey>))));
		}

		public static IQueryable<TResult> GroupBy<TSource, TKey, TElement, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TSource, TElement>> elementSelector, Expression<Func<TKey, IEnumerable<TElement>, TResult>> resultSelector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			if (elementSelector == null)
			{
				throw Error.ArgumentNull("elementSelector");
			}
			if (resultSelector == null)
			{
				throw Error.ArgumentNull("resultSelector");
			}
			return source.Provider.CreateQuery<TResult>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource), typeof(TKey), typeof(TElement), typeof(TResult)), source.Expression, Expression.Quote(keySelector), Expression.Quote(elementSelector), Expression.Quote(resultSelector)));
		}

		public static IQueryable<TResult> GroupBy<TSource, TKey, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TKey, IEnumerable<TSource>, TResult>> resultSelector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			if (resultSelector == null)
			{
				throw Error.ArgumentNull("resultSelector");
			}
			return source.Provider.CreateQuery<TResult>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource), typeof(TKey), typeof(TResult)), source.Expression, Expression.Quote(keySelector), Expression.Quote(resultSelector)));
		}

		public static IQueryable<TResult> GroupBy<TSource, TKey, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TKey, IEnumerable<TSource>, TResult>> resultSelector, IEqualityComparer<TKey> comparer)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			if (resultSelector == null)
			{
				throw Error.ArgumentNull("resultSelector");
			}
			return source.Provider.CreateQuery<TResult>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource), typeof(TKey), typeof(TResult)), source.Expression, Expression.Quote(keySelector), Expression.Quote(resultSelector), Expression.Constant(comparer, typeof(IEqualityComparer<TKey>))));
		}

		public static IQueryable<TResult> GroupBy<TSource, TKey, TElement, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TSource, TElement>> elementSelector, Expression<Func<TKey, IEnumerable<TElement>, TResult>> resultSelector, IEqualityComparer<TKey> comparer)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			if (elementSelector == null)
			{
				throw Error.ArgumentNull("elementSelector");
			}
			if (resultSelector == null)
			{
				throw Error.ArgumentNull("resultSelector");
			}
			return source.Provider.CreateQuery<TResult>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource), typeof(TKey), typeof(TElement), typeof(TResult)), source.Expression, Expression.Quote(keySelector), Expression.Quote(elementSelector), Expression.Quote(resultSelector), Expression.Constant(comparer, typeof(IEqualityComparer<TKey>))));
		}

		public static IQueryable<TSource> Distinct<TSource>(this IQueryable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.CreateQuery<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression));
		}

		public static IQueryable<TSource> Distinct<TSource>(this IQueryable<TSource> source, IEqualityComparer<TSource> comparer)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.CreateQuery<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Constant(comparer, typeof(IEqualityComparer<TSource>))));
		}

		public static IQueryable<TSource> Concat<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2)
		{
			if (source1 == null)
			{
				throw Error.ArgumentNull("source1");
			}
			if (source2 == null)
			{
				throw Error.ArgumentNull("source2");
			}
			return source1.Provider.CreateQuery<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source1.Expression, GetSourceExpression(source2)));
		}

		public static IQueryable<TSource> Union<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2)
		{
			if (source1 == null)
			{
				throw Error.ArgumentNull("source1");
			}
			if (source2 == null)
			{
				throw Error.ArgumentNull("source2");
			}
			return source1.Provider.CreateQuery<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source1.Expression, GetSourceExpression(source2)));
		}

		public static IQueryable<TSource> Union<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2, IEqualityComparer<TSource> comparer)
		{
			if (source1 == null)
			{
				throw Error.ArgumentNull("source1");
			}
			if (source2 == null)
			{
				throw Error.ArgumentNull("source2");
			}
			return source1.Provider.CreateQuery<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source1.Expression, GetSourceExpression(source2), Expression.Constant(comparer, typeof(IEqualityComparer<TSource>))));
		}

		public static IQueryable<TSource> Intersect<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2)
		{
			if (source1 == null)
			{
				throw Error.ArgumentNull("source1");
			}
			if (source2 == null)
			{
				throw Error.ArgumentNull("source2");
			}
			return source1.Provider.CreateQuery<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source1.Expression, GetSourceExpression(source2)));
		}

		public static IQueryable<TSource> Intersect<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2, IEqualityComparer<TSource> comparer)
		{
			if (source1 == null)
			{
				throw Error.ArgumentNull("source1");
			}
			if (source2 == null)
			{
				throw Error.ArgumentNull("source2");
			}
			return source1.Provider.CreateQuery<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source1.Expression, GetSourceExpression(source2), Expression.Constant(comparer, typeof(IEqualityComparer<TSource>))));
		}

		public static IQueryable<TSource> Except<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2)
		{
			if (source1 == null)
			{
				throw Error.ArgumentNull("source1");
			}
			if (source2 == null)
			{
				throw Error.ArgumentNull("source2");
			}
			return source1.Provider.CreateQuery<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source1.Expression, GetSourceExpression(source2)));
		}

		public static IQueryable<TSource> Except<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2, IEqualityComparer<TSource> comparer)
		{
			if (source1 == null)
			{
				throw Error.ArgumentNull("source1");
			}
			if (source2 == null)
			{
				throw Error.ArgumentNull("source2");
			}
			return source1.Provider.CreateQuery<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source1.Expression, GetSourceExpression(source2), Expression.Constant(comparer, typeof(IEqualityComparer<TSource>))));
		}

		public static TSource First<TSource>(this IQueryable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression));
		}

		public static TSource First<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return source.Provider.Execute<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Quote(predicate)));
		}

		public static TSource FirstOrDefault<TSource>(this IQueryable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression));
		}

		public static TSource FirstOrDefault<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return source.Provider.Execute<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Quote(predicate)));
		}

		public static TSource Last<TSource>(this IQueryable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression));
		}

		public static TSource Last<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return source.Provider.Execute<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Quote(predicate)));
		}

		public static TSource LastOrDefault<TSource>(this IQueryable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression));
		}

		public static TSource LastOrDefault<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return source.Provider.Execute<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Quote(predicate)));
		}

		public static TSource Single<TSource>(this IQueryable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression));
		}

		public static TSource Single<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return source.Provider.Execute<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Quote(predicate)));
		}

		public static TSource SingleOrDefault<TSource>(this IQueryable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression));
		}

		public static TSource SingleOrDefault<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return source.Provider.Execute<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Quote(predicate)));
		}

		public static TSource ElementAt<TSource>(this IQueryable<TSource> source, int index)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (index < 0)
			{
				throw Error.ArgumentOutOfRange("index");
			}
			return source.Provider.Execute<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Constant(index)));
		}

		public static TSource ElementAtOrDefault<TSource>(this IQueryable<TSource> source, int index)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Constant(index)));
		}

		public static IQueryable<TSource> DefaultIfEmpty<TSource>(this IQueryable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.CreateQuery<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression));
		}

		public static IQueryable<TSource> DefaultIfEmpty<TSource>(this IQueryable<TSource> source, TSource defaultValue)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.CreateQuery<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Constant(defaultValue, typeof(TSource))));
		}

		public static bool Contains<TSource>(this IQueryable<TSource> source, TSource item)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<bool>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Constant(item, typeof(TSource))));
		}

		public static bool Contains<TSource>(this IQueryable<TSource> source, TSource item, IEqualityComparer<TSource> comparer)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<bool>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Constant(item, typeof(TSource)), Expression.Constant(comparer, typeof(IEqualityComparer<TSource>))));
		}

		public static IQueryable<TSource> Reverse<TSource>(this IQueryable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.CreateQuery<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression));
		}

		public static bool SequenceEqual<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2)
		{
			if (source1 == null)
			{
				throw Error.ArgumentNull("source1");
			}
			if (source2 == null)
			{
				throw Error.ArgumentNull("source2");
			}
			return source1.Provider.Execute<bool>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source1.Expression, GetSourceExpression(source2)));
		}

		public static bool SequenceEqual<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2, IEqualityComparer<TSource> comparer)
		{
			if (source1 == null)
			{
				throw Error.ArgumentNull("source1");
			}
			if (source2 == null)
			{
				throw Error.ArgumentNull("source2");
			}
			return source1.Provider.Execute<bool>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source1.Expression, GetSourceExpression(source2), Expression.Constant(comparer, typeof(IEqualityComparer<TSource>))));
		}

		public static bool Any<TSource>(this IQueryable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<bool>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression));
		}

		public static bool Any<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return source.Provider.Execute<bool>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Quote(predicate)));
		}

		public static bool All<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return source.Provider.Execute<bool>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Quote(predicate)));
		}

		public static int Count<TSource>(this IQueryable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<int>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression));
		}

		public static int Count<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return source.Provider.Execute<int>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Quote(predicate)));
		}

		public static long LongCount<TSource>(this IQueryable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<long>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression));
		}

		public static long LongCount<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return source.Provider.Execute<long>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Quote(predicate)));
		}

		public static TSource Min<TSource>(this IQueryable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression));
		}

		public static TResult Min<TSource, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, TResult>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<TResult>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource), typeof(TResult)), source.Expression, Expression.Quote(selector)));
		}

		public static TSource Max<TSource>(this IQueryable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression));
		}

		public static TResult Max<TSource, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, TResult>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<TResult>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource), typeof(TResult)), source.Expression, Expression.Quote(selector)));
		}

		public static int Sum(this IQueryable<int> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<int>(Expression.Call(null, (MethodInfo)MethodBase.GetCurrentMethod(), source.Expression));
		}

		public static int? Sum(this IQueryable<int?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<int?>(Expression.Call(null, (MethodInfo)MethodBase.GetCurrentMethod(), source.Expression));
		}

		public static long Sum(this IQueryable<long> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<long>(Expression.Call(null, (MethodInfo)MethodBase.GetCurrentMethod(), source.Expression));
		}

		public static long? Sum(this IQueryable<long?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<long?>(Expression.Call(null, (MethodInfo)MethodBase.GetCurrentMethod(), source.Expression));
		}

		public static float Sum(this IQueryable<float> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<float>(Expression.Call(null, (MethodInfo)MethodBase.GetCurrentMethod(), source.Expression));
		}

		public static float? Sum(this IQueryable<float?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<float?>(Expression.Call(null, (MethodInfo)MethodBase.GetCurrentMethod(), source.Expression));
		}

		public static double Sum(this IQueryable<double> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<double>(Expression.Call(null, (MethodInfo)MethodBase.GetCurrentMethod(), source.Expression));
		}

		public static double? Sum(this IQueryable<double?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<double?>(Expression.Call(null, (MethodInfo)MethodBase.GetCurrentMethod(), source.Expression));
		}

		public static decimal Sum(this IQueryable<decimal> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<decimal>(Expression.Call(null, (MethodInfo)MethodBase.GetCurrentMethod(), source.Expression));
		}

		public static decimal? Sum(this IQueryable<decimal?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<decimal?>(Expression.Call(null, (MethodInfo)MethodBase.GetCurrentMethod(), source.Expression));
		}

		public static int Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, int>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<int>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		public static int? Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, int?>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<int?>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		public static long Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, long>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<long>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		public static long? Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, long?>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<long?>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		public static float Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, float>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<float>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		public static float? Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, float?>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<float?>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		public static double Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, double>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<double>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		public static double? Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, double?>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<double?>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		public static decimal Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, decimal>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<decimal>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		public static decimal? Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, decimal?>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<decimal?>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		public static double Average(this IQueryable<int> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<double>(Expression.Call(null, (MethodInfo)MethodBase.GetCurrentMethod(), source.Expression));
		}

		public static double? Average(this IQueryable<int?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<double?>(Expression.Call(null, (MethodInfo)MethodBase.GetCurrentMethod(), source.Expression));
		}

		public static double Average(this IQueryable<long> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<double>(Expression.Call(null, (MethodInfo)MethodBase.GetCurrentMethod(), source.Expression));
		}

		public static double? Average(this IQueryable<long?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<double?>(Expression.Call(null, (MethodInfo)MethodBase.GetCurrentMethod(), source.Expression));
		}

		public static float Average(this IQueryable<float> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<float>(Expression.Call(null, (MethodInfo)MethodBase.GetCurrentMethod(), source.Expression));
		}

		public static float? Average(this IQueryable<float?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<float?>(Expression.Call(null, (MethodInfo)MethodBase.GetCurrentMethod(), source.Expression));
		}

		public static double Average(this IQueryable<double> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<double>(Expression.Call(null, (MethodInfo)MethodBase.GetCurrentMethod(), source.Expression));
		}

		public static double? Average(this IQueryable<double?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<double?>(Expression.Call(null, (MethodInfo)MethodBase.GetCurrentMethod(), source.Expression));
		}

		public static decimal Average(this IQueryable<decimal> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<decimal>(Expression.Call(null, (MethodInfo)MethodBase.GetCurrentMethod(), source.Expression));
		}

		public static decimal? Average(this IQueryable<decimal?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<decimal?>(Expression.Call(null, (MethodInfo)MethodBase.GetCurrentMethod(), source.Expression));
		}

		public static double Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, int>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<double>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		public static double? Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, int?>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<double?>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		public static float Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, float>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<float>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		public static float? Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, float?>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<float?>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		public static double Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, long>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<double>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		public static double? Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, long?>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<double?>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		public static double Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, double>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<double>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		public static double? Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, double?>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<double?>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		public static decimal Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, decimal>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<decimal>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		public static decimal? Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, decimal?>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<decimal?>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		public static TSource Aggregate<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, TSource, TSource>> func)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (func == null)
			{
				throw Error.ArgumentNull("func");
			}
			return source.Provider.Execute<TSource>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource)), source.Expression, Expression.Quote(func)));
		}

		public static TAccumulate Aggregate<TSource, TAccumulate>(this IQueryable<TSource> source, TAccumulate seed, Expression<Func<TAccumulate, TSource, TAccumulate>> func)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (func == null)
			{
				throw Error.ArgumentNull("func");
			}
			return source.Provider.Execute<TAccumulate>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource), typeof(TAccumulate)), source.Expression, Expression.Constant(seed), Expression.Quote(func)));
		}

		public static TResult Aggregate<TSource, TAccumulate, TResult>(this IQueryable<TSource> source, TAccumulate seed, Expression<Func<TAccumulate, TSource, TAccumulate>> func, Expression<Func<TAccumulate, TResult>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (func == null)
			{
				throw Error.ArgumentNull("func");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<TResult>(Expression.Call(null, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(typeof(TSource), typeof(TAccumulate), typeof(TResult)), source.Expression, Expression.Constant(seed), Expression.Quote(func), Expression.Quote(selector)));
		}
	}
	public static class Enumerable
	{
		private abstract class Iterator<TSource> : IEnumerable<TSource>, IEnumerable, IEnumerator<TSource>, IDisposable, IEnumerator
		{
			private int threadId;

			internal int state;

			internal TSource current;

			public TSource Current => current;

			object IEnumerator.Current => Current;

			public Iterator()
			{
				threadId = Thread.CurrentThread.ManagedThreadId;
			}

			public abstract Iterator<TSource> Clone();

			public virtual void Dispose()
			{
				current = default(TSource);
				state = -1;
			}

			public IEnumerator<TSource> GetEnumerator()
			{
				if (threadId == Thread.CurrentThread.ManagedThreadId && state == 0)
				{
					state = 1;
					return this;
				}
				Iterator<TSource> iterator = Clone();
				iterator.state = 1;
				return iterator;
			}

			public abstract bool MoveNext();

			public abstract IEnumerable<TResult> Select<TResult>(Func<TSource, TResult> selector);

			public abstract IEnumerable<TSource> Where(Func<TSource, bool> predicate);

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}

			void IEnumerator.Reset()
			{
				throw new NotImplementedException();
			}
		}

		private class WhereEnumerableIterator<TSource> : Iterator<TSource>
		{
			private IEnumerable<TSource> source;

			private Func<TSource, bool> predicate;

			private IEnumerator<TSource> enumerator;

			public WhereEnumerableIterator(IEnumerable<TSource> source, Func<TSource, bool> predicate)
			{
				this.source = source;
				this.predicate = predicate;
			}

			public override Iterator<TSource> Clone()
			{
				return new WhereEnumerableIterator<TSource>(source, predicate);
			}

			public override void Dispose()
			{
				if (enumerator != null)
				{
					enumerator.Dispose();
				}
				enumerator = null;
				base.Dispose();
			}

			public override bool MoveNext()
			{
				switch (state)
				{
				case 1:
					enumerator = source.GetEnumerator();
					state = 2;
					goto case 2;
				case 2:
					while (enumerator.MoveNext())
					{
						TSource arg = enumerator.Current;
						if (predicate(arg))
						{
							current = arg;
							return true;
						}
					}
					Dispose();
					break;
				}
				return false;
			}

			public override IEnumerable<TResult> Select<TResult>(Func<TSource, TResult> selector)
			{
				return new WhereSelectEnumerableIterator<TSource, TResult>(source, predicate, selector);
			}

			public override IEnumerable<TSource> Where(Func<TSource, bool> predicate)
			{
				return new WhereEnumerableIterator<TSource>(source, CombinePredicates(this.predicate, predicate));
			}
		}

		private class WhereArrayIterator<TSource> : Iterator<TSource>
		{
			private TSource[] source;

			private Func<TSource, bool> predicate;

			private int index;

			public WhereArrayIterator(TSource[] source, Func<TSource, bool> predicate)
			{
				this.source = source;
				this.predicate = predicate;
			}

			public override Iterator<TSource> Clone()
			{
				return new WhereArrayIterator<TSource>(source, predicate);
			}

			public override bool MoveNext()
			{
				if (state == 1)
				{
					while (index < source.Length)
					{
						TSource arg = source[index];
						index++;
						if (predicate(arg))
						{
							current = arg;
							return true;
						}
					}
					Dispose();
				}
				return false;
			}

			public override IEnumerable<TResult> Select<TResult>(Func<TSource, TResult> selector)
			{
				return new WhereSelectArrayIterator<TSource, TResult>(source, predicate, selector);
			}

			public override IEnumerable<TSource> Where(Func<TSource, bool> predicate)
			{
				return new WhereArrayIterator<TSource>(source, CombinePredicates(this.predicate, predicate));
			}
		}

		private class WhereListIterator<TSource> : Iterator<TSource>
		{
			private List<TSource> source;

			private Func<TSource, bool> predicate;

			private List<TSource>.Enumerator enumerator;

			public WhereListIterator(List<TSource> source, Func<TSource, bool> predicate)
			{
				this.source = source;
				this.predicate = predicate;
			}

			public override Iterator<TSource> Clone()
			{
				return new WhereListIterator<TSource>(source, predicate);
			}

			public override bool MoveNext()
			{
				switch (state)
				{
				case 1:
					enumerator = source.GetEnumerator();
					state = 2;
					goto case 2;
				case 2:
					while (enumerator.MoveNext())
					{
						TSource arg = enumerator.Current;
						if (predicate(arg))
						{
							current = arg;
							return true;
						}
					}
					Dispose();
					break;
				}
				return false;
			}

			public override IEnumerable<TResult> Select<TResult>(Func<TSource, TResult> selector)
			{
				return new WhereSelectListIterator<TSource, TResult>(source, predicate, selector);
			}

			public override IEnumerable<TSource> Where(Func<TSource, bool> predicate)
			{
				return new WhereListIterator<TSource>(source, CombinePredicates(this.predicate, predicate));
			}
		}

		private class WhereSelectEnumerableIterator<TSource, TResult> : Iterator<TResult>
		{
			private IEnumerable<TSource> source;

			private Func<TSource, bool> predicate;

			private Func<TSource, TResult> selector;

			private IEnumerator<TSource> enumerator;

			public WhereSelectEnumerableIterator(IEnumerable<TSource> source, Func<TSource, bool> predicate, Func<TSource, TResult> selector)
			{
				this.source = source;
				this.predicate = predicate;
				this.selector = selector;
			}

			public override Iterator<TResult> Clone()
			{
				return new WhereSelectEnumerableIterator<TSource, TResult>(source, predicate, selector);
			}

			public override void Dispose()
			{
				if (enumerator != null)
				{
					enumerator.Dispose();
				}
				enumerator = null;
				base.Dispose();
			}

			public override bool MoveNext()
			{
				switch (state)
				{
				case 1:
					enumerator = source.GetEnumerator();
					state = 2;
					goto case 2;
				case 2:
					while (enumerator.MoveNext())
					{
						TSource arg = enumerator.Current;
						if (predicate == null || predicate(arg))
						{
							current = selector(arg);
							return true;
						}
					}
					Dispose();
					break;
				}
				return false;
			}

			public override IEnumerable<TResult2> Select<TResult2>(Func<TResult, TResult2> selector)
			{
				return new WhereSelectEnumerableIterator<TSource, TResult2>(source, predicate, CombineSelectors(this.selector, selector));
			}

			public override IEnumerable<TResult> Where(Func<TResult, bool> predicate)
			{
				return new WhereEnumerableIterator<TResult>(this, predicate);
			}
		}

		private class WhereSelectArrayIterator<TSource, TResult> : Iterator<TResult>
		{
			private TSource[] source;

			private Func<TSource, bool> predicate;

			private Func<TSource, TResult> selector;

			private int index;

			public WhereSelectArrayIterator(TSource[] source, Func<TSource, bool> predicate, Func<TSource, TResult> selector)
			{
				this.source = source;
				this.predicate = predicate;
				this.selector = selector;
			}

			public override Iterator<TResult> Clone()
			{
				return new WhereSelectArrayIterator<TSource, TResult>(source, predicate, selector);
			}

			public override bool MoveNext()
			{
				if (state == 1)
				{
					while (index < source.Length)
					{
						TSource arg = source[index];
						index++;
						if (predicate == null || predicate(arg))
						{
							current = selector(arg);
							return true;
						}
					}
					Dispose();
				}
				return false;
			}

			public override IEnumerable<TResult2> Select<TResult2>(Func<TResult, TResult2> selector)
			{
				return new WhereSelectArrayIterator<TSource, TResult2>(source, predicate, CombineSelectors(this.selector, selector));
			}

			public override IEnumerable<TResult> Where(Func<TResult, bool> predicate)
			{
				return new WhereEnumerableIterator<TResult>(this, predicate);
			}
		}

		private class WhereSelectListIterator<TSource, TResult> : Iterator<TResult>
		{
			private List<TSource> source;

			private Func<TSource, bool> predicate;

			private Func<TSource, TResult> selector;

			private List<TSource>.Enumerator enumerator;

			public WhereSelectListIterator(List<TSource> source, Func<TSource, bool> predicate, Func<TSource, TResult> selector)
			{
				this.source = source;
				this.predicate = predicate;
				this.selector = selector;
			}

			public override Iterator<TResult> Clone()
			{
				return new WhereSelectListIterator<TSource, TResult>(source, predicate, selector);
			}

			public override bool MoveNext()
			{
				switch (state)
				{
				case 1:
					enumerator = source.GetEnumerator();
					state = 2;
					goto case 2;
				case 2:
					while (enumerator.MoveNext())
					{
						TSource arg = enumerator.Current;
						if (predicate == null || predicate(arg))
						{
							current = selector(arg);
							return true;
						}
					}
					Dispose();
					break;
				}
				return false;
			}

			public override IEnumerable<TResult2> Select<TResult2>(Func<TResult, TResult2> selector)
			{
				return new WhereSelectListIterator<TSource, TResult2>(source, predicate, CombineSelectors(this.selector, selector));
			}

			public override IEnumerable<TResult> Where(Func<TResult, bool> predicate)
			{
				return new WhereEnumerableIterator<TResult>(this, predicate);
			}
		}

		public static IEnumerable<TSource> Where<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			if (source is Iterator<TSource>)
			{
				return ((Iterator<TSource>)source).Where(predicate);
			}
			if (source is TSource[])
			{
				return new WhereArrayIterator<TSource>((TSource[])source, predicate);
			}
			if (source is List<TSource>)
			{
				return new WhereListIterator<TSource>((List<TSource>)source, predicate);
			}
			return new WhereEnumerableIterator<TSource>(source, predicate);
		}

		public static IEnumerable<TSource> Where<TSource>(this IEnumerable<TSource> source, Func<TSource, int, bool> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return WhereIterator(source, predicate);
		}

		private static IEnumerable<TSource> WhereIterator<TSource>(IEnumerable<TSource> source, Func<TSource, int, bool> predicate)
		{
			int index = -1;
			foreach (TSource element in source)
			{
				index = checked(index + 1);
				if (predicate(element, index))
				{
					yield return element;
				}
			}
		}

		public static IEnumerable<TResult> Select<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			if (source is Iterator<TSource>)
			{
				return ((Iterator<TSource>)source).Select(selector);
			}
			if (source is TSource[])
			{
				return new WhereSelectArrayIterator<TSource, TResult>((TSource[])source, null, selector);
			}
			if (source is List<TSource>)
			{
				return new WhereSelectListIterator<TSource, TResult>((List<TSource>)source, null, selector);
			}
			return new WhereSelectEnumerableIterator<TSource, TResult>(source, null, selector);
		}

		public static IEnumerable<TResult> Select<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, int, TResult> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return SelectIterator(source, selector);
		}

		private static IEnumerable<TResult> SelectIterator<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, int, TResult> selector)
		{
			int index = -1;
			foreach (TSource element in source)
			{
				index = checked(index + 1);
				yield return selector(element, index);
			}
		}

		private static Func<TSource, bool> CombinePredicates<TSource>(Func<TSource, bool> predicate1, Func<TSource, bool> predicate2)
		{
			return (TSource x) => predicate1(x) && predicate2(x);
		}

		private static Func<TSource, TResult> CombineSelectors<TSource, TMiddle, TResult>(Func<TSource, TMiddle> selector1, Func<TMiddle, TResult> selector2)
		{
			return (TSource x) => selector2(selector1(x));
		}

		public static IEnumerable<TResult> SelectMany<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, IEnumerable<TResult>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return SelectManyIterator(source, selector);
		}

		private static IEnumerable<TResult> SelectManyIterator<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, IEnumerable<TResult>> selector)
		{
			foreach (TSource element in source)
			{
				foreach (TResult item in selector(element))
				{
					yield return item;
				}
			}
		}

		public static IEnumerable<TResult> SelectMany<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, int, IEnumerable<TResult>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return SelectManyIterator(source, selector);
		}

		private static IEnumerable<TResult> SelectManyIterator<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, int, IEnumerable<TResult>> selector)
		{
			int index = -1;
			foreach (TSource element in source)
			{
				index = checked(index + 1);
				foreach (TResult item in selector(element, index))
				{
					yield return item;
				}
			}
		}

		public static IEnumerable<TResult> SelectMany<TSource, TCollection, TResult>(this IEnumerable<TSource> source, Func<TSource, int, IEnumerable<TCollection>> collectionSelector, Func<TSource, TCollection, TResult> resultSelector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (collectionSelector == null)
			{
				throw Error.ArgumentNull("collectionSelector");
			}
			if (resultSelector == null)
			{
				throw Error.ArgumentNull("resultSelector");
			}
			return SelectManyIterator(source, collectionSelector, resultSelector);
		}

		private static IEnumerable<TResult> SelectManyIterator<TSource, TCollection, TResult>(IEnumerable<TSource> source, Func<TSource, int, IEnumerable<TCollection>> collectionSelector, Func<TSource, TCollection, TResult> resultSelector)
		{
			int index = -1;
			foreach (TSource element in source)
			{
				index = checked(index + 1);
				foreach (TCollection subElement in collectionSelector(element, index))
				{
					yield return resultSelector(element, subElement);
				}
			}
		}

		public static IEnumerable<TResult> SelectMany<TSource, TCollection, TResult>(this IEnumerable<TSource> source, Func<TSource, IEnumerable<TCollection>> collectionSelector, Func<TSource, TCollection, TResult> resultSelector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (collectionSelector == null)
			{
				throw Error.ArgumentNull("collectionSelector");
			}
			if (resultSelector == null)
			{
				throw Error.ArgumentNull("resultSelector");
			}
			return SelectManyIterator(source, collectionSelector, resultSelector);
		}

		private static IEnumerable<TResult> SelectManyIterator<TSource, TCollection, TResult>(IEnumerable<TSource> source, Func<TSource, IEnumerable<TCollection>> collectionSelector, Func<TSource, TCollection, TResult> resultSelector)
		{
			foreach (TSource element in source)
			{
				foreach (TCollection subElement in collectionSelector(element))
				{
					yield return resultSelector(element, subElement);
				}
			}
		}

		public static IEnumerable<TSource> Take<TSource>(this IEnumerable<TSource> source, int count)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return TakeIterator(source, count);
		}

		private static IEnumerable<TSource> TakeIterator<TSource>(IEnumerable<TSource> source, int count)
		{
			if (count <= 0)
			{
				yield break;
			}
			foreach (TSource item in source)
			{
				yield return item;
				int num;
				count = (num = count - 1);
				if (num == 0)
				{
					break;
				}
			}
		}

		public static IEnumerable<TSource> TakeWhile<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return TakeWhileIterator(source, predicate);
		}

		private static IEnumerable<TSource> TakeWhileIterator<TSource>(IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			foreach (TSource element in source)
			{
				if (predicate(element))
				{
					yield return element;
					continue;
				}
				break;
			}
		}

		public static IEnumerable<TSource> TakeWhile<TSource>(this IEnumerable<TSource> source, Func<TSource, int, bool> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return TakeWhileIterator(source, predicate);
		}

		private static IEnumerable<TSource> TakeWhileIterator<TSource>(IEnumerable<TSource> source, Func<TSource, int, bool> predicate)
		{
			int index = -1;
			foreach (TSource element in source)
			{
				index = checked(index + 1);
				if (predicate(element, index))
				{
					yield return element;
					continue;
				}
				break;
			}
		}

		public static IEnumerable<TSource> Skip<TSource>(this IEnumerable<TSource> source, int count)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return SkipIterator(source, count);
		}

		private static IEnumerable<TSource> SkipIterator<TSource>(IEnumerable<TSource> source, int count)
		{
			using IEnumerator<TSource> e = source.GetEnumerator();
			while (count > 0 && e.MoveNext())
			{
				count--;
			}
			if (count <= 0)
			{
				while (e.MoveNext())
				{
					yield return e.Current;
				}
			}
		}

		public static IEnumerable<TSource> SkipWhile<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return SkipWhileIterator(source, predicate);
		}

		private static IEnumerable<TSource> SkipWhileIterator<TSource>(IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			bool yielding = false;
			foreach (TSource element in source)
			{
				if (!yielding && !predicate(element))
				{
					yielding = true;
				}
				if (yielding)
				{
					yield return element;
				}
			}
		}

		public static IEnumerable<TSource> SkipWhile<TSource>(this IEnumerable<TSource> source, Func<TSource, int, bool> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return SkipWhileIterator(source, predicate);
		}

		private static IEnumerable<TSource> SkipWhileIterator<TSource>(IEnumerable<TSource> source, Func<TSource, int, bool> predicate)
		{
			int index = -1;
			bool yielding = false;
			foreach (TSource element in source)
			{
				index = checked(index + 1);
				if (!yielding && !predicate(element, index))
				{
					yielding = true;
				}
				if (yielding)
				{
					yield return element;
				}
			}
		}

		public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector)
		{
			if (outer == null)
			{
				throw Error.ArgumentNull("outer");
			}
			if (inner == null)
			{
				throw Error.ArgumentNull("inner");
			}
			if (outerKeySelector == null)
			{
				throw Error.ArgumentNull("outerKeySelector");
			}
			if (innerKeySelector == null)
			{
				throw Error.ArgumentNull("innerKeySelector");
			}
			if (resultSelector == null)
			{
				throw Error.ArgumentNull("resultSelector");
			}
			return JoinIterator(outer, inner, outerKeySelector, innerKeySelector, resultSelector, null);
		}

		public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector, IEqualityComparer<TKey> comparer)
		{
			if (outer == null)
			{
				throw Error.ArgumentNull("outer");
			}
			if (inner == null)
			{
				throw Error.ArgumentNull("inner");
			}
			if (outerKeySelector == null)
			{
				throw Error.ArgumentNull("outerKeySelector");
			}
			if (innerKeySelector == null)
			{
				throw Error.ArgumentNull("innerKeySelector");
			}
			if (resultSelector == null)
			{
				throw Error.ArgumentNull("resultSelector");
			}
			return JoinIterator(outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer);
		}

		private static IEnumerable<TResult> JoinIterator<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector, IEqualityComparer<TKey> comparer)
		{
			Lookup<TKey, TInner> lookup = Lookup<TKey, TInner>.CreateForJoin(inner, innerKeySelector, comparer);
			foreach (TOuter item in outer)
			{
				Lookup<TKey, TInner>.Grouping g = lookup.GetGrouping(outerKeySelector(item), create: false);
				if (g != null)
				{
					for (int i = 0; i < g.count; i++)
					{
						yield return resultSelector(item, g.elements[i]);
					}
				}
			}
		}

		public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector)
		{
			if (outer == null)
			{
				throw Error.ArgumentNull("outer");
			}
			if (inner == null)
			{
				throw Error.ArgumentNull("inner");
			}
			if (outerKeySelector == null)
			{
				throw Error.ArgumentNull("outerKeySelector");
			}
			if (innerKeySelector == null)
			{
				throw Error.ArgumentNull("innerKeySelector");
			}
			if (resultSelector == null)
			{
				throw Error.ArgumentNull("resultSelector");
			}
			return GroupJoinIterator(outer, inner, outerKeySelector, innerKeySelector, resultSelector, null);
		}

		public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector, IEqualityComparer<TKey> comparer)
		{
			if (outer == null)
			{
				throw Error.ArgumentNull("outer");
			}
			if (inner == null)
			{
				throw Error.ArgumentNull("inner");
			}
			if (outerKeySelector == null)
			{
				throw Error.ArgumentNull("outerKeySelector");
			}
			if (innerKeySelector == null)
			{
				throw Error.ArgumentNull("innerKeySelector");
			}
			if (resultSelector == null)
			{
				throw Error.ArgumentNull("resultSelector");
			}
			return GroupJoinIterator(outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer);
		}

		private static IEnumerable<TResult> GroupJoinIterator<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector, IEqualityComparer<TKey> comparer)
		{
			Lookup<TKey, TInner> lookup = Lookup<TKey, TInner>.CreateForJoin(inner, innerKeySelector, comparer);
			foreach (TOuter item in outer)
			{
				yield return resultSelector(item, lookup[outerKeySelector(item)]);
			}
		}

		public static IOrderedEnumerable<TSource> OrderBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector)
		{
			return new OrderedEnumerable<TSource, TKey>(source, keySelector, null, descending: false);
		}

		public static IOrderedEnumerable<TSource> OrderBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IComparer<TKey> comparer)
		{
			return new OrderedEnumerable<TSource, TKey>(source, keySelector, comparer, descending: false);
		}

		public static IOrderedEnumerable<TSource> OrderByDescending<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector)
		{
			return new OrderedEnumerable<TSource, TKey>(source, keySelector, null, descending: true);
		}

		public static IOrderedEnumerable<TSource> OrderByDescending<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IComparer<TKey> comparer)
		{
			return new OrderedEnumerable<TSource, TKey>(source, keySelector, comparer, descending: true);
		}

		public static IOrderedEnumerable<TSource> ThenBy<TSource, TKey>(this IOrderedEnumerable<TSource> source, Func<TSource, TKey> keySelector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.CreateOrderedEnumerable(keySelector, null, descending: false);
		}

		public static IOrderedEnumerable<TSource> ThenBy<TSource, TKey>(this IOrderedEnumerable<TSource> source, Func<TSource, TKey> keySelector, IComparer<TKey> comparer)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.CreateOrderedEnumerable(keySelector, comparer, descending: false);
		}

		public static IOrderedEnumerable<TSource> ThenByDescending<TSource, TKey>(this IOrderedEnumerable<TSource> source, Func<TSource, TKey> keySelector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.CreateOrderedEnumerable(keySelector, null, descending: true);
		}

		public static IOrderedEnumerable<TSource> ThenByDescending<TSource, TKey>(this IOrderedEnumerable<TSource> source, Func<TSource, TKey> keySelector, IComparer<TKey> comparer)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.CreateOrderedEnumerable(keySelector, comparer, descending: true);
		}

		public static IEnumerable<IGrouping<TKey, TSource>> GroupBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector)
		{
			return new GroupedEnumerable<TSource, TKey, TSource>(source, keySelector, IdentityFunction<TSource>.Instance, null);
		}

		public static IEnumerable<IGrouping<TKey, TSource>> GroupBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IEqualityComparer<TKey> comparer)
		{
			return new GroupedEnumerable<TSource, TKey, TSource>(source, keySelector, IdentityFunction<TSource>.Instance, comparer);
		}

		public static IEnumerable<IGrouping<TKey, TElement>> GroupBy<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector)
		{
			return new GroupedEnumerable<TSource, TKey, TElement>(source, keySelector, elementSelector, null);
		}

		public static IEnumerable<IGrouping<TKey, TElement>> GroupBy<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, IEqualityComparer<TKey> comparer)
		{
			return new GroupedEnumerable<TSource, TKey, TElement>(source, keySelector, elementSelector, comparer);
		}

		public static IEnumerable<TResult> GroupBy<TSource, TKey, TResult>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TKey, IEnumerable<TSource>, TResult> resultSelector)
		{
			return new GroupedEnumerable<TSource, TKey, TSource, TResult>(source, keySelector, IdentityFunction<TSource>.Instance, resultSelector, null);
		}

		public static IEnumerable<TResult> GroupBy<TSource, TKey, TElement, TResult>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, TResult> resultSelector)
		{
			return new GroupedEnumerable<TSource, TKey, TElement, TResult>(source, keySelector, elementSelector, resultSelector, null);
		}

		public static IEnumerable<TResult> GroupBy<TSource, TKey, TResult>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TKey, IEnumerable<TSource>, TResult> resultSelector, IEqualityComparer<TKey> comparer)
		{
			return new GroupedEnumerable<TSource, TKey, TSource, TResult>(source, keySelector, IdentityFunction<TSource>.Instance, resultSelector, comparer);
		}

		public static IEnumerable<TResult> GroupBy<TSource, TKey, TElement, TResult>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, TResult> resultSelector, IEqualityComparer<TKey> comparer)
		{
			return new GroupedEnumerable<TSource, TKey, TElement, TResult>(source, keySelector, elementSelector, resultSelector, comparer);
		}

		public static IEnumerable<TSource> Concat<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second)
		{
			if (first == null)
			{
				throw Error.ArgumentNull("first");
			}
			if (second == null)
			{
				throw Error.ArgumentNull("second");
			}
			return ConcatIterator(first, second);
		}

		private static IEnumerable<TSource> ConcatIterator<TSource>(IEnumerable<TSource> first, IEnumerable<TSource> second)
		{
			foreach (TSource item in first)
			{
				yield return item;
			}
			foreach (TSource item2 in second)
			{
				yield return item2;
			}
		}

		public static IEnumerable<TSource> Distinct<TSource>(this IEnumerable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return DistinctIterator(source, null);
		}

		public static IEnumerable<TSource> Distinct<TSource>(this IEnumerable<TSource> source, IEqualityComparer<TSource> comparer)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return DistinctIterator(source, comparer);
		}

		private static IEnumerable<TSource> DistinctIterator<TSource>(IEnumerable<TSource> source, IEqualityComparer<TSource> comparer)
		{
			Set<TSource> set = new Set<TSource>(comparer);
			foreach (TSource element in source)
			{
				if (set.Add(element))
				{
					yield return element;
				}
			}
		}

		public static IEnumerable<TSource> Union<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second)
		{
			if (first == null)
			{
				throw Error.ArgumentNull("first");
			}
			if (second == null)
			{
				throw Error.ArgumentNull("second");
			}
			return UnionIterator(first, second, null);
		}

		public static IEnumerable<TSource> Union<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer)
		{
			if (first == null)
			{
				throw Error.ArgumentNull("first");
			}
			if (second == null)
			{
				throw Error.ArgumentNull("second");
			}
			return UnionIterator(first, second, comparer);
		}

		private static IEnumerable<TSource> UnionIterator<TSource>(IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer)
		{
			Set<TSource> set = new Set<TSource>(comparer);
			foreach (TSource element2 in first)
			{
				if (set.Add(element2))
				{
					yield return element2;
				}
			}
			foreach (TSource element in second)
			{
				if (set.Add(element))
				{
					yield return element;
				}
			}
		}

		public static IEnumerable<TSource> Intersect<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second)
		{
			if (first == null)
			{
				throw Error.ArgumentNull("first");
			}
			if (second == null)
			{
				throw Error.ArgumentNull("second");
			}
			return IntersectIterator(first, second, null);
		}

		public static IEnumerable<TSource> Intersect<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer)
		{
			if (first == null)
			{
				throw Error.ArgumentNull("first");
			}
			if (second == null)
			{
				throw Error.ArgumentNull("second");
			}
			return IntersectIterator(first, second, comparer);
		}

		private static IEnumerable<TSource> IntersectIterator<TSource>(IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer)
		{
			Set<TSource> set = new Set<TSource>(comparer);
			foreach (TSource item in second)
			{
				set.Add(item);
			}
			foreach (TSource element in first)
			{
				if (set.Remove(element))
				{
					yield return element;
				}
			}
		}

		public static IEnumerable<TSource> Except<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second)
		{
			if (first == null)
			{
				throw Error.ArgumentNull("first");
			}
			if (second == null)
			{
				throw Error.ArgumentNull("second");
			}
			return ExceptIterator(first, second, null);
		}

		public static IEnumerable<TSource> Except<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer)
		{
			if (first == null)
			{
				throw Error.ArgumentNull("first");
			}
			if (second == null)
			{
				throw Error.ArgumentNull("second");
			}
			return ExceptIterator(first, second, comparer);
		}

		private static IEnumerable<TSource> ExceptIterator<TSource>(IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer)
		{
			Set<TSource> set = new Set<TSource>(comparer);
			foreach (TSource item in second)
			{
				set.Add(item);
			}
			foreach (TSource element in first)
			{
				if (set.Add(element))
				{
					yield return element;
				}
			}
		}

		public static IEnumerable<TSource> Reverse<TSource>(this IEnumerable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return ReverseIterator(source);
		}

		private static IEnumerable<TSource> ReverseIterator<TSource>(IEnumerable<TSource> source)
		{
			Buffer<TSource> buffer = new Buffer<TSource>(source);
			for (int i = buffer.count - 1; i >= 0; i--)
			{
				yield return buffer.items[i];
			}
		}

		public static bool SequenceEqual<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second)
		{
			return first.SequenceEqual(second, null);
		}

		public static bool SequenceEqual<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer)
		{
			if (comparer == null)
			{
				comparer = EqualityComparer<TSource>.Default;
			}
			if (first == null)
			{
				throw Error.ArgumentNull("first");
			}
			if (second == null)
			{
				throw Error.ArgumentNull("second");
			}
			using (IEnumerator<TSource> enumerator = first.GetEnumerator())
			{
				using IEnumerator<TSource> enumerator2 = second.GetEnumerator();
				while (enumerator.MoveNext())
				{
					if (!enumerator2.MoveNext() || !comparer.Equals(enumerator.Current, enumerator2.Current))
					{
						return false;
					}
				}
				if (enumerator2.MoveNext())
				{
					return false;
				}
			}
			return true;
		}

		public static IEnumerable<TSource> AsEnumerable<TSource>(this IEnumerable<TSource> source)
		{
			return source;
		}

		public static TSource[] ToArray<TSource>(this IEnumerable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return new Buffer<TSource>(source).ToArray();
		}

		public static List<TSource> ToList<TSource>(this IEnumerable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return new List<TSource>(source);
		}

		public static Dictionary<TKey, TSource> ToDictionary<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector)
		{
			return source.ToDictionary(keySelector, IdentityFunction<TSource>.Instance, null);
		}

		public static Dictionary<TKey, TSource> ToDictionary<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IEqualityComparer<TKey> comparer)
		{
			return source.ToDictionary(keySelector, IdentityFunction<TSource>.Instance, comparer);
		}

		public static Dictionary<TKey, TElement> ToDictionary<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector)
		{
			return source.ToDictionary(keySelector, elementSelector, null);
		}

		public static Dictionary<TKey, TElement> ToDictionary<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, IEqualityComparer<TKey> comparer)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			if (elementSelector == null)
			{
				throw Error.ArgumentNull("elementSelector");
			}
			Dictionary<TKey, TElement> dictionary = new Dictionary<TKey, TElement>(comparer);
			foreach (TSource item in source)
			{
				dictionary.Add(keySelector(item), elementSelector(item));
			}
			return dictionary;
		}

		public static ILookup<TKey, TSource> ToLookup<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector)
		{
			return Lookup<TKey, TSource>.Create(source, keySelector, IdentityFunction<TSource>.Instance, null);
		}

		public static ILookup<TKey, TSource> ToLookup<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IEqualityComparer<TKey> comparer)
		{
			return Lookup<TKey, TSource>.Create(source, keySelector, IdentityFunction<TSource>.Instance, comparer);
		}

		public static ILookup<TKey, TElement> ToLookup<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector)
		{
			return Lookup<TKey, TElement>.Create(source, keySelector, elementSelector, null);
		}

		public static ILookup<TKey, TElement> ToLookup<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, IEqualityComparer<TKey> comparer)
		{
			return Lookup<TKey, TElement>.Create(source, keySelector, elementSelector, comparer);
		}

		public static IEnumerable<TSource> DefaultIfEmpty<TSource>(this IEnumerable<TSource> source)
		{
			return source.DefaultIfEmpty(default(TSource));
		}

		public static IEnumerable<TSource> DefaultIfEmpty<TSource>(this IEnumerable<TSource> source, TSource defaultValue)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return DefaultIfEmptyIterator(source, defaultValue);
		}

		private static IEnumerable<TSource> DefaultIfEmptyIterator<TSource>(IEnumerable<TSource> source, TSource defaultValue)
		{
			using IEnumerator<TSource> e = source.GetEnumerator();
			if (e.MoveNext())
			{
				do
				{
					yield return e.Current;
				}
				while (e.MoveNext());
			}
			else
			{
				yield return defaultValue;
			}
		}

		public static IEnumerable<TResult> OfType<TResult>(this IEnumerable source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return OfTypeIterator<TResult>(source);
		}

		private static IEnumerable<TResult> OfTypeIterator<TResult>(IEnumerable source)
		{
			foreach (object obj in source)
			{
				if (obj is TResult)
				{
					yield return (TResult)obj;
				}
			}
		}

		public static IEnumerable<TResult> Cast<TResult>(this IEnumerable source)
		{
			if (source is IEnumerable<TResult> result)
			{
				return result;
			}
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return CastIterator<TResult>(source);
		}

		private static IEnumerable<TResult> CastIterator<TResult>(IEnumerable source)
		{
			foreach (object obj in source)
			{
				yield return (TResult)obj;
			}
		}

		public static TSource First<TSource>(this IEnumerable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (source is IList<TSource> list)
			{
				if (list.Count > 0)
				{
					return list[0];
				}
			}
			else
			{
				using IEnumerator<TSource> enumerator = source.GetEnumerator();
				if (enumerator.MoveNext())
				{
					return enumerator.Current;
				}
			}
			throw Error.NoElements();
		}

		public static TSource First<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			foreach (TSource item in source)
			{
				if (predicate(item))
				{
					return item;
				}
			}
			throw Error.NoMatch();
		}

		public static TSource FirstOrDefault<TSource>(this IEnumerable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (source is IList<TSource> list)
			{
				if (list.Count > 0)
				{
					return list[0];
				}
			}
			else
			{
				using IEnumerator<TSource> enumerator = source.GetEnumerator();
				if (enumerator.MoveNext())
				{
					return enumerator.Current;
				}
			}
			return default(TSource);
		}

		public static TSource FirstOrDefault<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			foreach (TSource item in source)
			{
				if (predicate(item))
				{
					return item;
				}
			}
			return default(TSource);
		}

		public static TSource Last<TSource>(this IEnumerable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (source is IList<TSource> list)
			{
				int count = list.Count;
				if (count > 0)
				{
					return list[count - 1];
				}
			}
			else
			{
				using IEnumerator<TSource> enumerator = source.GetEnumerator();
				if (enumerator.MoveNext())
				{
					TSource current;
					do
					{
						current = enumerator.Current;
					}
					while (enumerator.MoveNext());
					return current;
				}
			}
			throw Error.NoElements();
		}

		public static TSource Last<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			TSource result = default(TSource);
			bool flag = false;
			foreach (TSource item in source)
			{
				if (predicate(item))
				{
					result = item;
					flag = true;
				}
			}
			if (flag)
			{
				return result;
			}
			throw Error.NoMatch();
		}

		public static TSource LastOrDefault<TSource>(this IEnumerable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (source is IList<TSource> list)
			{
				int count = list.Count;
				if (count > 0)
				{
					return list[count - 1];
				}
			}
			else
			{
				using IEnumerator<TSource> enumerator = source.GetEnumerator();
				if (enumerator.MoveNext())
				{
					TSource current;
					do
					{
						current = enumerator.Current;
					}
					while (enumerator.MoveNext());
					return current;
				}
			}
			return default(TSource);
		}

		public static TSource LastOrDefault<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			TSource result = default(TSource);
			foreach (TSource item in source)
			{
				if (predicate(item))
				{
					result = item;
				}
			}
			return result;
		}

		public static TSource Single<TSource>(this IEnumerable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (source is IList<TSource> list)
			{
				switch (list.Count)
				{
				case 0:
					throw Error.NoElements();
				case 1:
					return list[0];
				}
			}
			else
			{
				using IEnumerator<TSource> enumerator = source.GetEnumerator();
				if (!enumerator.MoveNext())
				{
					throw Error.NoElements();
				}
				TSource current = enumerator.Current;
				if (!enumerator.MoveNext())
				{
					return current;
				}
			}
			throw Error.MoreThanOneElement();
		}

		public static TSource Single<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			TSource result = default(TSource);
			long num = 0L;
			foreach (TSource item in source)
			{
				if (predicate(item))
				{
					result = item;
					num = checked(num + 1);
				}
			}
			long num2 = num;
			if (num2 <= 1 && num2 >= 0)
			{
				switch (num2)
				{
				case 0L:
					throw Error.NoMatch();
				case 1L:
					return result;
				}
			}
			throw Error.MoreThanOneMatch();
		}

		public static TSource SingleOrDefault<TSource>(this IEnumerable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (source is IList<TSource> list)
			{
				switch (list.Count)
				{
				case 0:
					return default(TSource);
				case 1:
					return list[0];
				}
			}
			else
			{
				using IEnumerator<TSource> enumerator = source.GetEnumerator();
				if (!enumerator.MoveNext())
				{
					return default(TSource);
				}
				TSource current = enumerator.Current;
				if (!enumerator.MoveNext())
				{
					return current;
				}
			}
			throw Error.MoreThanOneElement();
		}

		public static TSource SingleOrDefault<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			TSource result = default(TSource);
			long num = 0L;
			foreach (TSource item in source)
			{
				if (predicate(item))
				{
					result = item;
					num = checked(num + 1);
				}
			}
			long num2 = num;
			if (num2 <= 1 && num2 >= 0)
			{
				switch (num2)
				{
				case 0L:
					return default(TSource);
				case 1L:
					return result;
				}
			}
			throw Error.MoreThanOneMatch();
		}

		public static TSource ElementAt<TSource>(this IEnumerable<TSource> source, int index)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (source is IList<TSource> list)
			{
				return list[index];
			}
			if (index < 0)
			{
				throw Error.ArgumentOutOfRange("index");
			}
			using IEnumerator<TSource> enumerator = source.GetEnumerator();
			while (enumerator.MoveNext())
			{
				if (index == 0)
				{
					return enumerator.Current;
				}
				index--;
			}
			throw Error.ArgumentOutOfRange("index");
		}

		public static TSource ElementAtOrDefault<TSource>(this IEnumerable<TSource> source, int index)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (index >= 0)
			{
				if (source is IList<TSource> list)
				{
					if (index < list.Count)
					{
						return list[index];
					}
				}
				else
				{
					using IEnumerator<TSource> enumerator = source.GetEnumerator();
					while (enumerator.MoveNext())
					{
						if (index == 0)
						{
							return enumerator.Current;
						}
						index--;
					}
				}
			}
			return default(TSource);
		}

		public static IEnumerable<int> Range(int start, int count)
		{
			long num = (long)start + (long)count - 1;
			if (count < 0 || num > int.MaxValue)
			{
				throw Error.ArgumentOutOfRange("count");
			}
			return RangeIterator(start, count);
		}

		private static IEnumerable<int> RangeIterator(int start, int count)
		{
			for (int i = 0; i < count; i++)
			{
				yield return start + i;
			}
		}

		public static IEnumerable<TResult> Repeat<TResult>(TResult element, int count)
		{
			if (count < 0)
			{
				throw Error.ArgumentOutOfRange("count");
			}
			return RepeatIterator(element, count);
		}

		private static IEnumerable<TResult> RepeatIterator<TResult>(TResult element, int count)
		{
			for (int i = 0; i < count; i++)
			{
				yield return element;
			}
		}

		public static IEnumerable<TResult> Empty<TResult>()
		{
			return EmptyEnumerable<TResult>.Instance;
		}

		public static bool Any<TSource>(this IEnumerable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			using (IEnumerator<TSource> enumerator = source.GetEnumerator())
			{
				if (enumerator.MoveNext())
				{
					return true;
				}
			}
			return false;
		}

		public static bool Any<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			foreach (TSource item in source)
			{
				if (predicate(item))
				{
					return true;
				}
			}
			return false;
		}

		public static bool All<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			foreach (TSource item in source)
			{
				if (!predicate(item))
				{
					return false;
				}
			}
			return true;
		}

		public static int Count<TSource>(this IEnumerable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (source is ICollection<TSource> collection)
			{
				return collection.Count;
			}
			int num = 0;
			using IEnumerator<TSource> enumerator = source.GetEnumerator();
			while (enumerator.MoveNext())
			{
				num = checked(num + 1);
			}
			return num;
		}

		public static int Count<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			int num = 0;
			foreach (TSource item in source)
			{
				if (predicate(item))
				{
					num = checked(num + 1);
				}
			}
			return num;
		}

		public static long LongCount<TSource>(this IEnumerable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			long num = 0L;
			using IEnumerator<TSource> enumerator = source.GetEnumerator();
			while (enumerator.MoveNext())
			{
				num = checked(num + 1);
			}
			return num;
		}

		public static long LongCount<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			long num = 0L;
			foreach (TSource item in source)
			{
				if (predicate(item))
				{
					num = checked(num + 1);
				}
			}
			return num;
		}

		public static bool Contains<TSource>(this IEnumerable<TSource> source, TSource value)
		{
			if (source is ICollection<TSource> collection)
			{
				return collection.Contains(value);
			}
			return source.Contains(value, null);
		}

		public static bool Contains<TSource>(this IEnumerable<TSource> source, TSource value, IEqualityComparer<TSource> comparer)
		{
			if (comparer == null)
			{
				comparer = EqualityComparer<TSource>.Default;
			}
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			foreach (TSource item in source)
			{
				if (comparer.Equals(item, value))
				{
					return true;
				}
			}
			return false;
		}

		public static TSource Aggregate<TSource>(this IEnumerable<TSource> source, Func<TSource, TSource, TSource> func)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (func == null)
			{
				throw Error.ArgumentNull("func");
			}
			using IEnumerator<TSource> enumerator = source.GetEnumerator();
			if (!enumerator.MoveNext())
			{
				throw Error.NoElements();
			}
			TSource val = enumerator.Current;
			while (enumerator.MoveNext())
			{
				val = func(val, enumerator.Current);
			}
			return val;
		}

		public static TAccumulate Aggregate<TSource, TAccumulate>(this IEnumerable<TSource> source, TAccumulate seed, Func<TAccumulate, TSource, TAccumulate> func)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (func == null)
			{
				throw Error.ArgumentNull("func");
			}
			TAccumulate val = seed;
			foreach (TSource item in source)
			{
				val = func(val, item);
			}
			return val;
		}

		public static TResult Aggregate<TSource, TAccumulate, TResult>(this IEnumerable<TSource> source, TAccumulate seed, Func<TAccumulate, TSource, TAccumulate> func, Func<TAccumulate, TResult> resultSelector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (func == null)
			{
				throw Error.ArgumentNull("func");
			}
			if (resultSelector == null)
			{
				throw Error.ArgumentNull("resultSelector");
			}
			TAccumulate val = seed;
			foreach (TSource item in source)
			{
				val = func(val, item);
			}
			return resultSelector(val);
		}

		public static int Sum(this IEnumerable<int> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			int num = 0;
			foreach (int item in source)
			{
				num = checked(num + item);
			}
			return num;
		}

		public static int? Sum(this IEnumerable<int?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			int num = 0;
			foreach (int? item in source)
			{
				if (item.HasValue)
				{
					num = checked(num + item.GetValueOrDefault());
				}
			}
			return num;
		}

		public static long Sum(this IEnumerable<long> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			long num = 0L;
			foreach (long item in source)
			{
				num = checked(num + item);
			}
			return num;
		}

		public static long? Sum(this IEnumerable<long?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			long num = 0L;
			foreach (long? item in source)
			{
				if (item.HasValue)
				{
					num = checked(num + item.GetValueOrDefault());
				}
			}
			return num;
		}

		public static float Sum(this IEnumerable<float> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			double num = 0.0;
			foreach (float item in source)
			{
				float num2 = item;
				num += (double)num2;
			}
			return (float)num;
		}

		public static float? Sum(this IEnumerable<float?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			double num = 0.0;
			foreach (float? item in source)
			{
				if (item.HasValue)
				{
					num += (double)item.GetValueOrDefault();
				}
			}
			return (float)num;
		}

		public static double Sum(this IEnumerable<double> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			double num = 0.0;
			foreach (double item in source)
			{
				double num2 = item;
				num += num2;
			}
			return num;
		}

		public static double? Sum(this IEnumerable<double?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			double num = 0.0;
			foreach (double? item in source)
			{
				if (item.HasValue)
				{
					num += item.GetValueOrDefault();
				}
			}
			return num;
		}

		public static decimal Sum(this IEnumerable<decimal> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			decimal result = 0m;
			foreach (decimal item in source)
			{
				result += item;
			}
			return result;
		}

		public static decimal? Sum(this IEnumerable<decimal?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			decimal value = 0m;
			foreach (decimal? item in source)
			{
				if (item.HasValue)
				{
					value += item.GetValueOrDefault();
				}
			}
			return value;
		}

		public static int Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, int> selector)
		{
			return source.Select(selector).Sum();
		}

		public static int? Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, int?> selector)
		{
			return source.Select(selector).Sum();
		}

		public static long Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, long> selector)
		{
			return source.Select(selector).Sum();
		}

		public static long? Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, long?> selector)
		{
			return source.Select(selector).Sum();
		}

		public static float Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, float> selector)
		{
			return source.Select(selector).Sum();
		}

		public static float? Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, float?> selector)
		{
			return source.Select(selector).Sum();
		}

		public static double Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, double> selector)
		{
			return source.Select(selector).Sum();
		}

		public static double? Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, double?> selector)
		{
			return source.Select(selector).Sum();
		}

		public static decimal Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> selector)
		{
			return source.Select(selector).Sum();
		}

		public static decimal? Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal?> selector)
		{
			return source.Select(selector).Sum();
		}

		public static int Min(this IEnumerable<int> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			int num = 0;
			bool flag = false;
			foreach (int item in source)
			{
				if (flag)
				{
					if (item < num)
					{
						num = item;
					}
				}
				else
				{
					num = item;
					flag = true;
				}
			}
			if (flag)
			{
				return num;
			}
			throw Error.NoElements();
		}

		public static int? Min(this IEnumerable<int?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			int? num = null;
			foreach (int? item in source)
			{
				if (!num.HasValue || item < num)
				{
					num = item;
				}
			}
			return num;
		}

		public static long Min(this IEnumerable<long> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			long num = 0L;
			bool flag = false;
			foreach (long item in source)
			{
				if (flag)
				{
					if (item < num)
					{
						num = item;
					}
				}
				else
				{
					num = item;
					flag = true;
				}
			}
			if (flag)
			{
				return num;
			}
			throw Error.NoElements();
		}

		public static long? Min(this IEnumerable<long?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			long? num = null;
			foreach (long? item in source)
			{
				if (!num.HasValue || item < num)
				{
					num = item;
				}
			}
			return num;
		}

		public static float Min(this IEnumerable<float> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			float num = 0f;
			bool flag = false;
			foreach (float item in source)
			{
				float num2 = item;
				if (flag)
				{
					if (num2 < num || float.IsNaN(num2))
					{
						num = num2;
					}
				}
				else
				{
					num = num2;
					flag = true;
				}
			}
			if (flag)
			{
				return num;
			}
			throw Error.NoElements();
		}

		public static float? Min(this IEnumerable<float?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			float? num = null;
			foreach (float? item in source)
			{
				if (item.HasValue && (!num.HasValue || item < num || float.IsNaN(item.Value)))
				{
					num = item;
				}
			}
			return num;
		}

		public static double Min(this IEnumerable<double> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			double num = 0.0;
			bool flag = false;
			foreach (double item in source)
			{
				double num2 = item;
				if (flag)
				{
					if (num2 < num || double.IsNaN(num2))
					{
						num = num2;
					}
				}
				else
				{
					num = num2;
					flag = true;
				}
			}
			if (flag)
			{
				return num;
			}
			throw Error.NoElements();
		}

		public static double? Min(this IEnumerable<double?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			double? num = null;
			foreach (double? item in source)
			{
				if (item.HasValue && (!num.HasValue || item < num || double.IsNaN(item.Value)))
				{
					num = item;
				}
			}
			return num;
		}

		public static decimal Min(this IEnumerable<decimal> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			decimal num = 0m;
			bool flag = false;
			foreach (decimal item in source)
			{
				if (flag)
				{
					if (item < num)
					{
						num = item;
					}
				}
				else
				{
					num = item;
					flag = true;
				}
			}
			if (flag)
			{
				return num;
			}
			throw Error.NoElements();
		}

		public static decimal? Min(this IEnumerable<decimal?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			decimal? num = null;
			foreach (decimal? item in source)
			{
				if (!num.HasValue || item < num)
				{
					num = item;
				}
			}
			return num;
		}

		public static TSource Min<TSource>(this IEnumerable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			Comparer<TSource> @default = Comparer<TSource>.Default;
			TSource val = default(TSource);
			if (val == null)
			{
				foreach (TSource item in source)
				{
					if (item != null && (val == null || @default.Compare(item, val) < 0))
					{
						val = item;
					}
				}
				return val;
			}
			bool flag = false;
			foreach (TSource item2 in source)
			{
				if (flag)
				{
					if (@default.Compare(item2, val) < 0)
					{
						val = item2;
					}
				}
				else
				{
					val = item2;
					flag = true;
				}
			}
			if (flag)
			{
				return val;
			}
			throw Error.NoElements();
		}

		public static int Min<TSource>(this IEnumerable<TSource> source, Func<TSource, int> selector)
		{
			return source.Select(selector).Min();
		}

		public static int? Min<TSource>(this IEnumerable<TSource> source, Func<TSource, int?> selector)
		{
			return source.Select(selector).Min();
		}

		public static long Min<TSource>(this IEnumerable<TSource> source, Func<TSource, long> selector)
		{
			return source.Select(selector).Min();
		}

		public static long? Min<TSource>(this IEnumerable<TSource> source, Func<TSource, long?> selector)
		{
			return source.Select(selector).Min();
		}

		public static float Min<TSource>(this IEnumerable<TSource> source, Func<TSource, float> selector)
		{
			return source.Select(selector).Min();
		}

		public static float? Min<TSource>(this IEnumerable<TSource> source, Func<TSource, float?> selector)
		{
			return source.Select(selector).Min();
		}

		public static double Min<TSource>(this IEnumerable<TSource> source, Func<TSource, double> selector)
		{
			return source.Select(selector).Min();
		}

		public static double? Min<TSource>(this IEnumerable<TSource> source, Func<TSource, double?> selector)
		{
			return source.Select(selector).Min();
		}

		public static decimal Min<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> selector)
		{
			return source.Select(selector).Min();
		}

		public static decimal? Min<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal?> selector)
		{
			return source.Select(selector).Min();
		}

		public static TResult Min<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> selector)
		{
			return source.Select(selector).Min();
		}

		public static int Max(this IEnumerable<int> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			int num = 0;
			bool flag = false;
			foreach (int item in source)
			{
				if (flag)
				{
					if (item > num)
					{
						num = item;
					}
				}
				else
				{
					num = item;
					flag = true;
				}
			}
			if (flag)
			{
				return num;
			}
			throw Error.NoElements();
		}

		public static int? Max(this IEnumerable<int?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			int? num = null;
			foreach (int? item in source)
			{
				if (!num.HasValue || item > num)
				{
					num = item;
				}
			}
			return num;
		}

		public static long Max(this IEnumerable<long> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			long num = 0L;
			bool flag = false;
			foreach (long item in source)
			{
				if (flag)
				{
					if (item > num)
					{
						num = item;
					}
				}
				else
				{
					num = item;
					flag = true;
				}
			}
			if (flag)
			{
				return num;
			}
			throw Error.NoElements();
		}

		public static long? Max(this IEnumerable<long?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			long? num = null;
			foreach (long? item in source)
			{
				if (!num.HasValue || item > num)
				{
					num = item;
				}
			}
			return num;
		}

		public static double Max(this IEnumerable<double> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			double num = 0.0;
			bool flag = false;
			foreach (double item in source)
			{
				double num2 = item;
				if (flag)
				{
					if (num2 > num || double.IsNaN(num))
					{
						num = num2;
					}
				}
				else
				{
					num = num2;
					flag = true;
				}
			}
			if (flag)
			{
				return num;
			}
			throw Error.NoElements();
		}

		public static double? Max(this IEnumerable<double?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			double? num = null;
			foreach (double? item in source)
			{
				if (item.HasValue && (!num.HasValue || item > num || double.IsNaN(num.Value)))
				{
					num = item;
				}
			}
			return num;
		}

		public static float Max(this IEnumerable<float> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			float num = 0f;
			bool flag = false;
			foreach (float item in source)
			{
				float num2 = item;
				if (flag)
				{
					if (num2 > num || double.IsNaN(num))
					{
						num = num2;
					}
				}
				else
				{
					num = num2;
					flag = true;
				}
			}
			if (flag)
			{
				return num;
			}
			throw Error.NoElements();
		}

		public static float? Max(this IEnumerable<float?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			float? num = null;
			foreach (float? item in source)
			{
				if (item.HasValue && (!num.HasValue || item > num || float.IsNaN(num.Value)))
				{
					num = item;
				}
			}
			return num;
		}

		public static decimal Max(this IEnumerable<decimal> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			decimal num = 0m;
			bool flag = false;
			foreach (decimal item in source)
			{
				if (flag)
				{
					if (item > num)
					{
						num = item;
					}
				}
				else
				{
					num = item;
					flag = true;
				}
			}
			if (flag)
			{
				return num;
			}
			throw Error.NoElements();
		}

		public static decimal? Max(this IEnumerable<decimal?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			decimal? num = null;
			foreach (decimal? item in source)
			{
				if (!num.HasValue || item > num)
				{
					num = item;
				}
			}
			return num;
		}

		public static TSource Max<TSource>(this IEnumerable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			Comparer<TSource> @default = Comparer<TSource>.Default;
			TSource val = default(TSource);
			if (val == null)
			{
				foreach (TSource item in source)
				{
					if (item != null && (val == null || @default.Compare(item, val) > 0))
					{
						val = item;
					}
				}
				return val;
			}
			bool flag = false;
			foreach (TSource item2 in source)
			{
				if (flag)
				{
					if (@default.Compare(item2, val) > 0)
					{
						val = item2;
					}
				}
				else
				{
					val = item2;
					flag = true;
				}
			}
			if (flag)
			{
				return val;
			}
			throw Error.NoElements();
		}

		public static int Max<TSource>(this IEnumerable<TSource> source, Func<TSource, int> selector)
		{
			return source.Select(selector).Max();
		}

		public static int? Max<TSource>(this IEnumerable<TSource> source, Func<TSource, int?> selector)
		{
			return source.Select(selector).Max();
		}

		public static long Max<TSource>(this IEnumerable<TSource> source, Func<TSource, long> selector)
		{
			return source.Select(selector).Max();
		}

		public static long? Max<TSource>(this IEnumerable<TSource> source, Func<TSource, long?> selector)
		{
			return source.Select(selector).Max();
		}

		public static float Max<TSource>(this IEnumerable<TSource> source, Func<TSource, float> selector)
		{
			return source.Select(selector).Max();
		}

		public static float? Max<TSource>(this IEnumerable<TSource> source, Func<TSource, float?> selector)
		{
			return source.Select(selector).Max();
		}

		public static double Max<TSource>(this IEnumerable<TSource> source, Func<TSource, double> selector)
		{
			return source.Select(selector).Max();
		}

		public static double? Max<TSource>(this IEnumerable<TSource> source, Func<TSource, double?> selector)
		{
			return source.Select(selector).Max();
		}

		public static decimal Max<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> selector)
		{
			return source.Select(selector).Max();
		}

		public static decimal? Max<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal?> selector)
		{
			return source.Select(selector).Max();
		}

		public static TResult Max<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> selector)
		{
			return source.Select(selector).Max();
		}

		public static double Average(this IEnumerable<int> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			long num = 0L;
			long num2 = 0L;
			checked
			{
				foreach (int item in source)
				{
					num += item;
					num2++;
				}
				if (num2 > 0)
				{
					return (double)num / (double)num2;
				}
				throw Error.NoElements();
			}
		}

		public static double? Average(this IEnumerable<int?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			long num = 0L;
			long num2 = 0L;
			checked
			{
				foreach (int? item in source)
				{
					if (item.HasValue)
					{
						num += item.GetValueOrDefault();
						num2++;
					}
				}
				if (num2 > 0)
				{
					return (double)num / (double)num2;
				}
				return null;
			}
		}

		public static double Average(this IEnumerable<long> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			long num = 0L;
			long num2 = 0L;
			checked
			{
				foreach (long item in source)
				{
					num += item;
					num2++;
				}
				if (num2 > 0)
				{
					return (double)num / (double)num2;
				}
				throw Error.NoElements();
			}
		}

		public static double? Average(this IEnumerable<long?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			long num = 0L;
			long num2 = 0L;
			checked
			{
				foreach (long? item in source)
				{
					if (item.HasValue)
					{
						num += item.GetValueOrDefault();
						num2++;
					}
				}
				if (num2 > 0)
				{
					return (double)num / (double)num2;
				}
				return null;
			}
		}

		public static float Average(this IEnumerable<float> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			double num = 0.0;
			long num2 = 0L;
			foreach (float item in source)
			{
				float num3 = item;
				num += (double)num3;
				num2 = checked(num2 + 1);
			}
			if (num2 > 0)
			{
				return (float)(num / (double)num2);
			}
			throw Error.NoElements();
		}

		public static float? Average(this IEnumerable<float?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			double num = 0.0;
			long num2 = 0L;
			foreach (float? item in source)
			{
				if (item.HasValue)
				{
					num += (double)item.GetValueOrDefault();
					num2 = checked(num2 + 1);
				}
			}
			if (num2 > 0)
			{
				return (float)(num / (double)num2);
			}
			return null;
		}

		public static double Average(this IEnumerable<double> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			double num = 0.0;
			long num2 = 0L;
			foreach (double item in source)
			{
				double num3 = item;
				num += num3;
				num2 = checked(num2 + 1);
			}
			if (num2 > 0)
			{
				return num / (double)num2;
			}
			throw Error.NoElements();
		}

		public static double? Average(this IEnumerable<double?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			double num = 0.0;
			long num2 = 0L;
			foreach (double? item in source)
			{
				if (item.HasValue)
				{
					num += item.GetValueOrDefault();
					num2 = checked(num2 + 1);
				}
			}
			if (num2 > 0)
			{
				return num / (double)num2;
			}
			return null;
		}

		public static decimal Average(this IEnumerable<decimal> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			decimal num = 0m;
			long num2 = 0L;
			foreach (decimal item in source)
			{
				num += item;
				num2 = checked(num2 + 1);
			}
			if (num2 > 0)
			{
				return num / (decimal)num2;
			}
			throw Error.NoElements();
		}

		public static decimal? Average(this IEnumerable<decimal?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			decimal num = 0m;
			long num2 = 0L;
			foreach (decimal? item in source)
			{
				if (item.HasValue)
				{
					num += item.GetValueOrDefault();
					num2 = checked(num2 + 1);
				}
			}
			if (num2 > 0)
			{
				return num / (decimal)num2;
			}
			return null;
		}

		public static double Average<TSource>(this IEnumerable<TSource> source, Func<TSource, int> selector)
		{
			return source.Select(selector).Average();
		}

		public static double? Average<TSource>(this IEnumerable<TSource> source, Func<TSource, int?> selector)
		{
			return source.Select(selector).Average();
		}

		public static double Average<TSource>(this IEnumerable<TSource> source, Func<TSource, long> selector)
		{
			return source.Select(selector).Average();
		}

		public static double? Average<TSource>(this IEnumerable<TSource> source, Func<TSource, long?> selector)
		{
			return source.Select(selector).Average();
		}

		public static float Average<TSource>(this IEnumerable<TSource> source, Func<TSource, float> selector)
		{
			return source.Select(selector).Average();
		}

		public static float? Average<TSource>(this IEnumerable<TSource> source, Func<TSource, float?> selector)
		{
			return source.Select(selector).Average();
		}

		public static double Average<TSource>(this IEnumerable<TSource> source, Func<TSource, double> selector)
		{
			return source.Select(selector).Average();
		}

		public static double? Average<TSource>(this IEnumerable<TSource> source, Func<TSource, double?> selector)
		{
			return source.Select(selector).Average();
		}

		public static decimal Average<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> selector)
		{
			return source.Select(selector).Average();
		}

		public static decimal? Average<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal?> selector)
		{
			return source.Select(selector).Average();
		}
	}
	internal class EmptyEnumerable<TElement>
	{
		private static TElement[] instance;

		public static IEnumerable<TElement> Instance
		{
			get
			{
				if (instance == null)
				{
					instance = new TElement[0];
				}
				return instance;
			}
		}
	}
	internal class IdentityFunction<TElement>
	{
		public static Func<TElement, TElement> Instance => (TElement x) => x;
	}
	public interface IOrderedEnumerable<TElement> : IEnumerable<TElement>, IEnumerable
	{
		IOrderedEnumerable<TElement> CreateOrderedEnumerable<TKey>(Func<TElement, TKey> keySelector, IComparer<TKey> comparer, bool descending);
	}
	public interface IGrouping<TKey, TElement> : IEnumerable<TElement>, IEnumerable
	{
		TKey Key { get; }
	}
	public interface ILookup<TKey, TElement> : IEnumerable<IGrouping<TKey, TElement>>, IEnumerable
	{
		int Count { get; }

		IEnumerable<TElement> this[TKey key] { get; }

		bool Contains(TKey key);
	}
	public class Lookup<TKey, TElement> : ILookup<TKey, TElement>, IEnumerable<IGrouping<TKey, TElement>>, IEnumerable
	{
		internal class Grouping : IGrouping<TKey, TElement>, IList<TElement>, ICollection<TElement>, IEnumerable<TElement>, IEnumerable
		{
			internal TKey key;

			internal int hashCode;

			internal TElement[] elements;

			internal int count;

			internal Grouping hashNext;

			internal Grouping next;

			public TKey Key => key;

			int ICollection<TElement>.Count => count;

			bool ICollection<TElement>.IsReadOnly => true;

			TElement IList<TElement>.this[int index]
			{
				get
				{
					if (index < 0 || index >= count)
					{
						throw Error.ArgumentOutOfRange("index");
					}
					return elements[index];
				}
				set
				{
					throw Error.NotSupported();
				}
			}

			internal void Add(TElement element)
			{
				if (elements.Length == count)
				{
					Array.Resize(ref elements, checked(count * 2));
				}
				elements[count] = element;
				count++;
			}

			public IEnumerator<TElement> GetEnumerator()
			{
				for (int i = 0; i < count; i++)
				{
					yield return elements[i];
				}
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}

			void ICollection<TElement>.Add(TElement item)
			{
				throw Error.NotSupported();
			}

			void ICollection<TElement>.Clear()
			{
				throw Error.NotSupported();
			}

			bool ICollection<TElement>.Contains(TElement item)
			{
				return Array.IndexOf(elements, item, 0, count) >= 0;
			}

			void ICollection<TElement>.CopyTo(TElement[] array, int arrayIndex)
			{
				Array.Copy(elements, 0, array, arrayIndex, count);
			}

			bool ICollection<TElement>.Remove(TElement item)
			{
				throw Error.NotSupported();
			}

			int IList<TElement>.IndexOf(TElement item)
			{
				return Array.IndexOf(elements, item, 0, count);
			}

			void IList<TElement>.Insert(int index, TElement item)
			{
				throw Error.NotSupported();
			}

			void IList<TElement>.RemoveAt(int index)
			{
				throw Error.NotSupported();
			}
		}

		private IEqualityComparer<TKey> comparer;

		private Grouping[] groupings;

		private Grouping lastGrouping;

		private int count;

		public int Count => count;

		public IEnumerable<TElement> this[TKey key]
		{
			get
			{
				Grouping grouping = GetGrouping(key, create: false);
				if (grouping != null)
				{
					return grouping;
				}
				return EmptyEnumerable<TElement>.Instance;
			}
		}

		internal static Lookup<TKey, TElement> Create<TSource>(IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, IEqualityComparer<TKey> comparer)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			if (elementSelector == null)
			{
				throw Error.ArgumentNull("elementSelector");
			}
			Lookup<TKey, TElement> lookup = new Lookup<TKey, TElement>(comparer);
			foreach (TSource item in source)
			{
				lookup.GetGrouping(keySelector(item), create: true).Add(elementSelector(item));
			}
			return lookup;
		}

		internal static Lookup<TKey, TElement> CreateForJoin(IEnumerable<TElement> source, Func<TElement, TKey> keySelector, IEqualityComparer<TKey> comparer)
		{
			Lookup<TKey, TElement> lookup = new Lookup<TKey, TElement>(comparer);
			foreach (TElement item in source)
			{
				TKey val = keySelector(item);
				if (val != null)
				{
					lookup.GetGrouping(val, create: true).Add(item);
				}
			}
			return lookup;
		}

		private Lookup(IEqualityComparer<TKey> comparer)
		{
			if (comparer == null)
			{
				comparer = EqualityComparer<TKey>.Default;
			}
			this.comparer = comparer;
			groupings = new Grouping[7];
		}

		public bool Contains(TKey key)
		{
			return GetGrouping(key, create: false) != null;
		}

		public IEnumerator<IGrouping<TKey, TElement>> GetEnumerator()
		{
			Grouping g = lastGrouping;
			if (g != null)
			{
				do
				{
					g = g.next;
					yield return g;
				}
				while (g != lastGrouping);
			}
		}

		public IEnumerable<TResult> ApplyResultSelector<TResult>(Func<TKey, IEnumerable<TElement>, TResult> resultSelector)
		{
			Grouping g = lastGrouping;
			if (g == null)
			{
				yield break;
			}
			do
			{
				g = g.next;
				if (g.count != g.elements.Length)
				{
					Array.Resize(ref g.elements, g.count);
				}
				yield return resultSelector(g.key, g.elements);
			}
			while (g != lastGrouping);
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		internal int InternalGetHashCode(TKey key)
		{
			if (key != null)
			{
				return comparer.GetHashCode(key) & 0x7FFFFFFF;
			}
			return 0;
		}

		internal Grouping GetGrouping(TKey key, bool create)
		{
			int num = InternalGetHashCode(key);
			for (Grouping grouping = groupings[num % groupings.Length]; grouping != null; grouping = grouping.hashNext)
			{
				if (grouping.hashCode == num && comparer.Equals(grouping.key, key))
				{
					return grouping;
				}
			}
			if (create)
			{
				if (count == groupings.Length)
				{
					Resize();
				}
				int num2 = num % groupings.Length;
				Grouping grouping2 = new Grouping();
				grouping2.key = key;
				grouping2.hashCode = num;
				grouping2.elements = new TElement[1];
				grouping2.hashNext = groupings[num2];
				groupings[num2] = grouping2;
				if (lastGrouping == null)
				{
					grouping2.next = grouping2;
				}
				else
				{
					grouping2.next = lastGrouping.next;
					lastGrouping.next = grouping2;
				}
				lastGrouping = grouping2;
				count++;
				return grouping2;
			}
			return null;
		}

		private void Resize()
		{
			int num = checked(count * 2 + 1);
			Grouping[] array = new Grouping[num];
			Grouping next = lastGrouping;
			do
			{
				next = next.next;
				int num2 = next.hashCode % num;
				next.hashNext = array[num2];
				array[num2] = next;
			}
			while (next != lastGrouping);
			groupings = array;
		}
	}
	internal class Set<TElement>
	{
		internal struct Slot
		{
			internal int hashCode;

			internal TElement value;

			internal int next;
		}

		private int[] buckets;

		private Slot[] slots;

		private int count;

		private int freeList;

		private IEqualityComparer<TElement> comparer;

		public Set()
			: this((IEqualityComparer<TElement>)null)
		{
		}

		public Set(IEqualityComparer<TElement> comparer)
		{
			if (comparer == null)
			{
				comparer = EqualityComparer<TElement>.Default;
			}
			this.comparer = comparer;
			buckets = new int[7];
			slots = new Slot[7];
			freeList = -1;
		}

		public bool Add(TElement value)
		{
			return !Find(value, add: true);
		}

		public bool Contains(TElement value)
		{
			return Find(value, add: false);
		}

		public bool Remove(TElement value)
		{
			int num = InternalGetHashCode(value);
			int num2 = num % buckets.Length;
			int num3 = -1;
			for (int num4 = buckets[num2] - 1; num4 >= 0; num4 = slots[num4].next)
			{
				if (slots[num4].hashCode == num && comparer.Equals(slots[num4].value, value))
				{
					if (num3 < 0)
					{
						buckets[num2] = slots[num4].next + 1;
					}
					else
					{
						slots[num3].next = slots[num4].next;
					}
					slots[num4].hashCode = -1;
					slots[num4].value = default(TElement);
					slots[num4].next = freeList;
					freeList = num4;
					return true;
				}
				num3 = num4;
			}
			return false;
		}

		private bool Find(TElement value, bool add)
		{
			int num = InternalGetHashCode(value);
			for (int num2 = buckets[num % buckets.Length] - 1; num2 >= 0; num2 = slots[num2].next)
			{
				if (slots[num2].hashCode == num && comparer.Equals(slots[num2].value, value))
				{
					return true;
				}
			}
			if (add)
			{
				int num3;
				if (freeList >= 0)
				{
					num3 = freeList;
					freeList = slots[num3].next;
				}
				else
				{
					if (count == slots.Length)
					{
						Resize();
					}
					num3 = count;
					count++;
				}
				int num4 = num % buckets.Length;
				slots[num3].hashCode = num;
				slots[num3].value = value;
				slots[num3].next = buckets[num4] - 1;
				buckets[num4] = num3 + 1;
			}
			return false;
		}

		private void Resize()
		{
			int num = checked(count * 2 + 1);
			int[] array = new int[num];
			Slot[] array2 = new Slot[num];
			Array.Copy(slots, 0, array2, 0, count);
			for (int i = 0; i < count; i++)
			{
				int num2 = array2[i].hashCode % num;
				array2[i].next = array[num2] - 1;
				array[num2] = i + 1;
			}
			buckets = array;
			slots = array2;
		}

		internal int InternalGetHashCode(TElement value)
		{
			if (value != null)
			{
				return comparer.GetHashCode(value) & 0x7FFFFFFF;
			}
			return 0;
		}
	}
	internal class GroupedEnumerable<TSource, TKey, TElement, TResult> : IEnumerable<TResult>, IEnumerable
	{
		private IEnumerable<TSource> source;

		private Func<TSource, TKey> keySelector;

		private Func<TSource, TElement> elementSelector;

		private IEqualityComparer<TKey> comparer;

		private Func<TKey, IEnumerable<TElement>, TResult> resultSelector;

		public GroupedEnumerable(IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, TResult> resultSelector, IEqualityComparer<TKey> comparer)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			if (elementSelector == null)
			{
				throw Error.ArgumentNull("elementSelector");
			}
			if (resultSelector == null)
			{
				throw Error.ArgumentNull("resultSelector");
			}
			this.source = source;
			this.keySelector = keySelector;
			this.elementSelector = elementSelector;
			this.comparer = comparer;
			this.resultSelector = resultSelector;
		}

		public IEnumerator<TResult> GetEnumerator()
		{
			Lookup<TKey, TElement> lookup = Lookup<TKey, TElement>.Create(source, keySelector, elementSelector, comparer);
			return lookup.ApplyResultSelector(resultSelector).GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}
	internal class GroupedEnumerable<TSource, TKey, TElement> : IEnumerable<IGrouping<TKey, TElement>>, IEnumerable
	{
		private IEnumerable<TSource> source;

		private Func<TSource, TKey> keySelector;

		private Func<TSource, TElement> elementSelector;

		private IEqualityComparer<TKey> comparer;

		public GroupedEnumerable(IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, IEqualityComparer<TKey> comparer)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			if (elementSelector == null)
			{
				throw Error.ArgumentNull("elementSelector");
			}
			this.source = source;
			this.keySelector = keySelector;
			this.elementSelector = elementSelector;
			this.comparer = comparer;
		}

		public IEnumerator<IGrouping<TKey, TElement>> GetEnumerator()
		{
			return Lookup<TKey, TElement>.Create(source, keySelector, elementSelector, comparer).GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}
	internal abstract class OrderedEnumerable<TElement> : IOrderedEnumerable<TElement>, IEnumerable<TElement>, IEnumerable
	{
		internal IEnumerable<TElement> source;

		public IEnumerator<TElement> GetEnumerator()
		{
			Buffer<TElement> buffer = new Buffer<TElement>(source);
			if (buffer.count > 0)
			{
				EnumerableSorter<TElement> sorter = GetEnumerableSorter(null);
				int[] map = sorter.Sort(buffer.items, buffer.count);
				for (int i = 0; i < buffer.count; i++)
				{
					yield return buffer.items[map[i]];
				}
			}
		}

		internal abstract EnumerableSorter<TElement> GetEnumerableSorter(EnumerableSorter<TElement> next);

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		IOrderedEnumerable<TElement> IOrderedEnumerable<TElement>.CreateOrderedEnumerable<TKey>(Func<TElement, TKey> keySelector, IComparer<TKey> comparer, bool descending)
		{
			OrderedEnumerable<TElement, TKey> orderedEnumerable = new OrderedEnumerable<TElement, TKey>(source, keySelector, comparer, descending);
			orderedEnumerable.parent = this;
			return orderedEnumerable;
		}
	}
	internal class OrderedEnumerable<TElement, TKey> : OrderedEnumerable<TElement>
	{
		internal OrderedEnumerable<TElement> parent;

		internal Func<TElement, TKey> keySelector;

		internal IComparer<TKey> comparer;

		internal bool descending;

		internal OrderedEnumerable(IEnumerable<TElement> source, Func<TElement, TKey> keySelector, IComparer<TKey> comparer, bool descending)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			base.source = source;
			parent = null;
			this.keySelector = keySelector;
			this.comparer = ((comparer != null) ? comparer : Comparer<TKey>.Default);
			this.descending = descending;
		}

		internal override EnumerableSorter<TElement> GetEnumerableSorter(EnumerableSorter<TElement> next)
		{
			EnumerableSorter<TElement> enumerableSorter = new EnumerableSorter<TElement, TKey>(keySelector, comparer, descending, next);
			if (parent != null)
			{
				enumerableSorter = parent.GetEnumerableSorter(enumerableSorter);
			}
			return enumerableSorter;
		}
	}
	internal abstract class EnumerableSorter<TElement>
	{
		internal abstract void ComputeKeys(TElement[] elements, int count);

		internal abstract int CompareKeys(int index1, int index2);

		internal int[] Sort(TElement[] elements, int count)
		{
			ComputeKeys(elements, count);
			int[] array = new int[count];
			for (int i = 0; i < count; i++)
			{
				array[i] = i;
			}
			QuickSort(array, 0, count - 1);
			return array;
		}

		private void QuickSort(int[] map, int left, int right)
		{
			do
			{
				int num = left;
				int num2 = right;
				int index = map[num + (num2 - num >> 1)];
				while (true)
				{
					if (num < map.Length && CompareKeys(index, map[num]) > 0)
					{
						num++;
						continue;
					}
					while (num2 >= 0 && CompareKeys(index, map[num2]) < 0)
					{
						num2--;
					}
					if (num > num2)
					{
						break;
					}
					if (num < num2)
					{
						int num3 = map[num];
						map[num] = map[num2];
						map[num2] = num3;
					}
					num++;
					num2--;
					if (num > num2)
					{
						break;
					}
				}
				if (num2 - left <= right - num)
				{
					if (left < num2)
					{
						QuickSort(map, left, num2);
					}
					left = num;
				}
				else
				{
					if (num < right)
					{
						QuickSort(map, num, right);
					}
					right = num2;
				}
			}
			while (left < right);
		}
	}
	internal class EnumerableSorter<TElement, TKey> : EnumerableSorter<TElement>
	{
		internal Func<TElement, TKey> keySelector;

		internal IComparer<TKey> comparer;

		internal bool descending;

		internal EnumerableSorter<TElement> next;

		internal TKey[] keys;

		internal EnumerableSorter(Func<TElement, TKey> keySelector, IComparer<TKey> comparer, bool descending, EnumerableSorter<TElement> next)
		{
			this.keySelector = keySelector;
			this.comparer = comparer;
			this.descending = descending;
			this.next = next;
		}

		internal override void ComputeKeys(TElement[] elements, int count)
		{
			keys = new TKey[count];
			for (int i = 0; i < count; i++)
			{
				keys[i] = keySelector(elements[i]);
			}
			if (next != null)
			{
				next.ComputeKeys(elements, count);
			}
		}

		internal override int CompareKeys(int index1, int index2)
		{
			int num = comparer.Compare(keys[index1], keys[index2]);
			if (num == 0)
			{
				if (next == null)
				{
					return index1 - index2;
				}
				return next.CompareKeys(index1, index2);
			}
			if (!descending)
			{
				return num;
			}
			return -num;
		}
	}
	internal struct Buffer<TElement>
	{
		internal TElement[] items;

		internal int count;

		internal Buffer(IEnumerable<TElement> source)
		{
			TElement[] array = null;
			int num = 0;
			if (source is ICollection<TElement> collection)
			{
				num = collection.Count;
				if (num > 0)
				{
					array = new TElement[num];
					collection.CopyTo(array, 0);
				}
			}
			else
			{
				foreach (TElement item in source)
				{
					if (array == null)
					{
						array = new TElement[4];
					}
					else if (array.Length == num)
					{
						TElement[] array2 = new TElement[checked(num * 2)];
						Array.Copy(array, 0, array2, 0, num);
						array = array2;
					}
					array[num] = item;
					num++;
				}
			}
			items = array;
			count = num;
		}

		internal TElement[] ToArray()
		{
			if (count == 0)
			{
				return new TElement[0];
			}
			if (items.Length == count)
			{
				return items;
			}
			TElement[] array = new TElement[count];
			Array.Copy(items, 0, array, 0, count);
			return array;
		}
	}
	internal sealed class SystemCore_EnumerableDebugView<T>
	{
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private IEnumerable<T> enumerable;

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private T[] cachedCollection;

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private int count;

		[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
		public T[] Items
		{
			get
			{
				List<T> list = new List<T>();
				IEnumerator<T> enumerator = enumerable.GetEnumerator();
				if (enumerator != null)
				{
					count = 0;
					while (enumerator.MoveNext())
					{
						list.Add(enumerator.Current);
						count++;
					}
				}
				if (count == 0)
				{
					throw new SystemCore_EnumerableDebugViewEmptyException();
				}
				cachedCollection = new T[count];
				list.CopyTo(cachedCollection, 0);
				return cachedCollection;
			}
		}

		public SystemCore_EnumerableDebugView(IEnumerable<T> enumerable)
		{
			if (enumerable == null)
			{
				throw new ArgumentNullException("enumerable");
			}
			this.enumerable = enumerable;
		}
	}
	internal sealed class SystemCore_EnumerableDebugViewEmptyException : Exception
	{
		public string Empty => Strings.EmptyEnumerable;
	}
	internal sealed class SystemCore_EnumerableDebugView
	{
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private IEnumerable enumerable;

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private object[] cachedCollection;

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private int count;

		[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
		public object[] Items
		{
			get
			{
				List<object> list = new List<object>();
				IEnumerator enumerator = enumerable.GetEnumerator();
				if (enumerator != null)
				{
					count = 0;
					while (enumerator.MoveNext())
					{
						list.Add(enumerator.Current);
						count++;
					}
				}
				if (count == 0)
				{
					throw new SystemCore_EnumerableDebugViewEmptyException();
				}
				cachedCollection = new object[count];
				list.CopyTo(cachedCollection, 0);
				return cachedCollection;
			}
		}

		public SystemCore_EnumerableDebugView(IEnumerable enumerable)
		{
			if (enumerable == null)
			{
				throw new ArgumentNullException("enumerable");
			}
			this.enumerable = enumerable;
			count = 0;
			cachedCollection = null;
		}
	}
	internal abstract class EnumerableQuery
	{
		internal abstract Expression Expression { get; }

		internal abstract IEnumerable Enumerable { get; }

		internal static IQueryable Create(Type elementType, IEnumerable sequence)
		{
			Type type = typeof(EnumerableQuery<>).MakeGenericType(elementType);
			return (IQueryable)Activator.CreateInstance(type, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new object[1] { sequence }, null);
		}

		internal static IQueryable Create(Type elementType, Expression expression)
		{
			Type type = typeof(EnumerableQuery<>).MakeGenericType(elementType);
			return (IQueryable)Activator.CreateInstance(type, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new object[1] { expression }, null);
		}
	}
	internal class EnumerableQuery<T> : EnumerableQuery, IOrderedQueryable<T>, IQueryable<T>, IOrderedQueryable, IQueryable, IQueryProvider, IEnumerable<T>, IEnumerable
	{
		private Expression expression;

		private IEnumerable<T> enumerable;

		IQueryProvider IQueryable.Provider => this;

		internal override Expression Expression => expression;

		internal override IEnumerable Enumerable => enumerable;

		Expression IQueryable.Expression => expression;

		Type IQueryable.ElementType => typeof(T);

		internal EnumerableQuery(IEnumerable<T> enumerable)
		{
			this.enumerable = enumerable;
			expression = Expression.Constant(this);
		}

		internal EnumerableQuery(Expression expression)
		{
			this.expression = expression;
		}

		IQueryable IQueryProvider.CreateQuery(Expression expression)
		{
			if (expression == null)
			{
				throw Error.ArgumentNull("expression");
			}
			Type type = TypeHelper.FindGenericType(typeof(IQueryable<>), expression.Type);
			if (type == null)
			{
				throw Error.ArgumentNotValid("expression");
			}
			return EnumerableQuery.Create(type.GetGenericArguments()[0], expression);
		}

		IQueryable<S> IQueryProvider.CreateQuery<S>(Expression expression)
		{
			if (expression == null)
			{
				throw Error.ArgumentNull("expression");
			}
			if (!typeof(IQueryable<S>).IsAssignableFrom(expression.Type))
			{
				throw Error.ArgumentNotValid("expression");
			}
			return new EnumerableQuery<S>(expression);
		}

		object IQueryProvider.Execute(Expression expression)
		{
			if (expression == null)
			{
				throw Error.ArgumentNull("expression");
			}
			typeof(EnumerableExecutor<>).MakeGenericType(expression.Type);
			return EnumerableExecutor.Create(expression).ExecuteBoxed();
		}

		S IQueryProvider.Execute<S>(Expression expression)
		{
			if (expression == null)
			{
				throw Error.ArgumentNull("expression");
			}
			if (!typeof(S).IsAssignableFrom(expression.Type))
			{
				throw Error.ArgumentNotValid("expression");
			}
			return new EnumerableExecutor<S>(expression).Execute();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		IEnumerator<T> IEnumerable<T>.GetEnumerator()
		{
			return GetEnumerator();
		}

		private IEnumerator<T> GetEnumerator()
		{
			if (enumerable == null)
			{
				EnumerableRewriter enumerableRewriter = new EnumerableRewriter();
				Expression body = enumerableRewriter.Visit(expression);
				ExpressionCompiler expressionCompiler = new ExpressionCompiler();
				Expression<Func<IEnumerable<T>>> lambda = Expression.Lambda<Func<IEnumerable<T>>>(body, (IEnumerable<ParameterExpression>)null);
				enumerable = expressionCompiler.Compile(lambda)();
			}
			return enumerable.GetEnumerator();
		}

		public override string ToString()
		{
			if (expression is ConstantExpression constantExpression && constantExpression.Value == this)
			{
				if (enumerable != null)
				{
					return enumerable.ToString();
				}
				return "null";
			}
			return expression.ToString();
		}
	}
	internal abstract class EnumerableExecutor
	{
		internal abstract object ExecuteBoxed();

		internal static EnumerableExecutor Create(Expression expression)
		{
			Type type = typeof(EnumerableExecutor<>).MakeGenericType(expression.Type);
			return (EnumerableExecutor)Activator.CreateInstance(type, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new object[1] { expression }, null);
		}
	}
	internal class EnumerableExecutor<T> : EnumerableExecutor
	{
		private Expression expression;

		private Func<T> func;

		internal EnumerableExecutor(Expression expression)
		{
			this.expression = expression;
		}

		internal override object ExecuteBoxed()
		{
			return Execute();
		}

		internal T Execute()
		{
			if (func == null)
			{
				EnumerableRewriter enumerableRewriter = new EnumerableRewriter();
				Expression body = enumerableRewriter.Visit(expression);
				ExpressionCompiler expressionCompiler = new ExpressionCompiler();
				Expression<Func<T>> lambda = Expression.Lambda<Func<T>>(body, (IEnumerable<ParameterExpression>)null);
				func = expressionCompiler.Compile(lambda);
			}
			return func();
		}
	}
	internal class EnumerableRewriter : ExpressionVisitor
	{
		private static ILookup<string, MethodInfo> _seqMethods;

		internal EnumerableRewriter()
		{
		}

		internal override Expression VisitMethodCall(MethodCallExpression m)
		{
			Expression expression = Visit(m.Object);
			ReadOnlyCollection<Expression> readOnlyCollection = VisitExpressionList(m.Arguments);
			if (expression != m.Object || readOnlyCollection != m.Arguments)
			{
				readOnlyCollection.ToArray();
				Type[] typeArgs = (m.Method.IsGenericMethod ? m.Method.GetGenericArguments() : null);
				if ((m.Method.IsStatic || m.Method.DeclaringType.IsAssignableFrom(expression.Type)) && ArgsMatch(m.Method, readOnlyCollection, typeArgs))
				{
					return Expression.Call(expression, m.Method, readOnlyCollection);
				}
				if (m.Method.DeclaringType == typeof(Queryable))
				{
					MethodInfo methodInfo = FindEnumerableMethod(m.Method.Name, readOnlyCollection, typeArgs);
					readOnlyCollection = FixupQuotedArgs(methodInfo, readOnlyCollection);
					return Expression.Call(expression, methodInfo, readOnlyCollection);
				}
				BindingFlags flags = BindingFlags.Static | (m.Method.IsPublic ? BindingFlags.Public : BindingFlags.NonPublic);
				MethodInfo methodInfo2 = FindMethod(m.Method.DeclaringType, m.Method.Name, readOnlyCollection, typeArgs, flags);
				readOnlyCollection = FixupQuotedArgs(methodInfo2, readOnlyCollection);
				return Expression.Call(expression, methodInfo2, readOnlyCollection);
			}
			return m;
		}

		private ReadOnlyCollection<Expression> FixupQuotedArgs(MethodInfo mi, ReadOnlyCollection<Expression> argList)
		{
			ParameterInfo[] parameters = mi.GetParameters();
			if (parameters.Length > 0)
			{
				List<Expression> list = null;
				int i = 0;
				for (int num = parameters.Length; i < num; i++)
				{
					Expression expression = argList[i];
					ParameterInfo parameterInfo = parameters[i];
					expression = FixupQuotedExpression(parameterInfo.ParameterType, expression);
					if (list == null && expression != argList[i])
					{
						list = new List<Expression>(argList.Count);
						for (int j = 0; j < i; j++)
						{
							list.Add(argList[j]);
						}
					}
					list?.Add(expression);
				}
				if (list != null)
				{
					argList = list.ToReadOnlyCollection();
				}
			}
			return argList;
		}

		private Expression FixupQuotedExpression(Type type, Expression expression)
		{
			Expression expression2 = expression;
			while (true)
			{
				if (type.IsAssignableFrom(expression2.Type))
				{
					return expression2;
				}
				if (expression2.NodeType != ExpressionType.Quote)
				{
					break;
				}
				expression2 = ((UnaryExpression)expression2).Operand;
			}
			if (!type.IsAssignableFrom(expression2.Type) && type.IsArray && expression2.NodeType == ExpressionType.NewArrayInit)
			{
				Type c = StripExpression(expression2.Type);
				if (type.IsAssignableFrom(c))
				{
					Type elementType = type.GetElementType();
					NewArrayExpression newArrayExpression = (NewArrayExpression)expression2;
					List<Expression> list = new List<Expression>(newArrayExpression.Expressions.Count);
					int i = 0;
					for (int count = newArrayExpression.Expressions.Count; i < count; i++)
					{
						list.Add(FixupQuotedExpression(elementType, newArrayExpression.Expressions[i]));
					}
					expression = Expression.NewArrayInit(elementType, list);
				}
			}
			return expression;
		}

		internal override Expression VisitLambda(LambdaExpression lambda)
		{
			return lambda;
		}

		private static Type GetPublicType(Type t)
		{
			if (t.IsGenericType && t.GetGenericTypeDefinition() == typeof(Lookup<, >.Grouping))
			{
				return typeof(IGrouping<, >).MakeGenericType(t.GetGenericArguments());
			}
			if (!t.IsNestedPrivate)
			{
				return t;
			}
			Type[] interfaces = t.GetInterfaces();
			foreach (Type type in interfaces)
			{
				if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(IEnumerable<>))
				{
					return type;
				}
			}
			if (typeof(IEnumerable).IsAssignableFrom(t))
			{
				return typeof(IEnumerable);
			}
			return t;
		}

		internal override Expression VisitConstant(ConstantExpression c)
		{
			if (c.Value is EnumerableQuery enumerableQuery)
			{
				if (enumerableQuery.Enumerable != null)
				{
					Type publicType = GetPublicType(enumerableQuery.Enumerable.GetType());
					return Expression.Constant(enumerableQuery.Enumerable, publicType);
				}
				return Visit(enumerableQuery.Expression);
			}
			return c;
		}

		internal override Expression VisitParameter(ParameterExpression p)
		{
			return p;
		}

		private static MethodInfo FindEnumerableMethod(string name, ReadOnlyCollection<Expression> args, params Type[] typeArgs)
		{
			if (_seqMethods == null)
			{
				_seqMethods = typeof(Enumerable).GetMethods(BindingFlags.Static | BindingFlags.Public).ToLookup((MethodInfo m) => m.Name);
			}
			MethodInfo methodInfo = _seqMethods[name].FirstOrDefault((MethodInfo m) => ArgsMatch(m, args, typeArgs));
			if (methodInfo == null)
			{
				throw Error.NoMethodOnTypeMatchingArguments(name, typeof(Enumerable));
			}
			if (typeArgs != null)
			{
				return methodInfo.MakeGenericMethod(typeArgs);
			}
			return methodInfo;
		}

		internal static MethodInfo FindMethod(Type type, string name, ReadOnlyCollection<Expression> args, Type[] typeArgs, BindingFlags flags)
		{
			MethodInfo[] array = (from m in type.GetMethods(flags)
				where m.Name == name
				select m).ToArray();
			if (array.Length == 0)
			{
				throw Error.NoMethodOnType(name, type);
			}
			MethodInfo methodInfo = array.FirstOrDefault((MethodInfo m) => ArgsMatch(m, args, typeArgs));
			if (methodInfo == null)
			{
				throw Error.NoMethodOnTypeMatchingArguments(name, type);
			}
			if (typeArgs != null)
			{
				return methodInfo.MakeGenericMethod(typeArgs);
			}
			return methodInfo;
		}

		private static bool ArgsMatch(MethodInfo m, ReadOnlyCollection<Expression> args, Type[] typeArgs)
		{
			ParameterInfo[] parameters = m.GetParameters();
			if (parameters.Length != args.Count)
			{
				return false;
			}
			if (!m.IsGenericMethod && typeArgs != null && typeArgs.Length > 0)
			{
				return false;
			}
			if (!m.IsGenericMethodDefinition && m.IsGenericMethod && m.ContainsGenericParameters)
			{
				m = m.GetGenericMethodDefinition();
			}
			if (m.IsGenericMethodDefinition)
			{
				if (typeArgs == null || typeArgs.Length == 0)
				{
					return false;
				}
				if (m.GetGenericArguments().Length != typeArgs.Length)
				{
					return false;
				}
				m = m.MakeGenericMethod(typeArgs);
				parameters = m.GetParameters();
			}
			int i = 0;
			for (int count = args.Count; i < count; i++)
			{
				Type type = parameters[i].ParameterType;
				if (type == null)
				{
					return false;
				}
				if (type.IsByRef)
				{
					type = type.GetElementType();
				}
				Expression expression = args[i];
				if (!type.IsAssignableFrom(expression.Type))
				{
					if (expression.NodeType == ExpressionType.Quote)
					{
						expression = ((UnaryExpression)expression).Operand;
					}
					if (!type.IsAssignableFrom(expression.Type) && !type.IsAssignableFrom(StripExpression(expression.Type)))
					{
						return false;
					}
				}
			}
			return true;
		}

		private static Type StripExpression(Type type)
		{
			bool isArray = type.IsArray;
			Type type2 = (isArray ? type.GetElementType() : type);
			Type type3 = TypeHelper.FindGenericType(typeof(Expression<>), type2);
			if (type3 != null)
			{
				type2 = type3.GetGenericArguments()[0];
			}
			if (isArray)
			{
				int arrayRank = type.GetArrayRank();
				if (arrayRank != 1)
				{
					return type2.MakeArrayType(arrayRank);
				}
				return type2.MakeArrayType();
			}
			return type;
		}
	}
	internal static class TypeHelper
	{
		internal static bool IsEnumerableType(Type enumerableType)
		{
			return FindGenericType(typeof(IEnumerable<>), enumerableType) != null;
		}

		internal static bool IsKindOfGeneric(Type type, Type definition)
		{
			return FindGenericType(definition, type) != null;
		}

		internal static Type GetElementType(Type enumerableType)
		{
			Type type = FindGenericType(typeof(IEnumerable<>), enumerableType);
			if (type != null)
			{
				return type.GetGenericArguments()[0];
			}
			return enumerableType;
		}

		internal static Type FindGenericType(Type definition, Type type)
		{
			while (type != null && type != typeof(object))
			{
				if (type.IsGenericType && type.GetGenericTypeDefinition() == definition)
				{
					return type;
				}
				if (definition.IsInterface)
				{
					Type[] interfaces = type.GetInterfaces();
					foreach (Type type2 in interfaces)
					{
						Type type3 = FindGenericType(definition, type2);
						if (type3 != null)
						{
							return type3;
						}
					}
				}
				type = type.BaseType;
			}
			return null;
		}

		internal static bool IsNullableType(Type type)
		{
			if (type != null && type.IsGenericType)
			{
				return type.GetGenericTypeDefinition() == typeof(Nullable<>);
			}
			return false;
		}

		internal static Type GetNonNullableType(Type type)
		{
			if (IsNullableType(type))
			{
				return type.GetGenericArguments()[0];
			}
			return type;
		}
	}
	internal static class Strings
	{
		internal static string OwningTeam => SR.GetString("OwningTeam");

		internal static string IncompatibleElementTypes => SR.GetString("IncompatibleElementTypes");

		internal static string MoreThanOneElement => SR.GetString("MoreThanOneElement");

		internal static string MoreThanOneMatch => SR.GetString("MoreThanOneMatch");

		internal static string NoElements => SR.GetString("NoElements");

		internal static string NoMatch => SR.GetString("NoMatch");

		internal static string EmptyEnumerable => SR.GetString("EmptyEnumerable");

		internal static string ArgumentArrayHasTooManyElements(object p0)
		{
			return SR.GetString("ArgumentArrayHasTooManyElements", p0);
		}

		internal static string ArgumentNotIEnumerableGeneric(object p0)
		{
			return SR.GetString("ArgumentNotIEnumerableGeneric", p0);
		}

		internal static string ArgumentNotSequence(object p0)
		{
			return SR.GetString("ArgumentNotSequence", p0);
		}

		internal static string ArgumentNotValid(object p0)
		{
			return SR.GetString("ArgumentNotValid", p0);
		}

		internal static string ArgumentNotLambda(object p0)
		{
			return SR.GetString("ArgumentNotLambda", p0);
		}

		internal static string NoArgumentMatchingMethodsInQueryable(object p0)
		{
			return SR.GetString("NoArgumentMatchingMethodsInQueryable", p0);
		}

		internal static string NoMethodOnType(object p0, object p1)
		{
			return SR.GetString("NoMethodOnType", p0, p1);
		}

		internal static string NoMethodOnTypeMatchingArguments(object p0, object p1)
		{
			return SR.GetString("NoMethodOnTypeMatchingArguments", p0, p1);
		}

		internal static string NoNameMatchingMethodsInQueryable(object p0)
		{
			return SR.GetString("NoNameMatchingMethodsInQueryable", p0);
		}
	}
	internal static class Error
	{
		internal static Exception ArgumentArrayHasTooManyElements(object p0)
		{
			return new ArgumentException(Strings.ArgumentArrayHasTooManyElements(p0));
		}

		internal static Exception ArgumentNotIEnumerableGeneric(object p0)
		{
			return new ArgumentException(Strings.ArgumentNotIEnumerableGeneric(p0));
		}

		internal static Exception ArgumentNotSequence(object p0)
		{
			return new ArgumentException(Strings.ArgumentNotSequence(p0));
		}

		internal static Exception ArgumentNotValid(object p0)
		{
			return new ArgumentException(Strings.ArgumentNotValid(p0));
		}

		internal static Exception IncompatibleElementTypes()
		{
			return new ArgumentException(Strings.IncompatibleElementTypes);
		}

		internal static Exception ArgumentNotLambda(object p0)
		{
			return new ArgumentException(Strings.ArgumentNotLambda(p0));
		}

		internal static Exception MoreThanOneElement()
		{
			return new InvalidOperationException(Strings.MoreThanOneElement);
		}

		internal static Exception MoreThanOneMatch()
		{
			return new InvalidOperationException(Strings.MoreThanOneMatch);
		}

		internal static Exception NoArgumentMatchingMethodsInQueryable(object p0)
		{
			return new InvalidOperationException(Strings.NoArgumentMatchingMethodsInQueryable(p0));
		}

		internal static Exception NoElements()
		{
			return new InvalidOperationException(Strings.NoElements);
		}

		internal static Exception NoMatch()
		{
			return new InvalidOperationException(Strings.NoMatch);
		}

		internal static Exception NoMethodOnType(object p0, object p1)
		{
			return new InvalidOperationException(Strings.NoMethodOnType(p0, p1));
		}

		internal static Exception NoMethodOnTypeMatchingArguments(object p0, object p1)
		{
			return new InvalidOperationException(Strings.NoMethodOnTypeMatchingArguments(p0, p1));
		}

		internal static Exception NoNameMatchingMethodsInQueryable(object p0)
		{
			return new InvalidOperationException(Strings.NoNameMatchingMethodsInQueryable(p0));
		}

		internal static Exception ArgumentNull(string paramName)
		{
			return new ArgumentNullException(paramName);
		}

		internal static Exception ArgumentOutOfRange(string paramName)
		{
			return new ArgumentOutOfRangeException(paramName);
		}

		internal static Exception NotImplemented()
		{
			return new NotImplementedException();
		}

		internal static Exception NotSupported()
		{
			return new NotSupportedException();
		}
	}
}
namespace System.Runtime.CompilerServices
{
	[AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Class | AttributeTargets.Method)]
	public sealed class ExtensionAttribute : Attribute
	{
	}
	public interface IStrongBox
	{
		object Value { get; set; }
	}
	public class StrongBox<T> : IStrongBox
	{
		public T Value;

		object IStrongBox.Value
		{
			get
			{
				return Value;
			}
			set
			{
				Value = (T)value;
			}
		}

		public StrongBox(T value)
		{
			Value = value;
		}
	}
	public class ExecutionScope
	{
		private class ExpressionIsolator : ExpressionVisitor
		{
			private ExecutionScope top;

			private object[] toplocals;

			internal ExpressionIsolator(ExecutionScope top, object[] toplocals)
			{
				this.top = top;
				this.toplocals = toplocals;
			}

			internal override Expression VisitParameter(ParameterExpression p)
			{
				ExecutionScope parent = top;
				object[] locals = toplocals;
				while (parent != null)
				{
					if (parent.Lambda.HoistedLocals.TryGetValue(p, out var value))
					{
						return Expression.Field(Expression.Convert(Expression.ArrayIndex(Expression.Constant(locals, typeof(object[])), Expression.Constant(value, typeof(int))), locals[value].GetType()), "Value");
					}
					locals = parent.Locals;
					parent = parent.Parent;
				}
				return p;
			}
		}

		public ExecutionScope Parent;

		public object[] Globals;

		public object[] Locals;

		private ExpressionCompiler.LambdaInfo Lambda;

		internal ExecutionScope(ExecutionScope parent, ExpressionCompiler.LambdaInfo lambda, object[] globals, object[] locals)
		{
			Parent = parent;
			Lambda = lambda;
			Globals = globals;
			Locals = locals;
		}

		public object[] CreateHoistedLocals()
		{
			return new object[Lambda.HoistedLocals.Count];
		}

		public Delegate CreateDelegate(int indexLambda, object[] locals)
		{
			ExpressionCompiler.LambdaInfo lambdaInfo = Lambda.Lambdas[indexLambda];
			ExecutionScope target = new ExecutionScope(this, lambdaInfo, Globals, locals);
			return ((DynamicMethod)lambdaInfo.Method).CreateDelegate(lambdaInfo.Lambda.Type, target);
		}

		public Expression IsolateExpression(Expression expression, object[] locals)
		{
			ExpressionIsolator expressionIsolator = new ExpressionIsolator(this, locals);
			return expressionIsolator.Visit(expression);
		}
	}
}
namespace Microsoft.Win32.SafeHandles
{
	[SecurityCritical(SecurityCriticalScope.Everything)]
	internal sealed class SafeBCryptAlgorithmHandle : SafeHandleZeroOrMinusOneIsInvalid
	{
		private SafeBCryptAlgorithmHandle()
			: base(ownsHandle: true)
		{
		}

		[DllImport("bcrypt")]
		[SuppressUnmanagedCodeSecurity]
		[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
		private static extern BCryptNative.ErrorCode BCryptCloseAlgorithmProvider(IntPtr hAlgorithm, int flags);

		protected override bool ReleaseHandle()
		{
			return BCryptCloseAlgorithmProvider(handle, 0) == BCryptNative.ErrorCode.Success;
		}
	}
	[SecurityCritical(SecurityCriticalScope.Everything)]
	internal sealed class SafeBCryptHashHandle : SafeHandleZeroOrMinusOneIsInvalid
	{
		private IntPtr m_hashObject;

		internal IntPtr HashObject
		{
			get
			{
				return m_hashObject;
			}
			set
			{
				Contract.Requires(value != IntPtr.Zero);
				m_hashObject = value;
			}
		}

		private SafeBCryptHashHandle()
			: base(ownsHandle: true)
		{
		}

		[DllImport("bcrypt")]
		[SuppressUnmanagedCodeSecurity]
		[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
		private static extern BCryptNative.ErrorCode BCryptDestroyHash(IntPtr hHash);

		protected override bool ReleaseHandle()
		{
			bool result = BCryptDestroyHash(handle) == BCryptNative.ErrorCode.Success;
			if (m_hashObject != IntPtr.Zero)
			{
				Marshal.FreeCoTaskMem(m_hashObject);
			}
			return result;
		}
	}
	[SecurityCritical(SecurityCriticalScope.Everything)]
	internal sealed class SafeAxlBufferHandle : SafeHandleZeroOrMinusOneIsInvalid
	{
		private SafeAxlBufferHandle()
			: base(ownsHandle: true)
		{
		}

		[DllImport("kernel32")]
		[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
		[SuppressUnmanagedCodeSecurity]
		private static extern IntPtr GetProcessHeap();

		[DllImport("kernel32")]
		[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
		[SuppressUnmanagedCodeSecurity]
		[return: MarshalAs(UnmanagedType.Bool)]
		private static extern bool HeapFree(IntPtr hHeap, int dwFlags, IntPtr lpMem);

		protected override bool ReleaseHandle()
		{
			HeapFree(GetProcessHeap(), 0, handle);
			return true;
		}
	}
	[SecurityCritical(SecurityCriticalScope.Everything)]
	internal sealed class SafeCapiHashHandle : SafeHandleZeroOrMinusOneIsInvalid
	{
		public static SafeCapiHashHandle InvalidHandle
		{
			get
			{
				SafeCapiHashHandle safeCapiHashHandle = new SafeCapiHashHandle();
				safeCapiHashHandle.SetHandle(IntPtr.Zero);
				return safeCapiHashHandle;
			}
		}

		private SafeCapiHashHandle()
			: base(ownsHandle: true)
		{
		}

		[DllImport("advapi32")]
		[SuppressUnmanagedCodeSecurity]
		[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
		[return: MarshalAs(UnmanagedType.Bool)]
		private static extern bool CryptDestroyHash(IntPtr hHash);

		protected override bool ReleaseHandle()
		{
			return CryptDestroyHash(handle);
		}
	}
	[SecurityCritical(SecurityCriticalScope.Everything)]
	internal sealed class SafeCapiKeyHandle : SafeHandleZeroOrMinusOneIsInvalid
	{
		private IntPtr m_csp;

		internal static SafeCapiKeyHandle InvalidHandle
		{
			get
			{
				SafeCapiKeyHandle safeCapiKeyHandle = new SafeCapiKeyHandle();
				safeCapiKeyHandle.SetHandle(IntPtr.Zero);
				return safeCapiKeyHandle;
			}
		}

		private SafeCapiKeyHandle()
			: base(ownsHandle: true)
		{
		}

		[DllImport("advapi32", SetLastError = true)]
		[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
		[SuppressUnmanagedCodeSecurity]
		[return: MarshalAs(UnmanagedType.Bool)]
		private static extern bool CryptContextAddRef(IntPtr hProv, IntPtr pdwReserved, int dwFlags);

		[DllImport("advapi32")]
		[SuppressUnmanagedCodeSecurity]
		[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
		[return: MarshalAs(UnmanagedType.Bool)]
		private static extern bool CryptDestroyKey(IntPtr hKey);

		[DllImport("advapi32")]
		[SuppressUnmanagedCodeSecurity]
		[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
		[return: MarshalAs(UnmanagedType.Bool)]
		private static extern bool CryptReleaseContext(IntPtr hProv, int dwFlags);

		internal SafeCapiKeyHandle Duplicate()
		{
			Contract.Requires(!IsInvalid && !base.IsClosed);
			SafeCapiKeyHandle phKey = null;
			RuntimeHelpers.PrepareConstrainedRegions();
			try
			{
				if (!CapiNative.UnsafeNativeMethods.CryptDuplicateKey(this, IntPtr.Zero, 0, out phKey))
				{
					throw new CryptographicException(Marshal.GetLastWin32Error());
				}
			}
			finally
			{
				if (phKey != null && !phKey.IsInvalid && m_csp != IntPtr.Zero)
				{
					phKey.SetCsp(m_csp);
				}
			}
			return phKey;
		}

		[ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]
		internal void SetCsp(SafeCspHandle parentCsp)
		{
			bool success = false;
			RuntimeHelpers.PrepareConstrainedRegions();
			try
			{
				parentCsp.DangerousAddRef(ref success);
				SetCsp(parentCsp.DangerousGetHandle());
			}
			finally
			{
				if (success)
				{
					parentCsp.DangerousRelease();
				}
			}
		}

		[ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]
		internal void SetCsp(IntPtr parentCsp)
		{
			Contract.Requires(m_csp == IntPtr.Zero);
			int num = 0;
			RuntimeHelpers.PrepareConstrainedRegions();
			try
			{
			}
			finally
			{
				if (!CryptContextAddRef(parentCsp, IntPtr.Zero, 0))
				{
					num = Marshal.GetLastWin32Error();
				}
				else
				{
					m_csp = parentCsp;
				}
			}
			if (num != 0)
			{
				throw new CryptographicException(num);
			}
		}

		protected override bool ReleaseHandle()
		{
			bool flag = CryptDestroyKey(handle);
			bool result = true;
			if (m_csp != IntPtr.Zero)
			{
				result = CryptReleaseContext(m_csp, 0);
			}
			if (flag)
			{
				return result;
			}
			return false;
		}
	}
	[SecurityCritical(SecurityCriticalScope.Everything)]
	internal sealed class SafeCspHandle : SafeHandleZeroOrMinusOneIsInvalid
	{
		private SafeCspHandle()
			: base(ownsHandle: true)
		{
		}

		[DllImport("advapi32", SetLastError = true)]
		[SuppressUnmanagedCodeSecurity]
		[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
		[return: MarshalAs(UnmanagedType.Bool)]
		private static extern bool CryptContextAddRef(SafeCspHandle hProv, IntPtr pdwReserved, int dwFlags);

		[DllImport("advapi32")]
		[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
		[SuppressUnmanagedCodeSecurity]
		[return: MarshalAs(UnmanagedType.Bool)]
		private static extern bool CryptReleaseContext(IntPtr hProv, int dwFlags);

		public SafeCspHandle Duplicate()
		{
			Contract.Requires(!IsInvalid && !base.IsClosed);
			bool success = false;
			RuntimeHelpers.PrepareConstrainedRegions();
			try
			{
				DangerousAddRef(ref success);
				IntPtr intPtr = DangerousGetHandle();
				int num = 0;
				SafeCspHandle safeCspHandle = new SafeCspHandle();
				RuntimeHelpers.PrepareConstrainedRegions();
				try
				{
				}
				finally
				{
					if (!CryptContextAddRef(this, IntPtr.Zero, 0))
					{
						num = Marshal.GetLastWin32Error();
					}
					else
					{
						safeCspHandle.SetHandle(intPtr);
					}
				}
				if (num != 0)
				{
					safeCspHandle.Dispose();
					throw new CryptographicException(num);
				}
				return safeCspHandle;
			}
			finally
			{
				if (success)
				{
					DangerousRelease();
				}
			}
		}

		protected override bool ReleaseHandle()
		{
			return CryptReleaseContext(handle, 0);
		}
	}
	[SecurityCritical(SecurityCriticalScope.Everything)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	[SecurityPermission(SecurityAction.LinkDemand, UnmanagedCode = true)]
	[SecurityPermission(SecurityAction.InheritanceDemand, UnmanagedCode = true)]
	public abstract class SafeNCryptHandle : SafeHandleZeroOrMinusOneIsInvalid
	{
		private enum OwnershipState
		{
			Owner,
			Duplicate,
			Holder
		}

		private OwnershipState m_ownershipState;

		private SafeNCryptHandle m_holder;

		private SafeNCryptHandle Holder
		{
			[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
			get
			{
				Contract.Requires((m_ownershipState == OwnershipState.Duplicate && m_holder != null) || (m_ownershipState != OwnershipState.Duplicate && m_holder == null));
				Contract.Requires(m_holder == null || m_holder.m_ownershipState == OwnershipState.Holder);
				return m_holder;
			}
			[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
			set
			{
				m_holder = value;
				m_ownershipState = OwnershipState.Duplicate;
			}
		}

		protected SafeNCryptHandle()
			: base(ownsHandle: true)
		{
		}

		internal T Duplicate<T>() where T : SafeNCryptHandle, new()
		{
			if (m_ownershipState == OwnershipState.Owner)
			{
				return DuplicateOwnerHandle<T>();
			}
			return DuplicateDuplicatedHandle<T>();
		}

		private T DuplicateDuplicatedHandle<T>() where T : SafeNCryptHandle, new()
		{
			bool success = false;
			T result = new T();
			RuntimeHelpers.PrepareConstrainedRegions();
			try
			{
			}
			finally
			{
				Holder.DangerousAddRef(ref success);
				result.SetHandle(Holder.DangerousGetHandle());
				result.Holder = Holder;
			}
			return result;
		}

		private T DuplicateOwnerHandle<T>() where T : SafeNCryptHandle, new()
		{
			bool success = false;
			T val = new T();
			T result = new T();
			RuntimeHelpers.PrepareConstrainedRegions();
			try
			{
			}
			finally
			{
				val.m_ownershipState = OwnershipState.Holder;
				val.SetHandle(DangerousGetHandle());
				GC.SuppressFinalize(val);
				Holder = val;
				val.DangerousAddRef(ref success);
				result.SetHandle(val.DangerousGetHandle());
				result.Holder = val;
			}
			return result;
		}

		protected override bool ReleaseHandle()
		{
			if (m_ownershipState == OwnershipState.Duplicate)
			{
				Holder.DangerousRelease();
				return true;
			}
			return ReleaseNativeHandle();
		}

		[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
		protected abstract bool ReleaseNativeHandle();
	}
	[SecurityCritical(SecurityCriticalScope.Everything)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	[SecurityPermission(SecurityAction.LinkDemand, UnmanagedCode = true)]
	public sealed class SafeNCryptKeyHandle : SafeNCryptHandle
	{
		[DllImport("ncrypt.dll")]
		[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
		[SuppressUnmanagedCodeSecurity]
		private static extern int NCryptFreeObject(IntPtr hObject);

		internal SafeNCryptKeyHandle Duplicate()
		{
			return Duplicate<SafeNCryptKeyHandle>();
		}

		protected override bool ReleaseNativeHandle()
		{
			return NCryptFreeObject(handle) == 0;
		}
	}
	[SecurityCritical(SecurityCriticalScope.Everything)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	[SecurityPermission(SecurityAction.LinkDemand, UnmanagedCode = true)]
	public sealed class SafeNCryptProviderHandle : SafeNCryptHandle
	{
		[DllImport("ncrypt.dll")]
		[SuppressUnmanagedCodeSecurity]
		[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
		private static extern int NCryptFreeObject(IntPtr hObject);

		internal SafeNCryptProviderHandle Duplicate()
		{
			return Duplicate<SafeNCryptProviderHandle>();
		}

		[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
		internal void SetHandleValue(IntPtr newHandleValue)
		{
			Contract.Requires(newHandleValue != IntPtr.Zero);
			Contract.Requires(!base.IsClosed);
			SetHandle(newHandleValue);
		}

		protected override bool ReleaseNativeHandle()
		{
			return NCryptFreeObject(handle) == 0;
		}
	}
	[SecurityCritical(SecurityCriticalScope.Everything)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	[SecurityPermission(SecurityAction.LinkDemand, UnmanagedCode = true)]
	public sealed class SafeNCryptSecretHandle : SafeNCryptHandle
	{
		[DllImport("ncrypt.dll")]
		[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
		[SuppressUnmanagedCodeSecurity]
		private static extern int NCryptFreeObject(IntPtr hObject);

		protected override bool ReleaseNativeHandle()
		{
			return NCryptFreeObject(handle) == 0;
		}
	}
}
namespace System.Security
{
	[Flags]
	public enum ManifestKinds
	{
		None = 0,
		Deployment = 1,
		Application = 2,
		ApplicationAndDeployment = 3
	}
}
namespace System.Security.Cryptography
{
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public abstract class Aes : SymmetricAlgorithm
	{
		private static KeySizes[] s_legalBlockSizes = new KeySizes[1]
		{
			new KeySizes(128, 128, 0)
		};

		private static KeySizes[] s_legalKeySizes = new KeySizes[1]
		{
			new KeySizes(128, 256, 64)
		};

		protected Aes()
		{
			LegalBlockSizesValue = s_legalBlockSizes;
			LegalKeySizesValue = s_legalKeySizes;
			BlockSizeValue = 128;
			FeedbackSizeValue = 8;
			KeySizeValue = 256;
			ModeValue = CipherMode.CBC;
		}

		public new static Aes Create()
		{
			return Create(typeof(AesCryptoServiceProvider).FullName);
		}

		public new static Aes Create(string algorithmName)
		{
			if (algorithmName == null)
			{
				throw new ArgumentNullException("algorithmName");
			}
			return CoreCryptoConfig.CreateFromName<Aes>(algorithmName);
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class AesCryptoServiceProvider : Aes
	{
		private static KeySizes[] s_supportedKeySizes;

		private static int s_defaultKeySize;

		private SafeCspHandle m_cspHandle;

		private SafeCapiKeyHandle m_key;

		public override byte[] Key
		{
			[SecurityCritical]
			get
			{
				if (m_key == null || m_key.IsInvalid || m_key.IsClosed)
				{
					GenerateKey();
				}
				return CapiNative.ExportSymmetricKey(m_key);
			}
			[SecurityCritical]
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				byte[] array = (byte[])value.Clone();
				if (!ValidKeySize(array.Length * 8))
				{
					throw new CryptographicException(SR.GetString("Cryptography_InvalidKeySize"));
				}
				SafeCapiKeyHandle key = CapiNative.ImportSymmetricKey(m_cspHandle, GetAlgorithmId(array.Length * 8), array);
				if (m_key != null)
				{
					m_key.Dispose();
				}
				m_key = key;
				KeySizeValue = array.Length * 8;
			}
		}

		public override int KeySize
		{
			get
			{
				return base.KeySize;
			}
			[SecurityCritical]
			set
			{
				base.KeySize = value;
				if (m_key != null)
				{
					m_key.Dispose();
				}
			}
		}

		[SecurityCritical]
		public AesCryptoServiceProvider()
		{
			string providerName = "Microsoft Enhanced RSA and AES Cryptographic Provider";
			if (Environment.OSVersion.Version.Major == 5 && Environment.OSVersion.Version.Minor == 1)
			{
				providerName = "Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)";
			}
			m_cspHandle = CapiNative.AcquireCsp(null, providerName, CapiNative.ProviderType.RsaAes, CapiNative.CryptAcquireContextFlags.VerifyContext, throwPlatformException: true);
			FeedbackSizeValue = 8;
			int defaultKeySize = 0;
			KeySizes[] array = FindSupportedKeySizes(m_cspHandle, out defaultKeySize);
			if (array.Length != 0)
			{
				KeySizeValue = defaultKeySize;
				return;
			}
			throw new PlatformNotSupportedException(SR.GetString("Cryptography_PlatformNotSupported"));
		}

		[SecurityCritical]
		public override ICryptoTransform CreateDecryptor()
		{
			if (m_key == null || m_key.IsInvalid || m_key.IsClosed)
			{
				throw new CryptographicException(SR.GetString("Cryptography_DecryptWithNoKey"));
			}
			return CreateDecryptor(m_key, IVValue);
		}

		[SecurityCritical]
		public override ICryptoTransform CreateDecryptor(byte[] key, byte[] iv)
		{
			if (key == null)
			{
				throw new ArgumentNullException("key");
			}
			if (!ValidKeySize(key.Length * 8))
			{
				throw new ArgumentException(SR.GetString("Cryptography_InvalidKeySize"), "key");
			}
			if (iv != null && iv.Length * 8 != BlockSizeValue)
			{
				throw new ArgumentException(SR.GetString("Cryptography_InvalidIVSize"), "iv");
			}
			byte[] array = (byte[])key.Clone();
			byte[] iv2 = null;
			if (iv != null)
			{
				iv2 = (byte[])iv.Clone();
			}
			using SafeCapiKeyHandle key2 = CapiNative.ImportSymmetricKey(m_cspHandle, GetAlgorithmId(array.Length * 8), array);
			return CreateDecryptor(key2, iv2);
		}

		[SecurityCritical]
		private ICryptoTransform CreateDecryptor(SafeCapiKeyHandle key, byte[] iv)
		{
			Contract.Requires(key != null);
			return new CapiSymmetricAlgorithm(BlockSizeValue, FeedbackSizeValue, m_cspHandle, key, iv, Mode, PaddingValue, EncryptionMode.Decrypt);
		}

		[SecurityCritical]
		public override ICryptoTransform CreateEncryptor()
		{
			if (m_key == null || m_key.IsInvalid || m_key.IsClosed)
			{
				GenerateKey();
			}
			if (Mode != CipherMode.ECB && IVValue == null)
			{
				GenerateIV();
			}
			return CreateEncryptor(m_key, IVValue);
		}

		[SecurityCritical]
		public override ICryptoTransform CreateEncryptor(byte[] key, byte[] iv)
		{
			if (key == null)
			{
				throw new ArgumentNullException("key");
			}
			if (!ValidKeySize(key.Length * 8))
			{
				throw new ArgumentException(SR.GetString("Cryptography_InvalidKeySize"), "key");
			}
			if (iv != null && iv.Length * 8 != BlockSizeValue)
			{
				throw new ArgumentException(SR.GetString("Cryptography_InvalidIVSize"), "iv");
			}
			byte[] array = (byte[])key.Clone();
			byte[] iv2 = null;
			if (iv != null)
			{
				iv2 = (byte[])iv.Clone();
			}
			using SafeCapiKeyHandle key2 = CapiNative.ImportSymmetricKey(m_cspHandle, GetAlgorithmId(array.Length * 8), array);
			return CreateEncryptor(key2, iv2);
		}

		[SecurityCritical]
		private ICryptoTransform CreateEncryptor(SafeCapiKeyHandle key, byte[] iv)
		{
			Contract.Requires(key != null);
			return new CapiSymmetricAlgorithm(BlockSizeValue, FeedbackSizeValue, m_cspHandle, key, iv, Mode, PaddingValue, EncryptionMode.Encrypt);
		}

		[SecurityCritical]
		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
			if (disposing)
			{
				if (m_key != null)
				{
					m_key.Dispose();
				}
				if (m_cspHandle != null)
				{
					m_cspHandle.Dispose();
				}
			}
		}

		[SecurityCritical]
		private static KeySizes[] FindSupportedKeySizes(SafeCspHandle csp, out int defaultKeySize)
		{
			Contract.Requires(csp != null);
			if (s_supportedKeySizes == null)
			{
				List<KeySizes> list = new List<KeySizes>();
				int num = 0;
				CapiNative.PROV_ENUMALGS providerParameterStruct = CapiNative.GetProviderParameterStruct<CapiNative.PROV_ENUMALGS>(csp, CapiNative.ProviderParameter.EnumerateAlgorithms, CapiNative.ProviderParameterFlags.RestartEnumeration);
				while (providerParameterStruct.aiAlgId != 0)
				{
					switch (providerParameterStruct.aiAlgId)
					{
					case CapiNative.AlgorithmId.Aes128:
						list.Add(new KeySizes(128, 128, 0));
						if (128 > num)
						{
							num = 128;
						}
						break;
					case CapiNative.AlgorithmId.Aes192:
						list.Add(new KeySizes(192, 192, 0));
						if (192 > num)
						{
							num = 192;
						}
						break;
					case CapiNative.AlgorithmId.Aes256:
						list.Add(new KeySizes(256, 256, 0));
						if (256 > num)
						{
							num = 256;
						}
						break;
					}
					providerParameterStruct = CapiNative.GetProviderParameterStruct<CapiNative.PROV_ENUMALGS>(csp, CapiNative.ProviderParameter.EnumerateAlgorithms, CapiNative.ProviderParameterFlags.None);
				}
				s_supportedKeySizes = list.ToArray();
				s_defaultKeySize = num;
			}
			defaultKeySize = s_defaultKeySize;
			return s_supportedKeySizes;
		}

		[SecurityCritical]
		public override void GenerateKey()
		{
			SafeCapiKeyHandle phKey = null;
			RuntimeHelpers.PrepareConstrainedRegions();
			try
			{
				if (!CapiNative.UnsafeNativeMethods.CryptGenKey(m_cspHandle, GetAlgorithmId(KeySizeValue), CapiNative.KeyFlags.Exportable, out phKey))
				{
					throw new CryptographicException(Marshal.GetLastWin32Error());
				}
			}
			finally
			{
				if (phKey != null && !phKey.IsInvalid)
				{
					phKey.SetCsp(m_cspHandle);
				}
			}
			if (m_key != null)
			{
				m_key.Dispose();
			}
			m_key = phKey;
		}

		[SecurityCritical]
		public override void GenerateIV()
		{
			byte[] array = new byte[BlockSizeValue / 8];
			if (!CapiNative.UnsafeNativeMethods.CryptGenRandom(m_cspHandle, array.Length, array))
			{
				throw new CryptographicException(Marshal.GetLastWin32Error());
			}
			IVValue = array;
		}

		private static CapiNative.AlgorithmId GetAlgorithmId(int keySize)
		{
			return keySize switch
			{
				128 => CapiNative.AlgorithmId.Aes128, 
				192 => CapiNative.AlgorithmId.Aes192, 
				256 => CapiNative.AlgorithmId.Aes256, 
				_ => CapiNative.AlgorithmId.None, 
			};
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class AesManaged : Aes
	{
		private RijndaelManaged m_rijndael;

		public override int FeedbackSize
		{
			get
			{
				return m_rijndael.FeedbackSize;
			}
			set
			{
				m_rijndael.FeedbackSize = value;
			}
		}

		public override byte[] IV
		{
			get
			{
				return m_rijndael.IV;
			}
			set
			{
				m_rijndael.IV = value;
			}
		}

		public override byte[] Key
		{
			get
			{
				return m_rijndael.Key;
			}
			set
			{
				m_rijndael.Key = value;
			}
		}

		public override int KeySize
		{
			get
			{
				return m_rijndael.KeySize;
			}
			set
			{
				m_rijndael.KeySize = value;
			}
		}

		public override CipherMode Mode
		{
			get
			{
				return m_rijndael.Mode;
			}
			set
			{
				if (value == CipherMode.CFB || value == CipherMode.OFB)
				{
					throw new CryptographicException(SR.GetString("Cryptography_InvalidCipherMode"));
				}
				m_rijndael.Mode = value;
			}
		}

		public override PaddingMode Padding
		{
			get
			{
				return m_rijndael.Padding;
			}
			set
			{
				m_rijndael.Padding = value;
			}
		}

		public AesManaged()
		{
			if (CoreCryptoConfig.EnforceFipsAlgorithms)
			{
				throw new InvalidOperationException(SR.GetString("Cryptography_NonCompliantFIPSAlgorithm"));
			}
			m_rijndael = new RijndaelManaged();
			m_rijndael.BlockSize = BlockSize;
			m_rijndael.KeySize = KeySize;
		}

		public override ICryptoTransform CreateDecryptor()
		{
			return m_rijndael.CreateDecryptor();
		}

		public override ICryptoTransform CreateDecryptor(byte[] key, byte[] iv)
		{
			if (key == null)
			{
				throw new ArgumentNullException("key");
			}
			if (!ValidKeySize(key.Length * 8))
			{
				throw new ArgumentException(SR.GetString("Cryptography_InvalidKeySize"), "key");
			}
			if (iv != null && iv.Length * 8 != BlockSizeValue)
			{
				throw new ArgumentException(SR.GetString("Cryptography_InvalidIVSize"), "iv");
			}
			return m_rijndael.CreateDecryptor(key, iv);
		}

		public override ICryptoTransform CreateEncryptor()
		{
			return m_rijndael.CreateEncryptor();
		}

		public override ICryptoTransform CreateEncryptor(byte[] key, byte[] iv)
		{
			if (key == null)
			{
				throw new ArgumentNullException("key");
			}
			if (!ValidKeySize(key.Length * 8))
			{
				throw new ArgumentException(SR.GetString("Cryptography_InvalidKeySize"), "key");
			}
			if (iv != null && iv.Length * 8 != BlockSizeValue)
			{
				throw new ArgumentException(SR.GetString("Cryptography_InvalidIVSize"), "iv");
			}
			return m_rijndael.CreateEncryptor(key, iv);
		}

		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
			if (disposing)
			{
				((IDisposable)m_rijndael).Dispose();
			}
		}

		public override void GenerateIV()
		{
			m_rijndael.GenerateIV();
		}

		public override void GenerateKey()
		{
			m_rijndael.GenerateKey();
		}
	}
	internal static class BCryptNative
	{
		internal static class AlgorithmName
		{
			public const string ECDHP256 = "ECDH_P256";

			public const string ECDHP384 = "ECDH_P384";

			public const string ECDHP521 = "ECDH_P521";

			public const string ECDsaP256 = "ECDSA_P256";

			public const string ECDsaP384 = "ECDSA_P384";

			public const string ECDsaP521 = "ECDSA_P521";

			public const string MD5 = "MD5";

			public const string Sha1 = "SHA1";

			public const string Sha256 = "SHA256";

			public const string Sha384 = "SHA384";

			public const string Sha512 = "SHA512";
		}

		internal enum ErrorCode
		{
			Success = 0,
			BufferToSmall = -1073741789,
			ObjectNameNotFound = -1073741772
		}

		internal static class HashPropertyName
		{
			public const string HashLength = "HashDigestLength";
		}

		internal enum KeyBlobMagicNumber
		{
			ECDHPublicP256 = 827016005,
			ECDHPublicP384 = 860570437,
			ECDHPublicP521 = 894124869,
			ECDsaPublicP256 = 827540293,
			ECDsaPublicP384 = 861094725,
			ECDsaPublicP521 = 894649157
		}

		internal static class KeyDerivationFunction
		{
			public const string Hash = "HASH";

			public const string Hmac = "HMAC";

			public const string Tls = "TLS_PRF";
		}

		internal static class ProviderName
		{
			public const string MicrosoftPrimitiveProvider = "Microsoft Primitive Provider";
		}

		internal static class ObjectPropertyName
		{
			public const string ObjectLength = "ObjectLength";
		}

		[SuppressUnmanagedCodeSecurity]
		[SecurityCritical(SecurityCriticalScope.Everything)]
		internal static class UnsafeNativeMethods
		{
			[DllImport("bcrypt.dll", CharSet = CharSet.Unicode)]
			internal static extern ErrorCode BCryptCreateHash(SafeBCryptAlgorithmHandle hAlgorithm, out SafeBCryptHashHandle phHash, IntPtr pbHashObject, int cbHashObject, IntPtr pbSecret, int cbSecret, int dwFlags);

			[DllImport("bcrypt.dll", CharSet = CharSet.Unicode)]
			internal static extern ErrorCode BCryptGetProperty(SafeBCryptAlgorithmHandle hObject, string pszProperty, [In][Out][MarshalAs(UnmanagedType.LPArray)] byte[] pbOutput, int cbOutput, [In][Out] ref int pcbResult, int flags);

			[DllImport("bcrypt.dll", CharSet = CharSet.Unicode, EntryPoint = "BCryptGetProperty")]
			internal static extern ErrorCode BCryptGetAlgorithmProperty(SafeBCryptAlgorithmHandle hObject, string pszProperty, [In][Out][MarshalAs(UnmanagedType.LPArray)] byte[] pbOutput, int cbOutput, [In][Out] ref int pcbResult, int flags);

			[DllImport("bcrypt.dll", CharSet = CharSet.Unicode, EntryPoint = "BCryptGetProperty")]
			internal static extern ErrorCode BCryptGetHashProperty(SafeBCryptHashHandle hObject, string pszProperty, [In][Out][MarshalAs(UnmanagedType.LPArray)] byte[] pbOutput, int cbOutput, [In][Out] ref int pcbResult, int flags);

			[DllImport("bcrypt.dll")]
			internal static extern ErrorCode BCryptFinishHash(SafeBCryptHashHandle hHash, [Out][MarshalAs(UnmanagedType.LPArray)] byte[] pbInput, int cbInput, int dwFlags);

			[DllImport("bcrypt.dll")]
			internal static extern ErrorCode BCryptHashData(SafeBCryptHashHandle hHash, [In][MarshalAs(UnmanagedType.LPArray)] byte[] pbInput, int cbInput, int dwFlags);

			[DllImport("bcrypt.dll", CharSet = CharSet.Unicode)]
			internal static extern ErrorCode BCryptOpenAlgorithmProvider(out SafeBCryptAlgorithmHandle phAlgorithm, string pszAlgId, string pszImplementation, int dwFlags);
		}

		private delegate ErrorCode BCryptPropertyGetter<T>(T hObject, string pszProperty, byte[] pbOutput, int cbOutput, ref int pcbResult, int dwFlags) where T : SafeHandle;

		private static bool? s_bcryptSupported;

		internal static bool BCryptSupported
		{
			[SecurityCritical]
			get
			{
				if (!s_bcryptSupported.HasValue)
				{
					using SafeLibraryHandle safeLibraryHandle = Microsoft.Win32.UnsafeNativeMethods.LoadLibraryEx("bcrypt", IntPtr.Zero, 0);
					s_bcryptSupported = !safeLibraryHandle.IsInvalid;
				}
				return s_bcryptSupported.Value;
			}
		}

		[SecurityCritical]
		internal static int GetInt32Property<T>(T algorithm, string property) where T : SafeHandle
		{
			Contract.Requires(algorithm != null);
			Contract.Requires(property == "HashDigestLength" || property == "ObjectLength");
			return BitConverter.ToInt32(GetProperty(algorithm, property), 0);
		}

		[SecurityCritical]
		internal static byte[] GetProperty<T>(T algorithm, string property) where T : SafeHandle
		{
			Contract.Requires(algorithm != null);
			Contract.Requires(!string.IsNullOrEmpty(property));
			BCryptPropertyGetter<T> bCryptPropertyGetter = null;
			if (typeof(T) == typeof(SafeBCryptAlgorithmHandle))
			{
				bCryptPropertyGetter = new BCryptPropertyGetter<SafeBCryptAlgorithmHandle>(UnsafeNativeMethods.BCryptGetAlgorithmProperty) as BCryptPropertyGetter<T>;
			}
			else if (typeof(T) == typeof(SafeBCryptHashHandle))
			{
				bCryptPropertyGetter = new BCryptPropertyGetter<SafeBCryptHashHandle>(UnsafeNativeMethods.BCryptGetHashProperty) as BCryptPropertyGetter<T>;
			}
			int pcbResult = 0;
			ErrorCode errorCode = bCryptPropertyGetter(algorithm, property, null, 0, ref pcbResult, 0);
			if (errorCode != ErrorCode.BufferToSmall && errorCode != 0)
			{
				throw new CryptographicException((int)errorCode);
			}
			byte[] array = new byte[pcbResult];
			errorCode = bCryptPropertyGetter(algorithm, property, array, array.Length, ref pcbResult, 0);
			if (errorCode != 0)
			{
				throw new CryptographicException((int)errorCode);
			}
			return array;
		}

		internal static void MapAlgorithmIdToMagic(string algorithm, out KeyBlobMagicNumber algorithmMagic, out int keySize)
		{
			Contract.Requires(!string.IsNullOrEmpty(algorithm));
			switch (algorithm)
			{
			case "ECDH_P256":
				algorithmMagic = KeyBlobMagicNumber.ECDHPublicP256;
				keySize = 256;
				break;
			case "ECDH_P384":
				algorithmMagic = KeyBlobMagicNumber.ECDHPublicP384;
				keySize = 384;
				break;
			case "ECDH_P521":
				algorithmMagic = KeyBlobMagicNumber.ECDHPublicP521;
				keySize = 521;
				break;
			case "ECDSA_P256":
				algorithmMagic = KeyBlobMagicNumber.ECDsaPublicP256;
				keySize = 256;
				break;
			case "ECDSA_P384":
				algorithmMagic = KeyBlobMagicNumber.ECDsaPublicP384;
				keySize = 384;
				break;
			case "ECDSA_P521":
				algorithmMagic = KeyBlobMagicNumber.ECDsaPublicP521;
				keySize = 521;
				break;
			default:
				throw new ArgumentException(SR.GetString("Cryptography_UnknownEllipticCurveAlgorithm"));
			}
		}

		[SecurityCritical]
		internal static SafeBCryptAlgorithmHandle OpenAlgorithm(string algorithm, string implementation)
		{
			Contract.Requires(!string.IsNullOrEmpty(algorithm));
			Contract.Requires(!string.IsNullOrEmpty(implementation));
			SafeBCryptAlgorithmHandle phAlgorithm = null;
			ErrorCode errorCode = UnsafeNativeMethods.BCryptOpenAlgorithmProvider(out phAlgorithm, algorithm, implementation, 0);
			if (errorCode != 0)
			{
				throw new CryptographicException((int)errorCode);
			}
			return phAlgorithm;
		}
	}
	internal sealed class BCryptHashAlgorithm : IDisposable
	{
		private SafeBCryptAlgorithmHandle m_algorithmHandle;

		private SafeBCryptHashHandle m_hashHandle;

		[SecurityCritical]
		public BCryptHashAlgorithm(CngAlgorithm algorithm, string implementation)
		{
			Contract.Requires(algorithm != null);
			Contract.Requires(!string.IsNullOrEmpty(implementation));
			if (!BCryptNative.BCryptSupported)
			{
				throw new PlatformNotSupportedException(SR.GetString("Cryptography_PlatformNotSupported"));
			}
			m_algorithmHandle = BCryptNative.OpenAlgorithm(algorithm.Algorithm, implementation);
			Initialize();
		}

		[SecurityCritical]
		public void Dispose()
		{
			if (m_hashHandle != null)
			{
				m_hashHandle.Dispose();
			}
			if (m_algorithmHandle != null)
			{
				m_algorithmHandle.Dispose();
			}
		}

		[SecurityCritical]
		public void Initialize()
		{
			SafeBCryptHashHandle phHash = null;
			IntPtr intPtr = IntPtr.Zero;
			RuntimeHelpers.PrepareConstrainedRegions();
			try
			{
				int int32Property = BCryptNative.GetInt32Property(m_algorithmHandle, "ObjectLength");
				RuntimeHelpers.PrepareConstrainedRegions();
				try
				{
				}
				finally
				{
					intPtr = Marshal.AllocCoTaskMem(int32Property);
				}
				BCryptNative.ErrorCode errorCode = BCryptNative.UnsafeNativeMethods.BCryptCreateHash(m_algorithmHandle, out phHash, intPtr, int32Property, IntPtr.Zero, 0, 0);
				if (errorCode != 0)
				{
					throw new CryptographicException((int)errorCode);
				}
				phHash.HashObject = intPtr;
			}
			finally
			{
				if (intPtr != IntPtr.Zero && (phHash == null || phHash.HashObject == IntPtr.Zero))
				{
					Marshal.FreeCoTaskMem(intPtr);
				}
			}
			if (m_hashHandle != null)
			{
				m_hashHandle.Dispose();
			}
			m_hashHandle = phHash;
		}

		[SecurityCritical]
		public void HashCore(byte[] array, int ibStart, int cbSize)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			if (ibStart < 0 || ibStart > array.Length - cbSize)
			{
				throw new ArgumentOutOfRangeException("ibStart");
			}
			if (cbSize < 0 || cbSize > array.Length)
			{
				throw new ArgumentOutOfRangeException("cbSize");
			}
			byte[] array2 = new byte[cbSize];
			Buffer.BlockCopy(array, ibStart, array2, 0, cbSize);
			BCryptNative.ErrorCode errorCode = BCryptNative.UnsafeNativeMethods.BCryptHashData(m_hashHandle, array2, array2.Length, 0);
			if (errorCode != 0)
			{
				throw new CryptographicException((int)errorCode);
			}
		}

		[SecurityCritical]
		public byte[] HashFinal()
		{
			int int32Property = BCryptNative.GetInt32Property(m_hashHandle, "HashDigestLength");
			byte[] array = new byte[int32Property];
			BCryptNative.ErrorCode errorCode = BCryptNative.UnsafeNativeMethods.BCryptFinishHash(m_hashHandle, array, array.Length, 0);
			if (errorCode != 0)
			{
				throw new CryptographicException((int)errorCode);
			}
			return array;
		}

		[SecurityCritical]
		public void HashStream(Stream stream)
		{
			Contract.Requires(stream != null);
			byte[] array = new byte[4096];
			int num = 0;
			do
			{
				num = stream.Read(array, 0, array.Length);
				if (num > 0)
				{
					HashCore(array, 0, num);
				}
			}
			while (num > 0);
		}
	}
	[Serializable]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class CngAlgorithm : IEquatable<CngAlgorithm>
	{
		private static CngAlgorithm s_ecdhp256;

		private static CngAlgorithm s_ecdhp384;

		private static CngAlgorithm s_ecdhp521;

		private static CngAlgorithm s_ecdsap256;

		private static CngAlgorithm s_ecdsap384;

		private static CngAlgorithm s_ecdsap521;

		private static CngAlgorithm s_md5;

		private static CngAlgorithm s_sha1;

		private static CngAlgorithm s_sha256;

		private static CngAlgorithm s_sha384;

		private static CngAlgorithm s_sha512;

		private string m_algorithm;

		public string Algorithm => m_algorithm;

		public static CngAlgorithm ECDiffieHellmanP256
		{
			get
			{
				if (s_ecdhp256 == null)
				{
					s_ecdhp256 = new CngAlgorithm("ECDH_P256");
				}
				return s_ecdhp256;
			}
		}

		public static CngAlgorithm ECDiffieHellmanP384
		{
			get
			{
				if (s_ecdhp384 == null)
				{
					s_ecdhp384 = new CngAlgorithm("ECDH_P384");
				}
				return s_ecdhp384;
			}
		}

		public static CngAlgorithm ECDiffieHellmanP521
		{
			get
			{
				if (s_ecdhp521 == null)
				{
					s_ecdhp521 = new CngAlgorithm("ECDH_P521");
				}
				return s_ecdhp521;
			}
		}

		public static CngAlgorithm ECDsaP256
		{
			get
			{
				if (s_ecdsap256 == null)
				{
					s_ecdsap256 = new CngAlgorithm("ECDSA_P256");
				}
				return s_ecdsap256;
			}
		}

		public static CngAlgorithm ECDsaP384
		{
			get
			{
				if (s_ecdsap384 == null)
				{
					s_ecdsap384 = new CngAlgorithm("ECDSA_P384");
				}
				return s_ecdsap384;
			}
		}

		public static CngAlgorithm ECDsaP521
		{
			get
			{
				if (s_ecdsap521 == null)
				{
					s_ecdsap521 = new CngAlgorithm("ECDSA_P521");
				}
				return s_ecdsap521;
			}
		}

		public static CngAlgorithm MD5
		{
			get
			{
				if (s_md5 == null)
				{
					s_md5 = new CngAlgorithm("MD5");
				}
				return s_md5;
			}
		}

		public static CngAlgorithm Sha1
		{
			get
			{
				if (s_sha1 == null)
				{
					s_sha1 = new CngAlgorithm("SHA1");
				}
				return s_sha1;
			}
		}

		public static CngAlgorithm Sha256
		{
			get
			{
				if (s_sha256 == null)
				{
					s_sha256 = new CngAlgorithm("SHA256");
				}
				return s_sha256;
			}
		}

		public static CngAlgorithm Sha384
		{
			get
			{
				if (s_sha384 == null)
				{
					s_sha384 = new CngAlgorithm("SHA384");
				}
				return s_sha384;
			}
		}

		public static CngAlgorithm Sha512
		{
			get
			{
				if (s_sha512 == null)
				{
					s_sha512 = new CngAlgorithm("SHA512");
				}
				return s_sha512;
			}
		}

		public CngAlgorithm(string algorithm)
		{
			if (algorithm == null)
			{
				throw new ArgumentNullException("algorithm");
			}
			if (algorithm.Length == 0)
			{
				throw new ArgumentException(SR.GetString("Cryptography_InvalidAlgorithmName", algorithm), "algorithm");
			}
			m_algorithm = algorithm;
		}

		public static bool operator ==(CngAlgorithm left, CngAlgorithm right)
		{
			if (object.ReferenceEquals(left, null))
			{
				return object.ReferenceEquals(right, null);
			}
			return left.Equals(right);
		}

		[Pure]
		public static bool operator !=(CngAlgorithm left, CngAlgorithm right)
		{
			if (object.ReferenceEquals(left, null))
			{
				return !object.ReferenceEquals(right, null);
			}
			return !left.Equals(right);
		}

		public override bool Equals(object obj)
		{
			return Equals(obj as CngAlgorithm);
		}

		public bool Equals(CngAlgorithm other)
		{
			if (object.ReferenceEquals(other, null))
			{
				return false;
			}
			return m_algorithm.Equals(other.Algorithm);
		}

		public override int GetHashCode()
		{
			return m_algorithm.GetHashCode();
		}

		public override string ToString()
		{
			return m_algorithm;
		}
	}
	[Serializable]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class CngAlgorithmGroup : IEquatable<CngAlgorithmGroup>
	{
		private static CngAlgorithmGroup s_dh;

		private static CngAlgorithmGroup s_dsa;

		private static CngAlgorithmGroup s_ecdh;

		private static CngAlgorithmGroup s_ecdsa;

		private static CngAlgorithmGroup s_rsa;

		private string m_algorithmGroup;

		public string AlgorithmGroup => m_algorithmGroup;

		public static CngAlgorithmGroup DiffieHellman
		{
			get
			{
				if (s_dh == null)
				{
					s_dh = new CngAlgorithmGroup("DH");
				}
				return s_dh;
			}
		}

		public static CngAlgorithmGroup Dsa
		{
			get
			{
				if (s_dsa == null)
				{
					s_dsa = new CngAlgorithmGroup("DSA");
				}
				return s_dsa;
			}
		}

		public static CngAlgorithmGroup ECDiffieHellman
		{
			[Pure]
			get
			{
				if (s_ecdh == null)
				{
					s_ecdh = new CngAlgorithmGroup("ECDH");
				}
				return s_ecdh;
			}
		}

		public static CngAlgorithmGroup ECDsa
		{
			[Pure]
			get
			{
				if (s_ecdsa == null)
				{
					s_ecdsa = new CngAlgorithmGroup("ECDSA");
				}
				return s_ecdsa;
			}
		}

		public static CngAlgorithmGroup Rsa
		{
			get
			{
				if (s_rsa == null)
				{
					s_rsa = new CngAlgorithmGroup("RSA");
				}
				return s_rsa;
			}
		}

		public CngAlgorithmGroup(string algorithmGroup)
		{
			if (algorithmGroup == null)
			{
				throw new ArgumentNullException("algorithmGroup");
			}
			if (algorithmGroup.Length == 0)
			{
				throw new ArgumentException(SR.GetString("Cryptography_InvalidAlgorithmGroup", algorithmGroup), "algorithmGroup");
			}
			m_algorithmGroup = algorithmGroup;
		}

		[Pure]
		public static bool operator ==(CngAlgorithmGroup left, CngAlgorithmGroup right)
		{
			if (object.ReferenceEquals(left, null))
			{
				return object.ReferenceEquals(right, null);
			}
			return left.Equals(right);
		}

		[Pure]
		public static bool operator !=(CngAlgorithmGroup left, CngAlgorithmGroup right)
		{
			if (object.ReferenceEquals(left, null))
			{
				return !object.ReferenceEquals(right, null);
			}
			return !left.Equals(right);
		}

		public override bool Equals(object obj)
		{
			return Equals(obj as CngAlgorithmGroup);
		}

		public bool Equals(CngAlgorithmGroup other)
		{
			if (object.ReferenceEquals(other, null))
			{
				return false;
			}
			return m_algorithmGroup.Equals(other.AlgorithmGroup);
		}

		public override int GetHashCode()
		{
			return m_algorithmGroup.GetHashCode();
		}

		public override string ToString()
		{
			return m_algorithmGroup;
		}
	}
	[Flags]
	public enum CngKeyHandleOpenOptions
	{
		None = 0,
		EphemeralKey = 1
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class CngKey : IDisposable
	{
		private SafeNCryptKeyHandle m_keyHandle;

		private SafeNCryptProviderHandle m_kspHandle;

		public CngAlgorithmGroup AlgorithmGroup
		{
			[SecurityCritical]
			[Pure]
			get
			{
				string propertyAsString = NCryptNative.GetPropertyAsString(m_keyHandle, "Algorithm Group", CngPropertyOptions.None);
				if (propertyAsString == null)
				{
					return null;
				}
				return new CngAlgorithmGroup(propertyAsString);
			}
		}

		public CngAlgorithm Algorithm
		{
			[SecurityCritical]
			get
			{
				string propertyAsString = NCryptNative.GetPropertyAsString(m_keyHandle, "Algorithm Name", CngPropertyOptions.None);
				return new CngAlgorithm(propertyAsString);
			}
		}

		public CngExportPolicies ExportPolicy
		{
			[SecurityCritical]
			get
			{
				return (CngExportPolicies)NCryptNative.GetPropertyAsDWord(m_keyHandle, "Export Policy", CngPropertyOptions.None);
			}
		}

		public SafeNCryptKeyHandle Handle
		{
			[SecurityCritical]
			[SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
			get
			{
				return m_keyHandle.Duplicate();
			}
		}

		public bool IsEphemeral
		{
			[Pure]
			[SecurityCritical]
			get
			{
				bool foundProperty;
				byte[] property = NCryptNative.GetProperty(m_keyHandle, "CLR IsEphemeral", CngPropertyOptions.CustomProperty, out foundProperty);
				if (foundProperty && property != null && property.Length == 1)
				{
					return property[0] == 1;
				}
				return false;
			}
			[SecurityCritical]
			private set
			{
				NCryptNative.SetProperty(m_keyHandle, "CLR IsEphemeral", new byte[1] { (byte)(value ? 1 : 0) }, CngPropertyOptions.CustomProperty);
			}
		}

		public bool IsMachineKey
		{
			[SecurityCritical]
			get
			{
				int propertyAsDWord = NCryptNative.GetPropertyAsDWord(m_keyHandle, "Key Type", CngPropertyOptions.None);
				return (propertyAsDWord & 0x20) == 32;
			}
		}

		public string KeyName
		{
			[SecurityCritical]
			get
			{
				if (IsEphemeral)
				{
					return null;
				}
				return NCryptNative.GetPropertyAsString(m_keyHandle, "Name", CngPropertyOptions.None);
			}
		}

		public int KeySize
		{
			[SecurityCritical]
			get
			{
				return NCryptNative.GetPropertyAsDWord(m_keyHandle, "Length", CngPropertyOptions.None);
			}
		}

		public CngKeyUsages KeyUsage
		{
			[SecurityCritical]
			get
			{
				return (CngKeyUsages)NCryptNative.GetPropertyAsDWord(m_keyHandle, "Key Usage", CngPropertyOptions.None);
			}
		}

		public IntPtr ParentWindowHandle
		{
			[SecurityCritical]
			get
			{
				return NCryptNative.GetPropertyAsIntPtr(m_keyHandle, "HWND Handle", CngPropertyOptions.None);
			}
			[SecurityCritical]
			[SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
			set
			{
				NCryptNative.SetProperty(m_keyHandle, "HWND Handle", value, CngPropertyOptions.None);
			}
		}

		public CngProvider Provider
		{
			[SecurityCritical]
			get
			{
				string propertyAsString = NCryptNative.GetPropertyAsString(m_kspHandle, "Name", CngPropertyOptions.None);
				if (propertyAsString == null)
				{
					return null;
				}
				return new CngProvider(propertyAsString);
			}
		}

		public SafeNCryptProviderHandle ProviderHandle
		{
			[SecurityCritical]
			[SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
			get
			{
				return m_kspHandle.Duplicate();
			}
		}

		public string UniqueName
		{
			[SecurityCritical]
			get
			{
				if (IsEphemeral)
				{
					return null;
				}
				return NCryptNative.GetPropertyAsString(m_keyHandle, "Unique Name", CngPropertyOptions.None);
			}
		}

		public CngUIPolicy UIPolicy
		{
			[SecurityCritical]
			get
			{
				NCryptNative.NCRYPT_UI_POLICY propertyAsStruct = NCryptNative.GetPropertyAsStruct<NCryptNative.NCRYPT_UI_POLICY>(m_keyHandle, "UI Policy", CngPropertyOptions.None);
				string propertyAsString = NCryptNative.GetPropertyAsString(m_keyHandle, "Use Context", CngPropertyOptions.None);
				return new CngUIPolicy(propertyAsStruct.dwFlags, propertyAsStruct.pszFriendlyName, propertyAsStruct.pszDescription, propertyAsString, propertyAsStruct.pszCreationTitle);
			}
		}

		[SecurityCritical]
		private CngKey(SafeNCryptProviderHandle kspHandle, SafeNCryptKeyHandle keyHandle)
		{
			Contract.Requires(keyHandle != null && !keyHandle.IsInvalid && !keyHandle.IsClosed);
			Contract.Requires(kspHandle != null && !kspHandle.IsInvalid && !kspHandle.IsClosed);
			m_keyHandle = keyHandle;
			m_kspHandle = kspHandle;
		}

		[SecurityCritical]
		internal KeyContainerPermission BuildKeyContainerPermission(KeyContainerPermissionFlags flags)
		{
			KeyContainerPermission keyContainerPermission = null;
			if (!IsEphemeral)
			{
				string text = null;
				string providerName = null;
				try
				{
					text = KeyName;
					providerName = NCryptNative.GetPropertyAsString(m_kspHandle, "Name", CngPropertyOptions.None);
				}
				catch (CryptographicException)
				{
				}
				if (text != null)
				{
					KeyContainerPermissionAccessEntry keyContainerPermissionAccessEntry = new KeyContainerPermissionAccessEntry(text, flags);
					keyContainerPermissionAccessEntry.ProviderName = providerName;
					keyContainerPermission = new KeyContainerPermission(KeyContainerPermissionFlags.NoFlags);
					keyContainerPermission.AccessEntries.Add(keyContainerPermissionAccessEntry);
				}
				else
				{
					keyContainerPermission = new KeyContainerPermission(flags);
				}
			}
			return keyContainerPermission;
		}

		public static CngKey Create(CngAlgorithm algorithm)
		{
			return Create(algorithm, null);
		}

		public static CngKey Create(CngAlgorithm algorithm, string keyName)
		{
			return Create(algorithm, keyName, null);
		}

		[SecurityCritical]
		public static CngKey Create(CngAlgorithm algorithm, string keyName, CngKeyCreationParameters creationParameters)
		{
			if (algorithm == null)
			{
				throw new ArgumentNullException("algorithm");
			}
			if (creationParameters == null)
			{
				creationParameters = new CngKeyCreationParameters();
			}
			if (!NCryptNative.NCryptSupported)
			{
				throw new PlatformNotSupportedException(SR.GetString("Cryptography_PlatformNotSupported"));
			}
			if (keyName != null)
			{
				KeyContainerPermissionAccessEntry keyContainerPermissionAccessEntry = new KeyContainerPermissionAccessEntry(keyName, KeyContainerPermissionFlags.Create);
				keyContainerPermissionAccessEntry.ProviderName = creationParameters.Provider.Provider;
				KeyContainerPermission keyContainerPermission = new KeyContainerPermission(KeyContainerPermissionFlags.NoFlags);
				keyContainerPermission.AccessEntries.Add(keyContainerPermissionAccessEntry);
				keyContainerPermission.Demand();
			}
			SafeNCryptProviderHandle safeNCryptProviderHandle = NCryptNative.OpenStorageProvider(creationParameters.Provider.Provider);
			SafeNCryptKeyHandle safeNCryptKeyHandle = NCryptNative.CreatePersistedKey(safeNCryptProviderHandle, algorithm.Algorithm, keyName, creationParameters.KeyCreationOptions);
			SetKeyProperties(safeNCryptKeyHandle, creationParameters);
			NCryptNative.FinalizeKey(safeNCryptKeyHandle);
			CngKey cngKey = new CngKey(safeNCryptProviderHandle, safeNCryptKeyHandle);
			if (keyName == null)
			{
				cngKey.IsEphemeral = true;
			}
			return cngKey;
		}

		[SecurityCritical]
		public void Delete()
		{
			BuildKeyContainerPermission(KeyContainerPermissionFlags.Delete)?.Demand();
			NCryptNative.DeleteKey(m_keyHandle);
			Dispose();
		}

		[SecurityCritical]
		public void Dispose()
		{
			if (m_kspHandle != null)
			{
				m_kspHandle.Dispose();
			}
			if (m_keyHandle != null)
			{
				m_keyHandle.Dispose();
			}
		}

		public static bool Exists(string keyName)
		{
			return Exists(keyName, CngProvider.MicrosoftSoftwareKeyStorageProvider);
		}

		public static bool Exists(string keyName, CngProvider provider)
		{
			return Exists(keyName, provider, CngKeyOpenOptions.None);
		}

		[SecurityCritical]
		public static bool Exists(string keyName, CngProvider provider, CngKeyOpenOptions options)
		{
			if (keyName == null)
			{
				throw new ArgumentNullException("keyName");
			}
			if (provider == null)
			{
				throw new ArgumentNullException("provider");
			}
			if (!NCryptNative.NCryptSupported)
			{
				throw new PlatformNotSupportedException(SR.GetString("Cryptography_PlatformNotSupported"));
			}
			using SafeNCryptProviderHandle hProvider = NCryptNative.OpenStorageProvider(provider.Provider);
			SafeNCryptKeyHandle phKey = null;
			try
			{
				NCryptNative.ErrorCode errorCode = NCryptNative.UnsafeNativeMethods.NCryptOpenKey(hProvider, out phKey, keyName, 0, options);
				bool flag = errorCode == NCryptNative.ErrorCode.KeyDoesNotExist || errorCode == NCryptNative.ErrorCode.NotFound;
				if (errorCode != 0 && !flag)
				{
					throw new CryptographicException((int)errorCode);
				}
				return errorCode == NCryptNative.ErrorCode.Success;
			}
			finally
			{
				phKey?.Dispose();
			}
		}

		public static CngKey Import(byte[] keyBlob, CngKeyBlobFormat format)
		{
			return Import(keyBlob, format, CngProvider.MicrosoftSoftwareKeyStorageProvider);
		}

		[SecurityCritical]
		public static CngKey Import(byte[] keyBlob, CngKeyBlobFormat format, CngProvider provider)
		{
			if (keyBlob == null)
			{
				throw new ArgumentNullException("keyBlob");
			}
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			if (provider == null)
			{
				throw new ArgumentNullException("provider");
			}
			if (!NCryptNative.NCryptSupported)
			{
				throw new PlatformNotSupportedException(SR.GetString("Cryptography_PlatformNotSupported"));
			}
			if (!(format == CngKeyBlobFormat.EccPublicBlob) && !(format == CngKeyBlobFormat.GenericPublicBlob))
			{
				new KeyContainerPermission(KeyContainerPermissionFlags.Import).Demand();
			}
			SafeNCryptProviderHandle safeNCryptProviderHandle = NCryptNative.OpenStorageProvider(provider.Provider);
			SafeNCryptKeyHandle keyHandle = NCryptNative.ImportKey(safeNCryptProviderHandle, keyBlob, format.Format);
			CngKey cngKey = new CngKey(safeNCryptProviderHandle, keyHandle);
			cngKey.IsEphemeral = format != CngKeyBlobFormat.OpaqueTransportBlob;
			return cngKey;
		}

		[SecurityCritical]
		public byte[] Export(CngKeyBlobFormat format)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			BuildKeyContainerPermission(KeyContainerPermissionFlags.Export)?.Demand();
			return NCryptNative.ExportKey(m_keyHandle, format.Format);
		}

		[SecurityCritical]
		[SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
		public CngProperty GetProperty(string name, CngPropertyOptions options)
		{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			bool foundProperty;
			byte[] property = NCryptNative.GetProperty(m_keyHandle, name, options, out foundProperty);
			if (!foundProperty)
			{
				throw new CryptographicException(-2146893807);
			}
			return new CngProperty(name, property, options);
		}

		[SecurityCritical]
		[SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
		public bool HasProperty(string name, CngPropertyOptions options)
		{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			NCryptNative.GetProperty(m_keyHandle, name, options, out var foundProperty);
			return foundProperty;
		}

		public static CngKey Open(string keyName)
		{
			return Open(keyName, CngProvider.MicrosoftSoftwareKeyStorageProvider);
		}

		public static CngKey Open(string keyName, CngProvider provider)
		{
			return Open(keyName, provider, CngKeyOpenOptions.None);
		}

		[SecurityCritical]
		public static CngKey Open(string keyName, CngProvider provider, CngKeyOpenOptions openOptions)
		{
			if (keyName == null)
			{
				throw new ArgumentNullException("keyName");
			}
			if (provider == null)
			{
				throw new ArgumentNullException("provider");
			}
			if (!NCryptNative.NCryptSupported)
			{
				throw new PlatformNotSupportedException(SR.GetString("Cryptography_PlatformNotSupported"));
			}
			KeyContainerPermissionAccessEntry keyContainerPermissionAccessEntry = new KeyContainerPermissionAccessEntry(keyName, KeyContainerPermissionFlags.Open);
			keyContainerPermissionAccessEntry.ProviderName = provider.Provider;
			KeyContainerPermission keyContainerPermission = new KeyContainerPermission(KeyContainerPermissionFlags.NoFlags);
			keyContainerPermission.AccessEntries.Add(keyContainerPermissionAccessEntry);
			keyContainerPermission.Demand();
			SafeNCryptProviderHandle safeNCryptProviderHandle = NCryptNative.OpenStorageProvider(provider.Provider);
			SafeNCryptKeyHandle keyHandle = NCryptNative.OpenKey(safeNCryptProviderHandle, keyName, openOptions);
			return new CngKey(safeNCryptProviderHandle, keyHandle);
		}

		[SecurityCritical]
		[SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
		public static CngKey Open(SafeNCryptKeyHandle keyHandle, CngKeyHandleOpenOptions keyHandleOpenOptions)
		{
			if (keyHandle == null)
			{
				throw new ArgumentNullException("keyHandle");
			}
			if (keyHandle.IsClosed || keyHandle.IsInvalid)
			{
				throw new ArgumentException(SR.GetString("Cryptography_OpenInvalidHandle"), "keyHandle");
			}
			SafeNCryptKeyHandle keyHandle2 = keyHandle.Duplicate();
			SafeNCryptProviderHandle safeNCryptProviderHandle = new SafeNCryptProviderHandle();
			RuntimeHelpers.PrepareConstrainedRegions();
			try
			{
			}
			finally
			{
				IntPtr propertyAsIntPtr = NCryptNative.GetPropertyAsIntPtr(keyHandle, "Provider Handle", CngPropertyOptions.None);
				safeNCryptProviderHandle.SetHandleValue(propertyAsIntPtr);
			}
			CngKey cngKey = null;
			bool flag = false;
			try
			{
				cngKey = new CngKey(safeNCryptProviderHandle, keyHandle2);
				bool flag2 = (keyHandleOpenOptions & CngKeyHandleOpenOptions.EphemeralKey) == CngKeyHandleOpenOptions.EphemeralKey;
				if (!cngKey.IsEphemeral && flag2)
				{
					cngKey.IsEphemeral = true;
				}
				else if (cngKey.IsEphemeral && !flag2)
				{
					throw new ArgumentException(SR.GetString("Cryptography_OpenEphemeralKeyHandleWithoutEphemeralFlag"), "keyHandleOpenOptions");
				}
				flag = true;
			}
			finally
			{
				if (!flag)
				{
					cngKey?.Dispose();
				}
			}
			return cngKey;
		}

		[SecurityCritical]
		private static void SetKeyProperties(SafeNCryptKeyHandle keyHandle, CngKeyCreationParameters creationParameters)
		{
			Contract.Requires(keyHandle != null && !keyHandle.IsInvalid && !keyHandle.IsClosed);
			Contract.Requires(creationParameters != null);
			if (creationParameters.ExportPolicy.HasValue)
			{
				NCryptNative.SetProperty(keyHandle, "Export Policy", (int)creationParameters.ExportPolicy.Value, CngPropertyOptions.Persist);
			}
			if (creationParameters.KeyUsage.HasValue)
			{
				NCryptNative.SetProperty(keyHandle, "Key Usage", (int)creationParameters.KeyUsage.Value, CngPropertyOptions.Persist);
			}
			if (creationParameters.ParentWindowHandle != IntPtr.Zero)
			{
				NCryptNative.SetProperty(keyHandle, "HWND Handle", creationParameters.ParentWindowHandle, CngPropertyOptions.None);
			}
			if (creationParameters.UIPolicy != null)
			{
				NCryptNative.NCRYPT_UI_POLICY value = default(NCryptNative.NCRYPT_UI_POLICY);
				value.dwVersion = 1;
				value.dwFlags = creationParameters.UIPolicy.ProtectionLevel;
				value.pszCreationTitle = creationParameters.UIPolicy.CreationTitle;
				value.pszFriendlyName = creationParameters.UIPolicy.FriendlyName;
				value.pszDescription = creationParameters.UIPolicy.Description;
				NCryptNative.SetProperty(keyHandle, "UI Policy", value, CngPropertyOptions.Persist);
				if (creationParameters.UIPolicy.UseContext != null)
				{
					NCryptNative.SetProperty(keyHandle, "Use Context", creationParameters.UIPolicy.UseContext, CngPropertyOptions.Persist);
				}
			}
			foreach (CngProperty item in creationParameters.ParametersNoDemand)
			{
				NCryptNative.SetProperty(keyHandle, item.Name, item.Value, item.Options);
			}
		}

		[SecurityCritical]
		[SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
		public void SetProperty(CngProperty property)
		{
			NCryptNative.SetProperty(m_keyHandle, property.Name, property.Value, property.Options);
		}
	}
	[Serializable]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class CngKeyBlobFormat : IEquatable<CngKeyBlobFormat>
	{
		private static CngKeyBlobFormat s_eccPrivate;

		private static CngKeyBlobFormat s_eccPublic;

		private static CngKeyBlobFormat s_genericPrivate;

		private static CngKeyBlobFormat s_genericPublic;

		private static CngKeyBlobFormat s_opaqueTransport;

		private static CngKeyBlobFormat s_pkcs8Private;

		private string m_format;

		public string Format => m_format;

		public static CngKeyBlobFormat EccPrivateBlob
		{
			get
			{
				if (s_eccPrivate == null)
				{
					s_eccPrivate = new CngKeyBlobFormat("ECCPRIVATEBLOB");
				}
				return s_eccPrivate;
			}
		}

		public static CngKeyBlobFormat EccPublicBlob
		{
			get
			{
				if (s_eccPublic == null)
				{
					s_eccPublic = new CngKeyBlobFormat("ECCPUBLICBLOB");
				}
				return s_eccPublic;
			}
		}

		public static CngKeyBlobFormat GenericPrivateBlob
		{
			get
			{
				if (s_genericPrivate == null)
				{
					s_genericPrivate = new CngKeyBlobFormat("PRIVATEBLOB");
				}
				return s_genericPrivate;
			}
		}

		public static CngKeyBlobFormat GenericPublicBlob
		{
			get
			{
				if (s_genericPublic == null)
				{
					s_genericPublic = new CngKeyBlobFormat("PUBLICBLOB");
				}
				return s_genericPublic;
			}
		}

		public static CngKeyBlobFormat OpaqueTransportBlob
		{
			get
			{
				if (s_opaqueTransport == null)
				{
					s_opaqueTransport = new CngKeyBlobFormat("OpaqueTransport");
				}
				return s_opaqueTransport;
			}
		}

		public static CngKeyBlobFormat Pkcs8PrivateBlob
		{
			get
			{
				if (s_pkcs8Private == null)
				{
					s_pkcs8Private = new CngKeyBlobFormat("PKCS8_PRIVATEKEY");
				}
				return s_pkcs8Private;
			}
		}

		public CngKeyBlobFormat(string format)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			if (format.Length == 0)
			{
				throw new ArgumentException(SR.GetString("Cryptography_InvalidKeyBlobFormat", format), "format");
			}
			m_format = format;
		}

		public static bool operator ==(CngKeyBlobFormat left, CngKeyBlobFormat right)
		{
			if (object.ReferenceEquals(left, null))
			{
				return object.ReferenceEquals(right, null);
			}
			return left.Equals(right);
		}

		[Pure]
		public static bool operator !=(CngKeyBlobFormat left, CngKeyBlobFormat right)
		{
			if (object.ReferenceEquals(left, null))
			{
				return !object.ReferenceEquals(right, null);
			}
			return !left.Equals(right);
		}

		public override bool Equals(object obj)
		{
			return Equals(obj as CngKeyBlobFormat);
		}

		public bool Equals(CngKeyBlobFormat other)
		{
			if (object.ReferenceEquals(other, null))
			{
				return false;
			}
			return m_format.Equals(other.Format);
		}

		public override int GetHashCode()
		{
			return m_format.GetHashCode();
		}

		public override string ToString()
		{
			return m_format;
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class CngKeyCreationParameters
	{
		private CngExportPolicies? m_exportPolicy;

		private CngKeyCreationOptions m_keyCreationOptions;

		private CngKeyUsages? m_keyUsage;

		private CngPropertyCollection m_parameters = new CngPropertyCollection();

		private IntPtr m_parentWindowHandle;

		private CngProvider m_provider = CngProvider.MicrosoftSoftwareKeyStorageProvider;

		private CngUIPolicy m_uiPolicy;

		public CngExportPolicies? ExportPolicy
		{
			get
			{
				return m_exportPolicy;
			}
			set
			{
				m_exportPolicy = value;
			}
		}

		public CngKeyCreationOptions KeyCreationOptions
		{
			get
			{
				return m_keyCreationOptions;
			}
			set
			{
				m_keyCreationOptions = value;
			}
		}

		public CngKeyUsages? KeyUsage
		{
			get
			{
				return m_keyUsage;
			}
			set
			{
				m_keyUsage = value;
			}
		}

		public IntPtr ParentWindowHandle
		{
			get
			{
				return m_parentWindowHandle;
			}
			[SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
			set
			{
				m_parentWindowHandle = value;
			}
		}

		public CngPropertyCollection Parameters
		{
			[SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
			get
			{
				return m_parameters;
			}
		}

		internal CngPropertyCollection ParametersNoDemand => m_parameters;

		public CngProvider Provider
		{
			get
			{
				return m_provider;
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				m_provider = value;
			}
		}

		public CngUIPolicy UIPolicy
		{
			get
			{
				return m_uiPolicy;
			}
			[UIPermission(SecurityAction.Demand, Window = UIPermissionWindow.SafeSubWindows)]
			[HostProtection(SecurityAction.LinkDemand, Action = SecurityAction.Demand, UI = true)]
			set
			{
				m_uiPolicy = value;
			}
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public struct CngProperty : IEquatable<CngProperty>
	{
		private string m_name;

		private CngPropertyOptions m_propertyOptions;

		private byte[] m_value;

		private int? m_hashCode;

		public string Name => m_name;

		public CngPropertyOptions Options => m_propertyOptions;

		internal byte[] Value => m_value;

		public CngProperty(string name, byte[] value, CngPropertyOptions options)
		{
			Contract.Requires((name != null) ? null : new ArgumentNullException("name"));
			m_name = name;
			m_propertyOptions = options;
			m_hashCode = null;
			if (value != null)
			{
				m_value = value.Clone() as byte[];
			}
			else
			{
				m_value = null;
			}
		}

		public byte[] GetValue()
		{
			byte[] result = null;
			if (m_value != null)
			{
				result = m_value.Clone() as byte[];
			}
			return result;
		}

		public static bool operator ==(CngProperty left, CngProperty right)
		{
			return left.Equals(right);
		}

		public static bool operator !=(CngProperty left, CngProperty right)
		{
			return !left.Equals(right);
		}

		public override bool Equals(object obj)
		{
			if (obj == null || !(obj is CngProperty))
			{
				return false;
			}
			return Equals((CngProperty)obj);
		}

		public bool Equals(CngProperty other)
		{
			if (!string.Equals(Name, other.Name, StringComparison.Ordinal))
			{
				return false;
			}
			if (Options != other.Options)
			{
				return false;
			}
			if (m_value == null)
			{
				return other.m_value == null;
			}
			if (other.m_value == null)
			{
				return false;
			}
			if (m_value.Length != other.m_value.Length)
			{
				return false;
			}
			for (int i = 0; i < m_value.Length; i++)
			{
				if (m_value[i] != other.m_value[i])
				{
					return false;
				}
			}
			return true;
		}

		public override int GetHashCode()
		{
			if (!m_hashCode.HasValue)
			{
				int num = Name.GetHashCode() ^ Options.GetHashCode();
				if (m_value != null)
				{
					for (int i = 0; i < m_value.Length; i++)
					{
						int num2 = m_value[i] << i % 4 * 8;
						num ^= num2;
					}
				}
				m_hashCode = num;
			}
			return m_hashCode.Value;
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class CngPropertyCollection : Collection<CngProperty>
	{
	}
	[Serializable]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class CngProvider : IEquatable<CngProvider>
	{
		private static CngProvider s_msSmartCardKsp;

		private static CngProvider s_msSoftwareKsp;

		private string m_provider;

		public string Provider => m_provider;

		public static CngProvider MicrosoftSmartCardKeyStorageProvider
		{
			get
			{
				if (s_msSmartCardKsp == null)
				{
					s_msSmartCardKsp = new CngProvider("Microsoft Smart Card Key Storage Provider");
				}
				return s_msSmartCardKsp;
			}
		}

		public static CngProvider MicrosoftSoftwareKeyStorageProvider
		{
			get
			{
				if (s_msSoftwareKsp == null)
				{
					s_msSoftwareKsp = new CngProvider("Microsoft Software Key Storage Provider");
				}
				return s_msSoftwareKsp;
			}
		}

		public CngProvider(string provider)
		{
			if (provider == null)
			{
				throw new ArgumentNullException("provider");
			}
			if (provider.Length == 0)
			{
				throw new ArgumentException(SR.GetString("Cryptography_InvalidProviderName", provider), "provider");
			}
			m_provider = provider;
		}

		public static bool operator ==(CngProvider left, CngProvider right)
		{
			if (object.ReferenceEquals(left, null))
			{
				return object.ReferenceEquals(right, null);
			}
			return left.Equals(right);
		}

		[Pure]
		public static bool operator !=(CngProvider left, CngProvider right)
		{
			if (object.ReferenceEquals(left, null))
			{
				return !object.ReferenceEquals(right, null);
			}
			return !left.Equals(right);
		}

		public override bool Equals(object obj)
		{
			return Equals(obj as CngProvider);
		}

		public bool Equals(CngProvider other)
		{
			if (object.ReferenceEquals(other, null))
			{
				return false;
			}
			return m_provider.Equals(other.Provider);
		}

		public override int GetHashCode()
		{
			return m_provider.GetHashCode();
		}

		public override string ToString()
		{
			return m_provider.ToString();
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class CngUIPolicy
	{
		private string m_creationTitle;

		private string m_description;

		private string m_friendlyName;

		private CngUIProtectionLevels m_protectionLevel;

		private string m_useContext;

		public string CreationTitle => m_creationTitle;

		public string Description => m_description;

		public string FriendlyName => m_friendlyName;

		public CngUIProtectionLevels ProtectionLevel => m_protectionLevel;

		public string UseContext => m_useContext;

		public CngUIPolicy(CngUIProtectionLevels protectionLevel)
			: this(protectionLevel, null)
		{
		}

		public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName)
			: this(protectionLevel, friendlyName, null)
		{
		}

		public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName, string description)
			: this(protectionLevel, friendlyName, description, null)
		{
		}

		public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName, string description, string useContext)
			: this(protectionLevel, friendlyName, description, useContext, null)
		{
		}

		public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName, string description, string useContext, string creationTitle)
		{
			m_creationTitle = creationTitle;
			m_description = description;
			m_friendlyName = friendlyName;
			m_protectionLevel = protectionLevel;
			m_useContext = useContext;
		}
	}
	internal sealed class CapiHashAlgorithm : IDisposable
	{
		private CapiNative.AlgorithmId m_algorithmId;

		private SafeCspHandle m_cspHandle;

		private SafeCapiHashHandle m_hashHandle;

		[SecurityCritical]
		public CapiHashAlgorithm(string provider, CapiNative.ProviderType providerType, CapiNative.AlgorithmId algorithm)
		{
			Contract.Requires(!string.IsNullOrEmpty(provider));
			Contract.Requires((algorithm & (CapiNative.AlgorithmId)32768) == (CapiNative.AlgorithmId)32768);
			m_algorithmId = algorithm;
			m_cspHandle = CapiNative.AcquireCsp(null, provider, providerType, CapiNative.CryptAcquireContextFlags.VerifyContext, throwPlatformException: true);
			Initialize();
		}

		[SecurityCritical]
		public void Dispose()
		{
			if (m_hashHandle != null)
			{
				m_hashHandle.Dispose();
			}
			if (m_cspHandle != null)
			{
				m_cspHandle.Dispose();
			}
		}

		[SecurityCritical]
		public void Initialize()
		{
			SafeCapiHashHandle phHash = null;
			if (!CapiNative.UnsafeNativeMethods.CryptCreateHash(m_cspHandle, m_algorithmId, SafeCapiKeyHandle.InvalidHandle, 0, out phHash))
			{
				int lastWin32Error = Marshal.GetLastWin32Error();
				if (lastWin32Error == -2146893816)
				{
					throw new PlatformNotSupportedException(SR.GetString("Cryptography_PlatformNotSupported"));
				}
				throw new CryptographicException(lastWin32Error);
			}
			if (m_hashHandle != null)
			{
				m_hashHandle.Dispose();
			}
			m_hashHandle = phHash;
		}

		[SecurityCritical]
		public void HashCore(byte[] array, int ibStart, int cbSize)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			if (ibStart < 0 || ibStart > array.Length - cbSize)
			{
				throw new ArgumentOutOfRangeException("ibStart");
			}
			if (cbSize < 0 || cbSize > array.Length)
			{
				throw new ArgumentOutOfRangeException("cbSize");
			}
			byte[] array2 = new byte[cbSize];
			Buffer.BlockCopy(array, ibStart, array2, 0, cbSize);
			if (!CapiNative.UnsafeNativeMethods.CryptHashData(m_hashHandle, array2, cbSize, 0))
			{
				throw new CryptographicException(Marshal.GetLastWin32Error());
			}
		}

		[SecurityCritical]
		public byte[] HashFinal()
		{
			return CapiNative.GetHashParameter(m_hashHandle, CapiNative.HashParameter.HashValue);
		}
	}
	internal static class CapiNative
	{
		internal enum AlgorithmClass
		{
			DataEncryption = 24576,
			Hash = 32768
		}

		internal enum AlgorithmType
		{
			Any = 0,
			Block = 1536
		}

		internal enum AlgorithmSubId
		{
			MD5 = 3,
			Sha1 = 4,
			Sha256 = 12,
			Sha384 = 13,
			Sha512 = 14,
			Aes128 = 14,
			Aes192 = 15,
			Aes256 = 16
		}

		internal enum AlgorithmId
		{
			None = 0,
			Aes128 = 26126,
			Aes192 = 26127,
			Aes256 = 26128,
			MD5 = 32771,
			Sha1 = 32772,
			Sha256 = 32780,
			Sha384 = 32781,
			Sha512 = 32782
		}

		[Flags]
		internal enum CryptAcquireContextFlags
		{
			None = 0,
			VerifyContext = -268435456
		}

		internal enum ErrorCode
		{
			Success = 0,
			MoreData = 234,
			NoMoreItems = 259,
			BadData = -2146893819,
			BadAlgorithmId = -2146893816,
			ProviderTypeNotDefined = -2146893801,
			KeysetNotDefined = -2146893799
		}

		internal enum HashParameter
		{
			None = 0,
			AlgorithmId = 1,
			HashValue = 2,
			HashSize = 4
		}

		internal enum KeyBlobType : byte
		{
			PlainText = 8
		}

		[Flags]
		internal enum KeyFlags
		{
			None = 0,
			Exportable = 1
		}

		internal enum KeyParameter
		{
			None = 0,
			IV = 1,
			Mode = 4,
			ModeBits = 5
		}

		internal static class ProviderNames
		{
			public const string MicrosoftEnhancedRsaAes = "Microsoft Enhanced RSA and AES Cryptographic Provider";

			public const string MicrosoftEnhancedRsaAesPrototype = "Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)";
		}

		internal enum ProviderParameter
		{
			None,
			EnumerateAlgorithms
		}

		[Flags]
		internal enum ProviderParameterFlags
		{
			None = 0,
			RestartEnumeration = 1
		}

		internal enum ProviderType
		{
			None = 0,
			RsaAes = 24
		}

		internal struct BLOBHEADER
		{
			public KeyBlobType bType;

			public byte bVersion;

			public short reserved;

			public AlgorithmId aiKeyAlg;
		}

		internal struct CRYPTOAPI_BLOB
		{
			public int cbData;

			public IntPtr pbData;
		}

		internal struct PROV_ENUMALGS
		{
			public AlgorithmId aiAlgId;

			public int dwBitLen;

			public int dwNameLen;

			public unsafe fixed byte szName[20];
		}

		[SecurityCritical(SecurityCriticalScope.Everything)]
		[SuppressUnmanagedCodeSecurity]
		internal static class UnsafeNativeMethods
		{
			[DllImport("mscorwks")]
			public static extern int _AxlPublicKeyBlobToPublicKeyToken(ref CRYPTOAPI_BLOB pCspPublicKeyBlob, out SafeAxlBufferHandle ppwszPublicKeyToken);

			[DllImport("advapi32", CharSet = CharSet.Unicode, SetLastError = true)]
			[return: MarshalAs(UnmanagedType.Bool)]
			public static extern bool CryptAcquireContext(out SafeCspHandle phProv, string pszContainer, string pszProvider, ProviderType dwProvType, CryptAcquireContextFlags dwFlags);

			[DllImport("advapi32", SetLastError = true)]
			[return: MarshalAs(UnmanagedType.Bool)]
			public static extern bool CryptCreateHash(SafeCspHandle hProv, AlgorithmId Algid, SafeCapiKeyHandle hKey, int dwFlags, out SafeCapiHashHandle phHash);

			[DllImport("advapi32", SetLastError = true)]
			[return: MarshalAs(UnmanagedType.Bool)]
			public static extern bool CryptDecrypt(SafeCapiKeyHandle hKey, SafeCapiHashHandle hHash, [MarshalAs(UnmanagedType.Bool)] bool Final, int dwFlags, IntPtr pbData, [In][Out] ref int pdwDataLen);

			[DllImport("advapi32")]
			[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
			[SuppressUnmanagedCodeSecurity]
			[return: MarshalAs(UnmanagedType.Bool)]
			public static extern bool CryptDuplicateKey(SafeCapiKeyHandle hKey, IntPtr pdwReserved, int dwFlags, out SafeCapiKeyHandle phKey);

			[DllImport("advapi32", SetLastError = true)]
			[return: MarshalAs(UnmanagedType.Bool)]
			public static extern bool CryptEncrypt(SafeCapiKeyHandle hKey, SafeCapiHashHandle hHash, [MarshalAs(UnmanagedType.Bool)] bool Final, int dwFlags, IntPtr pbData, [In][Out] ref int pdwDataLen, int dwBufLen);

			[DllImport("advapi32", SetLastError = true)]
			[return: MarshalAs(UnmanagedType.Bool)]
			public static extern bool CryptExportKey(SafeCapiKeyHandle hKey, SafeCapiKeyHandle hExpKey, int dwBlobType, int dwExportFlags, [Out][MarshalAs(UnmanagedType.LPArray)] byte[] pbData, [In][Out] ref int pdwDataLen);

			[DllImport("advapi32", SetLastError = true)]
			[return: MarshalAs(UnmanagedType.Bool)]
			public static extern bool CryptGenKey(SafeCspHandle hProv, AlgorithmId Algid, KeyFlags dwFlags, out SafeCapiKeyHandle phKey);

			[DllImport("advapi32", SetLastError = true)]
			[return: MarshalAs(UnmanagedType.Bool)]
			public static extern bool CryptGenRandom(SafeCspHandle hProv, int dwLen, [Out][MarshalAs(UnmanagedType.LPArray)] byte[] pbBuffer);

			[DllImport("advapi32", SetLastError = true)]
			[return: MarshalAs(UnmanagedType.Bool)]
			public static extern bool CryptGetHashParam(SafeCapiHashHandle hHash, HashParameter dwParam, [Out][MarshalAs(UnmanagedType.LPArray)] byte[] pbData, [In][Out] ref int pdwDataLen, int dwFlags);

			[DllImport("advapi32", SetLastError = true)]
			[return: MarshalAs(UnmanagedType.Bool)]
			public static extern bool CryptGetProvParam(SafeCspHandle hProv, ProviderParameter dwParam, IntPtr pbData, [In][Out] ref int pdwDataLen, ProviderParameterFlags dwFlags);

			[DllImport("advapi32", SetLastError = true)]
			[return: MarshalAs(UnmanagedType.Bool)]
			public static extern bool CryptHashData(SafeCapiHashHandle hHash, [MarshalAs(UnmanagedType.LPArray)] byte[] pbData, int dwDataLen, int dwFlags);

			[DllImport("advapi32", SetLastError = true)]
			[return: MarshalAs(UnmanagedType.Bool)]
			public static extern bool CryptImportKey(SafeCspHandle hProv, [MarshalAs(UnmanagedType.LPArray)] byte[] pbData, int dwDataLen, SafeCapiKeyHandle hPubKey, KeyFlags dwFlags, out SafeCapiKeyHandle phKey);

			[DllImport("advapi32", SetLastError = true)]
			[return: MarshalAs(UnmanagedType.Bool)]
			public static extern bool CryptSetKeyParam(SafeCapiKeyHandle hKey, KeyParameter dwParam, [MarshalAs(UnmanagedType.LPArray)] byte[] pbData, int dwFlags);
		}

		[SecurityCritical]
		internal static SafeCspHandle AcquireCsp(string keyContainer, string providerName, ProviderType providerType, CryptAcquireContextFlags flags, bool throwPlatformException)
		{
			SafeCspHandle phProv = null;
			if (!UnsafeNativeMethods.CryptAcquireContext(out phProv, keyContainer, providerName, providerType, flags))
			{
				int lastWin32Error = Marshal.GetLastWin32Error();
				if (throwPlatformException && (lastWin32Error == -2146893801 || lastWin32Error == -2146893799))
				{
					throw new PlatformNotSupportedException(SR.GetString("Cryptography_PlatformNotSupported"));
				}
				throw new CryptographicException(lastWin32Error);
			}
			return phProv;
		}

		[SecurityCritical]
		internal static byte[] ExportSymmetricKey(SafeCapiKeyHandle key)
		{
			Contract.Requires(key != null);
			int pdwDataLen = 0;
			if (!UnsafeNativeMethods.CryptExportKey(key, SafeCapiKeyHandle.InvalidHandle, 8, 0, null, ref pdwDataLen))
			{
				int lastWin32Error = Marshal.GetLastWin32Error();
				if (lastWin32Error != 234)
				{
					throw new CryptographicException(lastWin32Error);
				}
			}
			byte[] array = new byte[pdwDataLen];
			if (!UnsafeNativeMethods.CryptExportKey(key, SafeCapiKeyHandle.InvalidHandle, 8, 0, array, ref pdwDataLen))
			{
				throw new CryptographicException(Marshal.GetLastWin32Error());
			}
			int srcOffset = Marshal.SizeOf(typeof(BLOBHEADER)) + Marshal.SizeOf(typeof(int));
			int num = BitConverter.ToInt32(array, Marshal.SizeOf(typeof(BLOBHEADER)));
			byte[] array2 = new byte[num];
			Buffer.BlockCopy(array, srcOffset, array2, 0, array2.Length);
			return array2;
		}

		internal static string GetAlgorithmName(AlgorithmId algorithm)
		{
			return algorithm.ToString().ToUpper(CultureInfo.InvariantCulture);
		}

		[SecurityCritical]
		internal static byte[] GetHashParameter(SafeCapiHashHandle hashHandle, HashParameter parameter)
		{
			Contract.Requires(hashHandle != null);
			Contract.Requires(HashParameter.AlgorithmId <= parameter && parameter <= HashParameter.HashSize);
			int pdwDataLen = 0;
			if (!UnsafeNativeMethods.CryptGetHashParam(hashHandle, parameter, null, ref pdwDataLen, 0))
			{
				throw new CryptographicException(Marshal.GetLastWin32Error());
			}
			byte[] array = new byte[pdwDataLen];
			if (!UnsafeNativeMethods.CryptGetHashParam(hashHandle, parameter, array, ref pdwDataLen, 0))
			{
				throw new CryptographicException(Marshal.GetLastWin32Error());
			}
			if (pdwDataLen != array.Length)
			{
				byte[] array2 = new byte[pdwDataLen];
				Buffer.BlockCopy(array, 0, array2, 0, pdwDataLen);
				array = array2;
			}
			return array;
		}

		[SecurityCritical]
		internal static T GetProviderParameterStruct<T>(SafeCspHandle provider, ProviderParameter parameter, ProviderParameterFlags flags) where T : struct
		{
			Contract.Requires(provider != null);
			Contract.Requires(parameter == ProviderParameter.EnumerateAlgorithms);
			int pdwDataLen = 0;
			IntPtr intPtr = IntPtr.Zero;
			if (!UnsafeNativeMethods.CryptGetProvParam(provider, parameter, intPtr, ref pdwDataLen, flags))
			{
				int lastWin32Error = Marshal.GetLastWin32Error();
				switch (lastWin32Error)
				{
				case 259:
					return default(T);
				default:
					throw new CryptographicException(lastWin32Error);
				case 234:
					break;
				}
			}
			RuntimeHelpers.PrepareConstrainedRegions();
			try
			{
				RuntimeHelpers.PrepareConstrainedRegions();
				try
				{
				}
				finally
				{
					intPtr = Marshal.AllocCoTaskMem(pdwDataLen);
				}
				if (!UnsafeNativeMethods.CryptGetProvParam(provider, parameter, intPtr, ref pdwDataLen, flags))
				{
					throw new CryptographicException(Marshal.GetLastWin32Error());
				}
				return (T)Marshal.PtrToStructure(intPtr, typeof(T));
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeCoTaskMem(intPtr);
				}
			}
		}

		internal static int HResultForVerificationResult(SignatureVerificationResult verificationResult)
		{
			switch (verificationResult)
			{
			case SignatureVerificationResult.AssemblyIdentityMismatch:
			case SignatureVerificationResult.PublicKeyTokenMismatch:
			case SignatureVerificationResult.PublisherMismatch:
				return -2146762749;
			case SignatureVerificationResult.ContainingSignatureInvalid:
				return -2146869232;
			default:
				return (int)verificationResult;
			}
		}

		[SecurityCritical]
		internal unsafe static SafeCapiKeyHandle ImportSymmetricKey(SafeCspHandle provider, AlgorithmId algorithm, byte[] key)
		{
			Contract.Requires(provider != null);
			Contract.Requires((algorithm & (AlgorithmId)24576) == (AlgorithmId)24576);
			Contract.Requires(key != null);
			int num = Marshal.SizeOf(typeof(BLOBHEADER)) + Marshal.SizeOf(typeof(int)) + key.Length;
			byte[] array = new byte[num];
			fixed (byte* ptr = array)
			{
				BLOBHEADER* ptr2 = (BLOBHEADER*)ptr;
				ptr2->bType = KeyBlobType.PlainText;
				ptr2->bVersion = 2;
				ptr2->reserved = 0;
				ptr2->aiKeyAlg = algorithm;
				int* ptr3 = (int*)(ptr + Marshal.SizeOf(*ptr2));
				*ptr3 = key.Length;
			}
			Buffer.BlockCopy(key, 0, array, Marshal.SizeOf(typeof(BLOBHEADER)) + Marshal.SizeOf(typeof(int)), key.Length);
			SafeCapiKeyHandle phKey = null;
			RuntimeHelpers.PrepareConstrainedRegions();
			try
			{
				if (!UnsafeNativeMethods.CryptImportKey(provider, array, array.Length, SafeCapiKeyHandle.InvalidHandle, KeyFlags.Exportable, out phKey))
				{
					throw new CryptographicException(Marshal.GetLastWin32Error());
				}
			}
			finally
			{
				if (phKey != null && !phKey.IsInvalid)
				{
					phKey.SetCsp(provider);
				}
			}
			return phKey;
		}

		[SecurityCritical]
		internal static void SetKeyParameter(SafeCapiKeyHandle key, KeyParameter parameter, int value)
		{
			Contract.Requires(key != null);
			Contract.Requires(parameter == KeyParameter.Mode || parameter == KeyParameter.ModeBits);
			SetKeyParameter(key, parameter, BitConverter.GetBytes(value));
		}

		[SecurityCritical]
		internal static void SetKeyParameter(SafeCapiKeyHandle key, KeyParameter parameter, byte[] value)
		{
			Contract.Requires(key != null && !key.IsInvalid && !key.IsClosed);
			Contract.Requires(value != null);
			if (!UnsafeNativeMethods.CryptSetKeyParam(key, parameter, value, 0))
			{
				throw new CryptographicException(Marshal.GetLastWin32Error());
			}
		}
	}
	internal enum EncryptionMode
	{
		Encrypt,
		Decrypt
	}
	internal sealed class CapiSymmetricAlgorithm : ICryptoTransform, IDisposable
	{
		private int m_blockSize;

		private byte[] m_depadBuffer;

		private EncryptionMode m_encryptionMode;

		private SafeCapiKeyHandle m_key;

		private PaddingMode m_paddingMode;

		private SafeCspHandle m_provider;

		public bool CanReuseTransform => true;

		public bool CanTransformMultipleBlocks => true;

		public int InputBlockSize
		{
			[Pure]
			get
			{
				return m_blockSize / 8;
			}
		}

		public int OutputBlockSize => m_blockSize / 8;

		[SecurityCritical]
		public CapiSymmetricAlgorithm(int blockSize, int feedbackSize, SafeCspHandle provider, SafeCapiKeyHandle key, byte[] iv, CipherMode cipherMode, PaddingMode paddingMode, EncryptionMode encryptionMode)
		{
			Contract.Requires(0 < blockSize && blockSize % 8 == 0);
			Contract.Requires(0 <= feedbackSize);
			Contract.Requires(provider != null && !provider.IsInvalid && !provider.IsClosed);
			Contract.Requires(key != null && !key.IsInvalid && !key.IsClosed);
			m_blockSize = blockSize;
			m_encryptionMode = encryptionMode;
			m_paddingMode = paddingMode;
			m_provider = provider.Duplicate();
			m_key = SetupKey(key, ProcessIV(iv, blockSize, cipherMode), cipherMode, feedbackSize);
		}

		[SecurityCritical]
		public void Dispose()
		{
			if (m_key != null)
			{
				m_key.Dispose();
			}
			if (m_provider != null)
			{
				m_provider.Dispose();
			}
			if (m_depadBuffer != null)
			{
				Array.Clear(m_depadBuffer, 0, m_depadBuffer.Length);
			}
		}

		[SecurityCritical]
		private int DecryptBlocks(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset)
		{
			Contract.Requires(m_key != null);
			Contract.Requires(inputBuffer != null && inputCount <= inputBuffer.Length - inputOffset);
			Contract.Requires(inputOffset >= 0);
			Contract.Requires(inputCount > 0 && inputCount % InputBlockSize == 0);
			Contract.Requires(outputBuffer != null && inputCount <= outputBuffer.Length - outputOffset);
			Contract.Requires(inputOffset >= 0);
			Contract.Requires(m_depadBuffer == null || (m_paddingMode != PaddingMode.None && m_paddingMode != PaddingMode.Zeros));
			int num = 0;
			if (m_paddingMode != PaddingMode.None && m_paddingMode != PaddingMode.Zeros)
			{
				if (m_depadBuffer != null)
				{
					int num2 = RawDecryptBlocks(m_depadBuffer, 0, m_depadBuffer.Length);
					Buffer.BlockCopy(m_depadBuffer, 0, outputBuffer, outputOffset, num2);
					Array.Clear(m_depadBuffer, 0, m_depadBuffer.Length);
					outputOffset += num2;
					num += num2;
				}
				else
				{
					m_depadBuffer = new byte[InputBlockSize];
				}
				Buffer.BlockCopy(inputBuffer, inputOffset + inputCount - m_depadBuffer.Length, m_depadBuffer, 0, m_depadBuffer.Length);
				inputCount -= m_depadBuffer.Length;
			}
			if (inputCount > 0)
			{
				Buffer.BlockCopy(inputBuffer, inputOffset, outputBuffer, outputOffset, inputCount);
				num += RawDecryptBlocks(outputBuffer, outputOffset, inputCount);
			}
			return num;
		}

		private byte[] DepadBlock(byte[] block, int offset, int count)
		{
			Contract.Requires(block != null && count >= block.Length - offset);
			Contract.Requires(0 <= offset);
			Contract.Requires(0 <= count);
			int num = 0;
			switch (m_paddingMode)
			{
			case PaddingMode.ANSIX923:
			{
				num = block[offset + count - 1];
				if (num <= 0 || num > InputBlockSize)
				{
					throw new CryptographicException(SR.GetString("Cryptography_InvalidPadding"));
				}
				for (int j = offset + count - num; j < offset + count - 1; j++)
				{
					if (block[j] != 0)
					{
						throw new CryptographicException(SR.GetString("Cryptography_InvalidPadding"));
					}
				}
				break;
			}
			case PaddingMode.ISO10126:
				num = block[offset + count - 1];
				if (num <= 0 || num > InputBlockSize)
				{
					throw new CryptographicException(SR.GetString("Cryptography_InvalidPadding"));
				}
				break;
			case PaddingMode.PKCS7:
			{
				num = block[offset + count - 1];
				if (num <= 0 || num > InputBlockSize)
				{
					throw new CryptographicException(SR.GetString("Cryptography_InvalidPadding"));
				}
				for (int i = offset + count - num; i < offset + count; i++)
				{
					if (block[i] != num)
					{
						throw new CryptographicException(SR.GetString("Cryptography_InvalidPadding"));
					}
				}
				break;
			}
			case PaddingMode.None:
			case PaddingMode.Zeros:
				num = 0;
				break;
			default:
				throw new CryptographicException(SR.GetString("Cryptography_UnknownPaddingMode"));
			}
			byte[] array = new byte[count - num];
			Buffer.BlockCopy(block, offset, array, 0, array.Length);
			return array;
		}

		[SecurityCritical]
		private unsafe int EncryptBlocks(byte[] buffer, int offset, int count)
		{
			Contract.Requires(m_key != null);
			Contract.Requires(buffer != null && count <= buffer.Length - offset);
			Contract.Requires(offset >= 0);
			Contract.Requires(count > 0 && count % InputBlockSize == 0);
			int pdwDataLen = count;
			fixed (byte* value = &buffer[offset])
			{
				if (!CapiNative.UnsafeNativeMethods.CryptEncrypt(m_key, SafeCapiHashHandle.InvalidHandle, Final: false, 0, new IntPtr(value), ref pdwDataLen, buffer.Length - offset))
				{
					throw new CryptographicException(Marshal.GetLastWin32Error());
				}
			}
			return pdwDataLen;
		}

		[SecurityCritical]
		private byte[] PadBlock(byte[] block, int offset, int count)
		{
			Contract.Requires(m_provider != null);
			Contract.Requires(block != null && count <= block.Length - offset);
			Contract.Requires(0 <= offset);
			Contract.Requires(0 <= count);
			byte[] array = null;
			int num = InputBlockSize - count % InputBlockSize;
			switch (m_paddingMode)
			{
			case PaddingMode.ANSIX923:
				array = new byte[count + num];
				Buffer.BlockCopy(block, 0, array, 0, count);
				array[array.Length - 1] = (byte)num;
				break;
			case PaddingMode.ISO10126:
				array = new byte[count + num];
				CapiNative.UnsafeNativeMethods.CryptGenRandom(m_provider, array.Length - 1, array);
				Buffer.BlockCopy(block, 0, array, 0, count);
				array[array.Length - 1] = (byte)num;
				break;
			case PaddingMode.None:
				if (count % InputBlockSize != 0)
				{
					throw new CryptographicException(SR.GetString("Cryptography_PartialBlock"));
				}
				array = new byte[count];
				Buffer.BlockCopy(block, offset, array, 0, array.Length);
				break;
			case PaddingMode.PKCS7:
			{
				array = new byte[count + num];
				Buffer.BlockCopy(block, offset, array, 0, count);
				for (int i = count; i < array.Length; i++)
				{
					array[i] = (byte)num;
				}
				break;
			}
			case PaddingMode.Zeros:
				if (num == InputBlockSize)
				{
					num = 0;
				}
				array = new byte[count + num];
				Buffer.BlockCopy(block, offset, array, 0, count);
				break;
			default:
				throw new CryptographicException(SR.GetString("Cryptography_UnknownPaddingMode"));
			}
			return array;
		}

		private static byte[] ProcessIV(byte[] iv, int blockSize, CipherMode cipherMode)
		{
			Contract.Requires(blockSize % 8 == 0);
			byte[] array = null;
			if (iv != null)
			{
				if (blockSize / 8 > iv.Length)
				{
					throw new CryptographicException(SR.GetString("Cryptography_InvalidIVSize"));
				}
				array = new byte[blockSize / 8];
				Buffer.BlockCopy(iv, 0, array, 0, array.Length);
			}
			else if (cipherMode != CipherMode.ECB)
			{
				throw new CryptographicException(SR.GetString("Cryptography_MissingIV"));
			}
			return array;
		}

		[SecurityCritical]
		private unsafe int RawDecryptBlocks(byte[] buffer, int offset, int count)
		{
			Contract.Requires(m_key != null);
			Contract.Requires(buffer != null && count <= buffer.Length - offset);
			Contract.Requires(offset >= 0);
			Contract.Requires(count > 0 && count % InputBlockSize == 0);
			int pdwDataLen = count;
			fixed (byte* value = &buffer[offset])
			{
				if (!CapiNative.UnsafeNativeMethods.CryptDecrypt(m_key, SafeCapiHashHandle.InvalidHandle, Final: false, 0, new IntPtr(value), ref pdwDataLen))
				{
					throw new CryptographicException(Marshal.GetLastWin32Error());
				}
			}
			return pdwDataLen;
		}

		[SecurityCritical]
		private unsafe void Reset()
		{
			Contract.Requires(m_key != null);
			byte[] array = new byte[OutputBlockSize];
			int pdwDataLen = 0;
			fixed (byte* value = array)
			{
				if (m_encryptionMode == EncryptionMode.Encrypt)
				{
					CapiNative.UnsafeNativeMethods.CryptEncrypt(m_key, SafeCapiHashHandle.InvalidHandle, Final: true, 0, new IntPtr(value), ref pdwDataLen, array.Length);
				}
				else
				{
					CapiNative.UnsafeNativeMethods.CryptDecrypt(m_key, SafeCapiHashHandle.InvalidHandle, Final: true, 0, new IntPtr(value), ref pdwDataLen);
				}
			}
			if (m_depadBuffer != null)
			{
				Array.Clear(m_depadBuffer, 0, m_depadBuffer.Length);
				m_depadBuffer = null;
			}
		}

		[SecurityCritical]
		public int TransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset)
		{
			if (inputBuffer == null)
			{
				throw new ArgumentNullException("inputBuffer");
			}
			if (inputOffset < 0)
			{
				throw new ArgumentOutOfRangeException("inputOffset");
			}
			if (inputCount <= 0)
			{
				throw new ArgumentOutOfRangeException("inputCount");
			}
			if (inputCount % InputBlockSize != 0)
			{
				throw new ArgumentOutOfRangeException("inputCount", SR.GetString("Cryptography_MustTransformWholeBlock"));
			}
			if (inputCount > inputBuffer.Length - inputOffset)
			{
				throw new ArgumentOutOfRangeException("inputCount", SR.GetString("Cryptography_TransformBeyondEndOfBuffer"));
			}
			if (outputBuffer == null)
			{
				throw new ArgumentNullException("outputBuffer");
			}
			if (inputCount > outputBuffer.Length - outputOffset)
			{
				throw new ArgumentOutOfRangeException("outputOffset", SR.GetString("Cryptography_TransformBeyondEndOfBuffer"));
			}
			if (m_encryptionMode == EncryptionMode.Encrypt)
			{
				Buffer.BlockCopy(inputBuffer, inputOffset, outputBuffer, outputOffset, inputCount);
				return EncryptBlocks(outputBuffer, outputOffset, inputCount);
			}
			return DecryptBlocks(inputBuffer, inputOffset, inputCount, outputBuffer, outputOffset);
		}

		[SecurityCritical]
		public byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount)
		{
			if (inputBuffer == null)
			{
				throw new ArgumentNullException("inputBuffer");
			}
			if (inputOffset < 0)
			{
				throw new ArgumentOutOfRangeException("inputOffset");
			}
			if (inputCount < 0)
			{
				throw new ArgumentOutOfRangeException("inputCount");
			}
			if (inputCount > inputBuffer.Length - inputOffset)
			{
				throw new ArgumentOutOfRangeException("inputCount", SR.GetString("Cryptography_TransformBeyondEndOfBuffer"));
			}
			byte[] array = null;
			if (m_encryptionMode == EncryptionMode.Encrypt)
			{
				array = PadBlock(inputBuffer, inputOffset, inputCount);
				if (array.Length > 0)
				{
					EncryptBlocks(array, 0, array.Length);
				}
			}
			else
			{
				if (inputCount % InputBlockSize != 0)
				{
					throw new CryptographicException(SR.GetString("Cryptography_PartialBlock"));
				}
				byte[] array2 = null;
				if (m_depadBuffer == null)
				{
					array2 = new byte[inputCount];
					Buffer.BlockCopy(inputBuffer, inputOffset, array2, 0, inputCount);
				}
				else
				{
					array2 = new byte[m_depadBuffer.Length + inputCount];
					Buffer.BlockCopy(m_depadBuffer, 0, array2, 0, m_depadBuffer.Length);
					Buffer.BlockCopy(inputBuffer, inputOffset, array2, m_depadBuffer.Length, inputCount);
				}
				if (array2.Length > 0)
				{
					int count = RawDecryptBlocks(array2, 0, array2.Length);
					array = DepadBlock(array2, 0, count);
				}
				else
				{
					array = new byte[0];
				}
			}
			Reset();
			return array;
		}

		[SecurityCritical]
		private static SafeCapiKeyHandle SetupKey(SafeCapiKeyHandle key, byte[] iv, CipherMode cipherMode, int feedbackSize)
		{
			Contract.Requires(key != null);
			Contract.Requires(cipherMode == CipherMode.ECB || iv != null);
			Contract.Requires(0 <= feedbackSize);
			SafeCapiKeyHandle safeCapiKeyHandle = key.Duplicate();
			CapiNative.SetKeyParameter(safeCapiKeyHandle, CapiNative.KeyParameter.Mode, (int)cipherMode);
			if (cipherMode != CipherMode.ECB)
			{
				CapiNative.SetKeyParameter(safeCapiKeyHandle, CapiNative.KeyParameter.IV, iv);
			}
			if (cipherMode == CipherMode.CFB || cipherMode == CipherMode.OFB)
			{
				CapiNative.SetKeyParameter(safeCapiKeyHandle, CapiNative.KeyParameter.ModeBits, feedbackSize);
			}
			return safeCapiKeyHandle;
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public abstract class ECDiffieHellman : AsymmetricAlgorithm
	{
		public override string KeyExchangeAlgorithm => "ECDiffieHellman";

		public override string SignatureAlgorithm => null;

		public abstract ECDiffieHellmanPublicKey PublicKey { get; }

		public new static ECDiffieHellman Create()
		{
			return Create(typeof(ECDiffieHellmanCng).FullName);
		}

		public new static ECDiffieHellman Create(string algorithm)
		{
			if (algorithm == null)
			{
				throw new ArgumentNullException("algorithm");
			}
			return CoreCryptoConfig.CreateFromName<ECDiffieHellman>(algorithm);
		}

		public abstract byte[] DeriveKeyMaterial(ECDiffieHellmanPublicKey otherPartyPublicKey);
	}
	[Serializable]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public abstract class ECDiffieHellmanPublicKey : IDisposable
	{
		private byte[] m_keyBlob;

		protected ECDiffieHellmanPublicKey(byte[] keyBlob)
		{
			if (keyBlob == null)
			{
				throw new ArgumentNullException("keyBlob");
			}
			m_keyBlob = keyBlob.Clone() as byte[];
		}

		public void Dispose()
		{
			Dispose(disposing: true);
		}

		protected virtual void Dispose(bool disposing)
		{
		}

		public virtual byte[] ToByteArray()
		{
			return m_keyBlob.Clone() as byte[];
		}

		public abstract string ToXmlString();
	}
	public enum ECDiffieHellmanKeyDerivationFunction
	{
		Hash,
		Hmac,
		Tls
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class ECDiffieHellmanCng : ECDiffieHellman
	{
		private static KeySizes[] s_legalKeySizes = new KeySizes[2]
		{
			new KeySizes(256, 384, 128),
			new KeySizes(521, 521, 0)
		};

		private CngAlgorithm m_hashAlgorithm = CngAlgorithm.Sha256;

		private byte[] m_hmacKey;

		private CngKey m_key;

		private ECDiffieHellmanKeyDerivationFunction m_kdf;

		private byte[] m_label;

		private byte[] m_secretAppend;

		private byte[] m_secretPrepend;

		private byte[] m_seed;

		public CngAlgorithm HashAlgorithm
		{
			get
			{
				return m_hashAlgorithm;
			}
			set
			{
				if (m_hashAlgorithm == null)
				{
					throw new ArgumentNullException("value");
				}
				m_hashAlgorithm = value;
			}
		}

		public byte[] HmacKey
		{
			get
			{
				return m_hmacKey;
			}
			set
			{
				m_hmacKey = value;
			}
		}

		public ECDiffieHellmanKeyDerivationFunction KeyDerivationFunction
		{
			get
			{
				return m_kdf;
			}
			set
			{
				if (value < ECDiffieHellmanKeyDerivationFunction.Hash || value > ECDiffieHellmanKeyDerivationFunction.Tls)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				m_kdf = value;
			}
		}

		public byte[] Label
		{
			get
			{
				return m_label;
			}
			set
			{
				m_label = value;
			}
		}

		public byte[] SecretAppend
		{
			get
			{
				return m_secretAppend;
			}
			set
			{
				m_secretAppend = value;
			}
		}

		public byte[] SecretPrepend
		{
			get
			{
				return m_secretPrepend;
			}
			set
			{
				m_secretPrepend = value;
			}
		}

		public byte[] Seed
		{
			get
			{
				return m_seed;
			}
			set
			{
				m_seed = value;
			}
		}

		public CngKey Key
		{
			get
			{
				if (m_key != null && m_key.KeySize != KeySize)
				{
					m_key.Dispose();
					m_key = null;
				}
				if (m_key == null)
				{
					CngAlgorithm algorithm = null;
					switch (KeySize)
					{
					case 256:
						algorithm = CngAlgorithm.ECDiffieHellmanP256;
						break;
					case 384:
						algorithm = CngAlgorithm.ECDiffieHellmanP384;
						break;
					case 521:
						algorithm = CngAlgorithm.ECDiffieHellmanP521;
						break;
					}
					m_key = CngKey.Create(algorithm);
				}
				return m_key;
			}
			private set
			{
				Contract.Requires(value != null);
				if (value.AlgorithmGroup != CngAlgorithmGroup.ECDiffieHellman)
				{
					throw new ArgumentException(SR.GetString("Cryptography_ArgECDHRequiresECDHKey"));
				}
				if (m_key != null)
				{
					m_key.Dispose();
				}
				m_key = value;
				KeySize = m_key.KeySize;
			}
		}

		public override ECDiffieHellmanPublicKey PublicKey
		{
			[SecurityCritical]
			get
			{
				return new ECDiffieHellmanCngPublicKey(Key);
			}
		}

		public bool UseSecretAgreementAsHmacKey => HmacKey == null;

		public ECDiffieHellmanCng()
			: this(521)
		{
		}

		[SecurityCritical]
		public ECDiffieHellmanCng(int keySize)
		{
			if (!NCryptNative.NCryptSupported)
			{
				throw new PlatformNotSupportedException(SR.GetString("Cryptography_PlatformNotSupported"));
			}
			LegalKeySizesValue = s_legalKeySizes;
			KeySize = keySize;
		}

		[SecurityCritical]
		public ECDiffieHellmanCng(CngKey key)
		{
			if (key == null)
			{
				throw new ArgumentNullException("key");
			}
			if (key.AlgorithmGroup != CngAlgorithmGroup.ECDiffieHellman)
			{
				throw new ArgumentException(SR.GetString("Cryptography_ArgECDHRequiresECDHKey"), "key");
			}
			if (!NCryptNative.NCryptSupported)
			{
				throw new PlatformNotSupportedException(SR.GetString("Cryptography_PlatformNotSupported"));
			}
			LegalKeySizesValue = s_legalKeySizes;
			new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Assert();
			Key = CngKey.Open(key.Handle, key.IsEphemeral ? CngKeyHandleOpenOptions.EphemeralKey : CngKeyHandleOpenOptions.None);
			CodeAccessPermission.RevertAssert();
			KeySize = m_key.KeySize;
		}

		public override byte[] DeriveKeyMaterial(ECDiffieHellmanPublicKey otherPartyPublicKey)
		{
			if (otherPartyPublicKey == null)
			{
				throw new ArgumentNullException("otherPartyPublicKey");
			}
			ECDiffieHellmanCngPublicKey eCDiffieHellmanCngPublicKey = otherPartyPublicKey as ECDiffieHellmanCngPublicKey;
			if (otherPartyPublicKey == null)
			{
				throw new ArgumentException(SR.GetString("Cryptography_ArgExpectedECDiffieHellmanCngPublicKey"));
			}
			using CngKey otherPartyPublicKey2 = eCDiffieHellmanCngPublicKey.Import();
			return DeriveKeyMaterial(otherPartyPublicKey2);
		}

		[SecurityCritical]
		public byte[] DeriveKeyMaterial(CngKey otherPartyPublicKey)
		{
			if (otherPartyPublicKey == null)
			{
				throw new ArgumentNullException("otherPartyPublicKey");
			}
			if (otherPartyPublicKey.AlgorithmGroup != CngAlgorithmGroup.ECDiffieHellman)
			{
				throw new ArgumentException(SR.GetString("Cryptography_ArgECDHRequiresECDHKey"), "otherPartyPublicKey");
			}
			if (otherPartyPublicKey.KeySize != KeySize)
			{
				throw new ArgumentException(SR.GetString("Cryptography_ArgECDHKeySizeMismatch"), "otherPartyPublicKey");
			}
			NCryptNative.SecretAgreementFlags flags = (UseSecretAgreementAsHmacKey ? NCryptNative.SecretAgreementFlags.UseSecretAsHmacKey : NCryptNative.SecretAgreementFlags.None);
			new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Assert();
			SafeNCryptKeyHandle handle = Key.Handle;
			SafeNCryptKeyHandle handle2 = otherPartyPublicKey.Handle;
			CodeAccessPermission.RevertAssert();
			using SafeNCryptSecretHandle secretAgreement = NCryptNative.DeriveSecretAgreement(handle, handle2);
			if (KeyDerivationFunction == ECDiffieHellmanKeyDerivationFunction.Hash)
			{
				byte[] secretAppend = ((SecretAppend == null) ? null : (SecretAppend.Clone() as byte[]));
				byte[] secretPrepend = ((SecretPrepend == null) ? null : (SecretPrepend.Clone() as byte[]));
				return NCryptNative.DeriveKeyMaterialHash(secretAgreement, HashAlgorithm.Algorithm, secretPrepend, secretAppend, flags);
			}
			if (KeyDerivationFunction == ECDiffieHellmanKeyDerivationFunction.Hmac)
			{
				byte[] hmacKey = ((HmacKey == null) ? null : (HmacKey.Clone() as byte[]));
				byte[] secretAppend2 = ((SecretAppend == null) ? null : (SecretAppend.Clone() as byte[]));
				byte[] secretPrepend2 = ((SecretPrepend == null) ? null : (SecretPrepend.Clone() as byte[]));
				return NCryptNative.DeriveKeyMaterialHmac(secretAgreement, HashAlgorithm.Algorithm, hmacKey, secretPrepend2, secretAppend2, flags);
			}
			byte[] array = ((Label == null) ? null : (Label.Clone() as byte[]));
			byte[] array2 = ((Seed == null) ? null : (Seed.Clone() as byte[]));
			if (array == null || array2 == null)
			{
				throw new InvalidOperationException(SR.GetString("Cryptography_TlsRequiresLabelAndSeed"));
			}
			return NCryptNative.DeriveKeyMaterialTls(secretAgreement, array, array2, flags);
		}

		public SafeNCryptSecretHandle DeriveSecretAgreementHandle(ECDiffieHellmanPublicKey otherPartyPublicKey)
		{
			if (otherPartyPublicKey == null)
			{
				throw new ArgumentNullException("otherPartyPublicKey");
			}
			ECDiffieHellmanCngPublicKey eCDiffieHellmanCngPublicKey = otherPartyPublicKey as ECDiffieHellmanCngPublicKey;
			if (otherPartyPublicKey == null)
			{
				throw new ArgumentException(SR.GetString("Cryptography_ArgExpectedECDiffieHellmanCngPublicKey"));
			}
			using CngKey otherPartyPublicKey2 = eCDiffieHellmanCngPublicKey.Import();
			return DeriveSecretAgreementHandle(otherPartyPublicKey2);
		}

		[SecurityCritical]
		[SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
		public SafeNCryptSecretHandle DeriveSecretAgreementHandle(CngKey otherPartyPublicKey)
		{
			if (otherPartyPublicKey == null)
			{
				throw new ArgumentNullException("otherPartyPublicKey");
			}
			if (otherPartyPublicKey.AlgorithmGroup != CngAlgorithmGroup.ECDiffieHellman)
			{
				throw new ArgumentException(SR.GetString("Cryptography_ArgECDHRequiresECDHKey"), "otherPartyPublicKey");
			}
			if (otherPartyPublicKey.KeySize != KeySize)
			{
				throw new ArgumentException(SR.GetString("Cryptography_ArgECDHKeySizeMismatch"), "otherPartyPublicKey");
			}
			return NCryptNative.DeriveSecretAgreement(Key.Handle, otherPartyPublicKey.Handle);
		}

		protected override void Dispose(bool disposing)
		{
			if (disposing && m_key != null)
			{
				m_key.Dispose();
			}
		}

		public override void FromXmlString(string xmlString)
		{
			throw new NotImplementedException(SR.GetString("Cryptography_ECXmlSerializationFormatRequired"));
		}

		public void FromXmlString(string xml, ECKeyXmlFormat format)
		{
			if (xml == null)
			{
				throw new ArgumentNullException("xml");
			}
			if (format != 0)
			{
				throw new ArgumentOutOfRangeException("format");
			}
			Key = Rfc4050KeyFormatter.FromXml(xml);
		}

		public override string ToXmlString(bool includePrivateParameters)
		{
			throw new NotImplementedException(SR.GetString("Cryptography_ECXmlSerializationFormatRequired"));
		}

		public string ToXmlString(ECKeyXmlFormat format)
		{
			if (format != 0)
			{
				throw new ArgumentOutOfRangeException("format");
			}
			return Rfc4050KeyFormatter.ToXml(Key);
		}
	}
	[Serializable]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class ECDiffieHellmanCngPublicKey : ECDiffieHellmanPublicKey
	{
		[NonSerialized]
		private CngKey m_key;

		private CngKeyBlobFormat m_format;

		public CngKeyBlobFormat BlobFormat => m_format;

		[SecurityCritical]
		internal ECDiffieHellmanCngPublicKey(CngKey key)
			: base(key.Export(CngKeyBlobFormat.EccPublicBlob))
		{
			Contract.Requires(key != null && key.AlgorithmGroup == CngAlgorithmGroup.ECDiffieHellman);
			m_format = CngKeyBlobFormat.EccPublicBlob;
			new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Assert();
			m_key = CngKey.Open(key.Handle, key.IsEphemeral ? CngKeyHandleOpenOptions.EphemeralKey : CngKeyHandleOpenOptions.None);
			CodeAccessPermission.RevertAssert();
		}

		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
			if (disposing && m_key != null)
			{
				m_key.Dispose();
			}
		}

		[SecurityCritical]
		public static ECDiffieHellmanPublicKey FromByteArray(byte[] publicKeyBlob, CngKeyBlobFormat format)
		{
			if (publicKeyBlob == null)
			{
				throw new ArgumentNullException("publicKeyBlob");
			}
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			using CngKey cngKey = CngKey.Import(publicKeyBlob, format);
			if (cngKey.AlgorithmGroup != CngAlgorithmGroup.ECDiffieHellman)
			{
				throw new ArgumentException(SR.GetString("Cryptography_ArgECDHRequiresECDHKey"));
			}
			return new ECDiffieHellmanCngPublicKey(cngKey);
		}

		[SecurityCritical]
		public static ECDiffieHellmanCngPublicKey FromXmlString(string xml)
		{
			if (xml == null)
			{
				throw new ArgumentNullException("xml");
			}
			using CngKey cngKey = Rfc4050KeyFormatter.FromXml(xml);
			if (cngKey.AlgorithmGroup != CngAlgorithmGroup.ECDiffieHellman)
			{
				throw new ArgumentException(SR.GetString("Cryptography_ArgECDHRequiresECDHKey"), "xml");
			}
			return new ECDiffieHellmanCngPublicKey(cngKey);
		}

		public CngKey Import()
		{
			return CngKey.Import(ToByteArray(), BlobFormat);
		}

		public override string ToXmlString()
		{
			if (m_key == null)
			{
				m_key = Import();
			}
			return Rfc4050KeyFormatter.ToXml(m_key);
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public abstract class ECDsa : AsymmetricAlgorithm
	{
		public override string KeyExchangeAlgorithm => null;

		public override string SignatureAlgorithm => "ECDsa";

		public new static ECDsa Create()
		{
			return Create(typeof(ECDsaCng).FullName);
		}

		public new static ECDsa Create(string algorithm)
		{
			if (algorithm == null)
			{
				throw new ArgumentNullException("algorithm");
			}
			return CoreCryptoConfig.CreateFromName<ECDsa>(algorithm);
		}

		public abstract byte[] SignHash(byte[] hash);

		public abstract bool VerifyHash(byte[] hash, byte[] signature);
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class ECDsaCng : ECDsa
	{
		private static KeySizes[] s_legalKeySizes = new KeySizes[2]
		{
			new KeySizes(256, 384, 128),
			new KeySizes(521, 521, 0)
		};

		private CngKey m_key;

		private CngAlgorithm m_hashAlgorithm = CngAlgorithm.Sha256;

		public CngAlgorithm HashAlgorithm
		{
			get
			{
				return m_hashAlgorithm;
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				m_hashAlgorithm = value;
			}
		}

		public CngKey Key
		{
			get
			{
				if (m_key != null && m_key.KeySize != KeySize)
				{
					m_key.Dispose();
					m_key = null;
				}
				if (m_key == null)
				{
					CngAlgorithm algorithm = null;
					switch (KeySize)
					{
					case 256:
						algorithm = CngAlgorithm.ECDsaP256;
						break;
					case 384:
						algorithm = CngAlgorithm.ECDsaP384;
						break;
					case 521:
						algorithm = CngAlgorithm.ECDsaP521;
						break;
					}
					m_key = CngKey.Create(algorithm);
				}
				return m_key;
			}
			private set
			{
				Contract.Requires(value != null);
				if (value.AlgorithmGroup != CngAlgorithmGroup.ECDsa)
				{
					throw new ArgumentException(SR.GetString("Cryptography_ArgECDsaRequiresECDsaKey"));
				}
				if (m_key != null)
				{
					m_key.Dispose();
				}
				m_key = value;
				KeySize = m_key.KeySize;
			}
		}

		public ECDsaCng()
			: this(521)
		{
		}

		[SecurityCritical]
		public ECDsaCng(int keySize)
		{
			if (!NCryptNative.NCryptSupported)
			{
				throw new PlatformNotSupportedException(SR.GetString("Cryptography_PlatformNotSupported"));
			}
			LegalKeySizesValue = s_legalKeySizes;
			KeySize = keySize;
		}

		[SecurityCritical]
		public ECDsaCng(CngKey key)
		{
			if (key == null)
			{
				throw new ArgumentNullException("key");
			}
			if (key.AlgorithmGroup != CngAlgorithmGroup.ECDsa)
			{
				throw new ArgumentException(SR.GetString("Cryptography_ArgECDsaRequiresECDsaKey"), "key");
			}
			if (!NCryptNative.NCryptSupported)
			{
				throw new PlatformNotSupportedException(SR.GetString("Cryptography_PlatformNotSupported"));
			}
			LegalKeySizesValue = s_legalKeySizes;
			new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Assert();
			Key = CngKey.Open(key.Handle, key.IsEphemeral ? CngKeyHandleOpenOptions.EphemeralKey : CngKeyHandleOpenOptions.None);
			CodeAccessPermission.RevertAssert();
			KeySize = m_key.KeySize;
		}

		protected override void Dispose(bool disposing)
		{
			if (m_key != null)
			{
				m_key.Dispose();
			}
		}

		public override void FromXmlString(string xmlString)
		{
			throw new NotImplementedException(SR.GetString("Cryptography_ECXmlSerializationFormatRequired"));
		}

		public void FromXmlString(string xml, ECKeyXmlFormat format)
		{
			if (xml == null)
			{
				throw new ArgumentNullException("xml");
			}
			if (format != 0)
			{
				throw new ArgumentOutOfRangeException("format");
			}
			Key = Rfc4050KeyFormatter.FromXml(xml);
		}

		public byte[] SignData(byte[] data)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			return SignData(data, 0, data.Length);
		}

		[SecurityCritical]
		public byte[] SignData(byte[] data, int offset, int count)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			if (offset < 0 || offset > data.Length)
			{
				throw new ArgumentOutOfRangeException("offset");
			}
			if (count < 0 || count > data.Length - offset)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			using BCryptHashAlgorithm bCryptHashAlgorithm = new BCryptHashAlgorithm(HashAlgorithm, "Microsoft Primitive Provider");
			bCryptHashAlgorithm.HashCore(data, offset, count);
			byte[] hash = bCryptHashAlgorithm.HashFinal();
			return SignHash(hash);
		}

		[SecurityCritical]
		public byte[] SignData(Stream data)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			using BCryptHashAlgorithm bCryptHashAlgorithm = new BCryptHashAlgorithm(HashAlgorithm, "Microsoft Primitive Provider");
			bCryptHashAlgorithm.HashStream(data);
			byte[] hash = bCryptHashAlgorithm.HashFinal();
			return SignHash(hash);
		}

		[SecurityCritical]
		public override byte[] SignHash(byte[] hash)
		{
			if (hash == null)
			{
				throw new ArgumentNullException("hash");
			}
			Key.BuildKeyContainerPermission(KeyContainerPermissionFlags.Sign)?.Demand();
			new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Assert();
			SafeNCryptKeyHandle handle = Key.Handle;
			CodeAccessPermission.RevertAssert();
			return NCryptNative.SignHash(handle, hash);
		}

		public override string ToXmlString(bool includePrivateParameters)
		{
			throw new NotImplementedException(SR.GetString("Cryptography_ECXmlSerializationFormatRequired"));
		}

		public string ToXmlString(ECKeyXmlFormat format)
		{
			if (format != 0)
			{
				throw new ArgumentOutOfRangeException("format");
			}
			return Rfc4050KeyFormatter.ToXml(Key);
		}

		public bool VerifyData(byte[] data, byte[] signature)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			return VerifyData(data, 0, data.Length, signature);
		}

		[SecurityCritical]
		public bool VerifyData(byte[] data, int offset, int count, byte[] signature)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			if (offset < 0 || offset > data.Length)
			{
				throw new ArgumentOutOfRangeException("offset");
			}
			if (count < 0 || count > data.Length - offset)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (signature == null)
			{
				throw new ArgumentNullException("signature");
			}
			using BCryptHashAlgorithm bCryptHashAlgorithm = new BCryptHashAlgorithm(HashAlgorithm, "Microsoft Primitive Provider");
			bCryptHashAlgorithm.HashCore(data, offset, count);
			byte[] hash = bCryptHashAlgorithm.HashFinal();
			return VerifyHash(hash, signature);
		}

		[SecurityCritical]
		public bool VerifyData(Stream data, byte[] signature)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			if (signature == null)
			{
				throw new ArgumentNullException("signature");
			}
			using BCryptHashAlgorithm bCryptHashAlgorithm = new BCryptHashAlgorithm(HashAlgorithm, "Microsoft Primitive Provider");
			bCryptHashAlgorithm.HashStream(data);
			byte[] hash = bCryptHashAlgorithm.HashFinal();
			return VerifyHash(hash, signature);
		}

		[SecurityCritical]
		public override bool VerifyHash(byte[] hash, byte[] signature)
		{
			if (hash == null)
			{
				throw new ArgumentNullException("hash");
			}
			if (signature == null)
			{
				throw new ArgumentNullException("signature");
			}
			new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Assert();
			SafeNCryptKeyHandle handle = Key.Handle;
			CodeAccessPermission.RevertAssert();
			return NCryptNative.VerifySignature(handle, hash, signature);
		}
	}
	public enum ECKeyXmlFormat
	{
		Rfc4050
	}
	internal static class CoreCryptoConfig
	{
		private static Dictionary<string, Type> s_nameMap;

		private static bool? s_enforceFipsAlgorithms;

		private static Dictionary<string, Type> AlgorithmNameMap
		{
			get
			{
				if (s_nameMap == null)
				{
					Dictionary<string, Type> dictionary = new Dictionary<string, Type>(StringComparer.OrdinalIgnoreCase);
					dictionary.Add("AES", typeof(AesCryptoServiceProvider));
					dictionary.Add(typeof(AesCryptoServiceProvider).Name, typeof(AesCryptoServiceProvider));
					dictionary.Add(typeof(AesCryptoServiceProvider).FullName, typeof(AesCryptoServiceProvider));
					dictionary.Add(typeof(AesManaged).Name, typeof(AesManaged));
					dictionary.Add(typeof(AesManaged).FullName, typeof(AesManaged));
					dictionary.Add("ECDsa", typeof(ECDsaCng));
					dictionary.Add(typeof(ECDsaCng).Name, typeof(ECDsaCng));
					dictionary.Add(typeof(ECDsaCng).FullName, typeof(ECDsaCng));
					dictionary.Add("ECDH", typeof(ECDiffieHellmanCng));
					dictionary.Add("ECDiffieHellman", typeof(ECDiffieHellmanCng));
					dictionary.Add(typeof(ECDiffieHellmanCng).Name, typeof(ECDiffieHellmanCng));
					dictionary.Add(typeof(ECDiffieHellmanCng).FullName, typeof(ECDiffieHellmanCng));
					s_nameMap = dictionary;
				}
				return s_nameMap;
			}
		}

		internal static bool EnforceFipsAlgorithms
		{
			get
			{
				if (!s_enforceFipsAlgorithms.HasValue)
				{
					try
					{
						using (new SHA1Managed())
						{
							s_enforceFipsAlgorithms = false;
						}
					}
					catch (InvalidOperationException)
					{
						s_enforceFipsAlgorithms = true;
					}
				}
				return s_enforceFipsAlgorithms.Value;
			}
		}

		[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
		public static T CreateFromName<T>(string name) where T : class
		{
			Contract.Requires(name != null);
			if (AlgorithmNameMap.TryGetValue(name, out var value))
			{
				return (T)Activator.CreateInstance(value);
			}
			return (T)CryptoConfig.CreateFromName(name);
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class ManifestSignatureInformation
	{
		private ManifestKinds m_manifest;

		private StrongNameSignatureInformation m_strongNameSignature;

		private AuthenticodeSignatureInformation m_authenticodeSignature;

		public AuthenticodeSignatureInformation AuthenticodeSignature => m_authenticodeSignature;

		public ManifestKinds Manifest => m_manifest;

		public StrongNameSignatureInformation StrongNameSignature => m_strongNameSignature;

		internal ManifestSignatureInformation(ManifestKinds manifest, StrongNameSignatureInformation strongNameSignature, AuthenticodeSignatureInformation authenticodeSignature)
		{
			m_manifest = manifest;
			m_strongNameSignature = strongNameSignature;
			m_authenticodeSignature = authenticodeSignature;
		}

		[SecurityCritical]
		private unsafe static XmlDocument GetManifestXml(ActivationContext application, ManifestKinds manifest)
		{
			IStream stream = null;
			switch (manifest)
			{
			case ManifestKinds.Application:
				stream = InternalActivationContextHelper.GetApplicationComponentManifest(application) as IStream;
				break;
			case ManifestKinds.Deployment:
				stream = InternalActivationContextHelper.GetDeploymentComponentManifest(application) as IStream;
				break;
			}
			using MemoryStream memoryStream = new MemoryStream();
			byte[] array = new byte[4096];
			int num = 0;
			do
			{
				stream.Read(array, array.Length, new IntPtr(&num));
				memoryStream.Write(array, 0, num);
			}
			while (num == array.Length);
			memoryStream.Position = 0L;
			XmlDocument xmlDocument = new XmlDocument();
			xmlDocument.PreserveWhitespace = true;
			xmlDocument.Load(memoryStream);
			return xmlDocument;
		}

		public static ManifestSignatureInformationCollection VerifySignature(ActivationContext application)
		{
			return VerifySignature(application, ManifestKinds.ApplicationAndDeployment);
		}

		public static ManifestSignatureInformationCollection VerifySignature(ActivationContext application, ManifestKinds manifests)
		{
			return VerifySignature(application, manifests, X509RevocationFlag.ExcludeRoot, X509RevocationMode.Online);
		}

		[SecurityCritical]
		public static ManifestSignatureInformationCollection VerifySignature(ActivationContext application, ManifestKinds manifests, X509RevocationFlag revocationFlag, X509RevocationMode revocationMode)
		{
			if (application == null)
			{
				throw new ArgumentNullException("application");
			}
			if (revocationFlag < X509RevocationFlag.EndCertificateOnly || X509RevocationFlag.ExcludeRoot < revocationFlag)
			{
				throw new ArgumentOutOfRangeException("revocationFlag");
			}
			if (revocationMode < X509RevocationMode.NoCheck || X509RevocationMode.Offline < revocationMode)
			{
				throw new ArgumentOutOfRangeException("revocationMode");
			}
			List<ManifestSignatureInformation> list = new List<ManifestSignatureInformation>();
			if ((manifests & ManifestKinds.Deployment) == ManifestKinds.Deployment)
			{
				XmlDocument manifestXml = GetManifestXml(application, ManifestKinds.Deployment);
				ManifestSignedXml manifestSignedXml = new ManifestSignedXml(manifestXml, ManifestKinds.Deployment);
				list.Add(manifestSignedXml.VerifySignature(revocationFlag, revocationMode));
			}
			if ((manifests & ManifestKinds.Application) == ManifestKinds.Application)
			{
				XmlDocument manifestXml2 = GetManifestXml(application, ManifestKinds.Application);
				ManifestSignedXml manifestSignedXml2 = new ManifestSignedXml(manifestXml2, ManifestKinds.Application);
				list.Add(manifestSignedXml2.VerifySignature(revocationFlag, revocationMode));
			}
			return new ManifestSignatureInformationCollection(list);
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class ManifestSignatureInformationCollection : ReadOnlyCollection<ManifestSignatureInformation>
	{
		internal ManifestSignatureInformationCollection(IList<ManifestSignatureInformation> signatureInformation)
			: base(signatureInformation)
		{
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class MD5Cng : MD5
	{
		private BCryptHashAlgorithm m_hashAlgorithm;

		[SecurityCritical]
		public MD5Cng()
		{
			if (CoreCryptoConfig.EnforceFipsAlgorithms)
			{
				throw new InvalidOperationException(SR.GetString("Cryptography_NonCompliantFIPSAlgorithm"));
			}
			m_hashAlgorithm = new BCryptHashAlgorithm(CngAlgorithm.MD5, "Microsoft Primitive Provider");
		}

		[SecurityCritical]
		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
			if (disposing)
			{
				m_hashAlgorithm.Dispose();
			}
		}

		[SecurityCritical]
		public override void Initialize()
		{
			m_hashAlgorithm.Initialize();
		}

		[SecurityCritical]
		protected override void HashCore(byte[] array, int ibStart, int cbSize)
		{
			m_hashAlgorithm.HashCore(array, ibStart, cbSize);
		}

		[SecurityCritical]
		protected override byte[] HashFinal()
		{
			return m_hashAlgorithm.HashFinal();
		}
	}
	[Flags]
	public enum CngExportPolicies
	{
		None = 0,
		AllowExport = 1,
		AllowPlaintextExport = 2,
		AllowArchiving = 4,
		AllowPlaintextArchiving = 8
	}
	[Flags]
	public enum CngKeyCreationOptions
	{
		None = 0,
		MachineKey = 0x20,
		OverwriteExistingKey = 0x80
	}
	[Flags]
	public enum CngKeyOpenOptions
	{
		None = 0,
		UserKey = 0,
		MachineKey = 0x20,
		Silent = 0x40
	}
	[Flags]
	internal enum CngKeyTypes
	{
		None = 0,
		MachineKey = 0x20
	}
	[Flags]
	public enum CngKeyUsages
	{
		None = 0,
		Decryption = 1,
		Signing = 2,
		KeyAgreement = 4,
		AllUsages = 0xFFFFFF
	}
	[Flags]
	public enum CngPropertyOptions
	{
		None = 0,
		CustomProperty = 0x40000000,
		Persist = int.MinValue
	}
	[Flags]
	public enum CngUIProtectionLevels
	{
		None = 0,
		ProtectKey = 1,
		ForceHighProtection = 2
	}
	internal static class NCryptNative
	{
		internal enum BufferType
		{
			KdfHashAlgorithm,
			KdfSecretPrepend,
			KdfSecretAppend,
			KdfHmacKey,
			KdfTlsLabel,
			KdfTlsSeed
		}

		internal enum ErrorCode
		{
			Success = 0,
			BadSignature = -2146893818,
			NotFound = -2146893807,
			KeyDoesNotExist = -2146893802,
			BufferTooSmall = -2146893784
		}

		internal static class KeyPropertyName
		{
			internal const string Algorithm = "Algorithm Name";

			internal const string AlgorithmGroup = "Algorithm Group";

			internal const string ExportPolicy = "Export Policy";

			internal const string KeyType = "Key Type";

			internal const string KeyUsage = "Key Usage";

			internal const string Length = "Length";

			internal const string Name = "Name";

			internal const string ParentWindowHandle = "HWND Handle";

			internal const string ProviderHandle = "Provider Handle";

			internal const string UIPolicy = "UI Policy";

			internal const string UniqueName = "Unique Name";

			internal const string UseContext = "Use Context";

			internal const string ClrIsEphemeral = "CLR IsEphemeral";
		}

		internal static class ProviderPropertyName
		{
			internal const string Name = "Name";
		}

		[Flags]
		internal enum SecretAgreementFlags
		{
			None = 0,
			UseSecretAsHmacKey = 1
		}

		internal struct NCRYPT_UI_POLICY
		{
			public int dwVersion;

			public CngUIProtectionLevels dwFlags;

			[MarshalAs(UnmanagedType.LPWStr)]
			public string pszCreationTitle;

			[MarshalAs(UnmanagedType.LPWStr)]
			public string pszFriendlyName;

			[MarshalAs(UnmanagedType.LPWStr)]
			public string pszDescription;
		}

		internal struct NCryptBuffer
		{
			public int cbBuffer;

			public BufferType BufferType;

			public IntPtr pvBuffer;
		}

		internal struct NCryptBufferDesc
		{
			public int ulVersion;

			public int cBuffers;

			public IntPtr pBuffers;
		}

		[SuppressUnmanagedCodeSecurity]
		internal static class UnsafeNativeMethods
		{
			[DllImport("ncrypt.dll", CharSet = CharSet.Unicode)]
			internal static extern ErrorCode NCryptCreatePersistedKey(SafeNCryptProviderHandle hProvider, out SafeNCryptKeyHandle phKey, string pszAlgId, string pszKeyName, int dwLegacyKeySpec, CngKeyCreationOptions dwFlags);

			[DllImport("ncrypt.dll")]
			internal static extern ErrorCode NCryptDeleteKey(SafeNCryptKeyHandle hKey, int flags);

			[DllImport("ncrypt.dll", CharSet = CharSet.Unicode)]
			internal static extern ErrorCode NCryptDeriveKey(SafeNCryptSecretHandle hSharedSecret, string pwszKDF, [In] ref NCryptBufferDesc pParameterList, [Out][MarshalAs(UnmanagedType.LPArray)] byte[] pbDerivedKey, int cbDerivedKey, out int pcbResult, SecretAgreementFlags dwFlags);

			[DllImport("ncrypt.dll", CharSet = CharSet.Unicode)]
			internal static extern ErrorCode NCryptExportKey(SafeNCryptKeyHandle hKey, IntPtr hExportKey, string pszBlobType, IntPtr pParameterList, [Out][MarshalAs(UnmanagedType.LPArray)] byte[] pbOutput, int cbOutput, out int pcbResult, int dwFlags);

			[DllImport("ncrypt.dll")]
			internal static extern ErrorCode NCryptFinalizeKey(SafeNCryptKeyHandle hKey, int dwFlags);

			[DllImport("ncrypt.dll", CharSet = CharSet.Unicode)]
			internal static extern ErrorCode NCryptGetProperty(SafeNCryptHandle hObject, string pszProperty, [Out][MarshalAs(UnmanagedType.LPArray)] byte[] pbOutput, int cbOutput, out int pcbResult, CngPropertyOptions dwFlags);

			[DllImport("ncrypt.dll", CharSet = CharSet.Unicode)]
			[ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]
			internal static extern ErrorCode NCryptGetProperty(SafeNCryptHandle hObject, string pszProperty, out IntPtr pbOutput, int cbOutput, out int pcbResult, CngPropertyOptions dwFlags);

			[DllImport("ncrypt.dll", CharSet = CharSet.Unicode)]
			internal static extern ErrorCode NCryptImportKey(SafeNCryptProviderHandle hProvider, IntPtr hImportKey, string pszBlobType, IntPtr pParameterList, out SafeNCryptKeyHandle phKey, [MarshalAs(UnmanagedType.LPArray)] byte[] pbData, int cbData, int dwFlags);

			[DllImport("ncrypt.dll", CharSet = CharSet.Unicode)]
			internal static extern ErrorCode NCryptOpenKey(SafeNCryptProviderHandle hProvider, out SafeNCryptKeyHandle phKey, string pszKeyName, int dwLegacyKeySpec, CngKeyOpenOptions dwFlags);

			[DllImport("ncrypt.dll", CharSet = CharSet.Unicode)]
			internal static extern ErrorCode NCryptOpenStorageProvider(out SafeNCryptProviderHandle phProvider, string pszProviderName, int dwFlags);

			[DllImport("ncrypt.dll")]
			internal static extern ErrorCode NCryptSecretAgreement(SafeNCryptKeyHandle hPrivKey, SafeNCryptKeyHandle hPubKey, out SafeNCryptSecretHandle phSecret, int dwFlags);

			[DllImport("ncrypt.dll", CharSet = CharSet.Unicode)]
			internal static extern ErrorCode NCryptSetProperty(SafeNCryptHandle hObject, string pszProperty, [MarshalAs(UnmanagedType.LPArray)] byte[] pbInput, int cbInput, CngPropertyOptions dwFlags);

			[DllImport("ncrypt.dll", CharSet = CharSet.Unicode)]
			internal static extern ErrorCode NCryptSetProperty(SafeNCryptHandle hObject, string pszProperty, string pbInput, int cbInput, CngPropertyOptions dwFlags);

			[DllImport("ncrypt.dll", CharSet = CharSet.Unicode)]
			internal static extern ErrorCode NCryptSetProperty(SafeNCryptHandle hObject, string pszProperty, IntPtr pbInput, int cbInput, CngPropertyOptions dwFlags);

			[DllImport("ncrypt.dll")]
			internal static extern ErrorCode NCryptSignHash(SafeNCryptKeyHandle hKey, IntPtr pPaddingInfo, [MarshalAs(UnmanagedType.LPArray)] byte[] pbHashValue, int cbHashValue, [MarshalAs(UnmanagedType.LPArray)] byte[] pbSignature, int cbSignature, out int pcbResult, int dwFlags);

			[DllImport("ncrypt.dll")]
			internal static extern ErrorCode NCryptVerifySignature(SafeNCryptKeyHandle hKey, IntPtr pPaddingInfo, [MarshalAs(UnmanagedType.LPArray)] byte[] pbHashValue, int cbHashValue, [MarshalAs(UnmanagedType.LPArray)] byte[] pbSignature, int cbSignature, int dwFlags);
		}

		private static bool? s_ncryptSupported;

		internal static bool NCryptSupported
		{
			[SecurityCritical]
			get
			{
				if (!s_ncryptSupported.HasValue)
				{
					using SafeLibraryHandle safeLibraryHandle = Microsoft.Win32.UnsafeNativeMethods.LoadLibraryEx("ncrypt", IntPtr.Zero, 0);
					s_ncryptSupported = !safeLibraryHandle.IsInvalid;
				}
				return s_ncryptSupported.Value;
			}
		}

		internal static byte[] BuildEccPublicBlob(string algorithm, BigInteger x, BigInteger y)
		{
			Contract.Requires(!string.IsNullOrEmpty(algorithm));
			BCryptNative.MapAlgorithmIdToMagic(algorithm, out var algorithmMagic, out var keySize);
			byte[] array = ReverseBytes(FillKeyParameter(x.ToByteArray(), keySize));
			byte[] array2 = ReverseBytes(FillKeyParameter(y.ToByteArray(), keySize));
			byte[] array3 = new byte[8 + array.Length + array2.Length];
			Buffer.BlockCopy(BitConverter.GetBytes((int)algorithmMagic), 0, array3, 0, 4);
			Buffer.BlockCopy(BitConverter.GetBytes(array.Length), 0, array3, 4, 4);
			Buffer.BlockCopy(array, 0, array3, 8, array.Length);
			Buffer.BlockCopy(array2, 0, array3, 8 + array.Length, array2.Length);
			return array3;
		}

		[SecurityCritical]
		internal static SafeNCryptKeyHandle CreatePersistedKey(SafeNCryptProviderHandle provider, string algorithm, string name, CngKeyCreationOptions options)
		{
			Contract.Requires(provider != null && !provider.IsInvalid && !provider.IsClosed);
			Contract.Requires(!string.IsNullOrEmpty(algorithm));
			SafeNCryptKeyHandle phKey = null;
			ErrorCode errorCode = UnsafeNativeMethods.NCryptCreatePersistedKey(provider, out phKey, algorithm, name, 0, options);
			if (errorCode != 0)
			{
				throw new CryptographicException((int)errorCode);
			}
			return phKey;
		}

		[SecurityCritical]
		internal static void DeleteKey(SafeNCryptKeyHandle key)
		{
			Contract.Requires(key != null);
			ErrorCode errorCode = UnsafeNativeMethods.NCryptDeleteKey(key, 0);
			if (errorCode != 0)
			{
				throw new CryptographicException((int)errorCode);
			}
			key.Dispose();
		}

		[SecurityCritical]
		private unsafe static byte[] DeriveKeyMaterial(SafeNCryptSecretHandle secretAgreement, string kdf, string hashAlgorithm, byte[] hmacKey, byte[] secretPrepend, byte[] secretAppend, SecretAgreementFlags flags)
		{
			Contract.Requires(secretAgreement != null);
			Contract.Requires(!string.IsNullOrEmpty(kdf));
			Contract.Requires(!string.IsNullOrEmpty(hashAlgorithm));
			Contract.Requires(hmacKey == null || kdf == "HMAC");
			List<NCryptBuffer> list = new List<NCryptBuffer>();
			IntPtr intPtr = IntPtr.Zero;
			RuntimeHelpers.PrepareConstrainedRegions();
			try
			{
				RuntimeHelpers.PrepareConstrainedRegions();
				try
				{
				}
				finally
				{
					intPtr = Marshal.StringToCoTaskMemUni(hashAlgorithm);
				}
				NCryptBuffer item = default(NCryptBuffer);
				item.cbBuffer = (hashAlgorithm.Length + 1) * 2;
				item.BufferType = BufferType.KdfHashAlgorithm;
				item.pvBuffer = intPtr;
				list.Add(item);
				fixed (byte* ptr = hmacKey)
				{
					fixed (byte* ptr2 = secretPrepend)
					{
						fixed (byte* ptr3 = secretAppend)
						{
							if (ptr != null)
							{
								NCryptBuffer item2 = default(NCryptBuffer);
								item2.cbBuffer = hmacKey.Length;
								item2.BufferType = BufferType.KdfHmacKey;
								item2.pvBuffer = new IntPtr(ptr);
								list.Add(item2);
							}
							if (ptr2 != null)
							{
								NCryptBuffer item3 = default(NCryptBuffer);
								item3.cbBuffer = secretPrepend.Length;
								item3.BufferType = BufferType.KdfSecretPrepend;
								item3.pvBuffer = new IntPtr(ptr2);
								list.Add(item3);
							}
							if (ptr3 != null)
							{
								NCryptBuffer item4 = default(NCryptBuffer);
								item4.cbBuffer = secretAppend.Length;
								item4.BufferType = BufferType.KdfSecretAppend;
								item4.pvBuffer = new IntPtr(ptr3);
								list.Add(item4);
							}
							return DeriveKeyMaterial(secretAgreement, kdf, list.ToArray(), flags);
						}
					}
				}
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeCoTaskMem(intPtr);
				}
			}
		}

		[SecurityCritical]
		private unsafe static byte[] DeriveKeyMaterial(SafeNCryptSecretHandle secretAgreement, string kdf, NCryptBuffer[] parameters, SecretAgreementFlags flags)
		{
			Contract.Requires(secretAgreement != null);
			Contract.Requires(!string.IsNullOrEmpty(kdf));
			Contract.Requires(parameters != null);
			fixed (NCryptBuffer* value = parameters)
			{
				NCryptBufferDesc pParameterList = default(NCryptBufferDesc);
				pParameterList.ulVersion = 0;
				pParameterList.cBuffers = parameters.Length;
				pParameterList.pBuffers = new IntPtr(value);
				int pcbResult = 0;
				ErrorCode errorCode = UnsafeNativeMethods.NCryptDeriveKey(secretAgreement, kdf, ref pParameterList, null, 0, out pcbResult, flags);
				if (errorCode != 0 && errorCode != ErrorCode.BufferTooSmall)
				{
					throw new CryptographicException((int)errorCode);
				}
				byte[] array = new byte[pcbResult];
				errorCode = UnsafeNativeMethods.NCryptDeriveKey(secretAgreement, kdf, ref pParameterList, array, array.Length, out pcbResult, flags);
				if (errorCode != 0)
				{
					throw new CryptographicException((int)errorCode);
				}
				return array;
			}
		}

		[SecurityCritical]
		internal static byte[] DeriveKeyMaterialHash(SafeNCryptSecretHandle secretAgreement, string hashAlgorithm, byte[] secretPrepend, byte[] secretAppend, SecretAgreementFlags flags)
		{
			Contract.Requires(secretAgreement != null);
			Contract.Requires(!string.IsNullOrEmpty(hashAlgorithm));
			return DeriveKeyMaterial(secretAgreement, "HASH", hashAlgorithm, null, secretPrepend, secretAppend, flags);
		}

		[SecurityCritical]
		internal static byte[] DeriveKeyMaterialHmac(SafeNCryptSecretHandle secretAgreement, string hashAlgorithm, byte[] hmacKey, byte[] secretPrepend, byte[] secretAppend, SecretAgreementFlags flags)
		{
			Contract.Requires(secretAgreement != null);
			Contract.Requires(!string.IsNullOrEmpty(hashAlgorithm));
			return DeriveKeyMaterial(secretAgreement, "HMAC", hashAlgorithm, hmacKey, secretPrepend, secretAppend, flags);
		}

		[SecurityCritical]
		internal unsafe static byte[] DeriveKeyMaterialTls(SafeNCryptSecretHandle secretAgreement, byte[] label, byte[] seed, SecretAgreementFlags flags)
		{
			Contract.Requires(secretAgreement != null);
			Contract.Requires(label != null && seed != null);
			NCryptBuffer[] array = new NCryptBuffer[2];
			fixed (byte* value = label)
			{
				fixed (byte* value2 = seed)
				{
					NCryptBuffer nCryptBuffer = default(NCryptBuffer);
					nCryptBuffer.cbBuffer = label.Length;
					nCryptBuffer.BufferType = BufferType.KdfTlsLabel;
					nCryptBuffer.pvBuffer = new IntPtr(value);
					array[0] = nCryptBuffer;
					NCryptBuffer nCryptBuffer2 = default(NCryptBuffer);
					nCryptBuffer2.cbBuffer = seed.Length;
					nCryptBuffer2.BufferType = BufferType.KdfTlsSeed;
					nCryptBuffer2.pvBuffer = new IntPtr(value2);
					array[1] = nCryptBuffer2;
					return DeriveKeyMaterial(secretAgreement, "TLS_PRF", array, flags);
				}
			}
		}

		[SecurityCritical]
		internal static SafeNCryptSecretHandle DeriveSecretAgreement(SafeNCryptKeyHandle privateKey, SafeNCryptKeyHandle otherPartyPublicKey)
		{
			Contract.Requires(privateKey != null);
			Contract.Requires(otherPartyPublicKey != null);
			SafeNCryptSecretHandle phSecret;
			ErrorCode errorCode = UnsafeNativeMethods.NCryptSecretAgreement(privateKey, otherPartyPublicKey, out phSecret, 0);
			if (errorCode != 0)
			{
				throw new CryptographicException((int)errorCode);
			}
			return phSecret;
		}

		[SecurityCritical]
		internal static byte[] ExportKey(SafeNCryptKeyHandle key, string format)
		{
			Contract.Requires(key != null);
			Contract.Requires(!string.IsNullOrEmpty(format));
			int pcbResult = 0;
			ErrorCode errorCode = UnsafeNativeMethods.NCryptExportKey(key, IntPtr.Zero, format, IntPtr.Zero, null, 0, out pcbResult, 0);
			if (errorCode != 0 && errorCode != ErrorCode.BufferTooSmall)
			{
				throw new CryptographicException((int)errorCode);
			}
			byte[] array = new byte[pcbResult];
			errorCode = UnsafeNativeMethods.NCryptExportKey(key, IntPtr.Zero, format, IntPtr.Zero, array, array.Length, out pcbResult, 0);
			if (errorCode != 0)
			{
				throw new CryptographicException((int)errorCode);
			}
			return array;
		}

		private static byte[] FillKeyParameter(byte[] key, int keySize)
		{
			Contract.Requires(key != null);
			Contract.Requires(keySize > 0);
			int num = keySize / 8 + ((keySize % 8 != 0) ? 1 : 0);
			if (key.Length == num)
			{
				return key;
			}
			byte[] array = new byte[num];
			Buffer.BlockCopy(key, 0, array, 0, Math.Min(key.Length, array.Length));
			return array;
		}

		[SecurityCritical]
		internal static void FinalizeKey(SafeNCryptKeyHandle key)
		{
			Contract.Requires(key != null && !key.IsInvalid && !key.IsClosed);
			ErrorCode errorCode = UnsafeNativeMethods.NCryptFinalizeKey(key, 0);
			if (errorCode != 0)
			{
				throw new CryptographicException((int)errorCode);
			}
		}

		[SecurityCritical]
		internal static byte[] GetProperty(SafeNCryptHandle ncryptObject, string propertyName, CngPropertyOptions propertyOptions, out bool foundProperty)
		{
			Contract.Requires(ncryptObject != null);
			Contract.Requires(propertyName != null);
			int pcbResult = 0;
			ErrorCode errorCode = UnsafeNativeMethods.NCryptGetProperty(ncryptObject, propertyName, null, 0, out pcbResult, propertyOptions);
			if (errorCode != 0 && errorCode != ErrorCode.BufferTooSmall && errorCode != ErrorCode.NotFound)
			{
				throw new CryptographicException((int)errorCode);
			}
			foundProperty = errorCode != ErrorCode.NotFound;
			byte[] array = null;
			if (errorCode != ErrorCode.NotFound && pcbResult > 0)
			{
				array = new byte[pcbResult];
				errorCode = UnsafeNativeMethods.NCryptGetProperty(ncryptObject, propertyName, array, array.Length, out pcbResult, propertyOptions);
				if (errorCode != 0)
				{
					throw new CryptographicException((int)errorCode);
				}
				foundProperty = true;
			}
			return array;
		}

		[SecurityCritical]
		internal static int GetPropertyAsDWord(SafeNCryptHandle ncryptObject, string propertyName, CngPropertyOptions propertyOptions)
		{
			Contract.Requires(ncryptObject != null);
			Contract.Requires(propertyName != null);
			bool foundProperty;
			byte[] property = GetProperty(ncryptObject, propertyName, propertyOptions, out foundProperty);
			if (!foundProperty || property == null)
			{
				return 0;
			}
			return BitConverter.ToInt32(property, 0);
		}

		[SecurityCritical]
		[ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]
		internal static IntPtr GetPropertyAsIntPtr(SafeNCryptHandle ncryptObject, string propertyName, CngPropertyOptions propertyOptions)
		{
			Contract.Requires(ncryptObject != null);
			Contract.Requires(propertyName != null);
			int pcbResult = IntPtr.Size;
			IntPtr pbOutput = IntPtr.Zero;
			ErrorCode errorCode = UnsafeNativeMethods.NCryptGetProperty(ncryptObject, propertyName, out pbOutput, IntPtr.Size, out pcbResult, propertyOptions);
			return errorCode switch
			{
				ErrorCode.NotFound => IntPtr.Zero, 
				ErrorCode.Success => pbOutput, 
				_ => throw new CryptographicException((int)errorCode), 
			};
		}

		[SecurityCritical]
		internal unsafe static string GetPropertyAsString(SafeNCryptHandle ncryptObject, string propertyName, CngPropertyOptions propertyOptions)
		{
			Contract.Requires(ncryptObject != null);
			Contract.Requires(propertyName != null);
			bool foundProperty;
			byte[] property = GetProperty(ncryptObject, propertyName, propertyOptions, out foundProperty);
			if (!foundProperty || property == null)
			{
				return null;
			}
			if (property.Length == 0)
			{
				return string.Empty;
			}
			fixed (byte* value = property)
			{
				return Marshal.PtrToStringUni(new IntPtr(value));
			}
		}

		[SecurityCritical]
		internal unsafe static T GetPropertyAsStruct<T>(SafeNCryptHandle ncryptObject, string propertyName, CngPropertyOptions propertyOptions) where T : struct
		{
			Contract.Requires(ncryptObject != null);
			Contract.Requires(propertyName != null);
			bool foundProperty;
			byte[] property = GetProperty(ncryptObject, propertyName, propertyOptions, out foundProperty);
			if (!foundProperty || property == null)
			{
				return default(T);
			}
			fixed (byte* value = property)
			{
				return (T)Marshal.PtrToStructure(new IntPtr(value), typeof(T));
			}
		}

		[SecurityCritical]
		internal static SafeNCryptKeyHandle ImportKey(SafeNCryptProviderHandle provider, byte[] keyBlob, string format)
		{
			Contract.Requires(provider != null);
			Contract.Requires(keyBlob != null);
			Contract.Requires(!string.IsNullOrEmpty(format));
			SafeNCryptKeyHandle phKey = null;
			ErrorCode errorCode = UnsafeNativeMethods.NCryptImportKey(provider, IntPtr.Zero, format, IntPtr.Zero, out phKey, keyBlob, keyBlob.Length, 0);
			if (errorCode != 0)
			{
				throw new CryptographicException((int)errorCode);
			}
			return phKey;
		}

		[SecurityCritical]
		internal static SafeNCryptKeyHandle OpenKey(SafeNCryptProviderHandle provider, string name, CngKeyOpenOptions options)
		{
			Contract.Requires(provider != null && !provider.IsInvalid && !provider.IsClosed);
			Contract.Requires(name != null);
			SafeNCryptKeyHandle phKey = null;
			ErrorCode errorCode = UnsafeNativeMethods.NCryptOpenKey(provider, out phKey, name, 0, options);
			if (errorCode != 0)
			{
				throw new CryptographicException((int)errorCode);
			}
			return phKey;
		}

		[SecurityCritical]
		internal static SafeNCryptProviderHandle OpenStorageProvider(string providerName)
		{
			Contract.Requires(!string.IsNullOrEmpty(providerName));
			SafeNCryptProviderHandle phProvider = null;
			ErrorCode errorCode = UnsafeNativeMethods.NCryptOpenStorageProvider(out phProvider, providerName, 0);
			if (errorCode != 0)
			{
				throw new CryptographicException((int)errorCode);
			}
			return phProvider;
		}

		private static byte[] ReverseBytes(byte[] buffer)
		{
			Contract.Requires(buffer != null);
			return ReverseBytes(buffer, 0, buffer.Length);
		}

		private static byte[] ReverseBytes(byte[] buffer, int offset, int count)
		{
			Contract.Requires(buffer != null);
			Contract.Requires(offset >= 0 && offset < buffer.Length);
			Contract.Requires(count >= 0 && buffer.Length - count >= offset);
			byte[] array = new byte[count];
			int num = offset + count - 1;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = buffer[num - i];
			}
			return array;
		}

		[SecurityCritical]
		internal static void SetProperty(SafeNCryptHandle ncryptObject, string propertyName, int value, CngPropertyOptions propertyOptions)
		{
			Contract.Requires(ncryptObject != null);
			Contract.Requires(propertyName != null);
			SetProperty(ncryptObject, propertyName, BitConverter.GetBytes(value), propertyOptions);
		}

		[SecurityCritical]
		internal static void SetProperty(SafeNCryptHandle ncryptObject, string propertyName, string value, CngPropertyOptions propertyOptions)
		{
			Contract.Requires(ncryptObject != null);
			Contract.Requires(propertyName != null);
			ErrorCode errorCode = UnsafeNativeMethods.NCryptSetProperty(ncryptObject, propertyName, value, (value.Length + 1) * 2, propertyOptions);
			if (errorCode != 0)
			{
				throw new CryptographicException((int)errorCode);
			}
		}

		[SecurityCritical]
		internal unsafe static void SetProperty<T>(SafeNCryptHandle ncryptObject, string propertyName, T value, CngPropertyOptions propertyOptions) where T : struct
		{
			Contract.Requires(ncryptObject != null);
			Contract.Requires(propertyName != null);
			byte[] array = new byte[Marshal.SizeOf(typeof(T))];
			fixed (byte* value2 = array)
			{
				bool flag = false;
				RuntimeHelpers.PrepareConstrainedRegions();
				try
				{
					RuntimeHelpers.PrepareConstrainedRegions();
					try
					{
					}
					finally
					{
						Marshal.StructureToPtr(value, new IntPtr(value2), fDeleteOld: false);
						flag = true;
					}
					SetProperty(ncryptObject, propertyName, array, propertyOptions);
				}
				finally
				{
					if (flag)
					{
						Marshal.DestroyStructure(new IntPtr(value2), typeof(T));
					}
				}
			}
		}

		[SecurityCritical]
		internal static void SetProperty(SafeNCryptHandle ncryptObject, string propertyName, byte[] value, CngPropertyOptions propertyOptions)
		{
			Contract.Requires(ncryptObject != null);
			Contract.Requires(propertyName != null);
			ErrorCode errorCode = UnsafeNativeMethods.NCryptSetProperty(ncryptObject, propertyName, value, (value != null) ? value.Length : 0, propertyOptions);
			if (errorCode != 0)
			{
				throw new CryptographicException((int)errorCode);
			}
		}

		[SecurityCritical]
		internal static byte[] SignHash(SafeNCryptKeyHandle key, byte[] hash)
		{
			Contract.Requires(key != null);
			Contract.Requires(hash != null);
			int pcbResult = 0;
			ErrorCode errorCode = UnsafeNativeMethods.NCryptSignHash(key, IntPtr.Zero, hash, hash.Length, null, 0, out pcbResult, 0);
			if (errorCode != 0 && errorCode != ErrorCode.BufferTooSmall)
			{
				throw new CryptographicException((int)errorCode);
			}
			byte[] array = new byte[pcbResult];
			errorCode = UnsafeNativeMethods.NCryptSignHash(key, IntPtr.Zero, hash, hash.Length, array, array.Length, out pcbResult, 0);
			if (errorCode != 0)
			{
				throw new CryptographicException((int)errorCode);
			}
			return array;
		}

		internal static void UnpackEccPublicBlob(byte[] blob, out BigInteger x, out BigInteger y)
		{
			Contract.Requires(blob != null && blob.Length > 8);
			int num = BitConverter.ToInt32(blob, 4);
			x = new BigInteger(ReverseBytes(blob, 8, num), negative: false);
			y = new BigInteger(ReverseBytes(blob, 8 + num, num), negative: false);
		}

		[SecurityCritical]
		internal static bool VerifySignature(SafeNCryptKeyHandle key, byte[] hash, byte[] signature)
		{
			Contract.Requires(key != null);
			Contract.Requires(hash != null);
			Contract.Requires(signature != null);
			ErrorCode errorCode = UnsafeNativeMethods.NCryptVerifySignature(key, IntPtr.Zero, hash, hash.Length, signature, signature.Length, 0);
			if (errorCode != 0 && errorCode != ErrorCode.BadSignature)
			{
				throw new CryptographicException((int)errorCode);
			}
			return errorCode == ErrorCode.Success;
		}
	}
	internal static class Rfc4050KeyFormatter
	{
		private const string DomainParametersRoot = "DomainParameters";

		private const string ECDHRoot = "ECDHKeyValue";

		private const string ECDsaRoot = "ECDSAKeyValue";

		private const string NamedCurveElement = "NamedCurve";

		private const string Namespace = "http://www.w3.org/2001/04/xmldsig-more#";

		private const string PublicKeyRoot = "PublicKey";

		private const string UrnAttribute = "URN";

		private const string ValueAttribute = "Value";

		private const string XElement = "X";

		private const string YElement = "Y";

		private const string Prime256CurveUrn = "urn:oid:1.2.840.10045.3.1.7";

		private const string Prime384CurveUrn = "urn:oid:1.3.132.0.34";

		private const string Prime521CurveUrn = "urn:oid:1.3.132.0.35";

		internal static CngKey FromXml(string xml)
		{
			Contract.Requires(xml != null);
			using TextReader input = new StringReader(xml);
			using XmlTextReader reader = new XmlTextReader(input);
			XPathDocument xPathDocument = new XPathDocument(reader);
			XPathNavigator xPathNavigator = xPathDocument.CreateNavigator();
			if (!xPathNavigator.MoveToFirstChild())
			{
				throw new ArgumentException(SR.GetString("Cryptography_MissingDomainParameters"));
			}
			if (xPathNavigator.NamespaceURI != "http://www.w3.org/2001/04/xmldsig-more#")
			{
				throw new ArgumentException(SR.GetString("Cryptography_UnexpectedXmlNamespace", xPathNavigator.NamespaceURI, "http://www.w3.org/2001/04/xmldsig-more#"));
			}
			CngAlgorithm cngAlgorithm = ReadAlgorithm(xPathNavigator);
			if (!xPathNavigator.MoveToNext(XPathNodeType.Element))
			{
				throw new ArgumentException(SR.GetString("Cryptography_MissingPublicKey"));
			}
			ReadPublicKey(xPathNavigator, out var x, out var y);
			byte[] keyBlob = NCryptNative.BuildEccPublicBlob(cngAlgorithm.Algorithm, x, y);
			return CngKey.Import(keyBlob, CngKeyBlobFormat.EccPublicBlob);
		}

		private static int GetKeySize(string urn)
		{
			Contract.Requires(!string.IsNullOrEmpty(urn));
			return urn switch
			{
				"urn:oid:1.2.840.10045.3.1.7" => 256, 
				"urn:oid:1.3.132.0.34" => 384, 
				"urn:oid:1.3.132.0.35" => 521, 
				_ => throw new ArgumentException(SR.GetString("Cryptography_UnknownEllipticCurve"), "algorithm"), 
			};
		}

		private static string GetCurveUrn(CngAlgorithm algorithm)
		{
			Contract.Requires(algorithm != null);
			if (algorithm == CngAlgorithm.ECDsaP256 || algorithm == CngAlgorithm.ECDiffieHellmanP256)
			{
				return "urn:oid:1.2.840.10045.3.1.7";
			}
			if (algorithm == CngAlgorithm.ECDsaP384 || algorithm == CngAlgorithm.ECDiffieHellmanP384)
			{
				return "urn:oid:1.3.132.0.34";
			}
			if (algorithm == CngAlgorithm.ECDsaP521 || algorithm == CngAlgorithm.ECDiffieHellmanP521)
			{
				return "urn:oid:1.3.132.0.35";
			}
			throw new ArgumentException(SR.GetString("Cryptography_UnknownEllipticCurve"), "algorithm");
		}

		private static CngAlgorithm ReadAlgorithm(XPathNavigator navigator)
		{
			Contract.Requires(navigator != null);
			if (navigator.NamespaceURI != "http://www.w3.org/2001/04/xmldsig-more#")
			{
				throw new ArgumentException(SR.GetString("Cryptography_UnexpectedXmlNamespace", navigator.NamespaceURI, "http://www.w3.org/2001/04/xmldsig-more#"));
			}
			bool flag = navigator.Name == "ECDHKeyValue";
			bool flag2 = navigator.Name == "ECDSAKeyValue";
			if (!flag && !flag2)
			{
				throw new ArgumentException(SR.GetString("Cryptography_UnknownEllipticCurveAlgorithm"));
			}
			if (!navigator.MoveToFirstChild() || navigator.Name != "DomainParameters")
			{
				throw new ArgumentException(SR.GetString("Cryptography_MissingDomainParameters"));
			}
			if (!navigator.MoveToFirstChild() || navigator.Name != "NamedCurve")
			{
				throw new ArgumentException(SR.GetString("Cryptography_MissingDomainParameters"));
			}
			if (!navigator.MoveToFirstAttribute() || navigator.Name != "URN" || string.IsNullOrEmpty(navigator.Value))
			{
				throw new ArgumentException(SR.GetString("Cryptography_MissingDomainParameters"));
			}
			int keySize = GetKeySize(navigator.Value);
			navigator.MoveToParent();
			navigator.MoveToParent();
			if (flag)
			{
				return keySize switch
				{
					256 => CngAlgorithm.ECDiffieHellmanP256, 
					384 => CngAlgorithm.ECDiffieHellmanP384, 
					_ => CngAlgorithm.ECDiffieHellmanP521, 
				};
			}
			return keySize switch
			{
				256 => CngAlgorithm.ECDsaP256, 
				384 => CngAlgorithm.ECDsaP384, 
				_ => CngAlgorithm.ECDsaP521, 
			};
		}

		private static void ReadPublicKey(XPathNavigator navigator, out BigInteger x, out BigInteger y)
		{
			Contract.Requires(navigator != null);
			if (navigator.NamespaceURI != "http://www.w3.org/2001/04/xmldsig-more#")
			{
				throw new ArgumentException(SR.GetString("Cryptography_UnexpectedXmlNamespace", navigator.NamespaceURI, "http://www.w3.org/2001/04/xmldsig-more#"));
			}
			if (navigator.Name != "PublicKey")
			{
				throw new ArgumentException(SR.GetString("Cryptography_MissingPublicKey"));
			}
			if (!navigator.MoveToFirstChild() || navigator.Name != "X")
			{
				throw new ArgumentException(SR.GetString("Cryptography_MissingPublicKey"));
			}
			if (!navigator.MoveToFirstAttribute() || navigator.Name != "Value" || string.IsNullOrEmpty(navigator.Value))
			{
				throw new ArgumentException(SR.GetString("Cryptography_MissingPublicKey"));
			}
			x = BigInteger.Parse(navigator.Value, CultureInfo.InvariantCulture);
			navigator.MoveToParent();
			if (!navigator.MoveToNext(XPathNodeType.Element) || navigator.Name != "Y")
			{
				throw new ArgumentException(SR.GetString("Cryptography_MissingPublicKey"));
			}
			if (!navigator.MoveToFirstAttribute() || navigator.Name != "Value" || string.IsNullOrEmpty(navigator.Value))
			{
				throw new ArgumentException(SR.GetString("Cryptography_MissingPublicKey"));
			}
			y = BigInteger.Parse(navigator.Value, CultureInfo.InvariantCulture);
		}

		private static void WriteDomainParameters(XmlWriter writer, CngKey key)
		{
			Contract.Requires(writer != null);
			Contract.Requires(key != null && (key.AlgorithmGroup == CngAlgorithmGroup.ECDsa || key.AlgorithmGroup == CngAlgorithmGroup.ECDiffieHellman));
			writer.WriteStartElement("DomainParameters");
			writer.WriteStartElement("NamedCurve");
			writer.WriteAttributeString("URN", GetCurveUrn(key.Algorithm));
			writer.WriteEndElement();
			writer.WriteEndElement();
		}

		private static void WritePublicKeyValue(XmlWriter writer, CngKey key)
		{
			Contract.Requires(writer != null);
			Contract.Requires(key != null && (key.AlgorithmGroup == CngAlgorithmGroup.ECDsa || key.AlgorithmGroup == CngAlgorithmGroup.ECDiffieHellman));
			writer.WriteStartElement("PublicKey");
			byte[] blob = key.Export(CngKeyBlobFormat.EccPublicBlob);
			NCryptNative.UnpackEccPublicBlob(blob, out var x, out var y);
			writer.WriteStartElement("X");
			writer.WriteAttributeString("Value", x.ToString(CultureInfo.InvariantCulture));
			writer.WriteEndElement();
			writer.WriteStartElement("Y");
			writer.WriteAttributeString("Value", y.ToString(CultureInfo.InvariantCulture));
			writer.WriteEndElement();
			writer.WriteEndElement();
		}

		internal static string ToXml(CngKey key)
		{
			Contract.Requires(key != null && (key.AlgorithmGroup == CngAlgorithmGroup.ECDsa || key.AlgorithmGroup == CngAlgorithmGroup.ECDiffieHellman));
			StringBuilder stringBuilder = new StringBuilder();
			XmlWriterSettings xmlWriterSettings = new XmlWriterSettings();
			xmlWriterSettings.Indent = true;
			xmlWriterSettings.IndentChars = "  ";
			xmlWriterSettings.OmitXmlDeclaration = true;
			using (XmlWriter xmlWriter = XmlWriter.Create(stringBuilder, xmlWriterSettings))
			{
				string localName = ((key.AlgorithmGroup == CngAlgorithmGroup.ECDsa) ? "ECDSAKeyValue" : "ECDHKeyValue");
				xmlWriter.WriteStartElement(localName, "http://www.w3.org/2001/04/xmldsig-more#");
				WriteDomainParameters(xmlWriter, key);
				WritePublicKeyValue(xmlWriter, key);
				xmlWriter.WriteEndElement();
			}
			return stringBuilder.ToString();
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class SHA1Cng : SHA1
	{
		private BCryptHashAlgorithm m_hashAlgorithm;

		[SecurityCritical]
		public SHA1Cng()
		{
			m_hashAlgorithm = new BCryptHashAlgorithm(CngAlgorithm.Sha1, "Microsoft Primitive Provider");
		}

		[SecurityCritical]
		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
			if (disposing)
			{
				m_hashAlgorithm.Dispose();
			}
		}

		[SecurityCritical]
		public override void Initialize()
		{
			m_hashAlgorithm.Initialize();
		}

		[SecurityCritical]
		protected override void HashCore(byte[] array, int ibStart, int cbSize)
		{
			m_hashAlgorithm.HashCore(array, ibStart, cbSize);
		}

		[SecurityCritical]
		protected override byte[] HashFinal()
		{
			return m_hashAlgorithm.HashFinal();
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class SHA256Cng : SHA256
	{
		private BCryptHashAlgorithm m_hashAlgorithm;

		[SecurityCritical]
		public SHA256Cng()
		{
			m_hashAlgorithm = new BCryptHashAlgorithm(CngAlgorithm.Sha256, "Microsoft Primitive Provider");
		}

		[SecurityCritical]
		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
			if (disposing)
			{
				m_hashAlgorithm.Dispose();
			}
		}

		[SecurityCritical]
		public override void Initialize()
		{
			m_hashAlgorithm.Initialize();
		}

		[SecurityCritical]
		protected override void HashCore(byte[] array, int ibStart, int cbSize)
		{
			m_hashAlgorithm.HashCore(array, ibStart, cbSize);
		}

		[SecurityCritical]
		protected override byte[] HashFinal()
		{
			return m_hashAlgorithm.HashFinal();
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class SHA256CryptoServiceProvider : SHA256
	{
		private CapiHashAlgorithm m_hashAlgorithm;

		[SecurityCritical]
		public SHA256CryptoServiceProvider()
		{
			m_hashAlgorithm = new CapiHashAlgorithm("Microsoft Enhanced RSA and AES Cryptographic Provider", CapiNative.ProviderType.RsaAes, CapiNative.AlgorithmId.Sha256);
		}

		[SecurityCritical]
		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
			if (disposing)
			{
				m_hashAlgorithm.Dispose();
			}
		}

		[SecurityCritical]
		public override void Initialize()
		{
			m_hashAlgorithm.Initialize();
		}

		[SecurityCritical]
		protected override void HashCore(byte[] array, int ibStart, int cbSize)
		{
			m_hashAlgorithm.HashCore(array, ibStart, cbSize);
		}

		[SecurityCritical]
		protected override byte[] HashFinal()
		{
			return m_hashAlgorithm.HashFinal();
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class SHA384Cng : SHA384
	{
		private BCryptHashAlgorithm m_hashAlgorithm;

		[SecurityCritical]
		public SHA384Cng()
		{
			m_hashAlgorithm = new BCryptHashAlgorithm(CngAlgorithm.Sha384, "Microsoft Primitive Provider");
		}

		[SecurityCritical]
		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
			if (disposing)
			{
				m_hashAlgorithm.Dispose();
			}
		}

		[SecurityCritical]
		public override void Initialize()
		{
			m_hashAlgorithm.Initialize();
		}

		[SecurityCritical]
		protected override void HashCore(byte[] array, int ibStart, int cbSize)
		{
			m_hashAlgorithm.HashCore(array, ibStart, cbSize);
		}

		[SecurityCritical]
		protected override byte[] HashFinal()
		{
			return m_hashAlgorithm.HashFinal();
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class SHA384CryptoServiceProvider : SHA384
	{
		private CapiHashAlgorithm m_hashAlgorithm;

		[SecurityCritical]
		public SHA384CryptoServiceProvider()
		{
			m_hashAlgorithm = new CapiHashAlgorithm("Microsoft Enhanced RSA and AES Cryptographic Provider", CapiNative.ProviderType.RsaAes, CapiNative.AlgorithmId.Sha384);
		}

		[SecurityCritical]
		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
			if (disposing)
			{
				m_hashAlgorithm.Dispose();
			}
		}

		[SecurityCritical]
		public override void Initialize()
		{
			m_hashAlgorithm.Initialize();
		}

		[SecurityCritical]
		protected override void HashCore(byte[] array, int ibStart, int cbSize)
		{
			m_hashAlgorithm.HashCore(array, ibStart, cbSize);
		}

		[SecurityCritical]
		protected override byte[] HashFinal()
		{
			return m_hashAlgorithm.HashFinal();
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class SHA512Cng : SHA512
	{
		private BCryptHashAlgorithm m_hashAlgorithm;

		[SecurityCritical]
		public SHA512Cng()
		{
			m_hashAlgorithm = new BCryptHashAlgorithm(CngAlgorithm.Sha512, "Microsoft Primitive Provider");
		}

		[SecurityCritical]
		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
			if (disposing)
			{
				m_hashAlgorithm.Dispose();
			}
		}

		[SecurityCritical]
		public override void Initialize()
		{
			m_hashAlgorithm.Initialize();
		}

		[SecurityCritical]
		protected override void HashCore(byte[] array, int ibStart, int cbSize)
		{
			m_hashAlgorithm.HashCore(array, ibStart, cbSize);
		}

		[SecurityCritical]
		protected override byte[] HashFinal()
		{
			return m_hashAlgorithm.HashFinal();
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class SHA512CryptoServiceProvider : SHA512
	{
		private CapiHashAlgorithm m_hashAlgorithm;

		[SecurityCritical]
		public SHA512CryptoServiceProvider()
		{
			m_hashAlgorithm = new CapiHashAlgorithm("Microsoft Enhanced RSA and AES Cryptographic Provider", CapiNative.ProviderType.RsaAes, CapiNative.AlgorithmId.Sha512);
		}

		[SecurityCritical]
		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
			if (disposing)
			{
				m_hashAlgorithm.Dispose();
			}
		}

		[SecurityCritical]
		public override void Initialize()
		{
			m_hashAlgorithm.Initialize();
		}

		[SecurityCritical]
		protected override void HashCore(byte[] array, int ibStart, int cbSize)
		{
			m_hashAlgorithm.HashCore(array, ibStart, cbSize);
		}

		[SecurityCritical]
		protected override byte[] HashFinal()
		{
			return m_hashAlgorithm.HashFinal();
		}
	}
	public enum SignatureVerificationResult
	{
		Valid = 0,
		AssemblyIdentityMismatch = 1,
		ContainingSignatureInvalid = 2,
		PublicKeyTokenMismatch = 3,
		PublisherMismatch = 4,
		SystemError = -2146869247,
		InvalidSignerCertificate = -2146869246,
		InvalidCountersignature = -2146869245,
		InvalidCertificateSignature = -2146869244,
		InvalidTimestamp = -2146869243,
		BadDigest = -2146869232,
		BasicConstraintsNotObserved = -2146869223,
		UnknownTrustProvider = -2146762751,
		UnknownVerificationAction = -2146762750,
		BadSignatureFormat = -2146762749,
		CertificateNotExplicitlyTrusted = -2146762748,
		MissingSignature = -2146762496,
		CertificateExpired = -2146762495,
		InvalidTimePeriodNesting = -2146762494,
		InvalidCertificateRole = -2146762493,
		PathLengthConstraintViolated = -2146762492,
		UnknownCriticalExtension = -2146762491,
		CertificateUsageNotAllowed = -2146762490,
		IssuerChainingError = -2146762489,
		CertificateMalformed = -2146762488,
		UntrustedRootCertificate = -2146762487,
		CouldNotBuildChain = -2146762486,
		GenericTrustFailure = -2146762485,
		CertificateRevoked = -2146762484,
		UntrustedTestRootCertificate = -2146762483,
		RevocationCheckFailure = -2146762482,
		InvalidCertificateUsage = -2146762480,
		CertificateExplicitlyDistrusted = -2146762479,
		UntrustedCertificationAuthority = -2146762478,
		InvalidCertificatePolicy = -2146762477,
		InvalidCertificateName = -2146762476
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class StrongNameSignatureInformation
	{
		private SignatureVerificationResult m_verificationResult;

		private AsymmetricAlgorithm m_publicKey;

		private static readonly string StrongNameHashAlgorithm = CapiNative.GetAlgorithmName(CapiNative.AlgorithmId.Sha1);

		public string HashAlgorithm => StrongNameHashAlgorithm;

		public int HResult => CapiNative.HResultForVerificationResult(m_verificationResult);

		public bool IsValid => m_verificationResult == SignatureVerificationResult.Valid;

		public AsymmetricAlgorithm PublicKey => m_publicKey;

		public SignatureVerificationResult VerificationResult => m_verificationResult;

		internal StrongNameSignatureInformation(AsymmetricAlgorithm publicKey)
		{
			m_verificationResult = SignatureVerificationResult.Valid;
			m_publicKey = publicKey;
		}

		internal StrongNameSignatureInformation(SignatureVerificationResult error)
		{
			m_verificationResult = error;
		}
	}
}
namespace System.Security.Cryptography.X509Certificates
{
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class AuthenticodeSignatureInformation
	{
		private string m_description;

		private Uri m_descriptionUrl;

		private CapiNative.AlgorithmId m_hashAlgorithmId;

		private X509Chain m_signatureChain;

		private TimestampInformation m_timestamp;

		private SignatureVerificationResult m_verificationResult;

		private X509Certificate2 m_signingCertificate;

		public string Description => m_description;

		public Uri DescriptionUrl => m_descriptionUrl;

		public string HashAlgorithm => CapiNative.GetAlgorithmName(m_hashAlgorithmId);

		public int HResult => CapiNative.HResultForVerificationResult(m_verificationResult);

		public X509Chain SignatureChain
		{
			[StorePermission(SecurityAction.Demand, OpenStore = true, EnumerateCertificates = true)]
			get
			{
				return m_signatureChain;
			}
		}

		public X509Certificate2 SigningCertificate
		{
			[StorePermission(SecurityAction.Demand, OpenStore = true, EnumerateCertificates = true)]
			get
			{
				if (m_signingCertificate == null && SignatureChain != null)
				{
					m_signingCertificate = SignatureChain.ChainElements[0].Certificate;
				}
				return m_signingCertificate;
			}
		}

		public TimestampInformation Timestamp => m_timestamp;

		public TrustStatus TrustStatus => VerificationResult switch
		{
			SignatureVerificationResult.Valid => TrustStatus.Trusted, 
			SignatureVerificationResult.CertificateNotExplicitlyTrusted => TrustStatus.KnownIdentity, 
			SignatureVerificationResult.CertificateExplicitlyDistrusted => TrustStatus.Untrusted, 
			_ => TrustStatus.UnknownIdentity, 
		};

		public SignatureVerificationResult VerificationResult => m_verificationResult;

		internal AuthenticodeSignatureInformation(X509Native.AXL_AUTHENTICODE_SIGNER_INFO signer, X509Chain signatureChain, TimestampInformation timestamp)
		{
			m_verificationResult = (SignatureVerificationResult)signer.dwError;
			m_hashAlgorithmId = signer.algHash;
			if (signer.pwszDescription != IntPtr.Zero)
			{
				m_description = Marshal.PtrToStringUni(signer.pwszDescription);
			}
			if (signer.pwszDescriptionUrl != IntPtr.Zero)
			{
				string uriString = Marshal.PtrToStringUni(signer.pwszDescriptionUrl);
				Uri.TryCreate(uriString, UriKind.RelativeOrAbsolute, out m_descriptionUrl);
			}
			m_signatureChain = signatureChain;
			if (timestamp != null && timestamp.VerificationResult != SignatureVerificationResult.MissingSignature)
			{
				if (timestamp.IsValid)
				{
					m_timestamp = timestamp;
				}
				else
				{
					m_verificationResult = SignatureVerificationResult.InvalidTimestamp;
				}
			}
			else
			{
				m_timestamp = null;
			}
		}

		internal AuthenticodeSignatureInformation(SignatureVerificationResult error)
		{
			m_verificationResult = error;
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class TimestampInformation
	{
		private CapiNative.AlgorithmId m_hashAlgorithmId;

		private DateTime m_timestamp;

		private X509Chain m_timestampChain;

		private SignatureVerificationResult m_verificationResult;

		private X509Certificate2 m_timestamper;

		public string HashAlgorithm => CapiNative.GetAlgorithmName(m_hashAlgorithmId);

		public int HResult => CapiNative.HResultForVerificationResult(m_verificationResult);

		public bool IsValid
		{
			get
			{
				if (VerificationResult != 0)
				{
					return VerificationResult == SignatureVerificationResult.CertificateNotExplicitlyTrusted;
				}
				return true;
			}
		}

		public X509Chain SignatureChain
		{
			[StorePermission(SecurityAction.Demand, OpenStore = true, EnumerateCertificates = true)]
			get
			{
				return m_timestampChain;
			}
		}

		public X509Certificate2 SigningCertificate
		{
			[StorePermission(SecurityAction.Demand, OpenStore = true, EnumerateCertificates = true)]
			get
			{
				if (m_timestamper == null && SignatureChain != null)
				{
					m_timestamper = SignatureChain.ChainElements[0].Certificate;
				}
				return m_timestamper;
			}
		}

		public DateTime Timestamp => m_timestamp.ToLocalTime();

		public SignatureVerificationResult VerificationResult => m_verificationResult;

		[SecurityCritical]
		internal TimestampInformation(X509Native.AXL_AUTHENTICODE_TIMESTAMPER_INFO timestamper)
		{
			m_hashAlgorithmId = timestamper.algHash;
			m_verificationResult = (SignatureVerificationResult)timestamper.dwError;
			ulong fileTime = ((ulong)(uint)timestamper.ftTimestamp.dwHighDateTime << 32) | (uint)timestamper.ftTimestamp.dwLowDateTime;
			m_timestamp = DateTime.FromFileTimeUtc((long)fileTime);
			if (timestamper.pChainContext != IntPtr.Zero)
			{
				m_timestampChain = new X509Chain(timestamper.pChainContext);
			}
		}

		internal TimestampInformation(SignatureVerificationResult error)
		{
			m_verificationResult = error;
		}
	}
	public enum TrustStatus
	{
		Untrusted,
		UnknownIdentity,
		KnownIdentity,
		Trusted
	}
	internal static class X509Native
	{
		[Flags]
		public enum AxlVerificationFlags
		{
			None = 0,
			NoRevocationCheck = 1,
			RevocationCheckEndCertOnly = 2,
			RevocationCheckEntireChain = 4,
			UrlOnlyCacheRetrieval = 8,
			LifetimeSigning = 0x10,
			TrustMicrosoftRootOnly = 0x20
		}

		[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
		public struct AXL_AUTHENTICODE_SIGNER_INFO
		{
			public int cbSize;

			public int dwError;

			public CapiNative.AlgorithmId algHash;

			public IntPtr pwszHash;

			public IntPtr pwszDescription;

			public IntPtr pwszDescriptionUrl;

			public IntPtr pChainContext;
		}

		[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
		public struct AXL_AUTHENTICODE_TIMESTAMPER_INFO
		{
			public int cbsize;

			public int dwError;

			public CapiNative.AlgorithmId algHash;

			public System.Runtime.InteropServices.ComTypes.FILETIME ftTimestamp;

			public IntPtr pChainContext;
		}

		[SuppressUnmanagedCodeSecurity]
		[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
		public static class UnsafeNativeMethods
		{
			[DllImport("mscorwks")]
			public static extern int _AxlGetIssuerPublicKeyHash(IntPtr pCertContext, out SafeAxlBufferHandle ppwszPublicKeyHash);

			[DllImport("mscorwks")]
			[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
			public static extern int CertFreeAuthenticodeSignerInfo(ref AXL_AUTHENTICODE_SIGNER_INFO pSignerInfo);

			[DllImport("mscorwks")]
			[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
			public static extern int CertFreeAuthenticodeTimestamperInfo(ref AXL_AUTHENTICODE_TIMESTAMPER_INFO pTimestamperInfo);

			[DllImport("mscorwks")]
			public static extern int CertVerifyAuthenticodeLicense(ref CapiNative.CRYPTOAPI_BLOB pLicenseBlob, AxlVerificationFlags dwFlags, [In][Out] ref AXL_AUTHENTICODE_SIGNER_INFO pSignerInfo, [In][Out] ref AXL_AUTHENTICODE_TIMESTAMPER_INFO pTimestamperInfo);
		}
	}
}
namespace System.Security.Cryptography.Xml
{
	internal sealed class ManifestSignedXml : SignedXml
	{
		private ManifestKinds m_manifest;

		private XmlDocument m_manifestXml;

		private XmlNamespaceManager m_namespaceManager;

		public ManifestSignedXml(XmlDocument manifestXml, ManifestKinds manifest)
			: base(manifestXml)
		{
			m_manifest = manifest;
			m_manifestXml = manifestXml;
			m_namespaceManager = new XmlNamespaceManager(manifestXml.NameTable);
			m_namespaceManager.AddNamespace("as", "http://schemas.microsoft.com/windows/pki/2005/Authenticode");
			m_namespaceManager.AddNamespace("asm", "urn:schemas-microsoft-com:asm.v1");
			m_namespaceManager.AddNamespace("asmv2", "urn:schemas-microsoft-com:asm.v2");
			m_namespaceManager.AddNamespace("ds", "http://www.w3.org/2000/09/xmldsig#");
			m_namespaceManager.AddNamespace("msrel", "http://schemas.microsoft.com/windows/rel/2005/reldata");
			m_namespaceManager.AddNamespace("r", "urn:mpeg:mpeg21:2003:01-REL-R-NS");
		}

		private static byte[] BackwardHexToBytes(string hex)
		{
			if (string.IsNullOrEmpty(hex) || hex.Length % 2 != 0)
			{
				return null;
			}
			byte[] array = new byte[hex.Length / 2];
			int num = hex.Length - 2;
			for (int i = 0; i < array.Length; i++)
			{
				byte? b = HexToByte(hex[num]);
				byte? b2 = HexToByte(hex[num + 1]);
				if (!b.HasValue || !b2.HasValue)
				{
					return null;
				}
				array[i] = (byte)((b.Value << 4) | b2.Value);
				num -= 2;
			}
			return array;
		}

		[SecurityCritical]
		[StorePermission(SecurityAction.Assert, EnumerateCertificates = true, OpenStore = true)]
		private X509Chain BuildSignatureChain(X509Native.AXL_AUTHENTICODE_SIGNER_INFO signer, XmlElement licenseNode, X509RevocationFlag revocationFlag, X509RevocationMode revocationMode)
		{
			X509Chain x509Chain = null;
			if (signer.dwError == -2146762487)
			{
				if (licenseNode.SelectSingleNode("r:issuer/ds:Signature/ds:KeyInfo/ds:X509Data", m_namespaceManager) is XmlElement xmlElement)
				{
					byte[] rawData = Convert.FromBase64String(xmlElement.InnerText.Trim());
					X509Certificate2 certificate = new X509Certificate2(rawData);
					x509Chain = new X509Chain();
					x509Chain.ChainPolicy.RevocationFlag = revocationFlag;
					x509Chain.ChainPolicy.RevocationMode = revocationMode;
					x509Chain.Build(certificate);
				}
			}
			else if (signer.pChainContext != IntPtr.Zero)
			{
				x509Chain = new X509Chain(signer.pChainContext);
			}
			return x509Chain;
		}

		private byte[] CalculateManifestPublicKeyToken()
		{
			if (!(m_manifestXml.SelectSingleNode("//asm:assembly/asm:assemblyIdentity", m_namespaceManager) is XmlElement xmlElement))
			{
				return null;
			}
			return HexStringToBytes(xmlElement.GetAttribute("publicKeyToken"));
		}

		[SecurityCritical]
		private unsafe static byte[] CalculateSignerPublicKeyToken(AsymmetricAlgorithm key)
		{
			if (!(key is ICspAsymmetricAlgorithm cspAsymmetricAlgorithm))
			{
				return null;
			}
			byte[] array = cspAsymmetricAlgorithm.ExportCspBlob(includePrivateParameters: false);
			SafeAxlBufferHandle ppwszPublicKeyToken;
			fixed (byte* value = array)
			{
				CapiNative.CRYPTOAPI_BLOB pCspPublicKeyBlob = default(CapiNative.CRYPTOAPI_BLOB);
				pCspPublicKeyBlob.cbData = array.Length;
				pCspPublicKeyBlob.pbData = new IntPtr(value);
				int num = CapiNative.UnsafeNativeMethods._AxlPublicKeyBlobToPublicKeyToken(ref pCspPublicKeyBlob, out ppwszPublicKeyToken);
				if (((uint)num & 0x80000000u) != 0)
				{
					return null;
				}
			}
			bool success = false;
			RuntimeHelpers.PrepareConstrainedRegions();
			try
			{
				ppwszPublicKeyToken.DangerousAddRef(ref success);
				return HexStringToBytes(Marshal.PtrToStringUni(ppwszPublicKeyToken.DangerousGetHandle()));
			}
			finally
			{
				if (success)
				{
					ppwszPublicKeyToken.DangerousRelease();
				}
			}
		}

		private static bool CompareBytes(byte[] lhs, byte[] rhs)
		{
			if (lhs == null || rhs == null)
			{
				return false;
			}
			for (int i = 0; i < lhs.Length; i++)
			{
				if (lhs[i] != rhs[i])
				{
					return false;
				}
			}
			return true;
		}

		public override XmlElement GetIdElement(XmlDocument document, string idValue)
		{
			if (base.KeyInfo != null && string.Compare(base.KeyInfo.Id, idValue, StringComparison.OrdinalIgnoreCase) == 0)
			{
				return base.KeyInfo.GetXml();
			}
			return null;
		}

		[SecurityCritical]
		private TimestampInformation GetTimestampInformation(X509Native.AXL_AUTHENTICODE_TIMESTAMPER_INFO timestamper, XmlElement licenseNode)
		{
			TimestampInformation result = null;
			if (timestamper.dwError == 0)
			{
				result = new TimestampInformation(timestamper);
			}
			else if (timestamper.dwError == -2146762748 || timestamper.dwError == -2146762496)
			{
				if (licenseNode.SelectSingleNode("r:issuer/ds:Signature/ds:Object/as:Timestamp", m_namespaceManager) is XmlElement xmlElement)
				{
					byte[] encodedMessage = Convert.FromBase64String(xmlElement.InnerText);
					try
					{
						SignedCms signedCms = new SignedCms();
						signedCms.Decode(encodedMessage);
						signedCms.CheckSignature(verifySignatureOnly: true);
						return null;
					}
					catch (CryptographicException e)
					{
						return new TimestampInformation((SignatureVerificationResult)Marshal.GetHRForException(e));
					}
				}
			}
			else
			{
				result = null;
			}
			return result;
		}

		private static byte[] HexStringToBytes(string hex)
		{
			if (string.IsNullOrEmpty(hex) || hex.Length % 2 != 0)
			{
				return null;
			}
			byte[] array = new byte[hex.Length / 2];
			for (int i = 0; i < array.Length; i++)
			{
				byte? b = HexToByte(hex[i]);
				byte? b2 = HexToByte(hex[i + 1]);
				if (!b.HasValue || !b2.HasValue)
				{
					return null;
				}
				array[i] = (byte)((b.Value << 4) | b2.Value);
			}
			return array;
		}

		private static byte? HexToByte(char hex)
		{
			if (hex >= '0' && hex <= '9')
			{
				return (byte)(hex - 48);
			}
			if (hex >= 'a' && hex <= 'f')
			{
				return (byte)(hex - 97 + 10);
			}
			if (hex >= 'A' && hex <= 'F')
			{
				return (byte)(hex - 65 + 10);
			}
			return null;
		}

		private static X509Native.AxlVerificationFlags MapRevocationFlags(X509RevocationFlag revocationFlag, X509RevocationMode revocationMode)
		{
			X509Native.AxlVerificationFlags axlVerificationFlags = X509Native.AxlVerificationFlags.None;
			axlVerificationFlags = revocationFlag switch
			{
				X509RevocationFlag.EndCertificateOnly => axlVerificationFlags | X509Native.AxlVerificationFlags.RevocationCheckEndCertOnly, 
				X509RevocationFlag.EntireChain => axlVerificationFlags | X509Native.AxlVerificationFlags.RevocationCheckEntireChain, 
				_ => axlVerificationFlags, 
			};
			return revocationMode switch
			{
				X509RevocationMode.NoCheck => axlVerificationFlags | X509Native.AxlVerificationFlags.NoRevocationCheck, 
				X509RevocationMode.Offline => axlVerificationFlags | X509Native.AxlVerificationFlags.UrlOnlyCacheRetrieval, 
				_ => axlVerificationFlags, 
			};
		}

		private SignatureVerificationResult VerifyAuthenticodeExpectedHash(XmlElement licenseNode)
		{
			if (!(licenseNode.SelectSingleNode("r:grant/as:ManifestInformation", m_namespaceManager) is XmlElement xmlElement))
			{
				return SignatureVerificationResult.BadSignatureFormat;
			}
			string attribute = xmlElement.GetAttribute("Hash");
			if (string.IsNullOrEmpty(attribute))
			{
				return SignatureVerificationResult.BadSignatureFormat;
			}
			byte[] lhs = BackwardHexToBytes(attribute);
			XmlDocument xmlDocument = new XmlDocument();
			xmlDocument.PreserveWhitespace = true;
			XmlReaderSettings xmlReaderSettings = new XmlReaderSettings();
			xmlReaderSettings.ProhibitDtd = false;
			using (TextReader input = new StringReader(m_manifestXml.OuterXml))
			{
				using XmlReader reader = XmlReader.Create(input, xmlReaderSettings, m_manifestXml.BaseURI);
				xmlDocument.Load(reader);
			}
			XmlElement xmlElement2 = xmlDocument.SelectSingleNode("//asm:assembly/ds:Signature", m_namespaceManager) as XmlElement;
			xmlElement2.ParentNode.RemoveChild(xmlElement2);
			XmlDsigExcC14NTransform xmlDsigExcC14NTransform = new XmlDsigExcC14NTransform();
			xmlDsigExcC14NTransform.LoadInput(xmlDocument);
			byte[] rhs = null;
			using (SHA1CryptoServiceProvider sHA1CryptoServiceProvider = new SHA1CryptoServiceProvider())
			{
				rhs = sHA1CryptoServiceProvider.ComputeHash(xmlDsigExcC14NTransform.GetOutput() as MemoryStream);
			}
			if (!CompareBytes(lhs, rhs))
			{
				return SignatureVerificationResult.BadDigest;
			}
			return SignatureVerificationResult.Valid;
		}

		[SecurityCritical]
		private SignatureVerificationResult VerifyAuthenticodePublisher(X509Certificate2 publisherCertificate)
		{
			if (!(m_manifestXml.SelectSingleNode("//asm:assembly/asmv2:publisherIdentity", m_namespaceManager) is XmlElement xmlElement))
			{
				return SignatureVerificationResult.BadSignatureFormat;
			}
			string attribute = xmlElement.GetAttribute("name");
			string attribute2 = xmlElement.GetAttribute("issuerKeyHash");
			if (string.IsNullOrEmpty(attribute) || string.IsNullOrEmpty(attribute2))
			{
				return SignatureVerificationResult.BadSignatureFormat;
			}
			SafeAxlBufferHandle ppwszPublicKeyHash = null;
			int num = X509Native.UnsafeNativeMethods._AxlGetIssuerPublicKeyHash(publisherCertificate.Handle, out ppwszPublicKeyHash);
			if (num != 0)
			{
				return (SignatureVerificationResult)num;
			}
			string strB = null;
			bool success = false;
			RuntimeHelpers.PrepareConstrainedRegions();
			try
			{
				ppwszPublicKeyHash.DangerousAddRef(ref success);
				strB = Marshal.PtrToStringUni(ppwszPublicKeyHash.DangerousGetHandle());
			}
			finally
			{
				if (success)
				{
					ppwszPublicKeyHash.DangerousRelease();
				}
			}
			if (string.Compare(attribute, publisherCertificate.SubjectName.Name, StringComparison.Ordinal) != 0 || string.Compare(attribute2, strB, StringComparison.Ordinal) != 0)
			{
				return SignatureVerificationResult.PublisherMismatch;
			}
			return SignatureVerificationResult.Valid;
		}

		[SecurityCritical]
		private unsafe AuthenticodeSignatureInformation VerifyAuthenticodeSignature(XmlElement signatureNode, X509RevocationFlag revocationFlag, X509RevocationMode revocationMode)
		{
			if (!(signatureNode.SelectSingleNode("ds:KeyInfo/msrel:RelData/r:license", m_namespaceManager) is XmlElement xmlElement))
			{
				return null;
			}
			SignatureVerificationResult signatureVerificationResult = VerifyAuthenticodeSignatureIdentity(xmlElement);
			if (signatureVerificationResult != 0)
			{
				return new AuthenticodeSignatureInformation(signatureVerificationResult);
			}
			SignatureVerificationResult signatureVerificationResult2 = VerifyAuthenticodeExpectedHash(xmlElement);
			if (signatureVerificationResult2 != 0)
			{
				return new AuthenticodeSignatureInformation(signatureVerificationResult2);
			}
			AuthenticodeSignatureInformation authenticodeSignatureInformation = null;
			X509Native.AXL_AUTHENTICODE_SIGNER_INFO pSignerInfo = default(X509Native.AXL_AUTHENTICODE_SIGNER_INFO);
			pSignerInfo.cbSize = Marshal.SizeOf(typeof(X509Native.AXL_AUTHENTICODE_SIGNER_INFO));
			X509Native.AXL_AUTHENTICODE_TIMESTAMPER_INFO pTimestamperInfo = default(X509Native.AXL_AUTHENTICODE_TIMESTAMPER_INFO);
			pTimestamperInfo.cbsize = Marshal.SizeOf(typeof(X509Native.AXL_AUTHENTICODE_TIMESTAMPER_INFO));
			RuntimeHelpers.PrepareConstrainedRegions();
			try
			{
				byte[] bytes = Encoding.UTF8.GetBytes(xmlElement.OuterXml);
				X509Native.AxlVerificationFlags dwFlags = MapRevocationFlags(revocationFlag, revocationMode);
				try
				{
					fixed (byte* value = bytes)
					{
						CapiNative.CRYPTOAPI_BLOB pLicenseBlob = default(CapiNative.CRYPTOAPI_BLOB);
						pLicenseBlob.cbData = bytes.Length;
						pLicenseBlob.pbData = new IntPtr(value);
						int num = X509Native.UnsafeNativeMethods.CertVerifyAuthenticodeLicense(ref pLicenseBlob, dwFlags, ref pSignerInfo, ref pTimestamperInfo);
						if (num == -2146762496)
						{
							return new AuthenticodeSignatureInformation(SignatureVerificationResult.MissingSignature);
						}
					}
				}
				finally
				{
				}
				X509Chain signatureChain = BuildSignatureChain(pSignerInfo, xmlElement, revocationFlag, revocationMode);
				TimestampInformation timestampInformation = GetTimestampInformation(pTimestamperInfo, xmlElement);
				authenticodeSignatureInformation = new AuthenticodeSignatureInformation(pSignerInfo, signatureChain, timestampInformation);
			}
			finally
			{
				X509Native.UnsafeNativeMethods.CertFreeAuthenticodeSignerInfo(ref pSignerInfo);
				X509Native.UnsafeNativeMethods.CertFreeAuthenticodeTimestamperInfo(ref pTimestamperInfo);
			}
			if (authenticodeSignatureInformation.SigningCertificate == null)
			{
				return new AuthenticodeSignatureInformation(authenticodeSignatureInformation.VerificationResult);
			}
			SignatureVerificationResult signatureVerificationResult3 = VerifyAuthenticodePublisher(authenticodeSignatureInformation.SigningCertificate);
			if (signatureVerificationResult3 != 0)
			{
				return new AuthenticodeSignatureInformation(signatureVerificationResult3);
			}
			return authenticodeSignatureInformation;
		}

		private SignatureVerificationResult VerifyAuthenticodeSignatureIdentity(XmlElement licenseNode)
		{
			XmlElement xmlElement = licenseNode.SelectSingleNode("r:grant/as:ManifestInformation/as:assemblyIdentity", m_namespaceManager) as XmlElement;
			XmlElement xmlElement2 = m_manifestXml.SelectSingleNode("//asm:assembly/asm:assemblyIdentity", m_namespaceManager) as XmlElement;
			bool flag = xmlElement2?.HasAttributes ?? false;
			bool flag2 = xmlElement?.HasAttributes ?? false;
			if (!flag || !flag2 || xmlElement2.Attributes.Count != xmlElement.Attributes.Count)
			{
				return SignatureVerificationResult.BadSignatureFormat;
			}
			foreach (XmlAttribute attribute2 in xmlElement2.Attributes)
			{
				string attribute = xmlElement.GetAttribute(attribute2.LocalName);
				if (attribute == null || string.Compare(attribute2.Value, attribute, StringComparison.Ordinal) != 0)
				{
					return SignatureVerificationResult.AssemblyIdentityMismatch;
				}
			}
			return SignatureVerificationResult.Valid;
		}

		private static SignatureVerificationResult VerifyStrongNameSignatureId(XmlElement signatureNode)
		{
			string text = null;
			for (int i = 0; i < signatureNode.Attributes.Count; i++)
			{
				if (text != null)
				{
					break;
				}
				if (string.Compare(signatureNode.Attributes[i].LocalName, "id", StringComparison.OrdinalIgnoreCase) == 0)
				{
					text = signatureNode.Attributes[i].Value;
				}
			}
			if (string.IsNullOrEmpty(text))
			{
				return SignatureVerificationResult.BadSignatureFormat;
			}
			if (string.Compare(text, "StrongNameSignature", StringComparison.Ordinal) != 0)
			{
				return SignatureVerificationResult.BadSignatureFormat;
			}
			return SignatureVerificationResult.Valid;
		}

		private static SignatureVerificationResult VerifyStrongNameSignatureTransforms(SignedInfo signedInfo)
		{
			int num = 0;
			foreach (Reference reference in signedInfo.References)
			{
				TransformChain transformChain = reference.TransformChain;
				bool flag = false;
				if (string.IsNullOrEmpty(reference.Uri))
				{
					num++;
					flag = transformChain != null && transformChain.Count == 2 && string.Compare(transformChain[0].Algorithm, "http://www.w3.org/2000/09/xmldsig#enveloped-signature", StringComparison.Ordinal) == 0 && string.Compare(transformChain[1].Algorithm, "http://www.w3.org/2001/10/xml-exc-c14n#", StringComparison.Ordinal) == 0;
				}
				else if (string.Compare(reference.Uri, "#StrongNameKeyInfo", StringComparison.Ordinal) == 0)
				{
					num++;
					flag = transformChain != null && transformChain.Count == 1 && string.Compare(transformChain[0].Algorithm, "http://www.w3.org/2001/10/xml-exc-c14n#", StringComparison.Ordinal) == 0;
				}
				else
				{
					flag = true;
				}
				if (!flag)
				{
					return SignatureVerificationResult.BadSignatureFormat;
				}
			}
			if (num == 0)
			{
				return SignatureVerificationResult.BadSignatureFormat;
			}
			return SignatureVerificationResult.Valid;
		}

		[SecurityCritical]
		private StrongNameSignatureInformation VerifyStrongNameSignature(XmlElement signatureNode)
		{
			if (!CheckSignatureReturningKey(out var signingKey))
			{
				return new StrongNameSignatureInformation(SignatureVerificationResult.BadDigest);
			}
			SignatureVerificationResult signatureVerificationResult = VerifyStrongNameSignatureId(signatureNode);
			if (signatureVerificationResult != 0)
			{
				return new StrongNameSignatureInformation(signatureVerificationResult);
			}
			SignatureVerificationResult signatureVerificationResult2 = VerifyStrongNameSignatureTransforms(base.Signature.SignedInfo);
			if (signatureVerificationResult2 != 0)
			{
				return new StrongNameSignatureInformation(signatureVerificationResult2);
			}
			if (!CompareBytes(CalculateManifestPublicKeyToken(), CalculateSignerPublicKeyToken(signingKey)))
			{
				return new StrongNameSignatureInformation(SignatureVerificationResult.PublicKeyTokenMismatch);
			}
			return new StrongNameSignatureInformation(signingKey);
		}

		[SecurityCritical]
		public ManifestSignatureInformation VerifySignature(X509RevocationFlag revocationFlag, X509RevocationMode revocationMode)
		{
			if (!(m_manifestXml.SelectSingleNode("//ds:Signature", m_namespaceManager) is XmlElement xmlElement))
			{
				return new ManifestSignatureInformation(m_manifest, null, null);
			}
			LoadXml(xmlElement);
			StrongNameSignatureInformation strongNameSignatureInformation = VerifyStrongNameSignature(xmlElement);
			AuthenticodeSignatureInformation authenticodeSignatureInformation = null;
			return new ManifestSignatureInformation(authenticodeSignature: (strongNameSignatureInformation.VerificationResult == SignatureVerificationResult.BadDigest) ? new AuthenticodeSignatureInformation(SignatureVerificationResult.ContainingSignatureInvalid) : VerifyAuthenticodeSignature(xmlElement, revocationFlag, revocationMode), manifest: m_manifest, strongNameSignature: strongNameSignatureInformation);
		}
	}
}
namespace System.Numeric
{
	[Serializable]
	[Immutable]
	[ComVisible(false)]
	internal struct BigInteger : IFormattable, IEquatable<BigInteger>, IComparable<BigInteger>, IComparable
	{
		private const int DecimalScaleFactorMask = 16711680;

		private const int DecimalSignMask = int.MinValue;

		private const int BitsPerDigit = 32;

		private const ulong Base = 4294967296uL;

		private const int UpperBoundForSchoolBookMultiplicationDigits = 64;

		private const int ForceSchoolBookMultiplicationThresholdDigits = 8;

		private static readonly uint[] maxCharsPerDigit = new uint[37]
		{
			0u, 0u, 31u, 20u, 15u, 13u, 12u, 11u, 10u, 10u,
			9u, 9u, 8u, 8u, 8u, 8u, 7u, 7u, 7u, 7u,
			7u, 7u, 7u, 7u, 6u, 6u, 6u, 6u, 6u, 6u,
			6u, 6u, 6u, 6u, 6u, 6u, 6u
		};

		private static readonly uint[] groupRadixValues = new uint[37]
		{
			0u, 0u, 2147483648u, 3486784401u, 1073741824u, 1220703125u, 2176782336u, 1977326743u, 1073741824u, 3486784401u,
			1000000000u, 2357947691u, 429981696u, 815730721u, 1475789056u, 2562890625u, 268435456u, 410338673u, 612220032u, 893871739u,
			1280000000u, 1801088541u, 2494357888u, 3404825447u, 191102976u, 244140625u, 308915776u, 387420489u, 481890304u, 594823321u,
			729000000u, 887503681u, 1073741824u, 1291467969u, 1544804416u, 1838265625u, 2176782336u
		};

		private static readonly uint[] zeroArray = new uint[0];

		private readonly short _sign;

		private readonly uint[] _data;

		private int _length;

		public static BigInteger Zero => new BigInteger(0, zeroArray);

		public static BigInteger One => new BigInteger(1);

		public static BigInteger MinusOne => new BigInteger(-1);

		public int Sign
		{
			[Pure]
			get
			{
				return _sign;
			}
		}

		private int Length
		{
			get
			{
				if (_length == -1)
				{
					_length = GetLength(_data);
				}
				return _length;
			}
		}

		public BigInteger(int value)
		{
			if (value == 0)
			{
				_sign = 0;
				_data = new uint[0];
			}
			else if (value < 0)
			{
				_sign = -1;
				_data = new uint[1] { (uint)(-value) };
			}
			else
			{
				_sign = 1;
				_data = new uint[1] { (uint)value };
			}
			_length = -1;
		}

		public BigInteger(long value)
		{
			ulong num = 0uL;
			if (value < 0)
			{
				num = (ulong)(-value);
				_sign = -1;
			}
			else if (value > 0)
			{
				num = (ulong)value;
				_sign = 1;
			}
			else
			{
				_sign = 0;
			}
			if (num >= 4294967296L)
			{
				_data = new uint[2];
				_data[0] = (uint)num;
				_data[1] = (uint)(num >> 32);
			}
			else
			{
				_data = new uint[1];
				_data[0] = (uint)num;
			}
			_length = -1;
		}

		[CLSCompliant(false)]
		public BigInteger(uint value)
		{
			if (value == 0)
			{
				_sign = 0;
			}
			else
			{
				_sign = 1;
			}
			_data = new uint[1];
			_data[0] = value;
			_length = -1;
		}

		[CLSCompliant(false)]
		public BigInteger(ulong value)
		{
			if (value == 0)
			{
				_sign = 0;
			}
			else
			{
				_sign = 1;
			}
			if (value >= 4294967296L)
			{
				_data = new uint[2];
				_data[0] = (uint)value;
				_data[1] = (uint)(value >> 32);
			}
			else
			{
				_data = new uint[1];
				_data[0] = (uint)value;
			}
			_length = -1;
		}

		public BigInteger(float value)
			: this((double)value)
		{
		}

		public BigInteger(double value)
		{
			Contract.Requires((!double.IsInfinity(value)) ? null : new OverflowException(Res.BigIntInfinity));
			Contract.Requires((!double.IsNaN(value)) ? null : new OverflowException(Res.NotANumber));
			byte[] bytes = BitConverter.GetBytes(value);
			ulong num = Mantissa(bytes);
			if (num == 0)
			{
				int num2 = Exponent(bytes);
				if (num2 == 0)
				{
					_sign = 0;
					_data = zeroArray;
					_length = 0;
					return;
				}
				BigInteger x = (IsNegative(bytes) ? Negate(One) : One);
				x = LeftShift(x, num2 - 1023);
				_sign = x._sign;
				_data = x._data;
			}
			else
			{
				int num3 = Exponent(bytes);
				num |= 0x10000000000000uL;
				BigInteger x2 = new BigInteger(num);
				x2 = ((num3 > 1075) ? LeftShift(x2, num3 - 1075) : RightShift(x2, 1075 - num3));
				_sign = (IsNegative(bytes) ? ((short)(x2._sign * -1)) : x2._sign);
				_data = x2._data;
			}
			_length = -1;
		}

		public BigInteger(decimal value)
		{
			int[] bits = decimal.GetBits(decimal.Truncate(value));
			int num = 3;
			while (num > 0 && bits[num - 1] == 0)
			{
				num--;
			}
			_length = num;
			if (num == 0)
			{
				_sign = 0;
				_data = new uint[0];
				return;
			}
			uint[] array = new uint[num];
			array[0] = (uint)bits[0];
			if (num > 1)
			{
				array[1] = (uint)bits[1];
			}
			if (num > 2)
			{
				array[2] = (uint)bits[2];
			}
			_sign = (short)(((bits[3] & int.MinValue) == 0) ? 1 : (-1));
			_data = array;
		}

		public BigInteger(byte[] value)
			: this(value, negative: false)
		{
		}

		public BigInteger(byte[] value, bool negative)
		{
			Contract.Requires((value != null) ? null : new ArgumentNullException("value"));
			int num = value.Length / 4;
			int num2 = value.Length % 4;
			if (num2 > 0)
			{
				_data = new uint[num + 1];
			}
			else
			{
				_data = new uint[num];
			}
			Buffer.BlockCopy(value, 0, _data, 0, num * 4);
			if (num2 > 0)
			{
				uint num3 = 0u;
				for (int i = 0; i < num2; i++)
				{
					num3 |= (uint)(value[num * 4 + i] << 8 * i);
				}
				_data[num] = num3;
			}
			_sign = (short)((!negative) ? 1 : (-1));
			_length = -1;
			if (Length == 0)
			{
				_sign = 0;
				_data = zeroArray;
			}
		}

		private BigInteger(int _sign, params uint[] _data)
		{
			Contract.Requires(_data != null);
			Contract.Requires(_sign >= -1 && _sign <= 1);
			Contract.Requires(_sign != 0 || GetLength(_data) == 0);
			if (GetLength(_data) == 0)
			{
				_sign = 0;
			}
			this._data = _data;
			this._sign = (short)_sign;
			_length = -1;
		}

		public static BigInteger Abs(BigInteger x)
		{
			if (x._sign == -1)
			{
				return -x;
			}
			return x;
		}

		public static BigInteger GreatestCommonDivisor(BigInteger x, BigInteger y)
		{
			Contract.Requires((x.Sign != 0) ? null : new ArgumentOutOfRangeException("x", Res.MustBePositive));
			Contract.Requires((y.Sign != 0) ? null : new ArgumentOutOfRangeException("y", Res.MustBePositive));
			x = Abs(x);
			y = Abs(y);
			int num = Compare(x, y);
			if (num == 0)
			{
				return x;
			}
			BigInteger bigInteger;
			BigInteger bigInteger2;
			if (num < 1)
			{
				bigInteger = x;
				bigInteger2 = y;
			}
			else
			{
				bigInteger = y;
				bigInteger2 = x;
			}
			do
			{
				BigInteger bigInteger3 = bigInteger2;
				DivRem(bigInteger, bigInteger2, out var remainder);
				bigInteger2 = remainder;
				bigInteger = bigInteger3;
			}
			while (bigInteger2 != 0);
			return bigInteger;
		}

		public static BigInteger Remainder(BigInteger dividend, BigInteger divisor)
		{
			DivRem(dividend, divisor, out var remainder);
			return remainder;
		}

		public static BigInteger Negate(BigInteger x)
		{
			BigInteger result = new BigInteger(-x._sign, (x._data == null) ? zeroArray : x._data);
			result._length = x._length;
			return result;
		}

		public static BigInteger Pow(BigInteger baseValue, BigInteger exponent)
		{
			Contract.Requires((exponent >= 0) ? null : new ArgumentOutOfRangeException("exponent", Res.NonNegative));
			if (exponent == 0)
			{
				return One;
			}
			BigInteger bigInteger = baseValue;
			BigInteger one = One;
			while (exponent > 0)
			{
				if ((exponent._data[0] & (true ? 1u : 0u)) != 0)
				{
					one *= bigInteger;
				}
				if (exponent == 1)
				{
					break;
				}
				bigInteger = bigInteger.Square();
				exponent = RightShift(exponent, 1);
			}
			return one;
		}

		public static BigInteger ModPow(BigInteger baseValue, BigInteger exponent, BigInteger modulus)
		{
			Contract.Requires((exponent >= 0) ? null : new ArgumentOutOfRangeException("exponent", Res.NonNegative));
			if (exponent == 0)
			{
				return One;
			}
			BigInteger bigInteger = baseValue;
			BigInteger one = One;
			while (exponent > 0)
			{
				if ((exponent._data[0] & (true ? 1u : 0u)) != 0)
				{
					one *= bigInteger;
					one %= modulus;
				}
				if (exponent == 1)
				{
					break;
				}
				bigInteger = bigInteger.Square();
				exponent = RightShift(exponent, 1);
			}
			return one;
		}

		private BigInteger Square()
		{
			return this * this;
		}

		public byte[] ToByteArray()
		{
			bool isNegative;
			return ToByteArray(out isNegative);
		}

		public byte[] ToByteArray(out bool isNegative)
		{
			int length = Length;
			byte[] array = new byte[length * 4];
			Buffer.BlockCopy(_data, 0, array, 0, length * 4);
			isNegative = _sign == -1;
			return array;
		}

		public static BigInteger operator +(BigInteger value)
		{
			return value;
		}

		public static BigInteger operator -(BigInteger value)
		{
			return Negate(value);
		}

		public static BigInteger operator ++(BigInteger value)
		{
			if (value._sign >= 0)
			{
				return new BigInteger(1, add0(value._data, value.Length, new uint[1] { 1u }, 1));
			}
			if (value.Length == 1 && value._data[0] == 1)
			{
				return Zero;
			}
			return new BigInteger(-1, sub(value._data, value.Length, new uint[1] { 1u }, 1));
		}

		public static BigInteger operator --(BigInteger value)
		{
			int length = value.Length;
			uint[] data;
			int sign;
			if (value._sign == 1)
			{
				if (length == 1 && value._data[0] == 1)
				{
					return Zero;
				}
				data = sub(value._data, length, new uint[1] { 1u }, 1);
				sign = 1;
			}
			else
			{
				data = add0(value._data, length, new uint[1] { 1u }, 1);
				sign = -1;
			}
			return new BigInteger(sign, data);
		}

		public static BigInteger operator %(BigInteger x, BigInteger y)
		{
			if (x._sign == y._sign && x.Length < y.Length)
			{
				return x;
			}
			DivRem(x, y, out var remainder);
			return remainder;
		}

		public static explicit operator byte(BigInteger value)
		{
			if (value._sign == 0)
			{
				return 0;
			}
			if (value.Length > 1)
			{
				throw new OverflowException(Res.Overflow_Byte);
			}
			if (value._data[0] > 255)
			{
				throw new OverflowException(Res.Overflow_Byte);
			}
			if (value._sign < 0)
			{
				throw new OverflowException(Res.Overflow_Byte);
			}
			return (byte)value._data[0];
		}

		[CLSCompliant(false)]
		public static explicit operator sbyte(BigInteger value)
		{
			if (value._sign == 0)
			{
				return 0;
			}
			if (value.Length > 1)
			{
				throw new OverflowException(Res.Overflow_SByte);
			}
			if (value._data[0] > 128)
			{
				throw new OverflowException(Res.Overflow_SByte);
			}
			if (value._data[0] == 128 && value._sign == 1)
			{
				throw new OverflowException(Res.Overflow_SByte);
			}
			sbyte b = (sbyte)value._data[0];
			return (sbyte)(b * (sbyte)value._sign);
		}

		public static explicit operator short(BigInteger value)
		{
			if (value._sign == 0)
			{
				return 0;
			}
			if (value.Length > 1)
			{
				throw new OverflowException(Res.Overflow_Int16);
			}
			if (value._data[0] > 32768)
			{
				throw new OverflowException(Res.Overflow_Int16);
			}
			if (value._data[0] == 32768 && value._sign == 1)
			{
				throw new OverflowException(Res.Overflow_Int16);
			}
			short num = (short)value._data[0];
			return (short)(num * value._sign);
		}

		[CLSCompliant(false)]
		public static explicit operator ushort(BigInteger value)
		{
			if (value._sign == 0)
			{
				return 0;
			}
			if (value.Length > 1)
			{
				throw new OverflowException(Res.Overflow_UInt16);
			}
			if (value._data[0] > 65535)
			{
				throw new OverflowException(Res.Overflow_UInt16);
			}
			if (value._sign < 0)
			{
				throw new OverflowException(Res.Overflow_UInt16);
			}
			return (ushort)value._data[0];
		}

		public static explicit operator int(BigInteger value)
		{
			if (value._sign == 0)
			{
				return 0;
			}
			if (value.Length > 1)
			{
				throw new OverflowException(Res.Overflow_Int32);
			}
			if (value._data[0] > 2147483648u)
			{
				throw new OverflowException(Res.Overflow_Int32);
			}
			if (value._data[0] == 2147483648u && value._sign == 1)
			{
				throw new OverflowException(Res.Overflow_Int32);
			}
			int num = (int)value._data[0];
			return num * value._sign;
		}

		[CLSCompliant(false)]
		public static explicit operator uint(BigInteger value)
		{
			if (value._sign == 0)
			{
				return 0u;
			}
			if (value.Length > 1)
			{
				throw new OverflowException(Res.Overflow_UInt32);
			}
			if (value._sign < 0)
			{
				throw new OverflowException(Res.Overflow_UInt32);
			}
			return value._data[0];
		}

		public static explicit operator long(BigInteger value)
		{
			long num = 0L;
			if (value._sign == 0)
			{
				return 0L;
			}
			if (value.Length > 2)
			{
				throw new OverflowException(Res.Overflow_Int64);
			}
			if (value.Length == 1)
			{
				return value._sign * value._data[0];
			}
			ulong num2 = ((ulong)value._data[1] << 32) | value._data[0];
			if (num2 > 9223372036854775808uL)
			{
				throw new OverflowException(Res.Overflow_Int64);
			}
			if (num2 == 9223372036854775808uL && value._sign == 1)
			{
				throw new OverflowException(Res.Overflow_Int64);
			}
			return (long)num2 * (long)value._sign;
		}

		[CLSCompliant(false)]
		public static explicit operator ulong(BigInteger value)
		{
			ulong num = 0uL;
			if (value._sign == 0)
			{
				return 0uL;
			}
			if (value._sign < 0)
			{
				throw new OverflowException(Res.Overflow_UInt64);
			}
			if (value.Length > 2)
			{
				throw new OverflowException(Res.Overflow_UInt64);
			}
			num = value._data[0];
			if (value.Length > 1)
			{
				num |= (ulong)value._data[1] << 32;
			}
			return num;
		}

		public static explicit operator float(BigInteger value)
		{
			NumberFormatInfo numberFormat = CultureInfo.InvariantCulture.NumberFormat;
			if (!float.TryParse(value.ToString(10u, useCapitalHexDigits: false, numberFormat), NumberStyles.Number, numberFormat, out var result))
			{
				throw new OverflowException(Res.Overflow_Single);
			}
			return result;
		}

		public static explicit operator double(BigInteger value)
		{
			NumberFormatInfo numberFormat = CultureInfo.InvariantCulture.NumberFormat;
			if (!double.TryParse(value.ToString(10u, useCapitalHexDigits: false, numberFormat), NumberStyles.Number, numberFormat, out var result))
			{
				throw new OverflowException(Res.Overflow_Double);
			}
			return result;
		}

		public static explicit operator decimal(BigInteger value)
		{
			if (value._sign == 0)
			{
				return 0m;
			}
			int length = value.Length;
			if (length > 3)
			{
				throw new OverflowException(Res.Overflow_Decimal);
			}
			int lo = 0;
			int mid = 0;
			int hi = 0;
			if (length > 2)
			{
				hi = (int)value._data[2];
			}
			if (length > 1)
			{
				mid = (int)value._data[1];
			}
			if (length > 0)
			{
				lo = (int)value._data[0];
			}
			return new decimal(lo, mid, hi, value._sign < 0, 0);
		}

		public static explicit operator BigInteger(float value)
		{
			return new BigInteger(value);
		}

		public static explicit operator BigInteger(double value)
		{
			return new BigInteger(value);
		}

		public static explicit operator BigInteger(decimal value)
		{
			return new BigInteger(value);
		}

		public static implicit operator BigInteger(byte value)
		{
			return new BigInteger(value);
		}

		[CLSCompliant(false)]
		public static implicit operator BigInteger(sbyte value)
		{
			return new BigInteger(value);
		}

		public static implicit operator BigInteger(short value)
		{
			return new BigInteger(value);
		}

		[CLSCompliant(false)]
		public static implicit operator BigInteger(ushort value)
		{
			return new BigInteger(value);
		}

		[Pure]
		public static implicit operator BigInteger(int value)
		{
			return new BigInteger(value);
		}

		[CLSCompliant(false)]
		public static implicit operator BigInteger(uint value)
		{
			return new BigInteger(value);
		}

		public static implicit operator BigInteger(long value)
		{
			return new BigInteger(value);
		}

		[CLSCompliant(false)]
		public static implicit operator BigInteger(ulong value)
		{
			return new BigInteger(value);
		}

		private static bool IsNegative(byte[] doubleBits)
		{
			Contract.Requires(doubleBits.Length == 8);
			return (doubleBits[7] & 0x80) != 0;
		}

		private static ushort Exponent(byte[] doubleBits)
		{
			Contract.Requires(doubleBits.Length == 8);
			return (ushort)(((ushort)(doubleBits[7] & 0x7F) << 4) | ((ushort)(doubleBits[6] & 0xF0) >> 4));
		}

		private static ulong Mantissa(byte[] doubleBits)
		{
			Contract.Requires(doubleBits.Length == 8);
			uint num = (uint)(doubleBits[0] | (doubleBits[1] << 8) | (doubleBits[2] << 16) | (doubleBits[3] << 24));
			uint num2 = (uint)(doubleBits[4] | (doubleBits[5] << 8) | ((doubleBits[6] & 0xF) << 16));
			return num | ((ulong)num2 << 32);
		}

		private static int GetLength(uint[] _data)
		{
			if (_data == null)
			{
				return 0;
			}
			int num = _data.Length - 1;
			while (num >= 0 && _data[num] == 0)
			{
				num--;
			}
			return num + 1;
		}

		private static uint[] copy(uint[] v)
		{
			uint[] array = new uint[v.Length];
			Array.Copy(v, array, v.Length);
			return array;
		}

		private static uint[] resize(uint[] v, int len)
		{
			if (v.Length == len)
			{
				return v;
			}
			uint[] array = new uint[len];
			int length = Math.Min(v.Length, len);
			Array.Copy(v, array, length);
			return array;
		}

		private static uint[] add0(uint[] x, int xl, uint[] y, int yl)
		{
			if (xl >= yl)
			{
				return InternalAdd(x, xl, y, yl);
			}
			return InternalAdd(y, yl, x, xl);
		}

		private static uint[] InternalAdd(uint[] x, int xl, uint[] y, int yl)
		{
			uint[] array = new uint[xl];
			ulong num = 0uL;
			int i;
			for (i = 0; i < yl; i++)
			{
				num = num + x[i] + y[i];
				array[i] = (uint)num;
				num >>= 32;
			}
			for (; i < xl; i++)
			{
				if (num == 0)
				{
					break;
				}
				num += x[i];
				array[i] = (uint)num;
				num >>= 32;
			}
			if (num != 0)
			{
				array = resize(array, xl + 1);
				array[i] = (uint)num;
			}
			else
			{
				for (; i < xl; i++)
				{
					array[i] = x[i];
				}
			}
			return array;
		}

		private static uint[] sub(uint[] x, int xl, uint[] y, int yl)
		{
			uint[] array = new uint[xl];
			bool flag = false;
			int i;
			for (i = 0; i < yl; i++)
			{
				uint num = x[i];
				uint num2 = y[i];
				if (flag)
				{
					if (num == 0)
					{
						num = uint.MaxValue;
						flag = true;
					}
					else
					{
						num--;
						flag = false;
					}
				}
				if (num2 > num)
				{
					flag = true;
				}
				array[i] = num - num2;
			}
			if (flag)
			{
				for (; i < xl; i++)
				{
					uint num3 = x[i];
					array[i] = num3 - 1;
					if (num3 != 0)
					{
						i++;
						break;
					}
				}
			}
			for (; i < xl; i++)
			{
				array[i] = x[i];
			}
			return array;
		}

		[Pure]
		public static int Compare(BigInteger x, BigInteger y)
		{
			if (x._sign == y._sign)
			{
				int length = x.Length;
				int length2 = y.Length;
				if (length == length2)
				{
					for (int num = length - 1; num >= 0; num--)
					{
						if (x._data[num] != y._data[num])
						{
							if (x._data[num] <= y._data[num])
							{
								return -x._sign;
							}
							return x._sign;
						}
					}
					return 0;
				}
				if (length <= length2)
				{
					return -x._sign;
				}
				return x._sign;
			}
			if (x._sign <= y._sign)
			{
				return -1;
			}
			return 1;
		}

		[Pure]
		public static bool operator ==(BigInteger x, BigInteger y)
		{
			return Compare(x, y) == 0;
		}

		[Pure]
		public static bool operator !=(BigInteger x, BigInteger y)
		{
			return Compare(x, y) != 0;
		}

		[Pure]
		public static bool operator <(BigInteger x, BigInteger y)
		{
			return Compare(x, y) < 0;
		}

		[Pure]
		public static bool operator <=(BigInteger x, BigInteger y)
		{
			return Compare(x, y) <= 0;
		}

		[Pure]
		public static bool operator >(BigInteger x, BigInteger y)
		{
			return Compare(x, y) > 0;
		}

		[Pure]
		public static bool operator >=(BigInteger x, BigInteger y)
		{
			return Compare(x, y) >= 0;
		}

		public static BigInteger Add(BigInteger x, BigInteger y)
		{
			return x + y;
		}

		public static BigInteger operator +(BigInteger x, BigInteger y)
		{
			if (x._sign == y._sign)
			{
				return new BigInteger(x._sign, add0(x._data, x.Length, y._data, y.Length));
			}
			return x - -y;
		}

		public static BigInteger Subtract(BigInteger x, BigInteger y)
		{
			return x - y;
		}

		public static BigInteger operator -(BigInteger x, BigInteger y)
		{
			int num = Compare(x, y);
			if (num == 0)
			{
				return Zero;
			}
			if (x._sign == y._sign)
			{
				uint[] data;
				switch (num * x._sign)
				{
				case 1:
					data = sub(x._data, x.Length, y._data, y.Length);
					break;
				case -1:
					data = sub(y._data, y.Length, x._data, x.Length);
					break;
				default:
					return Zero;
				}
				return new BigInteger(num, data);
			}
			uint[] data2 = add0(x._data, x.Length, y._data, y.Length);
			return new BigInteger(num, data2);
		}

		public static BigInteger Multiply(BigInteger x, BigInteger y)
		{
			int length = x.Length;
			int length2 = y.Length;
			if (length + length2 < 64 || length < 8 || length2 < 8)
			{
				return MultiplySchoolBook(x, y);
			}
			return MultiplyKaratsuba(x, y);
		}

		[Pure]
		public static BigInteger operator *(BigInteger x, BigInteger y)
		{
			return Multiply(x, y);
		}

		private static BigInteger MultiplySchoolBook(BigInteger x, BigInteger y)
		{
			int length = x.Length;
			int length2 = y.Length;
			int num = length + length2;
			uint[] data = x._data;
			uint[] data2 = y._data;
			uint[] array = new uint[num];
			for (int i = 0; i < length; i++)
			{
				uint num2 = data[i];
				int num3 = i;
				ulong num4 = 0uL;
				for (int j = 0; j < length2; j++)
				{
					num4 = (ulong)((long)num4 + (long)num2 * (long)data2[j] + array[num3]);
					array[num3++] = (uint)num4;
					num4 >>= 32;
				}
				while (num4 != 0)
				{
					num4 += array[num3];
					array[num3++] = (uint)num4;
					num4 >>= 32;
				}
			}
			return new BigInteger(x._sign * y._sign, array);
		}

		private static BigInteger MultiplyKaratsuba(BigInteger x, BigInteger y)
		{
			int num = Math.Max(x.Length, y.Length) / 2;
			if (num <= 16 || x.Length < 16 || y.Length < 16)
			{
				return MultiplySchoolBook(x, y);
			}
			int shift = 32 * num;
			BigInteger bigInteger = RightShift(x, shift);
			BigInteger bigInteger2 = x.RestrictTo(num);
			BigInteger bigInteger3 = RightShift(y, shift);
			BigInteger bigInteger4 = y.RestrictTo(num);
			BigInteger bigInteger5 = Multiply(bigInteger, bigInteger3);
			BigInteger bigInteger6 = Multiply(bigInteger2, bigInteger4);
			BigInteger bigInteger7 = Multiply(bigInteger + bigInteger2, bigInteger3 + bigInteger4);
			BigInteger bigInteger8 = bigInteger7 - (bigInteger5 + bigInteger6);
			return bigInteger6 + LeftShift(bigInteger8 + LeftShift(bigInteger5, shift), shift);
		}

		private BigInteger RestrictTo(int numDigits)
		{
			Contract.Requires(numDigits > 0);
			int num = Math.Min(numDigits, Length);
			if (num == Length)
			{
				return this;
			}
			BigInteger result = new BigInteger(_sign, _data);
			result._length = num;
			return result;
		}

		public static BigInteger Divide(BigInteger dividend, BigInteger divisor)
		{
			return dividend / divisor;
		}

		public static BigInteger operator /(BigInteger dividend, BigInteger divisor)
		{
			BigInteger remainder;
			return DivRem(dividend, divisor, out remainder);
		}

		private static int GetNormalizeShift(uint value)
		{
			int num = 0;
			if ((value & 0xFFFF0000u) == 0)
			{
				value <<= 16;
				num += 16;
			}
			if ((value & 0xFF000000u) == 0)
			{
				value <<= 8;
				num += 8;
			}
			if ((value & 0xF0000000u) == 0)
			{
				value <<= 4;
				num += 4;
			}
			if ((value & 0xC0000000u) == 0)
			{
				value <<= 2;
				num += 2;
			}
			if ((value & 0x80000000u) == 0)
			{
				value <<= 1;
				num++;
			}
			return num;
		}

		[Conditional("DEBUG")]
		private static void TestNormalize(uint[] u, uint[] un, int shift)
		{
			new BigInteger(1, u);
			BigInteger x = new BigInteger(1, un);
			RightShift(x, shift);
		}

		[Conditional("DEBUG")]
		private static void TestDivisionStep(uint[] un, uint[] vn, uint[] q, uint[] u, uint[] v)
		{
			int length = GetLength(v);
			int normalizeShift = GetNormalizeShift(v[length - 1]);
			BigInteger bigInteger = new BigInteger(1, un);
			BigInteger bigInteger2 = new BigInteger(1, vn);
			BigInteger bigInteger3 = new BigInteger(1, q);
			BigInteger x = new BigInteger(1, u);
			_ = bigInteger2 * bigInteger3 + bigInteger;
			LeftShift(x, normalizeShift);
		}

		[Conditional("DEBUG")]
		private static void TestResult(uint[] u, uint[] v, uint[] q, uint[] r)
		{
			new BigInteger(1, u);
			BigInteger bigInteger = new BigInteger(1, v);
			BigInteger bigInteger2 = new BigInteger(1, q);
			BigInteger bigInteger3 = new BigInteger(1, r);
			BigInteger bigInteger4 = bigInteger * bigInteger2;
			_ = bigInteger4 + bigInteger3;
		}

		private static void Normalize(uint[] u, int l, uint[] un, int shift)
		{
			uint num = 0u;
			int i;
			if (shift > 0)
			{
				int num2 = 32 - shift;
				for (i = 0; i < l; i++)
				{
					uint num3 = u[i];
					un[i] = (num3 << shift) | num;
					num = num3 >> num2;
				}
			}
			else
			{
				for (i = 0; i < l; i++)
				{
					un[i] = u[i];
				}
			}
			while (i < un.Length)
			{
				un[i++] = 0u;
			}
			if (num != 0)
			{
				un[l] = num;
			}
		}

		private static void Unnormalize(uint[] un, out uint[] r, int shift)
		{
			int length = GetLength(un);
			r = new uint[length];
			if (shift > 0)
			{
				int num = 32 - shift;
				uint num2 = 0u;
				for (int num3 = length - 1; num3 >= 0; num3--)
				{
					uint num4 = un[num3];
					r[num3] = (num4 >> shift) | num2;
					num2 = num4 << num;
				}
			}
			else
			{
				for (int i = 0; i < length; i++)
				{
					r[i] = un[i];
				}
			}
		}

		private static void DivModUnsigned(uint[] u, uint[] v, out uint[] q, out uint[] r)
		{
			int length = GetLength(u);
			int length2 = GetLength(v);
			if (length2 <= 1)
			{
				if (length2 == 0)
				{
					throw new DivideByZeroException();
				}
				ulong num = 0uL;
				uint num2 = v[0];
				q = new uint[length];
				r = new uint[1];
				for (int num3 = length - 1; num3 >= 0; num3--)
				{
					num *= 4294967296L;
					num += u[num3];
					ulong num4 = num / num2;
					num -= num4 * num2;
					q[num3] = (uint)num4;
				}
				r[0] = (uint)num;
			}
			else if (length >= length2)
			{
				int normalizeShift = GetNormalizeShift(v[length2 - 1]);
				uint[] array = new uint[length + 1];
				uint[] array2 = new uint[length2];
				Normalize(u, length, array, normalizeShift);
				Normalize(v, length2, array2, normalizeShift);
				q = new uint[length - length2 + 1];
				r = null;
				for (int num5 = length - length2; num5 >= 0; num5--)
				{
					ulong num6 = (ulong)(4294967296L * (long)array[num5 + length2] + array[num5 + length2 - 1]);
					ulong num7 = num6 / array2[length2 - 1];
					num6 -= num7 * array2[length2 - 1];
					while (num7 >= 4294967296L || num7 * array2[length2 - 2] > num6 * 4294967296L + array[num5 + length2 - 2])
					{
						num7--;
						num6 += array2[length2 - 1];
						if (num6 >= 4294967296L)
						{
							break;
						}
					}
					long num8 = 0L;
					long num9 = 0L;
					for (int i = 0; i < length2; i++)
					{
						ulong num10 = array2[i] * num7;
						num9 = (long)array[i + num5] - (long)(uint)num10 - num8;
						array[i + num5] = (uint)num9;
						num10 >>= 32;
						num9 >>= 32;
						num8 = (long)num10 - num9;
					}
					num9 = array[num5 + length2] - num8;
					array[num5 + length2] = (uint)num9;
					q[num5] = (uint)num7;
					if (num9 < 0)
					{
						q[num5]--;
						ulong num11 = 0uL;
						for (int i = 0; i < length2; i++)
						{
							num11 = (ulong)((long)array2[i] + (long)array[num5 + i]) + num11;
							array[num5 + i] = (uint)num11;
							num11 >>= 32;
						}
						num11 += array[num5 + length2];
						array[num5 + length2] = (uint)num11;
					}
				}
				Unnormalize(array, out r, normalizeShift);
			}
			else
			{
				q = zeroArray;
				r = u;
			}
		}

		public static BigInteger DivRem(BigInteger dividend, BigInteger divisor, out BigInteger remainder)
		{
			DivModUnsigned((dividend._data == null) ? zeroArray : dividend._data, (divisor._data == null) ? zeroArray : divisor._data, out var q, out var r);
			remainder = new BigInteger(dividend._sign, r);
			return new BigInteger(dividend._sign * divisor._sign, q);
		}

		private static BigInteger LeftShift(BigInteger x, int shift)
		{
			if (shift == 0)
			{
				return x;
			}
			if (shift < 0)
			{
				return RightShift(x, -shift);
			}
			int num = shift / 32;
			int num2 = shift - num * 32;
			int length = x.Length;
			uint[] data = x._data;
			int num3 = length + num + 1;
			uint[] array = new uint[num3];
			if (num2 == 0)
			{
				for (int i = 0; i < length; i++)
				{
					array[i + num] = data[i];
				}
			}
			else
			{
				int num4 = 32 - num2;
				uint num5 = 0u;
				int j;
				for (j = 0; j < length; j++)
				{
					uint num6 = data[j];
					array[j + num] = (num6 << num2) | num5;
					num5 = num6 >> num4;
				}
				array[j + num] = num5;
			}
			return new BigInteger(x._sign, array);
		}

		private static BigInteger RightShift(BigInteger x, int shift)
		{
			if (shift == 0)
			{
				return x;
			}
			if (shift < 0)
			{
				return LeftShift(x, -shift);
			}
			int num = shift / 32;
			int num2 = shift - num * 32;
			int length = x.Length;
			uint[] data = x._data;
			int num3 = length - num;
			if (num3 < 0)
			{
				num3 = 0;
			}
			uint[] array = new uint[num3];
			if (num2 == 0)
			{
				for (int num4 = length - 1; num4 >= num; num4--)
				{
					array[num4 - num] = data[num4];
				}
			}
			else
			{
				int num5 = 32 - num2;
				uint num6 = 0u;
				for (int num7 = length - 1; num7 >= num; num7--)
				{
					uint num8 = data[num7];
					array[num7 - num] = (num8 >> num2) | num6;
					num6 = num8 << num5;
				}
			}
			return new BigInteger(x._sign, array);
		}

		public static BigInteger Parse(string s)
		{
			return Parse(s, CultureInfo.CurrentCulture);
		}

		public static BigInteger Parse(string s, IFormatProvider provider)
		{
			return Parse(s, NumberStyles.Integer, provider);
		}

		public static BigInteger Parse(string s, NumberStyles style)
		{
			return Parse(s, style, CultureInfo.CurrentCulture);
		}

		public static BigInteger Parse(string s, NumberStyles style, IFormatProvider provider)
		{
			if (TryParse(s, style, provider, out var value, out var error))
			{
				return value;
			}
			throw new FormatException(error);
		}

		public static bool TryParse(string s, out BigInteger b)
		{
			string error;
			return TryParse(s, NumberStyles.Integer, CultureInfo.CurrentCulture, out b, out error);
		}

		public static bool TryParse(string s, NumberStyles style, IFormatProvider formatProvider, out BigInteger value)
		{
			string error;
			return TryParse(s, style, formatProvider, out value, out error);
		}

		private static bool TryParse(string s, NumberStyles style, IFormatProvider formatProvider, out BigInteger value, out string error)
		{
			Contract.Requires((s != null) ? null : new ArgumentNullException("s"));
			if (formatProvider == null)
			{
				formatProvider = CultureInfo.CurrentCulture;
			}
			if (((uint)style & 0xFFFFFDF8u) != 0)
			{
				throw new NotSupportedException(string.Format(CultureInfo.CurrentUICulture, Res.UnsupportedNumberStyle, style));
			}
			error = null;
			NumberFormatInfo numberFormatInfo = (NumberFormatInfo)formatProvider.GetFormat(typeof(NumberFormatInfo));
			uint num = (((style & NumberStyles.AllowHexSpecifier) != 0) ? 16u : 10u);
			int i = 0;
			bool flag = false;
			if ((style & NumberStyles.AllowLeadingWhite) != 0)
			{
				for (; i < s.Length && IsWhiteSpace(s[i]); i++)
				{
				}
			}
			if ((style & NumberStyles.AllowLeadingSign) != 0)
			{
				int length = numberFormatInfo.NegativeSign.Length;
				if (length + i < s.Length && string.Compare(s, i, numberFormatInfo.NegativeSign, 0, length, ignoreCase: false, CultureInfo.CurrentCulture) == 0)
				{
					flag = true;
					i += numberFormatInfo.NegativeSign.Length;
				}
			}
			value = Zero;
			BigInteger one = One;
			if (i == s.Length)
			{
				error = Res.ParsedStringWasInvalid;
				return false;
			}
			for (int num2 = s.Length - 1; num2 >= i; num2--)
			{
				if ((style & NumberStyles.AllowTrailingWhite) != 0 && IsWhiteSpace(s[num2]))
				{
					int num3 = num2;
					while (num3 >= i && IsWhiteSpace(s[num3]))
					{
						num3--;
					}
					if (num3 < i)
					{
						error = Res.ParsedStringWasInvalid;
						return false;
					}
					num2 = num3;
				}
				uint num4 = ParseSingleDigit(s[num2], num, out error);
				if (error != null)
				{
					return false;
				}
				if (num4 != 0)
				{
					value += num4 * one;
				}
				one *= (BigInteger)num;
			}
			if (value._sign == 1 && flag)
			{
				value = -value;
			}
			return true;
		}

		private static uint ParseSingleDigit(char c, ulong radix, out string error)
		{
			error = null;
			if (c >= '0' && c <= '9')
			{
				return (uint)(c - 48);
			}
			if (radix == 16)
			{
				c = (char)(c & 0xFFFFFFDFu);
				if (c >= 'A' && c <= 'F')
				{
					return (uint)(c - 65 + 10);
				}
			}
			error = Res.InvalidCharactersInString;
			return uint.MaxValue;
		}

		private static bool IsWhiteSpace(char ch)
		{
			if (ch != ' ')
			{
				if (ch >= '\t')
				{
					return ch <= '\r';
				}
				return false;
			}
			return true;
		}

		public string ToString(string format)
		{
			return ToString(format, CultureInfo.CurrentCulture);
		}

		public string ToString(IFormatProvider formatProvider)
		{
			if (formatProvider == null)
			{
				formatProvider = CultureInfo.CurrentCulture;
			}
			return ToString(10u, useCapitalHexDigits: false, (NumberFormatInfo)formatProvider.GetFormat(typeof(NumberFormatInfo)));
		}

		public string ToString(string format, IFormatProvider formatProvider)
		{
			if (formatProvider == null)
			{
				formatProvider = CultureInfo.CurrentCulture;
			}
			uint num = 10u;
			bool flag = false;
			if (!string.IsNullOrEmpty(format))
			{
				char c = format[0];
				switch (c)
				{
				case 'X':
				case 'x':
					num = 16u;
					flag = c == 'X';
					break;
				default:
					throw new NotSupportedException(string.Format(CultureInfo.CurrentCulture, "Currently not supported format: {0}", format));
				case 'D':
				case 'G':
				case 'd':
				case 'g':
					break;
				}
			}
			return ToString(num, flag, (NumberFormatInfo)formatProvider.GetFormat(typeof(NumberFormatInfo)));
		}

		public override string ToString()
		{
			return ToString(10u, useCapitalHexDigits: false, CultureInfo.CurrentCulture.NumberFormat);
		}

		private string ToString(uint radix, bool useCapitalHexDigits, NumberFormatInfo info)
		{
			Contract.Requires(radix >= 2 && radix <= 36);
			if (_sign == 0)
			{
				return "0";
			}
			_ = Length;
			List<uint> list = new List<uint>();
			uint[] n = copy(_data);
			int nl = Length;
			uint d = groupRadixValues[radix];
			while (nl > 0)
			{
				uint item = div(n, ref nl, d);
				list.Add(item);
			}
			StringBuilder stringBuilder = new StringBuilder();
			if (_sign == -1)
			{
				stringBuilder.Append(info.NegativeSign);
			}
			int num = list.Count - 1;
			char[] tmp = new char[maxCharsPerDigit[radix]];
			AppendRadix(list[num--], radix, useCapitalHexDigits, tmp, stringBuilder, leadingZeros: false);
			while (num >= 0)
			{
				AppendRadix(list[num--], radix, useCapitalHexDigits, tmp, stringBuilder, leadingZeros: true);
			}
			return stringBuilder.ToString();
		}

		private static void AppendRadix(uint rem, uint radix, bool useCapitalHexDigits, char[] tmp, StringBuilder buf, bool leadingZeros)
		{
			string text = (useCapitalHexDigits ? "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" : "0123456789abcdefghijklmnopqrstuvwxyz");
			int num = tmp.Length;
			int num2 = num;
			while (num2 > 0 && (leadingZeros || rem != 0))
			{
				uint index = rem % radix;
				rem /= radix;
				tmp[--num2] = text[(int)index];
			}
			if (leadingZeros)
			{
				buf.Append(tmp);
			}
			else
			{
				buf.Append(tmp, num2, num - num2);
			}
		}

		private static uint div(uint[] n, ref int nl, uint d)
		{
			ulong num = 0uL;
			int num2 = nl;
			bool flag = false;
			while (--num2 >= 0)
			{
				num <<= 32;
				num |= n[num2];
				if ((n[num2] = (uint)(num / d)) == 0)
				{
					if (!flag)
					{
						nl--;
					}
				}
				else
				{
					flag = true;
				}
				num %= d;
			}
			return (uint)num;
		}

		public override int GetHashCode()
		{
			if (_sign == 0)
			{
				return 0;
			}
			return (int)_data[0];
		}

		public bool Equals(BigInteger other)
		{
			if (_sign != other._sign)
			{
				return false;
			}
			int length = Length;
			int length2 = other.Length;
			if (length != length2)
			{
				return false;
			}
			for (uint num = 0u; num < length; num++)
			{
				if (_data[num] != other._data[num])
				{
					return false;
				}
			}
			return true;
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
			{
				return false;
			}
			if (!(obj is BigInteger))
			{
				return false;
			}
			return Equals((BigInteger)obj);
		}

		public int CompareTo(BigInteger other)
		{
			return Compare(this, other);
		}

		public int CompareTo(object obj)
		{
			if (obj == null)
			{
				return 1;
			}
			if (!(obj is BigInteger))
			{
				throw new ArgumentException(Res.MustBeBigInt);
			}
			return Compare(this, (BigInteger)obj);
		}
	}
}
namespace Microsoft.Win32
{
	internal sealed class NativeMethods
	{
		internal struct SystemTime
		{
			[MarshalAs(UnmanagedType.U2)]
			public short Year;

			[MarshalAs(UnmanagedType.U2)]
			public short Month;

			[MarshalAs(UnmanagedType.U2)]
			public short DayOfWeek;

			[MarshalAs(UnmanagedType.U2)]
			public short Day;

			[MarshalAs(UnmanagedType.U2)]
			public short Hour;

			[MarshalAs(UnmanagedType.U2)]
			public short Minute;

			[MarshalAs(UnmanagedType.U2)]
			public short Second;

			[MarshalAs(UnmanagedType.U2)]
			public short Milliseconds;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct TimeZoneInformation
		{
			[MarshalAs(UnmanagedType.I4)]
			public int Bias;

			[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]
			public string StandardName;

			public SystemTime StandardDate;

			[MarshalAs(UnmanagedType.I4)]
			public int StandardBias;

			[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]
			public string DaylightName;

			public SystemTime DaylightDate;

			[MarshalAs(UnmanagedType.I4)]
			public int DaylightBias;

			public TimeZoneInformation(DynamicTimeZoneInformation dtzi)
			{
				Bias = dtzi.Bias;
				StandardName = dtzi.StandardName;
				StandardDate = dtzi.StandardDate;
				StandardBias = dtzi.StandardBias;
				DaylightName = dtzi.DaylightName;
				DaylightDate = dtzi.DaylightDate;
				DaylightBias = dtzi.DaylightBias;
			}
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct DynamicTimeZoneInformation
		{
			[MarshalAs(UnmanagedType.I4)]
			public int Bias;

			[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]
			public string StandardName;

			public SystemTime StandardDate;

			[MarshalAs(UnmanagedType.I4)]
			public int StandardBias;

			[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]
			public string DaylightName;

			public SystemTime DaylightDate;

			[MarshalAs(UnmanagedType.I4)]
			public int DaylightBias;

			[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
			public string TimeZoneKeyName;
		}

		internal struct RegistryTimeZoneInformation
		{
			[MarshalAs(UnmanagedType.I4)]
			public int Bias;

			[MarshalAs(UnmanagedType.I4)]
			public int StandardBias;

			[MarshalAs(UnmanagedType.I4)]
			public int DaylightBias;

			public SystemTime StandardDate;

			public SystemTime DaylightDate;

			public RegistryTimeZoneInformation(TimeZoneInformation tzi)
			{
				Bias = tzi.Bias;
				StandardDate = tzi.StandardDate;
				StandardBias = tzi.StandardBias;
				DaylightDate = tzi.DaylightDate;
				DaylightBias = tzi.DaylightBias;
			}

			public RegistryTimeZoneInformation(byte[] bytes)
			{
				if (bytes == null || bytes.Length != 44)
				{
					throw new ArgumentException(System.SR.GetString("Argument_InvalidREG_TZI_FORMAT"), "bytes");
				}
				Bias = BitConverter.ToInt32(bytes, 0);
				StandardBias = BitConverter.ToInt32(bytes, 4);
				DaylightBias = BitConverter.ToInt32(bytes, 8);
				StandardDate.Year = BitConverter.ToInt16(bytes, 12);
				StandardDate.Month = BitConverter.ToInt16(bytes, 14);
				StandardDate.DayOfWeek = BitConverter.ToInt16(bytes, 16);
				StandardDate.Day = BitConverter.ToInt16(bytes, 18);
				StandardDate.Hour = BitConverter.ToInt16(bytes, 20);
				StandardDate.Minute = BitConverter.ToInt16(bytes, 22);
				StandardDate.Second = BitConverter.ToInt16(bytes, 24);
				StandardDate.Milliseconds = BitConverter.ToInt16(bytes, 26);
				DaylightDate.Year = BitConverter.ToInt16(bytes, 28);
				DaylightDate.Month = BitConverter.ToInt16(bytes, 30);
				DaylightDate.DayOfWeek = BitConverter.ToInt16(bytes, 32);
				DaylightDate.Day = BitConverter.ToInt16(bytes, 34);
				DaylightDate.Hour = BitConverter.ToInt16(bytes, 36);
				DaylightDate.Minute = BitConverter.ToInt16(bytes, 38);
				DaylightDate.Second = BitConverter.ToInt16(bytes, 40);
				DaylightDate.Milliseconds = BitConverter.ToInt16(bytes, 42);
			}
		}

		internal const int TIME_ZONE_ID_INVALID = -1;

		internal const int TIME_ZONE_ID_UNKNOWN = 0;

		internal const int TIME_ZONE_ID_STANDARD = 1;

		internal const int TIME_ZONE_ID_DAYLIGHT = 2;

		internal const int MAX_PATH = 260;

		internal const int MUI_LANGUAGE_ID = 4;

		internal const int MUI_LANGUAGE_NAME = 8;

		internal const int MUI_PREFERRED_UI_LANGUAGES = 16;

		internal const int MUI_INSTALLED_LANGUAGES = 32;

		internal const int MUI_ALL_LANGUAGES = 64;

		internal const int MUI_LANG_NEUTRAL_PE_FILE = 256;

		internal const int MUI_NON_LANG_NEUTRAL_FILE = 512;

		internal const int LOAD_LIBRARY_AS_DATAFILE = 2;

		internal const int LOAD_STRING_MAX_LENGTH = 500;

		private NativeMethods()
		{
		}
	}
	[SuppressUnmanagedCodeSecurity]
	internal static class UnsafeNativeMethods
	{
		[StructLayout(LayoutKind.Sequential)]
		internal class SECURITY_ATTRIBUTES
		{
			internal int nLength;

			internal unsafe byte* pSecurityDescriptor;

			internal int bInheritHandle;
		}

		internal unsafe delegate void EtwEnableCallback([In] ref Guid sourceId, [In] int isEnabled, [In] byte level, [In] long matchAnyKeywords, [In] long matchAllKeywords, [In] void* filterData, [In] void* callbackContext);

		[StructLayout(LayoutKind.Explicit, Size = 40)]
		internal struct PerfCounterSetInfoStruct
		{
			[FieldOffset(0)]
			internal Guid CounterSetGuid;

			[FieldOffset(16)]
			internal Guid ProviderGuid;

			[FieldOffset(32)]
			internal uint NumCounters;

			[FieldOffset(36)]
			internal uint InstanceType;
		}

		[StructLayout(LayoutKind.Explicit, Size = 32)]
		internal struct PerfCounterInfoStruct
		{
			[FieldOffset(0)]
			internal uint CounterId;

			[FieldOffset(4)]
			internal uint CounterType;

			[FieldOffset(8)]
			internal long Attrib;

			[FieldOffset(16)]
			internal uint Size;

			[FieldOffset(20)]
			internal uint DetailLevel;

			[FieldOffset(24)]
			internal uint Scale;

			[FieldOffset(28)]
			internal uint Offset;
		}

		[StructLayout(LayoutKind.Explicit, Size = 32)]
		internal struct PerfCounterSetInstanceStruct
		{
			[FieldOffset(0)]
			internal Guid CounterSetGuid;

			[FieldOffset(16)]
			internal uint dwSize;

			[FieldOffset(20)]
			internal uint InstanceId;

			[FieldOffset(24)]
			internal uint InstanceNameOffset;

			[FieldOffset(28)]
			internal uint InstanceNameSize;
		}

		internal unsafe delegate uint PERFLIBREQUEST([In] uint RequestCode, [In] void* Buffer, [In] uint BufferSize);

		[Flags]
		internal enum EvtQueryFlags
		{
			EvtQueryChannelPath = 1,
			EvtQueryFilePath = 2,
			EvtQueryForwardDirection = 0x100,
			EvtQueryReverseDirection = 0x200,
			EvtQueryTolerateQueryErrors = 0x1000
		}

		[Flags]
		internal enum EvtSubscribeFlags
		{
			EvtSubscribeToFutureEvents = 1,
			EvtSubscribeStartAtOldestRecord = 2,
			EvtSubscribeStartAfterBookmark = 3,
			EvtSubscribeTolerateQueryErrors = 0x1000,
			EvtSubscribeStrict = 0x10000
		}

		internal enum NativeErrorCodes : uint
		{
			ERROR_SUCCESS = 0u,
			ERROR_INVALID_PARAMETER = 87u,
			ERROR_INSUFFICIENT_BUFFER = 122u,
			ERROR_NO_MORE_ITEMS = 259u,
			ERROR_RESOURCE_LANG_NOT_FOUND = 1815u,
			ERROR_EVT_MESSAGE_NOT_FOUND = 15027u,
			ERROR_EVT_MESSAGE_ID_NOT_FOUND = 15028u,
			ERROR_EVT_UNRESOLVED_VALUE_INSERT = 15029u,
			ERROR_EVT_MESSAGE_LOCALE_NOT_FOUND = 15033u,
			ERROR_MUI_FILE_NOT_FOUND = 15100u
		}

		internal enum EvtVariantType
		{
			EvtVarTypeNull = 0,
			EvtVarTypeString = 1,
			EvtVarTypeAnsiString = 2,
			EvtVarTypeSByte = 3,
			EvtVarTypeByte = 4,
			EvtVarTypeInt16 = 5,
			EvtVarTypeUInt16 = 6,
			EvtVarTypeInt32 = 7,
			EvtVarTypeUInt32 = 8,
			EvtVarTypeInt64 = 9,
			EvtVarTypeUInt64 = 10,
			EvtVarTypeSingle = 11,
			EvtVarTypeDouble = 12,
			EvtVarTypeBoolean = 13,
			EvtVarTypeBinary = 14,
			EvtVarTypeGuid = 15,
			EvtVarTypeSizeT = 16,
			EvtVarTypeFileTime = 17,
			EvtVarTypeSysTime = 18,
			EvtVarTypeSid = 19,
			EvtVarTypeHexInt32 = 20,
			EvtVarTypeHexInt64 = 21,
			EvtVarTypeEvtHandle = 32,
			EvtVarTypeEvtXml = 35,
			EvtVarTypeStringArray = 129,
			EvtVarTypeUInt32Array = 136
		}

		internal enum EvtMasks
		{
			EVT_VARIANT_TYPE_MASK = 127,
			EVT_VARIANT_TYPE_ARRAY
		}

		[StructLayout(LayoutKind.Explicit, CharSet = CharSet.Auto)]
		internal struct EvtVariant
		{
			[FieldOffset(0)]
			public uint UInteger;

			[FieldOffset(0)]
			public int Integer;

			[FieldOffset(0)]
			public byte UInt8;

			[FieldOffset(0)]
			public short Short;

			[FieldOffset(0)]
			public ushort UShort;

			[FieldOffset(0)]
			public uint Bool;

			[FieldOffset(0)]
			public byte ByteVal;

			[FieldOffset(0)]
			public byte SByte;

			[FieldOffset(0)]
			public ulong ULong;

			[FieldOffset(0)]
			public long Long;

			[FieldOffset(0)]
			public double Double;

			[FieldOffset(0)]
			public IntPtr StringVal;

			[FieldOffset(0)]
			public IntPtr AnsiString;

			[FieldOffset(0)]
			public IntPtr SidVal;

			[FieldOffset(0)]
			public IntPtr Binary;

			[FieldOffset(0)]
			public IntPtr Reference;

			[FieldOffset(0)]
			public IntPtr Handle;

			[FieldOffset(0)]
			public IntPtr GuidReference;

			[FieldOffset(0)]
			public ulong FileTime;

			[FieldOffset(0)]
			public IntPtr SystemTime;

			[FieldOffset(8)]
			public uint Count;

			[FieldOffset(12)]
			public uint Type;
		}

		internal enum EvtEventPropertyId
		{
			EvtEventQueryIDs,
			EvtEventPath
		}

		internal enum EvtQueryPropertyId
		{
			EvtQueryNames,
			EvtQueryStatuses
		}

		internal enum EvtPublisherMetadataPropertyId
		{
			EvtPublisherMetadataPublisherGuid,
			EvtPublisherMetadataResourceFilePath,
			EvtPublisherMetadataParameterFilePath,
			EvtPublisherMetadataMessageFilePath,
			EvtPublisherMetadataHelpLink,
			EvtPublisherMetadataPublisherMessageID,
			EvtPublisherMetadataChannelReferences,
			EvtPublisherMetadataChannelReferencePath,
			EvtPublisherMetadataChannelReferenceIndex,
			EvtPublisherMetadataChannelReferenceID,
			EvtPublisherMetadataChannelReferenceFlags,
			EvtPublisherMetadataChannelReferenceMessageID,
			EvtPublisherMetadataLevels,
			EvtPublisherMetadataLevelName,
			EvtPublisherMetadataLevelValue,
			EvtPublisherMetadataLevelMessageID,
			EvtPublisherMetadataTasks,
			EvtPublisherMetadataTaskName,
			EvtPublisherMetadataTaskEventGuid,
			EvtPublisherMetadataTaskValue,
			EvtPublisherMetadataTaskMessageID,
			EvtPublisherMetadataOpcodes,
			EvtPublisherMetadataOpcodeName,
			EvtPublisherMetadataOpcodeValue,
			EvtPublisherMetadataOpcodeMessageID,
			EvtPublisherMetadataKeywords,
			EvtPublisherMetadataKeywordName,
			EvtPublisherMetadataKeywordValue,
			EvtPublisherMetadataKeywordMessageID
		}

		internal enum EvtChannelReferenceFlags
		{
			EvtChannelReferenceImported = 1
		}

		internal enum EvtEventMetadataPropertyId
		{
			EventMetadataEventID,
			EventMetadataEventVersion,
			EventMetadataEventChannel,
			EventMetadataEventLevel,
			EventMetadataEventOpcode,
			EventMetadataEventTask,
			EventMetadataEventKeyword,
			EventMetadataEventMessageID,
			EventMetadataEventTemplate
		}

		internal enum EvtChannelConfigPropertyId
		{
			EvtChannelConfigEnabled,
			EvtChannelConfigIsolation,
			EvtChannelConfigType,
			EvtChannelConfigOwningPublisher,
			EvtChannelConfigClassicEventlog,
			EvtChannelConfigAccess,
			EvtChannelLoggingConfigRetention,
			EvtChannelLoggingConfigAutoBackup,
			EvtChannelLoggingConfigMaxSize,
			EvtChannelLoggingConfigLogFilePath,
			EvtChannelPublishingConfigLevel,
			EvtChannelPublishingConfigKeywords,
			EvtChannelPublishingConfigControlGuid,
			EvtChannelPublishingConfigBufferSize,
			EvtChannelPublishingConfigMinBuffers,
			EvtChannelPublishingConfigMaxBuffers,
			EvtChannelPublishingConfigLatency,
			EvtChannelPublishingConfigClockType,
			EvtChannelPublishingConfigSidType,
			EvtChannelPublisherList,
			EvtChannelConfigPropertyIdEND
		}

		internal enum EvtLogPropertyId
		{
			EvtLogCreationTime,
			EvtLogLastAccessTime,
			EvtLogLastWriteTime,
			EvtLogFileSize,
			EvtLogAttributes,
			EvtLogNumberOfLogRecords,
			EvtLogOldestRecordNumber,
			EvtLogFull
		}

		internal enum EvtExportLogFlags
		{
			EvtExportLogChannelPath = 1,
			EvtExportLogFilePath = 2,
			EvtExportLogTolerateQueryErrors = 0x1000
		}

		internal enum EvtRenderContextFlags
		{
			EvtRenderContextValues,
			EvtRenderContextSystem,
			EvtRenderContextUser
		}

		internal enum EvtRenderFlags
		{
			EvtRenderEventValues,
			EvtRenderEventXml,
			EvtRenderBookmark
		}

		internal enum EvtFormatMessageFlags
		{
			EvtFormatMessageEvent = 1,
			EvtFormatMessageLevel,
			EvtFormatMessageTask,
			EvtFormatMessageOpcode,
			EvtFormatMessageKeyword,
			EvtFormatMessageChannel,
			EvtFormatMessageProvider,
			EvtFormatMessageId,
			EvtFormatMessageXml
		}

		internal enum EvtSystemPropertyId
		{
			EvtSystemProviderName,
			EvtSystemProviderGuid,
			EvtSystemEventID,
			EvtSystemQualifiers,
			EvtSystemLevel,
			EvtSystemTask,
			EvtSystemOpcode,
			EvtSystemKeywords,
			EvtSystemTimeCreated,
			EvtSystemEventRecordId,
			EvtSystemActivityID,
			EvtSystemRelatedActivityID,
			EvtSystemProcessID,
			EvtSystemThreadID,
			EvtSystemChannel,
			EvtSystemComputer,
			EvtSystemUserID,
			EvtSystemVersion,
			EvtSystemPropertyIdEND
		}

		internal enum EvtLoginClass
		{
			EvtRpcLogin = 1
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
		internal struct EvtRpcLogin
		{
			[MarshalAs(UnmanagedType.LPWStr)]
			public string Server;

			[MarshalAs(UnmanagedType.LPWStr)]
			public string User;

			[MarshalAs(UnmanagedType.LPWStr)]
			public string Domain;

			public CoTaskMemUnicodeSafeHandle Password;

			public int Flags;
		}

		[Flags]
		internal enum EvtSeekFlags
		{
			EvtSeekRelativeToFirst = 1,
			EvtSeekRelativeToLast = 2,
			EvtSeekRelativeToCurrent = 3,
			EvtSeekRelativeToBookmark = 4,
			EvtSeekOriginMask = 7,
			EvtSeekStrict = 0x10000
		}

		[StructLayout(LayoutKind.Explicit, CharSet = CharSet.Auto)]
		internal struct EvtStringVariant
		{
			[FieldOffset(0)]
			[MarshalAs(UnmanagedType.LPWStr)]
			public string StringVal;

			[FieldOffset(8)]
			public uint Count;

			[FieldOffset(12)]
			public uint Type;
		}

		internal const string KERNEL32 = "kernel32.dll";

		internal const string ADVAPI32 = "advapi32.dll";

		internal const int ERROR_HANDLE_EOF = 38;

		internal const int ERROR_INVALID_DRIVE = 15;

		internal const int ERROR_NO_MORE_FILES = 18;

		internal const int ERROR_NOT_READY = 21;

		internal const int ERROR_BAD_LENGTH = 24;

		internal const int ERROR_SHARING_VIOLATION = 32;

		internal const int ERROR_FILE_EXISTS = 80;

		internal const int ERROR_OPERATION_ABORTED = 995;

		internal const int ERROR_INVALID_HANDLE = 6;

		internal const int ERROR_INVALID_NAME = 123;

		internal const int ERROR_BAD_PATHNAME = 161;

		internal const int ERROR_ALREADY_EXISTS = 183;

		internal const int ERROR_ENVVAR_NOT_FOUND = 203;

		internal const int ERROR_FILENAME_EXCED_RANGE = 206;

		internal const int ERROR_MORE_DATA = 234;

		internal const int ERROR_NOT_FOUND = 1168;

		internal const int SECURITY_SQOS_PRESENT = 1048576;

		internal const int SECURITY_ANONYMOUS = 0;

		internal const int SECURITY_IDENTIFICATION = 65536;

		internal const int SECURITY_IMPERSONATION = 131072;

		internal const int SECURITY_DELEGATION = 196608;

		internal const int ERROR_BROKEN_PIPE = 109;

		internal const int ERROR_IO_PENDING = 997;

		internal const int ERROR_PIPE_BUSY = 231;

		internal const int ERROR_NO_DATA = 232;

		internal const int ERROR_PIPE_NOT_CONNECTED = 233;

		internal const int ERROR_PIPE_CONNECTED = 535;

		internal const int ERROR_PIPE_LISTENING = 536;

		internal const int ERROR_FILE_NOT_FOUND = 2;

		internal const int ERROR_PATH_NOT_FOUND = 3;

		internal const int ERROR_ACCESS_DENIED = 5;

		internal const int ERROR_INVALID_PARAMETER = 87;

		internal const int GENERIC_READ = int.MinValue;

		internal const int GENERIC_WRITE = 1073741824;

		internal const int STD_INPUT_HANDLE = -10;

		internal const int STD_OUTPUT_HANDLE = -11;

		internal const int STD_ERROR_HANDLE = -12;

		internal const int DUPLICATE_SAME_ACCESS = 2;

		internal const int PIPE_ACCESS_INBOUND = 1;

		internal const int PIPE_ACCESS_OUTBOUND = 2;

		internal const int PIPE_ACCESS_DUPLEX = 3;

		internal const int PIPE_TYPE_BYTE = 0;

		internal const int PIPE_TYPE_MESSAGE = 4;

		internal const int PIPE_READMODE_BYTE = 0;

		internal const int PIPE_READMODE_MESSAGE = 2;

		internal const int PIPE_UNLIMITED_INSTANCES = 255;

		internal const int FILE_FLAG_FIRST_PIPE_INSTANCE = 524288;

		internal const int FILE_SHARE_READ = 1;

		internal const int FILE_SHARE_WRITE = 2;

		internal const int FILE_ATTRIBUTE_NORMAL = 128;

		internal const int FILE_FLAG_OVERLAPPED = 1073741824;

		internal const int OPEN_EXISTING = 3;

		internal const int ERROR_SUCCESS = 0;

		internal const int FILE_TYPE_DISK = 1;

		internal const int FILE_TYPE_CHAR = 2;

		internal const int FILE_TYPE_PIPE = 3;

		internal const int ERROR_ARITHMETIC_OVERFLOW = 534;

		internal const int ERROR_NOT_ENOUGH_MEMORY = 8;

		internal const int SEM_FAILCRITICALERRORS = 1;

		private const int FORMAT_MESSAGE_IGNORE_INSERTS = 512;

		private const int FORMAT_MESSAGE_FROM_SYSTEM = 4096;

		private const int FORMAT_MESSAGE_ARGUMENT_ARRAY = 8192;

		internal static readonly IntPtr NULL = IntPtr.Zero;

		[DllImport("kernel32.dll")]
		internal static extern int GetFileType(SafeFileHandle handle);

		[DllImport("kernel32.dll", SetLastError = true)]
		internal unsafe static extern int WriteFile(SafeFileHandle handle, byte* bytes, int numBytesToWrite, out int numBytesWritten, NativeOverlapped* lpOverlapped);

		[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		private static extern SafeFileHandle CreateFile(string lpFileName, int dwDesiredAccess, FileShare dwShareMode, SECURITY_ATTRIBUTES securityAttrs, FileMode dwCreationDisposition, int dwFlagsAndAttributes, IntPtr hTemplateFile);

		[SecurityCritical]
		internal static SafeFileHandle SafeCreateFile(string lpFileName, int dwDesiredAccess, FileShare dwShareMode, SECURITY_ATTRIBUTES securityAttrs, FileMode dwCreationDisposition, int dwFlagsAndAttributes, IntPtr hTemplateFile)
		{
			SafeFileHandle safeFileHandle = CreateFile(lpFileName, dwDesiredAccess, dwShareMode, securityAttrs, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
			if (!safeFileHandle.IsInvalid)
			{
				int fileType = GetFileType(safeFileHandle);
				if (fileType != 1)
				{
					safeFileHandle.Dispose();
					throw new NotSupportedException(System.SR.GetString("NotSupported_IONonFileDevices"));
				}
			}
			return safeFileHandle;
		}

		[DllImport("kernel32.dll")]
		internal static extern int SetErrorMode(int newMode);

		[DllImport("kernel32.dll", EntryPoint = "SetFilePointer", SetLastError = true)]
		private unsafe static extern int SetFilePointerWin32(SafeFileHandle handle, int lo, int* hi, int origin);

		[SecurityCritical]
		internal unsafe static long SetFilePointer(SafeFileHandle handle, long offset, SeekOrigin origin, out int hr)
		{
			hr = 0;
			int lo = (int)offset;
			int num = (int)(offset >> 32);
			lo = SetFilePointerWin32(handle, lo, &num, (int)origin);
			if (lo == -1 && (hr = Marshal.GetLastWin32Error()) != 0)
			{
				return -1L;
			}
			return (long)(((ulong)(uint)num << 32) | (uint)lo);
		}

		internal static int MakeHRFromErrorCode(int errorCode)
		{
			return -2147024896 | errorCode;
		}

		[DllImport("kernel32.dll", BestFitMapping = false, CharSet = CharSet.Auto)]
		internal static extern int FormatMessage(int dwFlags, IntPtr lpSource, int dwMessageId, int dwLanguageId, StringBuilder lpBuffer, int nSize, IntPtr va_list_arguments);

		[SecurityCritical]
		internal static string GetMessage(int errorCode)
		{
			StringBuilder stringBuilder = new StringBuilder(512);
			if (FormatMessage(12800, NULL, errorCode, 0, stringBuilder, stringBuilder.Capacity, NULL) != 0)
			{
				return stringBuilder.ToString();
			}
			return "UnknownError_Num " + errorCode;
		}

		[DllImport("kernel32.dll", ExactSpelling = true, SetLastError = true)]
		internal static extern int GetTimeZoneInformation(out NativeMethods.TimeZoneInformation lpTimeZoneInformation);

		[DllImport("kernel32.dll", ExactSpelling = true, SetLastError = true)]
		internal static extern int GetDynamicTimeZoneInformation(out NativeMethods.DynamicTimeZoneInformation lpDynamicTimeZoneInformation);

		[DllImport("kernel32.dll", ExactSpelling = true, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool GetFileMUIPath(int flags, [MarshalAs(UnmanagedType.LPWStr)] string filePath, [MarshalAs(UnmanagedType.LPWStr)] StringBuilder language, ref int languageLength, [MarshalAs(UnmanagedType.LPWStr)] StringBuilder fileMuiPath, ref int fileMuiPathLength, ref long enumerator);

		[DllImport("user32.dll", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Unicode, EntryPoint = "LoadStringW", ExactSpelling = true, SetLastError = true)]
		[SecurityCritical]
		internal static extern int LoadString(SafeLibraryHandle handle, int id, StringBuilder buffer, int bufferLength);

		[DllImport("kernel32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
		[SecurityCritical]
		internal static extern SafeLibraryHandle LoadLibraryEx(string libFilename, IntPtr reserved, int flags);

		[DllImport("kernel32.dll", CharSet = CharSet.Unicode)]
		[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool FreeLibrary(IntPtr hModule);

		[DllImport("kernel32.dll", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool CloseHandle(IntPtr handle);

		[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		internal static extern IntPtr GetCurrentProcess();

		[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool DuplicateHandle(IntPtr hSourceProcessHandle, SafePipeHandle hSourceHandle, IntPtr hTargetProcessHandle, out SafePipeHandle lpTargetHandle, uint dwDesiredAccess, [MarshalAs(UnmanagedType.Bool)] bool bInheritHandle, uint dwOptions);

		[DllImport("kernel32.dll")]
		internal static extern int GetFileType(SafePipeHandle handle);

		[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool CreatePipe(out SafePipeHandle hReadPipe, out SafePipeHandle hWritePipe, SECURITY_ATTRIBUTES lpPipeAttributes, int nSize);

		[DllImport("kernel32.dll", BestFitMapping = false, CharSet = CharSet.Auto, EntryPoint = "CreateFile", SetLastError = true)]
		internal static extern SafePipeHandle CreateNamedPipeClient(string lpFileName, int dwDesiredAccess, FileShare dwShareMode, SECURITY_ATTRIBUTES securityAttrs, FileMode dwCreationDisposition, int dwFlagsAndAttributes, IntPtr hTemplateFile);

		[DllImport("kernel32.dll", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal unsafe static extern bool ConnectNamedPipe(SafePipeHandle handle, NativeOverlapped* overlapped);

		[DllImport("kernel32.dll", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool ConnectNamedPipe(SafePipeHandle handle, IntPtr overlapped);

		[DllImport("kernel32.dll", BestFitMapping = false, CharSet = CharSet.Auto, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool WaitNamedPipe(string name, int timeout);

		[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool GetNamedPipeHandleState(SafePipeHandle hNamedPipe, out int lpState, IntPtr lpCurInstances, IntPtr lpMaxCollectionCount, IntPtr lpCollectDataTimeout, IntPtr lpUserName, int nMaxUserNameSize);

		[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool GetNamedPipeHandleState(SafePipeHandle hNamedPipe, IntPtr lpState, out int lpCurInstances, IntPtr lpMaxCollectionCount, IntPtr lpCollectDataTimeout, IntPtr lpUserName, int nMaxUserNameSize);

		[DllImport("kernel32.dll", BestFitMapping = false, CharSet = CharSet.Auto, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool GetNamedPipeHandleState(SafePipeHandle hNamedPipe, IntPtr lpState, IntPtr lpCurInstances, IntPtr lpMaxCollectionCount, IntPtr lpCollectDataTimeout, StringBuilder lpUserName, int nMaxUserNameSize);

		[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool GetNamedPipeInfo(SafePipeHandle hNamedPipe, out int lpFlags, IntPtr lpOutBufferSize, IntPtr lpInBufferSize, IntPtr lpMaxInstances);

		[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool GetNamedPipeInfo(SafePipeHandle hNamedPipe, IntPtr lpFlags, out int lpOutBufferSize, IntPtr lpInBufferSize, IntPtr lpMaxInstances);

		[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool GetNamedPipeInfo(SafePipeHandle hNamedPipe, IntPtr lpFlags, IntPtr lpOutBufferSize, out int lpInBufferSize, IntPtr lpMaxInstances);

		[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal unsafe static extern bool SetNamedPipeHandleState(SafePipeHandle hNamedPipe, int* lpMode, IntPtr lpMaxCollectionCount, IntPtr lpCollectDataTimeout);

		[DllImport("kernel32.dll", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool DisconnectNamedPipe(SafePipeHandle hNamedPipe);

		[DllImport("kernel32.dll", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool FlushFileBuffers(SafePipeHandle hNamedPipe);

		[DllImport("advapi32.dll", SetLastError = true)]
		[ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool RevertToSelf();

		[DllImport("advapi32.dll", SetLastError = true)]
		[ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool ImpersonateNamedPipeClient(SafePipeHandle hNamedPipe);

		[DllImport("kernel32.dll", BestFitMapping = false, CharSet = CharSet.Auto, SetLastError = true)]
		internal static extern SafePipeHandle CreateNamedPipe(string pipeName, int openMode, int pipeMode, int maxInstances, int outBufferSize, int inBufferSize, int defaultTimeout, SECURITY_ATTRIBUTES securityAttributes);

		[DllImport("kernel32.dll", SetLastError = true)]
		internal unsafe static extern int ReadFile(SafePipeHandle handle, byte* bytes, int numBytesToRead, IntPtr numBytesRead_mustBeZero, NativeOverlapped* overlapped);

		[DllImport("kernel32.dll", SetLastError = true)]
		internal unsafe static extern int ReadFile(SafePipeHandle handle, byte* bytes, int numBytesToRead, out int numBytesRead, IntPtr mustBeZero);

		[DllImport("kernel32.dll", SetLastError = true)]
		internal unsafe static extern int WriteFile(SafePipeHandle handle, byte* bytes, int numBytesToWrite, IntPtr numBytesWritten_mustBeZero, NativeOverlapped* lpOverlapped);

		[DllImport("kernel32.dll", SetLastError = true)]
		internal unsafe static extern int WriteFile(SafePipeHandle handle, byte* bytes, int numBytesToWrite, out int numBytesWritten, IntPtr mustBeZero);

		[DllImport("kernel32.dll", SetLastError = true)]
		internal static extern bool SetEndOfFile(IntPtr hNamedPipe);

		[DllImport("advapi32.dll", CharSet = CharSet.Unicode, ExactSpelling = true)]
		internal unsafe static extern uint EventRegister([In] ref Guid providerId, [In] EtwEnableCallback enableCallback, [In] void* callbackContext, [In][Out] ref long registrationHandle);

		[DllImport("advapi32.dll", CharSet = CharSet.Unicode, ExactSpelling = true)]
		internal static extern int EventUnregister([In] long registrationHandle);

		[DllImport("advapi32.dll", CharSet = CharSet.Unicode, ExactSpelling = true)]
		internal static extern int EventEnabled([In] long registrationHandle, [In] ref System.Diagnostics.Eventing.EventDescriptor eventDescriptor);

		[DllImport("advapi32.dll", CharSet = CharSet.Unicode, ExactSpelling = true)]
		internal static extern int EventProviderEnabled([In] long registrationHandle, [In] byte level, [In] long keywords);

		[DllImport("advapi32.dll", CharSet = CharSet.Unicode, ExactSpelling = true)]
		internal unsafe static extern uint EventWrite([In] long registrationHandle, [In] ref System.Diagnostics.Eventing.EventDescriptor eventDescriptor, [In] uint userDataCount, [In] void* userData);

		[DllImport("advapi32.dll", CharSet = CharSet.Unicode, ExactSpelling = true)]
		internal unsafe static extern uint EventWrite([In] long registrationHandle, [In] System.Diagnostics.Eventing.EventDescriptor* eventDescriptor, [In] uint userDataCount, [In] void* userData);

		[DllImport("advapi32.dll", CharSet = CharSet.Unicode, ExactSpelling = true)]
		internal unsafe static extern uint EventWriteTransfer([In] long registrationHandle, [In] ref System.Diagnostics.Eventing.EventDescriptor eventDescriptor, [In] ref Guid activityId, [In] ref Guid relatedActivityId, [In] uint userDataCount, [In] void* userData);

		[DllImport("advapi32.dll", CharSet = CharSet.Unicode, ExactSpelling = true)]
		internal unsafe static extern uint EventWriteString([In] long registrationHandle, [In] byte level, [In] long keywords, [In] char* message);

		[DllImport("advapi32.dll", CharSet = CharSet.Unicode, ExactSpelling = true)]
		internal static extern uint EventActivityIdControl([In] int ControlCode, [In][Out] ref Guid ActivityId);

		[DllImport("advapi32.dll", CharSet = CharSet.Unicode, ExactSpelling = true)]
		internal static extern uint PerfStartProvider([In] ref Guid ProviderGuid, [In] PERFLIBREQUEST ControlCallback, out SafePerfProviderHandle phProvider);

		[DllImport("advapi32.dll", CharSet = CharSet.Unicode, ExactSpelling = true)]
		internal static extern uint PerfStopProvider([In] IntPtr hProvider);

		[DllImport("advapi32.dll", CharSet = CharSet.Unicode, ExactSpelling = true)]
		[SecurityCritical]
		internal unsafe static extern uint PerfSetCounterSetInfo([In] SafePerfProviderHandle hProvider, [In][Out] PerfCounterSetInfoStruct* pTemplate, [In] uint dwTemplateSize);

		[DllImport("advapi32.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
		[SecurityCritical]
		internal unsafe static extern PerfCounterSetInstanceStruct* PerfCreateInstance([In] SafePerfProviderHandle hProvider, [In] ref Guid CounterSetGuid, [In] string szInstanceName, [In] uint dwInstance);

		[DllImport("advapi32.dll", CharSet = CharSet.Unicode, ExactSpelling = true)]
		[SecurityCritical]
		internal unsafe static extern uint PerfDeleteInstance([In] SafePerfProviderHandle hProvider, [In] PerfCounterSetInstanceStruct* InstanceBlock);

		[DllImport("advapi32.dll", CharSet = CharSet.Unicode, ExactSpelling = true)]
		[SecurityCritical]
		internal unsafe static extern uint PerfSetCounterRefValue([In] SafePerfProviderHandle hProvider, [In] PerfCounterSetInstanceStruct* pInstance, [In] uint CounterId, [In] void* lpAddr);

		[DllImport("wevtapi.dll", SetLastError = true)]
		internal static extern EventLogHandle EvtQuery(EventLogHandle session, [MarshalAs(UnmanagedType.LPWStr)] string path, [MarshalAs(UnmanagedType.LPWStr)] string query, int flags);

		[DllImport("wevtapi.dll", CharSet = CharSet.Auto, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool EvtSeek(EventLogHandle resultSet, long position, EventLogHandle bookmark, int timeout, [MarshalAs(UnmanagedType.I4)] EvtSeekFlags flags);

		[DllImport("wevtapi.dll", SetLastError = true)]
		internal static extern EventLogHandle EvtSubscribe(EventLogHandle session, SafeWaitHandle signalEvent, [MarshalAs(UnmanagedType.LPWStr)] string path, [MarshalAs(UnmanagedType.LPWStr)] string query, EventLogHandle bookmark, IntPtr context, IntPtr callback, int flags);

		[DllImport("wevtapi.dll", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool EvtNext(EventLogHandle queryHandle, int eventSize, [MarshalAs(UnmanagedType.LPArray)] IntPtr[] events, int timeout, int flags, ref int returned);

		[DllImport("wevtapi.dll", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool EvtCancel(EventLogHandle handle);

		[DllImport("wevtapi.dll")]
		[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool EvtClose(IntPtr handle);

		[DllImport("wevtapi.dll", CharSet = CharSet.Auto, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool EvtGetEventInfo(EventLogHandle eventHandle, [MarshalAs(UnmanagedType.I4)] EvtEventPropertyId propertyId, int bufferSize, IntPtr bufferPtr, out int bufferUsed);

		[DllImport("wevtapi.dll", CharSet = CharSet.Auto, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool EvtGetQueryInfo(EventLogHandle queryHandle, [MarshalAs(UnmanagedType.I4)] EvtQueryPropertyId propertyId, int bufferSize, IntPtr buffer, ref int bufferRequired);

		[DllImport("wevtapi.dll", CharSet = CharSet.Auto, SetLastError = true)]
		internal static extern EventLogHandle EvtOpenPublisherMetadata(EventLogHandle session, [MarshalAs(UnmanagedType.LPWStr)] string publisherId, [MarshalAs(UnmanagedType.LPWStr)] string logFilePath, int locale, int flags);

		[DllImport("wevtapi.dll", CharSet = CharSet.Auto, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool EvtGetPublisherMetadataProperty(EventLogHandle publisherMetadataHandle, [MarshalAs(UnmanagedType.I4)] EvtPublisherMetadataPropertyId propertyId, int flags, int publisherMetadataPropertyBufferSize, IntPtr publisherMetadataPropertyBuffer, out int publisherMetadataPropertyBufferUsed);

		[DllImport("wevtapi.dll", CharSet = CharSet.Auto, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool EvtGetObjectArraySize(EventLogHandle objectArray, out int objectArraySize);

		[DllImport("wevtapi.dll", CharSet = CharSet.Auto, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool EvtGetObjectArrayProperty(EventLogHandle objectArray, int propertyId, int arrayIndex, int flags, int propertyValueBufferSize, IntPtr propertyValueBuffer, out int propertyValueBufferUsed);

		[DllImport("wevtapi.dll", CharSet = CharSet.Auto, SetLastError = true)]
		internal static extern EventLogHandle EvtOpenEventMetadataEnum(EventLogHandle publisherMetadata, int flags);

		[DllImport("wevtapi.dll", CharSet = CharSet.Auto, SetLastError = true)]
		internal static extern EventLogHandle EvtNextEventMetadata(EventLogHandle eventMetadataEnum, int flags);

		[DllImport("wevtapi.dll", CharSet = CharSet.Auto, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool EvtGetEventMetadataProperty(EventLogHandle eventMetadata, [MarshalAs(UnmanagedType.I4)] EvtEventMetadataPropertyId propertyId, int flags, int eventMetadataPropertyBufferSize, IntPtr eventMetadataPropertyBuffer, out int eventMetadataPropertyBufferUsed);

		[DllImport("wevtapi.dll", CharSet = CharSet.Auto, SetLastError = true)]
		internal static extern EventLogHandle EvtOpenChannelEnum(EventLogHandle session, int flags);

		[DllImport("wevtapi.dll", CharSet = CharSet.Auto, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool EvtNextChannelPath(EventLogHandle channelEnum, int channelPathBufferSize, [Out][MarshalAs(UnmanagedType.LPWStr)] StringBuilder channelPathBuffer, out int channelPathBufferUsed);

		[DllImport("wevtapi.dll", CharSet = CharSet.Auto, SetLastError = true)]
		internal static extern EventLogHandle EvtOpenPublisherEnum(EventLogHandle session, int flags);

		[DllImport("wevtapi.dll", CharSet = CharSet.Auto, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool EvtNextPublisherId(EventLogHandle publisherEnum, int publisherIdBufferSize, [Out][MarshalAs(UnmanagedType.LPWStr)] StringBuilder publisherIdBuffer, out int publisherIdBufferUsed);

		[DllImport("wevtapi.dll", CharSet = CharSet.Auto, SetLastError = true)]
		internal static extern EventLogHandle EvtOpenChannelConfig(EventLogHandle session, [MarshalAs(UnmanagedType.LPWStr)] string channelPath, int flags);

		[DllImport("wevtapi.dll", CharSet = CharSet.Auto, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool EvtSaveChannelConfig(EventLogHandle channelConfig, int flags);

		[DllImport("wevtapi.dll", CharSet = CharSet.Auto, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool EvtSetChannelConfigProperty(EventLogHandle channelConfig, [MarshalAs(UnmanagedType.I4)] EvtChannelConfigPropertyId propertyId, int flags, ref EvtVariant propertyValue);

		[DllImport("wevtapi.dll", CharSet = CharSet.Auto, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool EvtGetChannelConfigProperty(EventLogHandle channelConfig, [MarshalAs(UnmanagedType.I4)] EvtChannelConfigPropertyId propertyId, int flags, int propertyValueBufferSize, IntPtr propertyValueBuffer, out int propertyValueBufferUsed);

		[DllImport("wevtapi.dll", CharSet = CharSet.Auto, SetLastError = true)]
		internal static extern EventLogHandle EvtOpenLog(EventLogHandle session, [MarshalAs(UnmanagedType.LPWStr)] string path, [MarshalAs(UnmanagedType.I4)] PathType flags);

		[DllImport("wevtapi.dll", CharSet = CharSet.Auto, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool EvtGetLogInfo(EventLogHandle log, [MarshalAs(UnmanagedType.I4)] EvtLogPropertyId propertyId, int propertyValueBufferSize, IntPtr propertyValueBuffer, out int propertyValueBufferUsed);

		[DllImport("wevtapi.dll", CharSet = CharSet.Auto, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool EvtExportLog(EventLogHandle session, [MarshalAs(UnmanagedType.LPWStr)] string channelPath, [MarshalAs(UnmanagedType.LPWStr)] string query, [MarshalAs(UnmanagedType.LPWStr)] string targetFilePath, int flags);

		[DllImport("wevtapi.dll", CharSet = CharSet.Auto, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool EvtArchiveExportedLog(EventLogHandle session, [MarshalAs(UnmanagedType.LPWStr)] string logFilePath, int locale, int flags);

		[DllImport("wevtapi.dll", CharSet = CharSet.Auto, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool EvtClearLog(EventLogHandle session, [MarshalAs(UnmanagedType.LPWStr)] string channelPath, [MarshalAs(UnmanagedType.LPWStr)] string targetFilePath, int flags);

		[DllImport("wevtapi.dll", CharSet = CharSet.Auto, SetLastError = true)]
		internal static extern EventLogHandle EvtCreateRenderContext(int valuePathsCount, [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.LPWStr)] string[] valuePaths, [MarshalAs(UnmanagedType.I4)] EvtRenderContextFlags flags);

		[DllImport("wevtapi.dll", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool EvtRender(EventLogHandle context, EventLogHandle eventHandle, EvtRenderFlags flags, int buffSize, [Out][MarshalAs(UnmanagedType.LPWStr)] StringBuilder buffer, out int buffUsed, out int propCount);

		[DllImport("wevtapi.dll", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool EvtRender(EventLogHandle context, EventLogHandle eventHandle, EvtRenderFlags flags, int buffSize, IntPtr buffer, out int buffUsed, out int propCount);

		[DllImport("wevtapi.dll", CharSet = CharSet.Auto, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool EvtFormatMessage(EventLogHandle publisherMetadataHandle, EventLogHandle eventHandle, uint messageId, int valueCount, EvtStringVariant[] values, [MarshalAs(UnmanagedType.I4)] EvtFormatMessageFlags flags, int bufferSize, [Out][MarshalAs(UnmanagedType.LPWStr)] StringBuilder buffer, out int bufferUsed);

		[DllImport("wevtapi.dll", CharSet = CharSet.Auto, EntryPoint = "EvtFormatMessage", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool EvtFormatMessageBuffer(EventLogHandle publisherMetadataHandle, EventLogHandle eventHandle, uint messageId, int valueCount, IntPtr values, [MarshalAs(UnmanagedType.I4)] EvtFormatMessageFlags flags, int bufferSize, IntPtr buffer, out int bufferUsed);

		[DllImport("wevtapi.dll", CharSet = CharSet.Auto, SetLastError = true)]
		internal static extern EventLogHandle EvtOpenSession([MarshalAs(UnmanagedType.I4)] EvtLoginClass loginClass, ref EvtRpcLogin login, int timeout, int flags);

		[DllImport("wevtapi.dll", CharSet = CharSet.Auto, SetLastError = true)]
		internal static extern EventLogHandle EvtCreateBookmark([MarshalAs(UnmanagedType.LPWStr)] string bookmarkXml);

		[DllImport("wevtapi.dll", CharSet = CharSet.Auto, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool EvtUpdateBookmark(EventLogHandle bookmark, EventLogHandle eventHandle);
	}
	[SecurityCritical(SecurityCriticalScope.Everything)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	internal sealed class SafeLibraryHandle : SafeHandleZeroOrMinusOneIsInvalid
	{
		internal SafeLibraryHandle()
			: base(ownsHandle: true)
		{
		}

		protected override bool ReleaseHandle()
		{
			return UnsafeNativeMethods.FreeLibrary(handle);
		}
	}
}
namespace Microsoft.Win32.SafeHandles
{
	[SecurityCritical(SecurityCriticalScope.Everything)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	[SecurityPermission(SecurityAction.LinkDemand, UnmanagedCode = true)]
	public sealed class SafePipeHandle : SafeHandleZeroOrMinusOneIsInvalid
	{
		private SafePipeHandle()
			: base(ownsHandle: true)
		{
		}

		public SafePipeHandle(IntPtr preexistingHandle, bool ownsHandle)
			: base(ownsHandle)
		{
			SetHandle(preexistingHandle);
		}

		protected override bool ReleaseHandle()
		{
			return UnsafeNativeMethods.CloseHandle(handle);
		}
	}
	[SecurityCritical(SecurityCriticalScope.Everything)]
	internal sealed class SafePerfProviderHandle : SafeHandleZeroOrMinusOneIsInvalid
	{
		private SafePerfProviderHandle()
			: base(ownsHandle: true)
		{
		}

		protected override bool ReleaseHandle()
		{
			IntPtr hProvider = handle;
			if (Interlocked.Exchange(ref handle, IntPtr.Zero) != IntPtr.Zero)
			{
				UnsafeNativeMethods.PerfStopProvider(hProvider);
			}
			return true;
		}
	}
}
namespace System
{
	[Flags]
	internal enum TimeZoneInfoOptions
	{
		None = 1,
		NoThrowOnInvalidTime = 2
	}
	[Serializable]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class TimeZoneInfo : IEquatable<TimeZoneInfo>, ISerializable, IDeserializationCallback
	{
		private enum TimeZoneInfoResult
		{
			Success,
			TimeZoneNotFoundException,
			InvalidTimeZoneException,
			SecurityException
		}

		[Serializable]
		[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
		[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
		public sealed class AdjustmentRule : IEquatable<AdjustmentRule>, ISerializable, IDeserializationCallback
		{
			private DateTime m_dateStart;

			private DateTime m_dateEnd;

			private TimeSpan m_daylightDelta;

			private TransitionTime m_daylightTransitionStart;

			private TransitionTime m_daylightTransitionEnd;

			private TimeSpan m_baseUtcOffsetDelta;

			public DateTime DateStart => m_dateStart;

			public DateTime DateEnd => m_dateEnd;

			public TimeSpan DaylightDelta => m_daylightDelta;

			public TransitionTime DaylightTransitionStart => m_daylightTransitionStart;

			public TransitionTime DaylightTransitionEnd => m_daylightTransitionEnd;

			internal TimeSpan BaseUtcOffsetDelta => m_baseUtcOffsetDelta;

			internal bool HasDaylightSaving
			{
				get
				{
					if (!(DaylightDelta != TimeSpan.Zero) && !(DaylightTransitionStart.TimeOfDay != DateTime.MinValue))
					{
						return DaylightTransitionEnd.TimeOfDay != DateTime.MinValue.AddMilliseconds(1.0);
					}
					return true;
				}
			}

			public bool Equals(AdjustmentRule other)
			{
				return other != null && m_dateStart == other.m_dateStart && m_dateEnd == other.m_dateEnd && m_daylightDelta == other.m_daylightDelta && m_baseUtcOffsetDelta == other.m_baseUtcOffsetDelta && m_daylightTransitionEnd.Equals(other.m_daylightTransitionEnd) && m_daylightTransitionStart.Equals(other.m_daylightTransitionStart);
			}

			public override int GetHashCode()
			{
				return m_dateStart.GetHashCode();
			}

			private AdjustmentRule()
			{
			}

			public static AdjustmentRule CreateAdjustmentRule(DateTime dateStart, DateTime dateEnd, TimeSpan daylightDelta, TransitionTime daylightTransitionStart, TransitionTime daylightTransitionEnd)
			{
				ValidateAdjustmentRule(dateStart, dateEnd, daylightDelta, daylightTransitionStart, daylightTransitionEnd);
				AdjustmentRule adjustmentRule = new AdjustmentRule();
				adjustmentRule.m_dateStart = dateStart;
				adjustmentRule.m_dateEnd = dateEnd;
				adjustmentRule.m_daylightDelta = daylightDelta;
				adjustmentRule.m_daylightTransitionStart = daylightTransitionStart;
				adjustmentRule.m_daylightTransitionEnd = daylightTransitionEnd;
				adjustmentRule.m_baseUtcOffsetDelta = TimeSpan.Zero;
				return adjustmentRule;
			}

			internal static AdjustmentRule CreateAdjustmentRule(DateTime dateStart, DateTime dateEnd, TimeSpan daylightDelta, TransitionTime daylightTransitionStart, TransitionTime daylightTransitionEnd, TimeSpan baseUtcOffsetDelta)
			{
				AdjustmentRule adjustmentRule = CreateAdjustmentRule(dateStart, dateEnd, daylightDelta, daylightTransitionStart, daylightTransitionEnd);
				adjustmentRule.m_baseUtcOffsetDelta = baseUtcOffsetDelta;
				return adjustmentRule;
			}

			internal bool IsStartDateMarkerForBeginningOfYear()
			{
				if (DaylightTransitionStart.Month == 1 && DaylightTransitionStart.Day == 1 && DaylightTransitionStart.TimeOfDay.Hour == 0 && DaylightTransitionStart.TimeOfDay.Minute == 0 && DaylightTransitionStart.TimeOfDay.Second == 0)
				{
					return m_dateStart.Year == m_dateEnd.Year;
				}
				return false;
			}

			internal bool IsEndDateMarkerForEndOfYear()
			{
				if (DaylightTransitionEnd.Month == 1 && DaylightTransitionEnd.Day == 1 && DaylightTransitionEnd.TimeOfDay.Hour == 0 && DaylightTransitionEnd.TimeOfDay.Minute == 0 && DaylightTransitionEnd.TimeOfDay.Second == 0)
				{
					return m_dateStart.Year == m_dateEnd.Year;
				}
				return false;
			}

			private static void ValidateAdjustmentRule(DateTime dateStart, DateTime dateEnd, TimeSpan daylightDelta, TransitionTime daylightTransitionStart, TransitionTime daylightTransitionEnd)
			{
				if (dateStart.Kind != 0)
				{
					throw new ArgumentException(SR.GetString("Argument_DateTimeKindMustBeUnspecified"), "dateStart");
				}
				if (dateEnd.Kind != 0)
				{
					throw new ArgumentException(SR.GetString("Argument_DateTimeKindMustBeUnspecified"), "dateEnd");
				}
				if (daylightTransitionStart.Equals(daylightTransitionEnd))
				{
					throw new ArgumentException(SR.GetString("Argument_TransitionTimesAreIdentical"), "daylightTransitionEnd");
				}
				if (dateStart > dateEnd)
				{
					throw new ArgumentException(SR.GetString("Argument_OutOfOrderDateTimes"), "dateStart");
				}
				if (UtcOffsetOutOfRange(daylightDelta))
				{
					throw new ArgumentOutOfRangeException("daylightDelta", daylightDelta, SR.GetString("ArgumentOutOfRange_UtcOffset"));
				}
				if (daylightDelta.Ticks % 600000000 != 0)
				{
					throw new ArgumentException(SR.GetString("Argument_TimeSpanHasSeconds"), "daylightDelta");
				}
				if (dateStart.TimeOfDay != TimeSpan.Zero)
				{
					throw new ArgumentException(SR.GetString("Argument_DateTimeHasTimeOfDay"), "dateStart");
				}
				if (dateEnd.TimeOfDay != TimeSpan.Zero)
				{
					throw new ArgumentException(SR.GetString("Argument_DateTimeHasTimeOfDay"), "dateEnd");
				}
			}

			void IDeserializationCallback.OnDeserialization(object sender)
			{
				try
				{
					ValidateAdjustmentRule(m_dateStart, m_dateEnd, m_daylightDelta, m_daylightTransitionStart, m_daylightTransitionEnd);
				}
				catch (ArgumentException innerException)
				{
					throw new SerializationException(SR.GetString("Serialization_InvalidData"), innerException);
				}
			}

			[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
			void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
			{
				if (info == null)
				{
					throw new ArgumentNullException("info");
				}
				info.AddValue("DateStart", m_dateStart);
				info.AddValue("DateEnd", m_dateEnd);
				info.AddValue("DaylightDelta", m_daylightDelta);
				info.AddValue("DaylightTransitionStart", m_daylightTransitionStart);
				info.AddValue("DaylightTransitionEnd", m_daylightTransitionEnd);
				info.AddValue("BaseUtcOffsetDelta", m_baseUtcOffsetDelta);
			}

			private AdjustmentRule(SerializationInfo info, StreamingContext context)
			{
				if (info == null)
				{
					throw new ArgumentNullException("info");
				}
				m_dateStart = (DateTime)info.GetValue("DateStart", typeof(DateTime));
				m_dateEnd = (DateTime)info.GetValue("DateEnd", typeof(DateTime));
				m_daylightDelta = (TimeSpan)info.GetValue("DaylightDelta", typeof(TimeSpan));
				m_daylightTransitionStart = (TransitionTime)info.GetValue("DaylightTransitionStart", typeof(TransitionTime));
				m_daylightTransitionEnd = (TransitionTime)info.GetValue("DaylightTransitionEnd", typeof(TransitionTime));
				if (info.MemberCount >= 6)
				{
					m_baseUtcOffsetDelta = (TimeSpan)info.GetValue("BaseUtcOffsetDelta", typeof(TimeSpan));
				}
			}
		}

		[Serializable]
		[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
		[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
		public struct TransitionTime : IEquatable<TransitionTime>, ISerializable, IDeserializationCallback
		{
			private DateTime m_timeOfDay;

			private byte m_month;

			private byte m_week;

			private byte m_day;

			private DayOfWeek m_dayOfWeek;

			private bool m_isFixedDateRule;

			public DateTime TimeOfDay => m_timeOfDay;

			public int Month => m_month;

			public int Week => m_week;

			public int Day => m_day;

			public DayOfWeek DayOfWeek => m_dayOfWeek;

			public bool IsFixedDateRule => m_isFixedDateRule;

			public override bool Equals(object obj)
			{
				if (obj is TransitionTime)
				{
					return Equals((TransitionTime)obj);
				}
				return false;
			}

			public static bool operator ==(TransitionTime left, TransitionTime right)
			{
				return left.Equals(right);
			}

			public static bool operator !=(TransitionTime left, TransitionTime right)
			{
				return !left.Equals(right);
			}

			public bool Equals(TransitionTime other)
			{
				bool flag = m_isFixedDateRule == other.m_isFixedDateRule && m_timeOfDay == other.m_timeOfDay && m_month == other.m_month;
				if (flag)
				{
					flag = ((!other.m_isFixedDateRule) ? (m_week == other.m_week && m_dayOfWeek == other.m_dayOfWeek) : (m_day == other.m_day));
				}
				return flag;
			}

			public override int GetHashCode()
			{
				return m_month ^ (m_week << 8);
			}

			public static TransitionTime CreateFixedDateRule(DateTime timeOfDay, int month, int day)
			{
				return CreateTransitionTime(timeOfDay, month, 1, day, DayOfWeek.Sunday, isFixedDateRule: true);
			}

			public static TransitionTime CreateFloatingDateRule(DateTime timeOfDay, int month, int week, DayOfWeek dayOfWeek)
			{
				return CreateTransitionTime(timeOfDay, month, week, 1, dayOfWeek, isFixedDateRule: false);
			}

			private static TransitionTime CreateTransitionTime(DateTime timeOfDay, int month, int week, int day, DayOfWeek dayOfWeek, bool isFixedDateRule)
			{
				ValidateTransitionTime(timeOfDay, month, week, day, dayOfWeek);
				TransitionTime result = default(TransitionTime);
				result.m_isFixedDateRule = isFixedDateRule;
				result.m_timeOfDay = timeOfDay;
				result.m_dayOfWeek = dayOfWeek;
				result.m_day = (byte)day;
				result.m_week = (byte)week;
				result.m_month = (byte)month;
				return result;
			}

			private static void ValidateTransitionTime(DateTime timeOfDay, int month, int week, int day, DayOfWeek dayOfWeek)
			{
				if (timeOfDay.Kind != 0)
				{
					throw new ArgumentException(SR.GetString("Argument_DateTimeKindMustBeUnspecified"), "timeOfDay");
				}
				if (month < 1 || month > 12)
				{
					throw new ArgumentOutOfRangeException("month", SR.GetString("ArgumentOutOfRange_Month"));
				}
				if (day < 1 || day > 31)
				{
					throw new ArgumentOutOfRangeException("day", SR.GetString("ArgumentOutOfRange_Day"));
				}
				if (week < 1 || week > 5)
				{
					throw new ArgumentOutOfRangeException("week", SR.GetString("ArgumentOutOfRange_Week"));
				}
				if (dayOfWeek < DayOfWeek.Sunday || dayOfWeek > DayOfWeek.Saturday)
				{
					throw new ArgumentOutOfRangeException("dayOfWeek", SR.GetString("ArgumentOutOfRange_DayOfWeek"));
				}
				if (timeOfDay.Year != 1 || timeOfDay.Month != 1 || timeOfDay.Day != 1 || timeOfDay.Ticks % 10000 != 0)
				{
					throw new ArgumentException(SR.GetString("Argument_DateTimeHasTicks"), "timeOfDay");
				}
			}

			void IDeserializationCallback.OnDeserialization(object sender)
			{
				try
				{
					ValidateTransitionTime(m_timeOfDay, m_month, m_week, m_day, m_dayOfWeek);
				}
				catch (ArgumentException innerException)
				{
					throw new SerializationException(SR.GetString("Serialization_InvalidData"), innerException);
				}
			}

			[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
			void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
			{
				if (info == null)
				{
					throw new ArgumentNullException("info");
				}
				info.AddValue("TimeOfDay", m_timeOfDay);
				info.AddValue("Month", m_month);
				info.AddValue("Week", m_week);
				info.AddValue("Day", m_day);
				info.AddValue("DayOfWeek", m_dayOfWeek);
				info.AddValue("IsFixedDateRule", m_isFixedDateRule);
			}

			private TransitionTime(SerializationInfo info, StreamingContext context)
			{
				if (info == null)
				{
					throw new ArgumentNullException("info");
				}
				m_timeOfDay = (DateTime)info.GetValue("TimeOfDay", typeof(DateTime));
				m_month = (byte)info.GetValue("Month", typeof(byte));
				m_week = (byte)info.GetValue("Week", typeof(byte));
				m_day = (byte)info.GetValue("Day", typeof(byte));
				m_dayOfWeek = (DayOfWeek)info.GetValue("DayOfWeek", typeof(DayOfWeek));
				m_isFixedDateRule = (bool)info.GetValue("IsFixedDateRule", typeof(bool));
			}
		}

		private sealed class StringSerializer
		{
			private enum State
			{
				Escaped,
				NotEscaped,
				StartOfToken,
				EndOfLine
			}

			private const int initialCapacityForString = 64;

			private const char esc = '\\';

			private const char sep = ';';

			private const char lhs = '[';

			private const char rhs = ']';

			private const string escString = "\\";

			private const string sepString = ";";

			private const string lhsString = "[";

			private const string rhsString = "]";

			private const string escapedEsc = "\\\\";

			private const string escapedSep = "\\;";

			private const string escapedLhs = "\\[";

			private const string escapedRhs = "\\]";

			private const string dateTimeFormat = "MM:dd:yyyy";

			private const string timeOfDayFormat = "HH:mm:ss.FFF";

			private string m_serializedText;

			private int m_currentTokenStartIndex;

			private State m_state;

			public static string GetSerializedString(TimeZoneInfo zone)
			{
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.Append(SerializeSubstitute(zone.Id));
				stringBuilder.Append(';');
				stringBuilder.Append(SerializeSubstitute(zone.BaseUtcOffset.TotalMinutes.ToString(CultureInfo.InvariantCulture)));
				stringBuilder.Append(';');
				stringBuilder.Append(SerializeSubstitute(zone.DisplayName));
				stringBuilder.Append(';');
				stringBuilder.Append(SerializeSubstitute(zone.StandardName));
				stringBuilder.Append(';');
				stringBuilder.Append(SerializeSubstitute(zone.DaylightName));
				stringBuilder.Append(';');
				AdjustmentRule[] adjustmentRules = zone.GetAdjustmentRules();
				if (adjustmentRules != null && adjustmentRules.Length > 0)
				{
					foreach (AdjustmentRule adjustmentRule in adjustmentRules)
					{
						stringBuilder.Append('[');
						stringBuilder.Append(SerializeSubstitute(adjustmentRule.DateStart.ToString("MM:dd:yyyy", DateTimeFormatInfo.InvariantInfo)));
						stringBuilder.Append(';');
						stringBuilder.Append(SerializeSubstitute(adjustmentRule.DateEnd.ToString("MM:dd:yyyy", DateTimeFormatInfo.InvariantInfo)));
						stringBuilder.Append(';');
						stringBuilder.Append(SerializeSubstitute(adjustmentRule.DaylightDelta.TotalMinutes.ToString(CultureInfo.InvariantCulture)));
						stringBuilder.Append(';');
						SerializeTransitionTime(adjustmentRule.DaylightTransitionStart, stringBuilder);
						stringBuilder.Append(';');
						SerializeTransitionTime(adjustmentRule.DaylightTransitionEnd, stringBuilder);
						stringBuilder.Append(';');
						if (adjustmentRule.BaseUtcOffsetDelta != TimeSpan.Zero)
						{
							stringBuilder.Append(SerializeSubstitute(adjustmentRule.BaseUtcOffsetDelta.TotalMinutes.ToString(CultureInfo.InvariantCulture)));
							stringBuilder.Append(';');
						}
						stringBuilder.Append(']');
					}
				}
				stringBuilder.Append(';');
				return stringBuilder.ToString();
			}

			public static TimeZoneInfo GetDeserializedTimeZoneInfo(string source)
			{
				StringSerializer stringSerializer = new StringSerializer(source);
				string nextStringValue = stringSerializer.GetNextStringValue(canEndWithoutSeparator: false);
				TimeSpan nextTimeSpanValue = stringSerializer.GetNextTimeSpanValue(canEndWithoutSeparator: false);
				string nextStringValue2 = stringSerializer.GetNextStringValue(canEndWithoutSeparator: false);
				string nextStringValue3 = stringSerializer.GetNextStringValue(canEndWithoutSeparator: false);
				string nextStringValue4 = stringSerializer.GetNextStringValue(canEndWithoutSeparator: false);
				AdjustmentRule[] nextAdjustmentRuleArrayValue = stringSerializer.GetNextAdjustmentRuleArrayValue(canEndWithoutSeparator: false);
				try
				{
					return CreateCustomTimeZone(nextStringValue, nextTimeSpanValue, nextStringValue2, nextStringValue3, nextStringValue4, nextAdjustmentRuleArrayValue);
				}
				catch (ArgumentException innerException)
				{
					throw new SerializationException(SR.GetString("Serialization_InvalidData"), innerException);
				}
				catch (InvalidTimeZoneException innerException2)
				{
					throw new SerializationException(SR.GetString("Serialization_InvalidData"), innerException2);
				}
			}

			private StringSerializer(string str)
			{
				m_serializedText = str;
				m_state = State.StartOfToken;
			}

			private static string SerializeSubstitute(string text)
			{
				text = text.Replace("\\", "\\\\");
				text = text.Replace("[", "\\[");
				text = text.Replace("]", "\\]");
				return text.Replace(";", "\\;");
			}

			private static void SerializeTransitionTime(TransitionTime time, StringBuilder serializedText)
			{
				serializedText.Append('[');
				serializedText.Append((time.IsFixedDateRule ? 1 : 0).ToString(CultureInfo.InvariantCulture));
				serializedText.Append(';');
				if (time.IsFixedDateRule)
				{
					serializedText.Append(SerializeSubstitute(time.TimeOfDay.ToString("HH:mm:ss.FFF", DateTimeFormatInfo.InvariantInfo)));
					serializedText.Append(';');
					serializedText.Append(SerializeSubstitute(time.Month.ToString(CultureInfo.InvariantCulture)));
					serializedText.Append(';');
					serializedText.Append(SerializeSubstitute(time.Day.ToString(CultureInfo.InvariantCulture)));
					serializedText.Append(';');
				}
				else
				{
					serializedText.Append(SerializeSubstitute(time.TimeOfDay.ToString("HH:mm:ss.FFF", DateTimeFormatInfo.InvariantInfo)));
					serializedText.Append(';');
					serializedText.Append(SerializeSubstitute(time.Month.ToString(CultureInfo.InvariantCulture)));
					serializedText.Append(';');
					serializedText.Append(SerializeSubstitute(time.Week.ToString(CultureInfo.InvariantCulture)));
					serializedText.Append(';');
					serializedText.Append(SerializeSubstitute(((int)time.DayOfWeek).ToString(CultureInfo.InvariantCulture)));
					serializedText.Append(';');
				}
				serializedText.Append(']');
			}

			private static void VerifyIsEscapableCharacter(char c)
			{
				if (c != '\\' && c != ';' && c != '[' && c != ']')
				{
					throw new SerializationException(SR.GetString("Serialization_InvalidEscapeSequence", c));
				}
			}

			private void SkipVersionNextDataFields(int depth)
			{
				if (m_currentTokenStartIndex < 0 || m_currentTokenStartIndex >= m_serializedText.Length)
				{
					throw new SerializationException(SR.GetString("Serialization_InvalidData"));
				}
				State state = State.NotEscaped;
				for (int i = m_currentTokenStartIndex; i < m_serializedText.Length; i++)
				{
					switch (state)
					{
					case State.Escaped:
						VerifyIsEscapableCharacter(m_serializedText[i]);
						state = State.NotEscaped;
						break;
					case State.NotEscaped:
						switch (m_serializedText[i])
						{
						case '\\':
							state = State.Escaped;
							break;
						case '[':
							depth++;
							break;
						case ']':
							depth--;
							if (depth == 0)
							{
								m_currentTokenStartIndex = i + 1;
								if (m_currentTokenStartIndex >= m_serializedText.Length)
								{
									m_state = State.EndOfLine;
								}
								else
								{
									m_state = State.StartOfToken;
								}
								return;
							}
							break;
						case '\0':
							throw new SerializationException(SR.GetString("Serialization_InvalidData"));
						}
						break;
					}
				}
				throw new SerializationException(SR.GetString("Serialization_InvalidData"));
			}

			private string GetNextStringValue(bool canEndWithoutSeparator)
			{
				if (m_state == State.EndOfLine)
				{
					if (canEndWithoutSeparator)
					{
						return null;
					}
					throw new SerializationException(SR.GetString("Serialization_InvalidData"));
				}
				if (m_currentTokenStartIndex < 0 || m_currentTokenStartIndex >= m_serializedText.Length)
				{
					throw new SerializationException(SR.GetString("Serialization_InvalidData"));
				}
				State state = State.NotEscaped;
				StringBuilder stringBuilder = new StringBuilder(64);
				for (int i = m_currentTokenStartIndex; i < m_serializedText.Length; i++)
				{
					switch (state)
					{
					case State.Escaped:
						VerifyIsEscapableCharacter(m_serializedText[i]);
						stringBuilder.Append(m_serializedText[i]);
						state = State.NotEscaped;
						break;
					case State.NotEscaped:
						switch (m_serializedText[i])
						{
						case '\\':
							state = State.Escaped;
							break;
						case '[':
							throw new SerializationException(SR.GetString("Serialization_InvalidData"));
						case ']':
							if (canEndWithoutSeparator)
							{
								m_currentTokenStartIndex = i;
								m_state = State.StartOfToken;
								return stringBuilder.ToString();
							}
							throw new SerializationException(SR.GetString("Serialization_InvalidData"));
						case ';':
							m_currentTokenStartIndex = i + 1;
							if (m_currentTokenStartIndex >= m_serializedText.Length)
							{
								m_state = State.EndOfLine;
							}
							else
							{
								m_state = State.StartOfToken;
							}
							return stringBuilder.ToString();
						case '\0':
							throw new SerializationException(SR.GetString("Serialization_InvalidData"));
						default:
							stringBuilder.Append(m_serializedText[i]);
							break;
						}
						break;
					}
				}
				if (state == State.Escaped)
				{
					throw new SerializationException(SR.GetString("Serialization_InvalidEscapeSequence", string.Empty));
				}
				if (!canEndWithoutSeparator)
				{
					throw new SerializationException(SR.GetString("Serialization_InvalidData"));
				}
				m_currentTokenStartIndex = m_serializedText.Length;
				m_state = State.EndOfLine;
				return stringBuilder.ToString();
			}

			private DateTime GetNextDateTimeValue(bool canEndWithoutSeparator, string format)
			{
				string nextStringValue = GetNextStringValue(canEndWithoutSeparator);
				if (!DateTime.TryParseExact(nextStringValue, format, DateTimeFormatInfo.InvariantInfo, DateTimeStyles.None, out var result))
				{
					throw new SerializationException(SR.GetString("Serialization_InvalidData"));
				}
				return result;
			}

			private TimeSpan GetNextTimeSpanValue(bool canEndWithoutSeparator)
			{
				int nextInt32Value = GetNextInt32Value(canEndWithoutSeparator);
				try
				{
					return new TimeSpan(0, nextInt32Value, 0);
				}
				catch (ArgumentOutOfRangeException innerException)
				{
					throw new SerializationException(SR.GetString("Serialization_InvalidData"), innerException);
				}
			}

			private int GetNextInt32Value(bool canEndWithoutSeparator)
			{
				string nextStringValue = GetNextStringValue(canEndWithoutSeparator);
				if (!int.TryParse(nextStringValue, NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out var result))
				{
					throw new SerializationException(SR.GetString("Serialization_InvalidData"));
				}
				return result;
			}

			private AdjustmentRule[] GetNextAdjustmentRuleArrayValue(bool canEndWithoutSeparator)
			{
				List<AdjustmentRule> list = new List<AdjustmentRule>(1);
				int num = 0;
				for (AdjustmentRule nextAdjustmentRuleValue = GetNextAdjustmentRuleValue(canEndWithoutSeparator: true); nextAdjustmentRuleValue != null; nextAdjustmentRuleValue = GetNextAdjustmentRuleValue(canEndWithoutSeparator: true))
				{
					list.Add(nextAdjustmentRuleValue);
					num++;
				}
				if (!canEndWithoutSeparator)
				{
					if (m_state == State.EndOfLine)
					{
						throw new SerializationException(SR.GetString("Serialization_InvalidData"));
					}
					if (m_currentTokenStartIndex < 0 || m_currentTokenStartIndex >= m_serializedText.Length)
					{
						throw new SerializationException(SR.GetString("Serialization_InvalidData"));
					}
				}
				if (num == 0)
				{
					return null;
				}
				return list.ToArray();
			}

			private AdjustmentRule GetNextAdjustmentRuleValue(bool canEndWithoutSeparator)
			{
				if (m_state == State.EndOfLine)
				{
					if (canEndWithoutSeparator)
					{
						return null;
					}
					throw new SerializationException(SR.GetString("Serialization_InvalidData"));
				}
				if (m_currentTokenStartIndex < 0 || m_currentTokenStartIndex >= m_serializedText.Length)
				{
					throw new SerializationException(SR.GetString("Serialization_InvalidData"));
				}
				if (m_serializedText[m_currentTokenStartIndex] == ';')
				{
					return null;
				}
				if (m_serializedText[m_currentTokenStartIndex] != '[')
				{
					throw new SerializationException(SR.GetString("Serialization_InvalidData"));
				}
				m_currentTokenStartIndex++;
				DateTime nextDateTimeValue = GetNextDateTimeValue(canEndWithoutSeparator: false, "MM:dd:yyyy");
				DateTime nextDateTimeValue2 = GetNextDateTimeValue(canEndWithoutSeparator: false, "MM:dd:yyyy");
				TimeSpan nextTimeSpanValue = GetNextTimeSpanValue(canEndWithoutSeparator: false);
				TransitionTime nextTransitionTimeValue = GetNextTransitionTimeValue(canEndWithoutSeparator: false);
				TransitionTime nextTransitionTimeValue2 = GetNextTransitionTimeValue(canEndWithoutSeparator: false);
				TimeSpan baseUtcOffsetDelta = TimeSpan.Zero;
				if (m_state == State.EndOfLine || m_currentTokenStartIndex >= m_serializedText.Length)
				{
					throw new SerializationException(SR.GetString("Serialization_InvalidData"));
				}
				if ((m_serializedText[m_currentTokenStartIndex] >= '0' && m_serializedText[m_currentTokenStartIndex] <= '9') || m_serializedText[m_currentTokenStartIndex] == '-' || m_serializedText[m_currentTokenStartIndex] == '+')
				{
					baseUtcOffsetDelta = GetNextTimeSpanValue(canEndWithoutSeparator: false);
				}
				if (m_state == State.EndOfLine || m_currentTokenStartIndex >= m_serializedText.Length)
				{
					throw new SerializationException(SR.GetString("Serialization_InvalidData"));
				}
				if (m_serializedText[m_currentTokenStartIndex] != ']')
				{
					SkipVersionNextDataFields(1);
				}
				else
				{
					m_currentTokenStartIndex++;
				}
				AdjustmentRule result;
				try
				{
					result = AdjustmentRule.CreateAdjustmentRule(nextDateTimeValue, nextDateTimeValue2, nextTimeSpanValue, nextTransitionTimeValue, nextTransitionTimeValue2, baseUtcOffsetDelta);
				}
				catch (ArgumentException innerException)
				{
					throw new SerializationException(SR.GetString("Serialization_InvalidData"), innerException);
				}
				if (m_currentTokenStartIndex >= m_serializedText.Length)
				{
					m_state = State.EndOfLine;
				}
				else
				{
					m_state = State.StartOfToken;
				}
				return result;
			}

			private TransitionTime GetNextTransitionTimeValue(bool canEndWithoutSeparator)
			{
				if (m_state == State.EndOfLine || (m_currentTokenStartIndex < m_serializedText.Length && m_serializedText[m_currentTokenStartIndex] == ']'))
				{
					throw new SerializationException(SR.GetString("Serialization_InvalidData"));
				}
				if (m_currentTokenStartIndex < 0 || m_currentTokenStartIndex >= m_serializedText.Length)
				{
					throw new SerializationException(SR.GetString("Serialization_InvalidData"));
				}
				if (m_serializedText[m_currentTokenStartIndex] != '[')
				{
					throw new SerializationException(SR.GetString("Serialization_InvalidData"));
				}
				m_currentTokenStartIndex++;
				int nextInt32Value = GetNextInt32Value(canEndWithoutSeparator: false);
				if (nextInt32Value != 0 && nextInt32Value != 1)
				{
					throw new SerializationException(SR.GetString("Serialization_InvalidData"));
				}
				DateTime nextDateTimeValue = GetNextDateTimeValue(canEndWithoutSeparator: false, "HH:mm:ss.FFF");
				nextDateTimeValue = new DateTime(1, 1, 1, nextDateTimeValue.Hour, nextDateTimeValue.Minute, nextDateTimeValue.Second, nextDateTimeValue.Millisecond);
				int nextInt32Value2 = GetNextInt32Value(canEndWithoutSeparator: false);
				TransitionTime result;
				if (nextInt32Value == 1)
				{
					int nextInt32Value3 = GetNextInt32Value(canEndWithoutSeparator: false);
					try
					{
						result = TransitionTime.CreateFixedDateRule(nextDateTimeValue, nextInt32Value2, nextInt32Value3);
					}
					catch (ArgumentException innerException)
					{
						throw new SerializationException(SR.GetString("Serialization_InvalidData"), innerException);
					}
				}
				else
				{
					int nextInt32Value4 = GetNextInt32Value(canEndWithoutSeparator: false);
					int nextInt32Value5 = GetNextInt32Value(canEndWithoutSeparator: false);
					try
					{
						result = TransitionTime.CreateFloatingDateRule(nextDateTimeValue, nextInt32Value2, nextInt32Value4, (DayOfWeek)nextInt32Value5);
					}
					catch (ArgumentException innerException2)
					{
						throw new SerializationException(SR.GetString("Serialization_InvalidData"), innerException2);
					}
				}
				if (m_state == State.EndOfLine || m_currentTokenStartIndex >= m_serializedText.Length)
				{
					throw new SerializationException(SR.GetString("Serialization_InvalidData"));
				}
				if (m_serializedText[m_currentTokenStartIndex] != ']')
				{
					SkipVersionNextDataFields(1);
				}
				else
				{
					m_currentTokenStartIndex++;
				}
				bool flag = false;
				if (m_currentTokenStartIndex < m_serializedText.Length && m_serializedText[m_currentTokenStartIndex] == ';')
				{
					m_currentTokenStartIndex++;
					flag = true;
				}
				if (!flag && !canEndWithoutSeparator)
				{
					throw new SerializationException(SR.GetString("Serialization_InvalidData"));
				}
				if (m_currentTokenStartIndex >= m_serializedText.Length)
				{
					m_state = State.EndOfLine;
				}
				else
				{
					m_state = State.StartOfToken;
				}
				return result;
			}
		}

		private class TimeZoneInfoComparer : IComparer<TimeZoneInfo>
		{
			int IComparer<TimeZoneInfo>.Compare(TimeZoneInfo x, TimeZoneInfo y)
			{
				return string.Compare(x.DisplayName, y.DisplayName, StringComparison.Ordinal);
			}
		}

		private const string c_timeZonesRegistryHive = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones";

		private const string c_timeZonesRegistryHivePermissionList = "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones";

		private const string c_displayValue = "Display";

		private const string c_daylightValue = "Dlt";

		private const string c_standardValue = "Std";

		private const string c_muiDisplayValue = "MUI_Display";

		private const string c_muiDaylightValue = "MUI_Dlt";

		private const string c_muiStandardValue = "MUI_Std";

		private const string c_timeZoneInfoValue = "TZI";

		private const string c_firstEntryValue = "FirstEntry";

		private const string c_lastEntryValue = "LastEntry";

		private const string c_timeZoneInfoRegistryHive = "SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation";

		private const string c_timeZoneInfoRegistryHivePermissionList = "HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation";

		private const string c_disableDST = "DisableAutoDaylightTimeSet";

		private const string c_disableDynamicDST = "DynamicDaylightTimeDisabled";

		private const string c_utcId = "UTC";

		private const string c_localId = "Local";

		private const int c_maxKeyLength = 255;

		private const long c_ticksPerMillisecond = 10000L;

		private const long c_ticksPerSecond = 10000000L;

		private const long c_ticksPerMinute = 600000000L;

		private const long c_ticksPerHour = 36000000000L;

		private const long c_ticksPerDay = 864000000000L;

		private const long c_ticksPerDayRange = 863999990000L;

		private string m_id;

		private string m_displayName;

		private string m_standardDisplayName;

		private string m_daylightDisplayName;

		private TimeSpan m_baseUtcOffset;

		private bool m_supportsDaylightSavingTime;

		private AdjustmentRule[] m_adjustmentRules;

		private static TimeZoneInfo s_localTimeZone;

		private static TimeZoneInfo s_utcTimeZone;

		private static ReadOnlyCollection<TimeZoneInfo> s_readOnlySystemTimeZones;

		private static bool s_allSystemTimeZonesRead = false;

		private static Dictionary<string, TimeZoneInfo> s_hiddenSystemTimeZones;

		private static object s_hiddenInternalSyncObject;

		private static Dictionary<string, TimeZoneInfo> s_systemTimeZones
		{
			get
			{
				if (s_hiddenSystemTimeZones == null)
				{
					s_hiddenSystemTimeZones = new Dictionary<string, TimeZoneInfo>();
				}
				return s_hiddenSystemTimeZones;
			}
			set
			{
				s_hiddenSystemTimeZones = value;
			}
		}

		private static object s_internalSyncObject
		{
			get
			{
				if (s_hiddenInternalSyncObject == null)
				{
					object value = new object();
					Interlocked.CompareExchange(ref s_hiddenInternalSyncObject, value, null);
				}
				return s_hiddenInternalSyncObject;
			}
		}

		public string Id => m_id;

		public string DisplayName
		{
			get
			{
				if (m_displayName != null)
				{
					return m_displayName;
				}
				return string.Empty;
			}
		}

		public string StandardName
		{
			get
			{
				if (m_standardDisplayName != null)
				{
					return m_standardDisplayName;
				}
				return string.Empty;
			}
		}

		public string DaylightName
		{
			get
			{
				if (m_daylightDisplayName != null)
				{
					return m_daylightDisplayName;
				}
				return string.Empty;
			}
		}

		public TimeSpan BaseUtcOffset => m_baseUtcOffset;

		public bool SupportsDaylightSavingTime => m_supportsDaylightSavingTime;

		public static TimeZoneInfo Local
		{
			[SecurityCritical]
			get
			{
				TimeZoneInfo timeZoneInfo = s_localTimeZone;
				if (timeZoneInfo == null)
				{
					lock (s_internalSyncObject)
					{
						if (s_localTimeZone == null)
						{
							TimeZoneInfo localTimeZone = GetLocalTimeZone();
							s_localTimeZone = new TimeZoneInfo(localTimeZone.m_id, localTimeZone.m_baseUtcOffset, localTimeZone.m_displayName, localTimeZone.m_standardDisplayName, localTimeZone.m_daylightDisplayName, localTimeZone.m_adjustmentRules, disableDaylightSavingTime: false);
						}
						return s_localTimeZone;
					}
				}
				return timeZoneInfo;
			}
		}

		public static TimeZoneInfo Utc
		{
			get
			{
				TimeZoneInfo timeZoneInfo = s_utcTimeZone;
				if (timeZoneInfo == null)
				{
					lock (s_internalSyncObject)
					{
						if (s_utcTimeZone == null)
						{
							s_utcTimeZone = CreateCustomTimeZone("UTC", TimeSpan.Zero, "UTC", "UTC");
						}
						return s_utcTimeZone;
					}
				}
				return timeZoneInfo;
			}
		}

		public AdjustmentRule[] GetAdjustmentRules()
		{
			if (m_adjustmentRules == null)
			{
				return new AdjustmentRule[0];
			}
			return (AdjustmentRule[])m_adjustmentRules.Clone();
		}

		public TimeSpan[] GetAmbiguousTimeOffsets(DateTimeOffset dateTimeOffset)
		{
			if (!m_supportsDaylightSavingTime)
			{
				throw new ArgumentException(SR.GetString("Argument_DateTimeOffsetIsNotAmbiguous"), "dateTimeOffset");
			}
			DateTime dateTime = ConvertTime(dateTimeOffset, this).DateTime;
			bool flag = false;
			AdjustmentRule adjustmentRuleForTime = GetAdjustmentRuleForTime(dateTime);
			if (adjustmentRuleForTime != null && adjustmentRuleForTime.HasDaylightSaving)
			{
				DaylightTime daylightTime = GetDaylightTime(dateTime.Year, adjustmentRuleForTime);
				flag = GetIsAmbiguousTime(dateTime, adjustmentRuleForTime, daylightTime);
			}
			if (!flag)
			{
				throw new ArgumentException(SR.GetString("Argument_DateTimeOffsetIsNotAmbiguous"), "dateTimeOffset");
			}
			TimeSpan[] array = new TimeSpan[2];
			TimeSpan timeSpan = m_baseUtcOffset + adjustmentRuleForTime.BaseUtcOffsetDelta;
			if (adjustmentRuleForTime.DaylightDelta > TimeSpan.Zero)
			{
				array[0] = timeSpan;
				ref TimeSpan reference = ref array[1];
				reference = timeSpan + adjustmentRuleForTime.DaylightDelta;
			}
			else
			{
				ref TimeSpan reference2 = ref array[0];
				reference2 = timeSpan + adjustmentRuleForTime.DaylightDelta;
				array[1] = timeSpan;
			}
			return array;
		}

		public TimeSpan[] GetAmbiguousTimeOffsets(DateTime dateTime)
		{
			if (!m_supportsDaylightSavingTime)
			{
				throw new ArgumentException(SR.GetString("Argument_DateTimeIsNotAmbiguous"), "dateTime");
			}
			DateTime dateTime2;
			if (dateTime.Kind == DateTimeKind.Local)
			{
				lock (s_internalSyncObject)
				{
					dateTime2 = ConvertTime(dateTime, Local, this, TimeZoneInfoOptions.NoThrowOnInvalidTime);
				}
			}
			else if (dateTime.Kind == DateTimeKind.Utc)
			{
				lock (s_internalSyncObject)
				{
					dateTime2 = ConvertTime(dateTime, Utc, this, TimeZoneInfoOptions.NoThrowOnInvalidTime);
				}
			}
			else
			{
				dateTime2 = dateTime;
			}
			bool flag = false;
			AdjustmentRule adjustmentRuleForTime = GetAdjustmentRuleForTime(dateTime2);
			if (adjustmentRuleForTime != null && adjustmentRuleForTime.HasDaylightSaving)
			{
				DaylightTime daylightTime = GetDaylightTime(dateTime2.Year, adjustmentRuleForTime);
				flag = GetIsAmbiguousTime(dateTime2, adjustmentRuleForTime, daylightTime);
			}
			if (!flag)
			{
				throw new ArgumentException(SR.GetString("Argument_DateTimeIsNotAmbiguous"), "dateTime");
			}
			TimeSpan[] array = new TimeSpan[2];
			TimeSpan timeSpan = m_baseUtcOffset + adjustmentRuleForTime.BaseUtcOffsetDelta;
			if (adjustmentRuleForTime.DaylightDelta > TimeSpan.Zero)
			{
				array[0] = timeSpan;
				ref TimeSpan reference = ref array[1];
				reference = timeSpan + adjustmentRuleForTime.DaylightDelta;
			}
			else
			{
				ref TimeSpan reference2 = ref array[0];
				reference2 = timeSpan + adjustmentRuleForTime.DaylightDelta;
				array[1] = timeSpan;
			}
			return array;
		}

		public TimeSpan GetUtcOffset(DateTimeOffset dateTimeOffset)
		{
			return GetUtcOffsetFromUtc(dateTimeOffset.UtcDateTime, this);
		}

		public TimeSpan GetUtcOffset(DateTime dateTime)
		{
			if (dateTime.Kind == DateTimeKind.Local)
			{
				DateTime time;
				lock (s_internalSyncObject)
				{
					if (GetCorrespondingKind() == DateTimeKind.Local)
					{
						return GetUtcOffset(dateTime, this);
					}
					time = ConvertTime(dateTime, Local, Utc, TimeZoneInfoOptions.NoThrowOnInvalidTime);
				}
				return GetUtcOffsetFromUtc(time, this);
			}
			if (dateTime.Kind == DateTimeKind.Utc)
			{
				if (GetCorrespondingKind() == DateTimeKind.Utc)
				{
					return m_baseUtcOffset;
				}
				return GetUtcOffsetFromUtc(dateTime, this);
			}
			return GetUtcOffset(dateTime, this);
		}

		public bool IsAmbiguousTime(DateTimeOffset dateTimeOffset)
		{
			if (!m_supportsDaylightSavingTime)
			{
				return false;
			}
			return IsAmbiguousTime(ConvertTime(dateTimeOffset, this).DateTime);
		}

		public bool IsAmbiguousTime(DateTime dateTime)
		{
			if (!m_supportsDaylightSavingTime)
			{
				return false;
			}
			DateTime dateTime2;
			if (dateTime.Kind == DateTimeKind.Local)
			{
				lock (s_internalSyncObject)
				{
					dateTime2 = ConvertTime(dateTime, Local, this, TimeZoneInfoOptions.NoThrowOnInvalidTime);
				}
			}
			else if (dateTime.Kind == DateTimeKind.Utc)
			{
				lock (s_internalSyncObject)
				{
					dateTime2 = ConvertTime(dateTime, Utc, this, TimeZoneInfoOptions.NoThrowOnInvalidTime);
				}
			}
			else
			{
				dateTime2 = dateTime;
			}
			AdjustmentRule adjustmentRuleForTime = GetAdjustmentRuleForTime(dateTime2);
			if (adjustmentRuleForTime != null && adjustmentRuleForTime.HasDaylightSaving)
			{
				DaylightTime daylightTime = GetDaylightTime(dateTime2.Year, adjustmentRuleForTime);
				return GetIsAmbiguousTime(dateTime2, adjustmentRuleForTime, daylightTime);
			}
			return false;
		}

		public bool IsDaylightSavingTime(DateTimeOffset dateTimeOffset)
		{
			GetUtcOffsetFromUtc(dateTimeOffset.UtcDateTime, this, out var isDaylightSavings);
			return isDaylightSavings;
		}

		public bool IsDaylightSavingTime(DateTime dateTime)
		{
			if (!m_supportsDaylightSavingTime || m_adjustmentRules == null)
			{
				return false;
			}
			DateTime dateTime2;
			if (dateTime.Kind == DateTimeKind.Local)
			{
				lock (s_internalSyncObject)
				{
					dateTime2 = ConvertTime(dateTime, Local, this, TimeZoneInfoOptions.NoThrowOnInvalidTime);
				}
			}
			else
			{
				if (dateTime.Kind == DateTimeKind.Utc)
				{
					if (GetCorrespondingKind() == DateTimeKind.Utc)
					{
						return false;
					}
					GetUtcOffsetFromUtc(dateTime, this, out var isDaylightSavings);
					return isDaylightSavings;
				}
				dateTime2 = dateTime;
			}
			AdjustmentRule adjustmentRuleForTime = GetAdjustmentRuleForTime(dateTime2);
			if (adjustmentRuleForTime != null && adjustmentRuleForTime.HasDaylightSaving)
			{
				DaylightTime daylightTime = GetDaylightTime(dateTime2.Year, adjustmentRuleForTime);
				return GetIsDaylightSavings(dateTime2, adjustmentRuleForTime, daylightTime);
			}
			return false;
		}

		public bool IsInvalidTime(DateTime dateTime)
		{
			bool result = false;
			if (dateTime.Kind == DateTimeKind.Unspecified || (dateTime.Kind == DateTimeKind.Local && GetCorrespondingKind() == DateTimeKind.Local))
			{
				AdjustmentRule adjustmentRuleForTime = GetAdjustmentRuleForTime(dateTime);
				if (adjustmentRuleForTime != null && adjustmentRuleForTime.HasDaylightSaving)
				{
					DaylightTime daylightTime = GetDaylightTime(dateTime.Year, adjustmentRuleForTime);
					result = GetIsInvalidTime(dateTime, adjustmentRuleForTime, daylightTime);
				}
				else
				{
					result = false;
				}
			}
			return result;
		}

		public static void ClearCachedData()
		{
			lock (s_internalSyncObject)
			{
				s_localTimeZone = null;
				s_utcTimeZone = null;
				s_systemTimeZones = null;
				s_readOnlySystemTimeZones = null;
				s_allSystemTimeZonesRead = false;
			}
		}

		public static DateTimeOffset ConvertTimeBySystemTimeZoneId(DateTimeOffset dateTimeOffset, string destinationTimeZoneId)
		{
			return ConvertTime(dateTimeOffset, FindSystemTimeZoneById(destinationTimeZoneId));
		}

		public static DateTime ConvertTimeBySystemTimeZoneId(DateTime dateTime, string destinationTimeZoneId)
		{
			return ConvertTime(dateTime, FindSystemTimeZoneById(destinationTimeZoneId));
		}

		public static DateTime ConvertTimeBySystemTimeZoneId(DateTime dateTime, string sourceTimeZoneId, string destinationTimeZoneId)
		{
			if (dateTime.Kind == DateTimeKind.Local && string.Compare(sourceTimeZoneId, Local.Id, StringComparison.OrdinalIgnoreCase) == 0)
			{
				lock (s_internalSyncObject)
				{
					return ConvertTime(dateTime, Local, FindSystemTimeZoneById(destinationTimeZoneId));
				}
			}
			if (dateTime.Kind == DateTimeKind.Utc && string.Compare(sourceTimeZoneId, Utc.Id, StringComparison.OrdinalIgnoreCase) == 0)
			{
				lock (s_internalSyncObject)
				{
					return ConvertTime(dateTime, Utc, FindSystemTimeZoneById(destinationTimeZoneId));
				}
			}
			return ConvertTime(dateTime, FindSystemTimeZoneById(sourceTimeZoneId), FindSystemTimeZoneById(destinationTimeZoneId));
		}

		public static DateTimeOffset ConvertTime(DateTimeOffset dateTimeOffset, TimeZoneInfo destinationTimeZone)
		{
			if (destinationTimeZone == null)
			{
				throw new ArgumentNullException("destinationTimeZone");
			}
			DateTime utcDateTime = dateTimeOffset.UtcDateTime;
			TimeSpan utcOffsetFromUtc = GetUtcOffsetFromUtc(utcDateTime, destinationTimeZone);
			long num = utcDateTime.Ticks + utcOffsetFromUtc.Ticks;
			if (num > DateTimeOffset.MaxValue.Ticks)
			{
				return DateTimeOffset.MaxValue;
			}
			if (num < DateTimeOffset.MinValue.Ticks)
			{
				return DateTimeOffset.MinValue;
			}
			return new DateTimeOffset(num, utcOffsetFromUtc);
		}

		public static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo destinationTimeZone)
		{
			if (destinationTimeZone == null)
			{
				throw new ArgumentNullException("destinationTimeZone");
			}
			if (dateTime.Kind == DateTimeKind.Utc)
			{
				lock (s_internalSyncObject)
				{
					return ConvertTime(dateTime, Utc, destinationTimeZone);
				}
			}
			lock (s_internalSyncObject)
			{
				return ConvertTime(dateTime, Local, destinationTimeZone);
			}
		}

		public static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo sourceTimeZone, TimeZoneInfo destinationTimeZone)
		{
			return ConvertTime(dateTime, sourceTimeZone, destinationTimeZone, TimeZoneInfoOptions.None);
		}

		internal static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo sourceTimeZone, TimeZoneInfo destinationTimeZone, TimeZoneInfoOptions flags)
		{
			if (sourceTimeZone == null)
			{
				throw new ArgumentNullException("sourceTimeZone");
			}
			if (destinationTimeZone == null)
			{
				throw new ArgumentNullException("destinationTimeZone");
			}
			DateTimeKind correspondingKind = sourceTimeZone.GetCorrespondingKind();
			if ((flags & TimeZoneInfoOptions.NoThrowOnInvalidTime) == 0 && dateTime.Kind != 0 && dateTime.Kind != correspondingKind)
			{
				throw new ArgumentException(SR.GetString("Argument_ConvertMismatch"), "sourceTimeZone");
			}
			AdjustmentRule adjustmentRuleForTime = sourceTimeZone.GetAdjustmentRuleForTime(dateTime);
			TimeSpan baseUtcOffset = sourceTimeZone.BaseUtcOffset;
			if (adjustmentRuleForTime != null)
			{
				baseUtcOffset += adjustmentRuleForTime.BaseUtcOffsetDelta;
				if (adjustmentRuleForTime.HasDaylightSaving)
				{
					bool flag = false;
					DaylightTime daylightTime = GetDaylightTime(dateTime.Year, adjustmentRuleForTime);
					if ((flags & TimeZoneInfoOptions.NoThrowOnInvalidTime) == 0 && GetIsInvalidTime(dateTime, adjustmentRuleForTime, daylightTime))
					{
						throw new ArgumentException(SR.GetString("Argument_DateTimeIsInvalid"), "dateTime");
					}
					flag = GetIsDaylightSavings(dateTime, adjustmentRuleForTime, daylightTime);
					baseUtcOffset += (flag ? adjustmentRuleForTime.DaylightDelta : TimeSpan.Zero);
				}
			}
			DateTimeKind dateTimeKind = destinationTimeZone.GetCorrespondingKind();
			if (dateTime.Kind != 0 && correspondingKind != 0 && correspondingKind == dateTimeKind)
			{
				return dateTime;
			}
			long ticks = dateTime.Ticks - baseUtcOffset.Ticks;
			DateTime dateTime2 = ConvertUtcToTimeZone(ticks, destinationTimeZone);
			if (dateTimeKind == DateTimeKind.Local)
			{
				dateTimeKind = DateTimeKind.Unspecified;
			}
			return new DateTime(dateTime2.Ticks, dateTimeKind);
		}

		public static DateTime ConvertTimeFromUtc(DateTime dateTime, TimeZoneInfo destinationTimeZone)
		{
			lock (s_internalSyncObject)
			{
				return ConvertTime(dateTime, Utc, destinationTimeZone);
			}
		}

		public static DateTime ConvertTimeToUtc(DateTime dateTime)
		{
			if (dateTime.Kind == DateTimeKind.Utc)
			{
				return dateTime;
			}
			lock (s_internalSyncObject)
			{
				return ConvertTime(dateTime, Local, Utc);
			}
		}

		public static DateTime ConvertTimeToUtc(DateTime dateTime, TimeZoneInfo sourceTimeZone)
		{
			lock (s_internalSyncObject)
			{
				return ConvertTime(dateTime, sourceTimeZone, Utc);
			}
		}

		public bool Equals(TimeZoneInfo other)
		{
			if (other != null && string.Compare(m_id, other.m_id, StringComparison.OrdinalIgnoreCase) == 0)
			{
				return HasSameRules(other);
			}
			return false;
		}

		public static TimeZoneInfo FindSystemTimeZoneById(string id)
		{
			if (string.Compare(id, "UTC", StringComparison.OrdinalIgnoreCase) == 0)
			{
				return Utc;
			}
			lock (s_internalSyncObject)
			{
				return GetTimeZone(id);
			}
		}

		public static TimeZoneInfo FromSerializedString(string source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (source.Length == 0)
			{
				throw new ArgumentException(SR.GetString("Argument_InvalidSerializedString", source), "source");
			}
			return StringSerializer.GetDeserializedTimeZoneInfo(source);
		}

		public override int GetHashCode()
		{
			return m_id.ToUpperInvariant().GetHashCode();
		}

		[SecurityCritical]
		[SecurityTreatAsSafe]
		public static ReadOnlyCollection<TimeZoneInfo> GetSystemTimeZones()
		{
			lock (s_internalSyncObject)
			{
				if (!s_allSystemTimeZonesRead)
				{
					PermissionSet permissionSet = new PermissionSet(PermissionState.None);
					permissionSet.AddPermission(new RegistryPermission(RegistryPermissionAccess.Read, "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones"));
					permissionSet.Assert();
					using (RegistryKey registryKey = Registry.LocalMachine.OpenSubKey("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones", RegistryKeyPermissionCheck.Default, RegistryRights.ExecuteKey))
					{
						if (registryKey == null)
						{
							List<TimeZoneInfo> list = ((s_systemTimeZones == null) ? new List<TimeZoneInfo>() : new List<TimeZoneInfo>(s_systemTimeZones.Values));
							s_readOnlySystemTimeZones = new ReadOnlyCollection<TimeZoneInfo>(list);
							s_allSystemTimeZonesRead = true;
							return s_readOnlySystemTimeZones;
						}
						string[] subKeyNames = registryKey.GetSubKeyNames();
						foreach (string id in subKeyNames)
						{
							TryGetTimeZone(id, dstDisabled: false, out var _, out var _);
						}
					}
					IComparer<TimeZoneInfo> comparer = new TimeZoneInfoComparer();
					List<TimeZoneInfo> list2 = new List<TimeZoneInfo>(s_systemTimeZones.Values);
					list2.Sort(comparer);
					s_readOnlySystemTimeZones = new ReadOnlyCollection<TimeZoneInfo>(list2);
					s_allSystemTimeZonesRead = true;
				}
				return s_readOnlySystemTimeZones;
			}
		}

		public bool HasSameRules(TimeZoneInfo other)
		{
			if (other == null)
			{
				throw new ArgumentNullException("other");
			}
			if (m_baseUtcOffset != other.m_baseUtcOffset || m_supportsDaylightSavingTime != other.m_supportsDaylightSavingTime)
			{
				return false;
			}
			AdjustmentRule[] adjustmentRules = m_adjustmentRules;
			AdjustmentRule[] adjustmentRules2 = other.m_adjustmentRules;
			bool flag = (adjustmentRules == null && adjustmentRules2 == null) || (adjustmentRules != null && adjustmentRules2 != null);
			if (!flag)
			{
				return false;
			}
			if (adjustmentRules != null)
			{
				if (adjustmentRules.Length != adjustmentRules2.Length)
				{
					return false;
				}
				for (int i = 0; i < adjustmentRules.Length; i++)
				{
					if (!adjustmentRules[i].Equals(adjustmentRules2[i]))
					{
						return false;
					}
				}
			}
			return flag;
		}

		public string ToSerializedString()
		{
			return StringSerializer.GetSerializedString(this);
		}

		public override string ToString()
		{
			return DisplayName;
		}

		private TimeZoneInfo(Microsoft.Win32.NativeMethods.TimeZoneInformation zone, bool dstDisabled)
		{
			if (string.IsNullOrEmpty(zone.StandardName))
			{
				m_id = "Local";
			}
			else
			{
				m_id = zone.StandardName;
			}
			m_baseUtcOffset = new TimeSpan(0, -zone.Bias, 0);
			if (!dstDisabled)
			{
				Microsoft.Win32.NativeMethods.RegistryTimeZoneInformation timeZoneInformation = new Microsoft.Win32.NativeMethods.RegistryTimeZoneInformation(zone);
				AdjustmentRule adjustmentRule = CreateAdjustmentRuleFromTimeZoneInformation(timeZoneInformation, DateTime.MinValue.Date, DateTime.MaxValue.Date, zone.Bias);
				if (adjustmentRule != null)
				{
					m_adjustmentRules = new AdjustmentRule[1];
					m_adjustmentRules[0] = adjustmentRule;
				}
			}
			ValidateTimeZoneInfo(m_id, m_baseUtcOffset, m_adjustmentRules, out m_supportsDaylightSavingTime);
			m_displayName = zone.StandardName;
			m_standardDisplayName = zone.StandardName;
			m_daylightDisplayName = zone.DaylightName;
		}

		private TimeZoneInfo(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules, bool disableDaylightSavingTime)
		{
			ValidateTimeZoneInfo(id, baseUtcOffset, adjustmentRules, out var adjustmentRulesSupportDst);
			if (!disableDaylightSavingTime && adjustmentRules != null && adjustmentRules.Length > 0)
			{
				m_adjustmentRules = (AdjustmentRule[])adjustmentRules.Clone();
			}
			m_id = id;
			m_baseUtcOffset = baseUtcOffset;
			m_displayName = displayName;
			m_standardDisplayName = standardDisplayName;
			m_daylightDisplayName = (disableDaylightSavingTime ? null : daylightDisplayName);
			m_supportsDaylightSavingTime = adjustmentRulesSupportDst && !disableDaylightSavingTime;
		}

		public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName)
		{
			return new TimeZoneInfo(id, baseUtcOffset, displayName, standardDisplayName, standardDisplayName, null, disableDaylightSavingTime: false);
		}

		public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules)
		{
			return new TimeZoneInfo(id, baseUtcOffset, displayName, standardDisplayName, daylightDisplayName, adjustmentRules, disableDaylightSavingTime: false);
		}

		public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules, bool disableDaylightSavingTime)
		{
			return new TimeZoneInfo(id, baseUtcOffset, displayName, standardDisplayName, daylightDisplayName, adjustmentRules, disableDaylightSavingTime);
		}

		void IDeserializationCallback.OnDeserialization(object sender)
		{
			try
			{
				ValidateTimeZoneInfo(m_id, m_baseUtcOffset, m_adjustmentRules, out var adjustmentRulesSupportDst);
				if (adjustmentRulesSupportDst != m_supportsDaylightSavingTime)
				{
					throw new SerializationException(SR.GetString("Serialization_CorruptField", "SupportsDaylightSavingTime"));
				}
			}
			catch (ArgumentException innerException)
			{
				throw new SerializationException(SR.GetString("Serialization_InvalidData"), innerException);
			}
			catch (InvalidTimeZoneException innerException2)
			{
				throw new SerializationException(SR.GetString("Serialization_InvalidData"), innerException2);
			}
		}

		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
		void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
		{
			if (info == null)
			{
				throw new ArgumentNullException("info");
			}
			info.AddValue("Id", m_id);
			info.AddValue("DisplayName", m_displayName);
			info.AddValue("StandardName", m_standardDisplayName);
			info.AddValue("DaylightName", m_daylightDisplayName);
			info.AddValue("BaseUtcOffset", m_baseUtcOffset);
			info.AddValue("AdjustmentRules", m_adjustmentRules);
			info.AddValue("SupportsDaylightSavingTime", m_supportsDaylightSavingTime);
		}

		private TimeZoneInfo(SerializationInfo info, StreamingContext context)
		{
			if (info == null)
			{
				throw new ArgumentNullException("info");
			}
			m_id = (string)info.GetValue("Id", typeof(string));
			m_displayName = (string)info.GetValue("DisplayName", typeof(string));
			m_standardDisplayName = (string)info.GetValue("StandardName", typeof(string));
			m_daylightDisplayName = (string)info.GetValue("DaylightName", typeof(string));
			m_baseUtcOffset = (TimeSpan)info.GetValue("BaseUtcOffset", typeof(TimeSpan));
			m_adjustmentRules = (AdjustmentRule[])info.GetValue("AdjustmentRules", typeof(AdjustmentRule[]));
			m_supportsDaylightSavingTime = (bool)info.GetValue("SupportsDaylightSavingTime", typeof(bool));
		}

		private AdjustmentRule GetAdjustmentRuleForTime(DateTime dateTime)
		{
			if (m_adjustmentRules == null || m_adjustmentRules.Length == 0)
			{
				return null;
			}
			DateTime date = dateTime.Date;
			for (int i = 0; i < m_adjustmentRules.Length; i++)
			{
				if (m_adjustmentRules[i].DateStart <= date && m_adjustmentRules[i].DateEnd >= date)
				{
					return m_adjustmentRules[i];
				}
			}
			return null;
		}

		private DateTimeKind GetCorrespondingKind()
		{
			if (this == s_utcTimeZone)
			{
				return DateTimeKind.Utc;
			}
			if (this == s_localTimeZone)
			{
				return DateTimeKind.Local;
			}
			return DateTimeKind.Unspecified;
		}

		[SecurityCritical]
		[SecurityTreatAsSafe]
		private static bool CheckDaylightSavingTimeDisabled()
		{
			try
			{
				PermissionSet permissionSet = new PermissionSet(PermissionState.None);
				permissionSet.AddPermission(new RegistryPermission(RegistryPermissionAccess.Read, "HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation"));
				permissionSet.Assert();
				using RegistryKey registryKey = Registry.LocalMachine.OpenSubKey("SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation", RegistryKeyPermissionCheck.Default, RegistryRights.ExecuteKey);
				if (registryKey == null)
				{
					return false;
				}
				int num = 0;
				try
				{
					num = (int)registryKey.GetValue("DisableAutoDaylightTimeSet", 0, RegistryValueOptions.None);
				}
				catch (InvalidCastException)
				{
				}
				if (num == 1)
				{
					return true;
				}
				try
				{
					num = (int)registryKey.GetValue("DynamicDaylightTimeDisabled", 0, RegistryValueOptions.None);
				}
				catch (InvalidCastException)
				{
				}
				if (num == 1)
				{
					return true;
				}
			}
			finally
			{
				PermissionSet.RevertAssert();
			}
			return false;
		}

		private static bool CheckDaylightSavingTimeNotSupported(Microsoft.Win32.NativeMethods.TimeZoneInformation timeZone)
		{
			if (timeZone.DaylightDate.Year == timeZone.StandardDate.Year && timeZone.DaylightDate.Month == timeZone.StandardDate.Month && timeZone.DaylightDate.DayOfWeek == timeZone.StandardDate.DayOfWeek && timeZone.DaylightDate.Day == timeZone.StandardDate.Day && timeZone.DaylightDate.Hour == timeZone.StandardDate.Hour && timeZone.DaylightDate.Minute == timeZone.StandardDate.Minute && timeZone.DaylightDate.Second == timeZone.StandardDate.Second)
			{
				return timeZone.DaylightDate.Milliseconds == timeZone.StandardDate.Milliseconds;
			}
			return false;
		}

		private static DateTime ConvertUtcToTimeZone(long ticks, TimeZoneInfo destinationTimeZone)
		{
			DateTime time = ((ticks > DateTime.MaxValue.Ticks) ? DateTime.MaxValue : ((ticks >= DateTime.MinValue.Ticks) ? new DateTime(ticks) : DateTime.MinValue));
			ticks += GetUtcOffsetFromUtc(time, destinationTimeZone).Ticks;
			if (ticks > DateTime.MaxValue.Ticks)
			{
				return DateTime.MaxValue;
			}
			if (ticks < DateTime.MinValue.Ticks)
			{
				return DateTime.MinValue;
			}
			return new DateTime(ticks);
		}

		private static AdjustmentRule CreateAdjustmentRuleFromTimeZoneInformation(Microsoft.Win32.NativeMethods.RegistryTimeZoneInformation timeZoneInformation, DateTime startDate, DateTime endDate, int defaultBaseUtcOffset)
		{
			if (timeZoneInformation.StandardDate.Month == 0)
			{
				if (timeZoneInformation.Bias == defaultBaseUtcOffset)
				{
					return null;
				}
				AdjustmentRule adjustmentRule;
				return adjustmentRule = AdjustmentRule.CreateAdjustmentRule(startDate, endDate, TimeSpan.Zero, TransitionTime.CreateFixedDateRule(DateTime.MinValue, 1, 1), TransitionTime.CreateFixedDateRule(DateTime.MinValue.AddMilliseconds(1.0), 1, 1), new TimeSpan(0, defaultBaseUtcOffset - timeZoneInformation.Bias, 0));
			}
			TransitionTime? transitionTime = TransitionTimeFromTimeZoneInformation(timeZoneInformation, readStartDate: true);
			if (!transitionTime.HasValue)
			{
				return null;
			}
			TransitionTime? transitionTime2 = TransitionTimeFromTimeZoneInformation(timeZoneInformation, readStartDate: false);
			if (!transitionTime2.HasValue)
			{
				return null;
			}
			if (transitionTime.Equals(transitionTime2))
			{
				return null;
			}
			return AdjustmentRule.CreateAdjustmentRule(startDate, endDate, new TimeSpan(0, -timeZoneInformation.DaylightBias, 0), transitionTime.Value, transitionTime2.Value, new TimeSpan(0, defaultBaseUtcOffset - timeZoneInformation.Bias, 0));
		}

		[SecurityCritical]
		[SecurityTreatAsSafe]
		private static string FindIdFromTimeZoneInformation(Microsoft.Win32.NativeMethods.TimeZoneInformation timeZone, out bool dstDisabled)
		{
			dstDisabled = false;
			try
			{
				PermissionSet permissionSet = new PermissionSet(PermissionState.None);
				permissionSet.AddPermission(new RegistryPermission(RegistryPermissionAccess.Read, "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones"));
				permissionSet.Assert();
				using RegistryKey registryKey = Registry.LocalMachine.OpenSubKey("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones", RegistryKeyPermissionCheck.Default, RegistryRights.ExecuteKey);
				if (registryKey == null)
				{
					return null;
				}
				string[] subKeyNames = registryKey.GetSubKeyNames();
				foreach (string text in subKeyNames)
				{
					if (TryCompareTimeZoneInformationToRegistry(timeZone, text, out dstDisabled))
					{
						return text;
					}
				}
			}
			finally
			{
				PermissionSet.RevertAssert();
			}
			return null;
		}

		private static DaylightTime GetDaylightTime(int year, AdjustmentRule rule)
		{
			TimeSpan daylightDelta = rule.DaylightDelta;
			DateTime start = TransitionTimeToDateTime(year, rule.DaylightTransitionStart);
			DateTime end = TransitionTimeToDateTime(year, rule.DaylightTransitionEnd);
			return new DaylightTime(start, end, daylightDelta);
		}

		private static bool GetIsDaylightSavings(DateTime time, AdjustmentRule rule, DaylightTime daylightTime)
		{
			if (rule == null)
			{
				return false;
			}
			bool flag = rule.DaylightDelta > TimeSpan.Zero;
			DateTime startTime = (rule.IsStartDateMarkerForBeginningOfYear() ? new DateTime(daylightTime.Start.Year, 1, 1, 0, 0, 0) : (daylightTime.Start + (flag ? rule.DaylightDelta : TimeSpan.Zero)));
			DateTime endTime = (rule.IsEndDateMarkerForEndOfYear() ? new DateTime(daylightTime.End.Year + 1, 1, 1, 0, 0, 0).AddTicks(-1L) : (daylightTime.End + (flag ? (-rule.DaylightDelta) : TimeSpan.Zero)));
			return CheckIsDst(startTime, time, endTime, ignoreYearAdjustment: false);
		}

		private static bool GetIsDaylightSavingsFromUtc(DateTime time, int Year, TimeSpan utc, AdjustmentRule rule, TimeZoneInfo zone)
		{
			if (rule == null)
			{
				return false;
			}
			TimeSpan timeSpan = utc + rule.BaseUtcOffsetDelta;
			DaylightTime daylightTime = GetDaylightTime(Year, rule);
			bool ignoreYearAdjustment = false;
			DateTime startTime;
			if (rule.IsStartDateMarkerForBeginningOfYear() && daylightTime.Start.Year > DateTime.MinValue.Year)
			{
				AdjustmentRule adjustmentRuleForTime = zone.GetAdjustmentRuleForTime(new DateTime(daylightTime.Start.Year - 1, 12, 31));
				if (adjustmentRuleForTime != null && adjustmentRuleForTime.IsEndDateMarkerForEndOfYear())
				{
					DaylightTime daylightTime2 = GetDaylightTime(daylightTime.Start.Year - 1, adjustmentRuleForTime);
					startTime = daylightTime2.Start - utc - adjustmentRuleForTime.BaseUtcOffsetDelta;
					ignoreYearAdjustment = true;
				}
				else
				{
					startTime = new DateTime(daylightTime.Start.Year, 1, 1, 0, 0, 0) - timeSpan;
				}
			}
			else
			{
				startTime = daylightTime.Start - timeSpan;
			}
			DateTime endTime;
			if (rule.IsEndDateMarkerForEndOfYear() && daylightTime.End.Year < DateTime.MaxValue.Year)
			{
				AdjustmentRule adjustmentRuleForTime2 = zone.GetAdjustmentRuleForTime(new DateTime(daylightTime.End.Year + 1, 1, 1));
				if (adjustmentRuleForTime2 != null && adjustmentRuleForTime2.IsStartDateMarkerForBeginningOfYear())
				{
					if (adjustmentRuleForTime2.IsEndDateMarkerForEndOfYear())
					{
						endTime = new DateTime(daylightTime.End.Year + 1, 12, 31) - utc - adjustmentRuleForTime2.BaseUtcOffsetDelta - adjustmentRuleForTime2.DaylightDelta;
					}
					else
					{
						DaylightTime daylightTime3 = GetDaylightTime(daylightTime.End.Year + 1, adjustmentRuleForTime2);
						endTime = daylightTime3.End - utc - adjustmentRuleForTime2.BaseUtcOffsetDelta - adjustmentRuleForTime2.DaylightDelta;
					}
					ignoreYearAdjustment = true;
				}
				else
				{
					endTime = new DateTime(daylightTime.End.Year + 1, 1, 1, 0, 0, 0).AddTicks(-1L) - timeSpan - rule.DaylightDelta;
				}
			}
			else
			{
				endTime = daylightTime.End - timeSpan - rule.DaylightDelta;
			}
			return CheckIsDst(startTime, time, endTime, ignoreYearAdjustment);
		}

		private static bool CheckIsDst(DateTime startTime, DateTime time, DateTime endTime, bool ignoreYearAdjustment)
		{
			if (!ignoreYearAdjustment)
			{
				if (startTime.Year != endTime.Year)
				{
					endTime = endTime.AddYears(startTime.Year - endTime.Year);
				}
				if (startTime.Year != time.Year)
				{
					time = time.AddYears(startTime.Year - time.Year);
				}
			}
			if (startTime > endTime)
			{
				return time < endTime || time >= startTime;
			}
			return time >= startTime && time < endTime;
		}

		private static bool GetIsAmbiguousTime(DateTime time, AdjustmentRule rule, DaylightTime daylightTime)
		{
			bool result = false;
			if (rule == null || rule.DaylightDelta == TimeSpan.Zero)
			{
				return result;
			}
			DateTime dateTime;
			DateTime dateTime2;
			if (rule.DaylightDelta > TimeSpan.Zero)
			{
				if (rule.IsEndDateMarkerForEndOfYear())
				{
					return false;
				}
				dateTime = daylightTime.End;
				dateTime2 = daylightTime.End - rule.DaylightDelta;
			}
			else
			{
				if (rule.IsStartDateMarkerForBeginningOfYear())
				{
					return false;
				}
				dateTime = daylightTime.Start;
				dateTime2 = daylightTime.Start + rule.DaylightDelta;
			}
			result = time >= dateTime2 && time < dateTime;
			if (!result && dateTime.Year != dateTime2.Year)
			{
				try
				{
					DateTime dateTime3 = dateTime.AddYears(1);
					DateTime dateTime4 = dateTime2.AddYears(1);
					result = time >= dateTime4 && time < dateTime3;
				}
				catch (ArgumentOutOfRangeException)
				{
				}
				if (!result)
				{
					try
					{
						DateTime dateTime3 = dateTime.AddYears(-1);
						DateTime dateTime4 = dateTime2.AddYears(-1);
						result = time >= dateTime4 && time < dateTime3;
						return result;
					}
					catch (ArgumentOutOfRangeException)
					{
						return result;
					}
				}
			}
			return result;
		}

		private static bool GetIsInvalidTime(DateTime time, AdjustmentRule rule, DaylightTime daylightTime)
		{
			bool result = false;
			if (rule == null || rule.DaylightDelta == TimeSpan.Zero)
			{
				return result;
			}
			DateTime dateTime;
			DateTime dateTime2;
			if (rule.DaylightDelta < TimeSpan.Zero)
			{
				dateTime = daylightTime.End;
				dateTime2 = daylightTime.End - rule.DaylightDelta;
			}
			else
			{
				dateTime = daylightTime.Start;
				dateTime2 = daylightTime.Start + rule.DaylightDelta;
			}
			result = time >= dateTime && time < dateTime2;
			if (!result && dateTime.Year != dateTime2.Year)
			{
				try
				{
					DateTime dateTime3 = dateTime.AddYears(1);
					DateTime dateTime4 = dateTime2.AddYears(1);
					result = time >= dateTime3 && time < dateTime4;
				}
				catch (ArgumentOutOfRangeException)
				{
				}
				if (!result)
				{
					try
					{
						DateTime dateTime3 = dateTime.AddYears(-1);
						DateTime dateTime4 = dateTime2.AddYears(-1);
						result = time >= dateTime3 && time < dateTime4;
						return result;
					}
					catch (ArgumentOutOfRangeException)
					{
						return result;
					}
				}
			}
			return result;
		}

		[SecurityCritical]
		private static TimeZoneInfo GetLocalTimeZone()
		{
			string text = null;
			try
			{
				Microsoft.Win32.NativeMethods.DynamicTimeZoneInformation lpDynamicTimeZoneInformation = default(Microsoft.Win32.NativeMethods.DynamicTimeZoneInformation);
				long num = Microsoft.Win32.UnsafeNativeMethods.GetDynamicTimeZoneInformation(out lpDynamicTimeZoneInformation);
				if (num == -1)
				{
					return CreateCustomTimeZone("Local", TimeSpan.Zero, "Local", "Local");
				}
				Microsoft.Win32.NativeMethods.TimeZoneInformation timeZoneInformation = new Microsoft.Win32.NativeMethods.TimeZoneInformation(lpDynamicTimeZoneInformation);
				bool dstDisabled = CheckDaylightSavingTimeDisabled();
				if (!string.IsNullOrEmpty(lpDynamicTimeZoneInformation.TimeZoneKeyName) && TryGetTimeZone(lpDynamicTimeZoneInformation.TimeZoneKeyName, dstDisabled, out var value, out var _) == TimeZoneInfoResult.Success)
				{
					return value;
				}
				text = FindIdFromTimeZoneInformation(timeZoneInformation, out dstDisabled);
				if (text != null && TryGetTimeZone(text, dstDisabled, out var value2, out var _) == TimeZoneInfoResult.Success)
				{
					return value2;
				}
				return GetLocalTimeZoneFromWin32Data(timeZoneInformation, dstDisabled);
			}
			catch (EntryPointNotFoundException)
			{
				Microsoft.Win32.NativeMethods.TimeZoneInformation lpTimeZoneInformation = default(Microsoft.Win32.NativeMethods.TimeZoneInformation);
				long num2 = Microsoft.Win32.UnsafeNativeMethods.GetTimeZoneInformation(out lpTimeZoneInformation);
				if (num2 == -1)
				{
					return CreateCustomTimeZone("Local", TimeSpan.Zero, "Local", "Local");
				}
				text = FindIdFromTimeZoneInformation(lpTimeZoneInformation, out var dstDisabled2);
				if (text != null && TryGetTimeZone(text, dstDisabled2, out var value3, out var _) == TimeZoneInfoResult.Success)
				{
					return value3;
				}
				return GetLocalTimeZoneFromWin32Data(lpTimeZoneInformation, dstDisabled2);
			}
		}

		private static TimeZoneInfo GetLocalTimeZoneFromWin32Data(Microsoft.Win32.NativeMethods.TimeZoneInformation timeZoneInformation, bool dstDisabled)
		{
			try
			{
				return new TimeZoneInfo(timeZoneInformation, dstDisabled);
			}
			catch (ArgumentException)
			{
			}
			catch (InvalidTimeZoneException)
			{
			}
			try
			{
				return new TimeZoneInfo(timeZoneInformation, dstDisabled: true);
			}
			catch (ArgumentException)
			{
			}
			catch (InvalidTimeZoneException)
			{
			}
			return CreateCustomTimeZone("Local", TimeSpan.Zero, "Local", "Local");
		}

		private static TimeZoneInfo GetTimeZone(string id)
		{
			if (id == null)
			{
				throw new ArgumentNullException("id");
			}
			if (id.Length == 0 || id.Length > 255 || id.Contains("\0"))
			{
				throw new TimeZoneNotFoundException(SR.GetString("TimeZoneNotFound_MissingRegistryData", id));
			}
			TimeZoneInfo value;
			Exception e;
			return TryGetTimeZone(id, dstDisabled: false, out value, out e) switch
			{
				TimeZoneInfoResult.Success => value, 
				TimeZoneInfoResult.InvalidTimeZoneException => throw new InvalidTimeZoneException(SR.GetString("InvalidTimeZone_InvalidRegistryData", id), e), 
				TimeZoneInfoResult.SecurityException => throw new SecurityException(SR.GetString("Security_CannotReadRegistryData", id), e), 
				_ => throw new TimeZoneNotFoundException(SR.GetString("TimeZoneNotFound_MissingRegistryData", id), e), 
			};
		}

		private static TimeSpan GetUtcOffset(DateTime time, TimeZoneInfo zone)
		{
			TimeSpan baseUtcOffset = zone.BaseUtcOffset;
			AdjustmentRule adjustmentRuleForTime = zone.GetAdjustmentRuleForTime(time);
			if (adjustmentRuleForTime != null)
			{
				baseUtcOffset += adjustmentRuleForTime.BaseUtcOffsetDelta;
				if (adjustmentRuleForTime.HasDaylightSaving)
				{
					DaylightTime daylightTime = GetDaylightTime(time.Year, adjustmentRuleForTime);
					bool isDaylightSavings = GetIsDaylightSavings(time, adjustmentRuleForTime, daylightTime);
					baseUtcOffset += (isDaylightSavings ? adjustmentRuleForTime.DaylightDelta : TimeSpan.Zero);
				}
			}
			return baseUtcOffset;
		}

		private static TimeSpan GetUtcOffsetFromUtc(DateTime time, TimeZoneInfo zone)
		{
			bool isDaylightSavings;
			return GetUtcOffsetFromUtc(time, zone, out isDaylightSavings);
		}

		private static TimeSpan GetUtcOffsetFromUtc(DateTime time, TimeZoneInfo zone, out bool isDaylightSavings)
		{
			isDaylightSavings = false;
			TimeSpan baseUtcOffset = zone.BaseUtcOffset;
			AdjustmentRule adjustmentRuleForTime;
			int year;
			if (time > new DateTime(9999, 12, 31))
			{
				adjustmentRuleForTime = zone.GetAdjustmentRuleForTime(DateTime.MaxValue);
				year = 9999;
			}
			else if (time < new DateTime(1, 1, 2))
			{
				adjustmentRuleForTime = zone.GetAdjustmentRuleForTime(DateTime.MinValue);
				year = 1;
			}
			else
			{
				DateTime dateTime = time + baseUtcOffset;
				year = dateTime.Year;
				adjustmentRuleForTime = zone.GetAdjustmentRuleForTime(dateTime);
			}
			if (adjustmentRuleForTime != null)
			{
				baseUtcOffset += adjustmentRuleForTime.BaseUtcOffsetDelta;
				if (adjustmentRuleForTime.HasDaylightSaving)
				{
					isDaylightSavings = GetIsDaylightSavingsFromUtc(time, year, zone.m_baseUtcOffset, adjustmentRuleForTime, zone);
					baseUtcOffset += (isDaylightSavings ? adjustmentRuleForTime.DaylightDelta : TimeSpan.Zero);
				}
			}
			return baseUtcOffset;
		}

		private static TransitionTime? TransitionTimeFromTimeZoneInformation(Microsoft.Win32.NativeMethods.RegistryTimeZoneInformation timeZoneInformation, bool readStartDate)
		{
			if (timeZoneInformation.StandardDate.Month == 0)
			{
				return null;
			}
			return readStartDate ? ((timeZoneInformation.DaylightDate.Year != 0) ? TransitionTime.CreateFixedDateRule(new DateTime(1, 1, 1, timeZoneInformation.DaylightDate.Hour, timeZoneInformation.DaylightDate.Minute, timeZoneInformation.DaylightDate.Second, timeZoneInformation.DaylightDate.Milliseconds), timeZoneInformation.DaylightDate.Month, timeZoneInformation.DaylightDate.Day) : TransitionTime.CreateFloatingDateRule(new DateTime(1, 1, 1, timeZoneInformation.DaylightDate.Hour, timeZoneInformation.DaylightDate.Minute, timeZoneInformation.DaylightDate.Second, timeZoneInformation.DaylightDate.Milliseconds), timeZoneInformation.DaylightDate.Month, timeZoneInformation.DaylightDate.Day, (DayOfWeek)timeZoneInformation.DaylightDate.DayOfWeek)) : ((timeZoneInformation.StandardDate.Year != 0) ? TransitionTime.CreateFixedDateRule(new DateTime(1, 1, 1, timeZoneInformation.StandardDate.Hour, timeZoneInformation.StandardDate.Minute, timeZoneInformation.StandardDate.Second, timeZoneInformation.StandardDate.Milliseconds), timeZoneInformation.StandardDate.Month, timeZoneInformation.StandardDate.Day) : TransitionTime.CreateFloatingDateRule(new DateTime(1, 1, 1, timeZoneInformation.StandardDate.Hour, timeZoneInformation.StandardDate.Minute, timeZoneInformation.StandardDate.Second, timeZoneInformation.StandardDate.Milliseconds), timeZoneInformation.StandardDate.Month, timeZoneInformation.StandardDate.Day, (DayOfWeek)timeZoneInformation.StandardDate.DayOfWeek));
		}

		private static DateTime TransitionTimeToDateTime(int year, TransitionTime transitionTime)
		{
			DateTime timeOfDay = transitionTime.TimeOfDay;
			DateTime result;
			if (transitionTime.IsFixedDateRule)
			{
				int num = DateTime.DaysInMonth(year, transitionTime.Month);
				result = new DateTime(year, transitionTime.Month, (num < transitionTime.Day) ? num : transitionTime.Day, timeOfDay.Hour, timeOfDay.Minute, timeOfDay.Second, timeOfDay.Millisecond);
			}
			else if (transitionTime.Week <= 4)
			{
				result = new DateTime(year, transitionTime.Month, 1, timeOfDay.Hour, timeOfDay.Minute, timeOfDay.Second, timeOfDay.Millisecond);
				int dayOfWeek = (int)result.DayOfWeek;
				int num2 = (int)(transitionTime.DayOfWeek - dayOfWeek);
				if (num2 < 0)
				{
					num2 += 7;
				}
				num2 += 7 * (transitionTime.Week - 1);
				if (num2 > 0)
				{
					return result.AddDays(num2);
				}
			}
			else
			{
				int day = DateTime.DaysInMonth(year, transitionTime.Month);
				result = new DateTime(year, transitionTime.Month, day, timeOfDay.Hour, timeOfDay.Minute, timeOfDay.Second, timeOfDay.Millisecond);
				int dayOfWeek2 = (int)result.DayOfWeek;
				int num3 = (int)(dayOfWeek2 - transitionTime.DayOfWeek);
				if (num3 < 0)
				{
					num3 += 7;
				}
				if (num3 > 0)
				{
					return result.AddDays(-num3);
				}
			}
			return result;
		}

		private static bool TryCreateAdjustmentRules(string id, Microsoft.Win32.NativeMethods.RegistryTimeZoneInformation defaultTimeZoneInformation, out AdjustmentRule[] rules, out Exception e, int defaultBaseUtcOffset)
		{
			e = null;
			try
			{
				using RegistryKey registryKey = Registry.LocalMachine.OpenSubKey(string.Format(CultureInfo.InvariantCulture, "{0}\\{1}\\Dynamic DST", "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones", id), RegistryKeyPermissionCheck.Default, RegistryRights.ExecuteKey);
				if (registryKey == null)
				{
					AdjustmentRule adjustmentRule = CreateAdjustmentRuleFromTimeZoneInformation(defaultTimeZoneInformation, DateTime.MinValue.Date, DateTime.MaxValue.Date, defaultBaseUtcOffset);
					if (adjustmentRule == null)
					{
						rules = null;
					}
					else
					{
						rules = new AdjustmentRule[1];
						rules[0] = adjustmentRule;
					}
					return true;
				}
				int num = (int)registryKey.GetValue("FirstEntry", -1, RegistryValueOptions.None);
				int num2 = (int)registryKey.GetValue("LastEntry", -1, RegistryValueOptions.None);
				if (num == -1 || num2 == -1 || num > num2)
				{
					rules = null;
					return false;
				}
				Microsoft.Win32.NativeMethods.RegistryTimeZoneInformation timeZoneInformation = new Microsoft.Win32.NativeMethods.RegistryTimeZoneInformation((byte[])registryKey.GetValue(num.ToString(CultureInfo.InvariantCulture), null, RegistryValueOptions.None));
				if (num == num2)
				{
					AdjustmentRule adjustmentRule2 = CreateAdjustmentRuleFromTimeZoneInformation(timeZoneInformation, DateTime.MinValue.Date, DateTime.MaxValue.Date, defaultBaseUtcOffset);
					if (adjustmentRule2 == null)
					{
						rules = null;
					}
					else
					{
						rules = new AdjustmentRule[1];
						rules[0] = adjustmentRule2;
					}
					return true;
				}
				List<AdjustmentRule> list = new List<AdjustmentRule>(1);
				AdjustmentRule adjustmentRule3 = CreateAdjustmentRuleFromTimeZoneInformation(timeZoneInformation, DateTime.MinValue.Date, new DateTime(num, 12, 31), defaultBaseUtcOffset);
				if (adjustmentRule3 != null)
				{
					list.Add(adjustmentRule3);
				}
				for (int i = num + 1; i < num2; i++)
				{
					timeZoneInformation = new Microsoft.Win32.NativeMethods.RegistryTimeZoneInformation((byte[])registryKey.GetValue(i.ToString(CultureInfo.InvariantCulture), null, RegistryValueOptions.None));
					AdjustmentRule adjustmentRule4 = CreateAdjustmentRuleFromTimeZoneInformation(timeZoneInformation, new DateTime(i, 1, 1), new DateTime(i, 12, 31), defaultBaseUtcOffset);
					if (adjustmentRule4 != null)
					{
						list.Add(adjustmentRule4);
					}
				}
				timeZoneInformation = new Microsoft.Win32.NativeMethods.RegistryTimeZoneInformation((byte[])registryKey.GetValue(num2.ToString(CultureInfo.InvariantCulture), null, RegistryValueOptions.None));
				AdjustmentRule adjustmentRule5 = CreateAdjustmentRuleFromTimeZoneInformation(timeZoneInformation, new DateTime(num2, 1, 1), DateTime.MaxValue.Date, defaultBaseUtcOffset);
				if (adjustmentRule5 != null)
				{
					list.Add(adjustmentRule5);
				}
				rules = list.ToArray();
				if (rules != null && rules.Length == 0)
				{
					rules = null;
				}
			}
			catch (InvalidCastException ex)
			{
				rules = null;
				e = ex;
				return false;
			}
			catch (ArgumentOutOfRangeException ex2)
			{
				rules = null;
				e = ex2;
				return false;
			}
			catch (ArgumentException ex3)
			{
				rules = null;
				e = ex3;
				return false;
			}
			return true;
		}

		private static bool TryCompareStandardDate(Microsoft.Win32.NativeMethods.TimeZoneInformation timeZone, Microsoft.Win32.NativeMethods.RegistryTimeZoneInformation registryTimeZoneInfo)
		{
			if (timeZone.Bias == registryTimeZoneInfo.Bias && timeZone.StandardBias == registryTimeZoneInfo.StandardBias && timeZone.StandardDate.Year == registryTimeZoneInfo.StandardDate.Year && timeZone.StandardDate.Month == registryTimeZoneInfo.StandardDate.Month && timeZone.StandardDate.DayOfWeek == registryTimeZoneInfo.StandardDate.DayOfWeek && timeZone.StandardDate.Day == registryTimeZoneInfo.StandardDate.Day && timeZone.StandardDate.Hour == registryTimeZoneInfo.StandardDate.Hour && timeZone.StandardDate.Minute == registryTimeZoneInfo.StandardDate.Minute && timeZone.StandardDate.Second == registryTimeZoneInfo.StandardDate.Second)
			{
				return timeZone.StandardDate.Milliseconds == registryTimeZoneInfo.StandardDate.Milliseconds;
			}
			return false;
		}

		[SecurityCritical]
		[SecurityTreatAsSafe]
		private static bool TryCompareTimeZoneInformationToRegistry(Microsoft.Win32.NativeMethods.TimeZoneInformation timeZone, string id, out bool dstDisabled)
		{
			dstDisabled = false;
			try
			{
				PermissionSet permissionSet = new PermissionSet(PermissionState.None);
				permissionSet.AddPermission(new RegistryPermission(RegistryPermissionAccess.Read, "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones"));
				permissionSet.Assert();
				using RegistryKey registryKey = Registry.LocalMachine.OpenSubKey(string.Format(CultureInfo.InvariantCulture, "{0}\\{1}", "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones", id), RegistryKeyPermissionCheck.Default, RegistryRights.ExecuteKey);
				if (registryKey == null)
				{
					return false;
				}
				Microsoft.Win32.NativeMethods.RegistryTimeZoneInformation registryTimeZoneInfo;
				try
				{
					registryTimeZoneInfo = new Microsoft.Win32.NativeMethods.RegistryTimeZoneInformation((byte[])registryKey.GetValue("TZI", null, RegistryValueOptions.None));
				}
				catch (InvalidCastException)
				{
					return false;
				}
				catch (ArgumentException)
				{
					return false;
				}
				if (!TryCompareStandardDate(timeZone, registryTimeZoneInfo))
				{
					return false;
				}
				dstDisabled = CheckDaylightSavingTimeDisabled();
				bool flag = dstDisabled || CheckDaylightSavingTimeNotSupported(timeZone) || (timeZone.DaylightBias == registryTimeZoneInfo.DaylightBias && timeZone.DaylightDate.Year == registryTimeZoneInfo.DaylightDate.Year && timeZone.DaylightDate.Month == registryTimeZoneInfo.DaylightDate.Month && timeZone.DaylightDate.DayOfWeek == registryTimeZoneInfo.DaylightDate.DayOfWeek && timeZone.DaylightDate.Day == registryTimeZoneInfo.DaylightDate.Day && timeZone.DaylightDate.Hour == registryTimeZoneInfo.DaylightDate.Hour && timeZone.DaylightDate.Minute == registryTimeZoneInfo.DaylightDate.Minute && timeZone.DaylightDate.Second == registryTimeZoneInfo.DaylightDate.Second && timeZone.DaylightDate.Milliseconds == registryTimeZoneInfo.DaylightDate.Milliseconds);
				if (flag)
				{
					string strA = registryKey.GetValue("Std", string.Empty, RegistryValueOptions.None) as string;
					flag = string.Compare(strA, timeZone.StandardName, StringComparison.Ordinal) == 0;
				}
				return flag;
			}
			finally
			{
				PermissionSet.RevertAssert();
			}
		}

		[SecurityCritical]
		[SecurityTreatAsSafe]
		[FileIOPermission(SecurityAction.Assert, AllLocalFiles = FileIOPermissionAccess.PathDiscovery)]
		private static string TryGetLocalizedNameByMuiNativeResource(string resource)
		{
			if (string.IsNullOrEmpty(resource))
			{
				return string.Empty;
			}
			string[] array = resource.Split(new char[1] { ',' }, StringSplitOptions.None);
			if (array.Length != 2)
			{
				return string.Empty;
			}
			string folderPath = Environment.GetFolderPath(Environment.SpecialFolder.System);
			string path = array[0].TrimStart('@');
			string filePath;
			try
			{
				filePath = Path.Combine(folderPath, path);
			}
			catch (ArgumentException)
			{
				return string.Empty;
			}
			if (!int.TryParse(array[1], NumberStyles.Integer, CultureInfo.InvariantCulture, out var result))
			{
				return string.Empty;
			}
			result = -result;
			try
			{
				StringBuilder stringBuilder = new StringBuilder(260);
				stringBuilder.Length = 260;
				int fileMuiPathLength = 260;
				int languageLength = 0;
				long enumerator = 0L;
				if (!Microsoft.Win32.UnsafeNativeMethods.GetFileMUIPath(16, filePath, null, ref languageLength, stringBuilder, ref fileMuiPathLength, ref enumerator))
				{
					return string.Empty;
				}
				return TryGetLocalizedNameByNativeResource(stringBuilder.ToString(), result);
			}
			catch (EntryPointNotFoundException)
			{
				return string.Empty;
			}
		}

		[SecurityCritical]
		private static string TryGetLocalizedNameByNativeResource(string filePath, int resource)
		{
			if (!File.Exists(filePath))
			{
				return string.Empty;
			}
			using (SafeLibraryHandle safeLibraryHandle = Microsoft.Win32.UnsafeNativeMethods.LoadLibraryEx(filePath, IntPtr.Zero, 2))
			{
				if (!safeLibraryHandle.IsInvalid)
				{
					StringBuilder stringBuilder = new StringBuilder(500);
					stringBuilder.Length = 500;
					if (Microsoft.Win32.UnsafeNativeMethods.LoadString(safeLibraryHandle, resource, stringBuilder, stringBuilder.Length) != 0)
					{
						return stringBuilder.ToString();
					}
				}
			}
			return string.Empty;
		}

		private static bool TryGetLocalizedNamesByRegistryKey(RegistryKey key, out string displayName, out string standardName, out string daylightName)
		{
			displayName = string.Empty;
			standardName = string.Empty;
			daylightName = string.Empty;
			string text = key.GetValue("MUI_Display", string.Empty, RegistryValueOptions.None) as string;
			string text2 = key.GetValue("MUI_Std", string.Empty, RegistryValueOptions.None) as string;
			string text3 = key.GetValue("MUI_Dlt", string.Empty, RegistryValueOptions.None) as string;
			if (!string.IsNullOrEmpty(text))
			{
				displayName = TryGetLocalizedNameByMuiNativeResource(text);
			}
			if (!string.IsNullOrEmpty(text2))
			{
				standardName = TryGetLocalizedNameByMuiNativeResource(text2);
			}
			if (!string.IsNullOrEmpty(text3))
			{
				daylightName = TryGetLocalizedNameByMuiNativeResource(text3);
			}
			if (string.IsNullOrEmpty(displayName))
			{
				displayName = key.GetValue("Display", string.Empty, RegistryValueOptions.None) as string;
			}
			if (string.IsNullOrEmpty(standardName))
			{
				standardName = key.GetValue("Std", string.Empty, RegistryValueOptions.None) as string;
			}
			if (string.IsNullOrEmpty(daylightName))
			{
				daylightName = key.GetValue("Dlt", string.Empty, RegistryValueOptions.None) as string;
			}
			return true;
		}

		[SecurityTreatAsSafe]
		[SecurityCritical]
		private static TimeZoneInfoResult TryGetTimeZoneByRegistryKey(string id, out TimeZoneInfo value, out Exception e)
		{
			e = null;
			try
			{
				PermissionSet permissionSet = new PermissionSet(PermissionState.None);
				permissionSet.AddPermission(new RegistryPermission(RegistryPermissionAccess.Read, "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones"));
				permissionSet.Assert();
				using RegistryKey registryKey = Registry.LocalMachine.OpenSubKey(string.Format(CultureInfo.InvariantCulture, "{0}\\{1}", "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones", id), RegistryKeyPermissionCheck.Default, RegistryRights.ExecuteKey);
				if (registryKey == null)
				{
					value = null;
					return TimeZoneInfoResult.TimeZoneNotFoundException;
				}
				Microsoft.Win32.NativeMethods.RegistryTimeZoneInformation defaultTimeZoneInformation;
				try
				{
					defaultTimeZoneInformation = new Microsoft.Win32.NativeMethods.RegistryTimeZoneInformation((byte[])registryKey.GetValue("TZI", null, RegistryValueOptions.None));
				}
				catch (InvalidCastException ex)
				{
					value = null;
					e = ex;
					return TimeZoneInfoResult.InvalidTimeZoneException;
				}
				catch (ArgumentException ex2)
				{
					value = null;
					e = ex2;
					return TimeZoneInfoResult.InvalidTimeZoneException;
				}
				if (!TryCreateAdjustmentRules(id, defaultTimeZoneInformation, out var rules, out e, defaultTimeZoneInformation.Bias))
				{
					value = null;
					return TimeZoneInfoResult.InvalidTimeZoneException;
				}
				if (!TryGetLocalizedNamesByRegistryKey(registryKey, out var displayName, out var standardName, out var daylightName))
				{
					value = null;
					return TimeZoneInfoResult.InvalidTimeZoneException;
				}
				try
				{
					value = new TimeZoneInfo(id, new TimeSpan(0, -defaultTimeZoneInformation.Bias, 0), displayName, standardName, daylightName, rules, disableDaylightSavingTime: false);
					return TimeZoneInfoResult.Success;
				}
				catch (ArgumentException ex3)
				{
					value = null;
					e = ex3;
					return TimeZoneInfoResult.InvalidTimeZoneException;
				}
				catch (InvalidTimeZoneException ex4)
				{
					value = null;
					e = ex4;
					return TimeZoneInfoResult.InvalidTimeZoneException;
				}
			}
			finally
			{
				PermissionSet.RevertAssert();
			}
		}

		private static TimeZoneInfoResult TryGetTimeZone(string id, bool dstDisabled, out TimeZoneInfo value, out Exception e)
		{
			TimeZoneInfoResult result = TimeZoneInfoResult.Success;
			e = null;
			TimeZoneInfo value2 = null;
			if (s_systemTimeZones.TryGetValue(id, out value2))
			{
				if (dstDisabled && value2.m_supportsDaylightSavingTime)
				{
					value = CreateCustomTimeZone(value2.m_id, value2.m_baseUtcOffset, value2.m_displayName, value2.m_standardDisplayName);
				}
				else
				{
					value = new TimeZoneInfo(value2.m_id, value2.m_baseUtcOffset, value2.m_displayName, value2.m_standardDisplayName, value2.m_daylightDisplayName, value2.m_adjustmentRules, disableDaylightSavingTime: false);
				}
				return result;
			}
			if (!s_allSystemTimeZonesRead)
			{
				result = TryGetTimeZoneByRegistryKey(id, out value2, out e);
				if (result == TimeZoneInfoResult.Success)
				{
					s_systemTimeZones.Add(id, value2);
					if (dstDisabled && value2.m_supportsDaylightSavingTime)
					{
						value = CreateCustomTimeZone(value2.m_id, value2.m_baseUtcOffset, value2.m_displayName, value2.m_standardDisplayName);
					}
					else
					{
						value = new TimeZoneInfo(value2.m_id, value2.m_baseUtcOffset, value2.m_displayName, value2.m_standardDisplayName, value2.m_daylightDisplayName, value2.m_adjustmentRules, disableDaylightSavingTime: false);
					}
				}
				else
				{
					value = null;
				}
			}
			else
			{
				result = TimeZoneInfoResult.TimeZoneNotFoundException;
				value = null;
			}
			return result;
		}

		internal static bool UtcOffsetOutOfRange(TimeSpan offset)
		{
			if (!(offset.TotalHours < -14.0))
			{
				return offset.TotalHours > 14.0;
			}
			return true;
		}

		private static void ValidateTimeZoneInfo(string id, TimeSpan baseUtcOffset, AdjustmentRule[] adjustmentRules, out bool adjustmentRulesSupportDst)
		{
			adjustmentRulesSupportDst = false;
			if (id == null)
			{
				throw new ArgumentNullException("id");
			}
			if (id.Length == 0)
			{
				throw new ArgumentException(SR.GetString("Argument_InvalidId", id), "id");
			}
			if (UtcOffsetOutOfRange(baseUtcOffset))
			{
				throw new ArgumentOutOfRangeException("baseUtcOffset", SR.GetString("ArgumentOutOfRange_UtcOffset"));
			}
			if (baseUtcOffset.Ticks % 600000000 != 0)
			{
				throw new ArgumentException(SR.GetString("Argument_TimeSpanHasSeconds"), "baseUtcOffset");
			}
			if (adjustmentRules == null || adjustmentRules.Length == 0)
			{
				return;
			}
			adjustmentRulesSupportDst = true;
			AdjustmentRule adjustmentRule = null;
			AdjustmentRule adjustmentRule2 = null;
			for (int i = 0; i < adjustmentRules.Length; i++)
			{
				adjustmentRule = adjustmentRule2;
				adjustmentRule2 = adjustmentRules[i];
				if (adjustmentRule2 == null)
				{
					throw new InvalidTimeZoneException(SR.GetString("Argument_AdjustmentRulesNoNulls"));
				}
				if (UtcOffsetOutOfRange(baseUtcOffset + adjustmentRule2.DaylightDelta))
				{
					throw new InvalidTimeZoneException(SR.GetString("ArgumentOutOfRange_UtcOffsetAndDaylightDelta"));
				}
				if (adjustmentRule != null && adjustmentRule2.DateStart <= adjustmentRule.DateEnd)
				{
					throw new InvalidTimeZoneException(SR.GetString("Argument_AdjustmentRulesOutOfOrder"));
				}
			}
		}
	}
	[Serializable]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class TimeZoneNotFoundException : Exception
	{
		public TimeZoneNotFoundException(string message)
			: base(message)
		{
		}

		public TimeZoneNotFoundException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		protected TimeZoneNotFoundException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}

		public TimeZoneNotFoundException()
		{
		}
	}
	[Serializable]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class InvalidTimeZoneException : Exception
	{
		public InvalidTimeZoneException(string message)
			: base(message)
		{
		}

		public InvalidTimeZoneException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		protected InvalidTimeZoneException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}

		public InvalidTimeZoneException()
		{
		}
	}
}
namespace System.IO
{
	internal static class __Error
	{
		internal static void EndOfFile()
		{
			throw new EndOfStreamException(SR.GetString("IO_EOF_ReadBeyondEOF"));
		}

		internal static void FileNotOpen()
		{
			throw new ObjectDisposedException(null, SR.GetString("ObjectDisposed_FileClosed"));
		}

		internal static void PipeNotOpen()
		{
			throw new ObjectDisposedException(null, SR.GetString("ObjectDisposed_PipeClosed"));
		}

		internal static void ReadNotSupported()
		{
			throw new NotSupportedException(SR.GetString("NotSupported_UnreadableStream"));
		}

		internal static void SeekNotSupported()
		{
			throw new NotSupportedException(SR.GetString("NotSupported_UnseekableStream"));
		}

		internal static void WrongAsyncResult()
		{
			throw new ArgumentException(SR.GetString("Argument_WrongAsyncResult"));
		}

		internal static void EndReadCalledTwice()
		{
			throw new ArgumentException(SR.GetString("InvalidOperation_EndReadCalledMultiple"));
		}

		internal static void EndWriteCalledTwice()
		{
			throw new ArgumentException(SR.GetString("InvalidOperation_EndWriteCalledMultiple"));
		}

		internal static void EndWaitForConnectionCalledTwice()
		{
			throw new ArgumentException(SR.GetString("InvalidOperation_EndWaitForConnectionCalledMultiple"));
		}

		internal static string GetDisplayablePath(string path, bool isInvalidPath)
		{
			if (string.IsNullOrEmpty(path))
			{
				return path;
			}
			bool flag = false;
			if (path.Length < 2)
			{
				return path;
			}
			if (path[0] == Path.DirectorySeparatorChar && path[1] == Path.DirectorySeparatorChar)
			{
				flag = true;
			}
			else if (path[1] == Path.VolumeSeparatorChar)
			{
				flag = true;
			}
			if (!flag && !isInvalidPath)
			{
				return path;
			}
			bool flag2 = false;
			try
			{
				if (!isInvalidPath)
				{
					new FileIOPermission(FileIOPermissionAccess.PathDiscovery, new string[1] { path }).Demand();
					flag2 = true;
				}
			}
			catch (SecurityException)
			{
			}
			catch (ArgumentException)
			{
			}
			catch (NotSupportedException)
			{
			}
			if (!flag2)
			{
				path = ((path[path.Length - 1] != Path.DirectorySeparatorChar) ? Path.GetFileName(path) : SR.GetString("IO_IO_NoPermissionToDirectoryName"));
			}
			return path;
		}

		[SecurityCritical]
		internal static void WinIOError()
		{
			int lastWin32Error = Marshal.GetLastWin32Error();
			WinIOError(lastWin32Error, string.Empty);
		}

		[SecurityCritical]
		internal static void WinIOError(int errorCode, string maybeFullPath)
		{
			bool isInvalidPath = errorCode == 123 || errorCode == 161;
			string displayablePath = GetDisplayablePath(maybeFullPath, isInvalidPath);
			switch (errorCode)
			{
			case 2:
				if (displayablePath.Length == 0)
				{
					throw new FileNotFoundException(SR.GetString("IO_FileNotFound"));
				}
				throw new FileNotFoundException(string.Format(CultureInfo.CurrentCulture, SR.GetString("IO_FileNotFound_FileName"), displayablePath), displayablePath);
			case 3:
				if (displayablePath.Length == 0)
				{
					throw new DirectoryNotFoundException(SR.GetString("IO_PathNotFound_NoPathName"));
				}
				throw new DirectoryNotFoundException(string.Format(CultureInfo.CurrentCulture, SR.GetString("IO_PathNotFound_Path"), displayablePath));
			case 5:
				if (displayablePath.Length == 0)
				{
					throw new UnauthorizedAccessException(SR.GetString("UnauthorizedAccess_IODenied_NoPathName"));
				}
				throw new UnauthorizedAccessException(string.Format(CultureInfo.CurrentCulture, SR.GetString("UnauthorizedAccess_IODenied_Path"), displayablePath));
			case 183:
				if (displayablePath.Length != 0)
				{
					throw new IOException(SR.GetString("IO_IO_AlreadyExists_Name", displayablePath), Microsoft.Win32.UnsafeNativeMethods.MakeHRFromErrorCode(errorCode));
				}
				break;
			case 206:
				throw new PathTooLongException(SR.GetString("IO_PathTooLong"));
			case 15:
				throw new DriveNotFoundException(string.Format(CultureInfo.CurrentCulture, SR.GetString("IO_DriveNotFound_Drive"), displayablePath));
			case 87:
				throw new IOException(Microsoft.Win32.UnsafeNativeMethods.GetMessage(errorCode), Microsoft.Win32.UnsafeNativeMethods.MakeHRFromErrorCode(errorCode));
			case 32:
				if (displayablePath.Length == 0)
				{
					throw new IOException(SR.GetString("IO_IO_SharingViolation_NoFileName"), Microsoft.Win32.UnsafeNativeMethods.MakeHRFromErrorCode(errorCode));
				}
				throw new IOException(SR.GetString("IO_IO_SharingViolation_File", displayablePath), Microsoft.Win32.UnsafeNativeMethods.MakeHRFromErrorCode(errorCode));
			case 80:
				if (displayablePath.Length != 0)
				{
					throw new IOException(string.Format(CultureInfo.CurrentCulture, SR.GetString("IO_IO_FileExists_Name"), displayablePath), Microsoft.Win32.UnsafeNativeMethods.MakeHRFromErrorCode(errorCode));
				}
				break;
			case 995:
				throw new OperationCanceledException();
			}
			throw new IOException(Microsoft.Win32.UnsafeNativeMethods.GetMessage(errorCode), Microsoft.Win32.UnsafeNativeMethods.MakeHRFromErrorCode(errorCode));
		}

		internal static void WriteNotSupported()
		{
			throw new NotSupportedException(SR.GetString("NotSupported_UnwritableStream"));
		}
	}
	[HostProtection(SecurityAction.LinkDemand, Synchronization = true)]
	internal abstract class BufferedStream2 : Stream
	{
		protected internal const int DefaultBufferSize = 32768;

		protected int bufferSize;

		private byte[] _buffer;

		private int _pendingBufferCopy;

		private int _writePos;

		private int _readPos;

		private int _readLen;

		protected long pos;

		protected long UnderlyingStreamPosition
		{
			get
			{
				return pos;
			}
			set
			{
				Interlocked.Exchange(ref pos, value);
			}
		}

		public override void Write(byte[] array, int offset, int count)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array", SR.GetString("ArgumentNull_Buffer"));
			}
			if (offset < 0)
			{
				throw new ArgumentOutOfRangeException("offset", SR.GetString("ArgumentOutOfRange_NeedNonNegNum"));
			}
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count", SR.GetString("ArgumentOutOfRange_NeedNonNegNum"));
			}
			if (array.Length - offset < count)
			{
				throw new ArgumentException(SR.GetString("Argument_InvalidOffLen"));
			}
			if (_writePos == 0)
			{
				if (!CanWrite)
				{
					__Error.WriteNotSupported();
				}
				if (_readPos < _readLen)
				{
					FlushRead();
				}
				_readPos = 0;
				_readLen = 0;
			}
			if (count == 0)
			{
				return;
			}
			int num2;
			while (true)
			{
				if (_writePos > bufferSize)
				{
					Thread.Sleep(1);
					continue;
				}
				if (_writePos == 0 && count >= bufferSize)
				{
					WriteCore(array, offset, count, blockForWrite: true);
					return;
				}
				Thread.BeginCriticalRegion();
				Interlocked.Increment(ref _pendingBufferCopy);
				int num = Interlocked.Add(ref _writePos, count);
				num2 = num - count;
				if (num <= bufferSize)
				{
					break;
				}
				Interlocked.Decrement(ref _pendingBufferCopy);
				Thread.EndCriticalRegion();
				if (_writePos > bufferSize && num2 <= bufferSize && num2 > 0)
				{
					while (_pendingBufferCopy != 0)
					{
						Thread.SpinWait(1);
					}
					WriteCore(_buffer, 0, num2, blockForWrite: true);
					_writePos = 0;
				}
			}
			if (_buffer == null)
			{
				Interlocked.CompareExchange(ref _buffer, new byte[bufferSize], null);
			}
			Buffer.BlockCopy(array, offset, _buffer, num2, count);
			Interlocked.Decrement(ref _pendingBufferCopy);
			Thread.EndCriticalRegion();
		}

		[MethodImpl(MethodImplOptions.Synchronized)]
		public override void Flush()
		{
			try
			{
				if (_writePos > 0)
				{
					FlushWrite(blockForWrite: false);
				}
				else if (_readPos < _readLen)
				{
					FlushRead();
				}
			}
			finally
			{
				_writePos = 0;
				_readPos = 0;
				_readLen = 0;
			}
		}

		[MethodImpl(MethodImplOptions.Synchronized)]
		protected void FlushRead()
		{
		}

		[MethodImpl(MethodImplOptions.Synchronized)]
		protected void FlushWrite(bool blockForWrite)
		{
			if (_writePos > 0)
			{
				WriteCore(_buffer, 0, _writePos, blockForWrite);
			}
			_writePos = 0;
		}

		protected override void Dispose(bool disposing)
		{
			try
			{
				if (_writePos > 0)
				{
					FlushWrite(disposing);
				}
			}
			finally
			{
				_readPos = 0;
				_readLen = 0;
				_writePos = 0;
				base.Dispose(disposing);
			}
		}

		protected long AddUnderlyingStreamPosition(long posDelta)
		{
			return Interlocked.Add(ref pos, posDelta);
		}

		[MethodImpl(MethodImplOptions.Synchronized)]
		protected internal void DiscardBuffer()
		{
			_readPos = 0;
			_readLen = 0;
			_writePos = 0;
		}

		private void WriteCore(byte[] buffer, int offset, int count, bool blockForWrite)
		{
			WriteCore(buffer, offset, count, blockForWrite, out var _);
		}

		protected abstract void WriteCore(byte[] buffer, int offset, int count, bool blockForWrite, out long streamPos);
	}
	internal class LogStream : BufferedStream2
	{
		internal const long DefaultFileSize = 10240000L;

		internal const int DefaultNumberOfFiles = 2;

		internal const LogRetentionOption DefaultRetention = LogRetentionOption.SingleFileUnboundedSize;

		private const int _retentionRetryThreshold = 2;

		private LogRetentionOption _retention;

		private long _maxFileSize = 10240000L;

		private int _maxNumberOfFiles = 2;

		private int _currentFileNum = 1;

		private bool _disableLogging;

		private int _retentionRetryCount;

		private bool _canRead;

		private bool _canWrite;

		private bool _canSeek;

		private SafeFileHandle _handle;

		private string _fileName;

		private string _fileNameWithoutExt;

		private string _fileExt;

		private string _pathSav;

		private int _fAccessSav;

		private FileShare _shareSav;

		private Microsoft.Win32.UnsafeNativeMethods.SECURITY_ATTRIBUTES _secAttrsSav;

		private FileIOPermissionAccess _secAccessSav;

		private FileMode _modeSav;

		private int _flagsAndAttributesSav;

		private bool _seekToEndSav;

		private readonly object m_lockObject = new object();

		public override bool CanRead => _canRead;

		public override bool CanWrite => _canWrite;

		public override bool CanSeek => _canSeek;

		public override long Length
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public override long Position
		{
			get
			{
				throw new NotSupportedException();
			}
			set
			{
				throw new NotSupportedException();
			}
		}

		[SecurityCritical]
		internal LogStream(string path, int bufferSize, LogRetentionOption retention, long maxFileSize, int maxNumOfFiles)
		{
			string text = (_fileName = Path.GetFullPath(path));
			if (text.StartsWith("\\\\.\\", StringComparison.Ordinal))
			{
				throw new NotSupportedException(SR.GetString("NotSupported_IONonFileDevices"));
			}
			Microsoft.Win32.UnsafeNativeMethods.SECURITY_ATTRIBUTES secAttrs = GetSecAttrs(FileShare.Read);
			int flagsAndAttributesSav = 1048576;
			_canWrite = true;
			_pathSav = text;
			_fAccessSav = 1073741824;
			_shareSav = FileShare.Read;
			_secAttrsSav = secAttrs;
			_secAccessSav = FileIOPermissionAccess.Write;
			_modeSav = ((retention != LogRetentionOption.SingleFileUnboundedSize) ? FileMode.Create : FileMode.OpenOrCreate);
			_flagsAndAttributesSav = flagsAndAttributesSav;
			_seekToEndSav = retention == LogRetentionOption.SingleFileUnboundedSize;
			base.bufferSize = bufferSize;
			_retention = retention;
			_maxFileSize = maxFileSize;
			_maxNumberOfFiles = maxNumOfFiles;
			_Init(text, _fAccessSav, _shareSav, _secAttrsSav, _secAccessSav, _modeSav, _flagsAndAttributesSav, _seekToEndSav);
		}

		[SecurityCritical]
		internal void _Init(string path, int fAccess, FileShare share, Microsoft.Win32.UnsafeNativeMethods.SECURITY_ATTRIBUTES secAttrs, FileIOPermissionAccess secAccess, FileMode mode, int flagsAndAttributes, bool seekToEnd)
		{
			string text = (_fileName = Path.GetFullPath(path));
			new FileIOPermission(secAccess, new string[1] { text }).Demand();
			int errorMode = Microsoft.Win32.UnsafeNativeMethods.SetErrorMode(1);
			try
			{
				_handle = Microsoft.Win32.UnsafeNativeMethods.SafeCreateFile(text, fAccess, share, secAttrs, mode, flagsAndAttributes, Microsoft.Win32.UnsafeNativeMethods.NULL);
				int lastWin32Error = Marshal.GetLastWin32Error();
				if (_handle.IsInvalid)
				{
					bool flag = false;
					try
					{
						new FileIOPermission(FileIOPermissionAccess.PathDiscovery, new string[1] { _fileName }).Demand();
						flag = true;
					}
					catch (SecurityException)
					{
					}
					if (flag)
					{
						__Error.WinIOError(lastWin32Error, _fileName);
					}
					else
					{
						__Error.WinIOError(lastWin32Error, Path.GetFileName(_fileName));
					}
				}
			}
			finally
			{
				Microsoft.Win32.UnsafeNativeMethods.SetErrorMode(errorMode);
			}
			pos = 0L;
			if (seekToEnd)
			{
				SeekCore(0L, SeekOrigin.End);
			}
		}

		public override void SetLength(long value)
		{
			throw new NotSupportedException();
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			throw new NotSupportedException();
		}

		public override int Read(byte[] array, int offset, int count)
		{
			throw new NotSupportedException();
		}

		[SecurityCritical]
		protected unsafe override void WriteCore(byte[] buffer, int offset, int count, bool blockForWrite, out long streamPos)
		{
			int hr = 0;
			int num = WriteFileNative(buffer, offset, count, null, out hr);
			if (num == -1)
			{
				switch (hr)
				{
				case 232:
					num = 0;
					break;
				case 87:
					throw new IOException(SR.GetString("IO_FileTooLongOrHandleNotSync"));
				default:
					__Error.WinIOError(hr, string.Empty);
					break;
				}
			}
			streamPos = AddUnderlyingStreamPosition(num);
			EnforceRetentionPolicy(_handle, streamPos);
			streamPos = pos;
		}

		[SecurityCritical]
		private unsafe int WriteFileNative(byte[] bytes, int offset, int count, NativeOverlapped* overlapped, out int hr)
		{
			if (_handle.IsClosed)
			{
				__Error.FileNotOpen();
			}
			if (_disableLogging)
			{
				hr = 0;
				return 0;
			}
			if (bytes.Length - offset < count)
			{
				throw new IndexOutOfRangeException(SR.GetString("IndexOutOfRange_IORaceCondition"));
			}
			if (bytes.Length == 0)
			{
				hr = 0;
				return 0;
			}
			int numBytesWritten = 0;
			int num = 0;
			fixed (byte* ptr = bytes)
			{
				num = Microsoft.Win32.UnsafeNativeMethods.WriteFile(_handle, ptr + offset, count, out numBytesWritten, overlapped);
			}
			if (num == 0)
			{
				hr = Marshal.GetLastWin32Error();
				if (hr == 6)
				{
					_handle.SetHandleAsInvalid();
				}
				return -1;
			}
			hr = 0;
			return numBytesWritten;
		}

		[SecurityCritical]
		private long SeekCore(long offset, SeekOrigin origin)
		{
			int hr = 0;
			long num = 0L;
			num = Microsoft.Win32.UnsafeNativeMethods.SetFilePointer(_handle, offset, origin, out hr);
			if (num == -1)
			{
				if (hr == 6)
				{
					_handle.SetHandleAsInvalid();
				}
				__Error.WinIOError(hr, string.Empty);
			}
			base.UnderlyingStreamPosition = num;
			return num;
		}

		[SecurityCritical]
		protected override void Dispose(bool disposing)
		{
			try
			{
				if (_handle == null || _handle.IsClosed)
				{
					DiscardBuffer();
				}
			}
			finally
			{
				try
				{
					base.Dispose(disposing);
				}
				finally
				{
					if (_handle != null && !_handle.IsClosed)
					{
						_handle.Dispose();
					}
					_handle = null;
					_canRead = false;
					_canWrite = false;
					_canSeek = false;
				}
			}
		}

		[SecurityCritical]
		~LogStream()
		{
			if (_handle != null)
			{
				Dispose(disposing: false);
			}
		}

		[SecurityCritical]
		private void EnforceRetentionPolicy(SafeFileHandle handle, long lastPos)
		{
			switch (_retention)
			{
			case LogRetentionOption.UnlimitedSequentialFiles:
			case LogRetentionOption.LimitedCircularFiles:
			case LogRetentionOption.LimitedSequentialFiles:
				if (lastPos < _maxFileSize || handle != _handle)
				{
					break;
				}
				lock (m_lockObject)
				{
					if (handle != _handle || lastPos < _maxFileSize)
					{
						break;
					}
					_currentFileNum++;
					if (_retention == LogRetentionOption.LimitedCircularFiles && _currentFileNum > _maxNumberOfFiles)
					{
						_currentFileNum = 1;
					}
					else if (_retention == LogRetentionOption.LimitedSequentialFiles && _currentFileNum > _maxNumberOfFiles)
					{
						_DisableLogging();
						break;
					}
					if (_fileNameWithoutExt == null)
					{
						_fileNameWithoutExt = Path.GetFileNameWithoutExtension(_pathSav);
						_fileExt = Path.GetExtension(_pathSav);
					}
					string path = ((_currentFileNum == 1) ? _pathSav : (_fileNameWithoutExt + _currentFileNum.ToString(CultureInfo.InvariantCulture) + _fileExt));
					try
					{
						_Init(path, _fAccessSav, _shareSav, _secAttrsSav, _secAccessSav, _modeSav, _flagsAndAttributesSav, _seekToEndSav);
						if (handle != null && !handle.IsClosed)
						{
							handle.Dispose();
						}
						break;
					}
					catch (IOException)
					{
						_handle = handle;
						_retentionRetryCount++;
						if (_retentionRetryCount >= 2)
						{
							_DisableLogging();
						}
						break;
					}
					catch (UnauthorizedAccessException)
					{
						_DisableLogging();
						break;
					}
					catch (Exception)
					{
						_DisableLogging();
						break;
					}
				}
			case LogRetentionOption.SingleFileBoundedSize:
				if (lastPos >= _maxFileSize)
				{
					_DisableLogging();
				}
				break;
			case LogRetentionOption.SingleFileUnboundedSize:
				break;
			}
		}

		[MethodImpl(MethodImplOptions.Synchronized)]
		private void _DisableLogging()
		{
			_disableLogging = true;
		}

		[SecurityCritical]
		private static Microsoft.Win32.UnsafeNativeMethods.SECURITY_ATTRIBUTES GetSecAttrs(FileShare share)
		{
			Microsoft.Win32.UnsafeNativeMethods.SECURITY_ATTRIBUTES sECURITY_ATTRIBUTES = null;
			if ((share & FileShare.Inheritable) != 0)
			{
				sECURITY_ATTRIBUTES = new Microsoft.Win32.UnsafeNativeMethods.SECURITY_ATTRIBUTES();
				sECURITY_ATTRIBUTES.nLength = Marshal.SizeOf(sECURITY_ATTRIBUTES);
				sECURITY_ATTRIBUTES.bInheritHandle = 1;
			}
			return sECURITY_ATTRIBUTES;
		}
	}
	internal enum LogRetentionOption
	{
		SingleFileUnboundedSize = 2,
		SingleFileBoundedSize = 4,
		UnlimitedSequentialFiles = 0,
		LimitedSequentialFiles = 3,
		LimitedCircularFiles = 1
	}
}
namespace System.Diagnostics
{
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	[HostProtection(SecurityAction.LinkDemand, Synchronization = true)]
	public class EventSchemaTraceListener : TextWriterTraceListener
	{
		private sealed class TraceWriter : TextWriter
		{
			private Encoding encNoBOMwithFallback;

			private Stream stream;

			private object m_lockObject = new object();

			public override Encoding Encoding
			{
				get
				{
					if (encNoBOMwithFallback == null)
					{
						lock (m_lockObject)
						{
							if (encNoBOMwithFallback == null)
							{
								encNoBOMwithFallback = GetEncodingWithFallback(new UTF8Encoding(encoderShouldEmitUTF8Identifier: false));
							}
						}
					}
					return encNoBOMwithFallback;
				}
			}

			[SecurityCritical]
			internal TraceWriter(string _fileName, int bufferSize, TraceLogRetentionOption retention, long maxFileSize, int maxNumberOfFiles)
				: base(CultureInfo.InvariantCulture)
			{
				stream = new LogStream(_fileName, bufferSize, (LogRetentionOption)retention, maxFileSize, maxNumberOfFiles);
			}

			private static Encoding GetEncodingWithFallback(Encoding encoding)
			{
				Encoding encoding2 = (Encoding)encoding.Clone();
				encoding2.EncoderFallback = EncoderFallback.ReplacementFallback;
				encoding2.DecoderFallback = DecoderFallback.ReplacementFallback;
				return encoding2;
			}

			public override void Write(string value)
			{
				try
				{
					byte[] bytes = Encoding.GetBytes(value);
					stream.Write(bytes, 0, bytes.Length);
				}
				catch (Exception)
				{
					if (stream is BufferedStream2)
					{
						((BufferedStream2)stream).DiscardBuffer();
					}
				}
			}

			public override void Flush()
			{
				stream.Flush();
			}

			protected override void Dispose(bool disposing)
			{
				try
				{
					if (disposing)
					{
						stream.Close();
					}
				}
				finally
				{
					base.Dispose(disposing);
				}
			}
		}

		private const string s_optionBufferSize = "bufferSize";

		private const string s_optionLogRetention = "logRetentionOption";

		private const string s_optionMaximumFileSize = "maximumFileSize";

		private const string s_optionMaximumNumberOfFiles = "maximumNumberOfFiles";

		private const string s_userDataHeader = "<System.Diagnostics.UserData xmlns=\"http://schemas.microsoft.com/win/2006/09/System.Diagnostics/UserData/\">";

		private const string s_eventHeader = "<Event xmlns=\"http://schemas.microsoft.com/win/2004/08/events/event\"><System><Provider Guid=\"";

		private const int s_defaultPayloadSize = 512;

		private const int _retryThreshold = 2;

		private static readonly string machineName = Environment.MachineName;

		private TraceWriter traceWriter;

		private string fileName;

		private bool _initialized;

		private int _bufferSize = 32768;

		private TraceLogRetentionOption _retention = TraceLogRetentionOption.SingleFileUnboundedSize;

		private long _maxFileSize = 10240000L;

		private int _maxNumberOfFiles = 2;

		private readonly object m_lockObject = new object();

		public new TextWriter Writer
		{
			[SecurityCritical]
			get
			{
				EnsureWriter();
				return traceWriter;
			}
			set
			{
				throw new NotSupportedException(SR.GetString("NotSupported_SetTextWriter"));
			}
		}

		public override bool IsThreadSafe => true;

		public int BufferSize
		{
			get
			{
				Init();
				return _bufferSize;
			}
		}

		public TraceLogRetentionOption TraceLogRetentionOption
		{
			get
			{
				Init();
				return _retention;
			}
		}

		public long MaximumFileSize
		{
			get
			{
				Init();
				return _maxFileSize;
			}
		}

		public int MaximumNumberOfFiles
		{
			get
			{
				Init();
				return _maxNumberOfFiles;
			}
		}

		public EventSchemaTraceListener(string fileName)
			: this(fileName, string.Empty)
		{
		}

		public EventSchemaTraceListener(string fileName, string name)
			: this(fileName, name, 32768)
		{
		}

		public EventSchemaTraceListener(string fileName, string name, int bufferSize)
			: this(fileName, name, bufferSize, TraceLogRetentionOption.SingleFileUnboundedSize)
		{
		}

		public EventSchemaTraceListener(string fileName, string name, int bufferSize, TraceLogRetentionOption logRetentionOption)
			: this(fileName, name, bufferSize, logRetentionOption, 10240000L)
		{
		}

		public EventSchemaTraceListener(string fileName, string name, int bufferSize, TraceLogRetentionOption logRetentionOption, long maximumFileSize)
			: this(fileName, name, bufferSize, logRetentionOption, maximumFileSize, 2)
		{
		}

		public EventSchemaTraceListener(string fileName, string name, int bufferSize, TraceLogRetentionOption logRetentionOption, long maximumFileSize, int maximumNumberOfFiles)
		{
			if (bufferSize < 0)
			{
				throw new ArgumentOutOfRangeException("bufferSize", SR.GetString("ArgumentOutOfRange_NeedNonNegNum"));
			}
			if (logRetentionOption < TraceLogRetentionOption.UnlimitedSequentialFiles || logRetentionOption > TraceLogRetentionOption.SingleFileBoundedSize)
			{
				throw new ArgumentOutOfRangeException("logRetentionOption", SR.GetString("ArgumentOutOfRange_NeedValidLogRetention"));
			}
			base.Name = name;
			this.fileName = fileName;
			if (!string.IsNullOrEmpty(this.fileName) && fileName[0] != Path.DirectorySeparatorChar && fileName[0] != Path.AltDirectorySeparatorChar && !Path.IsPathRooted(fileName))
			{
				this.fileName = Path.Combine(Path.GetDirectoryName(AppDomain.CurrentDomain.SetupInformation.ConfigurationFile), this.fileName);
			}
			_retention = logRetentionOption;
			_bufferSize = bufferSize;
			_SetMaxFileSize(maximumFileSize, throwOnError: false);
			_SetMaxNumberOfFiles(maximumNumberOfFiles, throwOnError: false);
		}

		public override void Close()
		{
			try
			{
				if (traceWriter != null)
				{
					traceWriter.Flush();
					traceWriter.Close();
				}
			}
			finally
			{
				traceWriter = null;
				base.Close();
			}
		}

		[SecurityCritical]
		public override void Flush()
		{
			if (EnsureWriter())
			{
				traceWriter.Flush();
			}
		}

		public override void Write(string message)
		{
			WriteLine(message);
		}

		public override void WriteLine(string message)
		{
			TraceEvent(null, SR.GetString("TraceAsTraceSource"), TraceEventType.Information, 0, message);
		}

		public override void Fail(string message, string detailMessage)
		{
			StringBuilder stringBuilder = new StringBuilder(message);
			if (detailMessage != null)
			{
				stringBuilder.Append(" ");
				stringBuilder.Append(detailMessage);
			}
			TraceEvent(null, SR.GetString("TraceAsTraceSource"), TraceEventType.Error, 0, stringBuilder.ToString());
		}

		[SecurityCritical]
		public override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, params object[] args)
		{
			if (base.Filter == null || base.Filter.ShouldTrace(eventCache, source, eventType, id, format, args, null, null))
			{
				StringBuilder stringBuilder = new StringBuilder(512);
				BuildHeader(stringBuilder, source, eventType, id, eventCache, null, isUserData: false, base.TraceOutputOptions);
				string message = ((args == null) ? format : string.Format(CultureInfo.InvariantCulture, format, args));
				BuildMessage(stringBuilder, message);
				BuildFooter(stringBuilder, eventType, eventCache, isUserData: false, base.TraceOutputOptions);
				_InternalWriteRaw(stringBuilder);
			}
		}

		[SecurityCritical]
		public override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message)
		{
			if (base.Filter == null || base.Filter.ShouldTrace(eventCache, source, eventType, id, message, null, null, null))
			{
				StringBuilder stringBuilder = new StringBuilder(512);
				BuildHeader(stringBuilder, source, eventType, id, eventCache, null, isUserData: false, base.TraceOutputOptions);
				BuildMessage(stringBuilder, message);
				BuildFooter(stringBuilder, eventType, eventCache, isUserData: false, base.TraceOutputOptions);
				_InternalWriteRaw(stringBuilder);
			}
		}

		[SecurityCritical]
		public override void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, object data)
		{
			if (base.Filter == null || base.Filter.ShouldTrace(eventCache, source, eventType, id, null, null, data, null))
			{
				StringBuilder stringBuilder = new StringBuilder(512);
				BuildHeader(stringBuilder, source, eventType, id, eventCache, null, isUserData: true, base.TraceOutputOptions);
				if (data != null)
				{
					_InternalBuildRaw(stringBuilder, "<System.Diagnostics.UserData xmlns=\"http://schemas.microsoft.com/win/2006/09/System.Diagnostics/UserData/\">");
					BuildUserData(stringBuilder, data);
					_InternalBuildRaw(stringBuilder, "</System.Diagnostics.UserData>");
				}
				BuildFooter(stringBuilder, eventType, eventCache, isUserData: true, base.TraceOutputOptions);
				_InternalWriteRaw(stringBuilder);
			}
		}

		[SecurityCritical]
		public override void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, params object[] data)
		{
			if (base.Filter != null && !base.Filter.ShouldTrace(eventCache, source, eventType, id, null, null, null, data))
			{
				return;
			}
			StringBuilder stringBuilder = new StringBuilder(512);
			BuildHeader(stringBuilder, source, eventType, id, eventCache, null, isUserData: true, base.TraceOutputOptions);
			if (data != null && data.Length > 0)
			{
				_InternalBuildRaw(stringBuilder, "<System.Diagnostics.UserData xmlns=\"http://schemas.microsoft.com/win/2006/09/System.Diagnostics/UserData/\">");
				for (int i = 0; i < data.Length; i++)
				{
					if (data[i] != null)
					{
						BuildUserData(stringBuilder, data[i]);
					}
				}
				_InternalBuildRaw(stringBuilder, "</System.Diagnostics.UserData>");
			}
			BuildFooter(stringBuilder, eventType, eventCache, isUserData: true, base.TraceOutputOptions);
			_InternalWriteRaw(stringBuilder);
		}

		[SecurityCritical]
		public override void TraceTransfer(TraceEventCache eventCache, string source, int id, string message, Guid relatedActivityId)
		{
			StringBuilder stringBuilder = new StringBuilder(512);
			BuildHeader(stringBuilder, source, TraceEventType.Transfer, id, eventCache, relatedActivityId.ToString("B"), isUserData: false, base.TraceOutputOptions);
			BuildMessage(stringBuilder, message);
			BuildFooter(stringBuilder, TraceEventType.Transfer, eventCache, isUserData: false, base.TraceOutputOptions);
			_InternalWriteRaw(stringBuilder);
		}

		private static void BuildMessage(StringBuilder writer, string message)
		{
			_InternalBuildRaw(writer, "<Data>");
			BuildEscaped(writer, message);
			_InternalBuildRaw(writer, "</Data>");
		}

		[SecurityCritical]
		private static void BuildHeader(StringBuilder writer, string source, TraceEventType eventType, int id, TraceEventCache eventCache, string relatedActivityId, bool isUserData, TraceOptions opts)
		{
			_InternalBuildRaw(writer, "<Event xmlns=\"http://schemas.microsoft.com/win/2004/08/events/event\"><System><Provider Guid=\"");
			_InternalBuildRaw(writer, "{00000000-0000-0000-0000-000000000000}");
			_InternalBuildRaw(writer, "\"/><EventID>");
			_InternalBuildRaw(writer, ((id >= 0) ? ((uint)id) : 0u).ToString(CultureInfo.InvariantCulture));
			_InternalBuildRaw(writer, "</EventID>");
			_InternalBuildRaw(writer, "<Level>");
			int num = (int)eventType;
			int num2 = num;
			if (num > 255 || num < 0)
			{
				num = 8;
			}
			_InternalBuildRaw(writer, num.ToString(CultureInfo.InvariantCulture));
			_InternalBuildRaw(writer, "</Level>");
			if (num2 > 255)
			{
				num2 /= 256;
				_InternalBuildRaw(writer, "<Opcode>");
				_InternalBuildRaw(writer, num2.ToString(CultureInfo.InvariantCulture));
				_InternalBuildRaw(writer, "</Opcode>");
			}
			if ((TraceOptions.DateTime & opts) != 0)
			{
				_InternalBuildRaw(writer, "<TimeCreated SystemTime=\"");
				if (eventCache != null)
				{
					_InternalBuildRaw(writer, eventCache.DateTime.ToString("o", CultureInfo.InvariantCulture));
				}
				else
				{
					_InternalBuildRaw(writer, DateTime.UtcNow.ToString("o", CultureInfo.InvariantCulture));
				}
				_InternalBuildRaw(writer, "\"/>");
			}
			_InternalBuildRaw(writer, "<Correlation ActivityID=\"");
			_InternalBuildRaw(writer, Trace.CorrelationManager.ActivityId.ToString("B"));
			if (relatedActivityId != null)
			{
				_InternalBuildRaw(writer, "\" RelatedActivityID=\"");
				_InternalBuildRaw(writer, relatedActivityId);
			}
			_InternalBuildRaw(writer, "\"/>");
			if (eventCache != null && ((TraceOptions.ProcessId | TraceOptions.ThreadId) & opts) != 0)
			{
				_InternalBuildRaw(writer, "<Execution ");
				_InternalBuildRaw(writer, "ProcessID=\"");
				_InternalBuildRaw(writer, ((uint)eventCache.ProcessId).ToString(CultureInfo.InvariantCulture));
				_InternalBuildRaw(writer, "\" ");
				_InternalBuildRaw(writer, "ThreadID=\"");
				_InternalBuildRaw(writer, eventCache.ThreadId);
				_InternalBuildRaw(writer, "\"");
				_InternalBuildRaw(writer, "/>");
			}
			_InternalBuildRaw(writer, "<Computer>");
			_InternalBuildRaw(writer, machineName);
			_InternalBuildRaw(writer, "</Computer>");
			_InternalBuildRaw(writer, "</System>");
			if (!isUserData)
			{
				_InternalBuildRaw(writer, "<EventData>");
			}
			else
			{
				_InternalBuildRaw(writer, "<UserData>");
			}
		}

		private static void BuildFooter(StringBuilder writer, TraceEventType eventType, TraceEventCache eventCache, bool isUserData, TraceOptions opts)
		{
			if (!isUserData)
			{
				_InternalBuildRaw(writer, "</EventData>");
			}
			else
			{
				_InternalBuildRaw(writer, "</UserData>");
			}
			_InternalBuildRaw(writer, "<RenderingInfo Culture=\"en-EN\">");
			switch (eventType)
			{
			case TraceEventType.Critical:
				_InternalBuildRaw(writer, "<Level>Critical</Level>");
				break;
			case TraceEventType.Error:
				_InternalBuildRaw(writer, "<Level>Error</Level>");
				break;
			case TraceEventType.Warning:
				_InternalBuildRaw(writer, "<Level>Warning</Level>");
				break;
			case TraceEventType.Information:
				_InternalBuildRaw(writer, "<Level>Information</Level>");
				break;
			case TraceEventType.Verbose:
				_InternalBuildRaw(writer, "<Level>Verbose</Level>");
				break;
			case TraceEventType.Start:
				_InternalBuildRaw(writer, "<Level>Information</Level><Opcode>Start</Opcode>");
				break;
			case TraceEventType.Stop:
				_InternalBuildRaw(writer, "<Level>Information</Level><Opcode>Stop</Opcode>");
				break;
			case TraceEventType.Suspend:
				_InternalBuildRaw(writer, "<Level>Information</Level><Opcode>Suspend</Opcode>");
				break;
			case TraceEventType.Resume:
				_InternalBuildRaw(writer, "<Level>Information</Level><Opcode>Resume</Opcode>");
				break;
			case TraceEventType.Transfer:
				_InternalBuildRaw(writer, "<Level>Information</Level><Opcode>Transfer</Opcode>");
				break;
			}
			_InternalBuildRaw(writer, "</RenderingInfo>");
			if (eventCache != null && ((TraceOptions.LogicalOperationStack | TraceOptions.Timestamp | TraceOptions.Callstack) & opts) != 0)
			{
				_InternalBuildRaw(writer, "<System.Diagnostics.ExtendedData xmlns=\"http://schemas.microsoft.com/2006/09/System.Diagnostics/ExtendedData\">");
				if ((TraceOptions.Timestamp & opts) != 0)
				{
					_InternalBuildRaw(writer, "<Timestamp>");
					_InternalBuildRaw(writer, eventCache.Timestamp.ToString(CultureInfo.InvariantCulture));
					_InternalBuildRaw(writer, "</Timestamp>");
				}
				if ((TraceOptions.LogicalOperationStack & opts) != 0)
				{
					Stack logicalOperationStack = eventCache.LogicalOperationStack;
					_InternalBuildRaw(writer, "<LogicalOperationStack>");
					if (logicalOperationStack != null && logicalOperationStack.Count > 0)
					{
						foreach (object item in logicalOperationStack)
						{
							_InternalBuildRaw(writer, "<LogicalOperation>");
							BuildEscaped(writer, item.ToString());
							_InternalBuildRaw(writer, "</LogicalOperation>");
						}
					}
					_InternalBuildRaw(writer, "</LogicalOperationStack>");
				}
				if ((TraceOptions.Callstack & opts) != 0)
				{
					_InternalBuildRaw(writer, "<Callstack>");
					BuildEscaped(writer, eventCache.Callstack);
					_InternalBuildRaw(writer, "</Callstack>");
				}
				_InternalBuildRaw(writer, "</System.Diagnostics.ExtendedData>");
			}
			_InternalBuildRaw(writer, "</Event>");
		}

		private static void BuildEscaped(StringBuilder writer, string str)
		{
			if (str == null)
			{
				return;
			}
			int num = 0;
			for (int i = 0; i < str.Length; i++)
			{
				switch (str[i])
				{
				case '&':
					_InternalBuildRaw(writer, str.Substring(num, i - num));
					_InternalBuildRaw(writer, "&amp;");
					num = i + 1;
					break;
				case '<':
					_InternalBuildRaw(writer, str.Substring(num, i - num));
					_InternalBuildRaw(writer, "&lt;");
					num = i + 1;
					break;
				case '>':
					_InternalBuildRaw(writer, str.Substring(num, i - num));
					_InternalBuildRaw(writer, "&gt;");
					num = i + 1;
					break;
				case '"':
					_InternalBuildRaw(writer, str.Substring(num, i - num));
					_InternalBuildRaw(writer, "&quot;");
					num = i + 1;
					break;
				case '\'':
					_InternalBuildRaw(writer, str.Substring(num, i - num));
					_InternalBuildRaw(writer, "&apos;");
					num = i + 1;
					break;
				case '\r':
					_InternalBuildRaw(writer, str.Substring(num, i - num));
					_InternalBuildRaw(writer, "&#xD;");
					num = i + 1;
					break;
				case '\n':
					_InternalBuildRaw(writer, str.Substring(num, i - num));
					_InternalBuildRaw(writer, "&#xA;");
					num = i + 1;
					break;
				}
			}
			_InternalBuildRaw(writer, str.Substring(num, str.Length - num));
		}

		private static void BuildUserData(StringBuilder writer, object data)
		{
			if (!(data is UnescapedXmlDiagnosticData unescapedXmlDiagnosticData))
			{
				BuildMessage(writer, data.ToString());
			}
			else
			{
				_InternalBuildRaw(writer, unescapedXmlDiagnosticData.ToString());
			}
		}

		private static void _InternalBuildRaw(StringBuilder writer, string message)
		{
			writer.Append(message);
		}

		[SecurityCritical]
		private void _InternalWriteRaw(StringBuilder writer)
		{
			if (EnsureWriter())
			{
				traceWriter.Write(writer.ToString());
			}
		}

		protected override string[] GetSupportedAttributes()
		{
			return new string[4] { "bufferSize", "logRetentionOption", "maximumFileSize", "maximumNumberOfFiles" };
		}

		private void Init()
		{
			if (_initialized)
			{
				return;
			}
			lock (m_lockObject)
			{
				if (_initialized)
				{
					return;
				}
				try
				{
					if (base.Attributes.ContainsKey("bufferSize"))
					{
						int num = int.Parse(base.Attributes["bufferSize"], CultureInfo.InvariantCulture);
						if (num > 0)
						{
							_bufferSize = num;
						}
					}
					if (base.Attributes.ContainsKey("logRetentionOption"))
					{
						string strA = base.Attributes["logRetentionOption"];
						if (string.Compare(strA, "SingleFileUnboundedSize", StringComparison.OrdinalIgnoreCase) == 0)
						{
							_retention = TraceLogRetentionOption.SingleFileUnboundedSize;
						}
						else if (string.Compare(strA, "LimitedCircularFiles", StringComparison.OrdinalIgnoreCase) == 0)
						{
							_retention = TraceLogRetentionOption.LimitedCircularFiles;
						}
						else if (string.Compare(strA, "UnlimitedSequentialFiles", StringComparison.OrdinalIgnoreCase) == 0)
						{
							_retention = TraceLogRetentionOption.UnlimitedSequentialFiles;
						}
						else if (string.Compare(strA, "SingleFileBoundedSize", StringComparison.OrdinalIgnoreCase) == 0)
						{
							_retention = TraceLogRetentionOption.SingleFileBoundedSize;
						}
						else if (string.Compare(strA, "LimitedSequentialFiles", StringComparison.OrdinalIgnoreCase) == 0)
						{
							_retention = TraceLogRetentionOption.LimitedSequentialFiles;
						}
						else
						{
							_retention = TraceLogRetentionOption.SingleFileUnboundedSize;
						}
					}
					if (base.Attributes.ContainsKey("maximumFileSize"))
					{
						long maximumFileSize = long.Parse(base.Attributes["maximumFileSize"], CultureInfo.InvariantCulture);
						_SetMaxFileSize(maximumFileSize, throwOnError: false);
					}
					if (base.Attributes.ContainsKey("maximumNumberOfFiles"))
					{
						int maximumNumberOfFiles = int.Parse(base.Attributes["maximumNumberOfFiles"], CultureInfo.InvariantCulture);
						_SetMaxNumberOfFiles(maximumNumberOfFiles, throwOnError: false);
					}
				}
				catch (Exception)
				{
				}
				finally
				{
					_initialized = true;
				}
			}
		}

		private void _SetMaxFileSize(long maximumFileSize, bool throwOnError)
		{
			switch (_retention)
			{
			case TraceLogRetentionOption.SingleFileUnboundedSize:
				_maxFileSize = -1L;
				break;
			case TraceLogRetentionOption.UnlimitedSequentialFiles:
			case TraceLogRetentionOption.LimitedCircularFiles:
			case TraceLogRetentionOption.LimitedSequentialFiles:
			case TraceLogRetentionOption.SingleFileBoundedSize:
				if (maximumFileSize < 0 && throwOnError)
				{
					throw new ArgumentOutOfRangeException("maximumFileSize", SR.GetString("ArgumentOutOfRange_NeedNonNegNum"));
				}
				if (maximumFileSize < _bufferSize)
				{
					if (throwOnError)
					{
						throw new ArgumentOutOfRangeException("maximumFileSize", SR.GetString("ArgumentOutOfRange_NeedMaxFileSizeGEBufferSize"));
					}
					_maxFileSize = _bufferSize;
				}
				else
				{
					_maxFileSize = maximumFileSize;
				}
				break;
			}
		}

		private void _SetMaxNumberOfFiles(int maximumNumberOfFiles, bool throwOnError)
		{
			switch (_retention)
			{
			case TraceLogRetentionOption.SingleFileUnboundedSize:
			case TraceLogRetentionOption.SingleFileBoundedSize:
				_maxNumberOfFiles = 1;
				break;
			case TraceLogRetentionOption.UnlimitedSequentialFiles:
				_maxNumberOfFiles = -1;
				break;
			case TraceLogRetentionOption.LimitedSequentialFiles:
				if (maximumNumberOfFiles < 1)
				{
					if (throwOnError)
					{
						throw new ArgumentOutOfRangeException("maximumNumberOfFiles", SR.GetString("ArgumentOutOfRange_NeedValidMaxNumFiles", 1));
					}
					_maxNumberOfFiles = 1;
				}
				else
				{
					_maxNumberOfFiles = maximumNumberOfFiles;
				}
				break;
			case TraceLogRetentionOption.LimitedCircularFiles:
				if (maximumNumberOfFiles < 2)
				{
					if (throwOnError)
					{
						throw new ArgumentOutOfRangeException("maximumNumberOfFiles", SR.GetString("ArgumentOutOfRange_NeedValidMaxNumFiles", 2));
					}
					_maxNumberOfFiles = 2;
				}
				else
				{
					_maxNumberOfFiles = maximumNumberOfFiles;
				}
				break;
			}
		}

		[SecurityCritical]
		private bool EnsureWriter()
		{
			if (traceWriter == null)
			{
				if (string.IsNullOrEmpty(fileName))
				{
					return false;
				}
				lock (m_lockObject)
				{
					if (traceWriter != null)
					{
						return true;
					}
					string text = fileName;
					for (int i = 0; i < 2; i++)
					{
						try
						{
							Init();
							traceWriter = new TraceWriter(text, _bufferSize, _retention, _maxFileSize, _maxNumberOfFiles);
						}
						catch (IOException)
						{
							string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(fileName);
							string extension = Path.GetExtension(fileName);
							text = fileNameWithoutExtension + Guid.NewGuid().ToString() + extension;
							continue;
						}
						catch (UnauthorizedAccessException)
						{
						}
						catch (Exception)
						{
						}
						break;
					}
					if (traceWriter == null)
					{
						fileName = null;
					}
				}
			}
			return traceWriter != null;
		}
	}
	public enum TraceLogRetentionOption
	{
		SingleFileUnboundedSize = 2,
		SingleFileBoundedSize = 4,
		UnlimitedSequentialFiles = 0,
		LimitedSequentialFiles = 3,
		LimitedCircularFiles = 1
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class UnescapedXmlDiagnosticData
	{
		private string _xmlString;

		public string UnescapedXml
		{
			get
			{
				return _xmlString;
			}
			set
			{
				_xmlString = value;
			}
		}

		public UnescapedXmlDiagnosticData(string xmlPayload)
		{
			_xmlString = xmlPayload;
			if (_xmlString == null)
			{
				_xmlString = string.Empty;
			}
		}

		public override string ToString()
		{
			return _xmlString;
		}
	}
}
namespace System.Diagnostics.PerformanceData
{
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class CounterData
	{
		private unsafe long* m_offset;

		public unsafe long Value
		{
			[SecurityCritical]
			get
			{
				return *m_offset;
			}
			[SecurityCritical]
			set
			{
				*m_offset = value;
			}
		}

		[SecurityCritical]
		internal unsafe CounterData(long* pCounterData)
		{
			m_offset = pCounterData;
			*m_offset = 0L;
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class CounterSetInstanceCounterDataSet : IDisposable
	{
		internal CounterSetInstance m_instance;

		private Dictionary<int, CounterData> m_counters;

		private int m_disposed;

		internal unsafe byte* m_dataBlock;

		public CounterData this[int counterId]
		{
			get
			{
				if (m_disposed != 0)
				{
					return null;
				}
				try
				{
					return m_counters[counterId];
				}
				catch (KeyNotFoundException)
				{
					return null;
				}
				catch
				{
					throw;
				}
			}
		}

		public CounterData this[string counterName]
		{
			get
			{
				if (counterName == null)
				{
					throw new ArgumentNullException("CounterName");
				}
				if (counterName.Length == 0)
				{
					throw new ArgumentNullException("CounterName");
				}
				if (m_disposed != 0)
				{
					return null;
				}
				try
				{
					int key = m_instance.m_counterSet.m_stringToId[counterName];
					try
					{
						return m_counters[key];
					}
					catch (KeyNotFoundException)
					{
						return null;
					}
					catch
					{
						throw;
					}
				}
				catch (KeyNotFoundException)
				{
					return null;
				}
				catch
				{
					throw;
				}
			}
		}

		[SecurityCritical]
		internal unsafe CounterSetInstanceCounterDataSet(CounterSetInstance thisInst)
		{
			m_instance = thisInst;
			m_counters = new Dictionary<int, CounterData>();
			if (m_instance.m_counterSet.m_provider == null)
			{
				throw new ArgumentException(SR.GetString("Perflib_Argument_ProviderNotFound", m_instance.m_counterSet.m_providerGuid), "ProviderGuid");
			}
			if (m_instance.m_counterSet.m_provider.m_hProvider.IsInvalid)
			{
				throw new InvalidOperationException(SR.GetString("Perflib_InvalidOperation_NoActiveProvider", m_instance.m_counterSet.m_providerGuid));
			}
			m_dataBlock = (byte*)(void*)Marshal.AllocHGlobal(m_instance.m_counterSet.m_idToCounter.Count * 8);
			if (m_dataBlock == null)
			{
				throw new InsufficientMemoryException(SR.GetString("Perflib_InsufficientMemory_InstanceCounterBlock", m_instance.m_counterSet.m_counterSet, m_instance.m_instName));
			}
			int num = 0;
			foreach (KeyValuePair<int, CounterType> item in m_instance.m_counterSet.m_idToCounter)
			{
				CounterData value = new CounterData((long*)(m_dataBlock + (long)num * 8L));
				m_counters.Add(item.Key, value);
				uint num2 = Microsoft.Win32.UnsafeNativeMethods.PerfSetCounterRefValue(m_instance.m_counterSet.m_provider.m_hProvider, m_instance.m_nativeInst, (uint)item.Key, m_dataBlock + (long)num * 8L);
				if (num2 != 0)
				{
					Dispose(disposing: true);
					uint num3 = num2;
					if (num3 == 1168)
					{
						throw new InvalidOperationException(SR.GetString("Perflib_InvalidOperation_CounterRefValue", m_instance.m_counterSet.m_counterSet, item.Key, m_instance.m_instName));
					}
					throw new Win32Exception((int)num2);
				}
				num++;
			}
		}

		[SecurityCritical]
		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		[SecurityCritical]
		~CounterSetInstanceCounterDataSet()
		{
			Dispose(disposing: false);
		}

		[SecurityCritical]
		private unsafe void Dispose(bool disposing)
		{
			if (Interlocked.Exchange(ref m_disposed, 1) == 0 && m_dataBlock != null)
			{
				Marshal.FreeHGlobal((IntPtr)m_dataBlock);
				m_dataBlock = null;
			}
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class CounterSet : IDisposable
	{
		private static readonly bool s_platformNotSupported = Environment.OSVersion.Version.Major < 6;

		internal PerfProvider m_provider;

		internal Guid m_providerGuid;

		internal Guid m_counterSet;

		internal CounterSetInstanceType m_instType;

		private readonly object m_lockObject;

		private bool m_instanceCreated;

		internal Dictionary<string, int> m_stringToId;

		internal Dictionary<int, CounterType> m_idToCounter;

		[SecurityCritical]
		[PermissionSet(SecurityAction.Demand, Unrestricted = true)]
		public CounterSet(Guid providerGuid, Guid counterSetGuid, CounterSetInstanceType instanceType)
		{
			if (s_platformNotSupported)
			{
				throw new PlatformNotSupportedException(SR.GetString("Perflib_PlatformNotSupported"));
			}
			if (!PerfProviderCollection.ValidateCounterSetInstanceType(instanceType))
			{
				throw new ArgumentException(SR.GetString("Perflib_Argument_InvalidCounterSetInstanceType", instanceType), "instanceType");
			}
			m_providerGuid = providerGuid;
			m_counterSet = counterSetGuid;
			m_instType = instanceType;
			PerfProviderCollection.RegisterCounterSet(m_counterSet);
			m_provider = PerfProviderCollection.QueryProvider(m_providerGuid);
			m_lockObject = new object();
			m_stringToId = new Dictionary<string, int>();
			m_idToCounter = new Dictionary<int, CounterType>();
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		~CounterSet()
		{
			Dispose(disposing: false);
		}

		[SecurityTreatAsSafe]
		[SecurityCritical]
		protected virtual void Dispose(bool disposing)
		{
			if (!disposing)
			{
				return;
			}
			PerfProviderCollection.UnregisterCounterSet(m_counterSet);
			if (!m_instanceCreated || m_provider == null)
			{
				return;
			}
			lock (m_lockObject)
			{
				if (m_provider != null)
				{
					Interlocked.Decrement(ref m_provider.m_counterSet);
					if (m_provider.m_counterSet <= 0)
					{
						PerfProviderCollection.RemoveProvider(m_providerGuid);
					}
					m_provider = null;
				}
			}
		}

		public void AddCounter(int counterId, CounterType counterType)
		{
			if (m_provider == null)
			{
				throw new InvalidOperationException(SR.GetString("Perflib_InvalidOperation_NoActiveProvider", m_providerGuid));
			}
			if (!PerfProviderCollection.ValidateCounterType(counterType))
			{
				throw new ArgumentException(SR.GetString("Perflib_Argument_InvalidCounterType", counterType), "counterType");
			}
			if (m_instanceCreated)
			{
				throw new InvalidOperationException(SR.GetString("Perflib_InvalidOperation_AddCounterAfterInstance", m_counterSet));
			}
			lock (m_lockObject)
			{
				if (m_instanceCreated)
				{
					throw new InvalidOperationException(SR.GetString("Perflib_InvalidOperation_AddCounterAfterInstance", m_counterSet));
				}
				if (m_idToCounter.ContainsKey(counterId))
				{
					throw new ArgumentException(SR.GetString("Perflib_Argument_CounterAlreadyExists", counterId, m_counterSet), "CounterId");
				}
				m_idToCounter.Add(counterId, counterType);
			}
		}

		public void AddCounter(int counterId, CounterType counterType, string counterName)
		{
			if (counterName == null)
			{
				throw new ArgumentNullException("CounterName");
			}
			if (counterName.Length == 0)
			{
				throw new ArgumentException(SR.GetString("Perflib_Argument_EmptyCounterName"), "counterName");
			}
			if (!PerfProviderCollection.ValidateCounterType(counterType))
			{
				throw new ArgumentException(SR.GetString("Perflib_Argument_InvalidCounterType", counterType), "counterType");
			}
			if (m_provider == null)
			{
				throw new InvalidOperationException(SR.GetString("Perflib_InvalidOperation_NoActiveProvider", m_providerGuid));
			}
			if (m_instanceCreated)
			{
				throw new InvalidOperationException(SR.GetString("Perflib_InvalidOperation_AddCounterAfterInstance", m_counterSet));
			}
			lock (m_lockObject)
			{
				if (m_instanceCreated)
				{
					throw new InvalidOperationException(SR.GetString("Perflib_InvalidOperation_AddCounterAfterInstance", m_counterSet));
				}
				if (m_stringToId.ContainsKey(counterName))
				{
					throw new ArgumentException(SR.GetString("Perflib_Argument_CounterNameAlreadyExists", counterName, m_counterSet), "CounterName");
				}
				if (m_idToCounter.ContainsKey(counterId))
				{
					throw new ArgumentException(SR.GetString("Perflib_Argument_CounterAlreadyExists", counterId, m_counterSet), "CounterId");
				}
				m_stringToId.Add(counterName, counterId);
				m_idToCounter.Add(counterId, counterType);
			}
		}

		[SecurityCritical]
		[PermissionSet(SecurityAction.Demand, Unrestricted = true)]
		public unsafe CounterSetInstance CreateCounterSetInstance(string instanceName)
		{
			if (instanceName == null)
			{
				throw new ArgumentNullException("instanceName");
			}
			if (instanceName.Length == 0)
			{
				throw new ArgumentException(SR.GetString("Perflib_Argument_EmptyInstanceName"), "instanceName");
			}
			if (m_provider == null)
			{
				throw new InvalidOperationException(SR.GetString("Perflib_InvalidOperation_NoActiveProvider", m_providerGuid));
			}
			if (!m_instanceCreated)
			{
				lock (m_lockObject)
				{
					if (!m_instanceCreated)
					{
						if (m_provider == null)
						{
							throw new ArgumentException(SR.GetString("Perflib_Argument_ProviderNotFound", m_providerGuid), "ProviderGuid");
						}
						if (m_provider.m_hProvider.IsInvalid)
						{
							throw new InvalidOperationException(SR.GetString("Perflib_InvalidOperation_NoActiveProvider", m_providerGuid));
						}
						if (m_idToCounter.Count == 0)
						{
							throw new InvalidOperationException(SR.GetString("Perflib_InvalidOperation_CounterSetContainsNoCounter", m_counterSet));
						}
						uint num = 0u;
						uint num2 = (uint)(sizeof(Microsoft.Win32.UnsafeNativeMethods.PerfCounterSetInfoStruct) + m_idToCounter.Count * sizeof(Microsoft.Win32.UnsafeNativeMethods.PerfCounterInfoStruct));
						uint num3 = 0u;
						byte* ptr = stackalloc byte[(int)num2];
						if (ptr == null)
						{
							throw new InsufficientMemoryException(SR.GetString("Perflib_InsufficientMemory_CounterSetTemplate", m_counterSet, num2));
						}
						uint num4 = 0u;
						uint num5 = 0u;
						Microsoft.Win32.UnsafeNativeMethods.PerfCounterSetInfoStruct* ptr2 = (Microsoft.Win32.UnsafeNativeMethods.PerfCounterSetInfoStruct*)ptr;
						ptr2->CounterSetGuid = m_counterSet;
						ptr2->ProviderGuid = m_providerGuid;
						ptr2->NumCounters = (uint)m_idToCounter.Count;
						ptr2->InstanceType = (uint)m_instType;
						foreach (KeyValuePair<int, CounterType> item in m_idToCounter)
						{
							num3 = (uint)(sizeof(Microsoft.Win32.UnsafeNativeMethods.PerfCounterSetInfoStruct) + (int)num4 * sizeof(Microsoft.Win32.UnsafeNativeMethods.PerfCounterInfoStruct));
							if (num3 < num2)
							{
								Microsoft.Win32.UnsafeNativeMethods.PerfCounterInfoStruct* ptr3 = (Microsoft.Win32.UnsafeNativeMethods.PerfCounterInfoStruct*)(ptr + (int)num3);
								ptr3->CounterId = (uint)item.Key;
								ptr3->CounterType = (uint)item.Value;
								ptr3->Attrib = 1L;
								ptr3->Size = (uint)sizeof(void*);
								ptr3->DetailLevel = 100u;
								ptr3->Scale = 0u;
								ptr3->Offset = num5;
								num5 += ptr3->Size;
							}
							num4++;
						}
						num = Microsoft.Win32.UnsafeNativeMethods.PerfSetCounterSetInfo(m_provider.m_hProvider, ptr2, num2);
						if (num != 0)
						{
							uint num6 = num;
							if (num6 == 183)
							{
								throw new ArgumentException(SR.GetString("Perflib_Argument_CounterSetAlreadyRegister", m_counterSet), "CounterSetGuid");
							}
							throw new Win32Exception((int)num);
						}
						Interlocked.Increment(ref m_provider.m_counterSet);
						m_instanceCreated = true;
					}
				}
			}
			return new CounterSetInstance(this, instanceName);
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class CounterSetInstance : IDisposable
	{
		internal CounterSet m_counterSet;

		internal string m_instName;

		private int m_active;

		private CounterSetInstanceCounterDataSet m_counters;

		internal unsafe Microsoft.Win32.UnsafeNativeMethods.PerfCounterSetInstanceStruct* m_nativeInst;

		public CounterSetInstanceCounterDataSet Counters => m_counters;

		[SecurityCritical]
		internal unsafe CounterSetInstance(CounterSet counterSetDefined, string instanceName)
		{
			if (counterSetDefined == null)
			{
				throw new ArgumentNullException("counterSetDefined");
			}
			if (instanceName == null)
			{
				throw new ArgumentNullException("InstanceName");
			}
			if (instanceName.Length == 0)
			{
				throw new ArgumentException(SR.GetString("Perflib_Argument_EmptyInstanceName"), "InstanceName");
			}
			m_counterSet = counterSetDefined;
			m_instName = instanceName;
			m_nativeInst = Microsoft.Win32.UnsafeNativeMethods.PerfCreateInstance(m_counterSet.m_provider.m_hProvider, ref m_counterSet.m_counterSet, m_instName, 0u);
			int num = ((m_nativeInst == null) ? Marshal.GetLastWin32Error() : 0);
			if (m_nativeInst != null)
			{
				m_counters = new CounterSetInstanceCounterDataSet(this);
				m_active = 1;
				return;
			}
			switch (num)
			{
			case 183:
				throw new ArgumentException(SR.GetString("Perflib_Argument_InstanceAlreadyExists", m_instName, m_counterSet.m_counterSet), "InstanceName");
			case 1168:
				throw new InvalidOperationException(SR.GetString("Perflib_InvalidOperation_CounterSetNotInstalled", m_counterSet.m_counterSet));
			case 87:
				if (m_counterSet.m_instType == CounterSetInstanceType.Single)
				{
					throw new ArgumentException(SR.GetString("Perflib_Argument_InvalidInstance", m_counterSet.m_counterSet), "InstanceName");
				}
				throw new Win32Exception(num);
			default:
				throw new Win32Exception(num);
			}
		}

		[SecurityCritical]
		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		[SecurityCritical]
		~CounterSetInstance()
		{
			Dispose(disposing: false);
		}

		[SecurityCritical]
		private unsafe void Dispose(bool disposing)
		{
			if (!disposing)
			{
				return;
			}
			if (m_counters != null)
			{
				m_counters.Dispose();
				m_counters = null;
			}
			if (m_nativeInst != null && Interlocked.Exchange(ref m_active, 0) != 0 && m_nativeInst != null)
			{
				if (m_counterSet.m_provider != null)
				{
					Microsoft.Win32.UnsafeNativeMethods.PerfDeleteInstance(m_counterSet.m_provider.m_hProvider, m_nativeInst);
				}
				m_nativeInst = null;
			}
		}
	}
	public enum CounterSetInstanceType
	{
		Single = 0,
		Multiple = 2,
		GlobalAggregate = 4,
		GlobalAggregateWithHistory = 11,
		MultipleAggregate = 6,
		InstanceAggregate = 22
	}
	public enum CounterType
	{
		QueueLength = 4523008,
		LargeQueueLength = 4523264,
		QueueLength100Ns = 5571840,
		QueueLengthObjectTime = 6620416,
		RawData32 = 65536,
		RawData64 = 65792,
		RawDataHex32 = 0,
		RawDataHex64 = 256,
		RateOfCountPerSecond32 = 272696320,
		RateOfCountPerSecond64 = 272696576,
		RawFraction32 = 537003008,
		RawFraction64 = 537003264,
		RawBase32 = 1073939459,
		RawBase64 = 1073939712,
		SampleFraction = 549585920,
		SampleCounter = 4260864,
		SampleBase = 1073939457,
		AverageTimer32 = 805438464,
		AverageBase = 1073939458,
		AverageCount64 = 1073874176,
		PercentageActive = 541132032,
		PercentageNotActive = 557909248,
		PercentageActive100Ns = 542180608,
		PercentageNotActive100Ns = 558957824,
		ElapsedTime = 807666944,
		MultiTimerPercentageActive = 574686464,
		MultiTimerPercentageNotActive = 591463680,
		MultiTimerPercentageActive100Ns = 575735040,
		MultiTimerPercentageNotActive100Ns = 592512256,
		MultiTimerBase = 1107494144,
		Delta32 = 4195328,
		Delta64 = 4195584,
		ObjectSpecificTimer = 543229184,
		PrecisionSystemTimer = 541525248,
		PrecisionTimer100Ns = 542573824,
		PrecisionObjectSpecificTimer = 543622400
	}
	internal sealed class PerfProvider
	{
		internal Guid m_providerGuid;

		internal int m_counterSet;

		internal SafePerfProviderHandle m_hProvider;

		[SecurityCritical]
		internal unsafe PerfProvider(Guid providerGuid)
		{
			m_providerGuid = providerGuid;
			uint num = Microsoft.Win32.UnsafeNativeMethods.PerfStartProvider(ref m_providerGuid, null, out m_hProvider);
			if (num != 0)
			{
				throw new Win32Exception((int)num);
			}
		}
	}
	internal static class PerfProviderCollection
	{
		private static object s_hiddenInternalSyncObject;

		private static List<PerfProvider> s_providerList = new List<PerfProvider>();

		private static Dictionary<object, int> s_counterSetList = new Dictionary<object, int>();

		private static CounterType[] s_counterTypes = (CounterType[])Enum.GetValues(typeof(CounterType));

		private static CounterSetInstanceType[] s_counterSetInstanceTypes = (CounterSetInstanceType[])Enum.GetValues(typeof(CounterSetInstanceType));

		private static object s_lockObject
		{
			get
			{
				if (s_hiddenInternalSyncObject == null)
				{
					object value = new object();
					Interlocked.CompareExchange(ref s_hiddenInternalSyncObject, value, null);
				}
				return s_hiddenInternalSyncObject;
			}
		}

		[SecurityCritical]
		internal static PerfProvider QueryProvider(Guid providerGuid)
		{
			lock (s_lockObject)
			{
				foreach (PerfProvider s_provider in s_providerList)
				{
					if (s_provider.m_providerGuid == providerGuid)
					{
						return s_provider;
					}
				}
				PerfProvider perfProvider = new PerfProvider(providerGuid);
				s_providerList.Add(perfProvider);
				return perfProvider;
			}
		}

		[SecurityCritical]
		internal static void RemoveProvider(Guid providerGuid)
		{
			lock (s_lockObject)
			{
				PerfProvider perfProvider = null;
				foreach (PerfProvider s_provider in s_providerList)
				{
					if (s_provider.m_providerGuid == providerGuid)
					{
						perfProvider = s_provider;
					}
				}
				if (perfProvider != null)
				{
					perfProvider.m_hProvider.Dispose();
					s_providerList.Remove(perfProvider);
				}
			}
		}

		internal static void RegisterCounterSet(Guid counterSetGuid)
		{
			lock (s_lockObject)
			{
				if (s_counterSetList.ContainsKey(counterSetGuid))
				{
					throw new ArgumentException(SR.GetString("Perflib_Argument_CounterSetAlreadyRegister", counterSetGuid), "CounterSetGuid");
				}
				s_counterSetList.Add(counterSetGuid, 0);
			}
		}

		internal static void UnregisterCounterSet(Guid counterSetGuid)
		{
			lock (s_lockObject)
			{
				s_counterSetList.Remove(counterSetGuid);
			}
		}

		internal static bool ValidateCounterType(CounterType inCounterType)
		{
			CounterType[] array = s_counterTypes;
			foreach (CounterType counterType in array)
			{
				if (counterType == inCounterType)
				{
					return true;
				}
			}
			return false;
		}

		internal static bool ValidateCounterSetInstanceType(CounterSetInstanceType inCounterSetInstanceType)
		{
			CounterSetInstanceType[] array = s_counterSetInstanceTypes;
			foreach (CounterSetInstanceType counterSetInstanceType in array)
			{
				if (counterSetInstanceType == inCounterSetInstanceType)
				{
					return true;
				}
			}
			return false;
		}
	}
}
namespace System.Collections.Generic
{
	internal class BitHelper
	{
		private const byte MarkedBitFlag = 1;

		private const byte IntSize = 32;

		private int m_length;

		private unsafe int* m_arrayPtr;

		private int[] m_array;

		private bool useStackAlloc;

		[SecurityCritical]
		internal unsafe BitHelper(int* bitArrayPtr, int length)
		{
			m_arrayPtr = bitArrayPtr;
			m_length = length;
			useStackAlloc = true;
		}

		internal BitHelper(int[] bitArray, int length)
		{
			m_array = bitArray;
			m_length = length;
		}

		[SecurityCritical]
		internal unsafe void MarkBit(int bitPosition)
		{
			if (useStackAlloc)
			{
				int num = bitPosition / 32;
				if (num < m_length && num >= 0)
				{
					m_arrayPtr[num] |= 1 << bitPosition % 32;
				}
			}
			else
			{
				int num2 = bitPosition / 32;
				if (num2 < m_length && num2 >= 0)
				{
					m_array[num2] |= 1 << bitPosition % 32;
				}
			}
		}

		[SecurityCritical]
		internal unsafe bool IsMarked(int bitPosition)
		{
			if (useStackAlloc)
			{
				int num = bitPosition / 32;
				if (num < m_length && num >= 0)
				{
					return (m_arrayPtr[num] & (1 << bitPosition % 32)) != 0;
				}
				return false;
			}
			int num2 = bitPosition / 32;
			if (num2 < m_length && num2 >= 0)
			{
				return (m_array[num2] & (1 << bitPosition % 32)) != 0;
			}
			return false;
		}

		internal static int ToIntArrayLength(int n)
		{
			if (n <= 0)
			{
				return 0;
			}
			return (n - 1) / 32 + 1;
		}
	}
	internal static class HashHelpers
	{
		internal static readonly int[] primes = new int[72]
		{
			3, 7, 11, 17, 23, 29, 37, 47, 59, 71,
			89, 107, 131, 163, 197, 239, 293, 353, 431, 521,
			631, 761, 919, 1103, 1327, 1597, 1931, 2333, 2801, 3371,
			4049, 4861, 5839, 7013, 8419, 10103, 12143, 14591, 17519, 21023,
			25229, 30293, 36353, 43627, 52361, 62851, 75431, 90523, 108631, 130363,
			156437, 187751, 225307, 270371, 324449, 389357, 467237, 560689, 672827, 807403,
			968897, 1162687, 1395263, 1674319, 2009191, 2411033, 2893249, 3471899, 4166287, 4999559,
			5999471, 7199369
		};

		[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
		internal static bool IsPrime(int candidate)
		{
			if (((uint)candidate & (true ? 1u : 0u)) != 0)
			{
				int num = (int)Math.Sqrt(candidate);
				for (int i = 3; i <= num; i += 2)
				{
					if (candidate % i == 0)
					{
						return false;
					}
				}
				return true;
			}
			return candidate == 2;
		}

		[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
		internal static int GetPrime(int min)
		{
			for (int i = 0; i < primes.Length; i++)
			{
				int num = primes[i];
				if (num >= min)
				{
					return num;
				}
			}
			for (int j = min | 1; j < int.MaxValue; j += 2)
			{
				if (IsPrime(j))
				{
					return j;
				}
			}
			return min;
		}

		internal static int GetMinPrime()
		{
			return primes[0];
		}
	}
	[Serializable]
	[DebuggerDisplay("Count = {Count}")]
	[DebuggerTypeProxy(typeof(HashSetDebugView<>))]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class HashSet<T> : ICollection<T>, IEnumerable<T>, IEnumerable, ISerializable, IDeserializationCallback
	{
		internal struct ElementCount
		{
			internal int uniqueCount;

			internal int unfoundCount;
		}

		internal struct Slot
		{
			internal int hashCode;

			internal T value;

			internal int next;
		}

		[Serializable]
		[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
		public struct Enumerator : IEnumerator<T>, IDisposable, IEnumerator
		{
			private HashSet<T> set;

			private int index;

			private int version;

			private T current;

			public T Current => current;

			object IEnumerator.Current
			{
				get
				{
					if (index == 0 || index == set.m_lastIndex + 1)
					{
						throw new InvalidOperationException(SR.GetString("InvalidOperation_EnumOpCantHappen"));
					}
					return Current;
				}
			}

			internal Enumerator(HashSet<T> set)
			{
				this.set = set;
				index = 0;
				version = set.m_version;
				current = default(T);
			}

			public void Dispose()
			{
			}

			public bool MoveNext()
			{
				if (version != set.m_version)
				{
					throw new InvalidOperationException(SR.GetString("InvalidOperation_EnumFailedVersion"));
				}
				while (index < set.m_lastIndex)
				{
					if (set.m_slots[index].hashCode >= 0)
					{
						current = set.m_slots[index].value;
						index++;
						return true;
					}
					index++;
				}
				index = set.m_lastIndex + 1;
				current = default(T);
				return false;
			}

			void IEnumerator.Reset()
			{
				if (version != set.m_version)
				{
					throw new InvalidOperationException(SR.GetString("InvalidOperation_EnumFailedVersion"));
				}
				index = 0;
				current = default(T);
			}
		}

		private const int Lower31BitMask = int.MaxValue;

		private const int GrowthFactor = 2;

		private const int StackAllocThreshold = 100;

		private const int ShrinkThreshold = 3;

		private const string CapacityName = "Capacity";

		private const string ElementsName = "Elements";

		private const string ComparerName = "Comparer";

		private const string VersionName = "Version";

		private int[] m_buckets;

		private Slot[] m_slots;

		private int m_count;

		private int m_lastIndex;

		private int m_freeList;

		private IEqualityComparer<T> m_comparer;

		private int m_version;

		private SerializationInfo m_siInfo;

		public int Count => m_count;

		bool ICollection<T>.IsReadOnly => false;

		public IEqualityComparer<T> Comparer => m_comparer;

		public HashSet()
			: this((IEqualityComparer<T>)EqualityComparer<T>.Default)
		{
		}

		public HashSet(IEqualityComparer<T> comparer)
		{
			if (comparer == null)
			{
				comparer = EqualityComparer<T>.Default;
			}
			m_comparer = comparer;
			m_lastIndex = 0;
			m_count = 0;
			m_freeList = -1;
			m_version = 0;
		}

		public HashSet(IEnumerable<T> collection)
			: this(collection, (IEqualityComparer<T>)EqualityComparer<T>.Default)
		{
		}

		public HashSet(IEnumerable<T> collection, IEqualityComparer<T> comparer)
			: this(comparer)
		{
			if (collection == null)
			{
				throw new ArgumentNullException("collection");
			}
			int capacity = 0;
			if (collection is ICollection<T> collection2)
			{
				capacity = collection2.Count;
			}
			Initialize(capacity);
			UnionWith(collection);
			if ((m_count == 0 && m_slots.Length > HashHelpers.GetMinPrime()) || (m_count > 0 && m_slots.Length / m_count > 3))
			{
				TrimExcess();
			}
		}

		protected HashSet(SerializationInfo info, StreamingContext context)
		{
			m_siInfo = info;
		}

		void ICollection<T>.Add(T item)
		{
			AddIfNotPresent(item);
		}

		public void Clear()
		{
			if (m_lastIndex > 0)
			{
				Array.Clear(m_slots, 0, m_lastIndex);
				Array.Clear(m_buckets, 0, m_buckets.Length);
				m_lastIndex = 0;
				m_count = 0;
				m_freeList = -1;
			}
			m_version++;
		}

		public bool Contains(T item)
		{
			if (m_buckets != null)
			{
				int num = InternalGetHashCode(item);
				for (int num2 = m_buckets[num % m_buckets.Length] - 1; num2 >= 0; num2 = m_slots[num2].next)
				{
					if (m_slots[num2].hashCode == num && m_comparer.Equals(m_slots[num2].value, item))
					{
						return true;
					}
				}
			}
			return false;
		}

		public void CopyTo(T[] array, int arrayIndex)
		{
			CopyTo(array, arrayIndex, m_count);
		}

		public bool Remove(T item)
		{
			if (m_buckets != null)
			{
				int num = InternalGetHashCode(item);
				int num2 = num % m_buckets.Length;
				int num3 = -1;
				for (int num4 = m_buckets[num2] - 1; num4 >= 0; num4 = m_slots[num4].next)
				{
					if (m_slots[num4].hashCode == num && m_comparer.Equals(m_slots[num4].value, item))
					{
						if (num3 < 0)
						{
							m_buckets[num2] = m_slots[num4].next + 1;
						}
						else
						{
							m_slots[num3].next = m_slots[num4].next;
						}
						m_slots[num4].hashCode = -1;
						m_slots[num4].value = default(T);
						m_slots[num4].next = m_freeList;
						m_freeList = num4;
						m_count--;
						m_version++;
						return true;
					}
					num3 = num4;
				}
			}
			return false;
		}

		public Enumerator GetEnumerator()
		{
			return new Enumerator(this);
		}

		IEnumerator<T> IEnumerable<T>.GetEnumerator()
		{
			return new Enumerator(this);
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return new Enumerator(this);
		}

		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
		public virtual void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			if (info == null)
			{
				throw new ArgumentNullException("info");
			}
			info.AddValue("Version", m_version);
			info.AddValue("Comparer", m_comparer, typeof(IEqualityComparer<T>));
			info.AddValue("Capacity", (m_buckets != null) ? m_buckets.Length : 0);
			if (m_buckets != null)
			{
				T[] array = new T[m_count];
				CopyTo(array);
				info.AddValue("Elements", array, typeof(T[]));
			}
		}

		public virtual void OnDeserialization(object sender)
		{
			if (m_siInfo == null)
			{
				return;
			}
			int @int = m_siInfo.GetInt32("Capacity");
			m_comparer = (IEqualityComparer<T>)m_siInfo.GetValue("Comparer", typeof(IEqualityComparer<T>));
			m_freeList = -1;
			if (@int != 0)
			{
				m_buckets = new int[@int];
				m_slots = new Slot[@int];
				T[] array = (T[])m_siInfo.GetValue("Elements", typeof(T[]));
				if (array == null)
				{
					throw new SerializationException(SR.GetString("Serialization_MissingKeys"));
				}
				for (int i = 0; i < array.Length; i++)
				{
					AddIfNotPresent(array[i]);
				}
			}
			else
			{
				m_buckets = null;
			}
			m_version = m_siInfo.GetInt32("Version");
			m_siInfo = null;
		}

		public bool Add(T item)
		{
			return AddIfNotPresent(item);
		}

		public void UnionWith(IEnumerable<T> other)
		{
			if (other == null)
			{
				throw new ArgumentNullException("other");
			}
			foreach (T item in other)
			{
				AddIfNotPresent(item);
			}
		}

		[SecurityCritical]
		public void IntersectWith(IEnumerable<T> other)
		{
			if (other == null)
			{
				throw new ArgumentNullException("other");
			}
			if (m_count == 0)
			{
				return;
			}
			if (other is ICollection<T> collection)
			{
				if (collection.Count == 0)
				{
					Clear();
					return;
				}
				if (other is HashSet<T> hashSet && AreEqualityComparersEqual(this, hashSet))
				{
					IntersectWithHashSetWithSameEC(hashSet);
					return;
				}
			}
			IntersectWithEnumerable(other);
		}

		public void ExceptWith(IEnumerable<T> other)
		{
			if (other == null)
			{
				throw new ArgumentNullException("other");
			}
			if (m_count == 0)
			{
				return;
			}
			if (other == this)
			{
				Clear();
				return;
			}
			foreach (T item in other)
			{
				Remove(item);
			}
		}

		[SecurityCritical]
		public void SymmetricExceptWith(IEnumerable<T> other)
		{
			if (other == null)
			{
				throw new ArgumentNullException("other");
			}
			if (m_count == 0)
			{
				UnionWith(other);
			}
			else if (other == this)
			{
				Clear();
			}
			else if (other is HashSet<T> hashSet && AreEqualityComparersEqual(this, hashSet))
			{
				SymmetricExceptWithUniqueHashSet(hashSet);
			}
			else
			{
				SymmetricExceptWithEnumerable(other);
			}
		}

		[SecurityCritical]
		public bool IsSubsetOf(IEnumerable<T> other)
		{
			if (other == null)
			{
				throw new ArgumentNullException("other");
			}
			if (m_count == 0)
			{
				return true;
			}
			if (other is HashSet<T> hashSet && AreEqualityComparersEqual(this, hashSet))
			{
				if (m_count > hashSet.Count)
				{
					return false;
				}
				return IsSubsetOfHashSetWithSameEC(hashSet);
			}
			ElementCount elementCount = CheckUniqueAndUnfoundElements(other, returnIfUnfound: false);
			if (elementCount.uniqueCount == m_count)
			{
				return elementCount.unfoundCount >= 0;
			}
			return false;
		}

		[SecurityCritical]
		public bool IsProperSubsetOf(IEnumerable<T> other)
		{
			if (other == null)
			{
				throw new ArgumentNullException("other");
			}
			if (other is ICollection<T> collection)
			{
				if (m_count == 0)
				{
					return collection.Count > 0;
				}
				if (other is HashSet<T> hashSet && AreEqualityComparersEqual(this, hashSet))
				{
					if (m_count >= hashSet.Count)
					{
						return false;
					}
					return IsSubsetOfHashSetWithSameEC(hashSet);
				}
			}
			ElementCount elementCount = CheckUniqueAndUnfoundElements(other, returnIfUnfound: false);
			if (elementCount.uniqueCount == m_count)
			{
				return elementCount.unfoundCount > 0;
			}
			return false;
		}

		public bool IsSupersetOf(IEnumerable<T> other)
		{
			if (other == null)
			{
				throw new ArgumentNullException("other");
			}
			if (other is ICollection<T> collection)
			{
				if (collection.Count == 0)
				{
					return true;
				}
				if (other is HashSet<T> hashSet && AreEqualityComparersEqual(this, hashSet) && hashSet.Count > m_count)
				{
					return false;
				}
			}
			return ContainsAllElements(other);
		}

		[SecurityCritical]
		public bool IsProperSupersetOf(IEnumerable<T> other)
		{
			if (other == null)
			{
				throw new ArgumentNullException("other");
			}
			if (m_count == 0)
			{
				return false;
			}
			if (other is ICollection<T> collection)
			{
				if (collection.Count == 0)
				{
					return true;
				}
				if (other is HashSet<T> hashSet && AreEqualityComparersEqual(this, hashSet))
				{
					if (hashSet.Count >= m_count)
					{
						return false;
					}
					return ContainsAllElements(hashSet);
				}
			}
			ElementCount elementCount = CheckUniqueAndUnfoundElements(other, returnIfUnfound: true);
			if (elementCount.uniqueCount < m_count)
			{
				return elementCount.unfoundCount == 0;
			}
			return false;
		}

		public bool Overlaps(IEnumerable<T> other)
		{
			if (other == null)
			{
				throw new ArgumentNullException("other");
			}
			if (m_count == 0)
			{
				return false;
			}
			foreach (T item in other)
			{
				if (Contains(item))
				{
					return true;
				}
			}
			return false;
		}

		[SecurityCritical]
		public bool SetEquals(IEnumerable<T> other)
		{
			if (other == null)
			{
				throw new ArgumentNullException("other");
			}
			if (other is HashSet<T> hashSet && AreEqualityComparersEqual(this, hashSet))
			{
				if (m_count != hashSet.Count)
				{
					return false;
				}
				return ContainsAllElements(hashSet);
			}
			if (other is ICollection<T> collection && m_count == 0 && collection.Count > 0)
			{
				return false;
			}
			ElementCount elementCount = CheckUniqueAndUnfoundElements(other, returnIfUnfound: true);
			if (elementCount.uniqueCount == m_count)
			{
				return elementCount.unfoundCount == 0;
			}
			return false;
		}

		public void CopyTo(T[] array)
		{
			CopyTo(array, 0, m_count);
		}

		public void CopyTo(T[] array, int arrayIndex, int count)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			if (arrayIndex < 0)
			{
				throw new ArgumentOutOfRangeException("arrayIndex", SR.GetString("ArgumentOutOfRange_NeedNonNegNum"));
			}
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count", SR.GetString("ArgumentOutOfRange_NeedNonNegNum"));
			}
			if (arrayIndex > array.Length || count > array.Length - arrayIndex)
			{
				throw new ArgumentException(SR.GetString("Arg_ArrayPlusOffTooSmall"));
			}
			int num = 0;
			for (int i = 0; i < m_lastIndex; i++)
			{
				if (num >= count)
				{
					break;
				}
				if (m_slots[i].hashCode >= 0)
				{
					array[arrayIndex + num] = m_slots[i].value;
					num++;
				}
			}
		}

		public int RemoveWhere(Predicate<T> match)
		{
			if (match == null)
			{
				throw new ArgumentNullException("match");
			}
			int num = 0;
			for (int i = 0; i < m_lastIndex; i++)
			{
				if (m_slots[i].hashCode >= 0)
				{
					T value = m_slots[i].value;
					if (match(value) && Remove(value))
					{
						num++;
					}
				}
			}
			return num;
		}

		public void TrimExcess()
		{
			if (m_count == 0)
			{
				m_buckets = null;
				m_slots = null;
				m_version++;
				return;
			}
			int prime = HashHelpers.GetPrime(m_count);
			Slot[] array = new Slot[prime];
			int[] array2 = new int[prime];
			int num = 0;
			for (int i = 0; i < m_lastIndex; i++)
			{
				if (m_slots[i].hashCode >= 0)
				{
					ref Slot reference = ref array[num];
					reference = m_slots[i];
					int num2 = array[num].hashCode % prime;
					array[num].next = array2[num2] - 1;
					array2[num2] = num + 1;
					num++;
				}
			}
			m_lastIndex = num;
			m_slots = array;
			m_buckets = array2;
			m_freeList = -1;
		}

		public static IEqualityComparer<HashSet<T>> CreateSetComparer()
		{
			return new HashSetEqualityComparer<T>();
		}

		private void Initialize(int capacity)
		{
			int prime = HashHelpers.GetPrime(capacity);
			m_buckets = new int[prime];
			m_slots = new Slot[prime];
		}

		private void IncreaseCapacity()
		{
			int num = m_count * 2;
			if (num < 0)
			{
				num = m_count;
			}
			int prime = HashHelpers.GetPrime(num);
			if (prime <= m_count)
			{
				throw new ArgumentException(SR.GetString("Arg_HSCapacityOverflow"));
			}
			Slot[] array = new Slot[prime];
			if (m_slots != null)
			{
				Array.Copy(m_slots, 0, array, 0, m_lastIndex);
			}
			int[] array2 = new int[prime];
			for (int i = 0; i < m_lastIndex; i++)
			{
				int num2 = array[i].hashCode % prime;
				array[i].next = array2[num2] - 1;
				array2[num2] = i + 1;
			}
			m_slots = array;
			m_buckets = array2;
		}

		private bool AddIfNotPresent(T value)
		{
			if (m_buckets == null)
			{
				Initialize(0);
			}
			int num = InternalGetHashCode(value);
			int num2 = num % m_buckets.Length;
			for (int num3 = m_buckets[num % m_buckets.Length] - 1; num3 >= 0; num3 = m_slots[num3].next)
			{
				if (m_slots[num3].hashCode == num && m_comparer.Equals(m_slots[num3].value, value))
				{
					return false;
				}
			}
			int num4;
			if (m_freeList >= 0)
			{
				num4 = m_freeList;
				m_freeList = m_slots[num4].next;
			}
			else
			{
				if (m_lastIndex == m_slots.Length)
				{
					IncreaseCapacity();
					num2 = num % m_buckets.Length;
				}
				num4 = m_lastIndex;
				m_lastIndex++;
			}
			m_slots[num4].hashCode = num;
			m_slots[num4].value = value;
			m_slots[num4].next = m_buckets[num2] - 1;
			m_buckets[num2] = num4 + 1;
			m_count++;
			m_version++;
			return true;
		}

		private bool ContainsAllElements(IEnumerable<T> other)
		{
			foreach (T item in other)
			{
				if (!Contains(item))
				{
					return false;
				}
			}
			return true;
		}

		private bool IsSubsetOfHashSetWithSameEC(HashSet<T> other)
		{
			using (Enumerator enumerator = GetEnumerator())
			{
				while (enumerator.MoveNext())
				{
					T current = enumerator.Current;
					if (!other.Contains(current))
					{
						return false;
					}
				}
			}
			return true;
		}

		private void IntersectWithHashSetWithSameEC(HashSet<T> other)
		{
			for (int i = 0; i < m_lastIndex; i++)
			{
				if (m_slots[i].hashCode >= 0)
				{
					T value = m_slots[i].value;
					if (!other.Contains(value))
					{
						Remove(value);
					}
				}
			}
		}

		[SecurityCritical]
		private unsafe void IntersectWithEnumerable(IEnumerable<T> other)
		{
			int lastIndex = m_lastIndex;
			int num = BitHelper.ToIntArrayLength(lastIndex);
			BitHelper bitHelper;
			if (num <= 100)
			{
				int* bitArrayPtr = (int*)stackalloc byte[4 * num];
				bitHelper = new BitHelper(bitArrayPtr, num);
			}
			else
			{
				int[] bitArray = new int[num];
				bitHelper = new BitHelper(bitArray, num);
			}
			foreach (T item in other)
			{
				int num2 = InternalIndexOf(item);
				if (num2 >= 0)
				{
					bitHelper.MarkBit(num2);
				}
			}
			for (int i = 0; i < lastIndex; i++)
			{
				if (m_slots[i].hashCode >= 0 && !bitHelper.IsMarked(i))
				{
					Remove(m_slots[i].value);
				}
			}
		}

		private int InternalIndexOf(T item)
		{
			int num = InternalGetHashCode(item);
			for (int num2 = m_buckets[num % m_buckets.Length] - 1; num2 >= 0; num2 = m_slots[num2].next)
			{
				if (m_slots[num2].hashCode == num && m_comparer.Equals(m_slots[num2].value, item))
				{
					return num2;
				}
			}
			return -1;
		}

		private void SymmetricExceptWithUniqueHashSet(HashSet<T> other)
		{
			foreach (T item in other)
			{
				if (!Remove(item))
				{
					AddIfNotPresent(item);
				}
			}
		}

		[SecurityCritical]
		private unsafe void SymmetricExceptWithEnumerable(IEnumerable<T> other)
		{
			int lastIndex = m_lastIndex;
			int num = BitHelper.ToIntArrayLength(lastIndex);
			BitHelper bitHelper;
			BitHelper bitHelper2;
			if (num <= 50)
			{
				int* bitArrayPtr = (int*)stackalloc byte[4 * num];
				bitHelper = new BitHelper(bitArrayPtr, num);
				int* bitArrayPtr2 = (int*)stackalloc byte[4 * num];
				bitHelper2 = new BitHelper(bitArrayPtr2, num);
			}
			else
			{
				int[] bitArray = new int[num];
				bitHelper = new BitHelper(bitArray, num);
				int[] bitArray2 = new int[num];
				bitHelper2 = new BitHelper(bitArray2, num);
			}
			foreach (T item in other)
			{
				int location = 0;
				if (AddOrGetLocation(item, out location))
				{
					bitHelper2.MarkBit(location);
				}
				else if (location < lastIndex && !bitHelper2.IsMarked(location))
				{
					bitHelper.MarkBit(location);
				}
			}
			for (int i = 0; i < lastIndex; i++)
			{
				if (bitHelper.IsMarked(i))
				{
					Remove(m_slots[i].value);
				}
			}
		}

		private bool AddOrGetLocation(T value, out int location)
		{
			int num = InternalGetHashCode(value);
			int num2 = num % m_buckets.Length;
			for (int num3 = m_buckets[num % m_buckets.Length] - 1; num3 >= 0; num3 = m_slots[num3].next)
			{
				if (m_slots[num3].hashCode == num && m_comparer.Equals(m_slots[num3].value, value))
				{
					location = num3;
					return false;
				}
			}
			int num4;
			if (m_freeList >= 0)
			{
				num4 = m_freeList;
				m_freeList = m_slots[num4].next;
			}
			else
			{
				if (m_lastIndex == m_slots.Length)
				{
					IncreaseCapacity();
					num2 = num % m_buckets.Length;
				}
				num4 = m_lastIndex;
				m_lastIndex++;
			}
			m_slots[num4].hashCode = num;
			m_slots[num4].value = value;
			m_slots[num4].next = m_buckets[num2] - 1;
			m_buckets[num2] = num4 + 1;
			m_count++;
			m_version++;
			location = num4;
			return true;
		}

		[SecurityCritical]
		private unsafe ElementCount CheckUniqueAndUnfoundElements(IEnumerable<T> other, bool returnIfUnfound)
		{
			ElementCount result = default(ElementCount);
			if (m_count == 0)
			{
				int num = 0;
				using (IEnumerator<T> enumerator = other.GetEnumerator())
				{
					if (enumerator.MoveNext())
					{
						_ = enumerator.Current;
						num++;
					}
				}
				result.uniqueCount = 0;
				result.unfoundCount = num;
				return result;
			}
			int lastIndex = m_lastIndex;
			int num2 = BitHelper.ToIntArrayLength(lastIndex);
			BitHelper bitHelper;
			if (num2 <= 100)
			{
				int* bitArrayPtr = (int*)stackalloc byte[4 * num2];
				bitHelper = new BitHelper(bitArrayPtr, num2);
			}
			else
			{
				int[] bitArray = new int[num2];
				bitHelper = new BitHelper(bitArray, num2);
			}
			int num3 = 0;
			int num4 = 0;
			foreach (T item in other)
			{
				int num5 = InternalIndexOf(item);
				if (num5 >= 0)
				{
					if (!bitHelper.IsMarked(num5))
					{
						bitHelper.MarkBit(num5);
						num4++;
					}
				}
				else
				{
					num3++;
					if (returnIfUnfound)
					{
						break;
					}
				}
			}
			result.uniqueCount = num4;
			result.unfoundCount = num3;
			return result;
		}

		internal T[] ToArray()
		{
			T[] array = new T[Count];
			CopyTo(array);
			return array;
		}

		internal static bool HashSetEquals(HashSet<T> set1, HashSet<T> set2, IEqualityComparer<T> comparer)
		{
			if (set1 == null)
			{
				return set2 == null;
			}
			if (set2 == null)
			{
				return false;
			}
			if (AreEqualityComparersEqual(set1, set2))
			{
				if (set1.Count != set2.Count)
				{
					return false;
				}
				foreach (T item in set2)
				{
					if (!set1.Contains(item))
					{
						return false;
					}
				}
				return true;
			}
			foreach (T item2 in set2)
			{
				bool flag = false;
				foreach (T item3 in set1)
				{
					if (comparer.Equals(item2, item3))
					{
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					return false;
				}
			}
			return true;
		}

		private static bool AreEqualityComparersEqual(HashSet<T> set1, HashSet<T> set2)
		{
			return set1.Comparer.Equals(set2.Comparer);
		}

		private int InternalGetHashCode(T item)
		{
			if (item == null)
			{
				return 0;
			}
			return m_comparer.GetHashCode(item) & 0x7FFFFFFF;
		}
	}
	internal class HashSetDebugView<T>
	{
		private HashSet<T> set;

		[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
		public T[] Items => set.ToArray();

		public HashSetDebugView(HashSet<T> set)
		{
			if (set == null)
			{
				throw new ArgumentNullException("set");
			}
			this.set = set;
		}
	}
	[Serializable]
	internal class HashSetEqualityComparer<T> : IEqualityComparer<HashSet<T>>
	{
		private IEqualityComparer<T> m_comparer;

		public HashSetEqualityComparer()
		{
			m_comparer = EqualityComparer<T>.Default;
		}

		public HashSetEqualityComparer(IEqualityComparer<T> comparer)
		{
			if (m_comparer == null)
			{
				m_comparer = EqualityComparer<T>.Default;
			}
			else
			{
				m_comparer = comparer;
			}
		}

		public bool Equals(HashSet<T> x, HashSet<T> y)
		{
			return HashSet<T>.HashSetEquals(x, y, m_comparer);
		}

		public int GetHashCode(HashSet<T> obj)
		{
			int num = 0;
			if (obj != null)
			{
				foreach (T item in obj)
				{
					num ^= m_comparer.GetHashCode(item) & 0x7FFFFFFF;
				}
				return num;
			}
			return num;
		}

		public override bool Equals(object obj)
		{
			if (!(obj is HashSetEqualityComparer<T> hashSetEqualityComparer))
			{
				return false;
			}
			return m_comparer == hashSetEqualityComparer.m_comparer;
		}

		public override int GetHashCode()
		{
			return m_comparer.GetHashCode();
		}
	}
}
namespace System.IO
{
	[Serializable]
	public enum HandleInheritability
	{
		None,
		Inheritable
	}
}
namespace System.IO.Pipes
{
	[Serializable]
	public enum PipeDirection
	{
		In = 1,
		Out,
		InOut
	}
	[Serializable]
	public enum PipeTransmissionMode
	{
		Byte,
		Message
	}
	[Serializable]
	[Flags]
	public enum PipeOptions
	{
		None = 0,
		WriteThrough = int.MinValue,
		Asynchronous = 0x40000000
	}
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public abstract class PipeStream : Stream
	{
		private static readonly bool _canUseAsync;

		private static readonly IOCompletionCallback IOCallback;

		private SafePipeHandle m_handle;

		private bool m_canRead;

		private bool m_canWrite;

		private bool m_isAsync;

		private bool m_isMessageComplete;

		private bool m_isFromExistingHandle;

		private bool m_isHandleExposed;

		private PipeTransmissionMode m_readMode;

		private PipeTransmissionMode m_transmissionMode;

		private PipeDirection m_pipeDirection;

		private int m_outBufferSize;

		private PipeState m_state;

		public bool IsConnected
		{
			get
			{
				return State == PipeState.Connected;
			}
			protected set
			{
				m_state = (value ? PipeState.Connected : PipeState.Disconnected);
			}
		}

		public bool IsAsync => m_isAsync;

		public bool IsMessageComplete
		{
			[SecurityCritical]
			get
			{
				if (m_state == PipeState.WaitingToConnect)
				{
					throw new InvalidOperationException(SR.GetString("InvalidOperation_PipeNotYetConnected"));
				}
				if (m_state == PipeState.Disconnected)
				{
					throw new InvalidOperationException(SR.GetString("InvalidOperation_PipeDisconnected"));
				}
				if (m_handle == null)
				{
					throw new InvalidOperationException(SR.GetString("InvalidOperation_PipeHandleNotSet"));
				}
				if (m_state == PipeState.Closed)
				{
					__Error.PipeNotOpen();
				}
				if (m_handle.IsClosed)
				{
					__Error.PipeNotOpen();
				}
				if (m_readMode != PipeTransmissionMode.Message)
				{
					throw new InvalidOperationException(SR.GetString("InvalidOperation_PipeReadModeNotMessage"));
				}
				return m_isMessageComplete;
			}
		}

		public virtual PipeTransmissionMode TransmissionMode
		{
			[SecurityCritical]
			get
			{
				CheckPipePropertyOperations();
				if (m_isFromExistingHandle)
				{
					if (!Microsoft.Win32.UnsafeNativeMethods.GetNamedPipeInfo(m_handle, out var lpFlags, Microsoft.Win32.UnsafeNativeMethods.NULL, Microsoft.Win32.UnsafeNativeMethods.NULL, Microsoft.Win32.UnsafeNativeMethods.NULL))
					{
						WinIOError(Marshal.GetLastWin32Error());
					}
					if (((uint)lpFlags & 4u) != 0)
					{
						return PipeTransmissionMode.Message;
					}
					return PipeTransmissionMode.Byte;
				}
				return m_transmissionMode;
			}
		}

		public virtual int InBufferSize
		{
			[SecurityCritical]
			get
			{
				CheckPipePropertyOperations();
				if (!CanRead)
				{
					throw new NotSupportedException(SR.GetString("NotSupported_UnreadableStream"));
				}
				if (!Microsoft.Win32.UnsafeNativeMethods.GetNamedPipeInfo(m_handle, Microsoft.Win32.UnsafeNativeMethods.NULL, Microsoft.Win32.UnsafeNativeMethods.NULL, out var lpInBufferSize, Microsoft.Win32.UnsafeNativeMethods.NULL))
				{
					WinIOError(Marshal.GetLastWin32Error());
				}
				return lpInBufferSize;
			}
		}

		public virtual int OutBufferSize
		{
			[SecurityCritical]
			get
			{
				CheckPipePropertyOperations();
				if (!CanWrite)
				{
					throw new NotSupportedException(SR.GetString("NotSupported_UnwritableStream"));
				}
				if (m_pipeDirection == PipeDirection.Out)
				{
					return m_outBufferSize;
				}
				if (!Microsoft.Win32.UnsafeNativeMethods.GetNamedPipeInfo(m_handle, Microsoft.Win32.UnsafeNativeMethods.NULL, out var lpOutBufferSize, Microsoft.Win32.UnsafeNativeMethods.NULL, Microsoft.Win32.UnsafeNativeMethods.NULL))
				{
					WinIOError(Marshal.GetLastWin32Error());
				}
				return lpOutBufferSize;
			}
		}

		public unsafe virtual PipeTransmissionMode ReadMode
		{
			[SecurityCritical]
			get
			{
				CheckPipePropertyOperations();
				if (m_isFromExistingHandle || IsHandleExposed)
				{
					UpdateReadMode();
				}
				return m_readMode;
			}
			[SecurityCritical]
			set
			{
				CheckPipePropertyOperations();
				if (value < PipeTransmissionMode.Byte || value > PipeTransmissionMode.Message)
				{
					throw new ArgumentOutOfRangeException("value", SR.GetString("ArgumentOutOfRange_TransmissionModeByteOrMsg"));
				}
				int num = (int)value << 1;
				if (!Microsoft.Win32.UnsafeNativeMethods.SetNamedPipeHandleState(m_handle, &num, Microsoft.Win32.UnsafeNativeMethods.NULL, Microsoft.Win32.UnsafeNativeMethods.NULL))
				{
					WinIOError(Marshal.GetLastWin32Error());
				}
				else
				{
					m_readMode = value;
				}
			}
		}

		public SafePipeHandle SafePipeHandle
		{
			[SecurityCritical]
			get
			{
				if (m_handle == null)
				{
					throw new InvalidOperationException(SR.GetString("InvalidOperation_PipeHandleNotSet"));
				}
				if (m_handle.IsClosed)
				{
					__Error.PipeNotOpen();
				}
				m_isHandleExposed = true;
				return m_handle;
			}
		}

		internal SafePipeHandle InternalHandle
		{
			[SecurityCritical]
			get
			{
				return m_handle;
			}
		}

		protected bool IsHandleExposed => m_isHandleExposed;

		public override bool CanRead => m_canRead;

		public override bool CanWrite => m_canWrite;

		public override bool CanSeek => false;

		public override long Length
		{
			get
			{
				__Error.SeekNotSupported();
				return 0L;
			}
		}

		public override long Position
		{
			get
			{
				__Error.SeekNotSupported();
				return 0L;
			}
			set
			{
				__Error.SeekNotSupported();
			}
		}

		internal PipeState State
		{
			get
			{
				return m_state;
			}
			set
			{
				m_state = value;
			}
		}

		[SecurityCritical]
		static unsafe PipeStream()
		{
			_canUseAsync = Environment.OSVersion.Platform == PlatformID.Win32NT;
			IOCallback = AsyncPSCallback;
		}

		protected PipeStream(PipeDirection direction, int bufferSize)
		{
			if (direction < PipeDirection.In || direction > PipeDirection.InOut)
			{
				throw new ArgumentOutOfRangeException("direction", SR.GetString("ArgumentOutOfRange_DirectionModeInOutOrInOut"));
			}
			if (bufferSize < 0)
			{
				throw new ArgumentOutOfRangeException("bufferSize", SR.GetString("ArgumentOutOfRange_NeedNonNegNum"));
			}
			Init(direction, PipeTransmissionMode.Byte, bufferSize);
		}

		protected PipeStream(PipeDirection direction, PipeTransmissionMode transmissionMode, int outBufferSize)
		{
			if (direction < PipeDirection.In || direction > PipeDirection.InOut)
			{
				throw new ArgumentOutOfRangeException("direction", SR.GetString("ArgumentOutOfRange_DirectionModeInOutOrInOut"));
			}
			if (transmissionMode < PipeTransmissionMode.Byte || transmissionMode > PipeTransmissionMode.Message)
			{
				throw new ArgumentOutOfRangeException("transmissionMode", SR.GetString("ArgumentOutOfRange_TransmissionModeByteOrMsg"));
			}
			if (outBufferSize < 0)
			{
				throw new ArgumentOutOfRangeException("outBufferSize", SR.GetString("ArgumentOutOfRange_NeedNonNegNum"));
			}
			Init(direction, transmissionMode, outBufferSize);
		}

		private void Init(PipeDirection direction, PipeTransmissionMode transmissionMode, int outBufferSize)
		{
			m_readMode = transmissionMode;
			m_transmissionMode = transmissionMode;
			m_pipeDirection = direction;
			if ((m_pipeDirection & PipeDirection.In) != 0)
			{
				m_canRead = true;
			}
			if ((m_pipeDirection & PipeDirection.Out) != 0)
			{
				m_canWrite = true;
			}
			m_outBufferSize = outBufferSize;
			m_isMessageComplete = true;
			m_state = PipeState.WaitingToConnect;
		}

		[SecurityCritical]
		protected void InitializeHandle(SafePipeHandle handle, bool isExposed, bool isAsync)
		{
			isAsync &= _canUseAsync;
			if (isAsync)
			{
				bool flag = false;
				new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Assert();
				try
				{
					flag = ThreadPool.BindHandle(handle);
				}
				finally
				{
					CodeAccessPermission.RevertAssert();
				}
				if (!flag)
				{
					throw new IOException(SR.GetString("IO_IO_BindHandleFailed"));
				}
			}
			m_handle = handle;
			m_isAsync = isAsync;
			m_isHandleExposed = isExposed;
			m_isFromExistingHandle = isExposed;
		}

		[SecurityCritical]
		public override int Read([In][Out] byte[] buffer, int offset, int count)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException("buffer", SR.GetString("ArgumentNull_Buffer"));
			}
			if (offset < 0)
			{
				throw new ArgumentOutOfRangeException("offset", SR.GetString("ArgumentOutOfRange_NeedNonNegNum"));
			}
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count", SR.GetString("ArgumentOutOfRange_NeedNonNegNum"));
			}
			if (buffer.Length - offset < count)
			{
				throw new ArgumentException(SR.GetString("Argument_InvalidOffLen"));
			}
			if (!CanRead)
			{
				__Error.ReadNotSupported();
			}
			CheckReadOperations();
			return ReadCore(buffer, offset, count);
		}

		[SecurityCritical]
		private unsafe int ReadCore(byte[] buffer, int offset, int count)
		{
			if (m_isAsync)
			{
				IAsyncResult asyncResult = BeginReadCore(buffer, offset, count, null, null);
				return EndRead(asyncResult);
			}
			int hr = 0;
			int num = ReadFileNative(m_handle, buffer, offset, count, null, out hr);
			if (num == -1)
			{
				if (hr == 109 || hr == 233)
				{
					State = PipeState.Broken;
					num = 0;
				}
				else
				{
					__Error.WinIOError(hr, string.Empty);
				}
			}
			m_isMessageComplete = hr != 234;
			return num;
		}

		[SecurityCritical]
		[HostProtection(SecurityAction.LinkDemand, ExternalThreading = true)]
		public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException("buffer", SR.GetString("ArgumentNull_Buffer"));
			}
			if (offset < 0)
			{
				throw new ArgumentOutOfRangeException("offset", SR.GetString("ArgumentOutOfRange_NeedNonNegNum"));
			}
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count", SR.GetString("ArgumentOutOfRange_NeedNonNegNum"));
			}
			if (buffer.Length - offset < count)
			{
				throw new ArgumentException(SR.GetString("Argument_InvalidOffLen"));
			}
			if (!CanRead)
			{
				__Error.ReadNotSupported();
			}
			CheckReadOperations();
			if (!m_isAsync)
			{
				if (m_state == PipeState.Broken)
				{
					PipeStreamAsyncResult pipeStreamAsyncResult = new PipeStreamAsyncResult();
					pipeStreamAsyncResult._handle = m_handle;
					pipeStreamAsyncResult._userCallback = callback;
					pipeStreamAsyncResult._userStateObject = state;
					pipeStreamAsyncResult._isWrite = false;
					pipeStreamAsyncResult.CallUserCallback();
					return pipeStreamAsyncResult;
				}
				return base.BeginRead(buffer, offset, count, callback, state);
			}
			return BeginReadCore(buffer, offset, count, callback, state);
		}

		[SecurityCritical]
		private unsafe PipeStreamAsyncResult BeginReadCore(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
		{
			PipeStreamAsyncResult pipeStreamAsyncResult = new PipeStreamAsyncResult();
			pipeStreamAsyncResult._handle = m_handle;
			pipeStreamAsyncResult._userCallback = callback;
			pipeStreamAsyncResult._userStateObject = state;
			pipeStreamAsyncResult._isWrite = false;
			if (buffer.Length == 0)
			{
				pipeStreamAsyncResult.CallUserCallback();
			}
			else
			{
				ManualResetEvent manualResetEvent = (pipeStreamAsyncResult._waitHandle = new ManualResetEvent(initialState: false));
				Overlapped overlapped = new Overlapped(0, 0, IntPtr.Zero, pipeStreamAsyncResult);
				NativeOverlapped* ptr = (pipeStreamAsyncResult._overlapped = overlapped.Pack(IOCallback, buffer));
				int hr = 0;
				int num = ReadFileNative(m_handle, buffer, offset, count, ptr, out hr);
				if (num == -1)
				{
					switch (hr)
					{
					case 109:
					case 233:
						State = PipeState.Broken;
						ptr->InternalLow = IntPtr.Zero;
						pipeStreamAsyncResult.CallUserCallback();
						break;
					default:
						__Error.WinIOError(hr, string.Empty);
						break;
					case 997:
						break;
					}
				}
			}
			return pipeStreamAsyncResult;
		}

		[SecurityCritical]
		public unsafe override int EndRead(IAsyncResult asyncResult)
		{
			if (asyncResult == null)
			{
				throw new ArgumentNullException("asyncResult");
			}
			if (!m_isAsync)
			{
				return base.EndRead(asyncResult);
			}
			PipeStreamAsyncResult pipeStreamAsyncResult = asyncResult as PipeStreamAsyncResult;
			if (pipeStreamAsyncResult == null || pipeStreamAsyncResult._isWrite)
			{
				__Error.WrongAsyncResult();
			}
			if (1 == Interlocked.CompareExchange(ref pipeStreamAsyncResult._EndXxxCalled, 1, 0))
			{
				__Error.EndReadCalledTwice();
			}
			WaitHandle waitHandle = pipeStreamAsyncResult._waitHandle;
			if (waitHandle != null)
			{
				try
				{
					waitHandle.WaitOne();
				}
				finally
				{
					waitHandle.Close();
				}
			}
			NativeOverlapped* overlapped = pipeStreamAsyncResult._overlapped;
			if (overlapped != null)
			{
				Overlapped.Free(overlapped);
			}
			if (pipeStreamAsyncResult._errorCode != 0)
			{
				WinIOError(pipeStreamAsyncResult._errorCode);
			}
			m_isMessageComplete = m_state == PipeState.Broken || pipeStreamAsyncResult._isMessageComplete;
			return pipeStreamAsyncResult._numBytes;
		}

		[SecurityCritical]
		public override void Write(byte[] buffer, int offset, int count)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException("buffer", SR.GetString("ArgumentNull_Buffer"));
			}
			if (offset < 0)
			{
				throw new ArgumentOutOfRangeException("offset", SR.GetString("ArgumentOutOfRange_NeedNonNegNum"));
			}
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count", SR.GetString("ArgumentOutOfRange_NeedNonNegNum"));
			}
			if (buffer.Length - offset < count)
			{
				throw new ArgumentException(SR.GetString("Argument_InvalidOffLen"));
			}
			if (!CanWrite)
			{
				__Error.WriteNotSupported();
			}
			CheckWriteOperations();
			WriteCore(buffer, offset, count);
		}

		[SecurityCritical]
		private unsafe void WriteCore(byte[] buffer, int offset, int count)
		{
			if (m_isAsync)
			{
				IAsyncResult asyncResult = BeginWriteCore(buffer, offset, count, null, null);
				EndWrite(asyncResult);
				return;
			}
			int hr = 0;
			int num = WriteFileNative(m_handle, buffer, offset, count, null, out hr);
			if (num == -1)
			{
				WinIOError(hr);
			}
		}

		[SecurityCritical]
		[HostProtection(SecurityAction.LinkDemand, ExternalThreading = true)]
		public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException("buffer", SR.GetString("ArgumentNull_Buffer"));
			}
			if (offset < 0)
			{
				throw new ArgumentOutOfRangeException("offset", SR.GetString("ArgumentOutOfRange_NeedNonNegNum"));
			}
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count", SR.GetString("ArgumentOutOfRange_NeedNonNegNum"));
			}
			if (buffer.Length - offset < count)
			{
				throw new ArgumentException(SR.GetString("Argument_InvalidOffLen"));
			}
			if (!CanWrite)
			{
				__Error.WriteNotSupported();
			}
			CheckWriteOperations();
			if (!m_isAsync)
			{
				return base.BeginWrite(buffer, offset, count, callback, state);
			}
			return BeginWriteCore(buffer, offset, count, callback, state);
		}

		[SecurityCritical]
		private unsafe PipeStreamAsyncResult BeginWriteCore(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
		{
			PipeStreamAsyncResult pipeStreamAsyncResult = new PipeStreamAsyncResult();
			pipeStreamAsyncResult._userCallback = callback;
			pipeStreamAsyncResult._userStateObject = state;
			pipeStreamAsyncResult._isWrite = true;
			pipeStreamAsyncResult._handle = m_handle;
			if (buffer.Length == 0)
			{
				pipeStreamAsyncResult.CallUserCallback();
			}
			else
			{
				ManualResetEvent manualResetEvent = (pipeStreamAsyncResult._waitHandle = new ManualResetEvent(initialState: false));
				Overlapped overlapped = new Overlapped(0, 0, IntPtr.Zero, pipeStreamAsyncResult);
				NativeOverlapped* ptr = (pipeStreamAsyncResult._overlapped = overlapped.Pack(IOCallback, buffer));
				int hr = 0;
				int num = WriteFileNative(m_handle, buffer, offset, count, ptr, out hr);
				if (num == -1 && hr != 997)
				{
					if (ptr != null)
					{
						Overlapped.Free(ptr);
					}
					WinIOError(hr);
				}
			}
			return pipeStreamAsyncResult;
		}

		[SecurityCritical]
		public unsafe override void EndWrite(IAsyncResult asyncResult)
		{
			if (asyncResult == null)
			{
				throw new ArgumentNullException("asyncResult");
			}
			if (!m_isAsync)
			{
				base.EndWrite(asyncResult);
				return;
			}
			PipeStreamAsyncResult pipeStreamAsyncResult = asyncResult as PipeStreamAsyncResult;
			if (pipeStreamAsyncResult == null || !pipeStreamAsyncResult._isWrite)
			{
				__Error.WrongAsyncResult();
			}
			if (1 == Interlocked.CompareExchange(ref pipeStreamAsyncResult._EndXxxCalled, 1, 0))
			{
				__Error.EndWriteCalledTwice();
			}
			WaitHandle waitHandle = pipeStreamAsyncResult._waitHandle;
			if (waitHandle != null)
			{
				try
				{
					waitHandle.WaitOne();
				}
				finally
				{
					waitHandle.Close();
				}
			}
			NativeOverlapped* overlapped = pipeStreamAsyncResult._overlapped;
			if (overlapped != null)
			{
				Overlapped.Free(overlapped);
			}
			if (pipeStreamAsyncResult._errorCode != 0)
			{
				WinIOError(pipeStreamAsyncResult._errorCode);
			}
		}

		[SecurityCritical]
		private unsafe int ReadFileNative(SafePipeHandle handle, byte[] buffer, int offset, int count, NativeOverlapped* overlapped, out int hr)
		{
			if (buffer.Length == 0)
			{
				hr = 0;
				return 0;
			}
			int num = 0;
			int numBytesRead = 0;
			fixed (byte* ptr = buffer)
			{
				num = ((!m_isAsync) ? Microsoft.Win32.UnsafeNativeMethods.ReadFile(handle, ptr + offset, count, out numBytesRead, IntPtr.Zero) : Microsoft.Win32.UnsafeNativeMethods.ReadFile(handle, ptr + offset, count, IntPtr.Zero, overlapped));
			}
			if (num == 0)
			{
				hr = Marshal.GetLastWin32Error();
				if (hr == 234)
				{
					return numBytesRead;
				}
				return -1;
			}
			hr = 0;
			return numBytesRead;
		}

		[SecurityCritical]
		private unsafe int WriteFileNative(SafePipeHandle handle, byte[] buffer, int offset, int count, NativeOverlapped* overlapped, out int hr)
		{
			if (buffer.Length == 0)
			{
				hr = 0;
				return 0;
			}
			int numBytesWritten = 0;
			int num = 0;
			fixed (byte* ptr = buffer)
			{
				num = ((!m_isAsync) ? Microsoft.Win32.UnsafeNativeMethods.WriteFile(handle, ptr + offset, count, out numBytesWritten, IntPtr.Zero) : Microsoft.Win32.UnsafeNativeMethods.WriteFile(handle, ptr + offset, count, IntPtr.Zero, overlapped));
			}
			if (num == 0)
			{
				hr = Marshal.GetLastWin32Error();
				return -1;
			}
			hr = 0;
			return numBytesWritten;
		}

		[SecurityCritical]
		public override int ReadByte()
		{
			CheckReadOperations();
			if (!CanRead)
			{
				__Error.ReadNotSupported();
			}
			byte[] array = new byte[1];
			if (ReadCore(array, 0, 1) == 0)
			{
				return -1;
			}
			return array[0];
		}

		[SecurityCritical]
		public override void WriteByte(byte value)
		{
			CheckWriteOperations();
			if (!CanWrite)
			{
				__Error.WriteNotSupported();
			}
			WriteCore(new byte[1] { value }, 0, 1);
		}

		[SecurityCritical]
		public override void Flush()
		{
			CheckWriteOperations();
			if (!CanWrite)
			{
				__Error.WriteNotSupported();
			}
		}

		[SecurityCritical]
		public void WaitForPipeDrain()
		{
			CheckWriteOperations();
			if (!CanWrite)
			{
				__Error.WriteNotSupported();
			}
			if (!Microsoft.Win32.UnsafeNativeMethods.FlushFileBuffers(m_handle))
			{
				WinIOError(Marshal.GetLastWin32Error());
			}
		}

		[SecurityCritical]
		protected override void Dispose(bool disposing)
		{
			try
			{
				if (m_handle != null && !m_handle.IsClosed)
				{
					m_handle.Dispose();
				}
			}
			finally
			{
				base.Dispose(disposing);
			}
			m_state = PipeState.Closed;
		}

		[SecurityCritical]
		private void UpdateReadMode()
		{
			if (!Microsoft.Win32.UnsafeNativeMethods.GetNamedPipeHandleState(SafePipeHandle, out var lpState, Microsoft.Win32.UnsafeNativeMethods.NULL, Microsoft.Win32.UnsafeNativeMethods.NULL, Microsoft.Win32.UnsafeNativeMethods.NULL, Microsoft.Win32.UnsafeNativeMethods.NULL, 0))
			{
				WinIOError(Marshal.GetLastWin32Error());
			}
			if (((uint)lpState & 2u) != 0)
			{
				m_readMode = PipeTransmissionMode.Message;
			}
			else
			{
				m_readMode = PipeTransmissionMode.Byte;
			}
		}

		[SecurityCritical]
		public PipeSecurity GetAccessControl()
		{
			if (m_state == PipeState.Closed)
			{
				__Error.PipeNotOpen();
			}
			if (m_handle == null)
			{
				throw new InvalidOperationException(SR.GetString("InvalidOperation_PipeHandleNotSet"));
			}
			if (m_handle.IsClosed)
			{
				__Error.PipeNotOpen();
			}
			return new PipeSecurity(m_handle, AccessControlSections.Access | AccessControlSections.Owner | AccessControlSections.Group);
		}

		[SecurityCritical]
		public void SetAccessControl(PipeSecurity pipeSecurity)
		{
			if (pipeSecurity == null)
			{
				throw new ArgumentNullException("pipeSecurity");
			}
			CheckPipePropertyOperations();
			pipeSecurity.Persist(m_handle);
		}

		public override void SetLength(long value)
		{
			__Error.SeekNotSupported();
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			__Error.SeekNotSupported();
			return 0L;
		}

		[SecurityCritical]
		protected internal virtual void CheckPipePropertyOperations()
		{
			if (m_handle == null)
			{
				throw new InvalidOperationException(SR.GetString("InvalidOperation_PipeHandleNotSet"));
			}
			if (m_state == PipeState.Closed)
			{
				__Error.PipeNotOpen();
			}
			if (m_handle.IsClosed)
			{
				__Error.PipeNotOpen();
			}
		}

		[SecurityCritical]
		protected internal void CheckReadOperations()
		{
			if (m_state == PipeState.WaitingToConnect)
			{
				throw new InvalidOperationException(SR.GetString("InvalidOperation_PipeNotYetConnected"));
			}
			if (m_state == PipeState.Disconnected)
			{
				throw new InvalidOperationException(SR.GetString("InvalidOperation_PipeDisconnected"));
			}
			if (m_handle == null)
			{
				throw new InvalidOperationException(SR.GetString("InvalidOperation_PipeHandleNotSet"));
			}
			if (m_state == PipeState.Closed)
			{
				__Error.PipeNotOpen();
			}
			if (m_handle.IsClosed)
			{
				__Error.PipeNotOpen();
			}
		}

		[SecurityCritical]
		protected internal void CheckWriteOperations()
		{
			if (m_state == PipeState.WaitingToConnect)
			{
				throw new InvalidOperationException(SR.GetString("InvalidOperation_PipeNotYetConnected"));
			}
			if (m_state == PipeState.Disconnected)
			{
				throw new InvalidOperationException(SR.GetString("InvalidOperation_PipeDisconnected"));
			}
			if (m_handle == null)
			{
				throw new InvalidOperationException(SR.GetString("InvalidOperation_PipeHandleNotSet"));
			}
			if (m_state == PipeState.Broken)
			{
				throw new IOException(SR.GetString("IO_IO_PipeBroken"));
			}
			if (m_state == PipeState.Closed)
			{
				__Error.PipeNotOpen();
			}
			if (m_handle.IsClosed)
			{
				__Error.PipeNotOpen();
			}
		}

		[SecurityCritical]
		internal void WinIOError(int errorCode)
		{
			switch (errorCode)
			{
			case 109:
			case 232:
			case 233:
				m_state = PipeState.Broken;
				throw new IOException(SR.GetString("IO_IO_PipeBroken"), Microsoft.Win32.UnsafeNativeMethods.MakeHRFromErrorCode(errorCode));
			case 38:
				__Error.EndOfFile();
				return;
			case 6:
				m_handle.SetHandleAsInvalid();
				m_state = PipeState.Broken;
				break;
			}
			__Error.WinIOError(errorCode, string.Empty);
		}

		[SecurityCritical]
		internal unsafe static Microsoft.Win32.UnsafeNativeMethods.SECURITY_ATTRIBUTES GetSecAttrs(HandleInheritability inheritability, PipeSecurity pipeSecurity, out object pinningHandle)
		{
			pinningHandle = null;
			Microsoft.Win32.UnsafeNativeMethods.SECURITY_ATTRIBUTES sECURITY_ATTRIBUTES = null;
			if ((inheritability & HandleInheritability.Inheritable) != 0 || pipeSecurity != null)
			{
				sECURITY_ATTRIBUTES = new Microsoft.Win32.UnsafeNativeMethods.SECURITY_ATTRIBUTES();
				sECURITY_ATTRIBUTES.nLength = Marshal.SizeOf(sECURITY_ATTRIBUTES);
				if ((inheritability & HandleInheritability.Inheritable) != 0)
				{
					sECURITY_ATTRIBUTES.bInheritHandle = 1;
				}
				if (pipeSecurity != null)
				{
					byte[] securityDescriptorBinaryForm = pipeSecurity.GetSecurityDescriptorBinaryForm();
					pinningHandle = GCHandle.Alloc(securityDescriptorBinaryForm, GCHandleType.Pinned);
					fixed (byte* pSecurityDescriptor = securityDescriptorBinaryForm)
					{
						sECURITY_ATTRIBUTES.pSecurityDescriptor = pSecurityDescriptor;
					}
				}
			}
			return sECURITY_ATTRIBUTES;
		}

		[SecurityCritical]
		internal static Microsoft.Win32.UnsafeNativeMethods.SECURITY_ATTRIBUTES GetSecAttrs(HandleInheritability inheritability)
		{
			Microsoft.Win32.UnsafeNativeMethods.SECURITY_ATTRIBUTES sECURITY_ATTRIBUTES = null;
			if ((inheritability & HandleInheritability.Inheritable) != 0)
			{
				sECURITY_ATTRIBUTES = new Microsoft.Win32.UnsafeNativeMethods.SECURITY_ATTRIBUTES();
				sECURITY_ATTRIBUTES.nLength = Marshal.SizeOf(sECURITY_ATTRIBUTES);
				sECURITY_ATTRIBUTES.bInheritHandle = 1;
			}
			return sECURITY_ATTRIBUTES;
		}

		[SecurityCritical]
		private unsafe static void AsyncPSCallback(uint errorCode, uint numBytes, NativeOverlapped* pOverlapped)
		{
			Overlapped overlapped = Overlapped.Unpack(pOverlapped);
			PipeStreamAsyncResult pipeStreamAsyncResult = (PipeStreamAsyncResult)overlapped.AsyncResult;
			pipeStreamAsyncResult._numBytes = (int)numBytes;
			if (!pipeStreamAsyncResult._isWrite && (errorCode == 109 || errorCode == 233 || errorCode == 232))
			{
				errorCode = 0u;
				numBytes = 0u;
			}
			if (errorCode == 234)
			{
				errorCode = 0u;
				pipeStreamAsyncResult._isMessageComplete = false;
			}
			else
			{
				pipeStreamAsyncResult._isMessageComplete = true;
			}
			pipeStreamAsyncResult._errorCode = (int)errorCode;
			pipeStreamAsyncResult._completedSynchronously = false;
			pipeStreamAsyncResult._isComplete = true;
			ManualResetEvent waitHandle = pipeStreamAsyncResult._waitHandle;
			if (waitHandle != null && !waitHandle.Set())
			{
				__Error.WinIOError();
			}
			pipeStreamAsyncResult._userCallback?.Invoke(pipeStreamAsyncResult);
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class AnonymousPipeServerStream : PipeStream
	{
		private SafePipeHandle m_clientHandle;

		private bool m_clientHandleExposed;

		public SafePipeHandle ClientSafePipeHandle
		{
			[SecurityCritical]
			get
			{
				m_clientHandleExposed = true;
				return m_clientHandle;
			}
		}

		public override PipeTransmissionMode TransmissionMode
		{
			[SecurityCritical]
			get
			{
				return PipeTransmissionMode.Byte;
			}
		}

		public override PipeTransmissionMode ReadMode
		{
			[SecurityCritical]
			set
			{
				CheckPipePropertyOperations();
				switch (value)
				{
				default:
					throw new ArgumentOutOfRangeException("value", SR.GetString("ArgumentOutOfRange_TransmissionModeByteOrMsg"));
				case PipeTransmissionMode.Message:
					throw new NotSupportedException(SR.GetString("NotSupported_AnonymousPipeMessagesNotSupported"));
				case PipeTransmissionMode.Byte:
					break;
				}
			}
		}

		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		public AnonymousPipeServerStream()
			: this(PipeDirection.Out, HandleInheritability.None, 0, null)
		{
		}

		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		public AnonymousPipeServerStream(PipeDirection direction)
			: this(direction, HandleInheritability.None, 0)
		{
		}

		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		public AnonymousPipeServerStream(PipeDirection direction, HandleInheritability inheritability)
			: this(direction, inheritability, 0)
		{
		}

		[SecurityCritical]
		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		public AnonymousPipeServerStream(PipeDirection direction, HandleInheritability inheritability, int bufferSize)
			: base(direction, bufferSize)
		{
			if (direction == PipeDirection.InOut)
			{
				throw new NotSupportedException(SR.GetString("NotSupported_AnonymousPipeUnidirectional"));
			}
			if (inheritability < HandleInheritability.None || inheritability > HandleInheritability.Inheritable)
			{
				throw new ArgumentOutOfRangeException("inheritability", SR.GetString("ArgumentOutOfRange_HandleInheritabilityNoneOrInheritable"));
			}
			Microsoft.Win32.UnsafeNativeMethods.SECURITY_ATTRIBUTES secAttrs = PipeStream.GetSecAttrs(inheritability);
			Create(direction, secAttrs, bufferSize);
		}

		[SecurityCritical]
		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		public AnonymousPipeServerStream(PipeDirection direction, HandleInheritability inheritability, int bufferSize, PipeSecurity pipeSecurity)
			: base(direction, bufferSize)
		{
			if (direction == PipeDirection.InOut)
			{
				throw new NotSupportedException(SR.GetString("NotSupported_AnonymousPipeUnidirectional"));
			}
			if (inheritability < HandleInheritability.None || inheritability > HandleInheritability.Inheritable)
			{
				throw new ArgumentOutOfRangeException("inheritability", SR.GetString("ArgumentOutOfRange_HandleInheritabilityNoneOrInheritable"));
			}
			object pinningHandle;
			Microsoft.Win32.UnsafeNativeMethods.SECURITY_ATTRIBUTES secAttrs = PipeStream.GetSecAttrs(inheritability, pipeSecurity, out pinningHandle);
			try
			{
				Create(direction, secAttrs, bufferSize);
			}
			finally
			{
				if (pinningHandle != null)
				{
					((GCHandle)pinningHandle).Free();
				}
			}
		}

		~AnonymousPipeServerStream()
		{
			Dispose(disposing: false);
		}

		[SecurityCritical]
		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		public AnonymousPipeServerStream(PipeDirection direction, SafePipeHandle serverSafePipeHandle, SafePipeHandle clientSafePipeHandle)
			: base(direction, 0)
		{
			if (direction == PipeDirection.InOut)
			{
				throw new NotSupportedException(SR.GetString("NotSupported_AnonymousPipeUnidirectional"));
			}
			if (Microsoft.Win32.UnsafeNativeMethods.GetFileType(serverSafePipeHandle) != 3)
			{
				throw new IOException(SR.GetString("IO_IO_InvalidPipeHandle"));
			}
			if (Microsoft.Win32.UnsafeNativeMethods.GetFileType(clientSafePipeHandle) != 3)
			{
				throw new IOException(SR.GetString("IO_IO_InvalidPipeHandle"));
			}
			InitializeHandle(serverSafePipeHandle, isExposed: true, isAsync: false);
			m_clientHandle = clientSafePipeHandle;
			m_clientHandleExposed = true;
			base.State = PipeState.Connected;
		}

		[SecurityCritical]
		public string GetClientHandleAsString()
		{
			m_clientHandleExposed = true;
			return m_clientHandle.DangerousGetHandle().ToString();
		}

		[SecurityCritical]
		public void DisposeLocalCopyOfClientHandle()
		{
			if (m_clientHandle != null && !m_clientHandle.IsClosed)
			{
				m_clientHandle.Dispose();
			}
		}

		[SecurityCritical]
		protected override void Dispose(bool disposing)
		{
			try
			{
				if (!m_clientHandleExposed && m_clientHandle != null && !m_clientHandle.IsClosed)
				{
					m_clientHandle.Dispose();
				}
			}
			finally
			{
				base.Dispose(disposing);
			}
		}

		[SecurityCritical]
		private void Create(PipeDirection direction, Microsoft.Win32.UnsafeNativeMethods.SECURITY_ATTRIBUTES secAttrs, int bufferSize)
		{
			if (!((direction != PipeDirection.In) ? Microsoft.Win32.UnsafeNativeMethods.CreatePipe(out m_clientHandle, out var hReadPipe, secAttrs, bufferSize) : Microsoft.Win32.UnsafeNativeMethods.CreatePipe(out hReadPipe, out m_clientHandle, secAttrs, bufferSize)))
			{
				__Error.WinIOError(Marshal.GetLastWin32Error(), string.Empty);
			}
			if (!Microsoft.Win32.UnsafeNativeMethods.DuplicateHandle(Microsoft.Win32.UnsafeNativeMethods.GetCurrentProcess(), hReadPipe, Microsoft.Win32.UnsafeNativeMethods.GetCurrentProcess(), out var lpTargetHandle, 0u, bInheritHandle: false, 2u))
			{
				__Error.WinIOError(Marshal.GetLastWin32Error(), string.Empty);
			}
			hReadPipe.Dispose();
			InitializeHandle(lpTargetHandle, isExposed: false, isAsync: false);
			base.State = PipeState.Connected;
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class AnonymousPipeClientStream : PipeStream
	{
		public override PipeTransmissionMode TransmissionMode
		{
			[SecurityCritical]
			get
			{
				return PipeTransmissionMode.Byte;
			}
		}

		public override PipeTransmissionMode ReadMode
		{
			[SecurityCritical]
			set
			{
				CheckPipePropertyOperations();
				switch (value)
				{
				default:
					throw new ArgumentOutOfRangeException("value", SR.GetString("ArgumentOutOfRange_TransmissionModeByteOrMsg"));
				case PipeTransmissionMode.Message:
					throw new NotSupportedException(SR.GetString("NotSupported_AnonymousPipeMessagesNotSupported"));
				case PipeTransmissionMode.Byte:
					break;
				}
			}
		}

		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		public AnonymousPipeClientStream(string pipeHandleAsString)
			: this(PipeDirection.In, pipeHandleAsString)
		{
		}

		[SecurityCritical]
		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		public AnonymousPipeClientStream(PipeDirection direction, string pipeHandleAsString)
			: this(direction, new SafePipeHandle((IntPtr)long.Parse(pipeHandleAsString), ownsHandle: true))
		{
		}

		[SecurityCritical]
		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		public AnonymousPipeClientStream(PipeDirection direction, SafePipeHandle safePipeHandle)
			: base(direction, 0)
		{
			if (direction == PipeDirection.InOut)
			{
				throw new NotSupportedException(SR.GetString("NotSupported_AnonymousPipeUnidirectional"));
			}
			if (Microsoft.Win32.UnsafeNativeMethods.GetFileType(safePipeHandle) != 3)
			{
				throw new IOException(SR.GetString("IO_IO_InvalidPipeHandle"));
			}
			InitializeHandle(safePipeHandle, isExposed: true, isAsync: false);
			base.State = PipeState.Connected;
		}

		~AnonymousPipeClientStream()
		{
			Dispose(disposing: false);
		}
	}
	public delegate void PipeStreamImpersonationWorker();
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class NamedPipeServerStream : PipeStream
	{
		internal class ExecuteHelper
		{
			internal PipeStreamImpersonationWorker m_userCode;

			internal SafePipeHandle m_handle;

			internal bool m_mustRevert;

			internal int m_impersonateErrorCode;

			internal int m_revertImpersonateErrorCode;

			[SecurityCritical]
			internal ExecuteHelper(PipeStreamImpersonationWorker userCode, SafePipeHandle handle)
			{
				m_userCode = userCode;
				m_handle = handle;
			}
		}

		public const int MaxAllowedServerInstances = -1;

		private static int s_maxUsernameLength;

		private static readonly IOCompletionCallback WaitForConnectionCallback;

		private static RuntimeHelpers.TryCode tryCode;

		private static RuntimeHelpers.CleanupCode cleanupCode;

		[SecurityCritical]
		static unsafe NamedPipeServerStream()
		{
			s_maxUsernameLength = 20;
			WaitForConnectionCallback = AsyncWaitForConnectionCallback;
			tryCode = ImpersonateAndTryCode;
			cleanupCode = RevertImpersonationOnBackout;
		}

		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		public NamedPipeServerStream(string pipeName)
			: this(pipeName, PipeDirection.InOut, 1, PipeTransmissionMode.Byte, PipeOptions.None, 0, 0, null, HandleInheritability.None, (PipeAccessRights)0)
		{
		}

		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		public NamedPipeServerStream(string pipeName, PipeDirection direction)
			: this(pipeName, direction, 1, PipeTransmissionMode.Byte, PipeOptions.None, 0, 0, null, HandleInheritability.None, (PipeAccessRights)0)
		{
		}

		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		public NamedPipeServerStream(string pipeName, PipeDirection direction, int maxNumberOfServerInstances)
			: this(pipeName, direction, maxNumberOfServerInstances, PipeTransmissionMode.Byte, PipeOptions.None, 0, 0, null, HandleInheritability.None, (PipeAccessRights)0)
		{
		}

		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		public NamedPipeServerStream(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode)
			: this(pipeName, direction, maxNumberOfServerInstances, transmissionMode, PipeOptions.None, 0, 0, null, HandleInheritability.None, (PipeAccessRights)0)
		{
		}

		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		public NamedPipeServerStream(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options)
			: this(pipeName, direction, maxNumberOfServerInstances, transmissionMode, options, 0, 0, null, HandleInheritability.None, (PipeAccessRights)0)
		{
		}

		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		public NamedPipeServerStream(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options, int inBufferSize, int outBufferSize)
			: this(pipeName, direction, maxNumberOfServerInstances, transmissionMode, options, inBufferSize, outBufferSize, null, HandleInheritability.None, (PipeAccessRights)0)
		{
		}

		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		public NamedPipeServerStream(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options, int inBufferSize, int outBufferSize, PipeSecurity pipeSecurity)
			: this(pipeName, direction, maxNumberOfServerInstances, transmissionMode, options, inBufferSize, outBufferSize, pipeSecurity, HandleInheritability.None, (PipeAccessRights)0)
		{
		}

		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		public NamedPipeServerStream(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options, int inBufferSize, int outBufferSize, PipeSecurity pipeSecurity, HandleInheritability inheritability)
			: this(pipeName, direction, maxNumberOfServerInstances, transmissionMode, options, inBufferSize, outBufferSize, pipeSecurity, inheritability, (PipeAccessRights)0)
		{
		}

		[SecurityCritical]
		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		public NamedPipeServerStream(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options, int inBufferSize, int outBufferSize, PipeSecurity pipeSecurity, HandleInheritability inheritability, PipeAccessRights additionalAccessRights)
			: base(direction, transmissionMode, outBufferSize)
		{
			if (pipeName == null)
			{
				throw new ArgumentNullException("pipeName");
			}
			if (pipeName.Length == 0)
			{
				throw new ArgumentException(SR.GetString("Argument_NeedNonemptyPipeName"));
			}
			if ((options & (PipeOptions)1073741823) != 0)
			{
				throw new ArgumentOutOfRangeException("options", SR.GetString("ArgumentOutOfRange_OptionsInvalid"));
			}
			if (inBufferSize < 0)
			{
				throw new ArgumentOutOfRangeException("inBufferSize", SR.GetString("ArgumentOutOfRange_NeedNonNegNum"));
			}
			if ((maxNumberOfServerInstances < 1 || maxNumberOfServerInstances > 254) && maxNumberOfServerInstances != -1)
			{
				throw new ArgumentOutOfRangeException("maxNumberOfServerInstances", SR.GetString("ArgumentOutOfRange_MaxNumServerInstances"));
			}
			if (inheritability < HandleInheritability.None || inheritability > HandleInheritability.Inheritable)
			{
				throw new ArgumentOutOfRangeException("inheritability", SR.GetString("ArgumentOutOfRange_HandleInheritabilityNoneOrInheritable"));
			}
			if (((uint)additionalAccessRights & 0xFEF3FFFFu) != 0)
			{
				throw new ArgumentOutOfRangeException("additionalAccessRights", SR.GetString("ArgumentOutOfRange_AdditionalAccessLimited"));
			}
			if (Environment.OSVersion.Platform == PlatformID.Win32Windows)
			{
				throw new PlatformNotSupportedException(SR.GetString("PlatformNotSupported_NamedPipeServers"));
			}
			string fullPath = Path.GetFullPath("\\\\.\\pipe\\" + pipeName);
			if (string.Compare(fullPath, "\\\\.\\pipe\\anonymous", StringComparison.OrdinalIgnoreCase) == 0)
			{
				throw new ArgumentOutOfRangeException("pipeName", SR.GetString("ArgumentOutOfRange_AnonymousReserved"));
			}
			object pinningHandle = null;
			Microsoft.Win32.UnsafeNativeMethods.SECURITY_ATTRIBUTES secAttrs = PipeStream.GetSecAttrs(inheritability, pipeSecurity, out pinningHandle);
			try
			{
				Create(fullPath, direction, maxNumberOfServerInstances, transmissionMode, options, inBufferSize, outBufferSize, additionalAccessRights, secAttrs);
			}
			finally
			{
				if (pinningHandle != null)
				{
					((GCHandle)pinningHandle).Free();
				}
			}
		}

		[SecurityCritical]
		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		public NamedPipeServerStream(PipeDirection direction, bool isAsync, bool isConnected, SafePipeHandle safePipeHandle)
			: base(direction, PipeTransmissionMode.Byte, 0)
		{
			if (Microsoft.Win32.UnsafeNativeMethods.GetFileType(safePipeHandle) != 3)
			{
				throw new IOException(SR.GetString("Pipe_InvalidHandle"));
			}
			InitializeHandle(safePipeHandle, isExposed: true, isAsync);
			if (isConnected)
			{
				base.State = PipeState.Connected;
			}
		}

		~NamedPipeServerStream()
		{
			Dispose(disposing: false);
		}

		[SecurityCritical]
		private void Create(string fullPipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options, int inBufferSize, int outBufferSize, PipeAccessRights rights, Microsoft.Win32.UnsafeNativeMethods.SECURITY_ATTRIBUTES secAttrs)
		{
			int openMode = (int)direction | ((maxNumberOfServerInstances == 1) ? 524288 : 0) | (int)options | (int)rights;
			int pipeMode = ((int)transmissionMode << 2) | ((int)transmissionMode << 1);
			if (maxNumberOfServerInstances == -1)
			{
				maxNumberOfServerInstances = 255;
			}
			SafePipeHandle safePipeHandle = Microsoft.Win32.UnsafeNativeMethods.CreateNamedPipe(fullPipeName, openMode, pipeMode, maxNumberOfServerInstances, outBufferSize, inBufferSize, 0, secAttrs);
			if (safePipeHandle.IsInvalid)
			{
				__Error.WinIOError(Marshal.GetLastWin32Error(), string.Empty);
			}
			InitializeHandle(safePipeHandle, isExposed: false, (options & PipeOptions.Asynchronous) != 0);
		}

		[SecurityCritical]
		public void WaitForConnection()
		{
			CheckConnectOperationsServer();
			if (base.IsAsync)
			{
				IAsyncResult asyncResult = BeginWaitForConnection(null, null);
				EndWaitForConnection(asyncResult);
				return;
			}
			if (!Microsoft.Win32.UnsafeNativeMethods.ConnectNamedPipe(base.InternalHandle, Microsoft.Win32.UnsafeNativeMethods.NULL))
			{
				int lastWin32Error = Marshal.GetLastWin32Error();
				if (lastWin32Error != 535)
				{
					__Error.WinIOError(lastWin32Error, string.Empty);
				}
				if (lastWin32Error == 535 && base.State == PipeState.Connected)
				{
					throw new InvalidOperationException(SR.GetString("InvalidOperation_PipeAlreadyConnected"));
				}
			}
			base.State = PipeState.Connected;
		}

		[SecurityCritical]
		[HostProtection(SecurityAction.LinkDemand, ExternalThreading = true)]
		public unsafe IAsyncResult BeginWaitForConnection(AsyncCallback callback, object state)
		{
			CheckConnectOperationsServer();
			if (!base.IsAsync)
			{
				throw new InvalidOperationException(SR.GetString("InvalidOperation_PipeNotAsync"));
			}
			PipeAsyncResult pipeAsyncResult = new PipeAsyncResult();
			pipeAsyncResult._handle = base.InternalHandle;
			pipeAsyncResult._userCallback = callback;
			pipeAsyncResult._userStateObject = state;
			ManualResetEvent manualResetEvent = (pipeAsyncResult._waitHandle = new ManualResetEvent(initialState: false));
			Overlapped overlapped = new Overlapped(0, 0, IntPtr.Zero, pipeAsyncResult);
			NativeOverlapped* ptr = (pipeAsyncResult._overlapped = overlapped.Pack(WaitForConnectionCallback, null));
			if (!Microsoft.Win32.UnsafeNativeMethods.ConnectNamedPipe(base.InternalHandle, ptr))
			{
				int lastWin32Error = Marshal.GetLastWin32Error();
				switch (lastWin32Error)
				{
				case 535:
					ptr->InternalLow = IntPtr.Zero;
					if (base.State == PipeState.Connected)
					{
						throw new InvalidOperationException(SR.GetString("InvalidOperation_PipeAlreadyConnected"));
					}
					pipeAsyncResult.CallUserCallback();
					break;
				default:
					__Error.WinIOError(lastWin32Error, string.Empty);
					break;
				case 997:
					break;
				}
			}
			return pipeAsyncResult;
		}

		[SecurityCritical]
		public unsafe void EndWaitForConnection(IAsyncResult asyncResult)
		{
			CheckConnectOperationsServer();
			if (asyncResult == null)
			{
				throw new ArgumentNullException("asyncResult");
			}
			if (!base.IsAsync)
			{
				throw new InvalidOperationException(SR.GetString("InvalidOperation_PipeNotAsync"));
			}
			PipeAsyncResult pipeAsyncResult = asyncResult as PipeAsyncResult;
			if (pipeAsyncResult == null)
			{
				__Error.WrongAsyncResult();
			}
			if (1 == Interlocked.CompareExchange(ref pipeAsyncResult._EndXxxCalled, 1, 0))
			{
				__Error.EndWaitForConnectionCalledTwice();
			}
			WaitHandle waitHandle = pipeAsyncResult._waitHandle;
			if (waitHandle != null)
			{
				try
				{
					waitHandle.WaitOne();
				}
				finally
				{
					waitHandle.Close();
				}
			}
			NativeOverlapped* overlapped = pipeAsyncResult._overlapped;
			if (overlapped != null)
			{
				Overlapped.Free(overlapped);
			}
			if (pipeAsyncResult._errorCode != 0)
			{
				__Error.WinIOError(pipeAsyncResult._errorCode, string.Empty);
			}
			base.State = PipeState.Connected;
		}

		[SecurityCritical]
		public void Disconnect()
		{
			CheckDisconnectOperations();
			if (!Microsoft.Win32.UnsafeNativeMethods.DisconnectNamedPipe(base.InternalHandle))
			{
				__Error.WinIOError(Marshal.GetLastWin32Error(), string.Empty);
			}
			base.State = PipeState.Disconnected;
		}

		[SecurityCritical]
		[SecurityPermission(SecurityAction.Demand, Flags = SecurityPermissionFlag.ControlPrincipal)]
		public void RunAsClient(PipeStreamImpersonationWorker impersonationWorker)
		{
			CheckWriteOperations();
			ExecuteHelper executeHelper = new ExecuteHelper(impersonationWorker, base.InternalHandle);
			RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(tryCode, cleanupCode, executeHelper);
			if (executeHelper.m_impersonateErrorCode != 0)
			{
				WinIOError(executeHelper.m_impersonateErrorCode);
			}
			else if (executeHelper.m_revertImpersonateErrorCode != 0)
			{
				WinIOError(executeHelper.m_revertImpersonateErrorCode);
			}
		}

		[SecurityCritical]
		private static void ImpersonateAndTryCode(object helper)
		{
			ExecuteHelper executeHelper = (ExecuteHelper)helper;
			RuntimeHelpers.PrepareConstrainedRegions();
			try
			{
			}
			finally
			{
				if (Microsoft.Win32.UnsafeNativeMethods.ImpersonateNamedPipeClient(executeHelper.m_handle))
				{
					executeHelper.m_mustRevert = true;
				}
				else
				{
					executeHelper.m_impersonateErrorCode = Marshal.GetLastWin32Error();
				}
			}
			if (executeHelper.m_mustRevert)
			{
				executeHelper.m_userCode();
			}
		}

		[SecurityCritical]
		[PrePrepareMethod]
		private static void RevertImpersonationOnBackout(object helper, bool exceptionThrown)
		{
			ExecuteHelper executeHelper = (ExecuteHelper)helper;
			if (executeHelper.m_mustRevert && !Microsoft.Win32.UnsafeNativeMethods.RevertToSelf())
			{
				executeHelper.m_revertImpersonateErrorCode = Marshal.GetLastWin32Error();
			}
		}

		[SecurityCritical]
		[SecurityPermission(SecurityAction.Demand, Flags = SecurityPermissionFlag.ControlPrincipal)]
		public string GetImpersonationUserName()
		{
			CheckWriteOperations();
			StringBuilder stringBuilder = new StringBuilder(s_maxUsernameLength);
			if (!Microsoft.Win32.UnsafeNativeMethods.GetNamedPipeHandleState(base.InternalHandle, Microsoft.Win32.UnsafeNativeMethods.NULL, Microsoft.Win32.UnsafeNativeMethods.NULL, Microsoft.Win32.UnsafeNativeMethods.NULL, Microsoft.Win32.UnsafeNativeMethods.NULL, stringBuilder, s_maxUsernameLength))
			{
				WinIOError(Marshal.GetLastWin32Error());
			}
			return stringBuilder.ToString();
		}

		[SecurityCritical]
		private unsafe static void AsyncWaitForConnectionCallback(uint errorCode, uint numBytes, NativeOverlapped* pOverlapped)
		{
			Overlapped overlapped = Overlapped.Unpack(pOverlapped);
			PipeAsyncResult pipeAsyncResult = (PipeAsyncResult)overlapped.AsyncResult;
			if (errorCode == 535)
			{
				errorCode = 0u;
			}
			pipeAsyncResult._errorCode = (int)errorCode;
			pipeAsyncResult._completedSynchronously = false;
			pipeAsyncResult._isComplete = true;
			ManualResetEvent waitHandle = pipeAsyncResult._waitHandle;
			if (waitHandle != null && !waitHandle.Set())
			{
				__Error.WinIOError();
			}
			pipeAsyncResult._userCallback?.Invoke(pipeAsyncResult);
		}

		[SecurityCritical]
		private void CheckConnectOperationsServer()
		{
			if (base.InternalHandle == null)
			{
				throw new InvalidOperationException(SR.GetString("InvalidOperation_PipeHandleNotSet"));
			}
			if (base.State == PipeState.Closed)
			{
				__Error.PipeNotOpen();
			}
			if (base.InternalHandle.IsClosed)
			{
				__Error.PipeNotOpen();
			}
			if (base.State == PipeState.Broken)
			{
				throw new IOException(SR.GetString("IO_IO_PipeBroken"));
			}
		}

		[SecurityCritical]
		private void CheckDisconnectOperations()
		{
			if (base.State == PipeState.WaitingToConnect)
			{
				throw new InvalidOperationException(SR.GetString("InvalidOperation_PipeNotYetConnected"));
			}
			if (base.State == PipeState.Disconnected)
			{
				throw new InvalidOperationException(SR.GetString("InvalidOperation_PipeAlreadyDisconnected"));
			}
			if (base.InternalHandle == null)
			{
				throw new InvalidOperationException(SR.GetString("InvalidOperation_PipeHandleNotSet"));
			}
			if (base.State == PipeState.Closed)
			{
				__Error.PipeNotOpen();
			}
			if (base.InternalHandle.IsClosed)
			{
				__Error.PipeNotOpen();
			}
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class NamedPipeClientStream : PipeStream
	{
		private string m_normalizedPipePath;

		private TokenImpersonationLevel m_impersonationLevel;

		private PipeOptions m_pipeOptions;

		private HandleInheritability m_inheritability;

		private int m_access;

		public int NumberOfServerInstances
		{
			[SecurityCritical]
			get
			{
				CheckPipePropertyOperations();
				if (!Microsoft.Win32.UnsafeNativeMethods.GetNamedPipeHandleState(base.InternalHandle, Microsoft.Win32.UnsafeNativeMethods.NULL, out var lpCurInstances, Microsoft.Win32.UnsafeNativeMethods.NULL, Microsoft.Win32.UnsafeNativeMethods.NULL, Microsoft.Win32.UnsafeNativeMethods.NULL, 0))
				{
					WinIOError(Marshal.GetLastWin32Error());
				}
				return lpCurInstances;
			}
		}

		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		public NamedPipeClientStream(string pipeName)
			: this(".", pipeName, PipeDirection.InOut, PipeOptions.None, TokenImpersonationLevel.None, HandleInheritability.None)
		{
		}

		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		public NamedPipeClientStream(string serverName, string pipeName)
			: this(serverName, pipeName, PipeDirection.InOut, PipeOptions.None, TokenImpersonationLevel.None, HandleInheritability.None)
		{
		}

		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		public NamedPipeClientStream(string serverName, string pipeName, PipeDirection direction)
			: this(serverName, pipeName, direction, PipeOptions.None, TokenImpersonationLevel.None, HandleInheritability.None)
		{
		}

		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		public NamedPipeClientStream(string serverName, string pipeName, PipeDirection direction, PipeOptions options)
			: this(serverName, pipeName, direction, options, TokenImpersonationLevel.None, HandleInheritability.None)
		{
		}

		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		public NamedPipeClientStream(string serverName, string pipeName, PipeDirection direction, PipeOptions options, TokenImpersonationLevel impersonationLevel)
			: this(serverName, pipeName, direction, options, impersonationLevel, HandleInheritability.None)
		{
		}

		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		public NamedPipeClientStream(string serverName, string pipeName, PipeDirection direction, PipeOptions options, TokenImpersonationLevel impersonationLevel, HandleInheritability inheritability)
			: base(direction, 0)
		{
			if (pipeName == null)
			{
				throw new ArgumentNullException("pipeName");
			}
			if (serverName == null)
			{
				throw new ArgumentNullException("serverName", SR.GetString("ArgumentNull_ServerName"));
			}
			if (pipeName.Length == 0)
			{
				throw new ArgumentException(SR.GetString("Argument_NeedNonemptyPipeName"));
			}
			if (serverName.Length == 0)
			{
				throw new ArgumentException(SR.GetString("Argument_EmptyServerName"));
			}
			if ((options & (PipeOptions)1073741823) != 0)
			{
				throw new ArgumentOutOfRangeException("options", SR.GetString("ArgumentOutOfRange_OptionsInvalid"));
			}
			if (impersonationLevel < TokenImpersonationLevel.None || impersonationLevel > TokenImpersonationLevel.Delegation)
			{
				throw new ArgumentOutOfRangeException("impersonationLevel", SR.GetString("ArgumentOutOfRange_ImpersonationInvalid"));
			}
			if (inheritability < HandleInheritability.None || inheritability > HandleInheritability.Inheritable)
			{
				throw new ArgumentOutOfRangeException("inheritability", SR.GetString("ArgumentOutOfRange_HandleInheritabilityNoneOrInheritable"));
			}
			m_normalizedPipePath = Path.GetFullPath("\\\\" + serverName + "\\pipe\\" + pipeName);
			if (string.Compare(m_normalizedPipePath, "\\\\.\\pipe\\anonymous", StringComparison.OrdinalIgnoreCase) == 0)
			{
				throw new ArgumentOutOfRangeException("pipeName", SR.GetString("ArgumentOutOfRange_AnonymousReserved"));
			}
			m_inheritability = inheritability;
			m_impersonationLevel = impersonationLevel;
			m_pipeOptions = options;
			if ((PipeDirection.In & direction) != 0)
			{
				m_access |= int.MinValue;
			}
			if ((PipeDirection.Out & direction) != 0)
			{
				m_access |= 1073741824;
			}
		}

		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		public NamedPipeClientStream(string serverName, string pipeName, PipeAccessRights desiredAccessRights, PipeOptions options, TokenImpersonationLevel impersonationLevel, HandleInheritability inheritability)
			: base(DirectionFromRights(desiredAccessRights), 0)
		{
			if (pipeName == null)
			{
				throw new ArgumentNullException("pipeName");
			}
			if (serverName == null)
			{
				throw new ArgumentNullException("serverName", SR.GetString("ArgumentNull_ServerName"));
			}
			if (pipeName.Length == 0)
			{
				throw new ArgumentException(SR.GetString("Argument_NeedNonemptyPipeName"));
			}
			if (serverName.Length == 0)
			{
				throw new ArgumentException(SR.GetString("Argument_EmptyServerName"));
			}
			if ((options & (PipeOptions)1073741823) != 0)
			{
				throw new ArgumentOutOfRangeException("options", SR.GetString("ArgumentOutOfRange_OptionsInvalid"));
			}
			if (impersonationLevel < TokenImpersonationLevel.None || impersonationLevel > TokenImpersonationLevel.Delegation)
			{
				throw new ArgumentOutOfRangeException("impersonationLevel", SR.GetString("ArgumentOutOfRange_ImpersonationInvalid"));
			}
			if (inheritability < HandleInheritability.None || inheritability > HandleInheritability.Inheritable)
			{
				throw new ArgumentOutOfRangeException("inheritability", SR.GetString("ArgumentOutOfRange_HandleInheritabilityNoneOrInheritable"));
			}
			if (((uint)desiredAccessRights & 0xFEE0FE60u) != 0)
			{
				throw new ArgumentOutOfRangeException("desiredAccessRights", SR.GetString("ArgumentOutOfRange_InvalidPipeAccessRights"));
			}
			m_normalizedPipePath = Path.GetFullPath("\\\\" + serverName + "\\pipe\\" + pipeName);
			if (string.Compare(m_normalizedPipePath, "\\\\.\\pipe\\anonymous", StringComparison.OrdinalIgnoreCase) == 0)
			{
				throw new ArgumentOutOfRangeException("pipeName", SR.GetString("ArgumentOutOfRange_AnonymousReserved"));
			}
			m_inheritability = inheritability;
			m_impersonationLevel = impersonationLevel;
			m_pipeOptions = options;
			m_access = (int)desiredAccessRights;
		}

		private static PipeDirection DirectionFromRights(PipeAccessRights rights)
		{
			PipeDirection pipeDirection = (PipeDirection)0;
			if ((rights & PipeAccessRights.ReadData) != 0)
			{
				pipeDirection |= PipeDirection.In;
			}
			if ((rights & PipeAccessRights.WriteData) != 0)
			{
				pipeDirection |= PipeDirection.Out;
			}
			return pipeDirection;
		}

		[SecurityCritical]
		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		public NamedPipeClientStream(PipeDirection direction, bool isAsync, bool isConnected, SafePipeHandle safePipeHandle)
			: base(direction, 0)
		{
			if (Microsoft.Win32.UnsafeNativeMethods.GetFileType(safePipeHandle) != 3)
			{
				throw new IOException(SR.GetString("IO_IO_InvalidPipeHandle"));
			}
			InitializeHandle(safePipeHandle, isExposed: true, isAsync);
			if (isConnected)
			{
				base.State = PipeState.Connected;
			}
		}

		~NamedPipeClientStream()
		{
			Dispose(disposing: false);
		}

		public void Connect()
		{
			Connect(-1);
		}

		[SecurityCritical]
		public void Connect(int timeout)
		{
			CheckConnectOperationsClient();
			if (timeout < 0 && timeout != -1)
			{
				throw new ArgumentOutOfRangeException("timeout", SR.GetString("ArgumentOutOfRange_InvalidTimeout"));
			}
			Microsoft.Win32.UnsafeNativeMethods.SECURITY_ATTRIBUTES secAttrs = PipeStream.GetSecAttrs(m_inheritability);
			int num = (int)m_pipeOptions;
			if (m_impersonationLevel != 0)
			{
				num |= 0x100000;
				num |= (int)(m_impersonationLevel - 1) << 16;
			}
			int tickCount = Environment.TickCount;
			int num2 = 0;
			do
			{
				if (!Microsoft.Win32.UnsafeNativeMethods.WaitNamedPipe(m_normalizedPipePath, timeout - num2))
				{
					int lastWin32Error = Marshal.GetLastWin32Error();
					if (lastWin32Error == 2)
					{
						continue;
					}
					if (lastWin32Error == 0)
					{
						break;
					}
					__Error.WinIOError(lastWin32Error, string.Empty);
				}
				SafePipeHandle safePipeHandle = Microsoft.Win32.UnsafeNativeMethods.CreateNamedPipeClient(m_normalizedPipePath, m_access, FileShare.None, secAttrs, FileMode.Open, num, Microsoft.Win32.UnsafeNativeMethods.NULL);
				if (safePipeHandle.IsInvalid)
				{
					int lastWin32Error2 = Marshal.GetLastWin32Error();
					if (lastWin32Error2 == 231)
					{
						continue;
					}
					__Error.WinIOError(lastWin32Error2, string.Empty);
				}
				InitializeHandle(safePipeHandle, isExposed: false, (m_pipeOptions & PipeOptions.Asynchronous) != 0);
				base.State = PipeState.Connected;
				return;
			}
			while (timeout == -1 || (num2 = Environment.TickCount - tickCount) < timeout);
			throw new TimeoutException();
		}

		[SecurityCritical]
		protected internal override void CheckPipePropertyOperations()
		{
			base.CheckPipePropertyOperations();
			if (base.State == PipeState.WaitingToConnect)
			{
				throw new InvalidOperationException(SR.GetString("InvalidOperation_PipeNotYetConnected"));
			}
			if (base.State == PipeState.Broken)
			{
				throw new IOException(SR.GetString("IO_IO_PipeBroken"));
			}
		}

		private void CheckConnectOperationsClient()
		{
			if (base.State == PipeState.Connected)
			{
				throw new InvalidOperationException(SR.GetString("InvalidOperation_PipeAlreadyConnected"));
			}
			if (base.State == PipeState.Closed)
			{
				__Error.PipeNotOpen();
			}
		}
	}
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	internal sealed class PipeAsyncResult : IAsyncResult
	{
		internal AsyncCallback _userCallback;

		internal object _userStateObject;

		internal ManualResetEvent _waitHandle;

		internal SafePipeHandle _handle;

		internal unsafe NativeOverlapped* _overlapped;

		internal int _EndXxxCalled;

		internal int _errorCode;

		internal bool _isComplete;

		internal bool _completedSynchronously;

		public object AsyncState => _userStateObject;

		public bool IsCompleted => _isComplete;

		public unsafe WaitHandle AsyncWaitHandle
		{
			[SecurityCritical]
			get
			{
				if (_waitHandle == null)
				{
					ManualResetEvent manualResetEvent = new ManualResetEvent(initialState: false);
					if (_overlapped != null && _overlapped->EventHandle != IntPtr.Zero)
					{
						manualResetEvent.SafeWaitHandle = new SafeWaitHandle(_overlapped->EventHandle, ownsHandle: true);
					}
					if (_isComplete)
					{
						manualResetEvent.Set();
					}
					_waitHandle = manualResetEvent;
				}
				return _waitHandle;
			}
		}

		public bool CompletedSynchronously => _completedSynchronously;

		private void CallUserCallbackWorker(object callbackState)
		{
			_isComplete = true;
			if (_waitHandle != null)
			{
				_waitHandle.Set();
			}
			_userCallback(this);
		}

		internal void CallUserCallback()
		{
			if (_userCallback != null)
			{
				_completedSynchronously = false;
				ThreadPool.QueueUserWorkItem(CallUserCallbackWorker);
				return;
			}
			_isComplete = true;
			if (_waitHandle != null)
			{
				_waitHandle.Set();
			}
		}
	}
	[Serializable]
	internal enum PipeState
	{
		WaitingToConnect,
		Connected,
		Broken,
		Disconnected,
		Closed
	}
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	internal sealed class PipeStreamAsyncResult : IAsyncResult
	{
		internal AsyncCallback _userCallback;

		internal object _userStateObject;

		internal ManualResetEvent _waitHandle;

		internal SafePipeHandle _handle;

		internal unsafe NativeOverlapped* _overlapped;

		internal int _EndXxxCalled;

		internal int _numBytes;

		internal int _errorCode;

		internal bool _isMessageComplete;

		internal bool _isWrite;

		internal bool _isComplete;

		internal bool _completedSynchronously;

		public object AsyncState => _userStateObject;

		public bool IsCompleted => _isComplete;

		public unsafe WaitHandle AsyncWaitHandle
		{
			[SecurityCritical]
			get
			{
				if (_waitHandle == null)
				{
					ManualResetEvent manualResetEvent = new ManualResetEvent(initialState: false);
					if (_overlapped != null && _overlapped->EventHandle != IntPtr.Zero)
					{
						manualResetEvent.SafeWaitHandle = new SafeWaitHandle(_overlapped->EventHandle, ownsHandle: true);
					}
					if (_isComplete)
					{
						manualResetEvent.Set();
					}
					_waitHandle = manualResetEvent;
				}
				return _waitHandle;
			}
		}

		public bool CompletedSynchronously => _completedSynchronously;

		private void CallUserCallbackWorker(object callbackState)
		{
			_isComplete = true;
			if (_waitHandle != null)
			{
				_waitHandle.Set();
			}
			_userCallback(this);
		}

		internal void CallUserCallback()
		{
			if (_userCallback != null)
			{
				_completedSynchronously = false;
				ThreadPool.QueueUserWorkItem(CallUserCallbackWorker);
				return;
			}
			_isComplete = true;
			if (_waitHandle != null)
			{
				_waitHandle.Set();
			}
		}
	}
	[Flags]
	public enum PipeAccessRights
	{
		ReadData = 1,
		WriteData = 2,
		ReadAttributes = 0x80,
		WriteAttributes = 0x100,
		ReadExtendedAttributes = 8,
		WriteExtendedAttributes = 0x10,
		CreateNewInstance = 4,
		Delete = 0x10000,
		ReadPermissions = 0x20000,
		ChangePermissions = 0x40000,
		TakeOwnership = 0x80000,
		Synchronize = 0x100000,
		FullControl = 0x1F019F,
		Read = 0x20089,
		Write = 0x112,
		ReadWrite = 0x2019B,
		AccessSystemSecurity = 0x1000000
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class PipeAccessRule : AccessRule
	{
		public PipeAccessRights PipeAccessRights => RightsFromAccessMask(base.AccessMask);

		public PipeAccessRule(string identity, PipeAccessRights rights, AccessControlType type)
			: this(new NTAccount(identity), AccessMaskFromRights(rights, type), isInherited: false, type)
		{
		}

		public PipeAccessRule(IdentityReference identity, PipeAccessRights rights, AccessControlType type)
			: this(identity, AccessMaskFromRights(rights, type), isInherited: false, type)
		{
		}

		internal PipeAccessRule(IdentityReference identity, int accessMask, bool isInherited, AccessControlType type)
			: base(identity, accessMask, isInherited, InheritanceFlags.None, PropagationFlags.None, type)
		{
		}

		internal static int AccessMaskFromRights(PipeAccessRights rights, AccessControlType controlType)
		{
			if (rights < (PipeAccessRights)0 || rights > (PipeAccessRights.FullControl | PipeAccessRights.AccessSystemSecurity))
			{
				throw new ArgumentOutOfRangeException("rights", SR.GetString("ArgumentOutOfRange_NeedValidPipeAccessRights"));
			}
			switch (controlType)
			{
			case AccessControlType.Allow:
				rights |= PipeAccessRights.Synchronize;
				break;
			case AccessControlType.Deny:
				if (rights != PipeAccessRights.FullControl)
				{
					rights &= ~PipeAccessRights.Synchronize;
				}
				break;
			}
			return (int)rights;
		}

		internal static PipeAccessRights RightsFromAccessMask(int accessMask)
		{
			return (PipeAccessRights)accessMask;
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class PipeAuditRule : AuditRule
	{
		public PipeAccessRights PipeAccessRights => PipeAccessRule.RightsFromAccessMask(base.AccessMask);

		public PipeAuditRule(IdentityReference identity, PipeAccessRights rights, AuditFlags flags)
			: this(identity, AccessMaskFromRights(rights), isInherited: false, flags)
		{
		}

		public PipeAuditRule(string identity, PipeAccessRights rights, AuditFlags flags)
			: this(new NTAccount(identity), AccessMaskFromRights(rights), isInherited: false, flags)
		{
		}

		internal PipeAuditRule(IdentityReference identity, int accessMask, bool isInherited, AuditFlags flags)
			: base(identity, accessMask, isInherited, InheritanceFlags.None, PropagationFlags.None, flags)
		{
		}

		private static int AccessMaskFromRights(PipeAccessRights rights)
		{
			if (rights < (PipeAccessRights)0 || rights > (PipeAccessRights.FullControl | PipeAccessRights.AccessSystemSecurity))
			{
				throw new ArgumentOutOfRangeException("rights", SR.GetString("ArgumentOutOfRange_NeedValidPipeAccessRights"));
			}
			return (int)rights;
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class PipeSecurity : NativeObjectSecurity
	{
		public override Type AccessRightType => typeof(PipeAccessRights);

		public override Type AccessRuleType => typeof(PipeAccessRule);

		public override Type AuditRuleType => typeof(PipeAuditRule);

		public PipeSecurity()
			: base(isContainer: false, ResourceType.KernelObject)
		{
		}

		internal PipeSecurity(SafePipeHandle safeHandle, AccessControlSections includeSections)
			: base(isContainer: false, ResourceType.KernelObject, safeHandle, includeSections)
		{
		}

		public void AddAccessRule(PipeAccessRule rule)
		{
			if (rule == null)
			{
				throw new ArgumentNullException("rule");
			}
			AddAccessRule((AccessRule)rule);
		}

		public void SetAccessRule(PipeAccessRule rule)
		{
			if (rule == null)
			{
				throw new ArgumentNullException("rule");
			}
			SetAccessRule((AccessRule)rule);
		}

		public void ResetAccessRule(PipeAccessRule rule)
		{
			if (rule == null)
			{
				throw new ArgumentNullException("rule");
			}
			ResetAccessRule((AccessRule)rule);
		}

		public bool RemoveAccessRule(PipeAccessRule rule)
		{
			if (rule == null)
			{
				throw new ArgumentNullException("rule");
			}
			AuthorizationRuleCollection accessRules = GetAccessRules(includeExplicit: true, includeInherited: true, rule.IdentityReference.GetType());
			for (int i = 0; i < accessRules.Count; i++)
			{
				if (accessRules[i] is PipeAccessRule pipeAccessRule && pipeAccessRule.PipeAccessRights == rule.PipeAccessRights && pipeAccessRule.IdentityReference == rule.IdentityReference && pipeAccessRule.AccessControlType == rule.AccessControlType)
				{
					return RemoveAccessRule((AccessRule)rule);
				}
			}
			if (rule.PipeAccessRights != PipeAccessRights.FullControl)
			{
				return RemoveAccessRule((AccessRule)new PipeAccessRule(rule.IdentityReference, PipeAccessRule.AccessMaskFromRights(rule.PipeAccessRights, AccessControlType.Deny), isInherited: false, rule.AccessControlType));
			}
			return RemoveAccessRule((AccessRule)rule);
		}

		public void RemoveAccessRuleSpecific(PipeAccessRule rule)
		{
			if (rule == null)
			{
				throw new ArgumentNullException("rule");
			}
			AuthorizationRuleCollection accessRules = GetAccessRules(includeExplicit: true, includeInherited: true, rule.IdentityReference.GetType());
			for (int i = 0; i < accessRules.Count; i++)
			{
				if (accessRules[i] is PipeAccessRule pipeAccessRule && pipeAccessRule.PipeAccessRights == rule.PipeAccessRights && pipeAccessRule.IdentityReference == rule.IdentityReference && pipeAccessRule.AccessControlType == rule.AccessControlType)
				{
					RemoveAccessRuleSpecific((AccessRule)rule);
					return;
				}
			}
			if (rule.PipeAccessRights != PipeAccessRights.FullControl)
			{
				RemoveAccessRuleSpecific((AccessRule)new PipeAccessRule(rule.IdentityReference, PipeAccessRule.AccessMaskFromRights(rule.PipeAccessRights, AccessControlType.Deny), isInherited: false, rule.AccessControlType));
			}
			else
			{
				RemoveAccessRuleSpecific((AccessRule)rule);
			}
		}

		public void AddAuditRule(PipeAuditRule rule)
		{
			AddAuditRule((AuditRule)rule);
		}

		public void SetAuditRule(PipeAuditRule rule)
		{
			SetAuditRule((AuditRule)rule);
		}

		public bool RemoveAuditRule(PipeAuditRule rule)
		{
			return RemoveAuditRule((AuditRule)rule);
		}

		public void RemoveAuditRuleAll(PipeAuditRule rule)
		{
			RemoveAuditRuleAll((AuditRule)rule);
		}

		public void RemoveAuditRuleSpecific(PipeAuditRule rule)
		{
			RemoveAuditRuleSpecific((AuditRule)rule);
		}

		public override AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type)
		{
			if (inheritanceFlags != 0)
			{
				throw new ArgumentException(SR.GetString("Argument_NonContainerInvalidAnyFlag"), "inheritanceFlags");
			}
			if (propagationFlags != 0)
			{
				throw new ArgumentException(SR.GetString("Argument_NonContainerInvalidAnyFlag"), "propagationFlags");
			}
			return new PipeAccessRule(identityReference, accessMask, isInherited, type);
		}

		public sealed override AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags)
		{
			if (inheritanceFlags != 0)
			{
				throw new ArgumentException(SR.GetString("Argument_NonContainerInvalidAnyFlag"), "inheritanceFlags");
			}
			if (propagationFlags != 0)
			{
				throw new ArgumentException(SR.GetString("Argument_NonContainerInvalidAnyFlag"), "propagationFlags");
			}
			return new PipeAuditRule(identityReference, accessMask, isInherited, flags);
		}

		private AccessControlSections GetAccessControlSectionsFromChanges()
		{
			AccessControlSections accessControlSections = AccessControlSections.None;
			if (base.AccessRulesModified)
			{
				accessControlSections = AccessControlSections.Access;
			}
			if (base.AuditRulesModified)
			{
				accessControlSections |= AccessControlSections.Audit;
			}
			if (base.OwnerModified)
			{
				accessControlSections |= AccessControlSections.Owner;
			}
			if (base.GroupModified)
			{
				accessControlSections |= AccessControlSections.Group;
			}
			return accessControlSections;
		}

		[SecurityCritical]
		[SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
		protected internal void Persist(SafeHandle handle)
		{
			WriteLock();
			try
			{
				AccessControlSections accessControlSectionsFromChanges = GetAccessControlSectionsFromChanges();
				Persist(handle, accessControlSectionsFromChanges);
				bool flag2 = (base.AccessRulesModified = false);
				bool flag4 = (base.AuditRulesModified = flag2);
				bool ownerModified = (base.GroupModified = flag4);
				base.OwnerModified = ownerModified;
			}
			finally
			{
				WriteUnlock();
			}
		}

		[SecurityCritical]
		[SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
		protected internal void Persist(string name)
		{
			WriteLock();
			try
			{
				AccessControlSections accessControlSectionsFromChanges = GetAccessControlSectionsFromChanges();
				Persist(name, accessControlSectionsFromChanges);
				bool flag2 = (base.AccessRulesModified = false);
				bool flag4 = (base.AuditRulesModified = flag2);
				bool ownerModified = (base.GroupModified = flag4);
				base.OwnerModified = ownerModified;
			}
			finally
			{
				WriteUnlock();
			}
		}
	}
}
namespace System.Threading
{
	public enum LockRecursionPolicy
	{
		NoRecursion,
		SupportsRecursion
	}
	internal class RecursiveCounts
	{
		public int writercount;

		public int upgradecount;
	}
	[Serializable]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class LockRecursionException : Exception
	{
		public LockRecursionException()
		{
		}

		public LockRecursionException(string message)
			: base(message)
		{
		}

		protected LockRecursionException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}

		public LockRecursionException(string message, Exception innerException)
			: base(message, innerException)
		{
		}
	}
	internal class ReaderWriterCount
	{
		public int threadid;

		public int readercount;

		public ReaderWriterCount next;

		public RecursiveCounts rc;

		public ReaderWriterCount(bool fIsReentrant)
		{
			threadid = -1;
			if (fIsReentrant)
			{
				rc = new RecursiveCounts();
			}
		}
	}
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	[HostProtection(SecurityAction.LinkDemand, Synchronization = true, ExternalThreading = true)]
	public class ReaderWriterLockSlim : IDisposable
	{
		private const int LockSpinCycles = 20;

		private const int LockSpinCount = 10;

		private const int LockSleep0Count = 5;

		private const int hashTableSize = 255;

		private const int MaxSpinCount = 20;

		private const uint WRITER_HELD = 2147483648u;

		private const uint WAITING_WRITERS = 1073741824u;

		private const uint WAITING_UPGRADER = 536870912u;

		private const uint MAX_READER = 268435454u;

		private const uint READER_MASK = 268435455u;

		private bool fIsReentrant;

		private int myLock;

		private uint numWriteWaiters;

		private uint numReadWaiters;

		private uint numWriteUpgradeWaiters;

		private uint numUpgradeWaiters;

		private bool fNoWaiters;

		private int upgradeLockOwnerId;

		private int writeLockOwnerId;

		private EventWaitHandle writeEvent;

		private EventWaitHandle readEvent;

		private EventWaitHandle upgradeEvent;

		private EventWaitHandle waitUpgradeEvent;

		private ReaderWriterCount[] rwc;

		private bool fUpgradeThreadHoldingRead;

		private uint owners;

		private bool fDisposed;

		public bool IsReadLockHeld
		{
			get
			{
				if (RecursiveReadCount > 0)
				{
					return true;
				}
				return false;
			}
		}

		public bool IsUpgradeableReadLockHeld
		{
			get
			{
				if (RecursiveUpgradeCount > 0)
				{
					return true;
				}
				return false;
			}
		}

		public bool IsWriteLockHeld
		{
			get
			{
				if (RecursiveWriteCount > 0)
				{
					return true;
				}
				return false;
			}
		}

		public LockRecursionPolicy RecursionPolicy
		{
			get
			{
				if (fIsReentrant)
				{
					return LockRecursionPolicy.SupportsRecursion;
				}
				return LockRecursionPolicy.NoRecursion;
			}
		}

		public int CurrentReadCount
		{
			get
			{
				int numReaders = (int)GetNumReaders();
				if (upgradeLockOwnerId != -1)
				{
					return numReaders - 1;
				}
				return numReaders;
			}
		}

		public int RecursiveReadCount
		{
			get
			{
				int managedThreadId = Thread.CurrentThread.ManagedThreadId;
				int result = 0;
				EnterMyLock();
				ReaderWriterCount threadRWCount = GetThreadRWCount(managedThreadId, DontAllocate: true);
				if (threadRWCount != null)
				{
					result = threadRWCount.readercount;
				}
				ExitMyLock();
				return result;
			}
		}

		public int RecursiveUpgradeCount
		{
			get
			{
				int managedThreadId = Thread.CurrentThread.ManagedThreadId;
				if (fIsReentrant)
				{
					int result = 0;
					EnterMyLock();
					ReaderWriterCount threadRWCount = GetThreadRWCount(managedThreadId, DontAllocate: true);
					if (threadRWCount != null)
					{
						result = threadRWCount.rc.upgradecount;
					}
					ExitMyLock();
					return result;
				}
				if (managedThreadId == upgradeLockOwnerId)
				{
					return 1;
				}
				return 0;
			}
		}

		public int RecursiveWriteCount
		{
			get
			{
				int managedThreadId = Thread.CurrentThread.ManagedThreadId;
				int result = 0;
				if (fIsReentrant)
				{
					EnterMyLock();
					ReaderWriterCount threadRWCount = GetThreadRWCount(managedThreadId, DontAllocate: true);
					if (threadRWCount != null)
					{
						result = threadRWCount.rc.writercount;
					}
					ExitMyLock();
					return result;
				}
				if (managedThreadId == writeLockOwnerId)
				{
					return 1;
				}
				return 0;
			}
		}

		public int WaitingReadCount => (int)numReadWaiters;

		public int WaitingUpgradeCount => (int)numUpgradeWaiters;

		public int WaitingWriteCount => (int)numWriteWaiters;

		private void InitializeThreadCounts()
		{
			rwc = new ReaderWriterCount[256];
			for (int i = 0; i < rwc.Length; i++)
			{
				rwc[i] = new ReaderWriterCount(fIsReentrant);
			}
			upgradeLockOwnerId = -1;
			writeLockOwnerId = -1;
		}

		public ReaderWriterLockSlim()
			: this(LockRecursionPolicy.NoRecursion)
		{
		}

		public ReaderWriterLockSlim(LockRecursionPolicy recursionPolicy)
		{
			if (recursionPolicy == LockRecursionPolicy.SupportsRecursion)
			{
				fIsReentrant = true;
			}
			InitializeThreadCounts();
		}

		private static bool IsRWEntryEmpty(ReaderWriterCount rwc)
		{
			if (rwc.threadid == -1)
			{
				return true;
			}
			if (rwc.readercount == 0 && rwc.rc == null)
			{
				return true;
			}
			if (rwc.readercount == 0 && rwc.rc.writercount == 0 && rwc.rc.upgradecount == 0)
			{
				return true;
			}
			return false;
		}

		private static bool IsRwHashEntryChanged(ReaderWriterCount lrwc, int id)
		{
			return lrwc.threadid != id;
		}

		private ReaderWriterCount GetThreadRWCount(int id, bool DontAllocate)
		{
			int num = id & 0xFF;
			ReaderWriterCount readerWriterCount = null;
			if (rwc[num].threadid == id)
			{
				return rwc[num];
			}
			if (IsRWEntryEmpty(rwc[num]) && !DontAllocate)
			{
				if (rwc[num].next == null)
				{
					rwc[num].threadid = id;
					return rwc[num];
				}
				readerWriterCount = rwc[num];
			}
			for (ReaderWriterCount next = rwc[num].next; next != null; next = next.next)
			{
				if (next.threadid == id)
				{
					return next;
				}
				if (readerWriterCount == null && IsRWEntryEmpty(next))
				{
					readerWriterCount = next;
				}
			}
			if (DontAllocate)
			{
				return null;
			}
			if (readerWriterCount == null)
			{
				ReaderWriterCount next = new ReaderWriterCount(fIsReentrant);
				next.threadid = id;
				next.next = rwc[num].next;
				rwc[num].next = next;
				return next;
			}
			readerWriterCount.threadid = id;
			return readerWriterCount;
		}

		public void EnterReadLock()
		{
			TryEnterReadLock(-1);
		}

		public bool TryEnterReadLock(TimeSpan timeout)
		{
			long num = (long)timeout.TotalMilliseconds;
			if (num < -1 || num > int.MaxValue)
			{
				throw new ArgumentOutOfRangeException("timeout");
			}
			int millisecondsTimeout = (int)timeout.TotalMilliseconds;
			return TryEnterReadLock(millisecondsTimeout);
		}

		public bool TryEnterReadLock(int millisecondsTimeout)
		{
			if (millisecondsTimeout < -1)
			{
				throw new ArgumentOutOfRangeException("millisecondsTimeout");
			}
			if (fDisposed)
			{
				throw new ObjectDisposedException(null);
			}
			ReaderWriterCount readerWriterCount = null;
			int managedThreadId = Thread.CurrentThread.ManagedThreadId;
			if (!fIsReentrant)
			{
				if (managedThreadId == writeLockOwnerId)
				{
					throw new LockRecursionException(SR.GetString("LockRecursionException_ReadAfterWriteNotAllowed"));
				}
				EnterMyLock();
				readerWriterCount = GetThreadRWCount(managedThreadId, DontAllocate: false);
				if (readerWriterCount.readercount > 0)
				{
					ExitMyLock();
					throw new LockRecursionException(SR.GetString("LockRecursionException_RecursiveReadNotAllowed"));
				}
				if (managedThreadId == upgradeLockOwnerId)
				{
					readerWriterCount.readercount++;
					owners++;
					ExitMyLock();
					return true;
				}
			}
			else
			{
				EnterMyLock();
				readerWriterCount = GetThreadRWCount(managedThreadId, DontAllocate: false);
				if (readerWriterCount.readercount > 0)
				{
					readerWriterCount.readercount++;
					ExitMyLock();
					return true;
				}
				if (managedThreadId == upgradeLockOwnerId)
				{
					readerWriterCount.readercount++;
					owners++;
					ExitMyLock();
					fUpgradeThreadHoldingRead = true;
					return true;
				}
				if (managedThreadId == writeLockOwnerId)
				{
					readerWriterCount.readercount++;
					owners++;
					ExitMyLock();
					return true;
				}
			}
			bool flag = true;
			int num = 0;
			while (true)
			{
				if (owners < 268435454)
				{
					owners++;
					readerWriterCount.readercount++;
					ExitMyLock();
					return flag;
				}
				if (num < 20)
				{
					ExitMyLock();
					if (millisecondsTimeout == 0)
					{
						return false;
					}
					num++;
					SpinWait(num);
					EnterMyLock();
					if (IsRwHashEntryChanged(readerWriterCount, managedThreadId))
					{
						readerWriterCount = GetThreadRWCount(managedThreadId, DontAllocate: false);
					}
				}
				else if (readEvent == null)
				{
					LazyCreateEvent(ref readEvent, makeAutoResetEvent: false);
					if (IsRwHashEntryChanged(readerWriterCount, managedThreadId))
					{
						readerWriterCount = GetThreadRWCount(managedThreadId, DontAllocate: false);
					}
				}
				else
				{
					flag = WaitOnEvent(readEvent, ref numReadWaiters, millisecondsTimeout);
					if (!flag)
					{
						break;
					}
					if (IsRwHashEntryChanged(readerWriterCount, managedThreadId))
					{
						readerWriterCount = GetThreadRWCount(managedThreadId, DontAllocate: false);
					}
				}
			}
			return false;
		}

		public void EnterWriteLock()
		{
			TryEnterWriteLock(-1);
		}

		public bool TryEnterWriteLock(TimeSpan timeout)
		{
			long num = (long)timeout.TotalMilliseconds;
			if (num < -1 || num > int.MaxValue)
			{
				throw new ArgumentOutOfRangeException("timeout");
			}
			int millisecondsTimeout = (int)timeout.TotalMilliseconds;
			return TryEnterWriteLock(millisecondsTimeout);
		}

		public bool TryEnterWriteLock(int millisecondsTimeout)
		{
			if (millisecondsTimeout < -1)
			{
				throw new ArgumentOutOfRangeException("millisecondsTimeout");
			}
			if (fDisposed)
			{
				throw new ObjectDisposedException(null);
			}
			int managedThreadId = Thread.CurrentThread.ManagedThreadId;
			bool flag = false;
			ReaderWriterCount threadRWCount;
			if (!fIsReentrant)
			{
				if (managedThreadId == writeLockOwnerId)
				{
					throw new LockRecursionException(SR.GetString("LockRecursionException_RecursiveWriteNotAllowed"));
				}
				if (managedThreadId == upgradeLockOwnerId)
				{
					flag = true;
				}
				EnterMyLock();
				threadRWCount = GetThreadRWCount(managedThreadId, DontAllocate: true);
				if (threadRWCount != null && threadRWCount.readercount > 0)
				{
					ExitMyLock();
					throw new LockRecursionException(SR.GetString("LockRecursionException_WriteAfterReadNotAllowed"));
				}
			}
			else
			{
				EnterMyLock();
				threadRWCount = GetThreadRWCount(managedThreadId, DontAllocate: false);
				if (managedThreadId == writeLockOwnerId)
				{
					threadRWCount.rc.writercount++;
					ExitMyLock();
					return true;
				}
				if (managedThreadId == upgradeLockOwnerId)
				{
					flag = true;
				}
				else if (threadRWCount.readercount > 0)
				{
					ExitMyLock();
					throw new LockRecursionException(SR.GetString("LockRecursionException_WriteAfterReadNotAllowed"));
				}
			}
			int num = 0;
			bool flag2 = true;
			while (true)
			{
				if (IsWriterAcquired())
				{
					SetWriterAcquired();
					break;
				}
				if (flag)
				{
					uint numReaders = GetNumReaders();
					if (numReaders == 1)
					{
						SetWriterAcquired();
						break;
					}
					if (numReaders == 2 && threadRWCount != null)
					{
						if (IsRwHashEntryChanged(threadRWCount, managedThreadId))
						{
							threadRWCount = GetThreadRWCount(managedThreadId, DontAllocate: false);
						}
						if (threadRWCount.readercount > 0)
						{
							SetWriterAcquired();
							break;
						}
					}
				}
				if (num < 20)
				{
					ExitMyLock();
					if (millisecondsTimeout == 0)
					{
						return false;
					}
					num++;
					SpinWait(num);
					EnterMyLock();
				}
				else if (flag)
				{
					if (waitUpgradeEvent == null)
					{
						LazyCreateEvent(ref waitUpgradeEvent, makeAutoResetEvent: true);
					}
					else if (!WaitOnEvent(waitUpgradeEvent, ref numWriteUpgradeWaiters, millisecondsTimeout))
					{
						return false;
					}
				}
				else if (writeEvent == null)
				{
					LazyCreateEvent(ref writeEvent, makeAutoResetEvent: true);
				}
				else if (!WaitOnEvent(writeEvent, ref numWriteWaiters, millisecondsTimeout))
				{
					return false;
				}
			}
			if (fIsReentrant)
			{
				if (IsRwHashEntryChanged(threadRWCount, managedThreadId))
				{
					threadRWCount = GetThreadRWCount(managedThreadId, DontAllocate: false);
				}
				threadRWCount.rc.writercount++;
			}
			ExitMyLock();
			writeLockOwnerId = managedThreadId;
			return true;
		}

		public void EnterUpgradeableReadLock()
		{
			TryEnterUpgradeableReadLock(-1);
		}

		public bool TryEnterUpgradeableReadLock(TimeSpan timeout)
		{
			long num = (long)timeout.TotalMilliseconds;
			if (num < -1 || num > int.MaxValue)
			{
				throw new ArgumentOutOfRangeException("timeout");
			}
			int millisecondsTimeout = (int)timeout.TotalMilliseconds;
			return TryEnterUpgradeableReadLock(millisecondsTimeout);
		}

		public bool TryEnterUpgradeableReadLock(int millisecondsTimeout)
		{
			if (millisecondsTimeout < -1)
			{
				throw new ArgumentOutOfRangeException("millisecondsTimeout");
			}
			if (fDisposed)
			{
				throw new ObjectDisposedException(null);
			}
			int managedThreadId = Thread.CurrentThread.ManagedThreadId;
			ReaderWriterCount threadRWCount;
			if (!fIsReentrant)
			{
				if (managedThreadId == upgradeLockOwnerId)
				{
					throw new LockRecursionException(SR.GetString("LockRecursionException_RecursiveUpgradeNotAllowed"));
				}
				if (managedThreadId == writeLockOwnerId)
				{
					throw new LockRecursionException(SR.GetString("LockRecursionException_UpgradeAfterWriteNotAllowed"));
				}
				EnterMyLock();
				threadRWCount = GetThreadRWCount(managedThreadId, DontAllocate: true);
				if (threadRWCount != null && threadRWCount.readercount > 0)
				{
					ExitMyLock();
					throw new LockRecursionException(SR.GetString("LockRecursionException_UpgradeAfterReadNotAllowed"));
				}
			}
			else
			{
				EnterMyLock();
				threadRWCount = GetThreadRWCount(managedThreadId, DontAllocate: false);
				if (managedThreadId == upgradeLockOwnerId)
				{
					threadRWCount.rc.upgradecount++;
					ExitMyLock();
					return true;
				}
				if (managedThreadId == writeLockOwnerId)
				{
					owners++;
					upgradeLockOwnerId = managedThreadId;
					threadRWCount.rc.upgradecount++;
					if (threadRWCount.readercount > 0)
					{
						fUpgradeThreadHoldingRead = true;
					}
					ExitMyLock();
					return true;
				}
				if (threadRWCount.readercount > 0)
				{
					ExitMyLock();
					throw new LockRecursionException(SR.GetString("LockRecursionException_UpgradeAfterReadNotAllowed"));
				}
			}
			bool flag = true;
			int num = 0;
			while (true)
			{
				if (upgradeLockOwnerId == -1 && owners < 268435454)
				{
					owners++;
					upgradeLockOwnerId = managedThreadId;
					if (fIsReentrant)
					{
						if (IsRwHashEntryChanged(threadRWCount, managedThreadId))
						{
							threadRWCount = GetThreadRWCount(managedThreadId, DontAllocate: false);
						}
						threadRWCount.rc.upgradecount++;
					}
					break;
				}
				if (num < 20)
				{
					ExitMyLock();
					if (millisecondsTimeout == 0)
					{
						return false;
					}
					num++;
					SpinWait(num);
					EnterMyLock();
				}
				else if (upgradeEvent == null)
				{
					LazyCreateEvent(ref upgradeEvent, makeAutoResetEvent: true);
				}
				else if (!WaitOnEvent(upgradeEvent, ref numUpgradeWaiters, millisecondsTimeout))
				{
					return false;
				}
			}
			ExitMyLock();
			return true;
		}

		public void ExitReadLock()
		{
			int managedThreadId = Thread.CurrentThread.ManagedThreadId;
			ReaderWriterCount readerWriterCount = null;
			EnterMyLock();
			readerWriterCount = GetThreadRWCount(managedThreadId, DontAllocate: true);
			if (!fIsReentrant)
			{
				if (readerWriterCount == null)
				{
					ExitMyLock();
					throw new SynchronizationLockException(SR.GetString("SynchronizationLockException_MisMatchedRead"));
				}
			}
			else
			{
				if (readerWriterCount == null || readerWriterCount.readercount < 1)
				{
					ExitMyLock();
					throw new SynchronizationLockException(SR.GetString("SynchronizationLockException_MisMatchedRead"));
				}
				if (readerWriterCount.readercount > 1)
				{
					readerWriterCount.readercount--;
					ExitMyLock();
					return;
				}
				if (managedThreadId == upgradeLockOwnerId)
				{
					fUpgradeThreadHoldingRead = false;
				}
			}
			owners--;
			readerWriterCount.readercount--;
			ExitAndWakeUpAppropriateWaiters();
		}

		public void ExitWriteLock()
		{
			int managedThreadId = Thread.CurrentThread.ManagedThreadId;
			if (!fIsReentrant)
			{
				if (managedThreadId != writeLockOwnerId)
				{
					throw new SynchronizationLockException(SR.GetString("SynchronizationLockException_MisMatchedWrite"));
				}
				EnterMyLock();
			}
			else
			{
				EnterMyLock();
				ReaderWriterCount threadRWCount = GetThreadRWCount(managedThreadId, DontAllocate: false);
				if (threadRWCount == null)
				{
					ExitMyLock();
					throw new SynchronizationLockException(SR.GetString("SynchronizationLockException_MisMatchedWrite"));
				}
				RecursiveCounts rc = threadRWCount.rc;
				if (rc.writercount < 1)
				{
					ExitMyLock();
					throw new SynchronizationLockException(SR.GetString("SynchronizationLockException_MisMatchedWrite"));
				}
				rc.writercount--;
				if (rc.writercount > 0)
				{
					ExitMyLock();
					return;
				}
			}
			ClearWriterAcquired();
			writeLockOwnerId = -1;
			ExitAndWakeUpAppropriateWaiters();
		}

		public void ExitUpgradeableReadLock()
		{
			int managedThreadId = Thread.CurrentThread.ManagedThreadId;
			if (!fIsReentrant)
			{
				if (managedThreadId != upgradeLockOwnerId)
				{
					throw new SynchronizationLockException(SR.GetString("SynchronizationLockException_MisMatchedUpgrade"));
				}
				EnterMyLock();
			}
			else
			{
				EnterMyLock();
				ReaderWriterCount threadRWCount = GetThreadRWCount(managedThreadId, DontAllocate: true);
				if (threadRWCount == null)
				{
					ExitMyLock();
					throw new SynchronizationLockException(SR.GetString("SynchronizationLockException_MisMatchedUpgrade"));
				}
				RecursiveCounts rc = threadRWCount.rc;
				if (rc.upgradecount < 1)
				{
					ExitMyLock();
					throw new SynchronizationLockException(SR.GetString("SynchronizationLockException_MisMatchedUpgrade"));
				}
				rc.upgradecount--;
				if (rc.upgradecount > 0)
				{
					ExitMyLock();
					return;
				}
				fUpgradeThreadHoldingRead = false;
			}
			owners--;
			upgradeLockOwnerId = -1;
			ExitAndWakeUpAppropriateWaiters();
		}

		private void LazyCreateEvent(ref EventWaitHandle waitEvent, bool makeAutoResetEvent)
		{
			ExitMyLock();
			EventWaitHandle eventWaitHandle = ((!makeAutoResetEvent) ? ((EventWaitHandle)new ManualResetEvent(initialState: false)) : ((EventWaitHandle)new AutoResetEvent(initialState: false)));
			EnterMyLock();
			if (waitEvent == null)
			{
				waitEvent = eventWaitHandle;
			}
			else
			{
				eventWaitHandle.Close();
			}
		}

		private bool WaitOnEvent(EventWaitHandle waitEvent, ref uint numWaiters, int millisecondsTimeout)
		{
			waitEvent.Reset();
			numWaiters++;
			fNoWaiters = false;
			if (numWriteWaiters == 1)
			{
				SetWritersWaiting();
			}
			if (numWriteUpgradeWaiters == 1)
			{
				SetUpgraderWaiting();
			}
			bool flag = false;
			ExitMyLock();
			try
			{
				flag = waitEvent.WaitOne(millisecondsTimeout, exitContext: false);
			}
			finally
			{
				EnterMyLock();
				numWaiters--;
				if (numWriteWaiters == 0 && numWriteUpgradeWaiters == 0 && numUpgradeWaiters == 0 && numReadWaiters == 0)
				{
					fNoWaiters = true;
				}
				if (numWriteWaiters == 0)
				{
					ClearWritersWaiting();
				}
				if (numWriteUpgradeWaiters == 0)
				{
					ClearUpgraderWaiting();
				}
				if (!flag)
				{
					ExitMyLock();
				}
			}
			return flag;
		}

		private void ExitAndWakeUpAppropriateWaiters()
		{
			if (fNoWaiters)
			{
				ExitMyLock();
			}
			else
			{
				ExitAndWakeUpAppropriateWaitersPreferringWriters();
			}
		}

		private void ExitAndWakeUpAppropriateWaitersPreferringWriters()
		{
			bool flag = false;
			bool flag2 = false;
			uint numReaders = GetNumReaders();
			if (fIsReentrant && numWriteUpgradeWaiters != 0 && fUpgradeThreadHoldingRead && numReaders == 2)
			{
				ExitMyLock();
				waitUpgradeEvent.Set();
			}
			else if (numReaders == 1 && numWriteUpgradeWaiters != 0)
			{
				ExitMyLock();
				waitUpgradeEvent.Set();
			}
			else if (numReaders == 0 && numWriteWaiters != 0)
			{
				ExitMyLock();
				writeEvent.Set();
			}
			else if (numReaders >= 0)
			{
				if (numReadWaiters != 0 || numUpgradeWaiters != 0)
				{
					if (numReadWaiters != 0)
					{
						flag2 = true;
					}
					if (numUpgradeWaiters != 0 && upgradeLockOwnerId == -1)
					{
						flag = true;
					}
					ExitMyLock();
					if (flag2)
					{
						readEvent.Set();
					}
					if (flag)
					{
						upgradeEvent.Set();
					}
				}
				else
				{
					ExitMyLock();
				}
			}
			else
			{
				ExitMyLock();
			}
		}

		private bool IsWriterAcquired()
		{
			return (owners & 0xBFFFFFFFu) == 0;
		}

		private void SetWriterAcquired()
		{
			owners |= 2147483648u;
		}

		private void ClearWriterAcquired()
		{
			owners &= 2147483647u;
		}

		private void SetWritersWaiting()
		{
			owners |= 1073741824u;
		}

		private void ClearWritersWaiting()
		{
			owners &= 3221225471u;
		}

		private void SetUpgraderWaiting()
		{
			owners |= 536870912u;
		}

		private void ClearUpgraderWaiting()
		{
			owners &= 3758096383u;
		}

		private uint GetNumReaders()
		{
			return owners & 0xFFFFFFFu;
		}

		private void EnterMyLock()
		{
			if (Interlocked.CompareExchange(ref myLock, 1, 0) != 0)
			{
				EnterMyLockSpin();
			}
		}

		private void EnterMyLockSpin()
		{
			int processorCount = Environment.ProcessorCount;
			int num = 0;
			while (true)
			{
				if (num < 10 && processorCount > 1)
				{
					Thread.SpinWait(20 * (num + 1));
				}
				else if (num < 15)
				{
					Thread.Sleep(0);
				}
				else
				{
					Thread.Sleep(1);
				}
				if (myLock == 0 && Interlocked.CompareExchange(ref myLock, 1, 0) == 0)
				{
					break;
				}
				num++;
			}
		}

		private void ExitMyLock()
		{
			myLock = 0;
		}

		private static void SpinWait(int SpinCount)
		{
			if (SpinCount < 5 && Environment.ProcessorCount > 1)
			{
				Thread.SpinWait(20 * SpinCount);
			}
			else if (SpinCount < 17)
			{
				Thread.Sleep(0);
			}
			else
			{
				Thread.Sleep(1);
			}
		}

		public void Dispose()
		{
			Dispose(disposing: true);
		}

		private void Dispose(bool disposing)
		{
			if (disposing)
			{
				if (fDisposed)
				{
					throw new ObjectDisposedException(null);
				}
				if (WaitingReadCount > 0 || WaitingUpgradeCount > 0 || WaitingWriteCount > 0)
				{
					throw new SynchronizationLockException(SR.GetString("SynchronizationLockException_IncorrectDispose"));
				}
				if (IsReadLockHeld || IsUpgradeableReadLockHeld || IsWriteLockHeld)
				{
					throw new SynchronizationLockException(SR.GetString("SynchronizationLockException_IncorrectDispose"));
				}
				if (writeEvent != null)
				{
					writeEvent.Close();
					writeEvent = null;
				}
				if (readEvent != null)
				{
					readEvent.Close();
					readEvent = null;
				}
				if (upgradeEvent != null)
				{
					upgradeEvent.Close();
					upgradeEvent = null;
				}
				if (waitUpgradeEvent != null)
				{
					waitUpgradeEvent.Close();
					waitUpgradeEvent = null;
				}
				fDisposed = true;
			}
		}
	}
}
internal static class FX20Assembly
{
	internal const string Version = "2.0.0.0";
}
internal static class FX35Assembly
{
	internal const string Version = "3.5.0.0";
}
internal static class FXAssembly
{
	internal const string Version = "3.5.0.0";
}
internal static class ThisAssembly
{
	internal const string Title = "System.Core.dll";

	internal const string Description = "System.Core.dll";

	internal const string DefaultAlias = "System.Core.dll";

	internal const string Copyright = "© Microsoft Corporation.  All rights reserved.";

	internal const string Version = "3.5.0.0";

	internal const string InformationalVersion = "3.5.30729.9141";

	internal const int DailyBuildNumber = 30729;
}
internal static class AssemblyRef
{
	internal const string EcmaPublicKey = "b77a5c561934e089";

	internal const string EcmaPublicKeyToken = "b77a5c561934e089";

	internal const string EcmaPublicKeyFull = "00000000000000000400000000000000";

	internal const string Mscorlib = "mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemData = "System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemDataOracleClient = "System.Data.OracleClient, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string System = "System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemRuntimeRemoting = "System.Runtime.Remoting, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemWindowsForms = "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemXml = "System.Xml, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string MicrosoftPublicKey = "b03f5f7f11d50a3a";

	internal const string MicrosoftPublicKeyToken = "b03f5f7f11d50a3a";

	internal const string MicrosoftPublicKeyFull = "002400000480000094000000060200000024000052534131000400000100010007D1FA57C4AED9F0A32E84AA0FAEFD0DE9E8FD6AEC8F87FB03766C834C99921EB23BE79AD9D5DCC1DD9AD236132102900B723CF980957FC4E177108FC607774F29E8320E92EA05ECE4E821C0A5EFE8F1645C4C0C93C1AB99285D622CAA652C1DFAD63D745D6F2DE5F17E5EAF0FC4963D261C8A12436518206DC093344D5AD293";

	internal const string SharedLibPublicKey = "31bf3856ad364e35";

	internal const string SharedLibPublicKeyToken = "31bf3856ad364e35";

	internal const string SharedLibPublicKeyFull = "0024000004800000940000000602000000240000525341310004000001000100B5FC90E7027F67871E773A8FDE8938C81DD402BA65B9201D60593E96C492651E889CC13F1415EBB53FAC1131AE0BD333C5EE6021672D9718EA31A8AEBD0DA0072F25D87DBA6FC90FFD598ED4DA35E44C398C454307E8E33B8426143DAEC9F596836F97C8F74750E5975C64E2189F45DEF46B2A2B1247ADC3652BF5C308055DA9";

	internal const string SystemComponentModelDataAnnotations = "System.ComponentModel.DataAnnotations, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemConfiguration = "System.Configuration, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemConfigurationInstall = "System.Configuration.Install, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemDeployment = "System.Deployment, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemDesign = "System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemDirectoryServices = "System.DirectoryServices, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemDrawingDesign = "System.Drawing.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemDrawing = "System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemEnterpriseServices = "System.EnterpriseServices, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemManagement = "System.Management, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemMessaging = "System.Messaging, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemRuntimeSerializationFormattersSoap = "System.Runtime.Serialization.Formatters.Soap, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemSecurity = "System.Security, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemServiceProcess = "System.ServiceProcess, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemWeb = "System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemWebAbstractions = "System.Web.Abstractions, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemWebDynamicData = "System.Web.DynamicData, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemWebDynamicDataDesign = "System.Web.DynamicData.Design, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemWebEntityDesign = "System.Web.Entity.Design, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemWebExtensions = "System.Web.Extensions, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemWebExtensionsDesign = "System.Web.Extensions.Design, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemWebMobile = "System.Web.Mobile, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemWebRegularExpressions = "System.Web.RegularExpressions, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemWebRouting = "System.Web.Routing, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemWebServices = "System.Web.Services, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string MicrosoftVisualStudio = "Microsoft.VisualStudio, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string MicrosoftVisualStudioWindowsForms = "Microsoft.VisualStudio.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string VJSharpCodeProvider = "VJSharpCodeProvider, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string ASPBrowserCapsPublicKey = "b7bd7678b977bd8f";

	internal const string ASPBrowserCapsFactory = "ASP.BrowserCapsFactory, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b7bd7678b977bd8f";

	internal const string MicrosoftVSDesigner = "Microsoft.VSDesigner, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string MicrosoftVisualStudioWeb = "Microsoft.VisualStudio.Web, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string MicrosoftWebDesign = "Microsoft.Web.Design.Client, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string MicrosoftVSDesignerMobile = "Microsoft.VSDesigner.Mobile, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string MicrosoftJScript = "Microsoft.JScript, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";
}
namespace System
{
	[AttributeUsage(AttributeTargets.All)]
	internal sealed class SRDescriptionAttribute : DescriptionAttribute
	{
		private bool replaced;

		public override string Description
		{
			get
			{
				if (!replaced)
				{
					replaced = true;
					base.DescriptionValue = SR.GetString(base.Description);
				}
				return base.Description;
			}
		}

		public SRDescriptionAttribute(string description)
			: base(description)
		{
		}
	}
	[AttributeUsage(AttributeTargets.All)]
	internal sealed class SRCategoryAttribute : CategoryAttribute
	{
		public SRCategoryAttribute(string category)
			: base(category)
		{
		}

		protected override string GetLocalizedString(string value)
		{
			return SR.GetString(value);
		}
	}
	internal sealed class SR
	{
		internal const string ArgumentOutOfRange_NeedNonNegNum = "ArgumentOutOfRange_NeedNonNegNum";

		internal const string Argument_AdjustmentRulesNoNulls = "Argument_AdjustmentRulesNoNulls";

		internal const string Argument_AdjustmentRulesOutOfOrder = "Argument_AdjustmentRulesOutOfOrder";

		internal const string Argument_AdjustmentRulesAmbiguousOverlap = "Argument_AdjustmentRulesAmbiguousOverlap";

		internal const string Argument_AdjustmentRulesrDaylightSavingTimeOverlap = "Argument_AdjustmentRulesrDaylightSavingTimeOverlap";

		internal const string Argument_AdjustmentRulesrDaylightSavingTimeOverlapNonRuleRange = "Argument_AdjustmentRulesrDaylightSavingTimeOverlapNonRuleRange";

		internal const string Argument_AdjustmentRulesInvalidOverlap = "Argument_AdjustmentRulesInvalidOverlap";

		internal const string Argument_ConvertMismatch = "Argument_ConvertMismatch";

		internal const string Argument_DateTimeHasTimeOfDay = "Argument_DateTimeHasTimeOfDay";

		internal const string Argument_DateTimeIsInvalid = "Argument_DateTimeIsInvalid";

		internal const string Argument_DateTimeIsNotAmbiguous = "Argument_DateTimeIsNotAmbiguous";

		internal const string Argument_DateTimeOffsetIsNotAmbiguous = "Argument_DateTimeOffsetIsNotAmbiguous";

		internal const string Argument_DateTimeKindMustBeUnspecified = "Argument_DateTimeKindMustBeUnspecified";

		internal const string Argument_DateTimeHasTicks = "Argument_DateTimeHasTicks";

		internal const string Argument_InvalidId = "Argument_InvalidId";

		internal const string Argument_InvalidSerializedString = "Argument_InvalidSerializedString";

		internal const string Argument_InvalidREG_TZI_FORMAT = "Argument_InvalidREG_TZI_FORMAT";

		internal const string Argument_OutOfOrderDateTimes = "Argument_OutOfOrderDateTimes";

		internal const string Argument_TimeSpanHasSeconds = "Argument_TimeSpanHasSeconds";

		internal const string Argument_TransitionTimesAreIdentical = "Argument_TransitionTimesAreIdentical";

		internal const string ArgumentOutOfRange_Day = "ArgumentOutOfRange_Day";

		internal const string ArgumentOutOfRange_DayOfWeek = "ArgumentOutOfRange_DayOfWeek";

		internal const string ArgumentOutOfRange_Month = "ArgumentOutOfRange_Month";

		internal const string ArgumentOutOfRange_UtcOffset = "ArgumentOutOfRange_UtcOffset";

		internal const string ArgumentOutOfRange_UtcOffsetAndDaylightDelta = "ArgumentOutOfRange_UtcOffsetAndDaylightDelta";

		internal const string ArgumentOutOfRange_Week = "ArgumentOutOfRange_Week";

		internal const string InvalidTimeZone_InvalidRegistryData = "InvalidTimeZone_InvalidRegistryData";

		internal const string InvalidTimeZone_InvalidWin32APIData = "InvalidTimeZone_InvalidWin32APIData";

		internal const string Security_CannotReadRegistryData = "Security_CannotReadRegistryData";

		internal const string Serialization_CorruptField = "Serialization_CorruptField";

		internal const string Serialization_InvalidData = "Serialization_InvalidData";

		internal const string Serialization_InvalidEscapeSequence = "Serialization_InvalidEscapeSequence";

		internal const string TimeZoneNotFound_MissingRegistryData = "TimeZoneNotFound_MissingRegistryData";

		internal const string Argument_WrongAsyncResult = "Argument_WrongAsyncResult";

		internal const string Argument_InvalidOffLen = "Argument_InvalidOffLen";

		internal const string Argument_NeedNonemptyPipeName = "Argument_NeedNonemptyPipeName";

		internal const string Argument_EmptyServerName = "Argument_EmptyServerName";

		internal const string Argument_NonContainerInvalidAnyFlag = "Argument_NonContainerInvalidAnyFlag";

		internal const string ArgumentNull_Buffer = "ArgumentNull_Buffer";

		internal const string ArgumentNull_ServerName = "ArgumentNull_ServerName";

		internal const string ArgumentOutOfRange_AdditionalAccessLimited = "ArgumentOutOfRange_AdditionalAccessLimited";

		internal const string ArgumentOutOfRange_AnonymousReserved = "ArgumentOutOfRange_AnonymousReserved";

		internal const string ArgumentOutOfRange_TransmissionModeByteOrMsg = "ArgumentOutOfRange_TransmissionModeByteOrMsg";

		internal const string ArgumentOutOfRange_DirectionModeInOrOut = "ArgumentOutOfRange_DirectionModeInOrOut";

		internal const string ArgumentOutOfRange_DirectionModeInOutOrInOut = "ArgumentOutOfRange_DirectionModeInOutOrInOut";

		internal const string ArgumentOutOfRange_ImpersonationInvalid = "ArgumentOutOfRange_ImpersonationInvalid";

		internal const string ArgumentOutOfRange_ImpersonationOptionsInvalid = "ArgumentOutOfRange_ImpersonationOptionsInvalid";

		internal const string ArgumentOutOfRange_OptionsInvalid = "ArgumentOutOfRange_OptionsInvalid";

		internal const string ArgumentOutOfRange_HandleInheritabilityNoneOrInheritable = "ArgumentOutOfRange_HandleInheritabilityNoneOrInheritable";

		internal const string ArgumentOutOfRange_InvalidPipeAccessRights = "ArgumentOutOfRange_InvalidPipeAccessRights";

		internal const string ArgumentOutOfRange_InvalidTimeout = "ArgumentOutOfRange_InvalidTimeout";

		internal const string ArgumentOutOfRange_MaxNumServerInstances = "ArgumentOutOfRange_MaxNumServerInstances";

		internal const string ArgumentOutOfRange_NeedValidPipeAccessRights = "ArgumentOutOfRange_NeedValidPipeAccessRights";

		internal const string IndexOutOfRange_IORaceCondition = "IndexOutOfRange_IORaceCondition";

		internal const string InvalidOperation_EndReadCalledMultiple = "InvalidOperation_EndReadCalledMultiple";

		internal const string InvalidOperation_EndWriteCalledMultiple = "InvalidOperation_EndWriteCalledMultiple";

		internal const string InvalidOperation_EndWaitForConnectionCalledMultiple = "InvalidOperation_EndWaitForConnectionCalledMultiple";

		internal const string InvalidOperation_PipeNotYetConnected = "InvalidOperation_PipeNotYetConnected";

		internal const string InvalidOperation_PipeDisconnected = "InvalidOperation_PipeDisconnected";

		internal const string InvalidOperation_PipeHandleNotSet = "InvalidOperation_PipeHandleNotSet";

		internal const string InvalidOperation_PipeNotAsync = "InvalidOperation_PipeNotAsync";

		internal const string InvalidOperation_PipeReadModeNotMessage = "InvalidOperation_PipeReadModeNotMessage";

		internal const string InvalidOperation_PipeMessageTypeNotSupported = "InvalidOperation_PipeMessageTypeNotSupported";

		internal const string InvalidOperation_PipeAlreadyConnected = "InvalidOperation_PipeAlreadyConnected";

		internal const string InvalidOperation_PipeAlreadyDisconnected = "InvalidOperation_PipeAlreadyDisconnected";

		internal const string InvalidOperation_PipeClosed = "InvalidOperation_PipeClosed";

		internal const string IO_FileTooLongOrHandleNotSync = "IO_FileTooLongOrHandleNotSync";

		internal const string IO_EOF_ReadBeyondEOF = "IO_EOF_ReadBeyondEOF";

		internal const string IO_FileNotFound = "IO_FileNotFound";

		internal const string IO_FileNotFound_FileName = "IO_FileNotFound_FileName";

		internal const string IO_IO_AlreadyExists_Name = "IO_IO_AlreadyExists_Name";

		internal const string IO_IO_BindHandleFailed = "IO_IO_BindHandleFailed";

		internal const string IO_IO_FileExists_Name = "IO_IO_FileExists_Name";

		internal const string IO_IO_NoPermissionToDirectoryName = "IO_IO_NoPermissionToDirectoryName";

		internal const string IO_IO_SharingViolation_File = "IO_IO_SharingViolation_File";

		internal const string IO_IO_SharingViolation_NoFileName = "IO_IO_SharingViolation_NoFileName";

		internal const string IO_IO_PipeBroken = "IO_IO_PipeBroken";

		internal const string IO_IO_InvalidPipeHandle = "IO_IO_InvalidPipeHandle";

		internal const string IO_DriveNotFound_Drive = "IO_DriveNotFound_Drive";

		internal const string IO_PathNotFound_Path = "IO_PathNotFound_Path";

		internal const string IO_PathNotFound_NoPathName = "IO_PathNotFound_NoPathName";

		internal const string IO_PathTooLong = "IO_PathTooLong";

		internal const string NotSupported_IONonFileDevices = "NotSupported_IONonFileDevices";

		internal const string NotSupported_MemStreamNotExpandable = "NotSupported_MemStreamNotExpandable";

		internal const string NotSupported_UnreadableStream = "NotSupported_UnreadableStream";

		internal const string NotSupported_UnseekableStream = "NotSupported_UnseekableStream";

		internal const string NotSupported_UnwritableStream = "NotSupported_UnwritableStream";

		internal const string NotSupported_AnonymousPipeUnidirectional = "NotSupported_AnonymousPipeUnidirectional";

		internal const string NotSupported_AnonymousPipeMessagesNotSupported = "NotSupported_AnonymousPipeMessagesNotSupported";

		internal const string ObjectDisposed_FileClosed = "ObjectDisposed_FileClosed";

		internal const string ObjectDisposed_PipeClosed = "ObjectDisposed_PipeClosed";

		internal const string ObjectDisposed_ReaderClosed = "ObjectDisposed_ReaderClosed";

		internal const string ObjectDisposed_StreamClosed = "ObjectDisposed_StreamClosed";

		internal const string ObjectDisposed_WriterClosed = "ObjectDisposed_WriterClosed";

		internal const string PlatformNotSupported_NamedPipeServers = "PlatformNotSupported_NamedPipeServers";

		internal const string UnauthorizedAccess_IODenied_Path = "UnauthorizedAccess_IODenied_Path";

		internal const string UnauthorizedAccess_IODenied_NoPathName = "UnauthorizedAccess_IODenied_NoPathName";

		internal const string TraceAsTraceSource = "TraceAsTraceSource";

		internal const string ArgumentOutOfRange_NeedValidLogRetention = "ArgumentOutOfRange_NeedValidLogRetention";

		internal const string ArgumentOutOfRange_NeedMaxFileSizeGEBufferSize = "ArgumentOutOfRange_NeedMaxFileSizeGEBufferSize";

		internal const string ArgumentOutOfRange_NeedValidMaxNumFiles = "ArgumentOutOfRange_NeedValidMaxNumFiles";

		internal const string ArgumentOutOfRange_NeedValidId = "ArgumentOutOfRange_NeedValidId";

		internal const string ArgumentOutOfRange_MaxArgExceeded = "ArgumentOutOfRange_MaxArgExceeded";

		internal const string ArgumentOutOfRange_MaxStringsExceeded = "ArgumentOutOfRange_MaxStringsExceeded";

		internal const string NotSupported_DownLevelVista = "NotSupported_DownLevelVista";

		internal const string Argument_NeedNonemptyDelimiter = "Argument_NeedNonemptyDelimiter";

		internal const string NotSupported_SetTextWriter = "NotSupported_SetTextWriter";

		internal const string Perflib_PlatformNotSupported = "Perflib_PlatformNotSupported";

		internal const string Perflib_Argument_CounterSetAlreadyRegister = "Perflib_Argument_CounterSetAlreadyRegister";

		internal const string Perflib_Argument_InvalidCounterType = "Perflib_Argument_InvalidCounterType";

		internal const string Perflib_Argument_InvalidCounterSetInstanceType = "Perflib_Argument_InvalidCounterSetInstanceType";

		internal const string Perflib_Argument_InstanceAlreadyExists = "Perflib_Argument_InstanceAlreadyExists";

		internal const string Perflib_Argument_CounterAlreadyExists = "Perflib_Argument_CounterAlreadyExists";

		internal const string Perflib_Argument_CounterNameAlreadyExists = "Perflib_Argument_CounterNameAlreadyExists";

		internal const string Perflib_Argument_ProviderNotFound = "Perflib_Argument_ProviderNotFound";

		internal const string Perflib_Argument_InvalidInstance = "Perflib_Argument_InvalidInstance";

		internal const string Perflib_Argument_EmptyInstanceName = "Perflib_Argument_EmptyInstanceName";

		internal const string Perflib_Argument_EmptyCounterName = "Perflib_Argument_EmptyCounterName";

		internal const string Perflib_InsufficientMemory_InstanceCounterBlock = "Perflib_InsufficientMemory_InstanceCounterBlock";

		internal const string Perflib_InsufficientMemory_CounterSetTemplate = "Perflib_InsufficientMemory_CounterSetTemplate";

		internal const string Perflib_InvalidOperation_CounterRefValue = "Perflib_InvalidOperation_CounterRefValue";

		internal const string Perflib_InvalidOperation_CounterSetNotInstalled = "Perflib_InvalidOperation_CounterSetNotInstalled";

		internal const string Perflib_InvalidOperation_InstanceNotFound = "Perflib_InvalidOperation_InstanceNotFound";

		internal const string Perflib_InvalidOperation_AddCounterAfterInstance = "Perflib_InvalidOperation_AddCounterAfterInstance";

		internal const string Perflib_InvalidOperation_NoActiveProvider = "Perflib_InvalidOperation_NoActiveProvider";

		internal const string Perflib_InvalidOperation_CounterSetContainsNoCounter = "Perflib_InvalidOperation_CounterSetContainsNoCounter";

		internal const string Arg_ArrayPlusOffTooSmall = "Arg_ArrayPlusOffTooSmall";

		internal const string Arg_HSCapacityOverflow = "Arg_HSCapacityOverflow";

		internal const string InvalidOperation_EnumFailedVersion = "InvalidOperation_EnumFailedVersion";

		internal const string InvalidOperation_EnumOpCantHappen = "InvalidOperation_EnumOpCantHappen";

		internal const string Serialization_MissingKeys = "Serialization_MissingKeys";

		internal const string LockRecursionException_RecursiveReadNotAllowed = "LockRecursionException_RecursiveReadNotAllowed";

		internal const string LockRecursionException_RecursiveWriteNotAllowed = "LockRecursionException_RecursiveWriteNotAllowed";

		internal const string LockRecursionException_RecursiveUpgradeNotAllowed = "LockRecursionException_RecursiveUpgradeNotAllowed";

		internal const string LockRecursionException_ReadAfterWriteNotAllowed = "LockRecursionException_ReadAfterWriteNotAllowed";

		internal const string LockRecursionException_WriteAfterReadNotAllowed = "LockRecursionException_WriteAfterReadNotAllowed";

		internal const string LockRecursionException_UpgradeAfterReadNotAllowed = "LockRecursionException_UpgradeAfterReadNotAllowed";

		internal const string LockRecursionException_UpgradeAfterWriteNotAllowed = "LockRecursionException_UpgradeAfterWriteNotAllowed";

		internal const string SynchronizationLockException_MisMatchedRead = "SynchronizationLockException_MisMatchedRead";

		internal const string SynchronizationLockException_MisMatchedWrite = "SynchronizationLockException_MisMatchedWrite";

		internal const string SynchronizationLockException_MisMatchedUpgrade = "SynchronizationLockException_MisMatchedUpgrade";

		internal const string SynchronizationLockException_IncorrectDispose = "SynchronizationLockException_IncorrectDispose";

		internal const string Cryptography_ArgECDHKeySizeMismatch = "Cryptography_ArgECDHKeySizeMismatch";

		internal const string Cryptography_ArgECDHRequiresECDHKey = "Cryptography_ArgECDHRequiresECDHKey";

		internal const string Cryptography_ArgECDsaRequiresECDsaKey = "Cryptography_ArgECDsaRequiresECDsaKey";

		internal const string Cryptography_ArgExpectedECDiffieHellmanCngPublicKey = "Cryptography_ArgExpectedECDiffieHellmanCngPublicKey";

		internal const string Cryptography_ArgMustBeCngAlgorithm = "Cryptography_ArgMustBeCngAlgorithm";

		internal const string Cryptography_ArgMustBeCngAlgorithmGroup = "Cryptography_ArgMustBeCngAlgorithmGroup";

		internal const string Cryptography_ArgMustBeCngKeyBlobFormat = "Cryptography_ArgMustBeCngKeyBlobFormat";

		internal const string Cryptography_ArgMustBeCngProvider = "Cryptography_ArgMustBeCngProvider";

		internal const string Cryptography_DecryptWithNoKey = "Cryptography_DecryptWithNoKey";

		internal const string Cryptography_ECXmlSerializationFormatRequired = "Cryptography_ECXmlSerializationFormatRequired";

		internal const string Cryptography_InvalidAlgorithmGroup = "Cryptography_InvalidAlgorithmGroup";

		internal const string Cryptography_InvalidAlgorithmName = "Cryptography_InvalidAlgorithmName";

		internal const string Cryptography_InvalidCipherMode = "Cryptography_InvalidCipherMode";

		internal const string Cryptography_InvalidIVSize = "Cryptography_InvalidIVSize";

		internal const string Cryptography_InvalidKeyBlobFormat = "Cryptography_InvalidKeyBlobFormat";

		internal const string Cryptography_InvalidKeySize = "Cryptography_InvalidKeySize";

		internal const string Cryptography_InvalidPadding = "Cryptography_InvalidPadding";

		internal const string Cryptography_InvalidProviderName = "Cryptography_InvalidProviderName";

		internal const string Cryptography_MissingDomainParameters = "Cryptography_MissingDomainParameters";

		internal const string Cryptography_MissingPublicKey = "Cryptography_MissingPublicKey";

		internal const string Cryptography_MissingIV = "Cryptography_MissingIV";

		internal const string Cryptography_MustTransformWholeBlock = "Cryptography_MustTransformWholeBlock";

		internal const string Cryptography_NonCompliantFIPSAlgorithm = "Cryptography_NonCompliantFIPSAlgorithm";

		internal const string Cryptography_OpenInvalidHandle = "Cryptography_OpenInvalidHandle";

		internal const string Cryptography_OpenEphemeralKeyHandleWithoutEphemeralFlag = "Cryptography_OpenEphemeralKeyHandleWithoutEphemeralFlag";

		internal const string Cryptography_PartialBlock = "Cryptography_PartialBlock";

		internal const string Cryptography_PlatformNotSupported = "Cryptography_PlatformNotSupported";

		internal const string Cryptography_TlsRequiresLabelAndSeed = "Cryptography_TlsRequiresLabelAndSeed";

		internal const string Cryptography_TransformBeyondEndOfBuffer = "Cryptography_TransformBeyondEndOfBuffer";

		internal const string Cryptography_UnknownEllipticCurve = "Cryptography_UnknownEllipticCurve";

		internal const string Cryptography_UnknownEllipticCurveAlgorithm = "Cryptography_UnknownEllipticCurveAlgorithm";

		internal const string Cryptography_UnknownPaddingMode = "Cryptography_UnknownPaddingMode";

		internal const string Cryptography_UnexpectedXmlNamespace = "Cryptography_UnexpectedXmlNamespace";

		private static SR loader;

		private ResourceManager resources;

		private static CultureInfo Culture => null;

		public static ResourceManager Resources => GetLoader().resources;

		internal SR()
		{
			resources = new ResourceManager("System.Core", GetType().Assembly);
		}

		private static SR GetLoader()
		{
			if (loader == null)
			{
				SR value = new SR();
				Interlocked.CompareExchange(ref loader, value, null);
			}
			return loader;
		}

		public static string GetString(string name, params object[] args)
		{
			SR sR = GetLoader();
			if (sR == null)
			{
				return null;
			}
			string @string = sR.resources.GetString(name, Culture);
			if (args != null && args.Length > 0)
			{
				for (int i = 0; i < args.Length; i++)
				{
					if (args[i] is string text && text.Length > 1024)
					{
						args[i] = text.Substring(0, 1021) + "...";
					}
				}
				return string.Format(CultureInfo.CurrentCulture, @string, args);
			}
			return @string;
		}

		public static string GetString(string name)
		{
			return GetLoader()?.resources.GetString(name, Culture);
		}

		public static object GetObject(string name)
		{
			return GetLoader()?.resources.GetObject(name, Culture);
		}
	}
}
namespace System.Linq
{
	[AttributeUsage(AttributeTargets.All)]
	internal sealed class SRDescriptionAttribute : DescriptionAttribute
	{
		private bool replaced;

		public override string Description
		{
			get
			{
				if (!replaced)
				{
					replaced = true;
					base.DescriptionValue = SR.GetString(base.Description);
				}
				return base.Description;
			}
		}

		public SRDescriptionAttribute(string description)
			: base(description)
		{
		}
	}
	[AttributeUsage(AttributeTargets.All)]
	internal sealed class SRCategoryAttribute : CategoryAttribute
	{
		public SRCategoryAttribute(string category)
			: base(category)
		{
		}

		protected override string GetLocalizedString(string value)
		{
			return SR.GetString(value);
		}
	}
	internal sealed class SR
	{
		internal const string OwningTeam = "OwningTeam";

		internal const string ArgumentArrayHasTooManyElements = "ArgumentArrayHasTooManyElements";

		internal const string ArgumentNotIEnumerableGeneric = "ArgumentNotIEnumerableGeneric";

		internal const string ArgumentNotSequence = "ArgumentNotSequence";

		internal const string ArgumentNotValid = "ArgumentNotValid";

		internal const string IncompatibleElementTypes = "IncompatibleElementTypes";

		internal const string ArgumentNotLambda = "ArgumentNotLambda";

		internal const string MoreThanOneElement = "MoreThanOneElement";

		internal const string MoreThanOneMatch = "MoreThanOneMatch";

		internal const string NoArgumentMatchingMethodsInQueryable = "NoArgumentMatchingMethodsInQueryable";

		internal const string NoElements = "NoElements";

		internal const string NoMatch = "NoMatch";

		internal const string NoMethodOnType = "NoMethodOnType";

		internal const string NoMethodOnTypeMatchingArguments = "NoMethodOnTypeMatchingArguments";

		internal const string NoNameMatchingMethodsInQueryable = "NoNameMatchingMethodsInQueryable";

		internal const string EmptyEnumerable = "EmptyEnumerable";

		private static SR loader;

		private ResourceManager resources;

		private static CultureInfo Culture => null;

		public static ResourceManager Resources => GetLoader().resources;

		internal SR()
		{
			resources = new ResourceManager("System.Linq", GetType().Assembly);
		}

		private static SR GetLoader()
		{
			if (loader == null)
			{
				SR value = new SR();
				Interlocked.CompareExchange(ref loader, value, null);
			}
			return loader;
		}

		public static string GetString(string name, params object[] args)
		{
			SR sR = GetLoader();
			if (sR == null)
			{
				return null;
			}
			string @string = sR.resources.GetString(name, Culture);
			if (args != null && args.Length > 0)
			{
				for (int i = 0; i < args.Length; i++)
				{
					if (args[i] is string text && text.Length > 1024)
					{
						args[i] = text.Substring(0, 1021) + "...";
					}
				}
				return string.Format(CultureInfo.CurrentCulture, @string, args);
			}
			return @string;
		}

		public static string GetString(string name)
		{
			return GetLoader()?.resources.GetString(name, Culture);
		}

		public static object GetObject(string name)
		{
			return GetLoader()?.resources.GetObject(name, Culture);
		}
	}
}
namespace System.Linq.Expressions
{
	[AttributeUsage(AttributeTargets.All)]
	internal sealed class SRDescriptionAttribute : DescriptionAttribute
	{
		private bool replaced;

		public override string Description
		{
			get
			{
				if (!replaced)
				{
					replaced = true;
					base.DescriptionValue = SR.GetString(base.Description);
				}
				return base.Description;
			}
		}

		public SRDescriptionAttribute(string description)
			: base(description)
		{
		}
	}
	[AttributeUsage(AttributeTargets.All)]
	internal sealed class SRCategoryAttribute : CategoryAttribute
	{
		public SRCategoryAttribute(string category)
			: base(category)
		{
		}

		protected override string GetLocalizedString(string value)
		{
			return SR.GetString(value);
		}
	}
	internal sealed class SR
	{
		internal const string OwningTeam = "OwningTeam";

		internal const string UserDefinedOperatorMustBeStatic = "UserDefinedOperatorMustBeStatic";

		internal const string UserDefinedOperatorMustNotBeVoid = "UserDefinedOperatorMustNotBeVoid";

		internal const string CoercionOperatorNotDefined = "CoercionOperatorNotDefined";

		internal const string UnaryOperatorNotDefined = "UnaryOperatorNotDefined";

		internal const string BinaryOperatorNotDefined = "BinaryOperatorNotDefined";

		internal const string OperandTypesDoNotMatchParameters = "OperandTypesDoNotMatchParameters";

		internal const string ArgumentMustBeArray = "ArgumentMustBeArray";

		internal const string ArgumentMustBeBoolean = "ArgumentMustBeBoolean";

		internal const string ArgumentMustBeComparable = "ArgumentMustBeComparable";

		internal const string ArgumentMustBeConvertible = "ArgumentMustBeConvertible";

		internal const string ArgumentMustBeFieldInfoOrPropertInfo = "ArgumentMustBeFieldInfoOrPropertInfo";

		internal const string ArgumentMustBeFieldInfoOrPropertInfoOrMethod = "ArgumentMustBeFieldInfoOrPropertInfoOrMethod";

		internal const string ArgumentMustBeInstanceMember = "ArgumentMustBeInstanceMember";

		internal const string ArgumentMustBeInteger = "ArgumentMustBeInteger";

		internal const string ArgumentMustBeInt32 = "ArgumentMustBeInt32";

		internal const string ArgumentMustBeCheckable = "ArgumentMustBeCheckable";

		internal const string ArgumentMustBeArrayIndexType = "ArgumentMustBeArrayIndexType";

		internal const string ArgumentMustBeIntegerOrBoolean = "ArgumentMustBeIntegerOrBoolean";

		internal const string ArgumentMustBeNumeric = "ArgumentMustBeNumeric";

		internal const string ArgumentMustBeSingleDimensionalArrayType = "ArgumentMustBeSingleDimensionalArrayType";

		internal const string ArgumentTypesMustMatch = "ArgumentTypesMustMatch";

		internal const string CannotAutoInitializeValueTypeElementThroughProperty = "CannotAutoInitializeValueTypeElementThroughProperty";

		internal const string CannotAutoInitializeValueTypeMemberThroughProperty = "CannotAutoInitializeValueTypeMemberThroughProperty";

		internal const string CannotCastTypeToType = "CannotCastTypeToType";

		internal const string IncorrectTypeForTypeAs = "IncorrectTypeForTypeAs";

		internal const string CoalesceUsedOnNonNullType = "CoalesceUsedOnNonNullType";

		internal const string ExpressionTypeCannotInitializeCollectionType = "ExpressionTypeCannotInitializeCollectionType";

		internal const string ExpressionTypeCannotInitializeArrayType = "ExpressionTypeCannotInitializeArrayType";

		internal const string ExpressionTypeDoesNotMatchArrayType = "ExpressionTypeDoesNotMatchArrayType";

		internal const string ExpressionTypeDoesNotMatchConstructorParameter = "ExpressionTypeDoesNotMatchConstructorParameter";

		internal const string ArgumentTypeDoesNotMatchMember = "ArgumentTypeDoesNotMatchMember";

		internal const string ArgumentMemberNotDeclOnType = "ArgumentMemberNotDeclOnType";

		internal const string ExpressionTypeDoesNotMatchMethodParameter = "ExpressionTypeDoesNotMatchMethodParameter";

		internal const string ExpressionTypeDoesNotMatchParameter = "ExpressionTypeDoesNotMatchParameter";

		internal const string ExpressionTypeDoesNotMatchReturn = "ExpressionTypeDoesNotMatchReturn";

		internal const string ExpressionTypeNotInvocable = "ExpressionTypeNotInvocable";

		internal const string FieldNotDefinedForType = "FieldNotDefinedForType";

		internal const string IncorrectNumberOfIndexes = "IncorrectNumberOfIndexes";

		internal const string IncorrectNumberOfLambdaArguments = "IncorrectNumberOfLambdaArguments";

		internal const string IncorrectNumberOfLambdaDeclarationParameters = "IncorrectNumberOfLambdaDeclarationParameters";

		internal const string IncorrectNumberOfMethodCallArguments = "IncorrectNumberOfMethodCallArguments";

		internal const string IncorrectNumberOfConstructorArguments = "IncorrectNumberOfConstructorArguments";

		internal const string IncorrectNumberOfMembersForGivenConstructor = "IncorrectNumberOfMembersForGivenConstructor";

		internal const string IncorrectNumberOfArgumentsForMembers = "IncorrectNumberOfArgumentsForMembers";

		internal const string LambdaParameterNotInScope = "LambdaParameterNotInScope";

		internal const string LambdaTypeMustBeDerivedFromSystemDelegate = "LambdaTypeMustBeDerivedFromSystemDelegate";

		internal const string MemberNotFieldOrProperty = "MemberNotFieldOrProperty";

		internal const string MethodContainsGenericParameters = "MethodContainsGenericParameters";

		internal const string MethodIsGeneric = "MethodIsGeneric";

		internal const string MethodNotPropertyAccessor = "MethodNotPropertyAccessor";

		internal const string PropertyDoesNotHaveGetter = "PropertyDoesNotHaveGetter";

		internal const string PropertyDoesNotHaveSetter = "PropertyDoesNotHaveSetter";

		internal const string NotAMemberOfType = "NotAMemberOfType";

		internal const string OperatorNotImplementedForType = "OperatorNotImplementedForType";

		internal const string ParameterExpressionNotValidAsDelegate = "ParameterExpressionNotValidAsDelegate";

		internal const string ParameterNotCaptured = "ParameterNotCaptured";

		internal const string PropertyNotDefinedForType = "PropertyNotDefinedForType";

		internal const string MethodNotDefinedForType = "MethodNotDefinedForType";

		internal const string TypeContainsGenericParameters = "TypeContainsGenericParameters";

		internal const string TypeIsGeneric = "TypeIsGeneric";

		internal const string TypeMissingDefaultConstructor = "TypeMissingDefaultConstructor";

		internal const string ListInitializerWithZeroMembers = "ListInitializerWithZeroMembers";

		internal const string ElementInitializerMethodNotAdd = "ElementInitializerMethodNotAdd";

		internal const string ElementInitializerMethodNoRefOutParam = "ElementInitializerMethodNoRefOutParam";

		internal const string ElementInitializerMethodWithZeroArgs = "ElementInitializerMethodWithZeroArgs";

		internal const string ElementInitializerMethodStatic = "ElementInitializerMethodStatic";

		internal const string TypeNotIEnumerable = "TypeNotIEnumerable";

		internal const string TypeParameterIsNotDelegate = "TypeParameterIsNotDelegate";

		internal const string UnexpectedCoalesceOperator = "UnexpectedCoalesceOperator";

		internal const string InvalidCast = "InvalidCast";

		internal const string UnhandledCall = "UnhandledCall";

		internal const string UnhandledBinary = "UnhandledBinary";

		internal const string UnhandledBinding = "UnhandledBinding";

		internal const string UnhandledBindingType = "UnhandledBindingType";

		internal const string UnhandledConvert = "UnhandledConvert";

		internal const string UnhandledConvertFromDecimal = "UnhandledConvertFromDecimal";

		internal const string UnhandledConvertToDecimal = "UnhandledConvertToDecimal";

		internal const string UnhandledExpressionType = "UnhandledExpressionType";

		internal const string UnhandledMemberAccess = "UnhandledMemberAccess";

		internal const string UnhandledUnary = "UnhandledUnary";

		internal const string UnknownBindingType = "UnknownBindingType";

		internal const string LogicalOperatorMustHaveConsistentTypes = "LogicalOperatorMustHaveConsistentTypes";

		internal const string LogicalOperatorMustHaveBooleanOperators = "LogicalOperatorMustHaveBooleanOperators";

		internal const string MethodDoesNotExistOnType = "MethodDoesNotExistOnType";

		internal const string MethodWithArgsDoesNotExistOnType = "MethodWithArgsDoesNotExistOnType";

		internal const string MethodWithMoreThanOneMatch = "MethodWithMoreThanOneMatch";

		internal const string IncorrectNumberOfTypeArgsForFunc = "IncorrectNumberOfTypeArgsForFunc";

		internal const string IncorrectNumberOfTypeArgsForAction = "IncorrectNumberOfTypeArgsForAction";

		internal const string ExpressionMayNotContainByrefParameters = "ExpressionMayNotContainByrefParameters";

		internal const string ArgumentCannotBeOfTypeVoid = "ArgumentCannotBeOfTypeVoid";

		private static SR loader;

		private ResourceManager resources;

		private static CultureInfo Culture => null;

		public static ResourceManager Resources => GetLoader().resources;

		internal SR()
		{
			resources = new ResourceManager("System.Linq.Expressions", GetType().Assembly);
		}

		private static SR GetLoader()
		{
			if (loader == null)
			{
				SR value = new SR();
				Interlocked.CompareExchange(ref loader, value, null);
			}
			return loader;
		}

		public static string GetString(string name, params object[] args)
		{
			SR sR = GetLoader();
			if (sR == null)
			{
				return null;
			}
			string @string = sR.resources.GetString(name, Culture);
			if (args != null && args.Length > 0)
			{
				for (int i = 0; i < args.Length; i++)
				{
					if (args[i] is string text && text.Length > 1024)
					{
						args[i] = text.Substring(0, 1021) + "...";
					}
				}
				return string.Format(CultureInfo.CurrentCulture, @string, args);
			}
			return @string;
		}

		public static string GetString(string name)
		{
			return GetLoader()?.resources.GetString(name, Culture);
		}

		public static object GetObject(string name)
		{
			return GetLoader()?.resources.GetObject(name, Culture);
		}
	}
}
namespace System
{
	[GeneratedCode("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
	[CompilerGenerated]
	[DebuggerNonUserCode]
	internal class Res
	{
		private static ResourceManager resourceMan;

		private static CultureInfo resourceCulture;

		[EditorBrowsable(EditorBrowsableState.Advanced)]
		internal static ResourceManager ResourceManager
		{
			get
			{
				if (object.ReferenceEquals(resourceMan, null))
				{
					ResourceManager resourceManager = (resourceMan = new ResourceManager("System.Res", typeof(Res).Assembly));
				}
				return resourceMan;
			}
		}

		[EditorBrowsable(EditorBrowsableState.Advanced)]
		internal static CultureInfo Culture
		{
			get
			{
				return resourceCulture;
			}
			set
			{
				resourceCulture = value;
			}
		}

		internal static string BigIntInfinity => ResourceManager.GetString("BigIntInfinity", resourceCulture);

		internal static string InvalidCharactersInString => ResourceManager.GetString("InvalidCharactersInString", resourceCulture);

		internal static string MustBeBigInt => ResourceManager.GetString("MustBeBigInt", resourceCulture);

		internal static string MustBePositive => ResourceManager.GetString("MustBePositive", resourceCulture);

		internal static string NonNegative => ResourceManager.GetString("NonNegative", resourceCulture);

		internal static string NotANumber => ResourceManager.GetString("NotANumber", resourceCulture);

		internal static string Overflow_Byte => ResourceManager.GetString("Overflow_Byte", resourceCulture);

		internal static string Overflow_Decimal => ResourceManager.GetString("Overflow_Decimal", resourceCulture);

		internal static string Overflow_Double => ResourceManager.GetString("Overflow_Double", resourceCulture);

		internal static string Overflow_Int16 => ResourceManager.GetString("Overflow_Int16", resourceCulture);

		internal static string Overflow_Int32 => ResourceManager.GetString("Overflow_Int32", resourceCulture);

		internal static string Overflow_Int64 => ResourceManager.GetString("Overflow_Int64", resourceCulture);

		internal static string Overflow_SByte => ResourceManager.GetString("Overflow_SByte", resourceCulture);

		internal static string Overflow_Single => ResourceManager.GetString("Overflow_Single", resourceCulture);

		internal static string Overflow_UInt16 => ResourceManager.GetString("Overflow_UInt16", resourceCulture);

		internal static string Overflow_UInt32 => ResourceManager.GetString("Overflow_UInt32", resourceCulture);

		internal static string Overflow_UInt64 => ResourceManager.GetString("Overflow_UInt64", resourceCulture);

		internal static string ParsedStringWasInvalid => ResourceManager.GetString("ParsedStringWasInvalid", resourceCulture);

		internal static string UnsupportedNumberStyle => ResourceManager.GetString("UnsupportedNumberStyle", resourceCulture);

		internal Res()
		{
		}
	}
}
