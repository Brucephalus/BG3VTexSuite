
// C:\WINDOWS\assembly\GAC_MSIL\System.Data.SqlXml\2.0.0.0__b77a5c561934e089\System.Data.SqlXml.dll
// System.Data.SqlXml, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089
// Global type: <Module>
// Architecture: AnyCPU (64-bit preferred)
// Runtime: v2.0.50727
// This assembly is signed with a strong name key.
// Hash algorithm: SHA1
// Public key: 00000000000000000400000000000000

using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Configuration;
using System.Diagnostics;
using System.Diagnostics.SymbolStore;
using System.Globalization;
using System.IO;
using System.Reflection;
using System.Reflection.Emit;
using System.Resources;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Security;
using System.Security.Permissions;
using System.Security.Policy;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml.Schema;
using System.Xml.Utils;
using System.Xml.XmlConfiguration;
using System.Xml.XPath;
using System.Xml.Xsl.IlGen;
using System.Xml.Xsl.Qil;
using System.Xml.Xsl.Runtime;
using System.Xml.Xsl.XPath;
using System.Xml.Xsl.Xslt;
using System.Xml.Xsl.XsltOld.Debugger;
using Microsoft.CSharp;
using Microsoft.VisualBasic;
using MS.Internal.Xml.XPath;

[assembly: AssemblyDescription("System.Data.SqlXml.dll")]
[assembly: AllowPartiallyTrustedCallers]
[assembly: AssemblyDefaultAlias("System.Data.SqlXml.dll")]
[assembly: AssemblyTitle("System.Data.SqlXml.dll")]
[assembly: CLSCompliant(true)]
[assembly: ComVisible(false)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: CompilationRelaxations(8)]
[assembly: AssemblyDelaySign(true)]
[assembly: NeutralResourcesLanguage("en-US")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: Dependency("System.Xml,", LoadHint.Always)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: AssemblyKeyFile("f:\\dd\\Tools\\devdiv\\EcmaPublicKey.snk")]
[assembly: AssemblyInformationalVersion("2.0.50727.9149")]
[assembly: AssemblyProduct("Microsoft® .NET Framework")]
[assembly: SatelliteContractVersion("2.0.0.0")]
[assembly: InternalsVisibleTo("System.Xml, PublicKey=00000000000000000400000000000000")]
[assembly: AssemblyFileVersion("2.0.50727.9149")]
[assembly: AssemblyCopyright("© Microsoft Corporation.  All rights reserved.")]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
[assembly: AssemblyVersion("2.0.0.0")]
[module: UnverifiableCode]
namespace System.Xml.Utils
{
	[AttributeUsage(AttributeTargets.All)]
	internal sealed class ResDescriptionAttribute : DescriptionAttribute
	{
		private bool replaced;

		public override string Description
		{
			get
			{
				if (!replaced)
				{
					replaced = true;
					base.DescriptionValue = Res.GetString(base.Description);
				}
				return base.Description;
			}
		}

		public ResDescriptionAttribute(string description)
			: base(description)
		{
		}
	}
	[AttributeUsage(AttributeTargets.All)]
	internal sealed class ResCategoryAttribute : CategoryAttribute
	{
		public ResCategoryAttribute(string category)
			: base(category)
		{
		}

		protected override string GetLocalizedString(string value)
		{
			return Res.GetString(value);
		}
	}
	internal sealed class Res
	{
		internal const string Xml_UserException = "Xml_UserException";

		internal const string Xml_ErrorFilePosition = "Xml_ErrorFilePosition";

		internal const string Xml_InvalidOperation = "Xml_InvalidOperation";

		internal const string Xml_EndOfInnerExceptionStack = "Xml_EndOfInnerExceptionStack";

		internal const string XPath_UnclosedString = "XPath_UnclosedString";

		internal const string XPath_ScientificNotation = "XPath_ScientificNotation";

		internal const string XPath_UnexpectedToken = "XPath_UnexpectedToken";

		internal const string XPath_NodeTestExpected = "XPath_NodeTestExpected";

		internal const string XPath_EofExpected = "XPath_EofExpected";

		internal const string XPath_TokenExpected = "XPath_TokenExpected";

		internal const string XPath_UnknownAxis = "XPath_UnknownAxis";

		internal const string XPath_InvalidAxisInPattern = "XPath_InvalidAxisInPattern";

		internal const string XPath_PredicateAfterDot = "XPath_PredicateAfterDot";

		internal const string XPath_PredicateAfterDotDot = "XPath_PredicateAfterDotDot";

		internal const string XPath_NArgsExpected = "XPath_NArgsExpected";

		internal const string XPath_NOrMArgsExpected = "XPath_NOrMArgsExpected";

		internal const string XPath_AtLeastNArgsExpected = "XPath_AtLeastNArgsExpected";

		internal const string XPath_AtMostMArgsExpected = "XPath_AtMostMArgsExpected";

		internal const string XPath_NodeSetArgumentExpected = "XPath_NodeSetArgumentExpected";

		internal const string XPath_NodeSetExpected = "XPath_NodeSetExpected";

		internal const string XPath_RtfInPathExpr = "XPath_RtfInPathExpr";

		internal const string Xslt_WarningAsError = "Xslt_WarningAsError";

		internal const string Xslt_CannotLoadStylesheet = "Xslt_CannotLoadStylesheet";

		internal const string Xslt_WrongStylesheetElement = "Xslt_WrongStylesheetElement";

		internal const string Xslt_WdXslNamespace = "Xslt_WdXslNamespace";

		internal const string Xslt_NotAtTop = "Xslt_NotAtTop";

		internal const string Xslt_UnexpectedElement = "Xslt_UnexpectedElement";

		internal const string Xslt_UnexpectedElementQ = "Xslt_UnexpectedElementQ";

		internal const string Xslt_NullNsAtTopLevel = "Xslt_NullNsAtTopLevel";

		internal const string Xslt_TextNodesNotAllowed = "Xslt_TextNodesNotAllowed";

		internal const string Xslt_NotEmptyContents = "Xslt_NotEmptyContents";

		internal const string Xslt_InvalidAttribute = "Xslt_InvalidAttribute";

		internal const string Xslt_MissingAttribute = "Xslt_MissingAttribute";

		internal const string Xslt_InvalidAttrValue = "Xslt_InvalidAttrValue";

		internal const string Xslt_BistateAttribute = "Xslt_BistateAttribute";

		internal const string Xslt_CharAttribute = "Xslt_CharAttribute";

		internal const string Xslt_CircularInclude = "Xslt_CircularInclude";

		internal const string Xslt_SingleRightBraceInAvt = "Xslt_SingleRightBraceInAvt";

		internal const string Xslt_VariableCntSel2 = "Xslt_VariableCntSel2";

		internal const string Xslt_DupTemplateName = "Xslt_DupTemplateName";

		internal const string Xslt_BothMatchNameAbsent = "Xslt_BothMatchNameAbsent";

		internal const string Xslt_InvalidVariable = "Xslt_InvalidVariable";

		internal const string Xslt_DupGlobalVariable = "Xslt_DupGlobalVariable";

		internal const string Xslt_DupLocalVariable = "Xslt_DupLocalVariable";

		internal const string Xslt_DupNsAlias = "Xslt_DupNsAlias";

		internal const string Xslt_EmptyAttrValue = "Xslt_EmptyAttrValue";

		internal const string Xslt_EmptyNsAlias = "Xslt_EmptyNsAlias";

		internal const string Xslt_UnknownXsltFunction = "Xslt_UnknownXsltFunction";

		internal const string Xslt_UnsupportedXsltFunction = "Xslt_UnsupportedXsltFunction";

		internal const string Xslt_NoAttributeSet = "Xslt_NoAttributeSet";

		internal const string Xslt_UndefinedKey = "Xslt_UndefinedKey";

		internal const string Xslt_CircularAttributeSet = "Xslt_CircularAttributeSet";

		internal const string Xslt_InvalidCallTemplate = "Xslt_InvalidCallTemplate";

		internal const string Xslt_InvalidPrefix = "Xslt_InvalidPrefix";

		internal const string Xslt_ScriptXsltNamespace = "Xslt_ScriptXsltNamespace";

		internal const string Xslt_ScriptInvalidLanguage = "Xslt_ScriptInvalidLanguage";

		internal const string Xslt_ScriptMixedLanguages = "Xslt_ScriptMixedLanguages";

		internal const string Xslt_ScriptCompileException = "Xslt_ScriptCompileException";

		internal const string Xslt_ScriptNotAtTop = "Xslt_ScriptNotAtTop";

		internal const string Xslt_AssemblyBothNameHrefAbsent = "Xslt_AssemblyBothNameHrefAbsent";

		internal const string Xslt_AssemblyBothNameHrefPresent = "Xslt_AssemblyBothNameHrefPresent";

		internal const string Xslt_ScriptAndExtensionClash = "Xslt_ScriptAndExtensionClash";

		internal const string Xslt_NoDecimalFormat = "Xslt_NoDecimalFormat";

		internal const string Xslt_DecimalFormatSignsNotDistinct = "Xslt_DecimalFormatSignsNotDistinct";

		internal const string Xslt_DecimalFormatRedefined = "Xslt_DecimalFormatRedefined";

		internal const string Xslt_UnknownExtensionElement = "Xslt_UnknownExtensionElement";

		internal const string Xslt_ModeWithoutMatch = "Xslt_ModeWithoutMatch";

		internal const string Xslt_PriorityWithoutMatch = "Xslt_PriorityWithoutMatch";

		internal const string Xslt_InvalidApplyImports = "Xslt_InvalidApplyImports";

		internal const string Xslt_DuplicateWithParam = "Xslt_DuplicateWithParam";

		internal const string Xslt_ReservedNS = "Xslt_ReservedNS";

		internal const string Xslt_XmlnsAttr = "Xslt_XmlnsAttr";

		internal const string Xslt_NoWhen = "Xslt_NoWhen";

		internal const string Xslt_WhenAfterOtherwise = "Xslt_WhenAfterOtherwise";

		internal const string Xslt_DupOtherwise = "Xslt_DupOtherwise";

		internal const string Xslt_AttributeRedefinition = "Xslt_AttributeRedefinition";

		internal const string Xslt_InvalidMethod = "Xslt_InvalidMethod";

		internal const string Xslt_InvalidEncoding = "Xslt_InvalidEncoding";

		internal const string Xslt_InvalidLanguage = "Xslt_InvalidLanguage";

		internal const string Xslt_InvalidLanguageTag = "Xslt_InvalidLanguageTag";

		internal const string Xslt_InvalidCompareOption = "Xslt_InvalidCompareOption";

		internal const string Xslt_KeyNotAllowed = "Xslt_KeyNotAllowed";

		internal const string Xslt_VariablesNotAllowed = "Xslt_VariablesNotAllowed";

		internal const string Xslt_CurrentNotAllowed = "Xslt_CurrentNotAllowed";

		internal const string Xslt_DocumentFuncProhibited = "Xslt_DocumentFuncProhibited";

		internal const string Xslt_ScriptsProhibited = "Xslt_ScriptsProhibited";

		internal const string Xslt_ItemNull = "Xslt_ItemNull";

		internal const string Xslt_NodeSetNotNode = "Xslt_NodeSetNotNode";

		internal const string Xslt_UnsupportedClrType = "Xslt_UnsupportedClrType";

		internal const string Coll_BadOptFormat = "Coll_BadOptFormat";

		internal const string Coll_Unsupported = "Coll_Unsupported";

		internal const string Coll_UnsupportedLanguage = "Coll_UnsupportedLanguage";

		internal const string Coll_UnsupportedOpt = "Coll_UnsupportedOpt";

		internal const string Coll_UnsupportedOptVal = "Coll_UnsupportedOptVal";

		internal const string Coll_UnsupportedSortOpt = "Coll_UnsupportedSortOpt";

		internal const string Qil_Validation = "Qil_Validation";

		internal const string XmlIl_TooManyParameters = "XmlIl_TooManyParameters";

		internal const string XmlIl_BadXmlState = "XmlIl_BadXmlState";

		internal const string XmlIl_BadXmlStateAttr = "XmlIl_BadXmlStateAttr";

		internal const string XmlIl_NmspAfterAttr = "XmlIl_NmspAfterAttr";

		internal const string XmlIl_NmspConflict = "XmlIl_NmspConflict";

		internal const string XmlIl_CantResolveEntity = "XmlIl_CantResolveEntity";

		internal const string XmlIl_NoDefaultDocument = "XmlIl_NoDefaultDocument";

		internal const string XmlIl_UnknownDocument = "XmlIl_UnknownDocument";

		internal const string XmlIl_UnknownParam = "XmlIl_UnknownParam";

		internal const string XmlIl_UnknownExtObj = "XmlIl_UnknownExtObj";

		internal const string XmlIl_CantStripNav = "XmlIl_CantStripNav";

		internal const string XmlIl_ExtensionError = "XmlIl_ExtensionError";

		internal const string XmlIl_TopLevelAttrNmsp = "XmlIl_TopLevelAttrNmsp";

		internal const string XmlIl_NoExtensionMethod = "XmlIl_NoExtensionMethod";

		internal const string XmlIl_AmbiguousExtensionMethod = "XmlIl_AmbiguousExtensionMethod";

		internal const string XmlIl_NonPublicExtensionMethod = "XmlIl_NonPublicExtensionMethod";

		internal const string XmlIl_GenericExtensionMethod = "XmlIl_GenericExtensionMethod";

		internal const string XmlIl_ByRefType = "XmlIl_ByRefType";

		internal const string XmlIl_DocumentLoadError = "XmlIl_DocumentLoadError";

		internal const string Xslt_CompileError = "Xslt_CompileError";

		internal const string Xslt_CompileError2 = "Xslt_CompileError2";

		internal const string Xslt_UnsuppFunction = "Xslt_UnsuppFunction";

		internal const string Xslt_NotFirstImport = "Xslt_NotFirstImport";

		internal const string Xslt_UnexpectedKeyword = "Xslt_UnexpectedKeyword";

		internal const string Xslt_InvalidContents = "Xslt_InvalidContents";

		internal const string Xslt_CantResolve = "Xslt_CantResolve";

		internal const string Xslt_SingleRightAvt = "Xslt_SingleRightAvt";

		internal const string Xslt_OpenBracesAvt = "Xslt_OpenBracesAvt";

		internal const string Xslt_OpenLiteralAvt = "Xslt_OpenLiteralAvt";

		internal const string Xslt_NestedAvt = "Xslt_NestedAvt";

		internal const string Xslt_EmptyAvtExpr = "Xslt_EmptyAvtExpr";

		internal const string Xslt_InvalidXPath = "Xslt_InvalidXPath";

		internal const string Xslt_InvalidQName = "Xslt_InvalidQName";

		internal const string Xslt_NoStylesheetLoaded = "Xslt_NoStylesheetLoaded";

		internal const string Xslt_TemplateNoAttrib = "Xslt_TemplateNoAttrib";

		internal const string Xslt_DupVarName = "Xslt_DupVarName";

		internal const string Xslt_WrongNumberArgs = "Xslt_WrongNumberArgs";

		internal const string Xslt_NoNodeSetConversion = "Xslt_NoNodeSetConversion";

		internal const string Xslt_NoNavigatorConversion = "Xslt_NoNavigatorConversion";

		internal const string Xslt_FunctionFailed = "Xslt_FunctionFailed";

		internal const string Xslt_InvalidFormat = "Xslt_InvalidFormat";

		internal const string Xslt_InvalidFormat1 = "Xslt_InvalidFormat1";

		internal const string Xslt_InvalidFormat2 = "Xslt_InvalidFormat2";

		internal const string Xslt_InvalidFormat3 = "Xslt_InvalidFormat3";

		internal const string Xslt_InvalidFormat4 = "Xslt_InvalidFormat4";

		internal const string Xslt_InvalidFormat5 = "Xslt_InvalidFormat5";

		internal const string Xslt_InvalidFormat8 = "Xslt_InvalidFormat8";

		internal const string Xslt_ScriptCompileErrors = "Xslt_ScriptCompileErrors";

		internal const string Xslt_ScriptInvalidPrefix = "Xslt_ScriptInvalidPrefix";

		internal const string Xslt_ScriptDub = "Xslt_ScriptDub";

		internal const string Xslt_ScriptEmpty = "Xslt_ScriptEmpty";

		internal const string Xslt_DupDecimalFormat = "Xslt_DupDecimalFormat";

		internal const string Xslt_CircularReference = "Xslt_CircularReference";

		internal const string Xslt_InvalidExtensionNamespace = "Xslt_InvalidExtensionNamespace";

		internal const string Xslt_InvalidModeAttribute = "Xslt_InvalidModeAttribute";

		internal const string Xslt_MultipleRoots = "Xslt_MultipleRoots";

		internal const string Xslt_ApplyImports = "Xslt_ApplyImports";

		internal const string Xslt_Terminate = "Xslt_Terminate";

		internal const string Xslt_InvalidPattern = "Xslt_InvalidPattern";

		internal const string Xslt_EmptyTagRequired = "Xslt_EmptyTagRequired";

		internal const string Xslt_WrongNamespace = "Xslt_WrongNamespace";

		internal const string Xslt_InvalidFormat6 = "Xslt_InvalidFormat6";

		internal const string Xslt_InvalidFormat7 = "Xslt_InvalidFormat7";

		internal const string Xslt_ScriptMixLang = "Xslt_ScriptMixLang";

		internal const string Xslt_ScriptInvalidLang = "Xslt_ScriptInvalidLang";

		internal const string Xslt_InvalidExtensionPermitions = "Xslt_InvalidExtensionPermitions";

		internal const string Xslt_InvalidParamNamespace = "Xslt_InvalidParamNamespace";

		internal const string Xslt_DuplicateParametr = "Xslt_DuplicateParametr";

		internal const string Xslt_VariableCntSel = "Xslt_VariableCntSel";

		private static Res loader;

		private ResourceManager resources;

		private static object s_InternalSyncObject;

		private static object InternalSyncObject
		{
			get
			{
				if (s_InternalSyncObject == null)
				{
					object value = new object();
					Interlocked.CompareExchange(ref s_InternalSyncObject, value, null);
				}
				return s_InternalSyncObject;
			}
		}

		private static CultureInfo Culture => null;

		public static ResourceManager Resources => GetLoader().resources;

		internal Res()
		{
			resources = new ResourceManager("System.Xml.Utils", GetType().Assembly);
		}

		private static Res GetLoader()
		{
			if (loader == null)
			{
				lock (InternalSyncObject)
				{
					if (loader == null)
					{
						loader = new Res();
					}
				}
			}
			return loader;
		}

		public static string GetString(string name, params object[] args)
		{
			Res res = GetLoader();
			if (res == null)
			{
				return null;
			}
			string @string = res.resources.GetString(name, Culture);
			if (args != null && args.Length > 0)
			{
				for (int i = 0; i < args.Length; i++)
				{
					if (args[i] is string text && text.Length > 1024)
					{
						args[i] = text.Substring(0, 1021) + "...";
					}
				}
				return string.Format(CultureInfo.CurrentCulture, @string, args);
			}
			return @string;
		}

		public static string GetString(string name)
		{
			return GetLoader()?.resources.GetString(name, Culture);
		}

		public static object GetObject(string name)
		{
			return GetLoader()?.resources.GetObject(name, Culture);
		}
	}
}
namespace System.Xml.Xsl
{
	internal interface ISourceLineInfo
	{
		string Uri { get; }

		int StartLine { get; }

		int StartPos { get; }

		int EndLine { get; }

		int EndPos { get; }

		bool IsNoSource { get; }
	}
	internal struct Int32Pair
	{
		private int left;

		private int right;

		public int Left => left;

		public int Right => right;

		public Int32Pair(int left, int right)
		{
			this.left = left;
			this.right = right;
		}

		public override bool Equals(object other)
		{
			if (other is Int32Pair int32Pair)
			{
				if (left == int32Pair.left)
				{
					return right == int32Pair.right;
				}
				return false;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return left.GetHashCode() ^ right.GetHashCode();
		}
	}
	internal struct StringPair
	{
		private string left;

		private string right;

		public string Left => left;

		public string Right => right;

		public StringPair(string left, string right)
		{
			this.left = left;
			this.right = right;
		}
	}
	[DebuggerDisplay("{uriString} [{startLine},{startPos} -- {endLine},{endPos}]")]
	internal class SourceLineInfo : ISourceLineInfo
	{
		private const int NoSourceMagicNumber = 16707566;

		private string uriString;

		private int startLine;

		private int startPos;

		private int endLine;

		private int endPos;

		public static SourceLineInfo NoSource = new SourceLineInfo(string.Empty, 16707566, 0, 16707566, 0);

		public string Uri => uriString;

		public int StartLine => startLine;

		public int StartPos => startPos;

		public int EndLine => endLine;

		public int EndPos => endPos;

		public bool IsNoSource => startLine == 16707566;

		public SourceLineInfo(string uriString, int startLine, int startPos, int endLine, int endPos)
		{
			this.uriString = uriString;
			this.startLine = startLine;
			this.startPos = startPos;
			this.endLine = endLine;
			this.endPos = endPos;
		}

		internal void SetEndLinePos(int endLine, int endPos)
		{
			this.endLine = endLine;
			this.endPos = endPos;
		}

		[Conditional("DEBUG")]
		public static void Validate(ISourceLineInfo lineInfo)
		{
			if (lineInfo.StartLine != 0 && lineInfo.StartLine != 16707566 && lineInfo.StartLine != lineInfo.EndLine)
			{
			}
		}

		public static string GetFileName(string uriString)
		{
			if (uriString.Length != 0 && System.Uri.TryCreate(uriString, UriKind.Absolute, out var result) && result.IsFile)
			{
				return result.LocalPath;
			}
			return uriString;
		}
	}
	internal class QueryReaderSettings
	{
		private bool validatingReader;

		private XmlReaderSettings xmlReaderSettings;

		private XmlNameTable xmlNameTable;

		private EntityHandling entityHandling;

		private bool namespaces;

		private bool normalization;

		private bool prohibitDtd;

		private WhitespaceHandling whitespaceHandling;

		private XmlResolver xmlResolver;

		public XmlNameTable NameTable
		{
			get
			{
				if (xmlReaderSettings == null)
				{
					return xmlNameTable;
				}
				return xmlReaderSettings.NameTable;
			}
		}

		public QueryReaderSettings(XmlNameTable xmlNameTable)
		{
			xmlReaderSettings = new XmlReaderSettings();
			xmlReaderSettings.NameTable = xmlNameTable;
			xmlReaderSettings.ConformanceLevel = ConformanceLevel.Document;
			xmlReaderSettings.XmlResolver = null;
			xmlReaderSettings.ProhibitDtd = true;
			xmlReaderSettings.CloseInput = true;
		}

		public QueryReaderSettings(XmlReader reader)
		{
			if (reader is XmlValidatingReader xmlValidatingReader)
			{
				validatingReader = true;
				reader = xmlValidatingReader.Impl.Reader;
			}
			xmlReaderSettings = reader.Settings;
			if (xmlReaderSettings != null)
			{
				xmlReaderSettings = xmlReaderSettings.Clone();
				xmlReaderSettings.NameTable = reader.NameTable;
				xmlReaderSettings.CloseInput = true;
				xmlReaderSettings.LineNumberOffset = 0;
				xmlReaderSettings.LinePositionOffset = 0;
				if (reader is XmlTextReaderImpl xmlTextReaderImpl)
				{
					xmlReaderSettings.XmlResolver = xmlTextReaderImpl.GetResolver();
				}
				return;
			}
			xmlNameTable = reader.NameTable;
			if (reader is XmlTextReader xmlTextReader)
			{
				XmlTextReaderImpl impl = xmlTextReader.Impl;
				entityHandling = impl.EntityHandling;
				namespaces = impl.Namespaces;
				normalization = impl.Normalization;
				prohibitDtd = impl.ProhibitDtd;
				whitespaceHandling = impl.WhitespaceHandling;
				xmlResolver = impl.GetResolver();
			}
			else
			{
				entityHandling = EntityHandling.ExpandEntities;
				namespaces = true;
				normalization = true;
				prohibitDtd = true;
				whitespaceHandling = WhitespaceHandling.All;
				xmlResolver = null;
			}
		}

		public XmlReader CreateReader(Stream stream, string baseUri)
		{
			XmlReader xmlReader;
			if (xmlReaderSettings != null)
			{
				xmlReader = XmlReader.Create(stream, xmlReaderSettings, baseUri);
			}
			else
			{
				XmlTextReaderImpl xmlTextReaderImpl = new XmlTextReaderImpl(baseUri, stream, xmlNameTable);
				xmlTextReaderImpl.EntityHandling = entityHandling;
				xmlTextReaderImpl.Namespaces = namespaces;
				xmlTextReaderImpl.Normalization = normalization;
				xmlTextReaderImpl.ProhibitDtd = prohibitDtd;
				xmlTextReaderImpl.WhitespaceHandling = whitespaceHandling;
				xmlTextReaderImpl.XmlResolver = xmlResolver;
				xmlReader = xmlTextReaderImpl;
			}
			if (validatingReader)
			{
				xmlReader = new XmlValidatingReader(xmlReader);
			}
			return xmlReader;
		}
	}
	internal abstract class XmlCommand
	{
		public abstract void Execute(IXPathNavigable contextDocument, XmlResolver dataSources, XsltArgumentList argumentList, XmlWriter results);

		public abstract void Execute(IXPathNavigable contextDocument, XmlResolver dataSources, XsltArgumentList argumentList, TextWriter results);

		public abstract void Execute(IXPathNavigable contextDocument, XmlResolver dataSources, XsltArgumentList argumentList, Stream results);

		public abstract void Execute(XmlReader contextDocument, XmlResolver dataSources, XsltArgumentList argumentList, XmlWriter results);

		public abstract void Execute(XmlReader contextDocument, XmlResolver dataSources, XsltArgumentList argumentList, TextWriter results);

		public abstract void Execute(XmlReader contextDocument, XmlResolver dataSources, XsltArgumentList argumentList, Stream results);

		public abstract IList Evaluate(XmlReader contextDocument, XmlResolver dataSources, XsltArgumentList argumentList);
	}
	internal delegate void ExecuteDelegate(XmlQueryRuntime runtime);
	internal class XmlILGenerator
	{
		private QilExpression qil;

		private GenerateHelper helper;

		private XmlILOptimizerVisitor optVisitor;

		private XmlILVisitor xmlIlVisitor;

		private XmlILModule module;

		public XmlILCommand Generate(QilExpression query, TypeBuilder typeBldr)
		{
			qil = query;
			bool useLRE = !qil.IsDebug && typeBldr == null;
			bool isDebug = qil.IsDebug;
			XmlILTrace.WriteQil(qil, "qilbefore.xml");
			XmlILTrace.TraceOptimizations(qil, "qilopt.xml");
			if (XmlILTrace.IsEnabled)
			{
				useLRE = false;
			}
			optVisitor = new XmlILOptimizerVisitor(qil, !qil.IsDebug);
			qil = optVisitor.Optimize();
			XmlILTrace.WriteQil(qil, "qilafter.xml");
			try
			{
				XmlILModule.CreateModulePermissionSet.Assert();
				if (typeBldr != null)
				{
					module = new XmlILModule(typeBldr);
				}
				else
				{
					module = new XmlILModule(useLRE, isDebug);
				}
				helper = new GenerateHelper(module, qil.IsDebug);
				CreateHelperFunctions();
				MethodInfo methExec = module.DefineMethod("Execute", typeof(void), new Type[0], new string[0], XmlILMethodAttributes.NonUser);
				XmlILMethodAttributes xmlAttrs = ((qil.Root.SourceLine == null) ? XmlILMethodAttributes.NonUser : XmlILMethodAttributes.None);
				MethodInfo methRoot = module.DefineMethod("Root", typeof(void), new Type[0], new string[0], xmlAttrs);
				foreach (EarlyBoundInfo earlyBoundType in qil.EarlyBoundTypes)
				{
					helper.StaticData.DeclareEarlyBound(earlyBoundType.NamespaceUri, earlyBoundType.EarlyBoundType);
				}
				CreateFunctionMetadata(qil.FunctionList);
				CreateGlobalValueMetadata(qil.GlobalVariableList);
				CreateGlobalValueMetadata(qil.GlobalParameterList);
				GenerateExecuteFunction(methExec, methRoot);
				xmlIlVisitor = new XmlILVisitor();
				xmlIlVisitor.Visit(qil, helper, methRoot);
				XmlQueryStaticData staticData = new XmlQueryStaticData(qil.DefaultWriterSettings, qil.WhitespaceRules, helper.StaticData);
				if (typeBldr != null)
				{
					CreateTypeInitializer(staticData);
				}
				module.BakeMethods();
				ExecuteDelegate delExec = (ExecuteDelegate)module.CreateDelegate("Execute", typeof(ExecuteDelegate));
				return new XmlILCommand(delExec, staticData);
			}
			finally
			{
				CodeAccessPermission.RevertAssert();
			}
		}

		private void CreateFunctionMetadata(IList<QilNode> funcList)
		{
			foreach (QilFunction func in funcList)
			{
				Type[] array = new Type[func.Arguments.Count];
				string[] array2 = new string[func.Arguments.Count];
				for (int i = 0; i < func.Arguments.Count; i++)
				{
					QilParameter qilParameter = (QilParameter)func.Arguments[i];
					array[i] = XmlILTypeHelper.GetStorageType(qilParameter.XmlType);
					if (qilParameter.DebugName != null)
					{
						array2[i] = qilParameter.DebugName;
					}
				}
				Type returnType = ((!XmlILConstructInfo.Read(func).PushToWriterLast) ? XmlILTypeHelper.GetStorageType(func.XmlType) : typeof(void));
				XmlILMethodAttributes xmlAttrs = ((func.SourceLine == null) ? XmlILMethodAttributes.NonUser : XmlILMethodAttributes.None);
				MethodInfo functionBinding = module.DefineMethod(func.DebugName, returnType, array, array2, xmlAttrs);
				for (int j = 0; j < func.Arguments.Count; j++)
				{
					XmlILAnnotation.Write(func.Arguments[j]).ArgumentPosition = j;
				}
				XmlILAnnotation.Write(func).FunctionBinding = functionBinding;
			}
		}

		private void CreateGlobalValueMetadata(IList<QilNode> globalList)
		{
			foreach (QilReference global in globalList)
			{
				Type storageType = XmlILTypeHelper.GetStorageType(global.XmlType);
				XmlILMethodAttributes xmlAttrs = ((global.SourceLine == null) ? XmlILMethodAttributes.NonUser : XmlILMethodAttributes.None);
				MethodInfo functionBinding = module.DefineMethod(global.DebugName.ToString(), storageType, new Type[0], new string[0], xmlAttrs);
				XmlILAnnotation.Write(global).FunctionBinding = functionBinding;
			}
		}

		private MethodInfo GenerateExecuteFunction(MethodInfo methExec, MethodInfo methRoot)
		{
			helper.MethodBegin(methExec, null, initWriters: false);
			EvaluateGlobalValues(qil.GlobalVariableList);
			EvaluateGlobalValues(qil.GlobalParameterList);
			helper.LoadQueryRuntime();
			helper.Call(methRoot);
			helper.MethodEnd();
			return methExec;
		}

		private void CreateHelperFunctions()
		{
			XmlILModule xmlILModule = module;
			Type typeFromHandle = typeof(XPathNavigator);
			Type[] paramTypes = new Type[2]
			{
				typeof(XPathNavigator),
				typeof(XPathNavigator)
			};
			string[] paramNames = new string[2];
			MethodInfo methInfo = xmlILModule.DefineMethod("SyncToNavigator", typeFromHandle, paramTypes, paramNames, (XmlILMethodAttributes)3);
			helper.MethodBegin(methInfo, null, initWriters: false);
			Label label = helper.DefineLabel();
			helper.Emit(OpCodes.Ldarg_0);
			helper.Emit(OpCodes.Brfalse, label);
			helper.Emit(OpCodes.Ldarg_0);
			helper.Emit(OpCodes.Ldarg_1);
			helper.Call(XmlILMethods.NavMoveTo);
			helper.Emit(OpCodes.Brfalse, label);
			helper.Emit(OpCodes.Ldarg_0);
			helper.Emit(OpCodes.Ret);
			helper.MarkLabel(label);
			helper.Emit(OpCodes.Ldarg_1);
			helper.Call(XmlILMethods.NavClone);
			helper.MethodEnd();
		}

		private void EvaluateGlobalValues(IList<QilNode> iterList)
		{
			foreach (QilIterator iter in iterList)
			{
				if (qil.IsDebug || OptimizerPatterns.Read(iter).MatchesPattern(OptimizerPatternName.MaybeSideEffects))
				{
					MethodInfo functionBinding = XmlILAnnotation.Write(iter).FunctionBinding;
					helper.LoadQueryRuntime();
					helper.Call(functionBinding);
					helper.Emit(OpCodes.Pop);
				}
			}
		}

		public void CreateTypeInitializer(XmlQueryStaticData staticData)
		{
			staticData.GetObjectData(out var data, out var ebTypes);
			FieldInfo fldInfo = module.DefineInitializedData("__staticData", data);
			FieldInfo fldInfo2 = module.DefineField("staticData", typeof(object));
			FieldInfo fldInfo3 = module.DefineField("ebTypes", typeof(Type[]));
			ConstructorInfo methInfo = module.DefineTypeInitializer();
			helper.MethodBegin(methInfo, null, initWriters: false);
			helper.LoadInteger(data.Length);
			helper.Emit(OpCodes.Newarr, typeof(byte));
			helper.Emit(OpCodes.Dup);
			helper.Emit(OpCodes.Ldtoken, fldInfo);
			helper.Call(XmlILMethods.InitializeArray);
			helper.Emit(OpCodes.Stsfld, fldInfo2);
			if (ebTypes != null)
			{
				LocalBuilder locBldr = helper.DeclareLocal("$$$types", typeof(Type[]));
				helper.LoadInteger(ebTypes.Length);
				helper.Emit(OpCodes.Newarr, typeof(Type));
				helper.Emit(OpCodes.Stloc, locBldr);
				for (int i = 0; i < ebTypes.Length; i++)
				{
					helper.Emit(OpCodes.Ldloc, locBldr);
					helper.LoadInteger(i);
					helper.LoadType(ebTypes[i]);
					helper.Emit(OpCodes.Stelem_Ref);
				}
				helper.Emit(OpCodes.Ldloc, locBldr);
				helper.Emit(OpCodes.Stsfld, fldInfo3);
			}
			helper.MethodEnd();
		}
	}
	internal class XmlILCommand : XmlCommand
	{
		private ExecuteDelegate delExec;

		private XmlQueryStaticData staticData;

		public ExecuteDelegate ExecuteDelegate => delExec;

		public XmlQueryStaticData StaticData => staticData;

		public XmlILCommand(ExecuteDelegate delExec, XmlQueryStaticData staticData)
		{
			this.delExec = delExec;
			this.staticData = staticData;
		}

		public override void Execute(IXPathNavigable contextDocument, XmlResolver dataSources, XsltArgumentList argumentList, XmlWriter results)
		{
			if (results == null)
			{
				throw new ArgumentNullException("results");
			}
			if (contextDocument != null)
			{
				Execute(contextDocument.CreateNavigator(), dataSources, argumentList, results, closeWriter: false);
			}
			else
			{
				Execute(null, dataSources, argumentList, results, closeWriter: false);
			}
		}

		public override void Execute(IXPathNavigable contextDocument, XmlResolver dataSources, XsltArgumentList argumentList, TextWriter results)
		{
			if (results == null)
			{
				throw new ArgumentNullException("results");
			}
			Execute(contextDocument, dataSources, argumentList, XmlWriter.Create(results, staticData.DefaultWriterSettings));
		}

		public override void Execute(IXPathNavigable contextDocument, XmlResolver dataSources, XsltArgumentList argumentList, Stream results)
		{
			if (results == null)
			{
				throw new ArgumentNullException("results");
			}
			Execute(contextDocument, dataSources, argumentList, XmlWriter.Create(results, staticData.DefaultWriterSettings));
		}

		public void Execute(string contextDocumentUri, XmlResolver dataSources, XsltArgumentList argumentList, XmlWriter results)
		{
			if (results == null)
			{
				throw new ArgumentNullException("results");
			}
			Execute(contextDocumentUri, dataSources, argumentList, results, closeWriter: false);
		}

		public IList Evaluate(string contextDocumentUri, XmlResolver dataSources, XsltArgumentList argumentList)
		{
			XmlCachedSequenceWriter xmlCachedSequenceWriter = new XmlCachedSequenceWriter();
			Execute(contextDocumentUri, dataSources, argumentList, xmlCachedSequenceWriter);
			return xmlCachedSequenceWriter.ResultSequence;
		}

		public override void Execute(XmlReader contextDocument, XmlResolver dataSources, XsltArgumentList argumentList, XmlWriter results)
		{
			if (results == null)
			{
				throw new ArgumentNullException("results");
			}
			Execute(contextDocument, dataSources, argumentList, results, closeWriter: false);
		}

		public override void Execute(XmlReader contextDocument, XmlResolver dataSources, XsltArgumentList argumentList, TextWriter results)
		{
			if (results == null)
			{
				throw new ArgumentNullException("results");
			}
			Execute(contextDocument, dataSources, argumentList, XmlWriter.Create(results, staticData.DefaultWriterSettings), closeWriter: true);
		}

		public override void Execute(XmlReader contextDocument, XmlResolver dataSources, XsltArgumentList argumentList, Stream results)
		{
			if (results == null)
			{
				throw new ArgumentNullException("results");
			}
			Execute(contextDocument, dataSources, argumentList, XmlWriter.Create(results, staticData.DefaultWriterSettings), closeWriter: true);
		}

		public override IList Evaluate(XmlReader contextDocument, XmlResolver dataSources, XsltArgumentList argumentList)
		{
			XmlCachedSequenceWriter xmlCachedSequenceWriter = new XmlCachedSequenceWriter();
			Execute(contextDocument, dataSources, argumentList, xmlCachedSequenceWriter);
			return xmlCachedSequenceWriter.ResultSequence;
		}

		private void Execute(object defaultDocument, XmlResolver dataSources, XsltArgumentList argumentList, XmlWriter writer, bool closeWriter)
		{
			try
			{
				if (writer is XmlWellFormedWriter xmlWellFormedWriter && xmlWellFormedWriter.WriteState == WriteState.Start && xmlWellFormedWriter.Settings.ConformanceLevel != ConformanceLevel.Document)
				{
					Execute(defaultDocument, dataSources, argumentList, new XmlMergeSequenceWriter(xmlWellFormedWriter.RawWriter));
				}
				else
				{
					Execute(defaultDocument, dataSources, argumentList, new XmlMergeSequenceWriter(new XmlRawWriterWrapper(writer)));
				}
			}
			finally
			{
				if (closeWriter)
				{
					writer.Close();
				}
				else
				{
					writer.Flush();
				}
			}
		}

		private void Execute(object defaultDocument, XmlResolver dataSources, XsltArgumentList argumentList, XmlSequenceWriter results)
		{
			if (dataSources == null)
			{
				dataSources = XmlNullResolver.Singleton;
			}
			delExec(new XmlQueryRuntime(staticData, defaultDocument, dataSources, argumentList, results));
		}
	}
	[Flags]
	internal enum XmlNodeKindFlags
	{
		None = 0,
		Document = 1,
		Element = 2,
		Attribute = 4,
		Text = 8,
		Comment = 0x10,
		PI = 0x20,
		Namespace = 0x40,
		Content = 0x3A,
		Any = 0x7F
	}
	internal class XmlQualifiedNameTest : XmlQualifiedName
	{
		private const string wildcard = "*";

		private bool exclude;

		private static XmlQualifiedNameTest wc = New("*", "*");

		public static XmlQualifiedNameTest Wildcard => wc;

		public bool IsWildcard => (object)this == Wildcard;

		public bool IsNameWildcard => (object)base.Name == "*";

		public bool IsNamespaceWildcard => (object)base.Namespace == "*";

		private XmlQualifiedNameTest(string name, string ns, bool exclude)
			: base(name, ns)
		{
			this.exclude = exclude;
		}

		public static XmlQualifiedNameTest New(string name, string ns)
		{
			if (ns == null && name == null)
			{
				return Wildcard;
			}
			return new XmlQualifiedNameTest((name == null) ? "*" : name, (ns == null) ? "*" : ns, exclude: false);
		}

		private bool IsNameSubsetOf(XmlQualifiedNameTest other)
		{
			if (!other.IsNameWildcard)
			{
				return base.Name == other.Name;
			}
			return true;
		}

		private bool IsNamespaceSubsetOf(XmlQualifiedNameTest other)
		{
			if (!other.IsNamespaceWildcard && (exclude != other.exclude || !(base.Namespace == other.Namespace)))
			{
				if (other.exclude && !exclude)
				{
					return base.Namespace != other.Namespace;
				}
				return false;
			}
			return true;
		}

		public bool IsSubsetOf(XmlQualifiedNameTest other)
		{
			if (IsNameSubsetOf(other))
			{
				return IsNamespaceSubsetOf(other);
			}
			return false;
		}

		public bool HasIntersection(XmlQualifiedNameTest other)
		{
			if (IsNamespaceSubsetOf(other) || other.IsNamespaceSubsetOf(this))
			{
				if (!IsNameSubsetOf(other))
				{
					return other.IsNameSubsetOf(this);
				}
				return true;
			}
			return false;
		}

		public override string ToString()
		{
			if ((object)this == Wildcard)
			{
				return "*";
			}
			if (base.Namespace.Length == 0)
			{
				return base.Name;
			}
			if ((object)base.Namespace == "*")
			{
				return "*:" + base.Name;
			}
			if (exclude)
			{
				return "{~" + base.Namespace + "}:" + base.Name;
			}
			return "{" + base.Namespace + "}:" + base.Name;
		}
	}
	internal struct XmlQueryCardinality
	{
		private int value;

		private static readonly XmlQueryCardinality[,] cardinalityProduct = new XmlQueryCardinality[8, 8]
		{
			{ None, Zero, None, Zero, None, Zero, None, Zero },
			{ Zero, Zero, Zero, Zero, Zero, Zero, Zero, Zero },
			{ None, Zero, One, ZeroOrOne, More, NotOne, OneOrMore, ZeroOrMore },
			{ Zero, Zero, ZeroOrOne, ZeroOrOne, NotOne, NotOne, ZeroOrMore, ZeroOrMore },
			{ None, Zero, More, NotOne, More, NotOne, More, NotOne },
			{ Zero, Zero, NotOne, NotOne, NotOne, NotOne, NotOne, NotOne },
			{ None, Zero, OneOrMore, ZeroOrMore, More, NotOne, OneOrMore, ZeroOrMore },
			{ Zero, Zero, ZeroOrMore, ZeroOrMore, NotOne, NotOne, ZeroOrMore, ZeroOrMore }
		};

		private static readonly XmlQueryCardinality[,] cardinalitySum = new XmlQueryCardinality[8, 8]
		{
			{ None, Zero, One, ZeroOrOne, More, NotOne, OneOrMore, ZeroOrMore },
			{ Zero, Zero, One, ZeroOrOne, More, NotOne, OneOrMore, ZeroOrMore },
			{ One, One, More, OneOrMore, More, OneOrMore, More, OneOrMore },
			{ ZeroOrOne, ZeroOrOne, OneOrMore, ZeroOrMore, More, ZeroOrMore, OneOrMore, ZeroOrMore },
			{ More, More, More, More, More, More, More, More },
			{ NotOne, NotOne, OneOrMore, ZeroOrMore, More, NotOne, OneOrMore, ZeroOrMore },
			{ OneOrMore, OneOrMore, More, OneOrMore, More, OneOrMore, More, OneOrMore },
			{ ZeroOrMore, ZeroOrMore, OneOrMore, ZeroOrMore, More, ZeroOrMore, OneOrMore, ZeroOrMore }
		};

		private static readonly string[] toString = new string[8] { "", "?", "", "?", "+", "*", "+", "*" };

		private static readonly string[] serialized = new string[8] { "None", "Zero", "One", "ZeroOrOne", "More", "NotOne", "OneOrMore", "ZeroOrMore" };

		public static XmlQueryCardinality None => new XmlQueryCardinality(0);

		public static XmlQueryCardinality Zero => new XmlQueryCardinality(1);

		public static XmlQueryCardinality One => new XmlQueryCardinality(2);

		public static XmlQueryCardinality ZeroOrOne => new XmlQueryCardinality(3);

		public static XmlQueryCardinality More => new XmlQueryCardinality(4);

		public static XmlQueryCardinality NotOne => new XmlQueryCardinality(5);

		public static XmlQueryCardinality OneOrMore => new XmlQueryCardinality(6);

		public static XmlQueryCardinality ZeroOrMore => new XmlQueryCardinality(7);

		private XmlQueryCardinality(int value)
		{
			this.value = value;
		}

		public bool Equals(XmlQueryCardinality other)
		{
			return value == other.value;
		}

		public static bool operator ==(XmlQueryCardinality left, XmlQueryCardinality right)
		{
			return left.value == right.value;
		}

		public static bool operator !=(XmlQueryCardinality left, XmlQueryCardinality right)
		{
			return left.value != right.value;
		}

		public override bool Equals(object other)
		{
			if (other is XmlQueryCardinality)
			{
				return Equals((XmlQueryCardinality)other);
			}
			return false;
		}

		public override int GetHashCode()
		{
			return value;
		}

		public static XmlQueryCardinality operator |(XmlQueryCardinality left, XmlQueryCardinality right)
		{
			return new XmlQueryCardinality(left.value | right.value);
		}

		public static XmlQueryCardinality operator &(XmlQueryCardinality left, XmlQueryCardinality right)
		{
			return new XmlQueryCardinality(left.value & right.value);
		}

		public static XmlQueryCardinality operator *(XmlQueryCardinality left, XmlQueryCardinality right)
		{
			return cardinalityProduct[left.value, right.value];
		}

		public static XmlQueryCardinality operator +(XmlQueryCardinality left, XmlQueryCardinality right)
		{
			return cardinalitySum[left.value, right.value];
		}

		public static bool operator <=(XmlQueryCardinality left, XmlQueryCardinality right)
		{
			return (left.value & ~right.value) == 0;
		}

		public static bool operator >=(XmlQueryCardinality left, XmlQueryCardinality right)
		{
			return (right.value & ~left.value) == 0;
		}

		public XmlQueryCardinality AtMost()
		{
			return new XmlQueryCardinality(value | (value >> 1) | (value >> 2));
		}

		public bool NeverSubset(XmlQueryCardinality other)
		{
			if (value != 0)
			{
				return (value & other.value) == 0;
			}
			return false;
		}

		public string ToString(string format)
		{
			if (format == "S")
			{
				return serialized[value];
			}
			return ToString();
		}

		public override string ToString()
		{
			return toString[value];
		}

		public XmlQueryCardinality(string s)
		{
			value = 0;
			for (int i = 0; i < serialized.Length; i++)
			{
				if (s == serialized[i])
				{
					value = i;
					break;
				}
			}
		}

		public void GetObjectData(BinaryWriter writer)
		{
			writer.Write((byte)value);
		}

		public XmlQueryCardinality(BinaryReader reader)
			: this(reader.ReadByte())
		{
		}
	}
	internal abstract class XmlQueryType : ListBase<XmlQueryType>
	{
		private enum TypeFlags
		{
			None = 0,
			IsNode = 1,
			IsAtomicValue = 2,
			IsNumeric = 4
		}

		private sealed class BitMatrix
		{
			private ulong[] bits;

			public bool this[int index1, int index2]
			{
				get
				{
					return (bits[index1] & (ulong)(1L << index2)) != 0;
				}
				set
				{
					if (value)
					{
						bits[index1] |= (ulong)(1L << index2);
					}
					else
					{
						bits[index1] &= (ulong)(~(1L << index2));
					}
				}
			}

			public bool this[XmlTypeCode index1, XmlTypeCode index2] => this[(int)index1, (int)index2];

			public BitMatrix(int count)
			{
				bits = new ulong[count];
			}
		}

		private static readonly BitMatrix TypeCodeDerivation;

		private int hashCode;

		private static readonly TypeFlags[] TypeCodeToFlags;

		private static readonly XmlTypeCode[] BaseTypeCodes;

		private static readonly string[] TypeNames;

		public abstract XmlTypeCode TypeCode { get; }

		public abstract XmlQualifiedNameTest NameTest { get; }

		public abstract XmlSchemaType SchemaType { get; }

		public abstract bool IsNillable { get; }

		public abstract XmlNodeKindFlags NodeKinds { get; }

		public abstract bool IsStrict { get; }

		public abstract XmlQueryCardinality Cardinality { get; }

		public abstract XmlQueryType Prime { get; }

		public abstract bool IsNotRtf { get; }

		public abstract bool IsDod { get; }

		public abstract XmlValueConverter ClrMapping { get; }

		public bool IsEmpty => Cardinality <= XmlQueryCardinality.Zero;

		public bool IsSingleton => Cardinality <= XmlQueryCardinality.One;

		public bool MaybeEmpty => XmlQueryCardinality.Zero <= Cardinality;

		public bool MaybeMany => XmlQueryCardinality.More <= Cardinality;

		public bool IsNode => (TypeCodeToFlags[(int)TypeCode] & TypeFlags.IsNode) != 0;

		public bool IsAtomicValue => (TypeCodeToFlags[(int)TypeCode] & TypeFlags.IsAtomicValue) != 0;

		public bool IsNumeric => (TypeCodeToFlags[(int)TypeCode] & TypeFlags.IsNumeric) != 0;

		static XmlQueryType()
		{
			TypeCodeToFlags = new TypeFlags[55]
			{
				(TypeFlags)7,
				TypeFlags.None,
				TypeFlags.IsNode,
				TypeFlags.IsNode,
				TypeFlags.IsNode,
				TypeFlags.IsNode,
				TypeFlags.IsNode,
				TypeFlags.IsNode,
				TypeFlags.IsNode,
				TypeFlags.IsNode,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				(TypeFlags)6,
				(TypeFlags)6,
				(TypeFlags)6,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				(TypeFlags)6,
				(TypeFlags)6,
				(TypeFlags)6,
				(TypeFlags)6,
				(TypeFlags)6,
				(TypeFlags)6,
				(TypeFlags)6,
				(TypeFlags)6,
				(TypeFlags)6,
				(TypeFlags)6,
				(TypeFlags)6,
				(TypeFlags)6,
				(TypeFlags)6,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue
			};
			BaseTypeCodes = new XmlTypeCode[55]
			{
				XmlTypeCode.None,
				XmlTypeCode.Item,
				XmlTypeCode.Item,
				XmlTypeCode.Node,
				XmlTypeCode.Node,
				XmlTypeCode.Node,
				XmlTypeCode.Node,
				XmlTypeCode.Node,
				XmlTypeCode.Node,
				XmlTypeCode.Node,
				XmlTypeCode.Item,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.String,
				XmlTypeCode.NormalizedString,
				XmlTypeCode.Token,
				XmlTypeCode.Token,
				XmlTypeCode.Token,
				XmlTypeCode.Name,
				XmlTypeCode.NCName,
				XmlTypeCode.NCName,
				XmlTypeCode.NCName,
				XmlTypeCode.Decimal,
				XmlTypeCode.Integer,
				XmlTypeCode.NonPositiveInteger,
				XmlTypeCode.Integer,
				XmlTypeCode.Long,
				XmlTypeCode.Int,
				XmlTypeCode.Short,
				XmlTypeCode.Integer,
				XmlTypeCode.NonNegativeInteger,
				XmlTypeCode.UnsignedLong,
				XmlTypeCode.UnsignedInt,
				XmlTypeCode.UnsignedShort,
				XmlTypeCode.NonNegativeInteger,
				XmlTypeCode.Duration,
				XmlTypeCode.Duration
			};
			TypeNames = new string[55]
			{
				"none", "item", "node", "document", "element", "attribute", "namespace", "processing-instruction", "comment", "text",
				"xdt:anyAtomicType", "xdt:untypedAtomic", "xs:string", "xs:boolean", "xs:decimal", "xs:float", "xs:double", "xs:duration", "xs:dateTime", "xs:time",
				"xs:date", "xs:gYearMonth", "xs:gYear", "xs:gMonthDay", "xs:gDay", "xs:gMonth", "xs:hexBinary", "xs:base64Binary", "xs:anyUri", "xs:QName",
				"xs:NOTATION", "xs:normalizedString", "xs:token", "xs:language", "xs:NMTOKEN", "xs:Name", "xs:NCName", "xs:ID", "xs:IDREF", "xs:ENTITY",
				"xs:integer", "xs:nonPositiveInteger", "xs:negativeInteger", "xs:long", "xs:int", "xs:short", "xs:byte", "xs:nonNegativeInteger", "xs:unsignedLong", "xs:unsignedInt",
				"xs:unsignedShort", "xs:unsignedByte", "xs:positiveInteger", "xdt:yearMonthDuration", "xdt:dayTimeDuration"
			};
			TypeCodeDerivation = new BitMatrix(BaseTypeCodes.Length);
			for (int i = 0; i < BaseTypeCodes.Length; i++)
			{
				int num = i;
				while (true)
				{
					TypeCodeDerivation[i, num] = true;
					if (BaseTypeCodes[num] == (XmlTypeCode)num)
					{
						break;
					}
					num = (int)BaseTypeCodes[num];
				}
			}
		}

		public bool IsSubtypeOf(XmlQueryType baseType)
		{
			if (!(Cardinality <= baseType.Cardinality) || (!IsDod && baseType.IsDod))
			{
				return false;
			}
			XmlQueryType prime = Prime;
			XmlQueryType prime2 = baseType.Prime;
			if ((object)prime == prime2)
			{
				return true;
			}
			if (prime.Count == 1 && prime2.Count == 1)
			{
				return prime.IsSubtypeOfItemType(prime2);
			}
			foreach (XmlQueryType item in prime)
			{
				bool flag = false;
				foreach (XmlQueryType item2 in prime2)
				{
					if (item.IsSubtypeOfItemType(item2))
					{
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					return false;
				}
			}
			return true;
		}

		public bool NeverSubtypeOf(XmlQueryType baseType)
		{
			if (Cardinality.NeverSubset(baseType.Cardinality))
			{
				return true;
			}
			if (MaybeEmpty && baseType.MaybeEmpty)
			{
				return false;
			}
			if (Count == 0)
			{
				return false;
			}
			using (IListEnumerator<XmlQueryType> listEnumerator = GetEnumerator())
			{
				while (listEnumerator.MoveNext())
				{
					XmlQueryType current = listEnumerator.Current;
					foreach (XmlQueryType item in baseType)
					{
						if (current.HasIntersectionItemType(item))
						{
							return false;
						}
					}
				}
			}
			return true;
		}

		public bool Equals(XmlQueryType that)
		{
			if (that == null)
			{
				return false;
			}
			if (Cardinality != that.Cardinality || IsDod != that.IsDod)
			{
				return false;
			}
			XmlQueryType prime = Prime;
			XmlQueryType prime2 = that.Prime;
			if ((object)prime == prime2)
			{
				return true;
			}
			if (prime.Count != prime2.Count)
			{
				return false;
			}
			if (prime.Count == 1)
			{
				if (prime.TypeCode == prime2.TypeCode && prime.NameTest == prime2.NameTest && prime.SchemaType == prime2.SchemaType && prime.IsStrict == prime2.IsStrict)
				{
					return prime.IsNotRtf == prime2.IsNotRtf;
				}
				return false;
			}
			using (IListEnumerator<XmlQueryType> listEnumerator = GetEnumerator())
			{
				while (listEnumerator.MoveNext())
				{
					XmlQueryType current = listEnumerator.Current;
					bool flag = false;
					foreach (XmlQueryType item in that)
					{
						if (current.TypeCode == item.TypeCode && current.NameTest == item.NameTest && current.SchemaType == item.SchemaType && current.IsStrict == item.IsStrict && current.IsNotRtf == item.IsNotRtf)
						{
							flag = true;
							break;
						}
					}
					if (!flag)
					{
						return false;
					}
				}
			}
			return true;
		}

		public static bool operator ==(XmlQueryType left, XmlQueryType right)
		{
			return left?.Equals(right) ?? ((object)right == null);
		}

		public static bool operator !=(XmlQueryType left, XmlQueryType right)
		{
			if ((object)left == null)
			{
				return (object)right != null;
			}
			return !left.Equals(right);
		}

		public override bool Equals(object obj)
		{
			XmlQueryType xmlQueryType = obj as XmlQueryType;
			if (xmlQueryType == null)
			{
				return false;
			}
			return Equals(xmlQueryType);
		}

		public override int GetHashCode()
		{
			if (hashCode == 0)
			{
				int num = (int)TypeCode;
				XmlSchemaType schemaType = SchemaType;
				if (schemaType != null)
				{
					num += (num << 7) ^ schemaType.GetHashCode();
				}
				num += (int)((uint)(num << 7) ^ (uint)NodeKinds);
				num += (num << 7) ^ Cardinality.GetHashCode();
				num += (num << 7) ^ (IsStrict ? 1 : 0);
				num -= num >> 17;
				num -= num >> 11;
				num -= num >> 5;
				hashCode = ((num == 0) ? 1 : num);
			}
			return hashCode;
		}

		public override string ToString()
		{
			return ToString("G");
		}

		public string ToString(string format)
		{
			if (format == "S")
			{
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.Append(Cardinality.ToString(format));
				stringBuilder.Append(';');
				for (int i = 0; i < Count; i++)
				{
					if (i != 0)
					{
						stringBuilder.Append("|");
					}
					stringBuilder.Append(this[i].TypeCode.ToString());
				}
				stringBuilder.Append(';');
				stringBuilder.Append(IsStrict);
				return stringBuilder.ToString();
			}
			bool flag = format == "X";
			if (Cardinality == XmlQueryCardinality.None)
			{
				return "none";
			}
			if (Cardinality == XmlQueryCardinality.Zero)
			{
				return "empty";
			}
			switch (Count)
			{
			case 0:
				return "none" + Cardinality.ToString();
			case 1:
				return this[0].ItemTypeToString(flag) + Cardinality.ToString();
			default:
			{
				string[] array = new string[Count];
				for (int j = 0; j < Count; j++)
				{
					array[j] = this[j].ItemTypeToString(flag);
				}
				Array.Sort(array);
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.Append("(");
				stringBuilder.Append(array[0]);
				for (int k = 1; k < array.Length; k++)
				{
					stringBuilder.Append(" | ");
					stringBuilder.Append(array[k]);
				}
				stringBuilder.Append(")");
				stringBuilder.Append(Cardinality.ToString());
				if (!flag && IsDod)
				{
					stringBuilder.Append('#');
				}
				return stringBuilder.ToString();
			}
			}
		}

		public abstract void GetObjectData(BinaryWriter writer);

		private bool IsSubtypeOfItemType(XmlQueryType baseType)
		{
			XmlSchemaType schemaType = baseType.SchemaType;
			if (TypeCode != baseType.TypeCode)
			{
				if (baseType.IsStrict)
				{
					return false;
				}
				XmlSchemaType builtInSimpleType = XmlSchemaType.GetBuiltInSimpleType(baseType.TypeCode);
				if (builtInSimpleType != null && schemaType != builtInSimpleType)
				{
					return false;
				}
				return TypeCodeDerivation[TypeCode, baseType.TypeCode];
			}
			if (baseType.IsStrict)
			{
				if (IsStrict)
				{
					return SchemaType == schemaType;
				}
				return false;
			}
			if ((IsNotRtf || !baseType.IsNotRtf) && (IsDod || !baseType.IsDod) && NameTest.IsSubsetOf(baseType.NameTest) && (schemaType == XmlSchemaComplexType.AnyType || XmlSchemaType.IsDerivedFrom(SchemaType, schemaType, XmlSchemaDerivationMethod.Empty)))
			{
				if (IsNillable)
				{
					return baseType.IsNillable;
				}
				return true;
			}
			return false;
		}

		private bool HasIntersectionItemType(XmlQueryType other)
		{
			if (TypeCode == other.TypeCode && (NodeKinds & (XmlNodeKindFlags.Document | XmlNodeKindFlags.Element | XmlNodeKindFlags.Attribute)) != 0)
			{
				if (TypeCode == XmlTypeCode.Node)
				{
					return true;
				}
				if (!NameTest.HasIntersection(other.NameTest))
				{
					return false;
				}
				if (!XmlSchemaType.IsDerivedFrom(SchemaType, other.SchemaType, XmlSchemaDerivationMethod.Empty) && !XmlSchemaType.IsDerivedFrom(other.SchemaType, SchemaType, XmlSchemaDerivationMethod.Empty))
				{
					return false;
				}
				return true;
			}
			if (IsSubtypeOf(other) || other.IsSubtypeOf(this))
			{
				return true;
			}
			return false;
		}

		private string ItemTypeToString(bool isXQ)
		{
			string text;
			if (!IsNode)
			{
				text = ((SchemaType == XmlSchemaComplexType.AnyType) ? TypeNames[(int)TypeCode] : ((!SchemaType.QualifiedName.IsEmpty) ? QNameToString(SchemaType.QualifiedName) : ("<:" + TypeNames[(int)TypeCode])));
			}
			else
			{
				text = TypeNames[(int)TypeCode];
				switch (TypeCode)
				{
				case XmlTypeCode.Document:
					if (isXQ)
					{
						text = text + "{(element" + NameAndType(isXQ: true) + "?&text?&comment?&processing-instruction?)*}";
						break;
					}
					goto case XmlTypeCode.Element;
				case XmlTypeCode.Element:
				case XmlTypeCode.Attribute:
					text += NameAndType(isXQ);
					break;
				}
			}
			if (!isXQ && IsStrict)
			{
				text += "=";
			}
			return text;
		}

		private string NameAndType(bool isXQ)
		{
			string text = NameTest.ToString();
			string text2 = "*";
			if (SchemaType.QualifiedName.IsEmpty)
			{
				text2 = "typeof(" + text + ")";
			}
			else if (isXQ || (SchemaType != XmlSchemaComplexType.AnyType && SchemaType != DatatypeImplementation.AnySimpleType))
			{
				text2 = QNameToString(SchemaType.QualifiedName);
			}
			if (IsNillable)
			{
				text2 += " nillable";
			}
			if (text == "*" && text2 == "*")
			{
				return "";
			}
			return "(" + text + ", " + text2 + ")";
		}

		private static string QNameToString(XmlQualifiedName name)
		{
			if (name.IsEmpty)
			{
				return "*";
			}
			if (name.Namespace.Length == 0)
			{
				return name.Name;
			}
			if (name.Namespace == "http://www.w3.org/2001/XMLSchema")
			{
				return "xs:" + name.Name;
			}
			if (name.Namespace == "http://www.w3.org/2003/11/xpath-datatypes")
			{
				return "xdt:" + name.Name;
			}
			return "{" + name.Namespace + "}" + name.Name;
		}
	}
	internal static class XmlQueryTypeFactory
	{
		private sealed class ItemType : XmlQueryType
		{
			public static readonly XmlQueryType UntypedDocument;

			public static readonly XmlQueryType UntypedElement;

			public static readonly XmlQueryType UntypedAttribute;

			public static readonly XmlQueryType NodeNotRtf;

			public static readonly XmlQueryType NodeDod;

			private static XmlQueryType[] BuiltInItemTypes;

			private static XmlQueryType[] BuiltInItemTypesStrict;

			private static XmlQueryType[] SpecialBuiltInItemTypes;

			private XmlTypeCode code;

			private XmlQualifiedNameTest nameTest;

			private XmlSchemaType schemaType;

			private bool isNillable;

			private XmlNodeKindFlags nodeKinds;

			private bool isStrict;

			private bool isNotRtf;

			public override XmlTypeCode TypeCode => code;

			public override XmlQualifiedNameTest NameTest => nameTest;

			public override XmlSchemaType SchemaType => schemaType;

			public override bool IsNillable => isNillable;

			public override XmlNodeKindFlags NodeKinds => nodeKinds;

			public override bool IsStrict => isStrict;

			public override bool IsNotRtf => isNotRtf;

			public override bool IsDod => (object)this == NodeDod;

			public override XmlQueryCardinality Cardinality => XmlQueryCardinality.One;

			public override XmlQueryType Prime => this;

			public override XmlValueConverter ClrMapping
			{
				get
				{
					if (base.IsAtomicValue)
					{
						return SchemaType.ValueConverter;
					}
					if (base.IsNode)
					{
						return XmlNodeConverter.Node;
					}
					return XmlAnyConverter.Item;
				}
			}

			public override int Count => 1;

			public override XmlQueryType this[int index]
			{
				get
				{
					if (index != 0)
					{
						throw new IndexOutOfRangeException();
					}
					return this;
				}
				set
				{
					throw new NotSupportedException();
				}
			}

			static ItemType()
			{
				int num = 55;
				BuiltInItemTypes = new XmlQueryType[num];
				BuiltInItemTypesStrict = new XmlQueryType[num];
				for (int i = 0; i < num; i++)
				{
					XmlTypeCode typeCode = (XmlTypeCode)i;
					switch (i)
					{
					case 0:
						BuiltInItemTypes[i] = ChoiceType.None;
						BuiltInItemTypesStrict[i] = ChoiceType.None;
						break;
					case 1:
					case 2:
						BuiltInItemTypes[i] = new ItemType(typeCode, XmlQualifiedNameTest.Wildcard, XmlSchemaComplexType.AnyType, isNillable: false, isStrict: false, isNotRtf: false);
						BuiltInItemTypesStrict[i] = BuiltInItemTypes[i];
						break;
					case 3:
					case 4:
					case 6:
					case 7:
					case 8:
					case 9:
						BuiltInItemTypes[i] = new ItemType(typeCode, XmlQualifiedNameTest.Wildcard, XmlSchemaComplexType.AnyType, isNillable: false, isStrict: false, isNotRtf: true);
						BuiltInItemTypesStrict[i] = BuiltInItemTypes[i];
						break;
					case 5:
						BuiltInItemTypes[i] = new ItemType(typeCode, XmlQualifiedNameTest.Wildcard, DatatypeImplementation.AnySimpleType, isNillable: false, isStrict: false, isNotRtf: true);
						BuiltInItemTypesStrict[i] = BuiltInItemTypes[i];
						break;
					case 10:
						BuiltInItemTypes[i] = new ItemType(typeCode, XmlQualifiedNameTest.Wildcard, DatatypeImplementation.AnyAtomicType, isNillable: false, isStrict: false, isNotRtf: true);
						BuiltInItemTypesStrict[i] = BuiltInItemTypes[i];
						break;
					case 11:
						BuiltInItemTypes[i] = new ItemType(typeCode, XmlQualifiedNameTest.Wildcard, DatatypeImplementation.UntypedAtomicType, isNillable: false, isStrict: true, isNotRtf: true);
						BuiltInItemTypesStrict[i] = BuiltInItemTypes[i];
						break;
					default:
					{
						XmlSchemaType builtInSimpleType = XmlSchemaType.GetBuiltInSimpleType(typeCode);
						BuiltInItemTypes[i] = new ItemType(typeCode, XmlQualifiedNameTest.Wildcard, builtInSimpleType, isNillable: false, isStrict: false, isNotRtf: true);
						BuiltInItemTypesStrict[i] = new ItemType(typeCode, XmlQualifiedNameTest.Wildcard, builtInSimpleType, isNillable: false, isStrict: true, isNotRtf: true);
						break;
					}
					}
				}
				UntypedDocument = new ItemType(XmlTypeCode.Document, XmlQualifiedNameTest.Wildcard, XmlSchemaComplexType.UntypedAnyType, isNillable: false, isStrict: false, isNotRtf: true);
				UntypedElement = new ItemType(XmlTypeCode.Element, XmlQualifiedNameTest.Wildcard, XmlSchemaComplexType.UntypedAnyType, isNillable: false, isStrict: false, isNotRtf: true);
				UntypedAttribute = new ItemType(XmlTypeCode.Attribute, XmlQualifiedNameTest.Wildcard, DatatypeImplementation.UntypedAtomicType, isNillable: false, isStrict: false, isNotRtf: true);
				NodeNotRtf = new ItemType(XmlTypeCode.Node, XmlQualifiedNameTest.Wildcard, XmlSchemaComplexType.AnyType, isNillable: false, isStrict: false, isNotRtf: true);
				NodeDod = new ItemType(XmlTypeCode.Node, XmlQualifiedNameTest.Wildcard, XmlSchemaComplexType.AnyType, isNillable: false, isStrict: false, isNotRtf: true);
				SpecialBuiltInItemTypes = new XmlQueryType[4] { UntypedDocument, UntypedElement, UntypedAttribute, NodeNotRtf };
			}

			public static XmlQueryType Create(XmlTypeCode code, bool isStrict)
			{
				if (isStrict)
				{
					return BuiltInItemTypesStrict[(int)code];
				}
				return BuiltInItemTypes[(int)code];
			}

			public static XmlQueryType Create(XmlSchemaSimpleType schemaType, bool isStrict)
			{
				XmlTypeCode typeCode = schemaType.Datatype.TypeCode;
				if (schemaType == XmlSchemaType.GetBuiltInSimpleType(typeCode))
				{
					return Create(typeCode, isStrict);
				}
				return new ItemType(typeCode, XmlQualifiedNameTest.Wildcard, schemaType, isNillable: false, isStrict, isNotRtf: true);
			}

			public static XmlQueryType Create(XmlTypeCode code, XmlQualifiedNameTest nameTest, XmlSchemaType contentType, bool isNillable)
			{
				switch (code)
				{
				case XmlTypeCode.Document:
				case XmlTypeCode.Element:
					if (nameTest.IsWildcard)
					{
						if (contentType == XmlSchemaComplexType.AnyType)
						{
							return Create(code, isStrict: false);
						}
						if (contentType == XmlSchemaComplexType.UntypedAnyType)
						{
							switch (code)
							{
							case XmlTypeCode.Element:
								return UntypedElement;
							case XmlTypeCode.Document:
								return UntypedDocument;
							}
						}
					}
					return new ItemType(code, nameTest, contentType, isNillable, isStrict: false, isNotRtf: true);
				case XmlTypeCode.Attribute:
					if (nameTest.IsWildcard)
					{
						if (contentType == DatatypeImplementation.AnySimpleType)
						{
							return Create(code, isStrict: false);
						}
						if (contentType == DatatypeImplementation.UntypedAtomicType)
						{
							return UntypedAttribute;
						}
					}
					return new ItemType(code, nameTest, contentType, isNillable, isStrict: false, isNotRtf: true);
				default:
					return Create(code, isStrict: false);
				}
			}

			private ItemType(XmlTypeCode code, XmlQualifiedNameTest nameTest, XmlSchemaType schemaType, bool isNillable, bool isStrict, bool isNotRtf)
			{
				this.code = code;
				this.nameTest = nameTest;
				this.schemaType = schemaType;
				this.isNillable = isNillable;
				this.isStrict = isStrict;
				this.isNotRtf = isNotRtf;
				switch (code)
				{
				case XmlTypeCode.Item:
					nodeKinds = XmlNodeKindFlags.Any;
					break;
				case XmlTypeCode.Node:
					nodeKinds = XmlNodeKindFlags.Any;
					break;
				case XmlTypeCode.Document:
					nodeKinds = XmlNodeKindFlags.Document;
					break;
				case XmlTypeCode.Element:
					nodeKinds = XmlNodeKindFlags.Element;
					break;
				case XmlTypeCode.Attribute:
					nodeKinds = XmlNodeKindFlags.Attribute;
					break;
				case XmlTypeCode.Namespace:
					nodeKinds = XmlNodeKindFlags.Namespace;
					break;
				case XmlTypeCode.ProcessingInstruction:
					nodeKinds = XmlNodeKindFlags.PI;
					break;
				case XmlTypeCode.Comment:
					nodeKinds = XmlNodeKindFlags.Comment;
					break;
				case XmlTypeCode.Text:
					nodeKinds = XmlNodeKindFlags.Text;
					break;
				default:
					nodeKinds = XmlNodeKindFlags.None;
					break;
				}
			}

			public override void GetObjectData(BinaryWriter writer)
			{
				sbyte b = (sbyte)code;
				for (int i = 0; i < SpecialBuiltInItemTypes.Length; i++)
				{
					if ((object)this == SpecialBuiltInItemTypes[i])
					{
						b = (sbyte)(~i);
						break;
					}
				}
				writer.Write(b);
				if (0 <= b)
				{
					writer.Write(isStrict);
				}
			}

			public static XmlQueryType Create(BinaryReader reader)
			{
				sbyte b = reader.ReadSByte();
				if (0 <= b)
				{
					return Create((XmlTypeCode)b, reader.ReadBoolean());
				}
				return SpecialBuiltInItemTypes[~b];
			}
		}

		private sealed class ChoiceType : XmlQueryType
		{
			public static readonly XmlQueryType None = new ChoiceType(new List<XmlQueryType>());

			private XmlTypeCode code;

			private XmlSchemaType schemaType;

			private XmlNodeKindFlags nodeKinds;

			private List<XmlQueryType> members;

			private static readonly XmlTypeCode[] NodeKindToTypeCode = new XmlTypeCode[8]
			{
				XmlTypeCode.None,
				XmlTypeCode.Document,
				XmlTypeCode.Element,
				XmlTypeCode.Attribute,
				XmlTypeCode.Text,
				XmlTypeCode.Comment,
				XmlTypeCode.ProcessingInstruction,
				XmlTypeCode.Namespace
			};

			public override XmlTypeCode TypeCode => code;

			public override XmlQualifiedNameTest NameTest => XmlQualifiedNameTest.Wildcard;

			public override XmlSchemaType SchemaType => schemaType;

			public override bool IsNillable => false;

			public override XmlNodeKindFlags NodeKinds => nodeKinds;

			public override bool IsStrict => members.Count == 0;

			public override bool IsNotRtf
			{
				get
				{
					for (int i = 0; i < members.Count; i++)
					{
						if (!members[i].IsNotRtf)
						{
							return false;
						}
					}
					return true;
				}
			}

			public override bool IsDod
			{
				get
				{
					for (int i = 0; i < members.Count; i++)
					{
						if (!members[i].IsDod)
						{
							return false;
						}
					}
					return true;
				}
			}

			public override XmlQueryCardinality Cardinality
			{
				get
				{
					if (TypeCode != 0)
					{
						return XmlQueryCardinality.One;
					}
					return XmlQueryCardinality.None;
				}
			}

			public override XmlQueryType Prime => this;

			public override XmlValueConverter ClrMapping
			{
				get
				{
					if (code == XmlTypeCode.None || code == XmlTypeCode.Item)
					{
						return XmlAnyConverter.Item;
					}
					if (base.IsAtomicValue)
					{
						return SchemaType.ValueConverter;
					}
					return XmlNodeConverter.Node;
				}
			}

			public override int Count => members.Count;

			public override XmlQueryType this[int index]
			{
				get
				{
					return members[index];
				}
				set
				{
					throw new NotSupportedException();
				}
			}

			public static XmlQueryType Create(XmlNodeKindFlags nodeKinds)
			{
				if (Bits.ExactlyOne((uint)nodeKinds))
				{
					return ItemType.Create(NodeKindToTypeCode[Bits.LeastPosition((uint)nodeKinds)], isStrict: false);
				}
				List<XmlQueryType> list = new List<XmlQueryType>();
				while (nodeKinds != 0)
				{
					list.Add(ItemType.Create(NodeKindToTypeCode[Bits.LeastPosition((uint)nodeKinds)], isStrict: false));
					nodeKinds = (XmlNodeKindFlags)Bits.ClearLeast((uint)nodeKinds);
				}
				return Create(list);
			}

			public static XmlQueryType Create(List<XmlQueryType> members)
			{
				if (members.Count == 0)
				{
					return None;
				}
				if (members.Count == 1)
				{
					return members[0];
				}
				return new ChoiceType(members);
			}

			private ChoiceType(List<XmlQueryType> members)
			{
				this.members = members;
				for (int i = 0; i < members.Count; i++)
				{
					XmlQueryType xmlQueryType = members[i];
					if (code == XmlTypeCode.None)
					{
						code = xmlQueryType.TypeCode;
						schemaType = xmlQueryType.SchemaType;
					}
					else if (base.IsNode && xmlQueryType.IsNode)
					{
						if (code == xmlQueryType.TypeCode)
						{
							if (code == XmlTypeCode.Element)
							{
								schemaType = XmlSchemaComplexType.AnyType;
							}
							else if (code == XmlTypeCode.Attribute)
							{
								schemaType = DatatypeImplementation.AnySimpleType;
							}
						}
						else
						{
							code = XmlTypeCode.Node;
							schemaType = null;
						}
					}
					else if (base.IsAtomicValue && xmlQueryType.IsAtomicValue)
					{
						code = XmlTypeCode.AnyAtomicType;
						schemaType = DatatypeImplementation.AnyAtomicType;
					}
					else
					{
						code = XmlTypeCode.Item;
						schemaType = null;
					}
					nodeKinds |= xmlQueryType.NodeKinds;
				}
			}

			public override void GetObjectData(BinaryWriter writer)
			{
				writer.Write(members.Count);
				for (int i = 0; i < members.Count; i++)
				{
					Serialize(writer, members[i]);
				}
			}

			public static XmlQueryType Create(BinaryReader reader)
			{
				int num = reader.ReadInt32();
				List<XmlQueryType> list = new List<XmlQueryType>(num);
				for (int i = 0; i < num; i++)
				{
					list.Add(Deserialize(reader));
				}
				return Create(list);
			}
		}

		private sealed class SequenceType : XmlQueryType
		{
			public static readonly XmlQueryType Zero = new SequenceType(ChoiceType.None, XmlQueryCardinality.Zero);

			private XmlQueryType prime;

			private XmlQueryCardinality card;

			private XmlValueConverter converter;

			public override XmlTypeCode TypeCode => prime.TypeCode;

			public override XmlQualifiedNameTest NameTest => prime.NameTest;

			public override XmlSchemaType SchemaType => prime.SchemaType;

			public override bool IsNillable => prime.IsNillable;

			public override XmlNodeKindFlags NodeKinds => prime.NodeKinds;

			public override bool IsStrict => prime.IsStrict;

			public override bool IsNotRtf => prime.IsNotRtf;

			public override bool IsDod => (object)this == NodeDodS;

			public override XmlQueryCardinality Cardinality => card;

			public override XmlQueryType Prime => prime;

			public override XmlValueConverter ClrMapping
			{
				get
				{
					if (converter == null)
					{
						converter = XmlListConverter.Create(prime.ClrMapping);
					}
					return converter;
				}
			}

			public override int Count => prime.Count;

			public override XmlQueryType this[int index]
			{
				get
				{
					return prime[index];
				}
				set
				{
					throw new NotSupportedException();
				}
			}

			public static XmlQueryType Create(XmlQueryType prime, XmlQueryCardinality card)
			{
				if (prime.TypeCode == XmlTypeCode.None)
				{
					if (!(XmlQueryCardinality.Zero <= card))
					{
						return None;
					}
					return Zero;
				}
				if (card == XmlQueryCardinality.None)
				{
					return None;
				}
				if (card == XmlQueryCardinality.Zero)
				{
					return Zero;
				}
				if (card == XmlQueryCardinality.One)
				{
					return prime;
				}
				return new SequenceType(prime, card);
			}

			private SequenceType(XmlQueryType prime, XmlQueryCardinality card)
			{
				this.prime = prime;
				this.card = card;
			}

			public override void GetObjectData(BinaryWriter writer)
			{
				writer.Write(IsDod);
				if (!IsDod)
				{
					Serialize(writer, prime);
					card.GetObjectData(writer);
				}
			}

			public static XmlQueryType Create(BinaryReader reader)
			{
				if (reader.ReadBoolean())
				{
					return NodeDodS;
				}
				XmlQueryType xmlQueryType = Deserialize(reader);
				XmlQueryCardinality xmlQueryCardinality = new XmlQueryCardinality(reader);
				return Create(xmlQueryType, xmlQueryCardinality);
			}
		}

		public static readonly XmlQueryType None = ChoiceType.None;

		public static readonly XmlQueryType Empty = SequenceType.Zero;

		public static readonly XmlQueryType Item = Type(XmlTypeCode.Item, isStrict: false);

		public static readonly XmlQueryType ItemS = PrimeProduct(Item, XmlQueryCardinality.ZeroOrMore);

		public static readonly XmlQueryType Node = Type(XmlTypeCode.Node, isStrict: false);

		public static readonly XmlQueryType NodeS = PrimeProduct(Node, XmlQueryCardinality.ZeroOrMore);

		public static readonly XmlQueryType Element = Type(XmlTypeCode.Element, isStrict: false);

		public static readonly XmlQueryType ElementS = PrimeProduct(Element, XmlQueryCardinality.ZeroOrMore);

		public static readonly XmlQueryType Document = Type(XmlTypeCode.Document, isStrict: false);

		public static readonly XmlQueryType DocumentS = PrimeProduct(Document, XmlQueryCardinality.ZeroOrMore);

		public static readonly XmlQueryType Attribute = Type(XmlTypeCode.Attribute, isStrict: false);

		public static readonly XmlQueryType AttributeQ = PrimeProduct(Attribute, XmlQueryCardinality.ZeroOrOne);

		public static readonly XmlQueryType AttributeS = PrimeProduct(Attribute, XmlQueryCardinality.ZeroOrMore);

		public static readonly XmlQueryType Namespace = Type(XmlTypeCode.Namespace, isStrict: false);

		public static readonly XmlQueryType NamespaceS = PrimeProduct(Namespace, XmlQueryCardinality.ZeroOrMore);

		public static readonly XmlQueryType Text = Type(XmlTypeCode.Text, isStrict: false);

		public static readonly XmlQueryType TextS = PrimeProduct(Text, XmlQueryCardinality.ZeroOrMore);

		public static readonly XmlQueryType Comment = Type(XmlTypeCode.Comment, isStrict: false);

		public static readonly XmlQueryType CommentS = PrimeProduct(Comment, XmlQueryCardinality.ZeroOrMore);

		public static readonly XmlQueryType PI = Type(XmlTypeCode.ProcessingInstruction, isStrict: false);

		public static readonly XmlQueryType PIS = PrimeProduct(PI, XmlQueryCardinality.ZeroOrMore);

		public static readonly XmlQueryType DocumentOrElement = Choice(Document, Element);

		public static readonly XmlQueryType DocumentOrElementQ = PrimeProduct(DocumentOrElement, XmlQueryCardinality.ZeroOrOne);

		public static readonly XmlQueryType DocumentOrElementS = PrimeProduct(DocumentOrElement, XmlQueryCardinality.ZeroOrMore);

		public static readonly XmlQueryType Content = Choice(Element, Comment, PI, Text);

		public static readonly XmlQueryType ContentS = PrimeProduct(Content, XmlQueryCardinality.ZeroOrMore);

		public static readonly XmlQueryType DocumentOrContent = Choice(Document, Content);

		public static readonly XmlQueryType DocumentOrContentS = PrimeProduct(DocumentOrContent, XmlQueryCardinality.ZeroOrMore);

		public static readonly XmlQueryType AttributeOrContent = Choice(Attribute, Content);

		public static readonly XmlQueryType AttributeOrContentS = PrimeProduct(AttributeOrContent, XmlQueryCardinality.ZeroOrMore);

		public static readonly XmlQueryType AnyAtomicType = Type(XmlTypeCode.AnyAtomicType, isStrict: false);

		public static readonly XmlQueryType AnyAtomicTypeS = PrimeProduct(AnyAtomicType, XmlQueryCardinality.ZeroOrMore);

		public static readonly XmlQueryType String = Type(XmlTypeCode.String, isStrict: false);

		public static readonly XmlQueryType StringX = Type(XmlTypeCode.String, isStrict: true);

		public static readonly XmlQueryType StringXS = PrimeProduct(StringX, XmlQueryCardinality.ZeroOrMore);

		public static readonly XmlQueryType Boolean = Type(XmlTypeCode.Boolean, isStrict: false);

		public static readonly XmlQueryType BooleanX = Type(XmlTypeCode.Boolean, isStrict: true);

		public static readonly XmlQueryType Int = Type(XmlTypeCode.Int, isStrict: false);

		public static readonly XmlQueryType IntX = Type(XmlTypeCode.Int, isStrict: true);

		public static readonly XmlQueryType IntXS = PrimeProduct(IntX, XmlQueryCardinality.ZeroOrMore);

		public static readonly XmlQueryType IntegerX = Type(XmlTypeCode.Integer, isStrict: true);

		public static readonly XmlQueryType LongX = Type(XmlTypeCode.Long, isStrict: true);

		public static readonly XmlQueryType DecimalX = Type(XmlTypeCode.Decimal, isStrict: true);

		public static readonly XmlQueryType FloatX = Type(XmlTypeCode.Float, isStrict: true);

		public static readonly XmlQueryType Double = Type(XmlTypeCode.Double, isStrict: false);

		public static readonly XmlQueryType DoubleX = Type(XmlTypeCode.Double, isStrict: true);

		public static readonly XmlQueryType DateTimeX = Type(XmlTypeCode.DateTime, isStrict: true);

		public static readonly XmlQueryType QNameX = Type(XmlTypeCode.QName, isStrict: true);

		public static readonly XmlQueryType UntypedDocument = ItemType.UntypedDocument;

		public static readonly XmlQueryType UntypedElement = ItemType.UntypedElement;

		public static readonly XmlQueryType UntypedAttribute = ItemType.UntypedAttribute;

		public static readonly XmlQueryType UntypedNode = Choice(UntypedDocument, UntypedElement, UntypedAttribute, Namespace, Text, Comment, PI);

		public static readonly XmlQueryType UntypedNodeS = PrimeProduct(UntypedNode, XmlQueryCardinality.ZeroOrMore);

		public static readonly XmlQueryType NodeNotRtf = ItemType.NodeNotRtf;

		public static readonly XmlQueryType NodeNotRtfQ = PrimeProduct(NodeNotRtf, XmlQueryCardinality.ZeroOrOne);

		public static readonly XmlQueryType NodeNotRtfS = PrimeProduct(NodeNotRtf, XmlQueryCardinality.ZeroOrMore);

		public static readonly XmlQueryType NodeDodS = PrimeProduct(NodeNotRtf, XmlQueryCardinality.ZeroOrMore);

		private static readonly XmlTypeCode[] NodeKindToTypeCode = new XmlTypeCode[10]
		{
			XmlTypeCode.Document,
			XmlTypeCode.Element,
			XmlTypeCode.Attribute,
			XmlTypeCode.Namespace,
			XmlTypeCode.Text,
			XmlTypeCode.Text,
			XmlTypeCode.Text,
			XmlTypeCode.ProcessingInstruction,
			XmlTypeCode.Comment,
			XmlTypeCode.Node
		};

		public static XmlQueryType Type(XmlTypeCode code, bool isStrict)
		{
			return ItemType.Create(code, isStrict);
		}

		public static XmlQueryType Type(XmlSchemaSimpleType schemaType, bool isStrict)
		{
			if (schemaType.Datatype.Variety == XmlSchemaDatatypeVariety.Atomic)
			{
				if (schemaType == DatatypeImplementation.AnySimpleType)
				{
					return AnyAtomicTypeS;
				}
				return ItemType.Create(schemaType, isStrict);
			}
			while (schemaType.DerivedBy == XmlSchemaDerivationMethod.Restriction)
			{
				schemaType = (XmlSchemaSimpleType)schemaType.BaseXmlSchemaType;
			}
			if (schemaType.DerivedBy == XmlSchemaDerivationMethod.List)
			{
				return PrimeProduct(Type(((XmlSchemaSimpleTypeList)schemaType.Content).BaseItemType, isStrict), XmlQueryCardinality.ZeroOrMore);
			}
			XmlSchemaSimpleType[] baseMemberTypes = ((XmlSchemaSimpleTypeUnion)schemaType.Content).BaseMemberTypes;
			XmlQueryType[] array = new XmlQueryType[baseMemberTypes.Length];
			for (int i = 0; i < baseMemberTypes.Length; i++)
			{
				array[i] = Type(baseMemberTypes[i], isStrict);
			}
			return Choice(array);
		}

		public static XmlQueryType Choice(XmlQueryType left, XmlQueryType right)
		{
			return SequenceType.Create(ChoiceType.Create(PrimeChoice(new List<XmlQueryType>(left), right)), left.Cardinality | right.Cardinality);
		}

		public static XmlQueryType Choice(params XmlQueryType[] types)
		{
			if (types.Length == 0)
			{
				return None;
			}
			if (types.Length == 1)
			{
				return types[0];
			}
			List<XmlQueryType> list = new List<XmlQueryType>(types[0]);
			XmlQueryCardinality cardinality = types[0].Cardinality;
			for (int i = 1; i < types.Length; i++)
			{
				PrimeChoice(list, types[i]);
				cardinality |= types[i].Cardinality;
			}
			return SequenceType.Create(ChoiceType.Create(list), cardinality);
		}

		public static XmlQueryType NodeChoice(XmlNodeKindFlags kinds)
		{
			return ChoiceType.Create(kinds);
		}

		public static XmlQueryType Sequence(XmlQueryType left, XmlQueryType right)
		{
			return SequenceType.Create(ChoiceType.Create(PrimeChoice(new List<XmlQueryType>(left), right)), left.Cardinality + right.Cardinality);
		}

		public static XmlQueryType PrimeProduct(XmlQueryType t, XmlQueryCardinality c)
		{
			if (t.Cardinality == c && !t.IsDod)
			{
				return t;
			}
			return SequenceType.Create(t.Prime, c);
		}

		public static XmlQueryType Product(XmlQueryType t, XmlQueryCardinality c)
		{
			return PrimeProduct(t, t.Cardinality * c);
		}

		public static XmlQueryType AtMost(XmlQueryType t, XmlQueryCardinality c)
		{
			return PrimeProduct(t, c.AtMost());
		}

		private static List<XmlQueryType> PrimeChoice(List<XmlQueryType> accumulator, IList<XmlQueryType> types)
		{
			foreach (XmlQueryType type in types)
			{
				AddItemToChoice(accumulator, type);
			}
			return accumulator;
		}

		private static void AddItemToChoice(List<XmlQueryType> accumulator, XmlQueryType itemType)
		{
			bool flag = true;
			for (int i = 0; i < accumulator.Count; i++)
			{
				if (itemType.IsSubtypeOf(accumulator[i]))
				{
					return;
				}
				if (accumulator[i].IsSubtypeOf(itemType))
				{
					if (flag)
					{
						flag = false;
						accumulator[i] = itemType;
					}
					else
					{
						accumulator.RemoveAt(i);
						i--;
					}
				}
			}
			if (flag)
			{
				accumulator.Add(itemType);
			}
		}

		public static XmlQueryType Type(XPathNodeType kind, XmlQualifiedNameTest nameTest, XmlSchemaType contentType, bool isNillable)
		{
			return ItemType.Create(NodeKindToTypeCode[(int)kind], nameTest, contentType, isNillable);
		}

		[Conditional("DEBUG")]
		public static void CheckSerializability(XmlQueryType type)
		{
			type.GetObjectData(new BinaryWriter(Stream.Null));
		}

		public static void Serialize(BinaryWriter writer, XmlQueryType type)
		{
			sbyte value = (sbyte)((type.GetType() != typeof(ItemType)) ? ((type.GetType() == typeof(ChoiceType)) ? 1 : ((type.GetType() != typeof(SequenceType)) ? (-1) : 2)) : 0);
			writer.Write(value);
			type.GetObjectData(writer);
		}

		public static XmlQueryType Deserialize(BinaryReader reader)
		{
			return reader.ReadByte() switch
			{
				0 => ItemType.Create(reader), 
				1 => ChoiceType.Create(reader), 
				2 => SequenceType.Create(reader), 
				_ => null, 
			};
		}
	}
	internal static class XPathConvert
	{
		private struct BigNumber
		{
			private uint u0;

			private uint u1;

			private uint u2;

			private int exp;

			private uint error;

			private static readonly BigNumber[] TenPowersPos = new BigNumber[46]
			{
				new BigNumber(0u, 0u, 2684354560u, 4, 0u),
				new BigNumber(0u, 0u, 3355443200u, 7, 0u),
				new BigNumber(0u, 0u, 4194304000u, 10, 0u),
				new BigNumber(0u, 0u, 2621440000u, 14, 0u),
				new BigNumber(0u, 0u, 3276800000u, 17, 0u),
				new BigNumber(0u, 0u, 4096000000u, 20, 0u),
				new BigNumber(0u, 0u, 2560000000u, 24, 0u),
				new BigNumber(0u, 0u, 3200000000u, 27, 0u),
				new BigNumber(0u, 0u, 4000000000u, 30, 0u),
				new BigNumber(0u, 0u, 2500000000u, 34, 0u),
				new BigNumber(0u, 0u, 3125000000u, 37, 0u),
				new BigNumber(0u, 0u, 3906250000u, 40, 0u),
				new BigNumber(0u, 0u, 2441406250u, 44, 0u),
				new BigNumber(0u, 2147483648u, 3051757812u, 47, 0u),
				new BigNumber(0u, 2684354560u, 3814697265u, 50, 0u),
				new BigNumber(0u, 67108864u, 2384185791u, 54, 0u),
				new BigNumber(0u, 3305111552u, 2980232238u, 57, 0u),
				new BigNumber(0u, 1983905792u, 3725290298u, 60, 0u),
				new BigNumber(0u, 2313682944u, 2328306436u, 64, 0u),
				new BigNumber(0u, 2892103680u, 2910383045u, 67, 0u),
				new BigNumber(0u, 393904128u, 3637978807u, 70, 0u),
				new BigNumber(0u, 1856802816u, 2273736754u, 74, 0u),
				new BigNumber(0u, 173519872u, 2842170943u, 77, 0u),
				new BigNumber(0u, 3438125312u, 3552713678u, 80, 0u),
				new BigNumber(0u, 1075086496u, 2220446049u, 84, 0u),
				new BigNumber(0u, 2417599944u, 2775557561u, 87, 0u),
				new BigNumber(0u, 4095741754u, 3469446951u, 90, 0u),
				new BigNumber(1073741824u, 4170451332u, 2168404344u, 94, 0u),
				new BigNumber(1342177280u, 918096869u, 2710505431u, 97, 0u),
				new BigNumber(2751463424u, 73879262u, 3388131789u, 100, 0u),
				new BigNumber(1291845632u, 1166090902u, 4235164736u, 103, 0u),
				new BigNumber(4028628992u, 728806813u, 2646977960u, 107, 0u),
				new BigNumber(1019177842u, 4291798741u, 3262652233u, 213, 1u),
				new BigNumber(3318737231u, 3315274914u, 4021529366u, 319, 1u),
				new BigNumber(3329176428u, 2162789599u, 2478458825u, 426, 1u),
				new BigNumber(1467717739u, 2145785770u, 3054936363u, 532, 1u),
				new BigNumber(2243682900u, 958879082u, 3765499789u, 638, 1u),
				new BigNumber(2193451889u, 3812411695u, 2320668415u, 745, 1u),
				new BigNumber(3720056860u, 2650398349u, 2860444667u, 851, 1u),
				new BigNumber(1937977068u, 1550462860u, 3525770265u, 957, 1u),
				new BigNumber(3869316483u, 4073513845u, 2172923689u, 1064, 1u),
				new BigNumber(1589582007u, 3683650258u, 2678335232u, 1170, 1u),
				new BigNumber(271056885u, 2935532055u, 3301303056u, 1276, 1u),
				new BigNumber(3051704177u, 3920665688u, 4069170183u, 1382, 1u),
				new BigNumber(2817170568u, 3958895571u, 2507819745u, 1489, 1u),
				new BigNumber(2113145460u, 127246946u, 3091126492u, 1595, 1u)
			};

			private static readonly BigNumber[] TenPowersNeg = new BigNumber[46]
			{
				new BigNumber(3435973837u, 3435973836u, 3435973836u, -3, 1u),
				new BigNumber(1030792151u, 1889785610u, 2748779069u, -6, 1u),
				new BigNumber(1683627180u, 2370821947u, 2199023255u, -9, 1u),
				new BigNumber(3552796947u, 3793315115u, 3518437208u, -13, 1u),
				new BigNumber(265257180u, 457671715u, 2814749767u, -16, 1u),
				new BigNumber(2789186122u, 2943117749u, 2251799813u, -19, 1u),
				new BigNumber(1026723958u, 3849994940u, 3602879701u, -23, 1u),
				new BigNumber(4257353003u, 2221002492u, 2882303761u, -26, 1u),
				new BigNumber(828902025u, 917808535u, 2305843009u, -29, 1u),
				new BigNumber(3044230158u, 3186480574u, 3689348814u, -33, 1u),
				new BigNumber(4153371045u, 3408177918u, 2951479051u, -36, 1u),
				new BigNumber(4181690295u, 1867548875u, 2361183241u, -39, 1u),
				new BigNumber(677750258u, 1270091283u, 3777893186u, -43, 1u),
				new BigNumber(1401193666u, 157079567u, 3022314549u, -46, 1u),
				new BigNumber(261961473u, 984657113u, 2417851639u, -49, 1u),
				new BigNumber(1278131816u, 3293438299u, 3868562622u, -53, 1u),
				new BigNumber(163511994u, 916763721u, 3094850098u, -56, 1u),
				new BigNumber(989803054u, 2451397895u, 2475880078u, -59, 1u),
				new BigNumber(724691428u, 3063243173u, 3961408125u, -63, 1u),
				new BigNumber(2297740061u, 2450594538u, 3169126500u, -66, 1u),
				new BigNumber(3556178967u, 1960475630u, 2535301200u, -69, 1u),
				new BigNumber(1394919051u, 3136761009u, 4056481920u, -73, 1u),
				new BigNumber(1974928700u, 2509408807u, 3245185536u, -76, 1u),
				new BigNumber(3297929878u, 1148533586u, 2596148429u, -79, 1u),
				new BigNumber(981720510u, 3555640657u, 4153837486u, -83, 1u),
				new BigNumber(2503363326u, 1985519066u, 3323069989u, -86, 1u),
				new BigNumber(2002690661u, 2447408712u, 2658455991u, -89, 1u),
				new BigNumber(2345311598u, 2197867021u, 4253529586u, -93, 1u),
				new BigNumber(158262360u, 899300158u, 3402823669u, -96, 1u),
				new BigNumber(2703590266u, 1578433585u, 2722258935u, -99, 1u),
				new BigNumber(2162872213u, 1262746868u, 2177807148u, -102, 1u),
				new BigNumber(1742608622u, 1161401530u, 3484491437u, -106, 1u),
				new BigNumber(1059297495u, 2772036005u, 2826955303u, -212, 1u),
				new BigNumber(299617026u, 4252324763u, 2293498615u, -318, 1u),
				new BigNumber(2893853687u, 1690100896u, 3721414268u, -425, 1u),
				new BigNumber(1508712807u, 3681788051u, 3019169939u, -531, 1u),
				new BigNumber(2070087331u, 1411632134u, 2449441655u, -637, 1u),
				new BigNumber(2767765334u, 1244745405u, 3974446316u, -744, 1u),
				new BigNumber(4203811158u, 1668946233u, 3224453925u, -850, 1u),
				new BigNumber(1323526137u, 2204812663u, 2615987810u, -956, 1u),
				new BigNumber(2300620953u, 1199716560u, 4244682903u, -1063, 1u),
				new BigNumber(9598332u, 1190350717u, 3443695891u, -1169, 1u),
				new BigNumber(2296094720u, 2971338839u, 2793858024u, -1275, 1u),
				new BigNumber(441364487u, 1073506470u, 2266646913u, -1381, 1u),
				new BigNumber(2227594191u, 3053929028u, 3677844889u, -1488, 1u),
				new BigNumber(1642812130u, 2030073654u, 2983822260u, -1594, 1u)
			};

			public uint Error => error;

			private bool IsZero
			{
				get
				{
					if (u2 == 0 && u1 == 0)
					{
						return 0 == u0;
					}
					return false;
				}
			}

			public BigNumber(uint u0, uint u1, uint u2, int exp, uint error)
			{
				this.u0 = u0;
				this.u1 = u1;
				this.u2 = u2;
				this.exp = exp;
				this.error = error;
			}

			public BigNumber(FloatingDecimal dec)
			{
				int num = 0;
				int exponent = dec.Exponent;
				int mantissaSize = dec.MantissaSize;
				u2 = (uint)(dec[num] << 28);
				u1 = 0u;
				u0 = 0u;
				exp = 4;
				error = 0u;
				exponent--;
				Normalize();
				while (++num < mantissaSize)
				{
					uint num2 = MulTenAdd(dec[num]);
					exponent--;
					if (num2 != 0)
					{
						Round(num2);
						if (num < mantissaSize - 1)
						{
							error++;
						}
						break;
					}
				}
				if (exponent != 0)
				{
					BigNumber[] array;
					if (exponent < 0)
					{
						array = TenPowersNeg;
						exponent = -exponent;
					}
					else
					{
						array = TenPowersPos;
					}
					int num3 = exponent & 0x1F;
					if (num3 > 0)
					{
						Mul(ref array[num3 - 1]);
					}
					num3 = (exponent >> 5) & 0xF;
					if (num3 > 0)
					{
						Mul(ref array[num3 + 30]);
					}
				}
			}

			private unsafe uint MulTenAdd(uint digit)
			{
				exp += 3;
				uint* ptr = (uint*)stackalloc byte[4 * 5];
				for (int i = 0; i < 5; i++)
				{
					ptr[i] = 0u;
				}
				if (digit != 0)
				{
					int num = 3 - (exp >> 5);
					if (num < 0)
					{
						*ptr = 1u;
					}
					else
					{
						int num2 = exp & 0x1F;
						if (num2 < 4)
						{
							ptr[num + 1] = digit >> num2;
							if (num2 > 0)
							{
								ptr[num] = digit << 32 - num2;
							}
						}
						else
						{
							ptr[num] = digit << 32 - num2;
						}
					}
				}
				ptr[1] += AddU(ref *ptr, u0 << 30);
				ptr[2] += AddU(ref u0, (u0 >> 2) + (u1 << 30));
				if (ptr[1] != 0)
				{
					ptr[2] += AddU(ref u0, ptr[1]);
				}
				ptr[3] += AddU(ref u1, (u1 >> 2) + (u2 << 30));
				if (ptr[2] != 0)
				{
					ptr[3] += AddU(ref u1, ptr[2]);
				}
				ptr[4] = AddU(ref u2, (u2 >> 2) + ptr[3]);
				if (ptr[4] != 0)
				{
					*ptr = (*ptr >> 1) | (*ptr & 1u) | (u0 << 31);
					u0 = (u0 >> 1) | (u1 << 31);
					u1 = (u1 >> 1) | (u2 << 31);
					u2 = (u2 >> 1) | 0x80000000u;
					exp++;
				}
				return *ptr;
			}

			private void Round(uint uExtra)
			{
				if ((uExtra & 0x80000000u) == 0 || ((uExtra & 0x7FFFFFFF) == 0 && (u0 & 1) == 0))
				{
					if (uExtra != 0)
					{
						error++;
					}
					return;
				}
				error++;
				if (AddU(ref u0, 1u) != 0 && AddU(ref u1, 1u) != 0 && AddU(ref u2, 1u) != 0)
				{
					u2 = 2147483648u;
					exp++;
				}
			}

			private void Normalize()
			{
				if (u2 == 0)
				{
					if (u1 == 0)
					{
						if (u0 == 0)
						{
							exp = 0;
							return;
						}
						u2 = u0;
						u0 = 0u;
						exp -= 64;
					}
					else
					{
						u2 = u1;
						u1 = u0;
						u0 = 0u;
						exp -= 32;
					}
				}
				int num;
				if ((num = CbitZeroLeft(u2)) != 0)
				{
					int num2 = 32 - num;
					u2 = (u2 << num) | (u1 >> num2);
					u1 = (u1 << num) | (u0 >> num2);
					u0 <<= num;
					exp -= num;
				}
			}

			private void Mul(ref BigNumber numOp)
			{
				uint num = 0u;
				uint num2 = 0u;
				uint num3 = 0u;
				uint num4 = 0u;
				uint num5 = 0u;
				uint num6 = 0u;
				uint uHi;
				uint num7;
				uint num8;
				uint num9;
				if ((num7 = u0) != 0)
				{
					num8 = MulU(num7, numOp.u0, out uHi);
					num = num8;
					num2 = uHi;
					num8 = MulU(num7, numOp.u1, out uHi);
					num9 = AddU(ref num2, num8);
					AddU(ref num3, uHi + num9);
					num8 = MulU(num7, numOp.u2, out uHi);
					num9 = AddU(ref num3, num8);
					AddU(ref num4, uHi + num9);
				}
				if ((num7 = u1) != 0)
				{
					num8 = MulU(num7, numOp.u0, out uHi);
					num9 = AddU(ref num2, num8);
					if (AddU(ref num3, uHi + num9) != 0 && AddU(ref num4, 1u) != 0)
					{
						AddU(ref num5, 1u);
					}
					num8 = MulU(num7, numOp.u1, out uHi);
					num9 = AddU(ref num3, num8);
					if (AddU(ref num4, uHi + num9) != 0)
					{
						AddU(ref num5, 1u);
					}
					num8 = MulU(num7, numOp.u2, out uHi);
					num9 = AddU(ref num4, num8);
					AddU(ref num5, uHi + num9);
				}
				num7 = u2;
				num8 = MulU(num7, numOp.u0, out uHi);
				num9 = AddU(ref num3, num8);
				if (AddU(ref num4, uHi + num9) != 0 && AddU(ref num5, 1u) != 0)
				{
					AddU(ref num6, 1u);
				}
				num8 = MulU(num7, numOp.u1, out uHi);
				num9 = AddU(ref num4, num8);
				if (AddU(ref num5, uHi + num9) != 0)
				{
					AddU(ref num6, 1u);
				}
				num8 = MulU(num7, numOp.u2, out uHi);
				num9 = AddU(ref num5, num8);
				AddU(ref num6, uHi + num9);
				exp += numOp.exp;
				error += numOp.error;
				if ((num6 & 0x80000000u) == 0)
				{
					if ((num3 & 0x40000000u) != 0 && ((num3 & 0xBFFFFFFFu) != 0 || num2 != 0 || num != 0) && AddU(ref num3, 1073741824u) != 0 && AddU(ref num4, 1u) != 0 && AddU(ref num5, 1u) != 0)
					{
						AddU(ref num6, 1u);
						if ((num6 & 0x80000000u) != 0)
						{
							goto IL_0314;
						}
					}
					u2 = (num6 << 1) | (num5 >> 31);
					u1 = (num5 << 1) | (num4 >> 31);
					u0 = (num4 << 1) | (num3 >> 31);
					exp--;
					error <<= 1;
					if ((num3 & 0x7FFFFFFFu) != 0 || num2 != 0 || num != 0)
					{
						error++;
					}
					return;
				}
				if ((num3 & 0x80000000u) != 0 && ((num4 & (true ? 1u : 0u)) != 0 || (num3 & 0x7FFFFFFFu) != 0 || num2 != 0 || num != 0) && AddU(ref num4, 1u) != 0 && AddU(ref num5, 1u) != 0 && AddU(ref num6, 1u) != 0)
				{
					num6 = 2147483648u;
					exp++;
				}
				goto IL_0314;
				IL_0314:
				u2 = num6;
				u1 = num5;
				u0 = num4;
				if (num3 != 0 || num2 != 0 || num != 0)
				{
					error++;
				}
			}

			public static explicit operator double(BigNumber bn)
			{
				int num = bn.exp + 1022;
				if (num >= 2047)
				{
					return double.PositiveInfinity;
				}
				uint num2;
				uint num3;
				uint num4;
				if (num > 0)
				{
					num2 = (uint)(num << 20) | ((bn.u2 & 0x7FFFFFFF) >> 11);
					num3 = (bn.u2 << 21) | (bn.u1 >> 11);
					num4 = (bn.u1 << 21) | NotZero(bn.u0);
				}
				else if (num > -20)
				{
					int num5 = 12 - num;
					num2 = bn.u2 >> num5;
					num3 = (bn.u2 << 32 - num5) | (bn.u1 >> num5);
					num4 = (bn.u1 << 32 - num5) | NotZero(bn.u0);
				}
				else if (num == -20)
				{
					num2 = 0u;
					num3 = bn.u2;
					num4 = bn.u1 | ((bn.u0 != 0) ? 1u : 0u);
				}
				else if (num > -52)
				{
					int num6 = -num - 20;
					num2 = 0u;
					num3 = bn.u2 >> num6;
					num4 = (bn.u2 << 32 - num6) | NotZero(bn.u1) | NotZero(bn.u0);
				}
				else
				{
					if (num != -52)
					{
						return 0.0;
					}
					num2 = 0u;
					num3 = 0u;
					num4 = bn.u2 | NotZero(bn.u1) | NotZero(bn.u0);
				}
				if ((num4 & 0x80000000u) != 0 && ((num4 & 0x7FFFFFFFu) != 0 || (num3 & (true ? 1u : 0u)) != 0) && AddU(ref num3, 1u) != 0)
				{
					AddU(ref num2, 1u);
				}
				return BitConverter.Int64BitsToDouble((long)(((ulong)num2 << 32) | num3));
			}

			private uint UMod1()
			{
				if (exp <= 0)
				{
					return 0u;
				}
				uint result = u2 >> 32 - exp;
				u2 &= 2147483647u >> exp - 1;
				Normalize();
				return result;
			}

			public void MakeUpperBound()
			{
				uint num = error + 1 >> 1;
				if (num != 0 && AddU(ref u0, num) != 0 && AddU(ref u1, 1u) != 0 && AddU(ref u2, 1u) != 0)
				{
					u2 = 2147483648u;
					u0 = (u0 >> 1) + (u0 & 1);
					exp++;
				}
				error = 0u;
			}

			public void MakeLowerBound()
			{
				uint num = error + 1 >> 1;
				if (num != 0 && AddU(ref u0, 0 - num) == 0 && AddU(ref u1, uint.MaxValue) == 0)
				{
					AddU(ref u2, uint.MaxValue);
					if ((0x80000000u & u2) == 0)
					{
						Normalize();
					}
				}
				error = 0u;
			}

			public static bool DblToRgbFast(double dbl, byte[] mantissa, out int exponent, out int mantissaSize)
			{
				int num = 0;
				uint num2 = DblHi(dbl);
				uint num3 = DblLo(dbl);
				int num4 = (int)((num2 >> 20) & 0x7FF);
				BigNumber bigNumber = default(BigNumber);
				BigNumber bigNumber2;
				BigNumber bigNumber3;
				int num7;
				if (num4 > 0)
				{
					if (num4 >= 1023 && num4 <= 1075 && dbl == Math.Floor(dbl))
					{
						double num5 = dbl;
						int num6 = 0;
						if (num5 >= C10toN[num6 + 8])
						{
							num6 += 8;
						}
						if (num5 >= C10toN[num6 + 4])
						{
							num6 += 4;
						}
						if (num5 >= C10toN[num6 + 2])
						{
							num6 += 2;
						}
						if (num5 >= C10toN[num6 + 1])
						{
							num6++;
						}
						exponent = num6 + 1;
						num7 = 0;
						while (0.0 != num5)
						{
							byte b = (byte)(num5 / C10toN[num6]);
							num5 -= (double)(int)b * C10toN[num6];
							mantissa[num7++] = b;
							num6--;
						}
						mantissaSize = num7;
						goto IL_05cb;
					}
					bigNumber.u2 = 0x80000000u | ((num2 & 0xFFFFFF) << 11) | (num3 >> 21);
					bigNumber.u1 = num3 << 11;
					bigNumber.u0 = 0u;
					bigNumber.exp = num4 - 1022;
					bigNumber.error = 0u;
					bigNumber2 = bigNumber;
					bigNumber2.u1 |= 1024u;
					bigNumber3 = bigNumber;
					if (AddU(u2: (int.MinValue != (int)bigNumber3.u2 || bigNumber3.u1 != 0) ? 4294966272u : 4294966784u, u1: ref bigNumber3.u1) == 0)
					{
						AddU(ref bigNumber3.u2, uint.MaxValue);
						if ((0x80000000u & bigNumber3.u2) == 0)
						{
							bigNumber3.Normalize();
						}
					}
				}
				else
				{
					bigNumber.u2 = num2 & 0xFFFFFu;
					bigNumber.u1 = num3;
					bigNumber.u0 = 0u;
					bigNumber.exp = -1010;
					bigNumber.error = 0u;
					bigNumber2 = bigNumber;
					bigNumber2.u0 = 2147483648u;
					bigNumber3 = bigNumber2;
					if (AddU(ref bigNumber3.u1, uint.MaxValue) == 0)
					{
						AddU(ref bigNumber3.u2, uint.MaxValue);
					}
					bigNumber.Normalize();
					bigNumber2.Normalize();
					bigNumber3.Normalize();
				}
				if (bigNumber2.exp >= 32)
				{
					int num6 = (bigNumber2.exp - 25) * 15 / -TenPowersNeg[45].exp;
					if (num6 > 0)
					{
						BigNumber numOp = TenPowersNeg[30 + num6];
						bigNumber2.Mul(ref numOp);
						bigNumber3.Mul(ref numOp);
						num += num6 * 32;
					}
					if (bigNumber2.exp >= 32)
					{
						num6 = (bigNumber2.exp - 25) * 32 / -TenPowersNeg[31].exp;
						BigNumber numOp = TenPowersNeg[num6 - 1];
						bigNumber2.Mul(ref numOp);
						bigNumber3.Mul(ref numOp);
						num += num6;
					}
				}
				else if (bigNumber2.exp < 1)
				{
					int num6 = (25 - bigNumber2.exp) * 15 / TenPowersPos[45].exp;
					if (num6 > 0)
					{
						BigNumber numOp = TenPowersPos[30 + num6];
						bigNumber2.Mul(ref numOp);
						bigNumber3.Mul(ref numOp);
						num -= num6 * 32;
					}
					if (bigNumber2.exp < 1)
					{
						num6 = (25 - bigNumber2.exp) * 32 / TenPowersPos[31].exp;
						BigNumber numOp = TenPowersPos[num6 - 1];
						bigNumber2.Mul(ref numOp);
						bigNumber3.Mul(ref numOp);
						num -= num6;
					}
				}
				BigNumber bigNumber4 = bigNumber2;
				bigNumber2.MakeUpperBound();
				bigNumber4.MakeLowerBound();
				uint num9 = bigNumber2.UMod1();
				uint num10 = bigNumber4.UMod1();
				BigNumber bigNumber5 = bigNumber3;
				bigNumber5.MakeUpperBound();
				bigNumber3.MakeLowerBound();
				uint num11 = bigNumber5.UMod1();
				uint num12 = bigNumber3.UMod1();
				uint num13 = 1u;
				if (num9 >= 100000000)
				{
					num13 = 100000000u;
					num += 8;
				}
				else
				{
					if (num9 >= 10000)
					{
						num13 = 10000u;
						num += 4;
					}
					if (num9 >= 100 * num13)
					{
						num13 *= 100;
						num += 2;
					}
				}
				if (num9 >= 10 * num13)
				{
					num13 *= 10;
					num++;
				}
				num++;
				num7 = 0;
				while (true)
				{
					byte b = (byte)(num9 / num13);
					num9 %= num13;
					byte b2 = (byte)(num12 / num13);
					num12 %= num13;
					if (b == b2)
					{
						mantissa[num7++] = b;
						if (1 != num13)
						{
							num13 /= 10u;
							continue;
						}
						num13 = 10000000u;
						bigNumber2.Mul(ref TenPowersPos[7]);
						bigNumber2.MakeUpperBound();
						num9 = bigNumber2.UMod1();
						if (num9 < 100000000)
						{
							bigNumber4.Mul(ref TenPowersPos[7]);
							bigNumber4.MakeLowerBound();
							num10 = bigNumber4.UMod1();
							bigNumber5.Mul(ref TenPowersPos[7]);
							bigNumber5.MakeUpperBound();
							num11 = bigNumber5.UMod1();
							bigNumber3.Mul(ref TenPowersPos[7]);
							bigNumber3.MakeLowerBound();
							num12 = bigNumber3.UMod1();
							continue;
						}
					}
					else
					{
						byte b3 = (byte)(num11 / num13 % 10u);
						num11 %= num13;
						byte b4 = (byte)(num10 / num13 % 10u);
						num10 %= num13;
						if (b3 < b4)
						{
							if (b3 == 0 && num11 == 0 && bigNumber5.IsZero && (num3 & 1) == 0)
							{
								break;
							}
							if (b4 - b3 > 1)
							{
								mantissa[num7++] = (byte)((b4 + b3 + 1) / 2);
								break;
							}
							if (num10 != 0 || !bigNumber4.IsZero || (num3 & 1) == 0)
							{
								mantissa[num7++] = b4;
								break;
							}
						}
					}
					exponent = (mantissaSize = 0);
					return false;
				}
				exponent = num;
				mantissaSize = num7;
				goto IL_05cb;
				IL_05cb:
				return true;
			}

			public static void DblToRgbPrecise(double dbl, byte[] mantissa, out int exponent, out int mantissaSize)
			{
				BigInteger bigInteger = new BigInteger();
				BigInteger bigInteger2 = new BigInteger();
				BigInteger bigInteger3 = new BigInteger();
				BigInteger bigInteger4 = new BigInteger();
				BigInteger bigInteger5 = new BigInteger();
				uint num = DblHi(dbl);
				uint num2 = DblLo(dbl);
				bigInteger2.InitFromDigits(1u, 0u, 1);
				bigInteger3.InitFromDigits(1u, 0u, 1);
				int num3 = (int)(((num & 0x7FF00000) >> 20) - 1075);
				uint num4 = num & 0xFFFFFu;
				uint num5 = num2;
				int num6 = 2;
				bool flag = false;
				double num7;
				int num8;
				if (num3 == -1075)
				{
					if (num4 == 0)
					{
						num6 = 1;
					}
					num7 = BitConverter.Int64BitsToDouble(5760103923406864384L);
					num7 *= dbl;
					num8 = (int)(((DblHi(num7) & 0x7FF00000) >> 20) - 1279);
					num = DblHi(num7);
					num &= 0xFFFFFu;
					num |= 0x3FF00000u;
					num7 = BitConverter.Int64BitsToDouble((long)(((ulong)num << 32) | DblLo(num7)));
					num3++;
				}
				else
				{
					num &= 0xFFFFFu;
					num |= 0x3FF00000u;
					num7 = BitConverter.Int64BitsToDouble((long)(((ulong)num << 32) | num2));
					num8 = num3 + 52;
					if (num5 == 0 && num4 == 0 && num3 > -1074)
					{
						num4 = 2097152u;
						num3--;
						flag = true;
					}
					else
					{
						num4 |= 0x100000u;
					}
				}
				num7 = (num7 - 1.5) * 0.289529654602168 + 0.1760912590558 + (double)num8 * 0.301029995663981;
				int num9 = (int)num7;
				if (num7 < 0.0 && num7 != (double)num9)
				{
					num9--;
				}
				int num10;
				int num11;
				if (num3 >= 0)
				{
					num10 = num3;
					num11 = 0;
				}
				else
				{
					num10 = 0;
					num11 = -num3;
				}
				int num12;
				int num13;
				if (num9 >= 0)
				{
					num12 = 0;
					num13 = num9;
					num11 += num9;
				}
				else
				{
					num10 -= num9;
					num12 = -num9;
					num13 = 0;
				}
				if (num10 > 0 && num11 > 0)
				{
					num8 = ((num10 < num11) ? num10 : num11);
					num10 -= num8;
					num11 -= num8;
				}
				num10++;
				num11++;
				if (num12 > 0)
				{
					bigInteger3.MulPow5(num12);
					bigInteger.InitFromBigint(bigInteger3);
					if (1 == num6)
					{
						bigInteger.MulAdd(num5, 0u);
					}
					else
					{
						bigInteger.MulAdd(num4, 0u);
						bigInteger.ShiftLeft(32);
						if (num5 != 0)
						{
							bigInteger5.InitFromBigint(bigInteger3);
							bigInteger5.MulAdd(num5, 0u);
							bigInteger.Add(bigInteger5);
						}
					}
				}
				else
				{
					bigInteger.InitFromDigits(num5, num4, num6);
					if (num13 > 0)
					{
						bigInteger2.MulPow5(num13);
					}
				}
				num8 = CbitZeroLeft(bigInteger2[bigInteger2.Length - 1]);
				num8 = (num8 + 28 - num11) & 0x1F;
				num10 += num8;
				num11 += num8;
				bigInteger.ShiftLeft(num10);
				if (num10 > 1)
				{
					bigInteger3.ShiftLeft(num10 - 1);
				}
				bigInteger2.ShiftLeft(num11);
				BigInteger bigInteger6;
				if (flag)
				{
					bigInteger6 = bigInteger4;
					bigInteger6.InitFromBigint(bigInteger3);
					bigInteger3.ShiftLeft(1);
				}
				else
				{
					bigInteger6 = bigInteger3;
				}
				int num14 = 0;
				while (true)
				{
					byte b = (byte)bigInteger.DivRem(bigInteger2);
					if (num14 == 0 && b == 0)
					{
						num9--;
						goto IL_03c7;
					}
					num8 = bigInteger.CompareTo(bigInteger6);
					int num15;
					if (bigInteger2.CompareTo(bigInteger3) < 0)
					{
						num15 = 1;
					}
					else
					{
						bigInteger5.InitFromBigint(bigInteger2);
						bigInteger5.Subtract(bigInteger3);
						num15 = bigInteger.CompareTo(bigInteger5);
					}
					if (num15 == 0 && (num2 & 1) == 0)
					{
						if (b != 9)
						{
							if (num8 > 0)
							{
								b = (byte)(b + 1);
							}
							mantissa[num14++] = b;
							break;
						}
					}
					else
					{
						if (num8 < 0 || (num8 == 0 && (num2 & 1) == 0))
						{
							if (num15 > 0)
							{
								bigInteger.ShiftLeft(1);
								num15 = bigInteger.CompareTo(bigInteger2);
								if ((num15 > 0 || (num15 == 0 && ((uint)b & (true ? 1u : 0u)) != 0)) && b++ == 9)
								{
									goto IL_041a;
								}
							}
							mantissa[num14++] = b;
							break;
						}
						if (num15 <= 0)
						{
							mantissa[num14++] = b;
							goto IL_03c7;
						}
						if (b != 9)
						{
							mantissa[num14++] = (byte)(b + 1);
							break;
						}
					}
					goto IL_041a;
					IL_041a:
					while (true)
					{
						if (num14 > 0)
						{
							if (mantissa[--num14] != 9)
							{
								mantissa[num14++]++;
								break;
							}
							continue;
						}
						num9++;
						mantissa[num14++] = 1;
						break;
					}
					break;
					IL_03c7:
					bigInteger.MulAdd(10u, 0u);
					bigInteger3.MulAdd(10u, 0u);
					if (bigInteger6 != bigInteger3)
					{
						bigInteger6.MulAdd(10u, 0u);
					}
				}
				exponent = num9 + 1;
				mantissaSize = num14;
			}
		}

		private class BigInteger : IComparable
		{
			private const int InitCapacity = 30;

			private int capacity;

			private int length;

			private uint[] digits;

			public int Length => length;

			public uint this[int idx] => digits[idx];

			public BigInteger()
			{
				capacity = 30;
				length = 0;
				digits = new uint[30];
			}

			[Conditional("DEBUG")]
			private void AssertValidNoVal()
			{
			}

			[Conditional("DEBUG")]
			private void AssertValid()
			{
			}

			private void Ensure(int cu)
			{
				if (cu > capacity)
				{
					cu += cu;
					uint[] array = new uint[cu];
					digits.CopyTo(array, 0);
					digits = array;
					capacity = cu;
				}
			}

			public void InitFromRgu(uint[] rgu, int cu)
			{
				Ensure(cu);
				length = cu;
				for (int i = 0; i < cu; i++)
				{
					digits[i] = rgu[i];
				}
			}

			public void InitFromDigits(uint u0, uint u1, int cu)
			{
				length = cu;
				digits[0] = u0;
				digits[1] = u1;
			}

			public void InitFromBigint(BigInteger biSrc)
			{
				InitFromRgu(biSrc.digits, biSrc.length);
			}

			public void InitFromFloatingDecimal(FloatingDecimal dec)
			{
				int cu = (dec.MantissaSize + 8) / 9;
				int mantissaSize = dec.MantissaSize;
				Ensure(cu);
				length = 0;
				uint num = 0u;
				uint num2 = 1u;
				for (int i = 0; i < mantissaSize; i++)
				{
					if (1000000000 == num2)
					{
						MulAdd(num2, num);
						num2 = 1u;
						num = 0u;
					}
					num2 *= 10;
					num = num * 10 + dec[i];
				}
				MulAdd(num2, num);
			}

			public void MulAdd(uint uMul, uint uAdd)
			{
				for (int i = 0; i < length; i++)
				{
					uint uHi;
					uint u = MulU(digits[i], uMul, out uHi);
					if (uAdd != 0)
					{
						uHi += AddU(ref u, uAdd);
					}
					digits[i] = u;
					uAdd = uHi;
				}
				if (uAdd != 0)
				{
					Ensure(length + 1);
					digits[length++] = uAdd;
				}
			}

			public void MulPow5(int c5)
			{
				int num = (c5 + 12) / 13;
				if (length == 0 || c5 == 0)
				{
					return;
				}
				Ensure(length + num);
				while (c5 >= 13)
				{
					MulAdd(1220703125u, 0u);
					c5 -= 13;
				}
				if (c5 > 0)
				{
					uint num2 = 5u;
					while (--c5 > 0)
					{
						num2 *= 5;
					}
					MulAdd(num2, 0u);
				}
			}

			public void ShiftLeft(int cbit)
			{
				if (cbit == 0 || length == 0)
				{
					return;
				}
				int num = cbit >> 5;
				cbit &= 0x1F;
				uint num3;
				int num2;
				if (cbit > 0)
				{
					num2 = length - 1;
					num3 = digits[num2] >> 32 - cbit;
					while (true)
					{
						digits[num2] <<= cbit;
						if (num2 == 0)
						{
							break;
						}
						digits[num2] |= digits[num2 - 1] >> 32 - cbit;
						num2--;
					}
				}
				else
				{
					num3 = 0u;
				}
				if (num <= 0 && num3 == 0)
				{
					return;
				}
				num2 = length + ((num3 != 0) ? 1 : 0) + num;
				Ensure(num2);
				if (num > 0)
				{
					int num4 = length;
					while (num4-- != 0)
					{
						digits[num + num4] = digits[num4];
					}
					for (int i = 0; i < num; i++)
					{
						digits[i] = 0u;
					}
					length += num;
				}
				if (num3 != 0)
				{
					digits[length++] = num3;
				}
			}

			public void ShiftUsRight(int cu)
			{
				if (cu >= length)
				{
					length = 0;
				}
				else if (cu > 0)
				{
					for (int i = 0; i < length - cu; i++)
					{
						digits[i] = digits[cu + i];
					}
					length -= cu;
				}
			}

			public void ShiftRight(int cbit)
			{
				int num = cbit >> 5;
				cbit &= 0x1F;
				if (num > 0)
				{
					ShiftUsRight(num);
				}
				if (cbit == 0 || length == 0)
				{
					return;
				}
				int num2 = 0;
				while (true)
				{
					digits[num2] >>= cbit;
					if (++num2 >= length)
					{
						break;
					}
					digits[num2 - 1] |= digits[num2] << 32 - cbit;
				}
				if (digits[num2 - 1] == 0)
				{
					length--;
				}
			}

			public int CompareTo(object obj)
			{
				BigInteger bigInteger = (BigInteger)obj;
				if (length > bigInteger.length)
				{
					return 1;
				}
				if (length < bigInteger.length)
				{
					return -1;
				}
				if (length == 0)
				{
					return 0;
				}
				int num = length - 1;
				while (digits[num] == bigInteger.digits[num])
				{
					if (num == 0)
					{
						return 0;
					}
					num--;
				}
				if (digits[num] <= bigInteger.digits[num])
				{
					return -1;
				}
				return 1;
			}

			public void Add(BigInteger bi)
			{
				int num;
				int num2;
				if ((num = length) < (num2 = bi.length))
				{
					num = bi.length;
					num2 = length;
					Ensure(num + 1);
				}
				uint num3 = 0u;
				int i;
				for (i = 0; i < num2; i++)
				{
					if (num3 != 0)
					{
						num3 = AddU(ref digits[i], num3);
					}
					num3 += AddU(ref digits[i], bi.digits[i]);
				}
				if (length < bi.length)
				{
					for (; i < num; i++)
					{
						digits[i] = bi.digits[i];
						if (num3 != 0)
						{
							num3 = AddU(ref digits[i], num3);
						}
					}
					length = num;
				}
				else
				{
					while (num3 != 0 && i < num)
					{
						num3 = AddU(ref digits[i], num3);
						i++;
					}
				}
				if (num3 != 0)
				{
					Ensure(length + 1);
					digits[length++] = num3;
				}
			}

			public void Subtract(BigInteger bi)
			{
				if (length >= bi.length)
				{
					uint num = 1u;
					int i;
					for (i = 0; i < bi.length; i++)
					{
						uint num2 = bi.digits[i];
						if (num2 != 0 || num == 0)
						{
							num = AddU(ref digits[i], ~num2 + num);
						}
					}
					while (num == 0 && i < length)
					{
						num = AddU(ref digits[i], uint.MaxValue);
					}
					if (num != 0)
					{
						if (i == length)
						{
							while (--i >= 0 && digits[i] == 0)
							{
							}
							length = i + 1;
						}
						return;
					}
				}
				length = 0;
			}

			public uint DivRem(BigInteger bi)
			{
				int num = bi.length;
				if (length < num)
				{
					return 0u;
				}
				uint num2 = digits[num - 1] / (bi.digits[num - 1] + 1);
				switch (num2)
				{
				case 1u:
					Subtract(bi);
					break;
				default:
				{
					uint u = 0u;
					uint num3 = 1u;
					int i;
					for (i = 0; i < num; i++)
					{
						uint uHi;
						uint u2 = MulU(num2, bi.digits[i], out uHi);
						u = uHi + AddU(ref u2, u);
						if (u2 != 0 || num3 == 0)
						{
							num3 = AddU(ref digits[i], ~u2 + num3);
						}
					}
					while (--i >= 0 && digits[i] == 0)
					{
					}
					length = i + 1;
					break;
				}
				case 0u:
					break;
				}
				int num4;
				if (num2 < 9 && (num4 = CompareTo(bi)) >= 0)
				{
					num2++;
					if (num4 == 0)
					{
						length = 0;
					}
					else
					{
						Subtract(bi);
					}
				}
				return num2;
			}
		}

		private class FloatingDecimal
		{
			public const int MaxDigits = 50;

			private const int MaxExp10 = 310;

			private const int MinExp10 = -325;

			private int exponent;

			private int sign;

			private int mantissaSize;

			private byte[] mantissa = new byte[50];

			public int Exponent
			{
				get
				{
					return exponent;
				}
				set
				{
					exponent = value;
				}
			}

			public int Sign
			{
				get
				{
					return sign;
				}
				set
				{
					sign = value;
				}
			}

			public byte[] Mantissa => mantissa;

			public int MantissaSize
			{
				get
				{
					return mantissaSize;
				}
				set
				{
					mantissaSize = value;
				}
			}

			public byte this[int ib] => mantissa[ib];

			public FloatingDecimal()
			{
				exponent = 0;
				sign = 1;
				mantissaSize = 0;
			}

			public FloatingDecimal(double dbl)
			{
				InitFromDouble(dbl);
			}

			public static explicit operator double(FloatingDecimal dec)
			{
				int num = dec.mantissaSize;
				int num2 = dec.exponent - num;
				double num4;
				if (num <= 15 && num2 >= -22 && dec.exponent <= 37)
				{
					if (num <= 9)
					{
						uint num3 = 0u;
						for (int i = 0; i < num; i++)
						{
							num3 = num3 * 10 + dec[i];
						}
						num4 = num3;
					}
					else
					{
						num4 = 0.0;
						for (int j = 0; j < num; j++)
						{
							num4 = num4 * 10.0 + (double)(int)dec[j];
						}
					}
					if (num2 > 0)
					{
						if (num2 > 22)
						{
							num4 *= C10toN[num2 - 22];
							num4 *= C10toN[22];
						}
						else
						{
							num4 *= C10toN[num2];
						}
					}
					else if (num2 < 0)
					{
						num4 /= C10toN[-num2];
					}
				}
				else if (dec.exponent >= 310)
				{
					num4 = double.PositiveInfinity;
				}
				else if (dec.exponent <= -325)
				{
					num4 = 0.0;
				}
				else
				{
					BigNumber bigNumber = new BigNumber(dec);
					if (bigNumber.Error == 0)
					{
						num4 = (double)bigNumber;
					}
					else
					{
						BigNumber bigNumber2 = bigNumber;
						bigNumber2.MakeUpperBound();
						BigNumber bigNumber3 = bigNumber;
						bigNumber3.MakeLowerBound();
						num4 = (double)bigNumber2;
						double num5 = (double)bigNumber3;
						if (num4 != num5)
						{
							num4 = dec.AdjustDbl((double)bigNumber);
						}
					}
				}
				if (dec.sign >= 0)
				{
					return num4;
				}
				return 0.0 - num4;
			}

			private double AdjustDbl(double dbl)
			{
				BigInteger bigInteger = new BigInteger();
				BigInteger bigInteger2 = new BigInteger();
				bigInteger.InitFromFloatingDecimal(this);
				int num = exponent - mantissaSize;
				int num3;
				int num5;
				int num4;
				int num2;
				if (num >= 0)
				{
					num3 = (num2 = num);
					num5 = (num4 = 0);
				}
				else
				{
					num3 = (num2 = 0);
					num5 = (num4 = -num);
				}
				uint num6 = DblHi(dbl);
				uint num7 = DblLo(dbl);
				int num8 = (int)((num6 >> 20) & 0x7FF);
				num6 &= 0xFFFFFu;
				uint u = 1u;
				if (num8 != 0)
				{
					if (num6 == 0 && num7 == 0 && 1 != num8)
					{
						u = 2u;
						num6 = 2097152u;
						num8--;
					}
					else
					{
						num6 |= 0x100000u;
					}
					num8 -= 1076;
				}
				else
				{
					num8 = -1075;
				}
				num6 = (num6 << 1) | (num7 >> 31);
				num7 <<= 1;
				int cu = ((num7 != 0 || num6 != 0) ? ((num6 == 0) ? 1 : 2) : 0);
				bigInteger2.InitFromDigits(num7, num6, cu);
				if (num8 >= 0)
				{
					num4 += num8;
				}
				else
				{
					num2 += -num8;
				}
				if (num4 > num2)
				{
					num4 -= num2;
					num2 = 0;
					int num9 = 0;
					while (num4 >= 32 && bigInteger[num9] == 0)
					{
						num4 -= 32;
						num9++;
					}
					if (num9 > 0)
					{
						bigInteger.ShiftUsRight(num9);
					}
					uint num10 = bigInteger[0];
					for (num9 = 0; num9 < num4 && 0 == (num10 & (1L << num9)); num9++)
					{
					}
					if (num9 > 0)
					{
						num4 -= num9;
						bigInteger.ShiftRight(num9);
					}
				}
				else
				{
					num2 -= num4;
					num4 = 0;
				}
				if (num5 > 0)
				{
					bigInteger2.MulPow5(num5);
				}
				else if (num3 > 0)
				{
					bigInteger.MulPow5(num3);
				}
				if (num4 > 0)
				{
					bigInteger2.ShiftLeft(num4);
				}
				else if (num2 > 0)
				{
					bigInteger.ShiftLeft(num2);
				}
				int num11 = bigInteger2.CompareTo(bigInteger);
				if (num11 == 0)
				{
					return dbl;
				}
				if (num11 > 0)
				{
					if (AddU(ref num7, uint.MaxValue) == 0)
					{
						AddU(ref num6, uint.MaxValue);
					}
					bigInteger2.InitFromDigits(num7, num6, 1 + ((num6 != 0) ? 1 : 0));
					if (num5 > 0)
					{
						bigInteger2.MulPow5(num5);
					}
					if (num4 > 0)
					{
						bigInteger2.ShiftLeft(num4);
					}
					num11 = bigInteger2.CompareTo(bigInteger);
					if (num11 > 0 || (num11 == 0 && (DblLo(dbl) & (true ? 1u : 0u)) != 0))
					{
						dbl = BitConverter.Int64BitsToDouble(BitConverter.DoubleToInt64Bits(dbl) - 1);
					}
				}
				else
				{
					if (AddU(ref num7, u) != 0)
					{
						AddU(ref num6, 1u);
					}
					bigInteger2.InitFromDigits(num7, num6, 1 + ((num6 != 0) ? 1 : 0));
					if (num5 > 0)
					{
						bigInteger2.MulPow5(num5);
					}
					if (num4 > 0)
					{
						bigInteger2.ShiftLeft(num4);
					}
					num11 = bigInteger2.CompareTo(bigInteger);
					if (num11 < 0 || (num11 == 0 && (DblLo(dbl) & (true ? 1u : 0u)) != 0))
					{
						dbl = BitConverter.Int64BitsToDouble(BitConverter.DoubleToInt64Bits(dbl) + 1);
					}
				}
				return dbl;
			}

			private void InitFromDouble(double dbl)
			{
				if (0.0 == dbl || IsSpecial(dbl))
				{
					exponent = 0;
					sign = 1;
					mantissaSize = 0;
					return;
				}
				if (dbl < 0.0)
				{
					sign = -1;
					dbl = 0.0 - dbl;
				}
				else
				{
					sign = 1;
				}
				if (!BigNumber.DblToRgbFast(dbl, mantissa, out exponent, out mantissaSize))
				{
					BigNumber.DblToRgbPrecise(dbl, mantissa, out exponent, out mantissaSize);
				}
			}
		}

		public static readonly double[] C10toN = new double[23]
		{
			1.0, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, 10000000.0, 100000000.0, 1000000000.0,
			10000000000.0, 100000000000.0, 1000000000000.0, 10000000000000.0, 100000000000000.0, 1E+15, 1E+16, 1E+17, 1E+18, 1E+19,
			1E+20, 1E+21, 1E+22
		};

		public static uint DblHi(double dbl)
		{
			return (uint)(BitConverter.DoubleToInt64Bits(dbl) >> 32);
		}

		public static uint DblLo(double dbl)
		{
			return (uint)BitConverter.DoubleToInt64Bits(dbl);
		}

		public static bool IsSpecial(double dbl)
		{
			return 0 == (~DblHi(dbl) & 0x7FF00000);
		}

		public static uint NotZero(uint u)
		{
			if (u == 0)
			{
				return 0u;
			}
			return 1u;
		}

		public static uint AddU(ref uint u1, uint u2)
		{
			u1 += u2;
			if (u1 >= u2)
			{
				return 0u;
			}
			return 1u;
		}

		public static uint MulU(uint u1, uint u2, out uint uHi)
		{
			ulong num = (ulong)u1 * (ulong)u2;
			uHi = (uint)(num >> 32);
			return (uint)num;
		}

		public static int CbitZeroLeft(uint u)
		{
			int num = 0;
			if ((u & 0xFFFF0000u) == 0)
			{
				num += 16;
				u <<= 16;
			}
			if ((u & 0xFF000000u) == 0)
			{
				num += 8;
				u <<= 8;
			}
			if ((u & 0xF0000000u) == 0)
			{
				num += 4;
				u <<= 4;
			}
			if ((u & 0xC0000000u) == 0)
			{
				num += 2;
				u <<= 2;
			}
			if ((u & 0x80000000u) == 0)
			{
				num++;
				u <<= 1;
			}
			return num;
		}

		public static bool IsInteger(double dbl, out int value)
		{
			if (!IsSpecial(dbl))
			{
				int num = (int)dbl;
				double num2 = num;
				if (dbl == num2)
				{
					value = num;
					return true;
				}
			}
			value = 0;
			return false;
		}

		private unsafe static string IntToString(int val)
		{
			char* ptr = (char*)stackalloc byte[2 * 12];
			char* ptr2 = (ptr += 12);
			uint num = (uint)((val < 0) ? (-val) : val);
			while (num >= 10)
			{
				uint num2 = (uint)(1717986919L * (long)num >> 32) >> 2;
				*(--ptr2) = (char)(num - num2 * 10 + 48);
				num = num2;
			}
			*(--ptr2) = (char)(num + 48);
			if (val < 0)
			{
				*(--ptr2) = '-';
			}
			return new string(ptr2, 0, (int)(ptr - ptr2));
		}

		public unsafe static string DoubleToString(double dbl)
		{
			if (IsInteger(dbl, out var value))
			{
				return IntToString(value);
			}
			if (IsSpecial(dbl))
			{
				if (double.IsNaN(dbl))
				{
					return "NaN";
				}
				if (!(dbl < 0.0))
				{
					return "Infinity";
				}
				return "-Infinity";
			}
			FloatingDecimal floatingDecimal = new FloatingDecimal(dbl);
			int num = floatingDecimal.MantissaSize - floatingDecimal.Exponent;
			int num2;
			if (num > 0)
			{
				num2 = ((floatingDecimal.Exponent > 0) ? floatingDecimal.Exponent : 0);
			}
			else
			{
				num2 = floatingDecimal.Exponent;
				num = 0;
			}
			int num3 = num2 + num + 4;
			char* ptr = (char*)stackalloc byte[2 * num3];
			char* ptr2 = ptr;
			if (floatingDecimal.Sign < 0)
			{
				char* intPtr = ptr2;
				ptr2 = intPtr + 1;
				*intPtr = '-';
			}
			int num4 = floatingDecimal.MantissaSize;
			int num5 = 0;
			if (num2 != 0)
			{
				do
				{
					if (num4 != 0)
					{
						char* intPtr2 = ptr2;
						ptr2 = intPtr2 + 1;
						*intPtr2 = (char)(floatingDecimal[num5++] | 0x30u);
						num4--;
					}
					else
					{
						char* intPtr3 = ptr2;
						ptr2 = intPtr3 + 1;
						*intPtr3 = '0';
					}
				}
				while (--num2 != 0);
			}
			else
			{
				char* intPtr4 = ptr2;
				ptr2 = intPtr4 + 1;
				*intPtr4 = '0';
			}
			if (num != 0)
			{
				char* intPtr5 = ptr2;
				ptr2 = intPtr5 + 1;
				*intPtr5 = '.';
				while (num > num4)
				{
					char* intPtr6 = ptr2;
					ptr2 = intPtr6 + 1;
					*intPtr6 = '0';
					num--;
				}
				while (num4 != 0)
				{
					char* intPtr7 = ptr2;
					ptr2 = intPtr7 + 1;
					*intPtr7 = (char)(floatingDecimal[num5++] | 0x30u);
					num4--;
				}
			}
			return new string(ptr, 0, (int)(ptr2 - ptr));
		}

		private static bool IsAsciiDigit(char ch)
		{
			return (uint)(ch - 48) <= 9u;
		}

		private static bool IsWhitespace(char ch)
		{
			if (ch != ' ' && ch != '\t' && ch != '\n')
			{
				return ch == '\r';
			}
			return true;
		}

		private unsafe static char* SkipWhitespace(char* pch)
		{
			while (IsWhitespace(*pch))
			{
				pch++;
			}
			return pch;
		}

		public unsafe static double StringToDouble(string s)
		{
			fixed (char* ptr = s)
			{
				int num = 0;
				char* ptr2 = ptr;
				char* ptr3 = null;
				int num2 = 1;
				int num3 = 0;
				while (true)
				{
					char* intPtr = ptr2;
					ptr2 = intPtr + 1;
					char c = *intPtr;
					if (!IsAsciiDigit(c))
					{
						switch (c)
						{
						case '-':
							if (num2 >= 0)
							{
								num2 = -1;
								continue;
							}
							goto IL_0073;
						case '.':
							if (IsAsciiDigit(*ptr2))
							{
								break;
							}
							goto IL_0073;
						default:
							{
								if (IsWhitespace(c) && num2 > 0)
								{
									ptr2 = SkipWhitespace(ptr2);
									continue;
								}
								goto IL_0073;
							}
							IL_0073:
							return double.NaN;
						}
						goto IL_00c8;
					}
					if (c == '0')
					{
						do
						{
							char* intPtr2 = ptr2;
							ptr2 = intPtr2 + 1;
							c = *intPtr2;
						}
						while (c == '0');
						if (!IsAsciiDigit(c))
						{
							goto IL_00c2;
						}
					}
					ptr3 = ptr2 - 1;
					do
					{
						char* intPtr3 = ptr2;
						ptr2 = intPtr3 + 1;
						c = *intPtr3;
					}
					while (IsAsciiDigit(c));
					num = (int)(ptr2 - ptr3) - 1;
					goto IL_00c2;
					IL_00c2:
					if (c != '.')
					{
						break;
					}
					goto IL_00c8;
					IL_00c8:
					char* intPtr4 = ptr2;
					ptr2 = intPtr4 + 1;
					c = *intPtr4;
					if (ptr3 == null)
					{
						while (c == '0')
						{
							num3--;
							char* intPtr5 = ptr2;
							ptr2 = intPtr5 + 1;
							c = *intPtr5;
						}
						ptr3 = ptr2 - 1;
					}
					while (IsAsciiDigit(c))
					{
						num3--;
						num++;
						char* intPtr6 = ptr2;
						ptr2 = intPtr6 + 1;
						c = *intPtr6;
					}
					break;
				}
				ptr2--;
				char* ptr4 = ptr + s.Length;
				if (ptr2 < ptr4 && SkipWhitespace(ptr2) < ptr4)
				{
					return double.NaN;
				}
				if (num == 0)
				{
					return 0.0;
				}
				if (num3 == 0 && num <= 9)
				{
					int num4 = *ptr3 & 0xF;
					while (--num != 0)
					{
						ptr3++;
						num4 = num4 * 10 + (*ptr3 & 0xF);
					}
					return (num2 < 0) ? (-num4) : num4;
				}
				if (num > 50)
				{
					ptr2 -= num - 50;
					num3 += num - 50;
					num = 50;
				}
				while (true)
				{
					if (*(--ptr2) == '0')
					{
						num--;
						num3++;
					}
					else if (*ptr2 != '.')
					{
						break;
					}
				}
				ptr2++;
				FloatingDecimal floatingDecimal = new FloatingDecimal();
				floatingDecimal.Exponent = num3 + num;
				floatingDecimal.Sign = num2;
				floatingDecimal.MantissaSize = num;
				fixed (byte* ptr5 = floatingDecimal.Mantissa)
				{
					byte* ptr6 = ptr5;
					for (; ptr3 < ptr2; ptr3++)
					{
						if (*ptr3 != '.')
						{
							*ptr6 = (byte)(*ptr3 & 0xFu);
							ptr6++;
						}
					}
				}
				return (double)floatingDecimal;
			}
		}
	}
	[Serializable]
	internal class XslTransformException : XsltException
	{
		protected XslTransformException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}

		public XslTransformException(Exception inner, string res, params string[] args)
			: base(CreateMessage(res, args), inner)
		{
		}

		public XslTransformException(string message)
			: base(CreateMessage(message, (string[])null), null)
		{
		}

		internal XslTransformException(string res, params string[] args)
			: this(null, res, args)
		{
		}

		internal static string CreateMessage(string res, params string[] args)
		{
			string text = null;
			try
			{
				text = System.Xml.Utils.Res.GetString(res, args);
			}
			catch (MissingManifestResourceException)
			{
			}
			if (text != null)
			{
				return text;
			}
			StringBuilder stringBuilder = new StringBuilder(res);
			if (args != null && args.Length > 0)
			{
				stringBuilder.Append('(');
				stringBuilder.Append(args[0]);
				for (int i = 1; i < args.Length; i++)
				{
					stringBuilder.Append(", ");
					stringBuilder.Append(args[i]);
				}
				stringBuilder.Append(')');
			}
			return stringBuilder.ToString();
		}

		internal virtual string FormatDetailedMessage()
		{
			return Message;
		}

		public override string ToString()
		{
			string text = GetType().FullName;
			string text2 = FormatDetailedMessage();
			if (text2 != null && text2.Length > 0)
			{
				text = text + ": " + text2;
			}
			if (base.InnerException != null)
			{
				string text3 = text;
				text = text3 + " ---> " + base.InnerException.ToString() + Environment.NewLine + "   " + CreateMessage("Xml_EndOfInnerExceptionStack");
			}
			if (StackTrace != null)
			{
				text = text + Environment.NewLine + StackTrace;
			}
			return text;
		}
	}
	[Serializable]
	internal class XslLoadException : XslTransformException
	{
		private ISourceLineInfo lineInfo;

		public override string SourceUri
		{
			get
			{
				if (lineInfo == null)
				{
					return null;
				}
				return lineInfo.Uri;
			}
		}

		public override int LineNumber
		{
			get
			{
				if (lineInfo == null)
				{
					return 0;
				}
				return lineInfo.StartLine;
			}
		}

		public override int LinePosition
		{
			get
			{
				if (lineInfo == null)
				{
					return 0;
				}
				return lineInfo.StartPos;
			}
		}

		protected XslLoadException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
			if ((bool)info.GetValue("hasLineInfo", typeof(bool)))
			{
				string uriString = (string)info.GetValue("Uri", typeof(string));
				int startLine = (int)info.GetValue("StartLine", typeof(int));
				int startPos = (int)info.GetValue("StartPos", typeof(int));
				int endLine = (int)info.GetValue("EndLine", typeof(int));
				int endPos = (int)info.GetValue("EndPos", typeof(int));
				lineInfo = new SourceLineInfo(uriString, startLine, startPos, endLine, endPos);
			}
		}

		[SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
		public override void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			base.GetObjectData(info, context);
			info.AddValue("hasLineInfo", lineInfo != null);
			if (lineInfo != null)
			{
				info.AddValue("Uri", lineInfo.Uri);
				info.AddValue("StartLine", lineInfo.StartLine);
				info.AddValue("StartPos", lineInfo.StartPos);
				info.AddValue("EndLine", lineInfo.EndLine);
				info.AddValue("EndPos", lineInfo.EndPos);
			}
		}

		internal XslLoadException(string res, params string[] args)
			: base(null, res, args)
		{
		}

		internal XslLoadException(Exception inner, ISourceLineInfo lineInfo)
			: base(inner, "Xslt_CompileError2", (string[])null)
		{
			this.lineInfo = lineInfo;
		}

		internal XslLoadException(CompilerError error)
			: base("Xml_UserException", error.ErrorText)
		{
			SetSourceLineInfo(new SourceLineInfo(error.FileName, error.Line, error.Column, error.Line, error.Column));
		}

		internal void SetSourceLineInfo(ISourceLineInfo lineInfo)
		{
			this.lineInfo = lineInfo;
		}

		private static string AppendLineInfoMessage(string message, ISourceLineInfo lineInfo)
		{
			if (lineInfo != null)
			{
				string fileName = SourceLineInfo.GetFileName(lineInfo.Uri);
				string text = XslTransformException.CreateMessage("Xml_ErrorFilePosition", fileName, lineInfo.StartLine.ToString(CultureInfo.InvariantCulture), lineInfo.StartPos.ToString(CultureInfo.InvariantCulture));
				if (text != null && text.Length > 0)
				{
					if (message.Length > 0 && !XmlCharType.Instance.IsWhiteSpace(message[message.Length - 1]))
					{
						message += " ";
					}
					message += text;
				}
			}
			return message;
		}

		internal static string CreateMessage(ISourceLineInfo lineInfo, string res, params string[] args)
		{
			return AppendLineInfoMessage(XslTransformException.CreateMessage(res, args), lineInfo);
		}

		internal override string FormatDetailedMessage()
		{
			return AppendLineInfoMessage(Message, lineInfo);
		}
	}
}
namespace System.Xml.Xsl.IlGen
{
	internal class XmlILStorageMethods
	{
		public MethodInfo AggAvg;

		public MethodInfo AggAvgResult;

		public MethodInfo AggCreate;

		public MethodInfo AggIsEmpty;

		public MethodInfo AggMax;

		public MethodInfo AggMaxResult;

		public MethodInfo AggMin;

		public MethodInfo AggMinResult;

		public MethodInfo AggSum;

		public MethodInfo AggSumResult;

		public Type SeqType;

		public FieldInfo SeqEmpty;

		public MethodInfo SeqReuse;

		public MethodInfo SeqReuseSgl;

		public MethodInfo SeqAdd;

		public MethodInfo SeqSortByKeys;

		public Type IListType;

		public MethodInfo IListCount;

		public MethodInfo IListItem;

		public MethodInfo ValueAs;

		public MethodInfo ToAtomicValue;

		public XmlILStorageMethods(Type storageType)
		{
			if (storageType == typeof(int) || storageType == typeof(long) || storageType == typeof(decimal) || storageType == typeof(double))
			{
				Type type = Type.GetType("System.Xml.Xsl.Runtime." + storageType.Name + "Aggregator");
				AggAvg = XmlILMethods.GetMethod(type, "Average");
				AggAvgResult = XmlILMethods.GetMethod(type, "get_AverageResult");
				AggCreate = XmlILMethods.GetMethod(type, "Create");
				AggIsEmpty = XmlILMethods.GetMethod(type, "get_IsEmpty");
				AggMax = XmlILMethods.GetMethod(type, "Maximum");
				AggMaxResult = XmlILMethods.GetMethod(type, "get_MaximumResult");
				AggMin = XmlILMethods.GetMethod(type, "Minimum");
				AggMinResult = XmlILMethods.GetMethod(type, "get_MinimumResult");
				AggSum = XmlILMethods.GetMethod(type, "Sum");
				AggSumResult = XmlILMethods.GetMethod(type, "get_SumResult");
			}
			if (storageType == typeof(XPathNavigator))
			{
				SeqType = typeof(XmlQueryNodeSequence);
				SeqAdd = XmlILMethods.GetMethod(SeqType, "AddClone");
			}
			else if (storageType == typeof(XPathItem))
			{
				SeqType = typeof(XmlQueryItemSequence);
				SeqAdd = XmlILMethods.GetMethod(SeqType, "AddClone");
			}
			else
			{
				SeqType = typeof(XmlQuerySequence<>).MakeGenericType(storageType);
				SeqAdd = XmlILMethods.GetMethod(SeqType, "Add");
			}
			SeqEmpty = SeqType.GetField("Empty");
			SeqReuse = XmlILMethods.GetMethod(SeqType, "CreateOrReuse", SeqType);
			SeqReuseSgl = XmlILMethods.GetMethod(SeqType, "CreateOrReuse", SeqType, storageType);
			SeqSortByKeys = XmlILMethods.GetMethod(SeqType, "SortByKeys");
			IListType = typeof(IList<>).MakeGenericType(storageType);
			IListItem = XmlILMethods.GetMethod(IListType, "get_Item");
			IListCount = XmlILMethods.GetMethod(typeof(ICollection<>).MakeGenericType(storageType), "get_Count");
			if (storageType == typeof(string))
			{
				ValueAs = XmlILMethods.GetMethod(typeof(XPathItem), "get_Value");
			}
			else if (storageType == typeof(int))
			{
				ValueAs = XmlILMethods.GetMethod(typeof(XPathItem), "get_ValueAsInt");
			}
			else if (storageType == typeof(long))
			{
				ValueAs = XmlILMethods.GetMethod(typeof(XPathItem), "get_ValueAsLong");
			}
			else if (storageType == typeof(DateTime))
			{
				ValueAs = XmlILMethods.GetMethod(typeof(XPathItem), "get_ValueAsDateTime");
			}
			else if (storageType == typeof(double))
			{
				ValueAs = XmlILMethods.GetMethod(typeof(XPathItem), "get_ValueAsDouble");
			}
			else if (storageType == typeof(bool))
			{
				ValueAs = XmlILMethods.GetMethod(typeof(XPathItem), "get_ValueAsBoolean");
			}
			if (storageType == typeof(byte[]))
			{
				ToAtomicValue = XmlILMethods.GetMethod(typeof(XmlILStorageConverter), "BytesToAtomicValue");
			}
			else if (storageType != typeof(XPathItem) && storageType != typeof(XPathNavigator))
			{
				ToAtomicValue = XmlILMethods.GetMethod(typeof(XmlILStorageConverter), storageType.Name + "ToAtomicValue");
			}
		}
	}
	internal static class XmlILConstructors
	{
		public static readonly ConstructorInfo DecFromParts = GetConstructor(typeof(decimal), typeof(int), typeof(int), typeof(int), typeof(bool), typeof(byte));

		public static readonly ConstructorInfo DecFromInt32 = GetConstructor(typeof(decimal), typeof(int));

		public static readonly ConstructorInfo DecFromInt64 = GetConstructor(typeof(decimal), typeof(long));

		public static readonly ConstructorInfo Debuggable = GetConstructor(typeof(DebuggableAttribute), typeof(DebuggableAttribute.DebuggingModes));

		public static readonly ConstructorInfo NonUserCode = GetConstructor(typeof(DebuggerNonUserCodeAttribute));

		public static readonly ConstructorInfo QName = GetConstructor(typeof(XmlQualifiedName), typeof(string), typeof(string));

		public static readonly ConstructorInfo StepThrough = GetConstructor(typeof(DebuggerStepThroughAttribute));

		public static readonly ConstructorInfo Transparent = GetConstructor(typeof(SecurityTransparentAttribute));

		private static ConstructorInfo GetConstructor(Type className)
		{
			return className.GetConstructor(new Type[0]);
		}

		private static ConstructorInfo GetConstructor(Type className, params Type[] args)
		{
			return className.GetConstructor(args);
		}
	}
	internal static class XmlILMethods
	{
		public static readonly MethodInfo AncCreate;

		public static readonly MethodInfo AncNext;

		public static readonly MethodInfo AncDOCreate;

		public static readonly MethodInfo AncDONext;

		public static readonly MethodInfo AttrContentCreate;

		public static readonly MethodInfo AttrContentNext;

		public static readonly MethodInfo AttrCreate;

		public static readonly MethodInfo AttrNext;

		public static readonly MethodInfo ContentCreate;

		public static readonly MethodInfo ContentNext;

		public static readonly MethodInfo ContentMergeCreate;

		public static readonly MethodInfo ContentMergeNext;

		public static readonly MethodInfo DescCreate;

		public static readonly MethodInfo DescNext;

		public static readonly MethodInfo DescMergeCreate;

		public static readonly MethodInfo DescMergeNext;

		public static readonly MethodInfo DiffCreate;

		public static readonly MethodInfo DiffNext;

		public static readonly MethodInfo DodMergeCreate;

		public static readonly MethodInfo DodMergeAdd;

		public static readonly MethodInfo DodMergeSeq;

		public static readonly MethodInfo ElemContentCreate;

		public static readonly MethodInfo ElemContentNext;

		public static readonly MethodInfo FollSibCreate;

		public static readonly MethodInfo FollSibNext;

		public static readonly MethodInfo FollSibMergeCreate;

		public static readonly MethodInfo FollSibMergeNext;

		public static readonly MethodInfo IdCreate;

		public static readonly MethodInfo IdNext;

		public static readonly MethodInfo InterCreate;

		public static readonly MethodInfo InterNext;

		public static readonly MethodInfo KindContentCreate;

		public static readonly MethodInfo KindContentNext;

		public static readonly MethodInfo NmspCreate;

		public static readonly MethodInfo NmspNext;

		public static readonly MethodInfo NodeRangeCreate;

		public static readonly MethodInfo NodeRangeNext;

		public static readonly MethodInfo ParentCreate;

		public static readonly MethodInfo ParentNext;

		public static readonly MethodInfo PrecCreate;

		public static readonly MethodInfo PrecNext;

		public static readonly MethodInfo PreSibCreate;

		public static readonly MethodInfo PreSibNext;

		public static readonly MethodInfo PreSibDOCreate;

		public static readonly MethodInfo PreSibDONext;

		public static readonly MethodInfo SortKeyCreate;

		public static readonly MethodInfo SortKeyDateTime;

		public static readonly MethodInfo SortKeyDecimal;

		public static readonly MethodInfo SortKeyDouble;

		public static readonly MethodInfo SortKeyEmpty;

		public static readonly MethodInfo SortKeyFinish;

		public static readonly MethodInfo SortKeyInt;

		public static readonly MethodInfo SortKeyInteger;

		public static readonly MethodInfo SortKeyKeys;

		public static readonly MethodInfo SortKeyString;

		public static readonly MethodInfo UnionCreate;

		public static readonly MethodInfo UnionNext;

		public static readonly MethodInfo XPFollCreate;

		public static readonly MethodInfo XPFollNext;

		public static readonly MethodInfo XPFollMergeCreate;

		public static readonly MethodInfo XPFollMergeNext;

		public static readonly MethodInfo XPPrecCreate;

		public static readonly MethodInfo XPPrecNext;

		public static readonly MethodInfo XPPrecDOCreate;

		public static readonly MethodInfo XPPrecDONext;

		public static readonly MethodInfo XPPrecMergeCreate;

		public static readonly MethodInfo XPPrecMergeNext;

		public static readonly MethodInfo AddNewIndex;

		public static readonly MethodInfo ChangeTypeXsltArg;

		public static readonly MethodInfo ChangeTypeXsltResult;

		public static readonly MethodInfo CompPos;

		public static readonly MethodInfo Context;

		public static readonly MethodInfo CreateCollation;

		public static readonly MethodInfo DocOrder;

		public static readonly MethodInfo EndRtfConstr;

		public static readonly MethodInfo EndSeqConstr;

		public static readonly MethodInfo FindIndex;

		public static readonly MethodInfo GenId;

		public static readonly MethodInfo GetAtomizedName;

		public static readonly MethodInfo GetCollation;

		public static readonly MethodInfo GetEarly;

		public static readonly MethodInfo GetNameFilter;

		public static readonly MethodInfo GetOutput;

		public static readonly MethodInfo GetGlobalValue;

		public static readonly MethodInfo GetTypeFilter;

		public static readonly MethodInfo GlobalComputed;

		public static readonly MethodInfo ItemMatchesCode;

		public static readonly MethodInfo ItemMatchesType;

		public static readonly MethodInfo QNameEqualLit;

		public static readonly MethodInfo QNameEqualNav;

		public static readonly MethodInfo RtfConstr;

		public static readonly MethodInfo SendMessage;

		public static readonly MethodInfo SeqMatchesCode;

		public static readonly MethodInfo SeqMatchesType;

		public static readonly MethodInfo SetGlobalValue;

		public static readonly MethodInfo StartRtfConstr;

		public static readonly MethodInfo StartSeqConstr;

		public static readonly MethodInfo TagAndMappings;

		public static readonly MethodInfo TagAndNamespace;

		public static readonly MethodInfo ThrowException;

		public static readonly MethodInfo XsltLib;

		public static readonly MethodInfo GetDataSource;

		public static readonly MethodInfo GetDefaultDataSource;

		public static readonly MethodInfo GetParam;

		public static readonly MethodInfo InvokeXsltLate;

		public static readonly MethodInfo IndexAdd;

		public static readonly MethodInfo IndexLookup;

		public static readonly MethodInfo ItemIsNode;

		public static readonly MethodInfo Value;

		public static readonly MethodInfo ValueAsAny;

		public static readonly MethodInfo NavClone;

		public static readonly MethodInfo NavLocalName;

		public static readonly MethodInfo NavMoveAttr;

		public static readonly MethodInfo NavMoveId;

		public static readonly MethodInfo NavMoveParent;

		public static readonly MethodInfo NavMoveRoot;

		public static readonly MethodInfo NavMoveTo;

		public static readonly MethodInfo NavNmsp;

		public static readonly MethodInfo NavPrefix;

		public static readonly MethodInfo NavSamePos;

		public static readonly MethodInfo NavType;

		public static readonly MethodInfo StartElemLitName;

		public static readonly MethodInfo StartElemLocName;

		public static readonly MethodInfo EndElemStackName;

		public static readonly MethodInfo StartAttrLitName;

		public static readonly MethodInfo StartAttrLocName;

		public static readonly MethodInfo EndAttr;

		public static readonly MethodInfo Text;

		public static readonly MethodInfo NoEntText;

		public static readonly MethodInfo StartTree;

		public static readonly MethodInfo EndTree;

		public static readonly MethodInfo StartElemLitNameUn;

		public static readonly MethodInfo StartElemLocNameUn;

		public static readonly MethodInfo StartContentUn;

		public static readonly MethodInfo EndElemLitNameUn;

		public static readonly MethodInfo EndElemLocNameUn;

		public static readonly MethodInfo StartAttrLitNameUn;

		public static readonly MethodInfo StartAttrLocNameUn;

		public static readonly MethodInfo EndAttrUn;

		public static readonly MethodInfo NamespaceDeclUn;

		public static readonly MethodInfo TextUn;

		public static readonly MethodInfo NoEntTextUn;

		public static readonly MethodInfo StartRoot;

		public static readonly MethodInfo EndRoot;

		public static readonly MethodInfo StartElemCopyName;

		public static readonly MethodInfo StartElemMapName;

		public static readonly MethodInfo StartElemNmspName;

		public static readonly MethodInfo StartElemQName;

		public static readonly MethodInfo StartAttrCopyName;

		public static readonly MethodInfo StartAttrMapName;

		public static readonly MethodInfo StartAttrNmspName;

		public static readonly MethodInfo StartAttrQName;

		public static readonly MethodInfo NamespaceDecl;

		public static readonly MethodInfo StartComment;

		public static readonly MethodInfo CommentText;

		public static readonly MethodInfo EndComment;

		public static readonly MethodInfo StartPI;

		public static readonly MethodInfo PIText;

		public static readonly MethodInfo EndPI;

		public static readonly MethodInfo WriteItem;

		public static readonly MethodInfo CopyOf;

		public static readonly MethodInfo StartCopy;

		public static readonly MethodInfo EndCopy;

		public static readonly MethodInfo DecAdd;

		public static readonly MethodInfo DecCmp;

		public static readonly MethodInfo DecEq;

		public static readonly MethodInfo DecSub;

		public static readonly MethodInfo DecMul;

		public static readonly MethodInfo DecDiv;

		public static readonly MethodInfo DecRem;

		public static readonly MethodInfo DecNeg;

		public static readonly MethodInfo QNameEq;

		public static readonly MethodInfo StrEq;

		public static readonly MethodInfo StrCat2;

		public static readonly MethodInfo StrCat3;

		public static readonly MethodInfo StrCat4;

		public static readonly MethodInfo StrCmp;

		public static readonly MethodInfo StrLen;

		public static readonly MethodInfo DblToDec;

		public static readonly MethodInfo DblToInt;

		public static readonly MethodInfo DblToLng;

		public static readonly MethodInfo DblToStr;

		public static readonly MethodInfo DecToDbl;

		public static readonly MethodInfo DTToStr;

		public static readonly MethodInfo IntToDbl;

		public static readonly MethodInfo LngToDbl;

		public static readonly MethodInfo StrToDbl;

		public static readonly MethodInfo StrToDT;

		public static readonly MethodInfo ItemToBool;

		public static readonly MethodInfo ItemToDbl;

		public static readonly MethodInfo ItemToStr;

		public static readonly MethodInfo ItemToNode;

		public static readonly MethodInfo ItemToNodes;

		public static readonly MethodInfo ItemsToBool;

		public static readonly MethodInfo ItemsToDbl;

		public static readonly MethodInfo ItemsToNode;

		public static readonly MethodInfo ItemsToNodes;

		public static readonly MethodInfo ItemsToStr;

		public static readonly MethodInfo StrCatCat;

		public static readonly MethodInfo StrCatClear;

		public static readonly MethodInfo StrCatResult;

		public static readonly MethodInfo StrCatDelim;

		public static readonly MethodInfo NavsToItems;

		public static readonly MethodInfo ItemsToNavs;

		public static readonly MethodInfo SetDod;

		public static readonly MethodInfo GetTypeFromHandle;

		public static readonly MethodInfo InitializeArray;

		public static readonly Dictionary<Type, XmlILStorageMethods> StorageMethods;

		static XmlILMethods()
		{
			AncCreate = GetMethod(typeof(AncestorIterator), "Create");
			AncNext = GetMethod(typeof(AncestorIterator), "MoveNext");
			AncDOCreate = GetMethod(typeof(AncestorDocOrderIterator), "Create");
			AncDONext = GetMethod(typeof(AncestorDocOrderIterator), "MoveNext");
			AttrContentCreate = GetMethod(typeof(AttributeContentIterator), "Create");
			AttrContentNext = GetMethod(typeof(AttributeContentIterator), "MoveNext");
			AttrCreate = GetMethod(typeof(AttributeIterator), "Create");
			AttrNext = GetMethod(typeof(AttributeIterator), "MoveNext");
			ContentCreate = GetMethod(typeof(ContentIterator), "Create");
			ContentNext = GetMethod(typeof(ContentIterator), "MoveNext");
			ContentMergeCreate = GetMethod(typeof(ContentMergeIterator), "Create");
			ContentMergeNext = GetMethod(typeof(ContentMergeIterator), "MoveNext");
			DescCreate = GetMethod(typeof(DescendantIterator), "Create");
			DescNext = GetMethod(typeof(DescendantIterator), "MoveNext");
			DescMergeCreate = GetMethod(typeof(DescendantMergeIterator), "Create");
			DescMergeNext = GetMethod(typeof(DescendantMergeIterator), "MoveNext");
			DiffCreate = GetMethod(typeof(DifferenceIterator), "Create");
			DiffNext = GetMethod(typeof(DifferenceIterator), "MoveNext");
			DodMergeCreate = GetMethod(typeof(DodSequenceMerge), "Create");
			DodMergeAdd = GetMethod(typeof(DodSequenceMerge), "AddSequence");
			DodMergeSeq = GetMethod(typeof(DodSequenceMerge), "MergeSequences");
			ElemContentCreate = GetMethod(typeof(ElementContentIterator), "Create");
			ElemContentNext = GetMethod(typeof(ElementContentIterator), "MoveNext");
			FollSibCreate = GetMethod(typeof(FollowingSiblingIterator), "Create");
			FollSibNext = GetMethod(typeof(FollowingSiblingIterator), "MoveNext");
			FollSibMergeCreate = GetMethod(typeof(FollowingSiblingMergeIterator), "Create");
			FollSibMergeNext = GetMethod(typeof(FollowingSiblingMergeIterator), "MoveNext");
			IdCreate = GetMethod(typeof(IdIterator), "Create");
			IdNext = GetMethod(typeof(IdIterator), "MoveNext");
			InterCreate = GetMethod(typeof(IntersectIterator), "Create");
			InterNext = GetMethod(typeof(IntersectIterator), "MoveNext");
			KindContentCreate = GetMethod(typeof(NodeKindContentIterator), "Create");
			KindContentNext = GetMethod(typeof(NodeKindContentIterator), "MoveNext");
			NmspCreate = GetMethod(typeof(NamespaceIterator), "Create");
			NmspNext = GetMethod(typeof(NamespaceIterator), "MoveNext");
			NodeRangeCreate = GetMethod(typeof(NodeRangeIterator), "Create");
			NodeRangeNext = GetMethod(typeof(NodeRangeIterator), "MoveNext");
			ParentCreate = GetMethod(typeof(ParentIterator), "Create");
			ParentNext = GetMethod(typeof(ParentIterator), "MoveNext");
			PrecCreate = GetMethod(typeof(PrecedingIterator), "Create");
			PrecNext = GetMethod(typeof(PrecedingIterator), "MoveNext");
			PreSibCreate = GetMethod(typeof(PrecedingSiblingIterator), "Create");
			PreSibNext = GetMethod(typeof(PrecedingSiblingIterator), "MoveNext");
			PreSibDOCreate = GetMethod(typeof(PrecedingSiblingDocOrderIterator), "Create");
			PreSibDONext = GetMethod(typeof(PrecedingSiblingDocOrderIterator), "MoveNext");
			SortKeyCreate = GetMethod(typeof(XmlSortKeyAccumulator), "Create");
			SortKeyDateTime = GetMethod(typeof(XmlSortKeyAccumulator), "AddDateTimeSortKey");
			SortKeyDecimal = GetMethod(typeof(XmlSortKeyAccumulator), "AddDecimalSortKey");
			SortKeyDouble = GetMethod(typeof(XmlSortKeyAccumulator), "AddDoubleSortKey");
			SortKeyEmpty = GetMethod(typeof(XmlSortKeyAccumulator), "AddEmptySortKey");
			SortKeyFinish = GetMethod(typeof(XmlSortKeyAccumulator), "FinishSortKeys");
			SortKeyInt = GetMethod(typeof(XmlSortKeyAccumulator), "AddIntSortKey");
			SortKeyInteger = GetMethod(typeof(XmlSortKeyAccumulator), "AddIntegerSortKey");
			SortKeyKeys = GetMethod(typeof(XmlSortKeyAccumulator), "get_Keys");
			SortKeyString = GetMethod(typeof(XmlSortKeyAccumulator), "AddStringSortKey");
			UnionCreate = GetMethod(typeof(UnionIterator), "Create");
			UnionNext = GetMethod(typeof(UnionIterator), "MoveNext");
			XPFollCreate = GetMethod(typeof(XPathFollowingIterator), "Create");
			XPFollNext = GetMethod(typeof(XPathFollowingIterator), "MoveNext");
			XPFollMergeCreate = GetMethod(typeof(XPathFollowingMergeIterator), "Create");
			XPFollMergeNext = GetMethod(typeof(XPathFollowingMergeIterator), "MoveNext");
			XPPrecCreate = GetMethod(typeof(XPathPrecedingIterator), "Create");
			XPPrecNext = GetMethod(typeof(XPathPrecedingIterator), "MoveNext");
			XPPrecDOCreate = GetMethod(typeof(XPathPrecedingDocOrderIterator), "Create");
			XPPrecDONext = GetMethod(typeof(XPathPrecedingDocOrderIterator), "MoveNext");
			XPPrecMergeCreate = GetMethod(typeof(XPathPrecedingMergeIterator), "Create");
			XPPrecMergeNext = GetMethod(typeof(XPathPrecedingMergeIterator), "MoveNext");
			AddNewIndex = GetMethod(typeof(XmlQueryRuntime), "AddNewIndex");
			ChangeTypeXsltArg = GetMethod(typeof(XmlQueryRuntime), "ChangeTypeXsltArgument", typeof(int), typeof(object), typeof(Type));
			ChangeTypeXsltResult = GetMethod(typeof(XmlQueryRuntime), "ChangeTypeXsltResult");
			CompPos = GetMethod(typeof(XmlQueryRuntime), "ComparePosition");
			Context = GetMethod(typeof(XmlQueryRuntime), "get_ExternalContext");
			CreateCollation = GetMethod(typeof(XmlQueryRuntime), "CreateCollation");
			DocOrder = GetMethod(typeof(XmlQueryRuntime), "DocOrderDistinct");
			EndRtfConstr = GetMethod(typeof(XmlQueryRuntime), "EndRtfConstruction");
			EndSeqConstr = GetMethod(typeof(XmlQueryRuntime), "EndSequenceConstruction");
			FindIndex = GetMethod(typeof(XmlQueryRuntime), "FindIndex");
			GenId = GetMethod(typeof(XmlQueryRuntime), "GenerateId");
			GetAtomizedName = GetMethod(typeof(XmlQueryRuntime), "GetAtomizedName");
			GetCollation = GetMethod(typeof(XmlQueryRuntime), "GetCollation");
			GetEarly = GetMethod(typeof(XmlQueryRuntime), "GetEarlyBoundObject");
			GetNameFilter = GetMethod(typeof(XmlQueryRuntime), "GetNameFilter");
			GetOutput = GetMethod(typeof(XmlQueryRuntime), "get_Output");
			GetGlobalValue = GetMethod(typeof(XmlQueryRuntime), "GetGlobalValue");
			GetTypeFilter = GetMethod(typeof(XmlQueryRuntime), "GetTypeFilter");
			GlobalComputed = GetMethod(typeof(XmlQueryRuntime), "IsGlobalComputed");
			ItemMatchesCode = GetMethod(typeof(XmlQueryRuntime), "MatchesXmlType", typeof(XPathItem), typeof(XmlTypeCode));
			ItemMatchesType = GetMethod(typeof(XmlQueryRuntime), "MatchesXmlType", typeof(XPathItem), typeof(int));
			QNameEqualLit = GetMethod(typeof(XmlQueryRuntime), "IsQNameEqual", typeof(XPathNavigator), typeof(int), typeof(int));
			QNameEqualNav = GetMethod(typeof(XmlQueryRuntime), "IsQNameEqual", typeof(XPathNavigator), typeof(XPathNavigator));
			RtfConstr = GetMethod(typeof(XmlQueryRuntime), "TextRtfConstruction");
			SendMessage = GetMethod(typeof(XmlQueryRuntime), "SendMessage");
			SeqMatchesCode = GetMethod(typeof(XmlQueryRuntime), "MatchesXmlType", typeof(IList<XPathItem>), typeof(XmlTypeCode));
			SeqMatchesType = GetMethod(typeof(XmlQueryRuntime), "MatchesXmlType", typeof(IList<XPathItem>), typeof(int));
			SetGlobalValue = GetMethod(typeof(XmlQueryRuntime), "SetGlobalValue");
			StartRtfConstr = GetMethod(typeof(XmlQueryRuntime), "StartRtfConstruction");
			StartSeqConstr = GetMethod(typeof(XmlQueryRuntime), "StartSequenceConstruction");
			TagAndMappings = GetMethod(typeof(XmlQueryRuntime), "ParseTagName", typeof(string), typeof(int));
			TagAndNamespace = GetMethod(typeof(XmlQueryRuntime), "ParseTagName", typeof(string), typeof(string));
			ThrowException = GetMethod(typeof(XmlQueryRuntime), "ThrowException");
			XsltLib = GetMethod(typeof(XmlQueryRuntime), "get_XsltFunctions");
			GetDataSource = GetMethod(typeof(XmlQueryContext), "GetDataSource");
			GetDefaultDataSource = GetMethod(typeof(XmlQueryContext), "get_DefaultDataSource");
			GetParam = GetMethod(typeof(XmlQueryContext), "GetParameter");
			InvokeXsltLate = GetMethod(typeof(XmlQueryContext), "InvokeXsltLateBoundFunction");
			IndexAdd = GetMethod(typeof(XmlILIndex), "Add");
			IndexLookup = GetMethod(typeof(XmlILIndex), "Lookup");
			ItemIsNode = GetMethod(typeof(XPathItem), "get_IsNode");
			Value = GetMethod(typeof(XPathItem), "get_Value");
			ValueAsAny = GetMethod(typeof(XPathItem), "ValueAs", typeof(Type), typeof(IXmlNamespaceResolver));
			NavClone = GetMethod(typeof(XPathNavigator), "Clone");
			NavLocalName = GetMethod(typeof(XPathNavigator), "get_LocalName");
			NavMoveAttr = GetMethod(typeof(XPathNavigator), "MoveToAttribute", typeof(string), typeof(string));
			NavMoveId = GetMethod(typeof(XPathNavigator), "MoveToId");
			NavMoveParent = GetMethod(typeof(XPathNavigator), "MoveToParent");
			NavMoveRoot = GetMethod(typeof(XPathNavigator), "MoveToRoot");
			NavMoveTo = GetMethod(typeof(XPathNavigator), "MoveTo");
			NavNmsp = GetMethod(typeof(XPathNavigator), "get_NamespaceURI");
			NavPrefix = GetMethod(typeof(XPathNavigator), "get_Prefix");
			NavSamePos = GetMethod(typeof(XPathNavigator), "IsSamePosition");
			NavType = GetMethod(typeof(XPathNavigator), "get_NodeType");
			StartElemLitName = GetMethod(typeof(XmlQueryOutput), "WriteStartElement", typeof(string), typeof(string), typeof(string));
			StartElemLocName = GetMethod(typeof(XmlQueryOutput), "WriteStartElementLocalName", typeof(string));
			EndElemStackName = GetMethod(typeof(XmlQueryOutput), "WriteEndElement");
			StartAttrLitName = GetMethod(typeof(XmlQueryOutput), "WriteStartAttribute", typeof(string), typeof(string), typeof(string));
			StartAttrLocName = GetMethod(typeof(XmlQueryOutput), "WriteStartAttributeLocalName", typeof(string));
			EndAttr = GetMethod(typeof(XmlQueryOutput), "WriteEndAttribute");
			Text = GetMethod(typeof(XmlQueryOutput), "WriteString");
			NoEntText = GetMethod(typeof(XmlQueryOutput), "WriteRaw", typeof(string));
			StartTree = GetMethod(typeof(XmlQueryOutput), "StartTree");
			EndTree = GetMethod(typeof(XmlQueryOutput), "EndTree");
			StartElemLitNameUn = GetMethod(typeof(XmlQueryOutput), "WriteStartElementUnchecked", typeof(string), typeof(string), typeof(string));
			StartElemLocNameUn = GetMethod(typeof(XmlQueryOutput), "WriteStartElementUnchecked", typeof(string));
			StartContentUn = GetMethod(typeof(XmlQueryOutput), "StartElementContentUnchecked");
			EndElemLitNameUn = GetMethod(typeof(XmlQueryOutput), "WriteEndElementUnchecked", typeof(string), typeof(string), typeof(string));
			EndElemLocNameUn = GetMethod(typeof(XmlQueryOutput), "WriteEndElementUnchecked", typeof(string));
			StartAttrLitNameUn = GetMethod(typeof(XmlQueryOutput), "WriteStartAttributeUnchecked", typeof(string), typeof(string), typeof(string));
			StartAttrLocNameUn = GetMethod(typeof(XmlQueryOutput), "WriteStartAttributeUnchecked", typeof(string));
			EndAttrUn = GetMethod(typeof(XmlQueryOutput), "WriteEndAttributeUnchecked");
			NamespaceDeclUn = GetMethod(typeof(XmlQueryOutput), "WriteNamespaceDeclarationUnchecked");
			TextUn = GetMethod(typeof(XmlQueryOutput), "WriteStringUnchecked");
			NoEntTextUn = GetMethod(typeof(XmlQueryOutput), "WriteRawUnchecked");
			StartRoot = GetMethod(typeof(XmlQueryOutput), "WriteStartRoot");
			EndRoot = GetMethod(typeof(XmlQueryOutput), "WriteEndRoot");
			StartElemCopyName = GetMethod(typeof(XmlQueryOutput), "WriteStartElementComputed", typeof(XPathNavigator));
			StartElemMapName = GetMethod(typeof(XmlQueryOutput), "WriteStartElementComputed", typeof(string), typeof(int));
			StartElemNmspName = GetMethod(typeof(XmlQueryOutput), "WriteStartElementComputed", typeof(string), typeof(string));
			StartElemQName = GetMethod(typeof(XmlQueryOutput), "WriteStartElementComputed", typeof(XmlQualifiedName));
			StartAttrCopyName = GetMethod(typeof(XmlQueryOutput), "WriteStartAttributeComputed", typeof(XPathNavigator));
			StartAttrMapName = GetMethod(typeof(XmlQueryOutput), "WriteStartAttributeComputed", typeof(string), typeof(int));
			StartAttrNmspName = GetMethod(typeof(XmlQueryOutput), "WriteStartAttributeComputed", typeof(string), typeof(string));
			StartAttrQName = GetMethod(typeof(XmlQueryOutput), "WriteStartAttributeComputed", typeof(XmlQualifiedName));
			NamespaceDecl = GetMethod(typeof(XmlQueryOutput), "WriteNamespaceDeclaration");
			StartComment = GetMethod(typeof(XmlQueryOutput), "WriteStartComment");
			CommentText = GetMethod(typeof(XmlQueryOutput), "WriteCommentString");
			EndComment = GetMethod(typeof(XmlQueryOutput), "WriteEndComment");
			StartPI = GetMethod(typeof(XmlQueryOutput), "WriteStartProcessingInstruction");
			PIText = GetMethod(typeof(XmlQueryOutput), "WriteProcessingInstructionString");
			EndPI = GetMethod(typeof(XmlQueryOutput), "WriteEndProcessingInstruction");
			WriteItem = GetMethod(typeof(XmlQueryOutput), "WriteItem");
			CopyOf = GetMethod(typeof(XmlQueryOutput), "XsltCopyOf");
			StartCopy = GetMethod(typeof(XmlQueryOutput), "StartCopy");
			EndCopy = GetMethod(typeof(XmlQueryOutput), "EndCopy");
			DecAdd = GetMethod(typeof(decimal), "Add");
			DecCmp = GetMethod(typeof(decimal), "Compare", typeof(decimal), typeof(decimal));
			DecEq = GetMethod(typeof(decimal), "Equals", typeof(decimal), typeof(decimal));
			DecSub = GetMethod(typeof(decimal), "Subtract");
			DecMul = GetMethod(typeof(decimal), "Multiply");
			DecDiv = GetMethod(typeof(decimal), "Divide");
			DecRem = GetMethod(typeof(decimal), "Remainder");
			DecNeg = GetMethod(typeof(decimal), "Negate");
			QNameEq = GetMethod(typeof(XmlQualifiedName), "Equals");
			StrEq = GetMethod(typeof(string), "Equals", typeof(string), typeof(string));
			StrCat2 = GetMethod(typeof(string), "Concat", typeof(string), typeof(string));
			StrCat3 = GetMethod(typeof(string), "Concat", typeof(string), typeof(string), typeof(string));
			StrCat4 = GetMethod(typeof(string), "Concat", typeof(string), typeof(string), typeof(string), typeof(string));
			StrCmp = GetMethod(typeof(string), "CompareOrdinal", typeof(string), typeof(string));
			StrLen = GetMethod(typeof(string), "get_Length");
			DblToDec = GetMethod(typeof(XsltConvert), "ToDecimal", typeof(double));
			DblToInt = GetMethod(typeof(XsltConvert), "ToInt", typeof(double));
			DblToLng = GetMethod(typeof(XsltConvert), "ToLong", typeof(double));
			DblToStr = GetMethod(typeof(XsltConvert), "ToString", typeof(double));
			DecToDbl = GetMethod(typeof(XsltConvert), "ToDouble", typeof(decimal));
			DTToStr = GetMethod(typeof(XsltConvert), "ToString", typeof(DateTime));
			IntToDbl = GetMethod(typeof(XsltConvert), "ToDouble", typeof(int));
			LngToDbl = GetMethod(typeof(XsltConvert), "ToDouble", typeof(long));
			StrToDbl = GetMethod(typeof(XsltConvert), "ToDouble", typeof(string));
			StrToDT = GetMethod(typeof(XsltConvert), "ToDateTime", typeof(string));
			ItemToBool = GetMethod(typeof(XsltConvert), "ToBoolean", typeof(XPathItem));
			ItemToDbl = GetMethod(typeof(XsltConvert), "ToDouble", typeof(XPathItem));
			ItemToStr = GetMethod(typeof(XsltConvert), "ToString", typeof(XPathItem));
			ItemToNode = GetMethod(typeof(XsltConvert), "ToNode", typeof(XPathItem));
			ItemToNodes = GetMethod(typeof(XsltConvert), "ToNodeSet", typeof(XPathItem));
			ItemsToBool = GetMethod(typeof(XsltConvert), "ToBoolean", typeof(IList<XPathItem>));
			ItemsToDbl = GetMethod(typeof(XsltConvert), "ToDouble", typeof(IList<XPathItem>));
			ItemsToNode = GetMethod(typeof(XsltConvert), "ToNode", typeof(IList<XPathItem>));
			ItemsToNodes = GetMethod(typeof(XsltConvert), "ToNodeSet", typeof(IList<XPathItem>));
			ItemsToStr = GetMethod(typeof(XsltConvert), "ToString", typeof(IList<XPathItem>));
			StrCatCat = GetMethod(typeof(StringConcat), "Concat");
			StrCatClear = GetMethod(typeof(StringConcat), "Clear");
			StrCatResult = GetMethod(typeof(StringConcat), "GetResult");
			StrCatDelim = GetMethod(typeof(StringConcat), "set_Delimiter");
			NavsToItems = GetMethod(typeof(XmlILStorageConverter), "NavigatorsToItems");
			ItemsToNavs = GetMethod(typeof(XmlILStorageConverter), "ItemsToNavigators");
			SetDod = GetMethod(typeof(XmlQueryNodeSequence), "set_IsDocOrderDistinct");
			GetTypeFromHandle = GetMethod(typeof(Type), "GetTypeFromHandle");
			InitializeArray = GetMethod(typeof(RuntimeHelpers), "InitializeArray");
			StorageMethods = new Dictionary<Type, XmlILStorageMethods>();
			StorageMethods[typeof(string)] = new XmlILStorageMethods(typeof(string));
			StorageMethods[typeof(bool)] = new XmlILStorageMethods(typeof(bool));
			StorageMethods[typeof(int)] = new XmlILStorageMethods(typeof(int));
			StorageMethods[typeof(long)] = new XmlILStorageMethods(typeof(long));
			StorageMethods[typeof(decimal)] = new XmlILStorageMethods(typeof(decimal));
			StorageMethods[typeof(double)] = new XmlILStorageMethods(typeof(double));
			StorageMethods[typeof(float)] = new XmlILStorageMethods(typeof(float));
			StorageMethods[typeof(DateTime)] = new XmlILStorageMethods(typeof(DateTime));
			StorageMethods[typeof(byte[])] = new XmlILStorageMethods(typeof(byte[]));
			StorageMethods[typeof(XmlQualifiedName)] = new XmlILStorageMethods(typeof(XmlQualifiedName));
			StorageMethods[typeof(TimeSpan)] = new XmlILStorageMethods(typeof(TimeSpan));
			StorageMethods[typeof(XPathItem)] = new XmlILStorageMethods(typeof(XPathItem));
			StorageMethods[typeof(XPathNavigator)] = new XmlILStorageMethods(typeof(XPathNavigator));
		}

		public static MethodInfo GetMethod(Type className, string methName)
		{
			return className.GetMethod(methName);
		}

		public static MethodInfo GetMethod(Type className, string methName, params Type[] args)
		{
			return className.GetMethod(methName, args);
		}
	}
	internal enum GenerateNameType
	{
		LiteralLocalName,
		LiteralName,
		CopiedName,
		TagNameAndMappings,
		TagNameAndNamespace,
		QName,
		StackName
	}
	internal class GenerateHelper
	{
		private MethodBase methInfo;

		private ILGenerator ilgen;

		private LocalBuilder locXOut;

		private XmlILModule module;

		private bool isDebug;

		private bool initWriters;

		private StaticDataManager staticData;

		private ISourceLineInfo lastSourceInfo;

		private MethodInfo methSyncToNav;

		private string lastUriString;

		private string lastFileName;

		public StaticDataManager StaticData => staticData;

		public GenerateHelper(XmlILModule module, bool isDebug)
		{
			this.isDebug = isDebug;
			this.module = module;
			staticData = new StaticDataManager();
		}

		public void MethodBegin(MethodBase methInfo, ISourceLineInfo sourceInfo, bool initWriters)
		{
			this.methInfo = methInfo;
			ilgen = XmlILModule.DefineMethodBody(methInfo);
			lastSourceInfo = null;
			if (isDebug)
			{
				DebugStartScope();
				if (sourceInfo != null)
				{
					MarkSequencePoint(sourceInfo);
					Emit(OpCodes.Nop);
				}
			}
			this.initWriters = false;
			if (initWriters)
			{
				EnsureWriter();
				LoadQueryRuntime();
				Call(XmlILMethods.GetOutput);
				Emit(OpCodes.Stloc, locXOut);
			}
		}

		public void MethodEnd()
		{
			Emit(OpCodes.Ret);
			if (isDebug)
			{
				DebugEndScope();
			}
		}

		public void CallSyncToNavigator()
		{
			if (methSyncToNav == null)
			{
				methSyncToNav = module.FindMethod("SyncToNavigator");
			}
			Call(methSyncToNav);
		}

		public void LoadInteger(int intVal)
		{
			if (intVal >= -1 && intVal < 9)
			{
				OpCode opcode;
				switch (intVal)
				{
				default:
					return;
				case -1:
					opcode = OpCodes.Ldc_I4_M1;
					break;
				case 0:
					opcode = OpCodes.Ldc_I4_0;
					break;
				case 1:
					opcode = OpCodes.Ldc_I4_1;
					break;
				case 2:
					opcode = OpCodes.Ldc_I4_2;
					break;
				case 3:
					opcode = OpCodes.Ldc_I4_3;
					break;
				case 4:
					opcode = OpCodes.Ldc_I4_4;
					break;
				case 5:
					opcode = OpCodes.Ldc_I4_5;
					break;
				case 6:
					opcode = OpCodes.Ldc_I4_6;
					break;
				case 7:
					opcode = OpCodes.Ldc_I4_7;
					break;
				case 8:
					opcode = OpCodes.Ldc_I4_8;
					break;
				}
				Emit(opcode);
			}
			else if (intVal >= -128 && intVal <= 127)
			{
				Emit(OpCodes.Ldc_I4_S, (sbyte)intVal);
			}
			else
			{
				Emit(OpCodes.Ldc_I4, intVal);
			}
		}

		public void LoadBoolean(bool boolVal)
		{
			Emit(boolVal ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);
		}

		public void LoadType(Type clrTyp)
		{
			Emit(OpCodes.Ldtoken, clrTyp);
			Call(XmlILMethods.GetTypeFromHandle);
		}

		public LocalBuilder DeclareLocal(string name, Type type)
		{
			return ilgen.DeclareLocal(type);
		}

		public void LoadQueryRuntime()
		{
			Emit(OpCodes.Ldarg_0);
		}

		public void LoadQueryContext()
		{
			Emit(OpCodes.Ldarg_0);
			Call(XmlILMethods.Context);
		}

		public void LoadXsltLibrary()
		{
			Emit(OpCodes.Ldarg_0);
			Call(XmlILMethods.XsltLib);
		}

		public void LoadQueryOutput()
		{
			Emit(OpCodes.Ldloc, locXOut);
		}

		public void LoadParameter(int paramPos)
		{
			switch (paramPos)
			{
			case 0:
				Emit(OpCodes.Ldarg_0);
				return;
			case 1:
				Emit(OpCodes.Ldarg_1);
				return;
			case 2:
				Emit(OpCodes.Ldarg_2);
				return;
			case 3:
				Emit(OpCodes.Ldarg_3);
				return;
			}
			if (paramPos <= 255)
			{
				Emit(OpCodes.Ldarg_S, (byte)paramPos);
				return;
			}
			if (paramPos <= 65535)
			{
				Emit(OpCodes.Ldarg, paramPos);
				return;
			}
			throw new XslTransformException("XmlIl_TooManyParameters");
		}

		public void SetParameter(object paramId)
		{
			int num = (int)paramId;
			if (num <= 255)
			{
				Emit(OpCodes.Starg_S, (byte)num);
				return;
			}
			if (num <= 65535)
			{
				Emit(OpCodes.Starg, num);
				return;
			}
			throw new XslTransformException("XmlIl_TooManyParameters");
		}

		public void BranchAndMark(Label lblBranch, Label lblMark)
		{
			if (!lblBranch.Equals(lblMark))
			{
				EmitUnconditionalBranch(OpCodes.Br, lblBranch);
			}
			MarkLabel(lblMark);
		}

		public void TestAndBranch(int i4, Label lblBranch, OpCode opcodeBranch)
		{
			if (i4 != 0)
			{
				goto IL_0083;
			}
			if (opcodeBranch.Value == OpCodes.Beq.Value)
			{
				opcodeBranch = OpCodes.Brfalse;
			}
			else if (opcodeBranch.Value == OpCodes.Beq_S.Value)
			{
				opcodeBranch = OpCodes.Brfalse_S;
			}
			else if (opcodeBranch.Value == OpCodes.Bne_Un.Value)
			{
				opcodeBranch = OpCodes.Brtrue;
			}
			else
			{
				if (opcodeBranch.Value != OpCodes.Bne_Un_S.Value)
				{
					goto IL_0083;
				}
				opcodeBranch = OpCodes.Brtrue_S;
			}
			goto IL_008a;
			IL_0083:
			LoadInteger(i4);
			goto IL_008a;
			IL_008a:
			Emit(opcodeBranch, lblBranch);
		}

		public void ConvBranchToBool(Label lblBranch, bool isTrueBranch)
		{
			Label label = DefineLabel();
			Emit(isTrueBranch ? OpCodes.Ldc_I4_0 : OpCodes.Ldc_I4_1);
			EmitUnconditionalBranch(OpCodes.Br_S, label);
			MarkLabel(lblBranch);
			Emit(isTrueBranch ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);
			MarkLabel(label);
		}

		public void TailCall(MethodInfo meth)
		{
			Emit(OpCodes.Tailcall);
			Call(meth);
			Emit(OpCodes.Ret);
		}

		[Conditional("DEBUG")]
		private void TraceCall(OpCode opcode, MethodInfo meth)
		{
		}

		public void Call(MethodInfo meth)
		{
			OpCode opcode = ((meth.IsVirtual || meth.IsAbstract) ? OpCodes.Callvirt : OpCodes.Call);
			ilgen.Emit(opcode, meth);
			if (lastSourceInfo != null)
			{
				MarkSequencePoint(SourceLineInfo.NoSource);
			}
		}

		public void CallToken(MethodInfo meth)
		{
			if (methInfo is MethodBuilder methodBuilder)
			{
				OpCode opcode = ((meth.IsVirtual || meth.IsAbstract) ? OpCodes.Callvirt : OpCodes.Call);
				ilgen.Emit(opcode, ((ModuleBuilder)methodBuilder.GetModule()).GetMethodToken(meth).Token);
				if (lastSourceInfo != null)
				{
					MarkSequencePoint(SourceLineInfo.NoSource);
				}
			}
			else
			{
				Call(meth);
			}
		}

		public void Construct(ConstructorInfo constr)
		{
			Emit(OpCodes.Newobj, constr);
		}

		public void CallConcatStrings(int cStrings)
		{
			switch (cStrings)
			{
			case 0:
				Emit(OpCodes.Ldstr, "");
				break;
			case 2:
				Call(XmlILMethods.StrCat2);
				break;
			case 3:
				Call(XmlILMethods.StrCat3);
				break;
			case 4:
				Call(XmlILMethods.StrCat4);
				break;
			case 1:
				break;
			}
		}

		public void TreatAs(Type clrTypeSrc, Type clrTypeDst)
		{
			if (clrTypeSrc != clrTypeDst)
			{
				if (clrTypeSrc.IsValueType)
				{
					Emit(OpCodes.Box, clrTypeSrc);
				}
				else if (clrTypeDst.IsValueType)
				{
					Emit(OpCodes.Unbox, clrTypeDst);
					Emit(OpCodes.Ldobj, clrTypeDst);
				}
				else if (clrTypeDst != typeof(object))
				{
					Emit(OpCodes.Castclass, clrTypeDst);
				}
			}
		}

		public void ConstructLiteralDecimal(decimal dec)
		{
			if (dec >= -2147483648m && dec <= 2147483647m && decimal.Truncate(dec) == dec)
			{
				LoadInteger((int)dec);
				Construct(XmlILConstructors.DecFromInt32);
				return;
			}
			int[] bits = decimal.GetBits(dec);
			LoadInteger(bits[0]);
			LoadInteger(bits[1]);
			LoadInteger(bits[2]);
			LoadBoolean(bits[3] < 0);
			LoadInteger(bits[3] >> 16);
			Construct(XmlILConstructors.DecFromParts);
		}

		public void ConstructLiteralQName(string localName, string namespaceName)
		{
			Emit(OpCodes.Ldstr, localName);
			Emit(OpCodes.Ldstr, namespaceName);
			Construct(XmlILConstructors.QName);
		}

		public void CallArithmeticOp(QilNodeType opType, XmlTypeCode code)
		{
			MethodInfo meth = null;
			switch (code)
			{
			case XmlTypeCode.Float:
			case XmlTypeCode.Double:
			case XmlTypeCode.Integer:
			case XmlTypeCode.Int:
				switch (opType)
				{
				case QilNodeType.Add:
					Emit(OpCodes.Add);
					break;
				case QilNodeType.Subtract:
					Emit(OpCodes.Sub);
					break;
				case QilNodeType.Multiply:
					Emit(OpCodes.Mul);
					break;
				case QilNodeType.Divide:
					Emit(OpCodes.Div);
					break;
				case QilNodeType.Modulo:
					Emit(OpCodes.Rem);
					break;
				case QilNodeType.Negate:
					Emit(OpCodes.Neg);
					break;
				}
				break;
			case XmlTypeCode.Decimal:
				switch (opType)
				{
				case QilNodeType.Add:
					meth = XmlILMethods.DecAdd;
					break;
				case QilNodeType.Subtract:
					meth = XmlILMethods.DecSub;
					break;
				case QilNodeType.Multiply:
					meth = XmlILMethods.DecMul;
					break;
				case QilNodeType.Divide:
					meth = XmlILMethods.DecDiv;
					break;
				case QilNodeType.Modulo:
					meth = XmlILMethods.DecRem;
					break;
				case QilNodeType.Negate:
					meth = XmlILMethods.DecNeg;
					break;
				}
				Call(meth);
				break;
			}
		}

		public void CallCompareEquals(XmlTypeCode code)
		{
			MethodInfo meth = null;
			switch (code)
			{
			case XmlTypeCode.String:
				meth = XmlILMethods.StrEq;
				break;
			case XmlTypeCode.QName:
				meth = XmlILMethods.QNameEq;
				break;
			case XmlTypeCode.Decimal:
				meth = XmlILMethods.DecEq;
				break;
			}
			Call(meth);
		}

		public void CallCompare(XmlTypeCode code)
		{
			MethodInfo meth = null;
			switch (code)
			{
			case XmlTypeCode.String:
				meth = XmlILMethods.StrCmp;
				break;
			case XmlTypeCode.Decimal:
				meth = XmlILMethods.DecCmp;
				break;
			}
			Call(meth);
		}

		public void CallStartRtfConstruction(string baseUri)
		{
			EnsureWriter();
			LoadQueryRuntime();
			Emit(OpCodes.Ldstr, baseUri);
			Emit(OpCodes.Ldloca, locXOut);
			Call(XmlILMethods.StartRtfConstr);
		}

		public void CallEndRtfConstruction()
		{
			LoadQueryRuntime();
			Emit(OpCodes.Ldloca, locXOut);
			Call(XmlILMethods.EndRtfConstr);
		}

		public void CallStartSequenceConstruction()
		{
			EnsureWriter();
			LoadQueryRuntime();
			Emit(OpCodes.Ldloca, locXOut);
			Call(XmlILMethods.StartSeqConstr);
		}

		public void CallEndSequenceConstruction()
		{
			LoadQueryRuntime();
			Emit(OpCodes.Ldloca, locXOut);
			Call(XmlILMethods.EndSeqConstr);
		}

		public void CallGetEarlyBoundObject(int idxObj, Type clrType)
		{
			LoadQueryRuntime();
			LoadInteger(idxObj);
			Call(XmlILMethods.GetEarly);
			TreatAs(typeof(object), clrType);
		}

		public void CallGetAtomizedName(int idxName)
		{
			LoadQueryRuntime();
			LoadInteger(idxName);
			Call(XmlILMethods.GetAtomizedName);
		}

		public void CallGetNameFilter(int idxFilter)
		{
			LoadQueryRuntime();
			LoadInteger(idxFilter);
			Call(XmlILMethods.GetNameFilter);
		}

		public void CallGetTypeFilter(XPathNodeType nodeType)
		{
			LoadQueryRuntime();
			LoadInteger((int)nodeType);
			Call(XmlILMethods.GetTypeFilter);
		}

		public void CallParseTagName(GenerateNameType nameType)
		{
			if (nameType == GenerateNameType.TagNameAndMappings)
			{
				Call(XmlILMethods.TagAndMappings);
			}
			else
			{
				Call(XmlILMethods.TagAndNamespace);
			}
		}

		public void CallGetGlobalValue(int idxValue, Type clrType)
		{
			LoadQueryRuntime();
			LoadInteger(idxValue);
			Call(XmlILMethods.GetGlobalValue);
			TreatAs(typeof(object), clrType);
		}

		public void CallSetGlobalValue(Type clrType)
		{
			TreatAs(clrType, typeof(object));
			Call(XmlILMethods.SetGlobalValue);
		}

		public void CallGetCollation(int idxName)
		{
			LoadQueryRuntime();
			LoadInteger(idxName);
			Call(XmlILMethods.GetCollation);
		}

		private void EnsureWriter()
		{
			if (!initWriters)
			{
				locXOut = DeclareLocal("$$$xwrtChk", typeof(XmlQueryOutput));
				initWriters = true;
			}
		}

		public void CallGetParameter(string localName, string namespaceUri)
		{
			LoadQueryContext();
			Emit(OpCodes.Ldstr, localName);
			Emit(OpCodes.Ldstr, namespaceUri);
			Call(XmlILMethods.GetParam);
		}

		public void CallStartTree(XPathNodeType rootType)
		{
			LoadQueryOutput();
			LoadInteger((int)rootType);
			Call(XmlILMethods.StartTree);
		}

		public void CallEndTree()
		{
			LoadQueryOutput();
			Call(XmlILMethods.EndTree);
		}

		public void CallWriteStartRoot()
		{
			LoadQueryOutput();
			Call(XmlILMethods.StartRoot);
		}

		public void CallWriteEndRoot()
		{
			LoadQueryOutput();
			Call(XmlILMethods.EndRoot);
		}

		public void CallWriteStartElement(GenerateNameType nameType, bool callChk)
		{
			MethodInfo meth = null;
			if (callChk)
			{
				switch (nameType)
				{
				case GenerateNameType.LiteralLocalName:
					meth = XmlILMethods.StartElemLocName;
					break;
				case GenerateNameType.LiteralName:
					meth = XmlILMethods.StartElemLitName;
					break;
				case GenerateNameType.CopiedName:
					meth = XmlILMethods.StartElemCopyName;
					break;
				case GenerateNameType.TagNameAndMappings:
					meth = XmlILMethods.StartElemMapName;
					break;
				case GenerateNameType.TagNameAndNamespace:
					meth = XmlILMethods.StartElemNmspName;
					break;
				case GenerateNameType.QName:
					meth = XmlILMethods.StartElemQName;
					break;
				}
			}
			else
			{
				switch (nameType)
				{
				case GenerateNameType.LiteralLocalName:
					meth = XmlILMethods.StartElemLocNameUn;
					break;
				case GenerateNameType.LiteralName:
					meth = XmlILMethods.StartElemLitNameUn;
					break;
				}
			}
			Call(meth);
		}

		public void CallWriteEndElement(GenerateNameType nameType, bool callChk)
		{
			MethodInfo meth = null;
			if (callChk)
			{
				meth = XmlILMethods.EndElemStackName;
			}
			else
			{
				switch (nameType)
				{
				case GenerateNameType.LiteralLocalName:
					meth = XmlILMethods.EndElemLocNameUn;
					break;
				case GenerateNameType.LiteralName:
					meth = XmlILMethods.EndElemLitNameUn;
					break;
				}
			}
			Call(meth);
		}

		public void CallStartElementContent()
		{
			LoadQueryOutput();
			Call(XmlILMethods.StartContentUn);
		}

		public void CallWriteStartAttribute(GenerateNameType nameType, bool callChk)
		{
			MethodInfo meth = null;
			if (callChk)
			{
				switch (nameType)
				{
				case GenerateNameType.LiteralLocalName:
					meth = XmlILMethods.StartAttrLocName;
					break;
				case GenerateNameType.LiteralName:
					meth = XmlILMethods.StartAttrLitName;
					break;
				case GenerateNameType.CopiedName:
					meth = XmlILMethods.StartAttrCopyName;
					break;
				case GenerateNameType.TagNameAndMappings:
					meth = XmlILMethods.StartAttrMapName;
					break;
				case GenerateNameType.TagNameAndNamespace:
					meth = XmlILMethods.StartAttrNmspName;
					break;
				case GenerateNameType.QName:
					meth = XmlILMethods.StartAttrQName;
					break;
				}
			}
			else
			{
				switch (nameType)
				{
				case GenerateNameType.LiteralLocalName:
					meth = XmlILMethods.StartAttrLocNameUn;
					break;
				case GenerateNameType.LiteralName:
					meth = XmlILMethods.StartAttrLitNameUn;
					break;
				}
			}
			Call(meth);
		}

		public void CallWriteEndAttribute(bool callChk)
		{
			LoadQueryOutput();
			if (callChk)
			{
				Call(XmlILMethods.EndAttr);
			}
			else
			{
				Call(XmlILMethods.EndAttrUn);
			}
		}

		public void CallWriteNamespaceDecl(bool callChk)
		{
			if (callChk)
			{
				Call(XmlILMethods.NamespaceDecl);
			}
			else
			{
				Call(XmlILMethods.NamespaceDeclUn);
			}
		}

		public void CallWriteString(bool disableOutputEscaping, bool callChk)
		{
			if (callChk)
			{
				if (disableOutputEscaping)
				{
					Call(XmlILMethods.NoEntText);
				}
				else
				{
					Call(XmlILMethods.Text);
				}
			}
			else if (disableOutputEscaping)
			{
				Call(XmlILMethods.NoEntTextUn);
			}
			else
			{
				Call(XmlILMethods.TextUn);
			}
		}

		public void CallWriteStartPI()
		{
			Call(XmlILMethods.StartPI);
		}

		public void CallWriteEndPI()
		{
			LoadQueryOutput();
			Call(XmlILMethods.EndPI);
		}

		public void CallWriteStartComment()
		{
			LoadQueryOutput();
			Call(XmlILMethods.StartComment);
		}

		public void CallWriteEndComment()
		{
			LoadQueryOutput();
			Call(XmlILMethods.EndComment);
		}

		public void CallCacheCount(Type itemStorageType)
		{
			XmlILStorageMethods xmlILStorageMethods = XmlILMethods.StorageMethods[itemStorageType];
			Call(xmlILStorageMethods.IListCount);
		}

		public void CallCacheItem(Type itemStorageType)
		{
			Call(XmlILMethods.StorageMethods[itemStorageType].IListItem);
		}

		public void CallValueAs(Type clrType)
		{
			MethodInfo valueAs = XmlILMethods.StorageMethods[clrType].ValueAs;
			if (valueAs == null)
			{
				LoadType(clrType);
				Emit(OpCodes.Ldnull);
				Call(XmlILMethods.ValueAsAny);
				TreatAs(typeof(object), clrType);
			}
			else
			{
				Call(valueAs);
			}
		}

		public void AddSortKey(XmlQueryType keyType)
		{
			MethodInfo meth = null;
			if (keyType == null)
			{
				meth = XmlILMethods.SortKeyEmpty;
			}
			else
			{
				switch (keyType.TypeCode)
				{
				case XmlTypeCode.String:
					meth = XmlILMethods.SortKeyString;
					break;
				case XmlTypeCode.Decimal:
					meth = XmlILMethods.SortKeyDecimal;
					break;
				case XmlTypeCode.Integer:
					meth = XmlILMethods.SortKeyInteger;
					break;
				case XmlTypeCode.Int:
					meth = XmlILMethods.SortKeyInt;
					break;
				case XmlTypeCode.Boolean:
					meth = XmlILMethods.SortKeyInt;
					break;
				case XmlTypeCode.Double:
					meth = XmlILMethods.SortKeyDouble;
					break;
				case XmlTypeCode.DateTime:
					meth = XmlILMethods.SortKeyDateTime;
					break;
				case XmlTypeCode.None:
					Emit(OpCodes.Pop);
					meth = XmlILMethods.SortKeyEmpty;
					break;
				case XmlTypeCode.AnyAtomicType:
					return;
				}
			}
			Call(meth);
		}

		public void DebugStartScope()
		{
			ilgen.BeginScope();
		}

		public void DebugEndScope()
		{
			ilgen.EndScope();
		}

		public void DebugSequencePoint(ISourceLineInfo sourceInfo)
		{
			Emit(OpCodes.Nop);
			MarkSequencePoint(sourceInfo);
		}

		private string GetFileName(ISourceLineInfo sourceInfo)
		{
			string uri = sourceInfo.Uri;
			if ((object)uri == lastUriString)
			{
				return lastFileName;
			}
			lastUriString = uri;
			lastFileName = SourceLineInfo.GetFileName(uri);
			return lastFileName;
		}

		private void MarkSequencePoint(ISourceLineInfo sourceInfo)
		{
			if (!sourceInfo.IsNoSource || lastSourceInfo == null || !lastSourceInfo.IsNoSource)
			{
				string fileName = GetFileName(sourceInfo);
				ISymbolDocumentWriter document = module.AddSourceDocument(fileName);
				ilgen.MarkSequencePoint(document, sourceInfo.StartLine, sourceInfo.StartPos, sourceInfo.EndLine, sourceInfo.EndPos);
				lastSourceInfo = sourceInfo;
			}
		}

		public Label DefineLabel()
		{
			return ilgen.DefineLabel();
		}

		public void MarkLabel(Label lbl)
		{
			if (lastSourceInfo != null && !lastSourceInfo.IsNoSource)
			{
				DebugSequencePoint(SourceLineInfo.NoSource);
			}
			ilgen.MarkLabel(lbl);
		}

		public void Emit(OpCode opcode)
		{
			ilgen.Emit(opcode);
		}

		public void Emit(OpCode opcode, byte byteVal)
		{
			ilgen.Emit(opcode, byteVal);
		}

		public void Emit(OpCode opcode, ConstructorInfo constrInfo)
		{
			ilgen.Emit(opcode, constrInfo);
		}

		public void Emit(OpCode opcode, double dblVal)
		{
			ilgen.Emit(opcode, dblVal);
		}

		public void Emit(OpCode opcode, float fltVal)
		{
			ilgen.Emit(opcode, fltVal);
		}

		public void Emit(OpCode opcode, FieldInfo fldInfo)
		{
			ilgen.Emit(opcode, fldInfo);
		}

		public void Emit(OpCode opcode, short shrtVal)
		{
			ilgen.Emit(opcode, shrtVal);
		}

		public void Emit(OpCode opcode, int intVal)
		{
			ilgen.Emit(opcode, intVal);
		}

		public void Emit(OpCode opcode, long longVal)
		{
			ilgen.Emit(opcode, longVal);
		}

		public void Emit(OpCode opcode, Label lblVal)
		{
			ilgen.Emit(opcode, lblVal);
		}

		public void Emit(OpCode opcode, Label[] arrLabels)
		{
			ilgen.Emit(opcode, arrLabels);
		}

		public void Emit(OpCode opcode, LocalBuilder locBldr)
		{
			ilgen.Emit(opcode, locBldr);
		}

		public void Emit(OpCode opcode, MethodInfo methInfo)
		{
			ilgen.Emit(opcode, methInfo);
		}

		public void Emit(OpCode opcode, sbyte sbyteVal)
		{
			ilgen.Emit(opcode, sbyteVal);
		}

		public void Emit(OpCode opcode, string strVal)
		{
			ilgen.Emit(opcode, strVal);
		}

		public void Emit(OpCode opcode, Type typVal)
		{
			ilgen.Emit(opcode, typVal);
		}

		public void EmitUnconditionalBranch(OpCode opcode, Label lblTarget)
		{
			if (!opcode.Equals(OpCodes.Br) && !opcode.Equals(OpCodes.Br_S))
			{
				Emit(OpCodes.Ldc_I4_1);
			}
			ilgen.Emit(opcode, lblTarget);
			if (lastSourceInfo != null && (opcode.Equals(OpCodes.Br) || opcode.Equals(OpCodes.Br_S)))
			{
				MarkSequencePoint(SourceLineInfo.NoSource);
			}
		}
	}
	internal enum ItemLocation
	{
		None,
		Stack,
		Parameter,
		Local,
		Current,
		Global
	}
	internal enum BranchingContext
	{
		None,
		OnTrue,
		OnFalse
	}
	internal struct StorageDescriptor
	{
		private ItemLocation location;

		private object locationObject;

		private Type itemStorageType;

		private bool isCached;

		public ItemLocation Location => location;

		public int ParameterLocation => (int)locationObject;

		public LocalBuilder LocalLocation => locationObject as LocalBuilder;

		public LocalBuilder CurrentLocation => locationObject as LocalBuilder;

		public MethodInfo GlobalLocation => locationObject as MethodInfo;

		public bool IsCached => isCached;

		public Type ItemStorageType => itemStorageType;

		public static StorageDescriptor None()
		{
			return default(StorageDescriptor);
		}

		public static StorageDescriptor Stack(Type itemStorageType, bool isCached)
		{
			StorageDescriptor result = default(StorageDescriptor);
			result.location = ItemLocation.Stack;
			result.itemStorageType = itemStorageType;
			result.isCached = isCached;
			return result;
		}

		public static StorageDescriptor Parameter(int paramIndex, Type itemStorageType, bool isCached)
		{
			StorageDescriptor result = default(StorageDescriptor);
			result.location = ItemLocation.Parameter;
			result.locationObject = paramIndex;
			result.itemStorageType = itemStorageType;
			result.isCached = isCached;
			return result;
		}

		public static StorageDescriptor Local(LocalBuilder loc, Type itemStorageType, bool isCached)
		{
			StorageDescriptor result = default(StorageDescriptor);
			result.location = ItemLocation.Local;
			result.locationObject = loc;
			result.itemStorageType = itemStorageType;
			result.isCached = isCached;
			return result;
		}

		public static StorageDescriptor Current(LocalBuilder locIter, Type itemStorageType)
		{
			StorageDescriptor result = default(StorageDescriptor);
			result.location = ItemLocation.Current;
			result.locationObject = locIter;
			result.itemStorageType = itemStorageType;
			return result;
		}

		public static StorageDescriptor Global(MethodInfo methGlobal, Type itemStorageType, bool isCached)
		{
			StorageDescriptor result = default(StorageDescriptor);
			result.location = ItemLocation.Global;
			result.locationObject = methGlobal;
			result.itemStorageType = itemStorageType;
			result.isCached = isCached;
			return result;
		}

		public StorageDescriptor ToStack()
		{
			return Stack(itemStorageType, isCached);
		}

		public StorageDescriptor ToLocal(LocalBuilder loc)
		{
			return Local(loc, itemStorageType, isCached);
		}

		public StorageDescriptor ToStorageType(Type itemStorageType)
		{
			StorageDescriptor result = this;
			result.itemStorageType = itemStorageType;
			return result;
		}
	}
	internal class IteratorDescriptor
	{
		private GenerateHelper helper;

		private IteratorDescriptor iterParent;

		private Label lblNext;

		private bool hasNext;

		private LocalBuilder locPos;

		private BranchingContext brctxt;

		private Label lblBranch;

		private StorageDescriptor storage;

		public IteratorDescriptor ParentIterator => iterParent;

		public bool HasLabelNext => hasNext;

		public LocalBuilder LocalPosition
		{
			get
			{
				return locPos;
			}
			set
			{
				locPos = value;
			}
		}

		public bool IsBranching => brctxt != BranchingContext.None;

		public Label LabelBranch => lblBranch;

		public BranchingContext CurrentBranchingContext => brctxt;

		public StorageDescriptor Storage
		{
			get
			{
				return storage;
			}
			set
			{
				storage = value;
			}
		}

		public IteratorDescriptor(GenerateHelper helper)
		{
			Init(null, helper);
		}

		public IteratorDescriptor(IteratorDescriptor iterParent)
		{
			Init(iterParent, iterParent.helper);
		}

		private void Init(IteratorDescriptor iterParent, GenerateHelper helper)
		{
			this.helper = helper;
			this.iterParent = iterParent;
		}

		public Label GetLabelNext()
		{
			return lblNext;
		}

		public void SetIterator(Label lblNext, StorageDescriptor storage)
		{
			this.lblNext = lblNext;
			hasNext = true;
			this.storage = storage;
		}

		public void SetIterator(IteratorDescriptor iterInfo)
		{
			if (iterInfo.HasLabelNext)
			{
				lblNext = iterInfo.GetLabelNext();
				hasNext = true;
			}
			storage = iterInfo.Storage;
		}

		public void LoopToEnd(Label lblOnEnd)
		{
			if (hasNext)
			{
				helper.BranchAndMark(lblNext, lblOnEnd);
				hasNext = false;
			}
			storage = StorageDescriptor.None();
		}

		public void CacheCount()
		{
			PushValue();
			helper.CallCacheCount(storage.ItemStorageType);
		}

		public void EnsureNoCache()
		{
			if (storage.IsCached)
			{
				if (!HasLabelNext)
				{
					EnsureStack();
					helper.LoadInteger(0);
					helper.CallCacheItem(storage.ItemStorageType);
					storage = StorageDescriptor.Stack(storage.ItemStorageType, isCached: false);
					return;
				}
				LocalBuilder locBldr = helper.DeclareLocal("$$$idx", typeof(int));
				EnsureNoStack("$$$cache");
				helper.LoadInteger(-1);
				helper.Emit(OpCodes.Stloc, locBldr);
				Label lbl = helper.DefineLabel();
				helper.MarkLabel(lbl);
				helper.Emit(OpCodes.Ldloc, locBldr);
				helper.LoadInteger(1);
				helper.Emit(OpCodes.Add);
				helper.Emit(OpCodes.Stloc, locBldr);
				helper.Emit(OpCodes.Ldloc, locBldr);
				CacheCount();
				helper.Emit(OpCodes.Bge, GetLabelNext());
				PushValue();
				helper.Emit(OpCodes.Ldloc, locBldr);
				helper.CallCacheItem(storage.ItemStorageType);
				SetIterator(lbl, StorageDescriptor.Stack(storage.ItemStorageType, isCached: false));
			}
		}

		public void SetBranching(BranchingContext brctxt, Label lblBranch)
		{
			this.brctxt = brctxt;
			this.lblBranch = lblBranch;
		}

		public void PushValue()
		{
			switch (storage.Location)
			{
			case ItemLocation.Stack:
				helper.Emit(OpCodes.Dup);
				break;
			case ItemLocation.Parameter:
				helper.LoadParameter(storage.ParameterLocation);
				break;
			case ItemLocation.Local:
				helper.Emit(OpCodes.Ldloc, storage.LocalLocation);
				break;
			case ItemLocation.Current:
				helper.Emit(OpCodes.Ldloca, storage.CurrentLocation);
				helper.Call(storage.CurrentLocation.LocalType.GetMethod("get_Current"));
				break;
			}
		}

		public void EnsureStack()
		{
			switch (storage.Location)
			{
			case ItemLocation.Stack:
				return;
			case ItemLocation.Parameter:
			case ItemLocation.Local:
			case ItemLocation.Current:
				PushValue();
				break;
			case ItemLocation.Global:
				helper.LoadQueryRuntime();
				helper.Call(storage.GlobalLocation);
				break;
			}
			storage = storage.ToStack();
		}

		public void EnsureNoStack(string locName)
		{
			if (storage.Location == ItemLocation.Stack)
			{
				EnsureLocal(locName);
			}
		}

		public void EnsureLocal(string locName)
		{
			if (storage.Location != ItemLocation.Local)
			{
				if (storage.IsCached)
				{
					EnsureLocal(helper.DeclareLocal(locName, typeof(IList<>).MakeGenericType(storage.ItemStorageType)));
				}
				else
				{
					EnsureLocal(helper.DeclareLocal(locName, storage.ItemStorageType));
				}
			}
		}

		public void EnsureLocal(LocalBuilder bldr)
		{
			if (storage.LocalLocation != bldr)
			{
				EnsureStack();
				helper.Emit(OpCodes.Stloc, bldr);
				storage = storage.ToLocal(bldr);
			}
		}

		public void DiscardStack()
		{
			if (storage.Location == ItemLocation.Stack)
			{
				helper.Emit(OpCodes.Pop);
				storage = StorageDescriptor.None();
			}
		}

		public void EnsureStackNoCache()
		{
			EnsureNoCache();
			EnsureStack();
		}

		public void EnsureNoStackNoCache(string locName)
		{
			EnsureNoCache();
			EnsureNoStack(locName);
		}

		public void EnsureLocalNoCache(string locName)
		{
			EnsureNoCache();
			EnsureLocal(locName);
		}

		public void EnsureLocalNoCache(LocalBuilder bldr)
		{
			EnsureNoCache();
			EnsureLocal(bldr);
		}

		public void EnsureItemStorageType(XmlQueryType xmlType, Type storageTypeDest)
		{
			if (storage.ItemStorageType != storageTypeDest)
			{
				if (!storage.IsCached)
				{
					goto IL_0078;
				}
				if (storage.ItemStorageType == typeof(XPathNavigator))
				{
					EnsureStack();
					helper.Call(XmlILMethods.NavsToItems);
				}
				else
				{
					if (storageTypeDest != typeof(XPathNavigator))
					{
						goto IL_0078;
					}
					EnsureStack();
					helper.Call(XmlILMethods.ItemsToNavs);
				}
			}
			goto IL_012f;
			IL_012f:
			storage = storage.ToStorageType(storageTypeDest);
			return;
			IL_0078:
			EnsureStackNoCache();
			if (storage.ItemStorageType == typeof(XPathItem))
			{
				if (storageTypeDest == typeof(XPathNavigator))
				{
					helper.Emit(OpCodes.Castclass, typeof(XPathNavigator));
				}
				else
				{
					helper.CallValueAs(storageTypeDest);
				}
			}
			else if (storage.ItemStorageType != typeof(XPathNavigator))
			{
				helper.LoadInteger(helper.StaticData.DeclareXmlType(xmlType));
				helper.LoadQueryRuntime();
				helper.Call(XmlILMethods.StorageMethods[storage.ItemStorageType].ToAtomicValue);
			}
			goto IL_012f;
		}
	}
	internal enum OptimizerPatternName
	{
		None,
		DodReverse,
		EqualityIndex,
		FilterAttributeKind,
		FilterContentKind,
		FilterElements,
		IsDocOrderDistinct,
		IsPositional,
		JoinAndDod,
		MaxPosition,
		SameDepth,
		Step,
		SingleTextRtf,
		Axis,
		MaybeSideEffects,
		TailCall,
		DodMerge
	}
	internal enum OptimizerPatternArgument
	{
		StepNode = 0,
		StepInput = 1,
		ElementQName = 2,
		KindTestType = 2,
		IndexedNodes = 0,
		KeyExpression = 1,
		DodStep = 2,
		MaxPosition = 2,
		RtfText = 2
	}
}
namespace System.Xml.Xsl.Qil
{
	internal interface IQilAnnotation
	{
		string Name { get; }
	}
}
namespace System.Xml.Xsl.IlGen
{
	internal class OptimizerPatterns : IQilAnnotation
	{
		private static readonly int PatternCount = Enum.GetValues(typeof(OptimizerPatternName)).Length;

		private int patterns;

		private bool isReadOnly;

		private object arg0;

		private object arg1;

		private object arg2;

		private static OptimizerPatterns ZeroOrOneDefault;

		private static OptimizerPatterns MaybeManyDefault;

		private static OptimizerPatterns DodDefault;

		public virtual string Name => "Patterns";

		public static OptimizerPatterns Read(QilNode nd)
		{
			OptimizerPatterns optimizerPatterns = ((nd.Annotation is XmlILAnnotation xmlILAnnotation) ? xmlILAnnotation.Patterns : null);
			if (optimizerPatterns == null)
			{
				if (!nd.XmlType.MaybeMany)
				{
					if (ZeroOrOneDefault == null)
					{
						optimizerPatterns = new OptimizerPatterns();
						optimizerPatterns.AddPattern(OptimizerPatternName.IsDocOrderDistinct);
						optimizerPatterns.AddPattern(OptimizerPatternName.SameDepth);
						optimizerPatterns.isReadOnly = true;
						ZeroOrOneDefault = optimizerPatterns;
					}
					else
					{
						optimizerPatterns = ZeroOrOneDefault;
					}
				}
				else if (nd.XmlType.IsDod)
				{
					if (DodDefault == null)
					{
						optimizerPatterns = new OptimizerPatterns();
						optimizerPatterns.AddPattern(OptimizerPatternName.IsDocOrderDistinct);
						optimizerPatterns.isReadOnly = true;
						DodDefault = optimizerPatterns;
					}
					else
					{
						optimizerPatterns = DodDefault;
					}
				}
				else if (MaybeManyDefault == null)
				{
					optimizerPatterns = new OptimizerPatterns();
					optimizerPatterns.isReadOnly = true;
					MaybeManyDefault = optimizerPatterns;
				}
				else
				{
					optimizerPatterns = MaybeManyDefault;
				}
			}
			return optimizerPatterns;
		}

		public static OptimizerPatterns Write(QilNode nd)
		{
			XmlILAnnotation xmlILAnnotation = XmlILAnnotation.Write(nd);
			OptimizerPatterns optimizerPatterns = xmlILAnnotation.Patterns;
			if (optimizerPatterns == null || optimizerPatterns.isReadOnly)
			{
				optimizerPatterns = (xmlILAnnotation.Patterns = new OptimizerPatterns());
				if (!nd.XmlType.MaybeMany)
				{
					optimizerPatterns.AddPattern(OptimizerPatternName.IsDocOrderDistinct);
					optimizerPatterns.AddPattern(OptimizerPatternName.SameDepth);
				}
				else if (nd.XmlType.IsDod)
				{
					optimizerPatterns.AddPattern(OptimizerPatternName.IsDocOrderDistinct);
				}
			}
			return optimizerPatterns;
		}

		public static void Inherit(QilNode ndSrc, QilNode ndDst, OptimizerPatternName pattern)
		{
			OptimizerPatterns optimizerPatterns = Read(ndSrc);
			if (optimizerPatterns.MatchesPattern(pattern))
			{
				OptimizerPatterns optimizerPatterns2 = Write(ndDst);
				optimizerPatterns2.AddPattern(pattern);
				switch (pattern)
				{
				case OptimizerPatternName.Step:
					optimizerPatterns2.AddArgument(OptimizerPatternArgument.StepNode, optimizerPatterns.GetArgument(OptimizerPatternArgument.StepNode));
					optimizerPatterns2.AddArgument(OptimizerPatternArgument.StepInput, optimizerPatterns.GetArgument(OptimizerPatternArgument.StepInput));
					break;
				case OptimizerPatternName.FilterElements:
					optimizerPatterns2.AddArgument(OptimizerPatternArgument.ElementQName, optimizerPatterns.GetArgument(OptimizerPatternArgument.ElementQName));
					break;
				case OptimizerPatternName.FilterContentKind:
					optimizerPatterns2.AddArgument(OptimizerPatternArgument.ElementQName, optimizerPatterns.GetArgument(OptimizerPatternArgument.ElementQName));
					break;
				case OptimizerPatternName.EqualityIndex:
					optimizerPatterns2.AddArgument(OptimizerPatternArgument.StepNode, optimizerPatterns.GetArgument(OptimizerPatternArgument.StepNode));
					optimizerPatterns2.AddArgument(OptimizerPatternArgument.StepInput, optimizerPatterns.GetArgument(OptimizerPatternArgument.StepInput));
					break;
				case OptimizerPatternName.DodReverse:
				case OptimizerPatternName.JoinAndDod:
					optimizerPatterns2.AddArgument(OptimizerPatternArgument.ElementQName, optimizerPatterns.GetArgument(OptimizerPatternArgument.ElementQName));
					break;
				case OptimizerPatternName.MaxPosition:
					optimizerPatterns2.AddArgument(OptimizerPatternArgument.ElementQName, optimizerPatterns.GetArgument(OptimizerPatternArgument.ElementQName));
					break;
				case OptimizerPatternName.SingleTextRtf:
					optimizerPatterns2.AddArgument(OptimizerPatternArgument.ElementQName, optimizerPatterns.GetArgument(OptimizerPatternArgument.ElementQName));
					break;
				case OptimizerPatternName.FilterAttributeKind:
				case OptimizerPatternName.IsDocOrderDistinct:
				case OptimizerPatternName.IsPositional:
				case OptimizerPatternName.SameDepth:
					break;
				}
			}
		}

		public void AddArgument(OptimizerPatternArgument argId, object arg)
		{
			switch (argId)
			{
			case OptimizerPatternArgument.StepNode:
				arg0 = arg;
				break;
			case OptimizerPatternArgument.StepInput:
				arg1 = arg;
				break;
			case OptimizerPatternArgument.ElementQName:
				arg2 = arg;
				break;
			}
		}

		public object GetArgument(OptimizerPatternArgument argNum)
		{
			object result = null;
			switch (argNum)
			{
			case OptimizerPatternArgument.StepNode:
				result = arg0;
				break;
			case OptimizerPatternArgument.StepInput:
				result = arg1;
				break;
			case OptimizerPatternArgument.ElementQName:
				result = arg2;
				break;
			}
			return result;
		}

		public void AddPattern(OptimizerPatternName pattern)
		{
			patterns |= 1 << (int)pattern;
		}

		public bool MatchesPattern(OptimizerPatternName pattern)
		{
			return (patterns & (1 << (int)pattern)) != 0;
		}

		public override string ToString()
		{
			string text = "";
			for (int i = 0; i < PatternCount; i++)
			{
				if (MatchesPattern((OptimizerPatternName)i))
				{
					if (text.Length != 0)
					{
						text += ", ";
					}
					text += (OptimizerPatternName)i;
				}
			}
			return text;
		}
	}
	internal class UniqueList<T>
	{
		private Dictionary<T, int> lookup = new Dictionary<T, int>();

		private List<T> list = new List<T>();

		public int Add(T value)
		{
			int num;
			if (!lookup.ContainsKey(value))
			{
				num = list.Count;
				lookup.Add(value, num);
				list.Add(value);
			}
			else
			{
				num = lookup[value];
			}
			return num;
		}

		public T[] ToArray()
		{
			return list.ToArray();
		}
	}
	internal class StaticDataManager
	{
		private UniqueList<string> uniqueNames;

		private UniqueList<Int32Pair> uniqueFilters;

		private List<StringPair[]> prefixMappingsList;

		private List<string> globalNames;

		private UniqueList<EarlyBoundInfo> earlyInfo;

		private UniqueList<XmlQueryType> uniqueXmlTypes;

		private UniqueList<XmlCollation> uniqueCollations;

		public string[] Names
		{
			get
			{
				if (uniqueNames == null)
				{
					return null;
				}
				return uniqueNames.ToArray();
			}
		}

		public Int32Pair[] NameFilters
		{
			get
			{
				if (uniqueFilters == null)
				{
					return null;
				}
				return uniqueFilters.ToArray();
			}
		}

		public StringPair[][] PrefixMappingsList
		{
			get
			{
				if (prefixMappingsList == null)
				{
					return null;
				}
				return prefixMappingsList.ToArray();
			}
		}

		public string[] GlobalNames
		{
			get
			{
				if (globalNames == null)
				{
					return null;
				}
				return globalNames.ToArray();
			}
		}

		public EarlyBoundInfo[] EarlyBound
		{
			get
			{
				if (earlyInfo != null)
				{
					return earlyInfo.ToArray();
				}
				return null;
			}
		}

		public XmlQueryType[] XmlTypes
		{
			get
			{
				if (uniqueXmlTypes == null)
				{
					return null;
				}
				return uniqueXmlTypes.ToArray();
			}
		}

		public XmlCollation[] Collations
		{
			get
			{
				if (uniqueCollations == null)
				{
					return null;
				}
				return uniqueCollations.ToArray();
			}
		}

		public int DeclareName(string name)
		{
			if (uniqueNames == null)
			{
				uniqueNames = new UniqueList<string>();
			}
			return uniqueNames.Add(name);
		}

		public int DeclareNameFilter(string locName, string nsUri)
		{
			if (uniqueFilters == null)
			{
				uniqueFilters = new UniqueList<Int32Pair>();
			}
			return uniqueFilters.Add(new Int32Pair(DeclareName(locName), DeclareName(nsUri)));
		}

		public int DeclarePrefixMappings(IList<QilNode> list)
		{
			StringPair[] array = new StringPair[list.Count];
			for (int i = 0; i < list.Count; i++)
			{
				QilBinary qilBinary = (QilBinary)list[i];
				ref StringPair reference = ref array[i];
				reference = new StringPair((QilLiteral)qilBinary.Left, (QilLiteral)qilBinary.Right);
			}
			if (prefixMappingsList == null)
			{
				prefixMappingsList = new List<StringPair[]>();
			}
			prefixMappingsList.Add(array);
			return prefixMappingsList.Count - 1;
		}

		public int DeclareGlobalValue(string name)
		{
			if (globalNames == null)
			{
				globalNames = new List<string>();
			}
			int count = globalNames.Count;
			globalNames.Add(name);
			return count;
		}

		public int DeclareEarlyBound(string namespaceUri, Type ebType)
		{
			if (earlyInfo == null)
			{
				earlyInfo = new UniqueList<EarlyBoundInfo>();
			}
			return earlyInfo.Add(new EarlyBoundInfo(namespaceUri, ebType));
		}

		public int DeclareXmlType(XmlQueryType type)
		{
			if (uniqueXmlTypes == null)
			{
				uniqueXmlTypes = new UniqueList<XmlQueryType>();
			}
			return uniqueXmlTypes.Add(type);
		}

		public int DeclareCollation(string collation)
		{
			if (uniqueCollations == null)
			{
				uniqueCollations = new UniqueList<XmlCollation>();
			}
			return uniqueCollations.Add(XmlCollation.Create(collation));
		}
	}
	internal static class TailCallAnalyzer
	{
		public static void Analyze(QilExpression qil)
		{
			foreach (QilFunction function in qil.FunctionList)
			{
				if (XmlILConstructInfo.Read(function).ConstructMethod == XmlILConstructMethod.Writer)
				{
					AnalyzeDefinition(function.Definition);
				}
			}
		}

		private static void AnalyzeDefinition(QilNode nd)
		{
			switch (nd.NodeType)
			{
			case QilNodeType.Invoke:
				if (XmlILConstructInfo.Read(nd).ConstructMethod == XmlILConstructMethod.Writer)
				{
					OptimizerPatterns.Write(nd).AddPattern(OptimizerPatternName.TailCall);
				}
				break;
			case QilNodeType.Loop:
			{
				QilLoop qilLoop = (QilLoop)nd;
				if (qilLoop.Variable.NodeType == QilNodeType.Let || !qilLoop.Variable.Binding.XmlType.MaybeMany)
				{
					AnalyzeDefinition(qilLoop.Body);
				}
				break;
			}
			case QilNodeType.Sequence:
			{
				QilList qilList = (QilList)nd;
				if (qilList.Count > 0)
				{
					AnalyzeDefinition(qilList[qilList.Count - 1]);
				}
				break;
			}
			case QilNodeType.Choice:
			{
				QilChoice qilChoice = (QilChoice)nd;
				for (int i = 0; i < qilChoice.Branches.Count; i++)
				{
					AnalyzeDefinition(qilChoice.Branches[i]);
				}
				break;
			}
			case QilNodeType.Conditional:
			{
				QilTernary qilTernary = (QilTernary)nd;
				AnalyzeDefinition(qilTernary.Center);
				AnalyzeDefinition(qilTernary.Right);
				break;
			}
			case QilNodeType.Nop:
				AnalyzeDefinition(((QilUnary)nd).Child);
				break;
			}
		}
	}
}
namespace System.Xml.Xsl.Qil
{
	internal abstract class QilVisitor
	{
		protected virtual QilNode VisitAssumeReference(QilNode expr)
		{
			if (expr is QilReference)
			{
				return VisitReference(expr);
			}
			return Visit(expr);
		}

		protected virtual QilNode VisitChildren(QilNode parent)
		{
			for (int i = 0; i < parent.Count; i++)
			{
				if (IsReference(parent, i))
				{
					VisitReference(parent[i]);
				}
				else
				{
					Visit(parent[i]);
				}
			}
			return parent;
		}

		protected virtual bool IsReference(QilNode parent, int childNum)
		{
			QilNode qilNode = parent[childNum];
			if (qilNode != null)
			{
				switch (qilNode.NodeType)
				{
				case QilNodeType.For:
				case QilNodeType.Let:
				case QilNodeType.Parameter:
					switch (parent.NodeType)
					{
					case QilNodeType.Loop:
					case QilNodeType.Filter:
					case QilNodeType.Sort:
						return childNum == 1;
					case QilNodeType.GlobalVariableList:
					case QilNodeType.GlobalParameterList:
					case QilNodeType.FormalParameterList:
						return false;
					default:
						return true;
					}
				case QilNodeType.Function:
					return parent.NodeType == QilNodeType.Invoke;
				}
			}
			return false;
		}

		protected virtual QilNode Visit(QilNode n)
		{
			if (n == null)
			{
				return VisitNull();
			}
			return n.NodeType switch
			{
				QilNodeType.QilExpression => VisitQilExpression((QilExpression)n), 
				QilNodeType.FunctionList => VisitFunctionList((QilList)n), 
				QilNodeType.GlobalVariableList => VisitGlobalVariableList((QilList)n), 
				QilNodeType.GlobalParameterList => VisitGlobalParameterList((QilList)n), 
				QilNodeType.ActualParameterList => VisitActualParameterList((QilList)n), 
				QilNodeType.FormalParameterList => VisitFormalParameterList((QilList)n), 
				QilNodeType.SortKeyList => VisitSortKeyList((QilList)n), 
				QilNodeType.BranchList => VisitBranchList((QilList)n), 
				QilNodeType.OptimizeBarrier => VisitOptimizeBarrier((QilUnary)n), 
				QilNodeType.Unknown => VisitUnknown(n), 
				QilNodeType.DataSource => VisitDataSource((QilDataSource)n), 
				QilNodeType.Nop => VisitNop((QilUnary)n), 
				QilNodeType.Error => VisitError((QilUnary)n), 
				QilNodeType.Warning => VisitWarning((QilUnary)n), 
				QilNodeType.For => VisitFor((QilIterator)n), 
				QilNodeType.Let => VisitLet((QilIterator)n), 
				QilNodeType.Parameter => VisitParameter((QilParameter)n), 
				QilNodeType.PositionOf => VisitPositionOf((QilUnary)n), 
				QilNodeType.True => VisitTrue(n), 
				QilNodeType.False => VisitFalse(n), 
				QilNodeType.LiteralString => VisitLiteralString((QilLiteral)n), 
				QilNodeType.LiteralInt32 => VisitLiteralInt32((QilLiteral)n), 
				QilNodeType.LiteralInt64 => VisitLiteralInt64((QilLiteral)n), 
				QilNodeType.LiteralDouble => VisitLiteralDouble((QilLiteral)n), 
				QilNodeType.LiteralDecimal => VisitLiteralDecimal((QilLiteral)n), 
				QilNodeType.LiteralQName => VisitLiteralQName((QilName)n), 
				QilNodeType.LiteralType => VisitLiteralType((QilLiteral)n), 
				QilNodeType.LiteralObject => VisitLiteralObject((QilLiteral)n), 
				QilNodeType.And => VisitAnd((QilBinary)n), 
				QilNodeType.Or => VisitOr((QilBinary)n), 
				QilNodeType.Not => VisitNot((QilUnary)n), 
				QilNodeType.Conditional => VisitConditional((QilTernary)n), 
				QilNodeType.Choice => VisitChoice((QilChoice)n), 
				QilNodeType.Length => VisitLength((QilUnary)n), 
				QilNodeType.Sequence => VisitSequence((QilList)n), 
				QilNodeType.Union => VisitUnion((QilBinary)n), 
				QilNodeType.Intersection => VisitIntersection((QilBinary)n), 
				QilNodeType.Difference => VisitDifference((QilBinary)n), 
				QilNodeType.Average => VisitAverage((QilUnary)n), 
				QilNodeType.Sum => VisitSum((QilUnary)n), 
				QilNodeType.Minimum => VisitMinimum((QilUnary)n), 
				QilNodeType.Maximum => VisitMaximum((QilUnary)n), 
				QilNodeType.Negate => VisitNegate((QilUnary)n), 
				QilNodeType.Add => VisitAdd((QilBinary)n), 
				QilNodeType.Subtract => VisitSubtract((QilBinary)n), 
				QilNodeType.Multiply => VisitMultiply((QilBinary)n), 
				QilNodeType.Divide => VisitDivide((QilBinary)n), 
				QilNodeType.Modulo => VisitModulo((QilBinary)n), 
				QilNodeType.StrLength => VisitStrLength((QilUnary)n), 
				QilNodeType.StrConcat => VisitStrConcat((QilStrConcat)n), 
				QilNodeType.StrParseQName => VisitStrParseQName((QilBinary)n), 
				QilNodeType.Ne => VisitNe((QilBinary)n), 
				QilNodeType.Eq => VisitEq((QilBinary)n), 
				QilNodeType.Gt => VisitGt((QilBinary)n), 
				QilNodeType.Ge => VisitGe((QilBinary)n), 
				QilNodeType.Lt => VisitLt((QilBinary)n), 
				QilNodeType.Le => VisitLe((QilBinary)n), 
				QilNodeType.Is => VisitIs((QilBinary)n), 
				QilNodeType.After => VisitAfter((QilBinary)n), 
				QilNodeType.Before => VisitBefore((QilBinary)n), 
				QilNodeType.Loop => VisitLoop((QilLoop)n), 
				QilNodeType.Filter => VisitFilter((QilLoop)n), 
				QilNodeType.Sort => VisitSort((QilLoop)n), 
				QilNodeType.SortKey => VisitSortKey((QilSortKey)n), 
				QilNodeType.DocOrderDistinct => VisitDocOrderDistinct((QilUnary)n), 
				QilNodeType.Function => VisitFunction((QilFunction)n), 
				QilNodeType.Invoke => VisitInvoke((QilInvoke)n), 
				QilNodeType.Content => VisitContent((QilUnary)n), 
				QilNodeType.Attribute => VisitAttribute((QilBinary)n), 
				QilNodeType.Parent => VisitParent((QilUnary)n), 
				QilNodeType.Root => VisitRoot((QilUnary)n), 
				QilNodeType.XmlContext => VisitXmlContext(n), 
				QilNodeType.Descendant => VisitDescendant((QilUnary)n), 
				QilNodeType.DescendantOrSelf => VisitDescendantOrSelf((QilUnary)n), 
				QilNodeType.Ancestor => VisitAncestor((QilUnary)n), 
				QilNodeType.AncestorOrSelf => VisitAncestorOrSelf((QilUnary)n), 
				QilNodeType.Preceding => VisitPreceding((QilUnary)n), 
				QilNodeType.FollowingSibling => VisitFollowingSibling((QilUnary)n), 
				QilNodeType.PrecedingSibling => VisitPrecedingSibling((QilUnary)n), 
				QilNodeType.NodeRange => VisitNodeRange((QilBinary)n), 
				QilNodeType.Deref => VisitDeref((QilBinary)n), 
				QilNodeType.ElementCtor => VisitElementCtor((QilBinary)n), 
				QilNodeType.AttributeCtor => VisitAttributeCtor((QilBinary)n), 
				QilNodeType.CommentCtor => VisitCommentCtor((QilUnary)n), 
				QilNodeType.PICtor => VisitPICtor((QilBinary)n), 
				QilNodeType.TextCtor => VisitTextCtor((QilUnary)n), 
				QilNodeType.RawTextCtor => VisitRawTextCtor((QilUnary)n), 
				QilNodeType.DocumentCtor => VisitDocumentCtor((QilUnary)n), 
				QilNodeType.NamespaceDecl => VisitNamespaceDecl((QilBinary)n), 
				QilNodeType.RtfCtor => VisitRtfCtor((QilBinary)n), 
				QilNodeType.NameOf => VisitNameOf((QilUnary)n), 
				QilNodeType.LocalNameOf => VisitLocalNameOf((QilUnary)n), 
				QilNodeType.NamespaceUriOf => VisitNamespaceUriOf((QilUnary)n), 
				QilNodeType.PrefixOf => VisitPrefixOf((QilUnary)n), 
				QilNodeType.TypeAssert => VisitTypeAssert((QilTargetType)n), 
				QilNodeType.IsType => VisitIsType((QilTargetType)n), 
				QilNodeType.IsEmpty => VisitIsEmpty((QilUnary)n), 
				QilNodeType.XPathNodeValue => VisitXPathNodeValue((QilUnary)n), 
				QilNodeType.XPathFollowing => VisitXPathFollowing((QilUnary)n), 
				QilNodeType.XPathPreceding => VisitXPathPreceding((QilUnary)n), 
				QilNodeType.XPathNamespace => VisitXPathNamespace((QilUnary)n), 
				QilNodeType.XsltGenerateId => VisitXsltGenerateId((QilUnary)n), 
				QilNodeType.XsltInvokeLateBound => VisitXsltInvokeLateBound((QilInvokeLateBound)n), 
				QilNodeType.XsltInvokeEarlyBound => VisitXsltInvokeEarlyBound((QilInvokeEarlyBound)n), 
				QilNodeType.XsltCopy => VisitXsltCopy((QilBinary)n), 
				QilNodeType.XsltCopyOf => VisitXsltCopyOf((QilUnary)n), 
				QilNodeType.XsltConvert => VisitXsltConvert((QilTargetType)n), 
				_ => VisitUnknown(n), 
			};
		}

		protected virtual QilNode VisitReference(QilNode n)
		{
			if (n == null)
			{
				return VisitNull();
			}
			return n.NodeType switch
			{
				QilNodeType.For => VisitForReference((QilIterator)n), 
				QilNodeType.Let => VisitLetReference((QilIterator)n), 
				QilNodeType.Parameter => VisitParameterReference((QilParameter)n), 
				QilNodeType.Function => VisitFunctionReference((QilFunction)n), 
				_ => VisitUnknown(n), 
			};
		}

		protected virtual QilNode VisitNull()
		{
			return null;
		}

		protected virtual QilNode VisitQilExpression(QilExpression n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitFunctionList(QilList n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitGlobalVariableList(QilList n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitGlobalParameterList(QilList n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitActualParameterList(QilList n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitFormalParameterList(QilList n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitSortKeyList(QilList n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitBranchList(QilList n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitOptimizeBarrier(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitUnknown(QilNode n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitDataSource(QilDataSource n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitNop(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitError(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitWarning(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitFor(QilIterator n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitForReference(QilIterator n)
		{
			return n;
		}

		protected virtual QilNode VisitLet(QilIterator n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitLetReference(QilIterator n)
		{
			return n;
		}

		protected virtual QilNode VisitParameter(QilParameter n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitParameterReference(QilParameter n)
		{
			return n;
		}

		protected virtual QilNode VisitPositionOf(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitTrue(QilNode n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitFalse(QilNode n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitLiteralString(QilLiteral n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitLiteralInt32(QilLiteral n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitLiteralInt64(QilLiteral n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitLiteralDouble(QilLiteral n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitLiteralDecimal(QilLiteral n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitLiteralQName(QilName n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitLiteralType(QilLiteral n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitLiteralObject(QilLiteral n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitAnd(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitOr(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitNot(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitConditional(QilTernary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitChoice(QilChoice n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitLength(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitSequence(QilList n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitUnion(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitIntersection(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitDifference(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitAverage(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitSum(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitMinimum(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitMaximum(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitNegate(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitAdd(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitSubtract(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitMultiply(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitDivide(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitModulo(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitStrLength(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitStrConcat(QilStrConcat n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitStrParseQName(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitNe(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitEq(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitGt(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitGe(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitLt(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitLe(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitIs(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitAfter(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitBefore(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitLoop(QilLoop n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitFilter(QilLoop n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitSort(QilLoop n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitSortKey(QilSortKey n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitDocOrderDistinct(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitFunction(QilFunction n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitFunctionReference(QilFunction n)
		{
			return n;
		}

		protected virtual QilNode VisitInvoke(QilInvoke n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitContent(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitAttribute(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitParent(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitRoot(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitXmlContext(QilNode n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitDescendant(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitDescendantOrSelf(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitAncestor(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitAncestorOrSelf(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitPreceding(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitFollowingSibling(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitPrecedingSibling(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitNodeRange(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitDeref(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitElementCtor(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitAttributeCtor(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitCommentCtor(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitPICtor(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitTextCtor(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitRawTextCtor(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitDocumentCtor(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitNamespaceDecl(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitRtfCtor(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitNameOf(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitLocalNameOf(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitNamespaceUriOf(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitPrefixOf(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitTypeAssert(QilTargetType n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitIsType(QilTargetType n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitIsEmpty(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitXPathNodeValue(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitXPathFollowing(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitXPathPreceding(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitXPathNamespace(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitXsltGenerateId(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitXsltInvokeLateBound(QilInvokeLateBound n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitXsltInvokeEarlyBound(QilInvokeEarlyBound n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitXsltCopy(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitXsltCopyOf(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitXsltConvert(QilTargetType n)
		{
			return VisitChildren(n);
		}
	}
}
namespace System.Xml.Xsl.IlGen
{
	internal class XmlILVisitor : QilVisitor
	{
		private QilExpression qil;

		private GenerateHelper helper;

		private IteratorDescriptor iterCurr;

		private IteratorDescriptor iterNested;

		private int indexId;

		public void Visit(QilExpression qil, GenerateHelper helper, MethodInfo methRoot)
		{
			this.qil = qil;
			this.helper = helper;
			iterNested = null;
			indexId = 0;
			PrepareGlobalValues(qil.GlobalParameterList);
			PrepareGlobalValues(qil.GlobalVariableList);
			VisitGlobalValues(qil.GlobalParameterList);
			VisitGlobalValues(qil.GlobalVariableList);
			foreach (QilFunction function in qil.FunctionList)
			{
				Function(function);
			}
			this.helper.MethodBegin(methRoot, null, initWriters: true);
			StartNestedIterator(qil.Root);
			Visit(qil.Root);
			EndNestedIterator(qil.Root);
			this.helper.MethodEnd();
		}

		private void PrepareGlobalValues(QilList globalIterators)
		{
			foreach (QilIterator globalIterator in globalIterators)
			{
				MethodInfo functionBinding = XmlILAnnotation.Write(globalIterator).FunctionBinding;
				IteratorDescriptor iteratorDescriptor = new IteratorDescriptor(helper);
				iteratorDescriptor.Storage = StorageDescriptor.Global(functionBinding, GetItemStorageType(globalIterator), !globalIterator.XmlType.IsSingleton);
				XmlILAnnotation.Write(globalIterator).CachedIteratorDescriptor = iteratorDescriptor;
			}
		}

		private void VisitGlobalValues(QilList globalIterators)
		{
			foreach (QilIterator globalIterator in globalIterators)
			{
				QilParameter qilParameter = globalIterator as QilParameter;
				MethodInfo globalLocation = XmlILAnnotation.Write(globalIterator).CachedIteratorDescriptor.Storage.GlobalLocation;
				bool isCached = !globalIterator.XmlType.IsSingleton;
				int num = helper.StaticData.DeclareGlobalValue(globalIterator.DebugName);
				helper.MethodBegin(globalLocation, globalIterator.SourceLine, initWriters: false);
				Label label = helper.DefineLabel();
				Label label2 = helper.DefineLabel();
				helper.LoadQueryRuntime();
				helper.LoadInteger(num);
				helper.Call(XmlILMethods.GlobalComputed);
				helper.Emit(OpCodes.Brtrue, label);
				StartNestedIterator(globalIterator);
				if (qilParameter != null)
				{
					LocalBuilder locBldr = helper.DeclareLocal("$$$param", typeof(object));
					helper.CallGetParameter(qilParameter.Name.LocalName, qilParameter.Name.NamespaceUri);
					helper.Emit(OpCodes.Stloc, locBldr);
					helper.Emit(OpCodes.Ldloc, locBldr);
					helper.Emit(OpCodes.Brfalse, label2);
					helper.LoadQueryRuntime();
					helper.LoadInteger(num);
					helper.LoadQueryRuntime();
					helper.LoadInteger(helper.StaticData.DeclareXmlType(XmlQueryTypeFactory.ItemS));
					helper.Emit(OpCodes.Ldloc, locBldr);
					helper.Call(XmlILMethods.ChangeTypeXsltResult);
					helper.CallSetGlobalValue(typeof(object));
					helper.EmitUnconditionalBranch(OpCodes.Br, label);
				}
				helper.MarkLabel(label2);
				if (globalIterator.Binding != null)
				{
					helper.LoadQueryRuntime();
					helper.LoadInteger(num);
					NestedVisitEnsureStack(globalIterator.Binding, GetItemStorageType(globalIterator), isCached);
					helper.CallSetGlobalValue(GetStorageType(globalIterator));
				}
				else
				{
					helper.LoadQueryRuntime();
					helper.Emit(OpCodes.Ldstr, System.Xml.Utils.Res.GetString("XmlIl_UnknownParam", qilParameter.Name.LocalName, qilParameter.Name.NamespaceUri));
					helper.Call(XmlILMethods.ThrowException);
				}
				EndNestedIterator(globalIterator);
				helper.MarkLabel(label);
				helper.CallGetGlobalValue(num, GetStorageType(globalIterator));
				helper.MethodEnd();
			}
		}

		private void Function(QilFunction ndFunc)
		{
			foreach (QilIterator argument in ndFunc.Arguments)
			{
				IteratorDescriptor iteratorDescriptor = new IteratorDescriptor(helper);
				int paramIndex = XmlILAnnotation.Write(argument).ArgumentPosition + 1;
				iteratorDescriptor.Storage = StorageDescriptor.Parameter(paramIndex, GetItemStorageType(argument), !argument.XmlType.IsSingleton);
				XmlILAnnotation.Write(argument).CachedIteratorDescriptor = iteratorDescriptor;
			}
			MethodInfo functionBinding = XmlILAnnotation.Write(ndFunc).FunctionBinding;
			bool flag = XmlILConstructInfo.Read(ndFunc).ConstructMethod == XmlILConstructMethod.Writer;
			helper.MethodBegin(functionBinding, ndFunc.SourceLine, flag);
			foreach (QilIterator argument2 in ndFunc.Arguments)
			{
				if (qil.IsDebug && argument2.SourceLine != null)
				{
					helper.DebugSequencePoint(argument2.SourceLine);
				}
				if (argument2.Binding != null)
				{
					int paramIndex = (argument2.Annotation as XmlILAnnotation).ArgumentPosition + 1;
					Label label = helper.DefineLabel();
					helper.LoadQueryRuntime();
					helper.LoadParameter(paramIndex);
					helper.LoadInteger(29);
					helper.Call(XmlILMethods.SeqMatchesCode);
					helper.Emit(OpCodes.Brfalse, label);
					StartNestedIterator(argument2);
					NestedVisitEnsureStack(argument2.Binding, GetItemStorageType(argument2), !argument2.XmlType.IsSingleton);
					EndNestedIterator(argument2);
					helper.SetParameter(paramIndex);
					helper.MarkLabel(label);
				}
			}
			StartNestedIterator(ndFunc);
			if (flag)
			{
				NestedVisit(ndFunc.Definition);
			}
			else
			{
				NestedVisitEnsureStack(ndFunc.Definition, GetItemStorageType(ndFunc), !ndFunc.XmlType.IsSingleton);
			}
			EndNestedIterator(ndFunc);
			helper.MethodEnd();
		}

		protected override QilNode Visit(QilNode nd)
		{
			if (nd == null)
			{
				return null;
			}
			if (qil.IsDebug && nd.SourceLine != null && !(nd is QilIterator))
			{
				helper.DebugSequencePoint(nd.SourceLine);
			}
			switch (XmlILConstructInfo.Read(nd).ConstructMethod)
			{
			case XmlILConstructMethod.WriterThenIterator:
				NestedConstruction(nd);
				break;
			case XmlILConstructMethod.IteratorThenWriter:
				CopySequence(nd);
				break;
			default:
				base.Visit(nd);
				break;
			}
			return nd;
		}

		protected override QilNode VisitChildren(QilNode parent)
		{
			return parent;
		}

		private void NestedConstruction(QilNode nd)
		{
			helper.CallStartSequenceConstruction();
			base.Visit(nd);
			helper.CallEndSequenceConstruction();
			iterCurr.Storage = StorageDescriptor.Stack(typeof(XPathItem), isCached: true);
		}

		private void CopySequence(QilNode nd)
		{
			XmlQueryType xmlType = nd.XmlType;
			StartWriterLoop(nd, out var hasOnEnd, out var lblOnEnd);
			if (xmlType.IsSingleton)
			{
				helper.LoadQueryOutput();
				base.Visit(nd);
				iterCurr.EnsureItemStorageType(nd.XmlType, typeof(XPathItem));
			}
			else
			{
				base.Visit(nd);
				iterCurr.EnsureItemStorageType(nd.XmlType, typeof(XPathItem));
				iterCurr.EnsureNoStackNoCache("$$$copyTemp");
				helper.LoadQueryOutput();
			}
			iterCurr.EnsureStackNoCache();
			helper.Call(XmlILMethods.WriteItem);
			EndWriterLoop(nd, hasOnEnd, lblOnEnd);
		}

		protected override QilNode VisitDataSource(QilDataSource ndSrc)
		{
			helper.LoadQueryContext();
			NestedVisitEnsureStack(ndSrc.Name);
			NestedVisitEnsureStack(ndSrc.BaseUri);
			helper.Call(XmlILMethods.GetDataSource);
			LocalBuilder localBuilder = helper.DeclareLocal("$$$navDoc", typeof(XPathNavigator));
			helper.Emit(OpCodes.Stloc, localBuilder);
			helper.Emit(OpCodes.Ldloc, localBuilder);
			helper.Emit(OpCodes.Brfalse, iterCurr.GetLabelNext());
			iterCurr.Storage = StorageDescriptor.Local(localBuilder, typeof(XPathNavigator), isCached: false);
			return ndSrc;
		}

		protected override QilNode VisitNop(QilUnary ndNop)
		{
			return Visit(ndNop.Child);
		}

		protected override QilNode VisitOptimizeBarrier(QilUnary ndBarrier)
		{
			return Visit(ndBarrier.Child);
		}

		protected override QilNode VisitError(QilUnary ndErr)
		{
			helper.LoadQueryRuntime();
			NestedVisitEnsureStack(ndErr.Child);
			helper.Call(XmlILMethods.ThrowException);
			if (XmlILConstructInfo.Read(ndErr).ConstructMethod == XmlILConstructMethod.Writer)
			{
				iterCurr.Storage = StorageDescriptor.None();
			}
			else
			{
				helper.Emit(OpCodes.Ldnull);
				iterCurr.Storage = StorageDescriptor.Stack(typeof(XPathItem), isCached: false);
			}
			return ndErr;
		}

		protected override QilNode VisitWarning(QilUnary ndWarning)
		{
			helper.LoadQueryRuntime();
			NestedVisitEnsureStack(ndWarning.Child);
			helper.Call(XmlILMethods.SendMessage);
			if (XmlILConstructInfo.Read(ndWarning).ConstructMethod == XmlILConstructMethod.Writer)
			{
				iterCurr.Storage = StorageDescriptor.None();
			}
			else
			{
				VisitEmpty(ndWarning);
			}
			return ndWarning;
		}

		protected override QilNode VisitTrue(QilNode ndTrue)
		{
			if (iterCurr.CurrentBranchingContext != 0)
			{
				helper.EmitUnconditionalBranch((iterCurr.CurrentBranchingContext == BranchingContext.OnTrue) ? OpCodes.Brtrue : OpCodes.Brfalse, iterCurr.LabelBranch);
				iterCurr.Storage = StorageDescriptor.None();
			}
			else
			{
				helper.LoadBoolean(boolVal: true);
				iterCurr.Storage = StorageDescriptor.Stack(typeof(bool), isCached: false);
			}
			return ndTrue;
		}

		protected override QilNode VisitFalse(QilNode ndFalse)
		{
			if (iterCurr.CurrentBranchingContext != 0)
			{
				helper.EmitUnconditionalBranch((iterCurr.CurrentBranchingContext == BranchingContext.OnFalse) ? OpCodes.Brtrue : OpCodes.Brfalse, iterCurr.LabelBranch);
				iterCurr.Storage = StorageDescriptor.None();
			}
			else
			{
				helper.LoadBoolean(boolVal: false);
				iterCurr.Storage = StorageDescriptor.Stack(typeof(bool), isCached: false);
			}
			return ndFalse;
		}

		protected override QilNode VisitLiteralString(QilLiteral ndStr)
		{
			helper.Emit(OpCodes.Ldstr, (string)ndStr);
			iterCurr.Storage = StorageDescriptor.Stack(typeof(string), isCached: false);
			return ndStr;
		}

		protected override QilNode VisitLiteralInt32(QilLiteral ndInt)
		{
			helper.LoadInteger(ndInt);
			iterCurr.Storage = StorageDescriptor.Stack(typeof(int), isCached: false);
			return ndInt;
		}

		protected override QilNode VisitLiteralInt64(QilLiteral ndLong)
		{
			helper.Emit(OpCodes.Ldc_I8, (long)ndLong);
			iterCurr.Storage = StorageDescriptor.Stack(typeof(long), isCached: false);
			return ndLong;
		}

		protected override QilNode VisitLiteralDouble(QilLiteral ndDbl)
		{
			helper.Emit(OpCodes.Ldc_R8, (double)ndDbl);
			iterCurr.Storage = StorageDescriptor.Stack(typeof(double), isCached: false);
			return ndDbl;
		}

		protected override QilNode VisitLiteralDecimal(QilLiteral ndDec)
		{
			helper.ConstructLiteralDecimal(ndDec);
			iterCurr.Storage = StorageDescriptor.Stack(typeof(decimal), isCached: false);
			return ndDec;
		}

		protected override QilNode VisitLiteralQName(QilName ndQName)
		{
			helper.ConstructLiteralQName(ndQName.LocalName, ndQName.NamespaceUri);
			iterCurr.Storage = StorageDescriptor.Stack(typeof(XmlQualifiedName), isCached: false);
			return ndQName;
		}

		protected override QilNode VisitAnd(QilBinary ndAnd)
		{
			IteratorDescriptor iteratorDescriptor = iterCurr;
			StartNestedIterator(ndAnd.Left);
			Label lblOnFalse = StartConjunctiveTests(iteratorDescriptor.CurrentBranchingContext, iteratorDescriptor.LabelBranch);
			Visit(ndAnd.Left);
			EndNestedIterator(ndAnd.Left);
			StartNestedIterator(ndAnd.Right);
			StartLastConjunctiveTest(iteratorDescriptor.CurrentBranchingContext, iteratorDescriptor.LabelBranch, lblOnFalse);
			Visit(ndAnd.Right);
			EndNestedIterator(ndAnd.Right);
			EndConjunctiveTests(iteratorDescriptor.CurrentBranchingContext, iteratorDescriptor.LabelBranch, lblOnFalse);
			return ndAnd;
		}

		private Label StartConjunctiveTests(BranchingContext brctxt, Label lblBranch)
		{
			if (brctxt == BranchingContext.OnFalse)
			{
				iterCurr.SetBranching(BranchingContext.OnFalse, lblBranch);
				return lblBranch;
			}
			Label label = helper.DefineLabel();
			iterCurr.SetBranching(BranchingContext.OnFalse, label);
			return label;
		}

		private void StartLastConjunctiveTest(BranchingContext brctxt, Label lblBranch, Label lblOnFalse)
		{
			if (brctxt == BranchingContext.OnTrue)
			{
				iterCurr.SetBranching(BranchingContext.OnTrue, lblBranch);
			}
			else
			{
				iterCurr.SetBranching(BranchingContext.OnFalse, lblOnFalse);
			}
		}

		private void EndConjunctiveTests(BranchingContext brctxt, Label lblBranch, Label lblOnFalse)
		{
			switch (brctxt)
			{
			case BranchingContext.OnTrue:
				helper.MarkLabel(lblOnFalse);
				goto case BranchingContext.OnFalse;
			case BranchingContext.OnFalse:
				iterCurr.Storage = StorageDescriptor.None();
				break;
			case BranchingContext.None:
				helper.ConvBranchToBool(lblOnFalse, isTrueBranch: false);
				iterCurr.Storage = StorageDescriptor.Stack(typeof(bool), isCached: false);
				break;
			}
		}

		protected override QilNode VisitOr(QilBinary ndOr)
		{
			Label label = default(Label);
			switch (iterCurr.CurrentBranchingContext)
			{
			case BranchingContext.OnFalse:
				label = helper.DefineLabel();
				NestedVisitWithBranch(ndOr.Left, BranchingContext.OnTrue, label);
				break;
			case BranchingContext.OnTrue:
				NestedVisitWithBranch(ndOr.Left, BranchingContext.OnTrue, iterCurr.LabelBranch);
				break;
			default:
				label = helper.DefineLabel();
				NestedVisitWithBranch(ndOr.Left, BranchingContext.OnTrue, label);
				break;
			}
			switch (iterCurr.CurrentBranchingContext)
			{
			case BranchingContext.OnFalse:
				NestedVisitWithBranch(ndOr.Right, BranchingContext.OnFalse, iterCurr.LabelBranch);
				break;
			case BranchingContext.OnTrue:
				NestedVisitWithBranch(ndOr.Right, BranchingContext.OnTrue, iterCurr.LabelBranch);
				break;
			default:
				NestedVisitWithBranch(ndOr.Right, BranchingContext.OnTrue, label);
				break;
			}
			switch (iterCurr.CurrentBranchingContext)
			{
			case BranchingContext.OnFalse:
				helper.MarkLabel(label);
				goto case BranchingContext.OnTrue;
			case BranchingContext.OnTrue:
				iterCurr.Storage = StorageDescriptor.None();
				break;
			case BranchingContext.None:
				helper.ConvBranchToBool(label, isTrueBranch: true);
				iterCurr.Storage = StorageDescriptor.Stack(typeof(bool), isCached: false);
				break;
			}
			return ndOr;
		}

		protected override QilNode VisitNot(QilUnary ndNot)
		{
			Label lblBranch = default(Label);
			switch (iterCurr.CurrentBranchingContext)
			{
			case BranchingContext.OnFalse:
				NestedVisitWithBranch(ndNot.Child, BranchingContext.OnTrue, iterCurr.LabelBranch);
				break;
			case BranchingContext.OnTrue:
				NestedVisitWithBranch(ndNot.Child, BranchingContext.OnFalse, iterCurr.LabelBranch);
				break;
			default:
				lblBranch = helper.DefineLabel();
				NestedVisitWithBranch(ndNot.Child, BranchingContext.OnTrue, lblBranch);
				break;
			}
			if (iterCurr.CurrentBranchingContext == BranchingContext.None)
			{
				helper.ConvBranchToBool(lblBranch, isTrueBranch: false);
				iterCurr.Storage = StorageDescriptor.Stack(typeof(bool), isCached: false);
			}
			else
			{
				iterCurr.Storage = StorageDescriptor.None();
			}
			return ndNot;
		}

		protected override QilNode VisitConditional(QilTernary ndCond)
		{
			XmlILConstructInfo xmlILConstructInfo = XmlILConstructInfo.Read(ndCond);
			if (xmlILConstructInfo.ConstructMethod == XmlILConstructMethod.Writer)
			{
				Label label = helper.DefineLabel();
				NestedVisitWithBranch(ndCond.Left, BranchingContext.OnFalse, label);
				NestedVisit(ndCond.Center);
				if (ndCond.Right.NodeType == QilNodeType.Sequence && ndCond.Right.Count == 0)
				{
					helper.MarkLabel(label);
					NestedVisit(ndCond.Right);
				}
				else
				{
					Label label2 = helper.DefineLabel();
					helper.EmitUnconditionalBranch(OpCodes.Br, label2);
					helper.MarkLabel(label);
					NestedVisit(ndCond.Right);
					helper.MarkLabel(label2);
				}
				iterCurr.Storage = StorageDescriptor.None();
			}
			else
			{
				LocalBuilder localBuilder = null;
				LocalBuilder localBuilder2 = null;
				Type itemStorageType = GetItemStorageType(ndCond);
				Label label3 = helper.DefineLabel();
				if (ndCond.XmlType.IsSingleton)
				{
					NestedVisitWithBranch(ndCond.Left, BranchingContext.OnFalse, label3);
				}
				else
				{
					localBuilder2 = helper.DeclareLocal("$$$cond", itemStorageType);
					localBuilder = helper.DeclareLocal("$$$boolResult", typeof(bool));
					NestedVisitEnsureLocal(ndCond.Left, localBuilder);
					helper.Emit(OpCodes.Ldloc, localBuilder);
					helper.Emit(OpCodes.Brfalse, label3);
				}
				ConditionalBranch(ndCond.Center, itemStorageType, localBuilder2);
				IteratorDescriptor iteratorDescriptor = iterNested;
				Label label4 = helper.DefineLabel();
				helper.EmitUnconditionalBranch(OpCodes.Br, label4);
				helper.MarkLabel(label3);
				ConditionalBranch(ndCond.Right, itemStorageType, localBuilder2);
				if (!ndCond.XmlType.IsSingleton)
				{
					helper.EmitUnconditionalBranch(OpCodes.Brtrue, label4);
					Label label5 = helper.DefineLabel();
					helper.MarkLabel(label5);
					helper.Emit(OpCodes.Ldloc, localBuilder);
					helper.Emit(OpCodes.Brtrue, iteratorDescriptor.GetLabelNext());
					helper.EmitUnconditionalBranch(OpCodes.Br, iterNested.GetLabelNext());
					iterCurr.SetIterator(label5, StorageDescriptor.Local(localBuilder2, itemStorageType, isCached: false));
				}
				helper.MarkLabel(label4);
			}
			return ndCond;
		}

		private void ConditionalBranch(QilNode ndBranch, Type itemStorageType, LocalBuilder locResult)
		{
			if (locResult == null)
			{
				if (iterCurr.IsBranching)
				{
					NestedVisitWithBranch(ndBranch, iterCurr.CurrentBranchingContext, iterCurr.LabelBranch);
				}
				else
				{
					NestedVisitEnsureStack(ndBranch, itemStorageType, isCached: false);
				}
			}
			else
			{
				NestedVisit(ndBranch, iterCurr.GetLabelNext());
				iterCurr.EnsureItemStorageType(ndBranch.XmlType, itemStorageType);
				iterCurr.EnsureLocalNoCache(locResult);
			}
		}

		protected override QilNode VisitChoice(QilChoice ndChoice)
		{
			NestedVisit(ndChoice.Expression);
			QilNode branches = ndChoice.Branches;
			int num = branches.Count - 1;
			Label[] array = new Label[num];
			int i;
			for (i = 0; i < num; i++)
			{
				ref Label reference = ref array[i];
				reference = helper.DefineLabel();
			}
			Label label = helper.DefineLabel();
			Label label2 = helper.DefineLabel();
			helper.Emit(OpCodes.Switch, array);
			helper.EmitUnconditionalBranch(OpCodes.Br, label);
			for (i = 0; i < num; i++)
			{
				helper.MarkLabel(array[i]);
				NestedVisit(branches[i]);
				helper.EmitUnconditionalBranch(OpCodes.Br, label2);
			}
			helper.MarkLabel(label);
			NestedVisit(branches[i]);
			helper.MarkLabel(label2);
			iterCurr.Storage = StorageDescriptor.None();
			return ndChoice;
		}

		protected override QilNode VisitLength(QilUnary ndSetLen)
		{
			Label label = helper.DefineLabel();
			OptimizerPatterns optimizerPatterns = OptimizerPatterns.Read(ndSetLen);
			if (CachesResult(ndSetLen.Child))
			{
				NestedVisitEnsureStack(ndSetLen.Child);
				helper.CallCacheCount(iterNested.Storage.ItemStorageType);
			}
			else
			{
				helper.Emit(OpCodes.Ldc_I4_0);
				StartNestedIterator(ndSetLen.Child, label);
				Visit(ndSetLen.Child);
				iterCurr.EnsureNoCache();
				iterCurr.DiscardStack();
				helper.Emit(OpCodes.Ldc_I4_1);
				helper.Emit(OpCodes.Add);
				if (optimizerPatterns.MatchesPattern(OptimizerPatternName.MaxPosition))
				{
					helper.Emit(OpCodes.Dup);
					helper.LoadInteger((int)optimizerPatterns.GetArgument(OptimizerPatternArgument.ElementQName));
					helper.Emit(OpCodes.Bgt, label);
				}
				iterCurr.LoopToEnd(label);
				EndNestedIterator(ndSetLen.Child);
			}
			iterCurr.Storage = StorageDescriptor.Stack(typeof(int), isCached: false);
			return ndSetLen;
		}

		protected override QilNode VisitSequence(QilList ndSeq)
		{
			if (XmlILConstructInfo.Read(ndSeq).ConstructMethod == XmlILConstructMethod.Writer)
			{
				foreach (QilNode item in ndSeq)
				{
					NestedVisit(item);
				}
				return ndSeq;
			}
			if (ndSeq.Count == 0)
			{
				VisitEmpty(ndSeq);
			}
			else
			{
				Sequence(ndSeq);
			}
			return ndSeq;
		}

		private void VisitEmpty(QilNode nd)
		{
			helper.EmitUnconditionalBranch(OpCodes.Brtrue, iterCurr.GetLabelNext());
			helper.Emit(OpCodes.Ldnull);
			iterCurr.Storage = StorageDescriptor.Stack(typeof(XPathItem), isCached: false);
		}

		private void Sequence(QilList ndSeq)
		{
			Label label = default(Label);
			Type itemStorageType = GetItemStorageType(ndSeq);
			if (ndSeq.XmlType.IsSingleton)
			{
				foreach (QilNode item in ndSeq)
				{
					if (item.XmlType.IsSingleton)
					{
						NestedVisitEnsureStack(item);
						continue;
					}
					label = helper.DefineLabel();
					NestedVisit(item, label);
					iterCurr.DiscardStack();
					helper.MarkLabel(label);
				}
				iterCurr.Storage = StorageDescriptor.Stack(itemStorageType, isCached: false);
				return;
			}
			LocalBuilder localBuilder = helper.DeclareLocal("$$$itemList", itemStorageType);
			LocalBuilder locBldr = helper.DeclareLocal("$$$idxList", typeof(int));
			Label[] array = new Label[ndSeq.Count];
			Label label2 = helper.DefineLabel();
			for (int i = 0; i < ndSeq.Count; i++)
			{
				if (i != 0)
				{
					helper.MarkLabel(label);
				}
				label = ((i != ndSeq.Count - 1) ? helper.DefineLabel() : iterCurr.GetLabelNext());
				helper.LoadInteger(i);
				helper.Emit(OpCodes.Stloc, locBldr);
				NestedVisit(ndSeq[i], label);
				iterCurr.EnsureItemStorageType(ndSeq[i].XmlType, itemStorageType);
				iterCurr.EnsureLocalNoCache(localBuilder);
				ref Label reference = ref array[i];
				reference = iterNested.GetLabelNext();
				helper.EmitUnconditionalBranch(OpCodes.Brtrue, label2);
			}
			Label label3 = helper.DefineLabel();
			helper.MarkLabel(label3);
			helper.Emit(OpCodes.Ldloc, locBldr);
			helper.Emit(OpCodes.Switch, array);
			helper.MarkLabel(label2);
			iterCurr.SetIterator(label3, StorageDescriptor.Local(localBuilder, itemStorageType, isCached: false));
		}

		protected override QilNode VisitUnion(QilBinary ndUnion)
		{
			return CreateSetIterator(ndUnion, "$$$iterUnion", typeof(UnionIterator), XmlILMethods.UnionCreate, XmlILMethods.UnionNext);
		}

		protected override QilNode VisitIntersection(QilBinary ndInter)
		{
			return CreateSetIterator(ndInter, "$$$iterInter", typeof(IntersectIterator), XmlILMethods.InterCreate, XmlILMethods.InterNext);
		}

		protected override QilNode VisitDifference(QilBinary ndDiff)
		{
			return CreateSetIterator(ndDiff, "$$$iterDiff", typeof(DifferenceIterator), XmlILMethods.DiffCreate, XmlILMethods.DiffNext);
		}

		private QilNode CreateSetIterator(QilBinary ndSet, string iterName, Type iterType, MethodInfo methCreate, MethodInfo methNext)
		{
			LocalBuilder localBuilder = helper.DeclareLocal(iterName, iterType);
			LocalBuilder localBuilder2 = helper.DeclareLocal("$$$navSet", typeof(XPathNavigator));
			helper.Emit(OpCodes.Ldloca, localBuilder);
			helper.LoadQueryRuntime();
			helper.Call(methCreate);
			Label label = helper.DefineLabel();
			Label label2 = helper.DefineLabel();
			Label label3 = helper.DefineLabel();
			NestedVisit(ndSet.Left, label);
			Label labelNext = iterNested.GetLabelNext();
			iterCurr.EnsureLocal(localBuilder2);
			helper.EmitUnconditionalBranch(OpCodes.Brtrue, label2);
			helper.MarkLabel(label3);
			NestedVisit(ndSet.Right, label);
			Label labelNext2 = iterNested.GetLabelNext();
			iterCurr.EnsureLocal(localBuilder2);
			helper.EmitUnconditionalBranch(OpCodes.Brtrue, label2);
			helper.MarkLabel(label);
			helper.Emit(OpCodes.Ldnull);
			helper.Emit(OpCodes.Stloc, localBuilder2);
			helper.MarkLabel(label2);
			helper.Emit(OpCodes.Ldloca, localBuilder);
			helper.Emit(OpCodes.Ldloc, localBuilder2);
			helper.Call(methNext);
			if (ndSet.XmlType.IsSingleton)
			{
				helper.Emit(OpCodes.Switch, new Label[3] { label3, labelNext, labelNext2 });
				iterCurr.Storage = StorageDescriptor.Current(localBuilder, typeof(XPathNavigator));
			}
			else
			{
				helper.Emit(OpCodes.Switch, new Label[4]
				{
					iterCurr.GetLabelNext(),
					label3,
					labelNext,
					labelNext2
				});
				iterCurr.SetIterator(label, StorageDescriptor.Current(localBuilder, typeof(XPathNavigator)));
			}
			return ndSet;
		}

		protected override QilNode VisitAverage(QilUnary ndAvg)
		{
			XmlILStorageMethods xmlILStorageMethods = XmlILMethods.StorageMethods[GetItemStorageType(ndAvg)];
			return CreateAggregator(ndAvg, "$$$aggAvg", xmlILStorageMethods, xmlILStorageMethods.AggAvg, xmlILStorageMethods.AggAvgResult);
		}

		protected override QilNode VisitSum(QilUnary ndSum)
		{
			XmlILStorageMethods xmlILStorageMethods = XmlILMethods.StorageMethods[GetItemStorageType(ndSum)];
			return CreateAggregator(ndSum, "$$$aggSum", xmlILStorageMethods, xmlILStorageMethods.AggSum, xmlILStorageMethods.AggSumResult);
		}

		protected override QilNode VisitMinimum(QilUnary ndMin)
		{
			XmlILStorageMethods xmlILStorageMethods = XmlILMethods.StorageMethods[GetItemStorageType(ndMin)];
			return CreateAggregator(ndMin, "$$$aggMin", xmlILStorageMethods, xmlILStorageMethods.AggMin, xmlILStorageMethods.AggMinResult);
		}

		protected override QilNode VisitMaximum(QilUnary ndMax)
		{
			XmlILStorageMethods xmlILStorageMethods = XmlILMethods.StorageMethods[GetItemStorageType(ndMax)];
			return CreateAggregator(ndMax, "$$$aggMax", xmlILStorageMethods, xmlILStorageMethods.AggMax, xmlILStorageMethods.AggMaxResult);
		}

		private QilNode CreateAggregator(QilUnary ndAgg, string aggName, XmlILStorageMethods methods, MethodInfo methAgg, MethodInfo methResult)
		{
			Label lblOnEnd = helper.DefineLabel();
			Type declaringType = methAgg.DeclaringType;
			LocalBuilder locBldr = helper.DeclareLocal(aggName, declaringType);
			helper.Emit(OpCodes.Ldloca, locBldr);
			helper.Call(methods.AggCreate);
			StartNestedIterator(ndAgg.Child, lblOnEnd);
			helper.Emit(OpCodes.Ldloca, locBldr);
			Visit(ndAgg.Child);
			iterCurr.EnsureStackNoCache();
			iterCurr.EnsureItemStorageType(ndAgg.XmlType, GetItemStorageType(ndAgg));
			helper.Call(methAgg);
			helper.Emit(OpCodes.Ldloca, locBldr);
			iterCurr.LoopToEnd(lblOnEnd);
			EndNestedIterator(ndAgg.Child);
			if (ndAgg.XmlType.MaybeEmpty)
			{
				helper.Call(methods.AggIsEmpty);
				helper.Emit(OpCodes.Brtrue, iterCurr.GetLabelNext());
				helper.Emit(OpCodes.Ldloca, locBldr);
			}
			helper.Call(methResult);
			iterCurr.Storage = StorageDescriptor.Stack(GetItemStorageType(ndAgg), isCached: false);
			return ndAgg;
		}

		protected override QilNode VisitNegate(QilUnary ndNeg)
		{
			NestedVisitEnsureStack(ndNeg.Child);
			helper.CallArithmeticOp(QilNodeType.Negate, ndNeg.XmlType.TypeCode);
			iterCurr.Storage = StorageDescriptor.Stack(GetItemStorageType(ndNeg), isCached: false);
			return ndNeg;
		}

		protected override QilNode VisitAdd(QilBinary ndPlus)
		{
			return ArithmeticOp(ndPlus);
		}

		protected override QilNode VisitSubtract(QilBinary ndMinus)
		{
			return ArithmeticOp(ndMinus);
		}

		protected override QilNode VisitMultiply(QilBinary ndMul)
		{
			return ArithmeticOp(ndMul);
		}

		protected override QilNode VisitDivide(QilBinary ndDiv)
		{
			return ArithmeticOp(ndDiv);
		}

		protected override QilNode VisitModulo(QilBinary ndMod)
		{
			return ArithmeticOp(ndMod);
		}

		private QilNode ArithmeticOp(QilBinary ndOp)
		{
			NestedVisitEnsureStack(ndOp.Left, ndOp.Right);
			helper.CallArithmeticOp(ndOp.NodeType, ndOp.XmlType.TypeCode);
			iterCurr.Storage = StorageDescriptor.Stack(GetItemStorageType(ndOp), isCached: false);
			return ndOp;
		}

		protected override QilNode VisitStrLength(QilUnary ndLen)
		{
			NestedVisitEnsureStack(ndLen.Child);
			helper.Call(XmlILMethods.StrLen);
			iterCurr.Storage = StorageDescriptor.Stack(typeof(int), isCached: false);
			return ndLen;
		}

		protected override QilNode VisitStrConcat(QilStrConcat ndStrConcat)
		{
			QilNode qilNode = ndStrConcat.Delimiter;
			if (qilNode.NodeType == QilNodeType.LiteralString && ((string)(QilLiteral)qilNode).Length == 0)
			{
				qilNode = null;
			}
			QilNode values = ndStrConcat.Values;
			bool flag;
			if (values.NodeType == QilNodeType.Sequence && values.Count < 5)
			{
				flag = true;
				foreach (QilNode item in values)
				{
					if (!item.XmlType.IsSingleton)
					{
						flag = false;
					}
				}
			}
			else
			{
				flag = false;
			}
			if (flag)
			{
				foreach (QilNode item2 in values)
				{
					NestedVisitEnsureStack(item2);
				}
				helper.CallConcatStrings(values.Count);
			}
			else
			{
				LocalBuilder localBuilder = helper.DeclareLocal("$$$strcat", typeof(StringConcat));
				helper.Emit(OpCodes.Ldloca, localBuilder);
				helper.Call(XmlILMethods.StrCatClear);
				if (qilNode != null)
				{
					helper.Emit(OpCodes.Ldloca, localBuilder);
					NestedVisitEnsureStack(qilNode);
					helper.Call(XmlILMethods.StrCatDelim);
				}
				helper.Emit(OpCodes.Ldloca, localBuilder);
				if (values.NodeType == QilNodeType.Sequence)
				{
					foreach (QilNode item3 in values)
					{
						GenerateConcat(item3, localBuilder);
					}
				}
				else
				{
					GenerateConcat(values, localBuilder);
				}
				helper.Call(XmlILMethods.StrCatResult);
			}
			iterCurr.Storage = StorageDescriptor.Stack(typeof(string), isCached: false);
			return ndStrConcat;
		}

		private void GenerateConcat(QilNode ndStr, LocalBuilder locStringConcat)
		{
			Label lblOnEnd = helper.DefineLabel();
			StartNestedIterator(ndStr, lblOnEnd);
			Visit(ndStr);
			iterCurr.EnsureStackNoCache();
			iterCurr.EnsureItemStorageType(ndStr.XmlType, typeof(string));
			helper.Call(XmlILMethods.StrCatCat);
			helper.Emit(OpCodes.Ldloca, locStringConcat);
			iterCurr.LoopToEnd(lblOnEnd);
			EndNestedIterator(ndStr);
		}

		protected override QilNode VisitStrParseQName(QilBinary ndParsedTagName)
		{
			VisitStrParseQName(ndParsedTagName, preservePrefix: false);
			return ndParsedTagName;
		}

		private void VisitStrParseQName(QilBinary ndParsedTagName, bool preservePrefix)
		{
			if (!preservePrefix)
			{
				helper.LoadQueryRuntime();
			}
			NestedVisitEnsureStack(ndParsedTagName.Left);
			if (ndParsedTagName.Right.XmlType.TypeCode == XmlTypeCode.String)
			{
				NestedVisitEnsureStack(ndParsedTagName.Right);
				if (!preservePrefix)
				{
					helper.CallParseTagName(GenerateNameType.TagNameAndNamespace);
				}
			}
			else
			{
				if (ndParsedTagName.Right.NodeType == QilNodeType.Sequence)
				{
					helper.LoadInteger(helper.StaticData.DeclarePrefixMappings(ndParsedTagName.Right));
				}
				else
				{
					helper.LoadInteger(helper.StaticData.DeclarePrefixMappings(new QilNode[1] { ndParsedTagName.Right }));
				}
				if (!preservePrefix)
				{
					helper.CallParseTagName(GenerateNameType.TagNameAndMappings);
				}
			}
			iterCurr.Storage = StorageDescriptor.Stack(typeof(XmlQualifiedName), isCached: false);
		}

		protected override QilNode VisitNe(QilBinary ndNe)
		{
			Compare(ndNe);
			return ndNe;
		}

		protected override QilNode VisitEq(QilBinary ndEq)
		{
			Compare(ndEq);
			return ndEq;
		}

		protected override QilNode VisitGt(QilBinary ndGt)
		{
			Compare(ndGt);
			return ndGt;
		}

		protected override QilNode VisitGe(QilBinary ndGe)
		{
			Compare(ndGe);
			return ndGe;
		}

		protected override QilNode VisitLt(QilBinary ndLt)
		{
			Compare(ndLt);
			return ndLt;
		}

		protected override QilNode VisitLe(QilBinary ndLe)
		{
			Compare(ndLe);
			return ndLe;
		}

		private void Compare(QilBinary ndComp)
		{
			QilNodeType nodeType = ndComp.NodeType;
			if ((nodeType == QilNodeType.Eq || nodeType == QilNodeType.Ne) && (TryZeroCompare(nodeType, ndComp.Left, ndComp.Right) || TryZeroCompare(nodeType, ndComp.Right, ndComp.Left) || TryNameCompare(nodeType, ndComp.Left, ndComp.Right) || TryNameCompare(nodeType, ndComp.Right, ndComp.Left)))
			{
				return;
			}
			NestedVisitEnsureStack(ndComp.Left, ndComp.Right);
			XmlTypeCode typeCode = ndComp.Left.XmlType.TypeCode;
			switch (typeCode)
			{
			case XmlTypeCode.String:
			case XmlTypeCode.Decimal:
			case XmlTypeCode.QName:
				if (nodeType == QilNodeType.Eq || nodeType == QilNodeType.Ne)
				{
					helper.CallCompareEquals(typeCode);
					ZeroCompare((nodeType == QilNodeType.Eq) ? QilNodeType.Ne : QilNodeType.Eq, isBoolVal: true);
				}
				else
				{
					helper.CallCompare(typeCode);
					helper.Emit(OpCodes.Ldc_I4_0);
					ClrCompare(nodeType, typeCode);
				}
				break;
			case XmlTypeCode.Boolean:
			case XmlTypeCode.Double:
			case XmlTypeCode.Integer:
			case XmlTypeCode.Int:
				ClrCompare(nodeType, typeCode);
				break;
			}
		}

		protected override QilNode VisitIs(QilBinary ndIs)
		{
			NestedVisitEnsureStack(ndIs.Left, ndIs.Right);
			helper.Call(XmlILMethods.NavSamePos);
			ZeroCompare(QilNodeType.Ne, isBoolVal: true);
			return ndIs;
		}

		protected override QilNode VisitBefore(QilBinary ndBefore)
		{
			ComparePosition(ndBefore);
			return ndBefore;
		}

		protected override QilNode VisitAfter(QilBinary ndAfter)
		{
			ComparePosition(ndAfter);
			return ndAfter;
		}

		private void ComparePosition(QilBinary ndComp)
		{
			helper.LoadQueryRuntime();
			NestedVisitEnsureStack(ndComp.Left, ndComp.Right);
			helper.Call(XmlILMethods.CompPos);
			helper.LoadInteger(0);
			ClrCompare((ndComp.NodeType == QilNodeType.Before) ? QilNodeType.Lt : QilNodeType.Gt, XmlTypeCode.String);
		}

		protected override QilNode VisitFor(QilIterator ndFor)
		{
			IteratorDescriptor cachedIteratorDescriptor = XmlILAnnotation.Write(ndFor).CachedIteratorDescriptor;
			iterCurr.Storage = cachedIteratorDescriptor.Storage;
			if (iterCurr.Storage.Location == ItemLocation.Global)
			{
				iterCurr.EnsureStack();
			}
			return ndFor;
		}

		protected override QilNode VisitLet(QilIterator ndLet)
		{
			return VisitFor(ndLet);
		}

		protected override QilNode VisitParameter(QilParameter ndParameter)
		{
			return VisitFor(ndParameter);
		}

		protected override QilNode VisitLoop(QilLoop ndLoop)
		{
			StartWriterLoop(ndLoop, out var hasOnEnd, out var lblOnEnd);
			StartBinding(ndLoop.Variable);
			Visit(ndLoop.Body);
			EndBinding(ndLoop.Variable);
			EndWriterLoop(ndLoop, hasOnEnd, lblOnEnd);
			return ndLoop;
		}

		protected override QilNode VisitFilter(QilLoop ndFilter)
		{
			if (HandleFilterPatterns(ndFilter))
			{
				return ndFilter;
			}
			StartBinding(ndFilter.Variable);
			iterCurr.SetIterator(iterNested);
			StartNestedIterator(ndFilter.Body);
			iterCurr.SetBranching(BranchingContext.OnFalse, iterCurr.ParentIterator.GetLabelNext());
			Visit(ndFilter.Body);
			EndNestedIterator(ndFilter.Body);
			EndBinding(ndFilter.Variable);
			return ndFilter;
		}

		private bool HandleFilterPatterns(QilLoop ndFilter)
		{
			OptimizerPatterns optimizerPatterns = OptimizerPatterns.Read(ndFilter);
			bool flag = optimizerPatterns.MatchesPattern(OptimizerPatternName.FilterElements);
			if (flag || optimizerPatterns.MatchesPattern(OptimizerPatternName.FilterContentKind))
			{
				XmlNodeKindFlags xmlNodeKindFlags;
				QilName qilName;
				if (flag)
				{
					xmlNodeKindFlags = XmlNodeKindFlags.Element;
					qilName = (QilName)optimizerPatterns.GetArgument(OptimizerPatternArgument.ElementQName);
				}
				else
				{
					xmlNodeKindFlags = ((XmlQueryType)optimizerPatterns.GetArgument(OptimizerPatternArgument.ElementQName)).NodeKinds;
					qilName = null;
				}
				QilNode qilNode = (QilNode)optimizerPatterns.GetArgument(OptimizerPatternArgument.StepNode);
				QilNode qilNode2 = (QilNode)optimizerPatterns.GetArgument(OptimizerPatternArgument.StepInput);
				switch (qilNode.NodeType)
				{
				case QilNodeType.Content:
					if (flag)
					{
						LocalBuilder localBuilder = helper.DeclareLocal("$$$iterElemContent", typeof(ElementContentIterator));
						helper.Emit(OpCodes.Ldloca, localBuilder);
						NestedVisitEnsureStack(qilNode2);
						helper.CallGetAtomizedName(helper.StaticData.DeclareName(qilName.LocalName));
						helper.CallGetAtomizedName(helper.StaticData.DeclareName(qilName.NamespaceUri));
						helper.Call(XmlILMethods.ElemContentCreate);
						GenerateSimpleIterator(typeof(XPathNavigator), localBuilder, XmlILMethods.ElemContentNext);
					}
					else if (xmlNodeKindFlags == XmlNodeKindFlags.Content)
					{
						CreateSimpleIterator(qilNode2, "$$$iterContent", typeof(ContentIterator), XmlILMethods.ContentCreate, XmlILMethods.ContentNext);
					}
					else
					{
						LocalBuilder localBuilder = helper.DeclareLocal("$$$iterContent", typeof(NodeKindContentIterator));
						helper.Emit(OpCodes.Ldloca, localBuilder);
						NestedVisitEnsureStack(qilNode2);
						helper.LoadInteger((int)QilXmlToXPathNodeType(xmlNodeKindFlags));
						helper.Call(XmlILMethods.KindContentCreate);
						GenerateSimpleIterator(typeof(XPathNavigator), localBuilder, XmlILMethods.KindContentNext);
					}
					return true;
				case QilNodeType.Parent:
					CreateFilteredIterator(qilNode2, "$$$iterPar", typeof(ParentIterator), XmlILMethods.ParentCreate, XmlILMethods.ParentNext, xmlNodeKindFlags, qilName, TriState.Unknown, null);
					return true;
				case QilNodeType.Ancestor:
				case QilNodeType.AncestorOrSelf:
					CreateFilteredIterator(qilNode2, "$$$iterAnc", typeof(AncestorIterator), XmlILMethods.AncCreate, XmlILMethods.AncNext, xmlNodeKindFlags, qilName, (qilNode.NodeType != QilNodeType.Ancestor) ? TriState.True : TriState.False, null);
					return true;
				case QilNodeType.Descendant:
				case QilNodeType.DescendantOrSelf:
					CreateFilteredIterator(qilNode2, "$$$iterDesc", typeof(DescendantIterator), XmlILMethods.DescCreate, XmlILMethods.DescNext, xmlNodeKindFlags, qilName, (qilNode.NodeType != QilNodeType.Descendant) ? TriState.True : TriState.False, null);
					return true;
				case QilNodeType.Preceding:
					CreateFilteredIterator(qilNode2, "$$$iterPrec", typeof(PrecedingIterator), XmlILMethods.PrecCreate, XmlILMethods.PrecNext, xmlNodeKindFlags, qilName, TriState.Unknown, null);
					return true;
				case QilNodeType.FollowingSibling:
					CreateFilteredIterator(qilNode2, "$$$iterFollSib", typeof(FollowingSiblingIterator), XmlILMethods.FollSibCreate, XmlILMethods.FollSibNext, xmlNodeKindFlags, qilName, TriState.Unknown, null);
					return true;
				case QilNodeType.PrecedingSibling:
					CreateFilteredIterator(qilNode2, "$$$iterPreSib", typeof(PrecedingSiblingIterator), XmlILMethods.PreSibCreate, XmlILMethods.PreSibNext, xmlNodeKindFlags, qilName, TriState.Unknown, null);
					return true;
				case QilNodeType.NodeRange:
					CreateFilteredIterator(qilNode2, "$$$iterRange", typeof(NodeRangeIterator), XmlILMethods.NodeRangeCreate, XmlILMethods.NodeRangeNext, xmlNodeKindFlags, qilName, TriState.Unknown, ((QilBinary)qilNode).Right);
					return true;
				case QilNodeType.XPathFollowing:
					CreateFilteredIterator(qilNode2, "$$$iterFoll", typeof(XPathFollowingIterator), XmlILMethods.XPFollCreate, XmlILMethods.XPFollNext, xmlNodeKindFlags, qilName, TriState.Unknown, null);
					return true;
				case QilNodeType.XPathPreceding:
					CreateFilteredIterator(qilNode2, "$$$iterPrec", typeof(XPathPrecedingIterator), XmlILMethods.XPPrecCreate, XmlILMethods.XPPrecNext, xmlNodeKindFlags, qilName, TriState.Unknown, null);
					return true;
				}
			}
			else
			{
				if (optimizerPatterns.MatchesPattern(OptimizerPatternName.FilterAttributeKind))
				{
					QilNode qilNode2 = (QilNode)optimizerPatterns.GetArgument(OptimizerPatternArgument.StepInput);
					CreateSimpleIterator(qilNode2, "$$$iterAttr", typeof(AttributeIterator), XmlILMethods.AttrCreate, XmlILMethods.AttrNext);
					return true;
				}
				if (optimizerPatterns.MatchesPattern(OptimizerPatternName.EqualityIndex))
				{
					Label lblOnEnd = helper.DefineLabel();
					Label label = helper.DefineLabel();
					QilIterator qilIterator = (QilIterator)optimizerPatterns.GetArgument(OptimizerPatternArgument.StepNode);
					QilNode n = (QilNode)optimizerPatterns.GetArgument(OptimizerPatternArgument.StepInput);
					LocalBuilder locBldr = helper.DeclareLocal("$$$index", typeof(XmlILIndex));
					helper.LoadQueryRuntime();
					helper.Emit(OpCodes.Ldarg_1);
					helper.LoadInteger(indexId);
					helper.Emit(OpCodes.Ldloca, locBldr);
					helper.Call(XmlILMethods.FindIndex);
					helper.Emit(OpCodes.Brtrue, label);
					helper.LoadQueryRuntime();
					helper.Emit(OpCodes.Ldarg_1);
					helper.LoadInteger(indexId);
					helper.Emit(OpCodes.Ldloc, locBldr);
					StartNestedIterator(qilIterator, lblOnEnd);
					StartBinding(qilIterator);
					Visit(n);
					iterCurr.EnsureStackNoCache();
					VisitFor(qilIterator);
					iterCurr.EnsureStackNoCache();
					iterCurr.EnsureItemStorageType(qilIterator.XmlType, typeof(XPathNavigator));
					helper.Call(XmlILMethods.IndexAdd);
					helper.Emit(OpCodes.Ldloc, locBldr);
					iterCurr.LoopToEnd(lblOnEnd);
					EndBinding(qilIterator);
					EndNestedIterator(qilIterator);
					helper.Call(XmlILMethods.AddNewIndex);
					helper.MarkLabel(label);
					helper.Emit(OpCodes.Ldloc, locBldr);
					helper.Emit(OpCodes.Ldarg_2);
					helper.Call(XmlILMethods.IndexLookup);
					iterCurr.Storage = StorageDescriptor.Stack(typeof(XPathNavigator), isCached: true);
					indexId++;
					return true;
				}
			}
			return false;
		}

		private void StartBinding(QilIterator ndIter)
		{
			OptimizerPatterns patt = OptimizerPatterns.Read(ndIter);
			if (qil.IsDebug && ndIter.SourceLine != null)
			{
				helper.DebugSequencePoint(ndIter.SourceLine);
			}
			if (ndIter.NodeType == QilNodeType.For || ndIter.XmlType.IsSingleton)
			{
				StartForBinding(ndIter, patt);
			}
			else
			{
				StartLetBinding(ndIter);
			}
			XmlILAnnotation.Write(ndIter).CachedIteratorDescriptor = iterNested;
		}

		private void StartForBinding(QilIterator ndFor, OptimizerPatterns patt)
		{
			LocalBuilder localBuilder = null;
			if (iterCurr.HasLabelNext)
			{
				StartNestedIterator(ndFor.Binding, iterCurr.GetLabelNext());
			}
			else
			{
				StartNestedIterator(ndFor.Binding);
			}
			if (patt.MatchesPattern(OptimizerPatternName.IsPositional))
			{
				localBuilder = helper.DeclareLocal("$$$pos", typeof(int));
				helper.Emit(OpCodes.Ldc_I4_0);
				helper.Emit(OpCodes.Stloc, localBuilder);
			}
			Visit(ndFor.Binding);
			if (qil.IsDebug && ndFor.DebugName != null)
			{
				helper.DebugStartScope();
				iterCurr.EnsureLocalNoCache("$$$for");
				iterCurr.Storage.LocalLocation.SetLocalSymInfo(ndFor.DebugName);
			}
			else
			{
				iterCurr.EnsureNoStackNoCache("$$$for");
			}
			if (patt.MatchesPattern(OptimizerPatternName.IsPositional))
			{
				helper.Emit(OpCodes.Ldloc, localBuilder);
				helper.Emit(OpCodes.Ldc_I4_1);
				helper.Emit(OpCodes.Add);
				helper.Emit(OpCodes.Stloc, localBuilder);
				if (patt.MatchesPattern(OptimizerPatternName.MaxPosition))
				{
					helper.Emit(OpCodes.Ldloc, localBuilder);
					helper.LoadInteger((int)patt.GetArgument(OptimizerPatternArgument.ElementQName));
					helper.Emit(OpCodes.Bgt, iterCurr.ParentIterator.GetLabelNext());
				}
				iterCurr.LocalPosition = localBuilder;
			}
			EndNestedIterator(ndFor.Binding);
			iterCurr.SetIterator(iterNested);
		}

		public void StartLetBinding(QilIterator ndLet)
		{
			StartNestedIterator(ndLet);
			NestedVisit(ndLet.Binding, GetItemStorageType(ndLet), !ndLet.XmlType.IsSingleton);
			if (qil.IsDebug && ndLet.DebugName != null)
			{
				helper.DebugStartScope();
				iterCurr.EnsureLocal("$$$cache");
				iterCurr.Storage.LocalLocation.SetLocalSymInfo(ndLet.DebugName);
			}
			else
			{
				iterCurr.EnsureNoStack("$$$cache");
			}
			EndNestedIterator(ndLet);
		}

		private void EndBinding(QilIterator ndIter)
		{
			if (qil.IsDebug && ndIter.DebugName != null)
			{
				helper.DebugEndScope();
			}
		}

		protected override QilNode VisitPositionOf(QilUnary ndPos)
		{
			QilIterator nd = ndPos.Child as QilIterator;
			LocalBuilder localPosition = XmlILAnnotation.Write(nd).CachedIteratorDescriptor.LocalPosition;
			iterCurr.Storage = StorageDescriptor.Local(localPosition, typeof(int), isCached: false);
			return ndPos;
		}

		protected override QilNode VisitSort(QilLoop ndSort)
		{
			Type itemStorageType = GetItemStorageType(ndSort);
			Label lblOnEnd = helper.DefineLabel();
			XmlILStorageMethods xmlILStorageMethods = XmlILMethods.StorageMethods[itemStorageType];
			LocalBuilder localBuilder = helper.DeclareLocal("$$$cache", xmlILStorageMethods.SeqType);
			helper.Emit(OpCodes.Ldloc, localBuilder);
			helper.CallToken(xmlILStorageMethods.SeqReuse);
			helper.Emit(OpCodes.Stloc, localBuilder);
			helper.Emit(OpCodes.Ldloc, localBuilder);
			LocalBuilder localBuilder2 = helper.DeclareLocal("$$$keys", typeof(XmlSortKeyAccumulator));
			helper.Emit(OpCodes.Ldloca, localBuilder2);
			helper.Call(XmlILMethods.SortKeyCreate);
			StartNestedIterator(ndSort.Variable, lblOnEnd);
			StartBinding(ndSort.Variable);
			iterCurr.EnsureStackNoCache();
			iterCurr.EnsureItemStorageType(ndSort.Variable.XmlType, GetItemStorageType(ndSort.Variable));
			helper.Call(xmlILStorageMethods.SeqAdd);
			helper.Emit(OpCodes.Ldloca, localBuilder2);
			foreach (QilSortKey item in ndSort.Body)
			{
				VisitSortKey(item, localBuilder2);
			}
			helper.Call(XmlILMethods.SortKeyFinish);
			helper.Emit(OpCodes.Ldloc, localBuilder);
			iterCurr.LoopToEnd(lblOnEnd);
			helper.Emit(OpCodes.Pop);
			helper.Emit(OpCodes.Ldloc, localBuilder);
			helper.Emit(OpCodes.Ldloca, localBuilder2);
			helper.Call(XmlILMethods.SortKeyKeys);
			helper.Call(xmlILStorageMethods.SeqSortByKeys);
			iterCurr.Storage = StorageDescriptor.Local(localBuilder, itemStorageType, isCached: true);
			EndBinding(ndSort.Variable);
			EndNestedIterator(ndSort.Variable);
			iterCurr.SetIterator(iterNested);
			return ndSort;
		}

		private void VisitSortKey(QilSortKey ndKey, LocalBuilder locKeys)
		{
			helper.Emit(OpCodes.Ldloca, locKeys);
			if (ndKey.Collation.NodeType == QilNodeType.LiteralString)
			{
				helper.CallGetCollation(helper.StaticData.DeclareCollation((QilLiteral)ndKey.Collation));
			}
			else
			{
				helper.LoadQueryRuntime();
				NestedVisitEnsureStack(ndKey.Collation);
				helper.Call(XmlILMethods.CreateCollation);
			}
			if (ndKey.XmlType.IsSingleton)
			{
				NestedVisitEnsureStack(ndKey.Key);
				helper.AddSortKey(ndKey.Key.XmlType);
				return;
			}
			Label label = helper.DefineLabel();
			StartNestedIterator(ndKey.Key, label);
			Visit(ndKey.Key);
			iterCurr.EnsureStackNoCache();
			iterCurr.EnsureItemStorageType(ndKey.Key.XmlType, GetItemStorageType(ndKey.Key));
			helper.AddSortKey(ndKey.Key.XmlType);
			Label label2 = helper.DefineLabel();
			helper.EmitUnconditionalBranch(OpCodes.Br_S, label2);
			helper.MarkLabel(label);
			helper.AddSortKey(null);
			helper.MarkLabel(label2);
			EndNestedIterator(ndKey.Key);
		}

		protected override QilNode VisitDocOrderDistinct(QilUnary ndDod)
		{
			if (ndDod.XmlType.IsSingleton)
			{
				return Visit(ndDod.Child);
			}
			if (HandleDodPatterns(ndDod))
			{
				return ndDod;
			}
			helper.LoadQueryRuntime();
			NestedVisitEnsureCache(ndDod.Child, typeof(XPathNavigator));
			iterCurr.EnsureStack();
			helper.Call(XmlILMethods.DocOrder);
			return ndDod;
		}

		private bool HandleDodPatterns(QilUnary ndDod)
		{
			OptimizerPatterns optimizerPatterns = OptimizerPatterns.Read(ndDod);
			bool flag = optimizerPatterns.MatchesPattern(OptimizerPatternName.JoinAndDod);
			if (flag || optimizerPatterns.MatchesPattern(OptimizerPatternName.DodReverse))
			{
				OptimizerPatterns optimizerPatterns2 = OptimizerPatterns.Read((QilNode)optimizerPatterns.GetArgument(OptimizerPatternArgument.ElementQName));
				XmlNodeKindFlags kinds;
				QilName ndName;
				if (optimizerPatterns2.MatchesPattern(OptimizerPatternName.FilterElements))
				{
					kinds = XmlNodeKindFlags.Element;
					ndName = (QilName)optimizerPatterns2.GetArgument(OptimizerPatternArgument.ElementQName);
				}
				else if (optimizerPatterns2.MatchesPattern(OptimizerPatternName.FilterContentKind))
				{
					kinds = ((XmlQueryType)optimizerPatterns2.GetArgument(OptimizerPatternArgument.ElementQName)).NodeKinds;
					ndName = null;
				}
				else
				{
					kinds = (((ndDod.XmlType.NodeKinds & XmlNodeKindFlags.Attribute) != 0) ? XmlNodeKindFlags.Any : XmlNodeKindFlags.Content);
					ndName = null;
				}
				QilNode qilNode = (QilNode)optimizerPatterns2.GetArgument(OptimizerPatternArgument.StepNode);
				if (flag)
				{
					switch (qilNode.NodeType)
					{
					case QilNodeType.Content:
						CreateContainerIterator(ndDod, "$$$iterContent", typeof(ContentMergeIterator), XmlILMethods.ContentMergeCreate, XmlILMethods.ContentMergeNext, kinds, ndName, TriState.Unknown);
						return true;
					case QilNodeType.Descendant:
					case QilNodeType.DescendantOrSelf:
						CreateContainerIterator(ndDod, "$$$iterDesc", typeof(DescendantMergeIterator), XmlILMethods.DescMergeCreate, XmlILMethods.DescMergeNext, kinds, ndName, (qilNode.NodeType != QilNodeType.Descendant) ? TriState.True : TriState.False);
						return true;
					case QilNodeType.XPathFollowing:
						CreateContainerIterator(ndDod, "$$$iterFoll", typeof(XPathFollowingMergeIterator), XmlILMethods.XPFollMergeCreate, XmlILMethods.XPFollMergeNext, kinds, ndName, TriState.Unknown);
						return true;
					case QilNodeType.FollowingSibling:
						CreateContainerIterator(ndDod, "$$$iterFollSib", typeof(FollowingSiblingMergeIterator), XmlILMethods.FollSibMergeCreate, XmlILMethods.FollSibMergeNext, kinds, ndName, TriState.Unknown);
						return true;
					case QilNodeType.XPathPreceding:
						CreateContainerIterator(ndDod, "$$$iterPrec", typeof(XPathPrecedingMergeIterator), XmlILMethods.XPPrecMergeCreate, XmlILMethods.XPPrecMergeNext, kinds, ndName, TriState.Unknown);
						return true;
					}
				}
				else
				{
					QilNode ndCtxt = (QilNode)optimizerPatterns2.GetArgument(OptimizerPatternArgument.StepInput);
					switch (qilNode.NodeType)
					{
					case QilNodeType.Ancestor:
					case QilNodeType.AncestorOrSelf:
						CreateFilteredIterator(ndCtxt, "$$$iterAnc", typeof(AncestorDocOrderIterator), XmlILMethods.AncDOCreate, XmlILMethods.AncDONext, kinds, ndName, (qilNode.NodeType != QilNodeType.Ancestor) ? TriState.True : TriState.False, null);
						return true;
					case QilNodeType.PrecedingSibling:
						CreateFilteredIterator(ndCtxt, "$$$iterPreSib", typeof(PrecedingSiblingDocOrderIterator), XmlILMethods.PreSibDOCreate, XmlILMethods.PreSibDONext, kinds, ndName, TriState.Unknown, null);
						return true;
					case QilNodeType.XPathPreceding:
						CreateFilteredIterator(ndCtxt, "$$$iterPrec", typeof(XPathPrecedingDocOrderIterator), XmlILMethods.XPPrecDOCreate, XmlILMethods.XPPrecDONext, kinds, ndName, TriState.Unknown, null);
						return true;
					}
				}
			}
			else if (optimizerPatterns.MatchesPattern(OptimizerPatternName.DodMerge))
			{
				LocalBuilder locBldr = helper.DeclareLocal("$$$dodMerge", typeof(DodSequenceMerge));
				Label lblOnEnd = helper.DefineLabel();
				helper.Emit(OpCodes.Ldloca, locBldr);
				helper.LoadQueryRuntime();
				helper.Call(XmlILMethods.DodMergeCreate);
				helper.Emit(OpCodes.Ldloca, locBldr);
				StartNestedIterator(ndDod.Child, lblOnEnd);
				Visit(ndDod.Child);
				iterCurr.EnsureStack();
				helper.Call(XmlILMethods.DodMergeAdd);
				helper.Emit(OpCodes.Ldloca, locBldr);
				iterCurr.LoopToEnd(lblOnEnd);
				EndNestedIterator(ndDod.Child);
				helper.Call(XmlILMethods.DodMergeSeq);
				iterCurr.Storage = StorageDescriptor.Stack(typeof(XPathNavigator), isCached: true);
				return true;
			}
			return false;
		}

		protected override QilNode VisitInvoke(QilInvoke ndInvoke)
		{
			QilFunction function = ndInvoke.Function;
			MethodInfo functionBinding = XmlILAnnotation.Write(function).FunctionBinding;
			bool flag = XmlILConstructInfo.Read(function).ConstructMethod == XmlILConstructMethod.Writer;
			helper.LoadQueryRuntime();
			for (int i = 0; i < ndInvoke.Arguments.Count; i++)
			{
				QilNode nd = ndInvoke.Arguments[i];
				QilNode qilNode = ndInvoke.Function.Arguments[i];
				NestedVisitEnsureStack(nd, GetItemStorageType(qilNode), !qilNode.XmlType.IsSingleton);
			}
			if (OptimizerPatterns.Read(ndInvoke).MatchesPattern(OptimizerPatternName.TailCall))
			{
				helper.TailCall(functionBinding);
			}
			else
			{
				helper.Call(functionBinding);
			}
			if (!flag)
			{
				iterCurr.Storage = StorageDescriptor.Stack(GetItemStorageType(ndInvoke), !ndInvoke.XmlType.IsSingleton);
			}
			else
			{
				iterCurr.Storage = StorageDescriptor.None();
			}
			return ndInvoke;
		}

		protected override QilNode VisitContent(QilUnary ndContent)
		{
			CreateSimpleIterator(ndContent.Child, "$$$iterAttrContent", typeof(AttributeContentIterator), XmlILMethods.AttrContentCreate, XmlILMethods.AttrContentNext);
			return ndContent;
		}

		protected override QilNode VisitAttribute(QilBinary ndAttr)
		{
			QilName qilName = ndAttr.Right as QilName;
			LocalBuilder localBuilder = helper.DeclareLocal("$$$navAttr", typeof(XPathNavigator));
			SyncToNavigator(localBuilder, ndAttr.Left);
			helper.Emit(OpCodes.Ldloc, localBuilder);
			helper.CallGetAtomizedName(helper.StaticData.DeclareName(qilName.LocalName));
			helper.CallGetAtomizedName(helper.StaticData.DeclareName(qilName.NamespaceUri));
			helper.Call(XmlILMethods.NavMoveAttr);
			helper.Emit(OpCodes.Brfalse, iterCurr.GetLabelNext());
			iterCurr.Storage = StorageDescriptor.Local(localBuilder, typeof(XPathNavigator), isCached: false);
			return ndAttr;
		}

		protected override QilNode VisitParent(QilUnary ndParent)
		{
			LocalBuilder localBuilder = helper.DeclareLocal("$$$navParent", typeof(XPathNavigator));
			SyncToNavigator(localBuilder, ndParent.Child);
			helper.Emit(OpCodes.Ldloc, localBuilder);
			helper.Call(XmlILMethods.NavMoveParent);
			helper.Emit(OpCodes.Brfalse, iterCurr.GetLabelNext());
			iterCurr.Storage = StorageDescriptor.Local(localBuilder, typeof(XPathNavigator), isCached: false);
			return ndParent;
		}

		protected override QilNode VisitRoot(QilUnary ndRoot)
		{
			LocalBuilder localBuilder = helper.DeclareLocal("$$$navRoot", typeof(XPathNavigator));
			SyncToNavigator(localBuilder, ndRoot.Child);
			helper.Emit(OpCodes.Ldloc, localBuilder);
			helper.Call(XmlILMethods.NavMoveRoot);
			iterCurr.Storage = StorageDescriptor.Local(localBuilder, typeof(XPathNavigator), isCached: false);
			return ndRoot;
		}

		protected override QilNode VisitXmlContext(QilNode ndCtxt)
		{
			helper.LoadQueryContext();
			helper.Call(XmlILMethods.GetDefaultDataSource);
			iterCurr.Storage = StorageDescriptor.Stack(typeof(XPathNavigator), isCached: false);
			return ndCtxt;
		}

		protected override QilNode VisitDescendant(QilUnary ndDesc)
		{
			CreateFilteredIterator(ndDesc.Child, "$$$iterDesc", typeof(DescendantIterator), XmlILMethods.DescCreate, XmlILMethods.DescNext, XmlNodeKindFlags.Any, null, TriState.False, null);
			return ndDesc;
		}

		protected override QilNode VisitDescendantOrSelf(QilUnary ndDesc)
		{
			CreateFilteredIterator(ndDesc.Child, "$$$iterDesc", typeof(DescendantIterator), XmlILMethods.DescCreate, XmlILMethods.DescNext, XmlNodeKindFlags.Any, null, TriState.True, null);
			return ndDesc;
		}

		protected override QilNode VisitAncestor(QilUnary ndAnc)
		{
			CreateFilteredIterator(ndAnc.Child, "$$$iterAnc", typeof(AncestorIterator), XmlILMethods.AncCreate, XmlILMethods.AncNext, XmlNodeKindFlags.Any, null, TriState.False, null);
			return ndAnc;
		}

		protected override QilNode VisitAncestorOrSelf(QilUnary ndAnc)
		{
			CreateFilteredIterator(ndAnc.Child, "$$$iterAnc", typeof(AncestorIterator), XmlILMethods.AncCreate, XmlILMethods.AncNext, XmlNodeKindFlags.Any, null, TriState.True, null);
			return ndAnc;
		}

		protected override QilNode VisitPreceding(QilUnary ndPrec)
		{
			CreateFilteredIterator(ndPrec.Child, "$$$iterPrec", typeof(PrecedingIterator), XmlILMethods.PrecCreate, XmlILMethods.PrecNext, XmlNodeKindFlags.Any, null, TriState.Unknown, null);
			return ndPrec;
		}

		protected override QilNode VisitFollowingSibling(QilUnary ndFollSib)
		{
			CreateFilteredIterator(ndFollSib.Child, "$$$iterFollSib", typeof(FollowingSiblingIterator), XmlILMethods.FollSibCreate, XmlILMethods.FollSibNext, XmlNodeKindFlags.Any, null, TriState.Unknown, null);
			return ndFollSib;
		}

		protected override QilNode VisitPrecedingSibling(QilUnary ndPreSib)
		{
			CreateFilteredIterator(ndPreSib.Child, "$$$iterPreSib", typeof(PrecedingSiblingIterator), XmlILMethods.PreSibCreate, XmlILMethods.PreSibNext, XmlNodeKindFlags.Any, null, TriState.Unknown, null);
			return ndPreSib;
		}

		protected override QilNode VisitNodeRange(QilBinary ndRange)
		{
			CreateFilteredIterator(ndRange.Left, "$$$iterRange", typeof(NodeRangeIterator), XmlILMethods.NodeRangeCreate, XmlILMethods.NodeRangeNext, XmlNodeKindFlags.Any, null, TriState.Unknown, ndRange.Right);
			return ndRange;
		}

		protected override QilNode VisitDeref(QilBinary ndDeref)
		{
			LocalBuilder localBuilder = helper.DeclareLocal("$$$iterId", typeof(IdIterator));
			helper.Emit(OpCodes.Ldloca, localBuilder);
			NestedVisitEnsureStack(ndDeref.Left);
			NestedVisitEnsureStack(ndDeref.Right);
			helper.Call(XmlILMethods.IdCreate);
			GenerateSimpleIterator(typeof(XPathNavigator), localBuilder, XmlILMethods.IdNext);
			return ndDeref;
		}

		protected override QilNode VisitElementCtor(QilBinary ndElem)
		{
			XmlILConstructInfo xmlILConstructInfo = XmlILConstructInfo.Read(ndElem);
			bool flag = CheckWithinContent(xmlILConstructInfo) || !xmlILConstructInfo.IsNamespaceInScope || ElementCachesAttributes(xmlILConstructInfo);
			if (XmlILConstructInfo.Read(ndElem.Right).FinalStates == PossibleXmlStates.Any)
			{
				flag = true;
			}
			if (xmlILConstructInfo.FinalStates == PossibleXmlStates.Any)
			{
				flag = true;
			}
			if (!flag)
			{
				BeforeStartChecks(ndElem);
			}
			GenerateNameType nameType = LoadNameAndType(XPathNodeType.Element, ndElem.Left, isStart: true, flag);
			helper.CallWriteStartElement(nameType, flag);
			NestedVisit(ndElem.Right);
			if (XmlILConstructInfo.Read(ndElem.Right).FinalStates == PossibleXmlStates.EnumAttrs && !flag)
			{
				helper.CallStartElementContent();
			}
			nameType = LoadNameAndType(XPathNodeType.Element, ndElem.Left, isStart: false, flag);
			helper.CallWriteEndElement(nameType, flag);
			if (!flag)
			{
				AfterEndChecks(ndElem);
			}
			iterCurr.Storage = StorageDescriptor.None();
			return ndElem;
		}

		protected override QilNode VisitAttributeCtor(QilBinary ndAttr)
		{
			XmlILConstructInfo xmlILConstructInfo = XmlILConstructInfo.Read(ndAttr);
			bool flag = CheckEnumAttrs(xmlILConstructInfo) || !xmlILConstructInfo.IsNamespaceInScope;
			if (!flag)
			{
				BeforeStartChecks(ndAttr);
			}
			GenerateNameType nameType = LoadNameAndType(XPathNodeType.Attribute, ndAttr.Left, isStart: true, flag);
			helper.CallWriteStartAttribute(nameType, flag);
			NestedVisit(ndAttr.Right);
			helper.CallWriteEndAttribute(flag);
			if (!flag)
			{
				AfterEndChecks(ndAttr);
			}
			iterCurr.Storage = StorageDescriptor.None();
			return ndAttr;
		}

		protected override QilNode VisitCommentCtor(QilUnary ndComment)
		{
			helper.CallWriteStartComment();
			NestedVisit(ndComment.Child);
			helper.CallWriteEndComment();
			iterCurr.Storage = StorageDescriptor.None();
			return ndComment;
		}

		protected override QilNode VisitPICtor(QilBinary ndPI)
		{
			helper.LoadQueryOutput();
			NestedVisitEnsureStack(ndPI.Left);
			helper.CallWriteStartPI();
			NestedVisit(ndPI.Right);
			helper.CallWriteEndPI();
			iterCurr.Storage = StorageDescriptor.None();
			return ndPI;
		}

		protected override QilNode VisitTextCtor(QilUnary ndText)
		{
			return VisitTextCtor(ndText, disableOutputEscaping: false);
		}

		protected override QilNode VisitRawTextCtor(QilUnary ndText)
		{
			return VisitTextCtor(ndText, disableOutputEscaping: true);
		}

		private QilNode VisitTextCtor(QilUnary ndText, bool disableOutputEscaping)
		{
			XmlILConstructInfo xmlILConstructInfo = XmlILConstructInfo.Read(ndText);
			bool flag;
			switch (xmlILConstructInfo.InitialStates)
			{
			case PossibleXmlStates.WithinAttr:
			case PossibleXmlStates.WithinComment:
			case PossibleXmlStates.WithinPI:
				flag = false;
				break;
			default:
				flag = CheckWithinContent(xmlILConstructInfo);
				break;
			}
			if (!flag)
			{
				BeforeStartChecks(ndText);
			}
			helper.LoadQueryOutput();
			NestedVisitEnsureStack(ndText.Child);
			switch (xmlILConstructInfo.InitialStates)
			{
			case PossibleXmlStates.WithinAttr:
				helper.CallWriteString(disableOutputEscaping: false, flag);
				break;
			case PossibleXmlStates.WithinComment:
				helper.Call(XmlILMethods.CommentText);
				break;
			case PossibleXmlStates.WithinPI:
				helper.Call(XmlILMethods.PIText);
				break;
			default:
				helper.CallWriteString(disableOutputEscaping, flag);
				break;
			}
			if (!flag)
			{
				AfterEndChecks(ndText);
			}
			iterCurr.Storage = StorageDescriptor.None();
			return ndText;
		}

		protected override QilNode VisitDocumentCtor(QilUnary ndDoc)
		{
			helper.CallWriteStartRoot();
			NestedVisit(ndDoc.Child);
			helper.CallWriteEndRoot();
			iterCurr.Storage = StorageDescriptor.None();
			return ndDoc;
		}

		protected override QilNode VisitNamespaceDecl(QilBinary ndNmsp)
		{
			XmlILConstructInfo info = XmlILConstructInfo.Read(ndNmsp);
			bool flag = CheckEnumAttrs(info) || MightHaveNamespacesAfterAttributes(info);
			if (!flag)
			{
				BeforeStartChecks(ndNmsp);
			}
			helper.LoadQueryOutput();
			NestedVisitEnsureStack(ndNmsp.Left);
			NestedVisitEnsureStack(ndNmsp.Right);
			helper.CallWriteNamespaceDecl(flag);
			if (!flag)
			{
				AfterEndChecks(ndNmsp);
			}
			iterCurr.Storage = StorageDescriptor.None();
			return ndNmsp;
		}

		protected override QilNode VisitRtfCtor(QilBinary ndRtf)
		{
			OptimizerPatterns optimizerPatterns = OptimizerPatterns.Read(ndRtf);
			string text = (QilLiteral)ndRtf.Right;
			if (optimizerPatterns.MatchesPattern(OptimizerPatternName.SingleTextRtf))
			{
				helper.LoadQueryRuntime();
				NestedVisitEnsureStack((QilNode)optimizerPatterns.GetArgument(OptimizerPatternArgument.ElementQName));
				helper.Emit(OpCodes.Ldstr, text);
				helper.Call(XmlILMethods.RtfConstr);
			}
			else
			{
				helper.CallStartRtfConstruction(text);
				NestedVisit(ndRtf.Left);
				helper.CallEndRtfConstruction();
			}
			iterCurr.Storage = StorageDescriptor.Stack(typeof(XPathNavigator), isCached: false);
			return ndRtf;
		}

		protected override QilNode VisitNameOf(QilUnary ndName)
		{
			return VisitNodeProperty(ndName);
		}

		protected override QilNode VisitLocalNameOf(QilUnary ndName)
		{
			return VisitNodeProperty(ndName);
		}

		protected override QilNode VisitNamespaceUriOf(QilUnary ndName)
		{
			return VisitNodeProperty(ndName);
		}

		protected override QilNode VisitPrefixOf(QilUnary ndName)
		{
			return VisitNodeProperty(ndName);
		}

		private QilNode VisitNodeProperty(QilUnary ndProp)
		{
			NestedVisitEnsureStack(ndProp.Child);
			switch (ndProp.NodeType)
			{
			case QilNodeType.NameOf:
				helper.Emit(OpCodes.Dup);
				helper.Call(XmlILMethods.NavLocalName);
				helper.Call(XmlILMethods.NavNmsp);
				helper.Construct(XmlILConstructors.QName);
				iterCurr.Storage = StorageDescriptor.Stack(typeof(XmlQualifiedName), isCached: false);
				break;
			case QilNodeType.LocalNameOf:
				helper.Call(XmlILMethods.NavLocalName);
				iterCurr.Storage = StorageDescriptor.Stack(typeof(string), isCached: false);
				break;
			case QilNodeType.NamespaceUriOf:
				helper.Call(XmlILMethods.NavNmsp);
				iterCurr.Storage = StorageDescriptor.Stack(typeof(string), isCached: false);
				break;
			case QilNodeType.PrefixOf:
				helper.Call(XmlILMethods.NavPrefix);
				iterCurr.Storage = StorageDescriptor.Stack(typeof(string), isCached: false);
				break;
			}
			return ndProp;
		}

		protected override QilNode VisitTypeAssert(QilTargetType ndTypeAssert)
		{
			if (!ndTypeAssert.Source.XmlType.IsSingleton && ndTypeAssert.XmlType.IsSingleton && !iterCurr.HasLabelNext)
			{
				Label label = helper.DefineLabel();
				helper.MarkLabel(label);
				NestedVisit(ndTypeAssert.Source, label);
			}
			else
			{
				Visit(ndTypeAssert.Source);
			}
			iterCurr.EnsureItemStorageType(ndTypeAssert.Source.XmlType, GetItemStorageType(ndTypeAssert));
			return ndTypeAssert;
		}

		protected override QilNode VisitIsType(QilTargetType ndIsType)
		{
			XmlQueryType xmlType = ndIsType.Source.XmlType;
			XmlQueryType targetType = ndIsType.TargetType;
			if (xmlType.IsSingleton && object.Equals(targetType, XmlQueryTypeFactory.Node))
			{
				NestedVisitEnsureStack(ndIsType.Source);
				helper.Call(XmlILMethods.ItemIsNode);
				ZeroCompare(QilNodeType.Ne, isBoolVal: true);
				return ndIsType;
			}
			if (MatchesNodeKinds(ndIsType, xmlType, targetType))
			{
				return ndIsType;
			}
			XmlTypeCode xmlTypeCode = (object.Equals(targetType, XmlQueryTypeFactory.Double) ? XmlTypeCode.Double : (object.Equals(targetType, XmlQueryTypeFactory.String) ? XmlTypeCode.String : (object.Equals(targetType, XmlQueryTypeFactory.Boolean) ? XmlTypeCode.Boolean : (object.Equals(targetType, XmlQueryTypeFactory.Node) ? XmlTypeCode.Node : XmlTypeCode.None))));
			if (xmlTypeCode != 0)
			{
				helper.LoadQueryRuntime();
				NestedVisitEnsureStack(ndIsType.Source, typeof(XPathItem), !xmlType.IsSingleton);
				helper.LoadInteger((int)xmlTypeCode);
				helper.Call(xmlType.IsSingleton ? XmlILMethods.ItemMatchesCode : XmlILMethods.SeqMatchesCode);
				ZeroCompare(QilNodeType.Ne, isBoolVal: true);
				return ndIsType;
			}
			helper.LoadQueryRuntime();
			NestedVisitEnsureStack(ndIsType.Source, typeof(XPathItem), !xmlType.IsSingleton);
			helper.LoadInteger(helper.StaticData.DeclareXmlType(targetType));
			helper.Call(xmlType.IsSingleton ? XmlILMethods.ItemMatchesType : XmlILMethods.SeqMatchesType);
			ZeroCompare(QilNodeType.Ne, isBoolVal: true);
			return ndIsType;
		}

		private bool MatchesNodeKinds(QilTargetType ndIsType, XmlQueryType typDerived, XmlQueryType typBase)
		{
			bool flag = true;
			if (!typBase.IsNode || !typBase.IsSingleton)
			{
				return false;
			}
			if (!typDerived.IsNode || !typDerived.IsSingleton || !typDerived.IsNotRtf)
			{
				return false;
			}
			XmlNodeKindFlags xmlNodeKindFlags = XmlNodeKindFlags.None;
			foreach (XmlQueryType item in typBase)
			{
				if (object.Equals(item, XmlQueryTypeFactory.Element))
				{
					xmlNodeKindFlags |= XmlNodeKindFlags.Element;
					continue;
				}
				if (object.Equals(item, XmlQueryTypeFactory.Attribute))
				{
					xmlNodeKindFlags |= XmlNodeKindFlags.Attribute;
					continue;
				}
				if (object.Equals(item, XmlQueryTypeFactory.Text))
				{
					xmlNodeKindFlags |= XmlNodeKindFlags.Text;
					continue;
				}
				if (object.Equals(item, XmlQueryTypeFactory.Document))
				{
					xmlNodeKindFlags |= XmlNodeKindFlags.Document;
					continue;
				}
				if (object.Equals(item, XmlQueryTypeFactory.Comment))
				{
					xmlNodeKindFlags |= XmlNodeKindFlags.Comment;
					continue;
				}
				if (object.Equals(item, XmlQueryTypeFactory.PI))
				{
					xmlNodeKindFlags |= XmlNodeKindFlags.PI;
					continue;
				}
				if (object.Equals(item, XmlQueryTypeFactory.Namespace))
				{
					xmlNodeKindFlags |= XmlNodeKindFlags.Namespace;
					continue;
				}
				return false;
			}
			xmlNodeKindFlags = typDerived.NodeKinds & xmlNodeKindFlags;
			if (!Bits.ExactlyOne((uint)xmlNodeKindFlags))
			{
				xmlNodeKindFlags = ~xmlNodeKindFlags & XmlNodeKindFlags.Any;
				flag = !flag;
			}
			XPathNodeType xPathNodeType;
			switch (xmlNodeKindFlags)
			{
			case XmlNodeKindFlags.Element:
				xPathNodeType = XPathNodeType.Element;
				break;
			case XmlNodeKindFlags.Attribute:
				xPathNodeType = XPathNodeType.Attribute;
				break;
			case XmlNodeKindFlags.Namespace:
				xPathNodeType = XPathNodeType.Namespace;
				break;
			case XmlNodeKindFlags.PI:
				xPathNodeType = XPathNodeType.ProcessingInstruction;
				break;
			case XmlNodeKindFlags.Comment:
				xPathNodeType = XPathNodeType.Comment;
				break;
			case XmlNodeKindFlags.Document:
				xPathNodeType = XPathNodeType.Root;
				break;
			default:
				helper.Emit(OpCodes.Ldc_I4_1);
				xPathNodeType = XPathNodeType.All;
				break;
			}
			NestedVisitEnsureStack(ndIsType.Source);
			helper.Call(XmlILMethods.NavType);
			if (xPathNodeType == XPathNodeType.All)
			{
				helper.Emit(OpCodes.Shl);
				int num = 0;
				if ((xmlNodeKindFlags & XmlNodeKindFlags.Document) != 0)
				{
					num |= 1;
				}
				if ((xmlNodeKindFlags & XmlNodeKindFlags.Element) != 0)
				{
					num |= 2;
				}
				if ((xmlNodeKindFlags & XmlNodeKindFlags.Attribute) != 0)
				{
					num |= 4;
				}
				if ((xmlNodeKindFlags & XmlNodeKindFlags.Text) != 0)
				{
					num |= 0x70;
				}
				if ((xmlNodeKindFlags & XmlNodeKindFlags.Comment) != 0)
				{
					num |= 0x100;
				}
				if ((xmlNodeKindFlags & XmlNodeKindFlags.PI) != 0)
				{
					num |= 0x80;
				}
				if ((xmlNodeKindFlags & XmlNodeKindFlags.Namespace) != 0)
				{
					num |= 8;
				}
				helper.LoadInteger(num);
				helper.Emit(OpCodes.And);
				ZeroCompare(flag ? QilNodeType.Ne : QilNodeType.Eq, isBoolVal: false);
			}
			else
			{
				helper.LoadInteger((int)xPathNodeType);
				ClrCompare(flag ? QilNodeType.Eq : QilNodeType.Ne, XmlTypeCode.Int);
			}
			return true;
		}

		protected override QilNode VisitIsEmpty(QilUnary ndIsEmpty)
		{
			if (CachesResult(ndIsEmpty.Child))
			{
				NestedVisitEnsureStack(ndIsEmpty.Child);
				helper.CallCacheCount(iterNested.Storage.ItemStorageType);
				switch (iterCurr.CurrentBranchingContext)
				{
				case BranchingContext.OnFalse:
					helper.TestAndBranch(0, iterCurr.LabelBranch, OpCodes.Bne_Un);
					break;
				case BranchingContext.OnTrue:
					helper.TestAndBranch(0, iterCurr.LabelBranch, OpCodes.Beq);
					break;
				default:
				{
					Label label = helper.DefineLabel();
					helper.Emit(OpCodes.Brfalse_S, label);
					helper.ConvBranchToBool(label, isTrueBranch: true);
					break;
				}
				}
			}
			else
			{
				Label label2 = helper.DefineLabel();
				IteratorDescriptor iteratorDescriptor = iterCurr;
				if (iteratorDescriptor.CurrentBranchingContext == BranchingContext.OnTrue)
				{
					StartNestedIterator(ndIsEmpty.Child, iterCurr.LabelBranch);
				}
				else
				{
					StartNestedIterator(ndIsEmpty.Child, label2);
				}
				Visit(ndIsEmpty.Child);
				iterCurr.EnsureNoCache();
				iterCurr.DiscardStack();
				switch (iteratorDescriptor.CurrentBranchingContext)
				{
				case BranchingContext.OnFalse:
					helper.EmitUnconditionalBranch(OpCodes.Br, iteratorDescriptor.LabelBranch);
					helper.MarkLabel(label2);
					break;
				case BranchingContext.None:
					helper.ConvBranchToBool(label2, isTrueBranch: true);
					break;
				}
				EndNestedIterator(ndIsEmpty.Child);
			}
			if (iterCurr.IsBranching)
			{
				iterCurr.Storage = StorageDescriptor.None();
			}
			else
			{
				iterCurr.Storage = StorageDescriptor.Stack(typeof(bool), isCached: false);
			}
			return ndIsEmpty;
		}

		protected override QilNode VisitXPathNodeValue(QilUnary ndVal)
		{
			if (ndVal.Child.XmlType.IsSingleton)
			{
				NestedVisitEnsureStack(ndVal.Child, typeof(XPathNavigator), isCached: false);
				helper.Call(XmlILMethods.Value);
			}
			else
			{
				Label label = helper.DefineLabel();
				StartNestedIterator(ndVal.Child, label);
				Visit(ndVal.Child);
				iterCurr.EnsureStackNoCache();
				helper.Call(XmlILMethods.Value);
				Label label2 = helper.DefineLabel();
				helper.EmitUnconditionalBranch(OpCodes.Br, label2);
				helper.MarkLabel(label);
				helper.Emit(OpCodes.Ldstr, "");
				helper.MarkLabel(label2);
				EndNestedIterator(ndVal.Child);
			}
			iterCurr.Storage = StorageDescriptor.Stack(typeof(string), isCached: false);
			return ndVal;
		}

		protected override QilNode VisitXPathFollowing(QilUnary ndFoll)
		{
			CreateFilteredIterator(ndFoll.Child, "$$$iterFoll", typeof(XPathFollowingIterator), XmlILMethods.XPFollCreate, XmlILMethods.XPFollNext, XmlNodeKindFlags.Any, null, TriState.Unknown, null);
			return ndFoll;
		}

		protected override QilNode VisitXPathPreceding(QilUnary ndPrec)
		{
			CreateFilteredIterator(ndPrec.Child, "$$$iterPrec", typeof(XPathPrecedingIterator), XmlILMethods.XPPrecCreate, XmlILMethods.XPPrecNext, XmlNodeKindFlags.Any, null, TriState.Unknown, null);
			return ndPrec;
		}

		protected override QilNode VisitXPathNamespace(QilUnary ndNmsp)
		{
			CreateSimpleIterator(ndNmsp.Child, "$$$iterNmsp", typeof(NamespaceIterator), XmlILMethods.NmspCreate, XmlILMethods.NmspNext);
			return ndNmsp;
		}

		protected override QilNode VisitXsltGenerateId(QilUnary ndGenId)
		{
			helper.LoadQueryRuntime();
			if (ndGenId.Child.XmlType.IsSingleton)
			{
				NestedVisitEnsureStack(ndGenId.Child, typeof(XPathNavigator), isCached: false);
				helper.Call(XmlILMethods.GenId);
			}
			else
			{
				Label label = helper.DefineLabel();
				StartNestedIterator(ndGenId.Child, label);
				Visit(ndGenId.Child);
				iterCurr.EnsureStackNoCache();
				iterCurr.EnsureItemStorageType(ndGenId.Child.XmlType, typeof(XPathNavigator));
				helper.Call(XmlILMethods.GenId);
				Label label2 = helper.DefineLabel();
				helper.EmitUnconditionalBranch(OpCodes.Br, label2);
				helper.MarkLabel(label);
				helper.Emit(OpCodes.Pop);
				helper.Emit(OpCodes.Ldstr, "");
				helper.MarkLabel(label2);
				EndNestedIterator(ndGenId.Child);
			}
			iterCurr.Storage = StorageDescriptor.Stack(typeof(string), isCached: false);
			return ndGenId;
		}

		protected override QilNode VisitXsltInvokeLateBound(QilInvokeLateBound ndInvoke)
		{
			LocalBuilder locBldr = helper.DeclareLocal("$$$args", typeof(IList<XPathItem>[]));
			QilName name = ndInvoke.Name;
			helper.LoadQueryContext();
			helper.Emit(OpCodes.Ldstr, name.LocalName);
			helper.Emit(OpCodes.Ldstr, name.NamespaceUri);
			helper.LoadInteger(ndInvoke.Arguments.Count);
			helper.Emit(OpCodes.Newarr, typeof(IList<XPathItem>));
			helper.Emit(OpCodes.Stloc, locBldr);
			for (int i = 0; i < ndInvoke.Arguments.Count; i++)
			{
				QilNode nd = ndInvoke.Arguments[i];
				helper.Emit(OpCodes.Ldloc, locBldr);
				helper.LoadInteger(i);
				helper.Emit(OpCodes.Ldelema, typeof(IList<XPathItem>));
				NestedVisitEnsureCache(nd, typeof(XPathItem));
				iterCurr.EnsureStack();
				helper.Emit(OpCodes.Stobj, typeof(IList<XPathItem>));
			}
			helper.Emit(OpCodes.Ldloc, locBldr);
			helper.Call(XmlILMethods.InvokeXsltLate);
			iterCurr.Storage = StorageDescriptor.Stack(typeof(XPathItem), isCached: true);
			return ndInvoke;
		}

		protected override QilNode VisitXsltInvokeEarlyBound(QilInvokeEarlyBound ndInvoke)
		{
			QilName name = ndInvoke.Name;
			XmlExtensionFunction xmlExtensionFunction = new XmlExtensionFunction(name.LocalName, name.NamespaceUri, ndInvoke.ClrMethod);
			Type clrReturnType = xmlExtensionFunction.ClrReturnType;
			Type storageType = GetStorageType(ndInvoke);
			if (clrReturnType != storageType && !ndInvoke.XmlType.IsEmpty)
			{
				helper.LoadQueryRuntime();
				helper.LoadInteger(helper.StaticData.DeclareXmlType(ndInvoke.XmlType));
			}
			if (!xmlExtensionFunction.Method.IsStatic)
			{
				if (name.NamespaceUri.Length == 0)
				{
					helper.LoadXsltLibrary();
				}
				else
				{
					helper.CallGetEarlyBoundObject(helper.StaticData.DeclareEarlyBound(name.NamespaceUri, xmlExtensionFunction.Method.DeclaringType), xmlExtensionFunction.Method.DeclaringType);
				}
			}
			for (int i = 0; i < ndInvoke.Arguments.Count; i++)
			{
				QilNode qilNode = ndInvoke.Arguments[i];
				XmlQueryType xmlArgumentType = xmlExtensionFunction.GetXmlArgumentType(i);
				Type clrArgumentType = xmlExtensionFunction.GetClrArgumentType(i);
				if (name.NamespaceUri.Length == 0)
				{
					Type itemStorageType = GetItemStorageType(qilNode);
					if (clrArgumentType == XmlILMethods.StorageMethods[itemStorageType].IListType)
					{
						NestedVisitEnsureStack(qilNode, itemStorageType, isCached: true);
					}
					else if (clrArgumentType == XmlILMethods.StorageMethods[typeof(XPathItem)].IListType)
					{
						NestedVisitEnsureStack(qilNode, typeof(XPathItem), isCached: true);
					}
					else if ((qilNode.XmlType.IsSingleton && clrArgumentType == itemStorageType) || qilNode.XmlType.TypeCode == XmlTypeCode.None)
					{
						NestedVisitEnsureStack(qilNode, clrArgumentType, isCached: false);
					}
					else if (qilNode.XmlType.IsSingleton && clrArgumentType == typeof(XPathItem))
					{
						NestedVisitEnsureStack(qilNode, typeof(XPathItem), isCached: false);
					}
				}
				else
				{
					Type storageType2 = GetStorageType(xmlArgumentType);
					if (xmlArgumentType.TypeCode == XmlTypeCode.Item || !clrArgumentType.IsAssignableFrom(storageType2))
					{
						helper.LoadQueryRuntime();
						helper.LoadInteger(helper.StaticData.DeclareXmlType(xmlArgumentType));
						NestedVisitEnsureStack(qilNode, GetItemStorageType(xmlArgumentType), !xmlArgumentType.IsSingleton);
						helper.TreatAs(storageType2, typeof(object));
						helper.LoadType(clrArgumentType);
						helper.Call(XmlILMethods.ChangeTypeXsltArg);
						helper.TreatAs(typeof(object), clrArgumentType);
					}
					else
					{
						NestedVisitEnsureStack(qilNode, GetItemStorageType(xmlArgumentType), !xmlArgumentType.IsSingleton);
					}
				}
			}
			helper.Call(xmlExtensionFunction.Method);
			if (ndInvoke.XmlType.IsEmpty)
			{
				helper.Emit(OpCodes.Ldsfld, XmlILMethods.StorageMethods[typeof(XPathItem)].SeqEmpty);
			}
			else if (clrReturnType != storageType)
			{
				helper.TreatAs(clrReturnType, typeof(object));
				helper.Call(XmlILMethods.ChangeTypeXsltResult);
				helper.TreatAs(typeof(object), storageType);
			}
			else if (name.NamespaceUri.Length != 0 && !clrReturnType.IsValueType)
			{
				Label label = helper.DefineLabel();
				helper.Emit(OpCodes.Dup);
				helper.Emit(OpCodes.Brtrue, label);
				helper.LoadQueryRuntime();
				helper.Emit(OpCodes.Ldstr, System.Xml.Utils.Res.GetString("Xslt_ItemNull"));
				helper.Call(XmlILMethods.ThrowException);
				helper.MarkLabel(label);
			}
			iterCurr.Storage = StorageDescriptor.Stack(GetItemStorageType(ndInvoke), !ndInvoke.XmlType.IsSingleton);
			return ndInvoke;
		}

		protected override QilNode VisitXsltCopy(QilBinary ndCopy)
		{
			Label label = helper.DefineLabel();
			helper.LoadQueryOutput();
			NestedVisitEnsureStack(ndCopy.Left);
			helper.Call(XmlILMethods.StartCopy);
			helper.Emit(OpCodes.Brfalse, label);
			NestedVisit(ndCopy.Right);
			helper.LoadQueryOutput();
			NestedVisitEnsureStack(ndCopy.Left);
			helper.Call(XmlILMethods.EndCopy);
			helper.MarkLabel(label);
			iterCurr.Storage = StorageDescriptor.None();
			return ndCopy;
		}

		protected override QilNode VisitXsltCopyOf(QilUnary ndCopyOf)
		{
			helper.LoadQueryOutput();
			NestedVisitEnsureStack(ndCopyOf.Child);
			helper.Call(XmlILMethods.CopyOf);
			iterCurr.Storage = StorageDescriptor.None();
			return ndCopyOf;
		}

		protected override QilNode VisitXsltConvert(QilTargetType ndConv)
		{
			XmlQueryType xmlType = ndConv.Source.XmlType;
			XmlQueryType targetType = ndConv.TargetType;
			if (GetXsltConvertMethod(xmlType, targetType, out var meth))
			{
				NestedVisitEnsureStack(ndConv.Source);
			}
			else
			{
				NestedVisitEnsureStack(ndConv.Source, typeof(XPathItem), !xmlType.IsSingleton);
				GetXsltConvertMethod(xmlType.IsSingleton ? XmlQueryTypeFactory.Item : XmlQueryTypeFactory.ItemS, targetType, out meth);
			}
			if (meth != null)
			{
				helper.Call(meth);
			}
			iterCurr.Storage = StorageDescriptor.Stack(GetItemStorageType(targetType), !targetType.IsSingleton);
			return ndConv;
		}

		private bool GetXsltConvertMethod(XmlQueryType typSrc, XmlQueryType typDst, out MethodInfo meth)
		{
			meth = null;
			if (object.Equals(typDst, XmlQueryTypeFactory.BooleanX))
			{
				if (object.Equals(typSrc, XmlQueryTypeFactory.Item))
				{
					meth = XmlILMethods.ItemToBool;
				}
				else if (object.Equals(typSrc, XmlQueryTypeFactory.ItemS))
				{
					meth = XmlILMethods.ItemsToBool;
				}
			}
			else if (object.Equals(typDst, XmlQueryTypeFactory.DateTimeX))
			{
				if (object.Equals(typSrc, XmlQueryTypeFactory.StringX))
				{
					meth = XmlILMethods.StrToDT;
				}
			}
			else if (object.Equals(typDst, XmlQueryTypeFactory.DecimalX))
			{
				if (object.Equals(typSrc, XmlQueryTypeFactory.DoubleX))
				{
					meth = XmlILMethods.DblToDec;
				}
			}
			else if (object.Equals(typDst, XmlQueryTypeFactory.DoubleX))
			{
				if (object.Equals(typSrc, XmlQueryTypeFactory.DecimalX))
				{
					meth = XmlILMethods.DecToDbl;
				}
				else if (object.Equals(typSrc, XmlQueryTypeFactory.IntX))
				{
					meth = XmlILMethods.IntToDbl;
				}
				else if (object.Equals(typSrc, XmlQueryTypeFactory.Item))
				{
					meth = XmlILMethods.ItemToDbl;
				}
				else if (object.Equals(typSrc, XmlQueryTypeFactory.ItemS))
				{
					meth = XmlILMethods.ItemsToDbl;
				}
				else if (object.Equals(typSrc, XmlQueryTypeFactory.LongX))
				{
					meth = XmlILMethods.LngToDbl;
				}
				else if (object.Equals(typSrc, XmlQueryTypeFactory.StringX))
				{
					meth = XmlILMethods.StrToDbl;
				}
			}
			else if (object.Equals(typDst, XmlQueryTypeFactory.IntX))
			{
				if (object.Equals(typSrc, XmlQueryTypeFactory.DoubleX))
				{
					meth = XmlILMethods.DblToInt;
				}
			}
			else if (object.Equals(typDst, XmlQueryTypeFactory.LongX))
			{
				if (object.Equals(typSrc, XmlQueryTypeFactory.DoubleX))
				{
					meth = XmlILMethods.DblToLng;
				}
			}
			else if (object.Equals(typDst, XmlQueryTypeFactory.NodeNotRtf))
			{
				if (object.Equals(typSrc, XmlQueryTypeFactory.Item))
				{
					meth = XmlILMethods.ItemToNode;
				}
				else if (object.Equals(typSrc, XmlQueryTypeFactory.ItemS))
				{
					meth = XmlILMethods.ItemsToNode;
				}
			}
			else if (object.Equals(typDst, XmlQueryTypeFactory.NodeDodS) || object.Equals(typDst, XmlQueryTypeFactory.NodeNotRtfS))
			{
				if (object.Equals(typSrc, XmlQueryTypeFactory.Item))
				{
					meth = XmlILMethods.ItemToNodes;
				}
				else if (object.Equals(typSrc, XmlQueryTypeFactory.ItemS))
				{
					meth = XmlILMethods.ItemsToNodes;
				}
			}
			else if (object.Equals(typDst, XmlQueryTypeFactory.StringX))
			{
				if (object.Equals(typSrc, XmlQueryTypeFactory.DateTimeX))
				{
					meth = XmlILMethods.DTToStr;
				}
				else if (object.Equals(typSrc, XmlQueryTypeFactory.DoubleX))
				{
					meth = XmlILMethods.DblToStr;
				}
				else if (object.Equals(typSrc, XmlQueryTypeFactory.Item))
				{
					meth = XmlILMethods.ItemToStr;
				}
				else if (object.Equals(typSrc, XmlQueryTypeFactory.ItemS))
				{
					meth = XmlILMethods.ItemsToStr;
				}
			}
			if (meth == null)
			{
				return false;
			}
			return true;
		}

		private void SyncToNavigator(LocalBuilder locNav, QilNode ndCtxt)
		{
			helper.Emit(OpCodes.Ldloc, locNav);
			NestedVisitEnsureStack(ndCtxt);
			helper.CallSyncToNavigator();
			helper.Emit(OpCodes.Stloc, locNav);
		}

		private void CreateSimpleIterator(QilNode ndCtxt, string iterName, Type iterType, MethodInfo methCreate, MethodInfo methNext)
		{
			LocalBuilder localBuilder = helper.DeclareLocal(iterName, iterType);
			helper.Emit(OpCodes.Ldloca, localBuilder);
			NestedVisitEnsureStack(ndCtxt);
			helper.Call(methCreate);
			GenerateSimpleIterator(typeof(XPathNavigator), localBuilder, methNext);
		}

		private void CreateFilteredIterator(QilNode ndCtxt, string iterName, Type iterType, MethodInfo methCreate, MethodInfo methNext, XmlNodeKindFlags kinds, QilName ndName, TriState orSelf, QilNode ndEnd)
		{
			LocalBuilder localBuilder = helper.DeclareLocal(iterName, iterType);
			helper.Emit(OpCodes.Ldloca, localBuilder);
			NestedVisitEnsureStack(ndCtxt);
			LoadSelectFilter(kinds, ndName);
			if (orSelf != TriState.Unknown)
			{
				helper.LoadBoolean(orSelf == TriState.True);
			}
			if (ndEnd != null)
			{
				NestedVisitEnsureStack(ndEnd);
			}
			helper.Call(methCreate);
			GenerateSimpleIterator(typeof(XPathNavigator), localBuilder, methNext);
		}

		private void CreateContainerIterator(QilUnary ndDod, string iterName, Type iterType, MethodInfo methCreate, MethodInfo methNext, XmlNodeKindFlags kinds, QilName ndName, TriState orSelf)
		{
			LocalBuilder localBuilder = helper.DeclareLocal(iterName, iterType);
			QilLoop qilLoop = (QilLoop)ndDod.Child;
			helper.Emit(OpCodes.Ldloca, localBuilder);
			LoadSelectFilter(kinds, ndName);
			if (orSelf != TriState.Unknown)
			{
				helper.LoadBoolean(orSelf == TriState.True);
			}
			helper.Call(methCreate);
			Label label = helper.DefineLabel();
			StartNestedIterator(qilLoop, label);
			StartBinding(qilLoop.Variable);
			EndBinding(qilLoop.Variable);
			EndNestedIterator(qilLoop.Variable);
			iterCurr.Storage = iterNested.Storage;
			GenerateContainerIterator(ndDod, localBuilder, label, methNext, typeof(XPathNavigator));
		}

		private void GenerateSimpleIterator(Type itemStorageType, LocalBuilder locIter, MethodInfo methNext)
		{
			Label label = helper.DefineLabel();
			helper.MarkLabel(label);
			helper.Emit(OpCodes.Ldloca, locIter);
			helper.Call(methNext);
			helper.Emit(OpCodes.Brfalse, iterCurr.GetLabelNext());
			iterCurr.SetIterator(label, StorageDescriptor.Current(locIter, itemStorageType));
		}

		private void GenerateContainerIterator(QilNode nd, LocalBuilder locIter, Label lblOnEndNested, MethodInfo methNext, Type itemStorageType)
		{
			Label label = helper.DefineLabel();
			iterCurr.EnsureNoStackNoCache(nd.XmlType.IsNode ? "$$$navInput" : "$$$itemInput");
			helper.Emit(OpCodes.Ldloca, locIter);
			iterCurr.PushValue();
			helper.EmitUnconditionalBranch(OpCodes.Br, label);
			helper.MarkLabel(lblOnEndNested);
			helper.Emit(OpCodes.Ldloca, locIter);
			helper.Emit(OpCodes.Ldnull);
			helper.MarkLabel(label);
			helper.Call(methNext);
			if (nd.XmlType.IsSingleton)
			{
				helper.LoadInteger(1);
				helper.Emit(OpCodes.Beq, iterNested.GetLabelNext());
				iterCurr.Storage = StorageDescriptor.Current(locIter, itemStorageType);
			}
			else
			{
				helper.Emit(OpCodes.Switch, new Label[2]
				{
					iterCurr.GetLabelNext(),
					iterNested.GetLabelNext()
				});
				iterCurr.SetIterator(lblOnEndNested, StorageDescriptor.Current(locIter, itemStorageType));
			}
		}

		private GenerateNameType LoadNameAndType(XPathNodeType nodeType, QilNode ndName, bool isStart, bool callChk)
		{
			helper.LoadQueryOutput();
			GenerateNameType result = GenerateNameType.StackName;
			if (ndName.NodeType == QilNodeType.LiteralQName)
			{
				if (isStart || !callChk)
				{
					QilName qilName = ndName as QilName;
					string prefix = qilName.Prefix;
					string localName = qilName.LocalName;
					string namespaceUri = qilName.NamespaceUri;
					if (qilName.NamespaceUri.Length == 0)
					{
						helper.Emit(OpCodes.Ldstr, qilName.LocalName);
						return GenerateNameType.LiteralLocalName;
					}
					if (!ValidateNames.ValidateName(prefix, localName, namespaceUri, nodeType, ValidateNames.Flags.CheckPrefixMapping))
					{
						if (isStart)
						{
							helper.Emit(OpCodes.Ldstr, localName);
							helper.Emit(OpCodes.Ldstr, namespaceUri);
							helper.Construct(XmlILConstructors.QName);
							result = GenerateNameType.QName;
						}
					}
					else
					{
						helper.Emit(OpCodes.Ldstr, prefix);
						helper.Emit(OpCodes.Ldstr, localName);
						helper.Emit(OpCodes.Ldstr, namespaceUri);
						result = GenerateNameType.LiteralName;
					}
				}
			}
			else if (isStart)
			{
				if (ndName.NodeType == QilNodeType.NameOf)
				{
					NestedVisitEnsureStack((ndName as QilUnary).Child);
					result = GenerateNameType.CopiedName;
				}
				else if (ndName.NodeType == QilNodeType.StrParseQName)
				{
					VisitStrParseQName(ndName as QilBinary, preservePrefix: true);
					result = (((ndName as QilBinary).Right.XmlType.TypeCode != XmlTypeCode.String) ? GenerateNameType.TagNameAndMappings : GenerateNameType.TagNameAndNamespace);
				}
				else
				{
					NestedVisitEnsureStack(ndName);
					result = GenerateNameType.QName;
				}
			}
			return result;
		}

		private bool TryZeroCompare(QilNodeType relOp, QilNode ndFirst, QilNode ndSecond)
		{
			switch (ndFirst.NodeType)
			{
			case QilNodeType.LiteralInt64:
				if ((int)(QilLiteral)ndFirst != 0)
				{
					return false;
				}
				break;
			case QilNodeType.LiteralInt32:
				if ((int)(QilLiteral)ndFirst != 0)
				{
					return false;
				}
				break;
			case QilNodeType.True:
				relOp = ((relOp == QilNodeType.Eq) ? QilNodeType.Ne : QilNodeType.Eq);
				break;
			default:
				return false;
			case QilNodeType.False:
				break;
			}
			NestedVisitEnsureStack(ndSecond);
			ZeroCompare(relOp, ndSecond.XmlType.TypeCode == XmlTypeCode.Boolean);
			return true;
		}

		private bool TryNameCompare(QilNodeType relOp, QilNode ndFirst, QilNode ndSecond)
		{
			if (ndFirst.NodeType == QilNodeType.NameOf)
			{
				QilNodeType nodeType = ndSecond.NodeType;
				if (nodeType == QilNodeType.LiteralQName || nodeType == QilNodeType.NameOf)
				{
					helper.LoadQueryRuntime();
					NestedVisitEnsureStack((ndFirst as QilUnary).Child);
					if (ndSecond.NodeType == QilNodeType.LiteralQName)
					{
						QilName qilName = ndSecond as QilName;
						helper.LoadInteger(helper.StaticData.DeclareName(qilName.LocalName));
						helper.LoadInteger(helper.StaticData.DeclareName(qilName.NamespaceUri));
						helper.Call(XmlILMethods.QNameEqualLit);
					}
					else
					{
						NestedVisitEnsureStack(ndSecond);
						helper.Call(XmlILMethods.QNameEqualNav);
					}
					ZeroCompare((relOp == QilNodeType.Eq) ? QilNodeType.Ne : QilNodeType.Eq, isBoolVal: true);
					return true;
				}
			}
			return false;
		}

		private void ClrCompare(QilNodeType relOp, XmlTypeCode code)
		{
			switch (iterCurr.CurrentBranchingContext)
			{
			case BranchingContext.OnFalse:
			{
				OpCode opcode = ((code == XmlTypeCode.Double || code == XmlTypeCode.Float) ? (relOp switch
				{
					QilNodeType.Gt => OpCodes.Ble_Un, 
					QilNodeType.Ge => OpCodes.Blt_Un, 
					QilNodeType.Lt => OpCodes.Bge_Un, 
					QilNodeType.Le => OpCodes.Bgt_Un, 
					QilNodeType.Eq => OpCodes.Bne_Un, 
					QilNodeType.Ne => OpCodes.Beq, 
					_ => OpCodes.Nop, 
				}) : (relOp switch
				{
					QilNodeType.Gt => OpCodes.Ble, 
					QilNodeType.Ge => OpCodes.Blt, 
					QilNodeType.Lt => OpCodes.Bge, 
					QilNodeType.Le => OpCodes.Bgt, 
					QilNodeType.Eq => OpCodes.Bne_Un, 
					QilNodeType.Ne => OpCodes.Beq, 
					_ => OpCodes.Nop, 
				}));
				helper.Emit(opcode, iterCurr.LabelBranch);
				iterCurr.Storage = StorageDescriptor.None();
				return;
			}
			case BranchingContext.OnTrue:
			{
				OpCode opcode = relOp switch
				{
					QilNodeType.Gt => OpCodes.Bgt, 
					QilNodeType.Ge => OpCodes.Bge, 
					QilNodeType.Lt => OpCodes.Blt, 
					QilNodeType.Le => OpCodes.Ble, 
					QilNodeType.Eq => OpCodes.Beq, 
					QilNodeType.Ne => OpCodes.Bne_Un, 
					_ => OpCodes.Nop, 
				};
				helper.Emit(opcode, iterCurr.LabelBranch);
				iterCurr.Storage = StorageDescriptor.None();
				return;
			}
			}
			switch (relOp)
			{
			case QilNodeType.Gt:
				helper.Emit(OpCodes.Cgt);
				break;
			case QilNodeType.Lt:
				helper.Emit(OpCodes.Clt);
				break;
			case QilNodeType.Eq:
				helper.Emit(OpCodes.Ceq);
				break;
			default:
			{
				OpCode opcode = relOp switch
				{
					QilNodeType.Ge => OpCodes.Bge_S, 
					QilNodeType.Le => OpCodes.Ble_S, 
					QilNodeType.Ne => OpCodes.Bne_Un_S, 
					_ => OpCodes.Nop, 
				};
				Label label = helper.DefineLabel();
				helper.Emit(opcode, label);
				helper.ConvBranchToBool(label, isTrueBranch: true);
				break;
			}
			}
			iterCurr.Storage = StorageDescriptor.Stack(typeof(bool), isCached: false);
		}

		private void ZeroCompare(QilNodeType relOp, bool isBoolVal)
		{
			switch (iterCurr.CurrentBranchingContext)
			{
			case BranchingContext.OnTrue:
				helper.Emit((relOp == QilNodeType.Eq) ? OpCodes.Brfalse : OpCodes.Brtrue, iterCurr.LabelBranch);
				iterCurr.Storage = StorageDescriptor.None();
				return;
			case BranchingContext.OnFalse:
				helper.Emit((relOp == QilNodeType.Eq) ? OpCodes.Brtrue : OpCodes.Brfalse, iterCurr.LabelBranch);
				iterCurr.Storage = StorageDescriptor.None();
				return;
			}
			if (!isBoolVal || relOp == QilNodeType.Eq)
			{
				Label label = helper.DefineLabel();
				helper.Emit((relOp == QilNodeType.Eq) ? OpCodes.Brfalse : OpCodes.Brtrue, label);
				helper.ConvBranchToBool(label, isTrueBranch: true);
			}
			iterCurr.Storage = StorageDescriptor.Stack(typeof(bool), isCached: false);
		}

		private void StartWriterLoop(QilNode nd, out bool hasOnEnd, out Label lblOnEnd)
		{
			XmlILConstructInfo xmlILConstructInfo = XmlILConstructInfo.Read(nd);
			hasOnEnd = false;
			lblOnEnd = default(Label);
			if (xmlILConstructInfo.PushToWriterLast && !nd.XmlType.IsSingleton && !iterCurr.HasLabelNext)
			{
				hasOnEnd = true;
				lblOnEnd = helper.DefineLabel();
				iterCurr.SetIterator(lblOnEnd, StorageDescriptor.None());
			}
		}

		private void EndWriterLoop(QilNode nd, bool hasOnEnd, Label lblOnEnd)
		{
			XmlILConstructInfo xmlILConstructInfo = XmlILConstructInfo.Read(nd);
			if (xmlILConstructInfo.PushToWriterLast)
			{
				iterCurr.Storage = StorageDescriptor.None();
				if (!nd.XmlType.IsSingleton && hasOnEnd)
				{
					iterCurr.LoopToEnd(lblOnEnd);
				}
			}
		}

		private bool MightHaveNamespacesAfterAttributes(XmlILConstructInfo info)
		{
			if (info != null)
			{
				info = info.ParentElementInfo;
			}
			return info?.MightHaveNamespacesAfterAttributes ?? true;
		}

		private bool ElementCachesAttributes(XmlILConstructInfo info)
		{
			if (!info.MightHaveDuplicateAttributes)
			{
				return info.MightHaveNamespacesAfterAttributes;
			}
			return true;
		}

		private void BeforeStartChecks(QilNode ndCtor)
		{
			switch (XmlILConstructInfo.Read(ndCtor).InitialStates)
			{
			case PossibleXmlStates.WithinSequence:
				helper.CallStartTree(QilConstructorToNodeType(ndCtor.NodeType));
				break;
			case PossibleXmlStates.EnumAttrs:
				switch (ndCtor.NodeType)
				{
				case QilNodeType.ElementCtor:
				case QilNodeType.CommentCtor:
				case QilNodeType.PICtor:
				case QilNodeType.TextCtor:
				case QilNodeType.RawTextCtor:
					helper.CallStartElementContent();
					break;
				case QilNodeType.AttributeCtor:
					break;
				}
				break;
			}
		}

		private void AfterEndChecks(QilNode ndCtor)
		{
			if (XmlILConstructInfo.Read(ndCtor).FinalStates == PossibleXmlStates.WithinSequence)
			{
				helper.CallEndTree();
			}
		}

		private bool CheckWithinContent(XmlILConstructInfo info)
		{
			switch (info.InitialStates)
			{
			case PossibleXmlStates.WithinSequence:
			case PossibleXmlStates.EnumAttrs:
			case PossibleXmlStates.WithinContent:
				return false;
			default:
				return true;
			}
		}

		private bool CheckEnumAttrs(XmlILConstructInfo info)
		{
			switch (info.InitialStates)
			{
			case PossibleXmlStates.WithinSequence:
			case PossibleXmlStates.EnumAttrs:
				return false;
			default:
				return true;
			}
		}

		private XPathNodeType QilXmlToXPathNodeType(XmlNodeKindFlags xmlTypes)
		{
			return xmlTypes switch
			{
				XmlNodeKindFlags.Element => XPathNodeType.Element, 
				XmlNodeKindFlags.Attribute => XPathNodeType.Attribute, 
				XmlNodeKindFlags.Text => XPathNodeType.Text, 
				XmlNodeKindFlags.Comment => XPathNodeType.Comment, 
				_ => XPathNodeType.ProcessingInstruction, 
			};
		}

		private XPathNodeType QilConstructorToNodeType(QilNodeType typ)
		{
			return typ switch
			{
				QilNodeType.DocumentCtor => XPathNodeType.Root, 
				QilNodeType.ElementCtor => XPathNodeType.Element, 
				QilNodeType.TextCtor => XPathNodeType.Text, 
				QilNodeType.RawTextCtor => XPathNodeType.Text, 
				QilNodeType.PICtor => XPathNodeType.ProcessingInstruction, 
				QilNodeType.CommentCtor => XPathNodeType.Comment, 
				QilNodeType.AttributeCtor => XPathNodeType.Attribute, 
				QilNodeType.NamespaceDecl => XPathNodeType.Namespace, 
				_ => XPathNodeType.All, 
			};
		}

		private void LoadSelectFilter(XmlNodeKindFlags xmlTypes, QilName ndName)
		{
			if (ndName != null)
			{
				helper.CallGetNameFilter(helper.StaticData.DeclareNameFilter(ndName.LocalName, ndName.NamespaceUri));
			}
			else if (IsNodeTypeUnion(xmlTypes))
			{
				if ((xmlTypes & XmlNodeKindFlags.Attribute) != 0)
				{
					helper.CallGetTypeFilter(XPathNodeType.All);
				}
				else
				{
					helper.CallGetTypeFilter(XPathNodeType.Attribute);
				}
			}
			else
			{
				helper.CallGetTypeFilter(QilXmlToXPathNodeType(xmlTypes));
			}
		}

		private static bool IsNodeTypeUnion(XmlNodeKindFlags xmlTypes)
		{
			return (xmlTypes & (xmlTypes - 1)) != 0;
		}

		private void StartNestedIterator(QilNode nd)
		{
			IteratorDescriptor iteratorDescriptor = iterCurr;
			if (iteratorDescriptor == null)
			{
				iterCurr = new IteratorDescriptor(helper);
			}
			else
			{
				iterCurr = new IteratorDescriptor(iteratorDescriptor);
			}
			iterNested = null;
		}

		private void StartNestedIterator(QilNode nd, Label lblOnEnd)
		{
			StartNestedIterator(nd);
			iterCurr.SetIterator(lblOnEnd, StorageDescriptor.None());
		}

		private void EndNestedIterator(QilNode nd)
		{
			if (iterCurr.IsBranching && iterCurr.Storage.Location != 0)
			{
				iterCurr.EnsureItemStorageType(nd.XmlType, typeof(bool));
				iterCurr.EnsureStackNoCache();
				if (iterCurr.CurrentBranchingContext == BranchingContext.OnTrue)
				{
					helper.Emit(OpCodes.Brtrue, iterCurr.LabelBranch);
				}
				else
				{
					helper.Emit(OpCodes.Brfalse, iterCurr.LabelBranch);
				}
				iterCurr.Storage = StorageDescriptor.None();
			}
			iterNested = iterCurr;
			iterCurr = iterCurr.ParentIterator;
		}

		private void NestedVisit(QilNode nd, Type itemStorageType, bool isCached)
		{
			if (XmlILConstructInfo.Read(nd).PushToWriterLast)
			{
				StartNestedIterator(nd);
				Visit(nd);
				EndNestedIterator(nd);
				iterCurr.Storage = StorageDescriptor.None();
			}
			else if (!isCached && nd.XmlType.IsSingleton)
			{
				StartNestedIterator(nd);
				Visit(nd);
				iterCurr.EnsureNoCache();
				iterCurr.EnsureItemStorageType(nd.XmlType, itemStorageType);
				EndNestedIterator(nd);
				iterCurr.Storage = iterNested.Storage;
			}
			else
			{
				NestedVisitEnsureCache(nd, itemStorageType);
			}
		}

		private void NestedVisit(QilNode nd)
		{
			NestedVisit(nd, GetItemStorageType(nd), !nd.XmlType.IsSingleton);
		}

		private void NestedVisit(QilNode nd, Label lblOnEnd)
		{
			StartNestedIterator(nd, lblOnEnd);
			Visit(nd);
			iterCurr.EnsureNoCache();
			iterCurr.EnsureItemStorageType(nd.XmlType, GetItemStorageType(nd));
			EndNestedIterator(nd);
			iterCurr.Storage = iterNested.Storage;
		}

		private void NestedVisitEnsureStack(QilNode nd)
		{
			NestedVisit(nd);
			iterCurr.EnsureStack();
		}

		private void NestedVisitEnsureStack(QilNode ndLeft, QilNode ndRight)
		{
			NestedVisitEnsureStack(ndLeft);
			NestedVisitEnsureStack(ndRight);
		}

		private void NestedVisitEnsureStack(QilNode nd, Type itemStorageType, bool isCached)
		{
			NestedVisit(nd, itemStorageType, isCached);
			iterCurr.EnsureStack();
		}

		private void NestedVisitEnsureLocal(QilNode nd, LocalBuilder loc)
		{
			NestedVisit(nd);
			iterCurr.EnsureLocal(loc);
		}

		private void NestedVisitWithBranch(QilNode nd, BranchingContext brctxt, Label lblBranch)
		{
			StartNestedIterator(nd);
			iterCurr.SetBranching(brctxt, lblBranch);
			Visit(nd);
			EndNestedIterator(nd);
			iterCurr.Storage = StorageDescriptor.None();
		}

		private void NestedVisitEnsureCache(QilNode nd, Type itemStorageType)
		{
			bool flag = CachesResult(nd);
			Label lblOnEnd = helper.DefineLabel();
			if (flag)
			{
				StartNestedIterator(nd);
				Visit(nd);
				EndNestedIterator(nd);
				iterCurr.Storage = iterNested.Storage;
				if (iterCurr.Storage.ItemStorageType == itemStorageType)
				{
					return;
				}
				if (iterCurr.Storage.ItemStorageType == typeof(XPathNavigator) || itemStorageType == typeof(XPathNavigator))
				{
					iterCurr.EnsureItemStorageType(nd.XmlType, itemStorageType);
					return;
				}
				iterCurr.EnsureNoStack("$$$cacheResult");
			}
			Type type = ((GetItemStorageType(nd) == typeof(XPathNavigator)) ? typeof(XPathNavigator) : itemStorageType);
			XmlILStorageMethods xmlILStorageMethods = XmlILMethods.StorageMethods[type];
			LocalBuilder localBuilder = helper.DeclareLocal("$$$cache", xmlILStorageMethods.SeqType);
			helper.Emit(OpCodes.Ldloc, localBuilder);
			if (nd.XmlType.IsSingleton)
			{
				NestedVisitEnsureStack(nd, type, isCached: false);
				helper.CallToken(xmlILStorageMethods.SeqReuseSgl);
				helper.Emit(OpCodes.Stloc, localBuilder);
			}
			else
			{
				helper.CallToken(xmlILStorageMethods.SeqReuse);
				helper.Emit(OpCodes.Stloc, localBuilder);
				helper.Emit(OpCodes.Ldloc, localBuilder);
				StartNestedIterator(nd, lblOnEnd);
				if (flag)
				{
					iterCurr.Storage = iterCurr.ParentIterator.Storage;
				}
				else
				{
					Visit(nd);
				}
				iterCurr.EnsureItemStorageType(nd.XmlType, type);
				iterCurr.EnsureStackNoCache();
				helper.Call(xmlILStorageMethods.SeqAdd);
				helper.Emit(OpCodes.Ldloc, localBuilder);
				iterCurr.LoopToEnd(lblOnEnd);
				EndNestedIterator(nd);
				helper.Emit(OpCodes.Pop);
			}
			iterCurr.Storage = StorageDescriptor.Local(localBuilder, itemStorageType, isCached: true);
		}

		private bool CachesResult(QilNode nd)
		{
			switch (nd.NodeType)
			{
			case QilNodeType.Let:
			case QilNodeType.Parameter:
			case QilNodeType.Invoke:
			case QilNodeType.XsltInvokeLateBound:
			case QilNodeType.XsltInvokeEarlyBound:
				return !nd.XmlType.IsSingleton;
			case QilNodeType.Filter:
			{
				OptimizerPatterns optimizerPatterns = OptimizerPatterns.Read(nd);
				return optimizerPatterns.MatchesPattern(OptimizerPatternName.EqualityIndex);
			}
			case QilNodeType.DocOrderDistinct:
			{
				if (nd.XmlType.IsSingleton)
				{
					return false;
				}
				OptimizerPatterns optimizerPatterns = OptimizerPatterns.Read(nd);
				if (!optimizerPatterns.MatchesPattern(OptimizerPatternName.JoinAndDod))
				{
					return !optimizerPatterns.MatchesPattern(OptimizerPatternName.DodReverse);
				}
				return false;
			}
			case QilNodeType.TypeAssert:
			{
				QilTargetType qilTargetType = (QilTargetType)nd;
				if (CachesResult(qilTargetType.Source))
				{
					return GetItemStorageType(qilTargetType.Source) == GetItemStorageType(qilTargetType);
				}
				return false;
			}
			default:
				return false;
			}
		}

		private Type GetStorageType(QilNode nd)
		{
			return XmlILTypeHelper.GetStorageType(nd.XmlType);
		}

		private Type GetStorageType(XmlQueryType typ)
		{
			return XmlILTypeHelper.GetStorageType(typ);
		}

		private Type GetItemStorageType(QilNode nd)
		{
			return XmlILTypeHelper.GetStorageType(nd.XmlType.Prime);
		}

		private Type GetItemStorageType(XmlQueryType typ)
		{
			return XmlILTypeHelper.GetStorageType(typ.Prime);
		}
	}
	internal class XmlILAnnotation : ListBase<object>
	{
		private object annPrev;

		private MethodInfo funcMethod;

		private int argPos;

		private IteratorDescriptor iterInfo;

		private XmlILConstructInfo constrInfo;

		private OptimizerPatterns optPatt;

		public MethodInfo FunctionBinding
		{
			get
			{
				return funcMethod;
			}
			set
			{
				funcMethod = value;
			}
		}

		public int ArgumentPosition
		{
			get
			{
				return argPos;
			}
			set
			{
				argPos = value;
			}
		}

		public IteratorDescriptor CachedIteratorDescriptor
		{
			get
			{
				return iterInfo;
			}
			set
			{
				iterInfo = value;
			}
		}

		public XmlILConstructInfo ConstructInfo
		{
			get
			{
				return constrInfo;
			}
			set
			{
				constrInfo = value;
			}
		}

		public OptimizerPatterns Patterns
		{
			get
			{
				return optPatt;
			}
			set
			{
				optPatt = value;
			}
		}

		public override int Count
		{
			get
			{
				if (annPrev == null)
				{
					return 2;
				}
				return 3;
			}
		}

		public override object this[int index]
		{
			get
			{
				if (annPrev != null)
				{
					if (index == 0)
					{
						return annPrev;
					}
					index--;
				}
				return index switch
				{
					0 => constrInfo, 
					1 => optPatt, 
					_ => throw new IndexOutOfRangeException(), 
				};
			}
			set
			{
				throw new NotSupportedException();
			}
		}

		public static XmlILAnnotation Write(QilNode nd)
		{
			XmlILAnnotation xmlILAnnotation = nd.Annotation as XmlILAnnotation;
			if (xmlILAnnotation == null)
			{
				xmlILAnnotation = (XmlILAnnotation)(nd.Annotation = new XmlILAnnotation(nd.Annotation));
			}
			return xmlILAnnotation;
		}

		private XmlILAnnotation(object annPrev)
		{
			this.annPrev = annPrev;
		}
	}
	internal enum PossibleXmlStates
	{
		None,
		WithinSequence,
		EnumAttrs,
		WithinContent,
		WithinAttr,
		WithinComment,
		WithinPI,
		Any
	}
	internal enum XmlILConstructMethod
	{
		Iterator,
		Writer,
		WriterThenIterator,
		IteratorThenWriter
	}
	internal class XmlILConstructInfo : IQilAnnotation
	{
		private QilNodeType nodeType;

		private PossibleXmlStates xstatesInitial;

		private PossibleXmlStates xstatesFinal;

		private PossibleXmlStates xstatesBeginLoop;

		private PossibleXmlStates xstatesEndLoop;

		private bool isNmspInScope;

		private bool mightHaveNmsp;

		private bool mightHaveAttrs;

		private bool mightHaveDupAttrs;

		private bool mightHaveNmspAfterAttrs;

		private XmlILConstructMethod constrMeth;

		private XmlILConstructInfo parentInfo;

		private ArrayList callersInfo;

		private bool isReadOnly;

		private static XmlILConstructInfo Default;

		public PossibleXmlStates InitialStates
		{
			get
			{
				return xstatesInitial;
			}
			set
			{
				xstatesInitial = value;
			}
		}

		public PossibleXmlStates FinalStates
		{
			get
			{
				return xstatesFinal;
			}
			set
			{
				xstatesFinal = value;
			}
		}

		public PossibleXmlStates BeginLoopStates
		{
			set
			{
				xstatesBeginLoop = value;
			}
		}

		public PossibleXmlStates EndLoopStates
		{
			set
			{
				xstatesEndLoop = value;
			}
		}

		public XmlILConstructMethod ConstructMethod
		{
			get
			{
				return constrMeth;
			}
			set
			{
				constrMeth = value;
			}
		}

		public bool PushToWriterFirst
		{
			get
			{
				if (constrMeth != XmlILConstructMethod.Writer)
				{
					return constrMeth == XmlILConstructMethod.WriterThenIterator;
				}
				return true;
			}
			set
			{
				switch (constrMeth)
				{
				case XmlILConstructMethod.Iterator:
					constrMeth = XmlILConstructMethod.WriterThenIterator;
					break;
				case XmlILConstructMethod.IteratorThenWriter:
					constrMeth = XmlILConstructMethod.Writer;
					break;
				}
			}
		}

		public bool PushToWriterLast
		{
			get
			{
				if (constrMeth != XmlILConstructMethod.Writer)
				{
					return constrMeth == XmlILConstructMethod.IteratorThenWriter;
				}
				return true;
			}
			set
			{
				switch (constrMeth)
				{
				case XmlILConstructMethod.Iterator:
					constrMeth = XmlILConstructMethod.IteratorThenWriter;
					break;
				case XmlILConstructMethod.WriterThenIterator:
					constrMeth = XmlILConstructMethod.Writer;
					break;
				case XmlILConstructMethod.Writer:
					break;
				}
			}
		}

		public bool PullFromIteratorFirst
		{
			get
			{
				if (constrMeth != XmlILConstructMethod.IteratorThenWriter)
				{
					return constrMeth == XmlILConstructMethod.Iterator;
				}
				return true;
			}
			set
			{
				switch (constrMeth)
				{
				case XmlILConstructMethod.Writer:
					constrMeth = XmlILConstructMethod.IteratorThenWriter;
					break;
				case XmlILConstructMethod.WriterThenIterator:
					constrMeth = XmlILConstructMethod.Iterator;
					break;
				}
			}
		}

		public XmlILConstructInfo ParentInfo
		{
			set
			{
				parentInfo = value;
			}
		}

		public XmlILConstructInfo ParentElementInfo
		{
			get
			{
				if (parentInfo != null && parentInfo.nodeType == QilNodeType.ElementCtor)
				{
					return parentInfo;
				}
				return null;
			}
		}

		public bool IsNamespaceInScope
		{
			get
			{
				return isNmspInScope;
			}
			set
			{
				isNmspInScope = value;
			}
		}

		public bool MightHaveNamespaces
		{
			get
			{
				return mightHaveNmsp;
			}
			set
			{
				mightHaveNmsp = value;
			}
		}

		public bool MightHaveNamespacesAfterAttributes
		{
			get
			{
				return mightHaveNmspAfterAttrs;
			}
			set
			{
				mightHaveNmspAfterAttrs = value;
			}
		}

		public bool MightHaveAttributes
		{
			get
			{
				return mightHaveAttrs;
			}
			set
			{
				mightHaveAttrs = value;
			}
		}

		public bool MightHaveDuplicateAttributes
		{
			get
			{
				return mightHaveDupAttrs;
			}
			set
			{
				mightHaveDupAttrs = value;
			}
		}

		public ArrayList CallersInfo
		{
			get
			{
				if (callersInfo == null)
				{
					callersInfo = new ArrayList();
				}
				return callersInfo;
			}
		}

		public virtual string Name => "ConstructInfo";

		public static XmlILConstructInfo Read(QilNode nd)
		{
			XmlILConstructInfo xmlILConstructInfo = ((nd.Annotation is XmlILAnnotation xmlILAnnotation) ? xmlILAnnotation.ConstructInfo : null);
			if (xmlILConstructInfo == null)
			{
				if (Default == null)
				{
					xmlILConstructInfo = new XmlILConstructInfo(QilNodeType.Unknown);
					xmlILConstructInfo.isReadOnly = true;
					Default = xmlILConstructInfo;
				}
				else
				{
					xmlILConstructInfo = Default;
				}
			}
			return xmlILConstructInfo;
		}

		public static XmlILConstructInfo Write(QilNode nd)
		{
			XmlILAnnotation xmlILAnnotation = XmlILAnnotation.Write(nd);
			XmlILConstructInfo xmlILConstructInfo = xmlILAnnotation.ConstructInfo;
			if (xmlILConstructInfo == null || xmlILConstructInfo.isReadOnly)
			{
				xmlILConstructInfo = (xmlILAnnotation.ConstructInfo = new XmlILConstructInfo(nd.NodeType));
			}
			return xmlILConstructInfo;
		}

		private XmlILConstructInfo(QilNodeType nodeType)
		{
			this.nodeType = nodeType;
			xstatesInitial = (xstatesFinal = PossibleXmlStates.Any);
			xstatesBeginLoop = (xstatesEndLoop = PossibleXmlStates.None);
			isNmspInScope = false;
			mightHaveNmsp = true;
			mightHaveAttrs = true;
			mightHaveDupAttrs = true;
			mightHaveNmspAfterAttrs = true;
			constrMeth = XmlILConstructMethod.Iterator;
			parentInfo = null;
		}

		public override string ToString()
		{
			string text = "";
			if (constrMeth != 0)
			{
				text += constrMeth;
				text = text + ", " + xstatesInitial;
				if (xstatesBeginLoop != 0)
				{
					string text2 = text;
					text = text2 + " => " + xstatesBeginLoop.ToString() + " => " + xstatesEndLoop;
				}
				text = text + " => " + xstatesFinal;
				if (!MightHaveAttributes)
				{
					text += ", NoAttrs";
				}
				if (!MightHaveDuplicateAttributes)
				{
					text += ", NoDupAttrs";
				}
				if (!MightHaveNamespaces)
				{
					text += ", NoNmsp";
				}
				if (!MightHaveNamespacesAfterAttributes)
				{
					text += ", NoNmspAfterAttrs";
				}
			}
			return text;
		}
	}
	internal class XmlILStateAnalyzer
	{
		protected XmlILConstructInfo parentInfo;

		protected QilFactory fac;

		protected PossibleXmlStates xstates;

		protected bool withinElem;

		public XmlILStateAnalyzer(QilFactory fac)
		{
			this.fac = fac;
		}

		public virtual QilNode Analyze(QilNode ndConstr, QilNode ndContent)
		{
			if (ndConstr == null)
			{
				parentInfo = null;
				xstates = PossibleXmlStates.WithinSequence;
				withinElem = false;
				ndContent = AnalyzeContent(ndContent);
			}
			else
			{
				parentInfo = XmlILConstructInfo.Write(ndConstr);
				if (ndConstr.NodeType == QilNodeType.Function)
				{
					parentInfo.ConstructMethod = XmlILConstructMethod.Writer;
					PossibleXmlStates possibleXmlStates = PossibleXmlStates.None;
					foreach (XmlILConstructInfo item in parentInfo.CallersInfo)
					{
						if (possibleXmlStates == PossibleXmlStates.None)
						{
							possibleXmlStates = item.InitialStates;
						}
						else if (possibleXmlStates != item.InitialStates)
						{
							possibleXmlStates = PossibleXmlStates.Any;
						}
						item.PushToWriterFirst = true;
					}
					parentInfo.InitialStates = possibleXmlStates;
				}
				else
				{
					if (ndConstr.NodeType != QilNodeType.Choice)
					{
						PossibleXmlStates possibleXmlStates4 = (parentInfo.InitialStates = (parentInfo.FinalStates = PossibleXmlStates.WithinSequence));
					}
					if (ndConstr.NodeType != QilNodeType.RtfCtor)
					{
						parentInfo.ConstructMethod = XmlILConstructMethod.WriterThenIterator;
					}
				}
				withinElem = ndConstr.NodeType == QilNodeType.ElementCtor;
				switch (ndConstr.NodeType)
				{
				case QilNodeType.DocumentCtor:
					xstates = PossibleXmlStates.WithinContent;
					break;
				case QilNodeType.ElementCtor:
					xstates = PossibleXmlStates.EnumAttrs;
					break;
				case QilNodeType.AttributeCtor:
					xstates = PossibleXmlStates.WithinAttr;
					break;
				case QilNodeType.CommentCtor:
					xstates = PossibleXmlStates.WithinComment;
					break;
				case QilNodeType.PICtor:
					xstates = PossibleXmlStates.WithinPI;
					break;
				case QilNodeType.XsltCopy:
					xstates = PossibleXmlStates.Any;
					break;
				case QilNodeType.Function:
					xstates = parentInfo.InitialStates;
					break;
				case QilNodeType.RtfCtor:
					xstates = PossibleXmlStates.WithinContent;
					break;
				case QilNodeType.Choice:
					xstates = PossibleXmlStates.Any;
					break;
				}
				if (ndContent != null)
				{
					ndContent = AnalyzeContent(ndContent);
				}
				if (ndConstr.NodeType == QilNodeType.Choice)
				{
					AnalyzeChoice(ndConstr as QilChoice, parentInfo);
				}
				if (ndConstr.NodeType == QilNodeType.Function)
				{
					parentInfo.FinalStates = xstates;
				}
			}
			return ndContent;
		}

		protected virtual QilNode AnalyzeContent(QilNode nd)
		{
			switch (nd.NodeType)
			{
			case QilNodeType.For:
			case QilNodeType.Let:
			case QilNodeType.Parameter:
				nd = fac.Nop(nd);
				break;
			}
			XmlILConstructInfo xmlILConstructInfo = XmlILConstructInfo.Write(nd);
			xmlILConstructInfo.ParentInfo = parentInfo;
			xmlILConstructInfo.PushToWriterLast = true;
			xmlILConstructInfo.InitialStates = xstates;
			switch (nd.NodeType)
			{
			case QilNodeType.Loop:
				AnalyzeLoop(nd as QilLoop, xmlILConstructInfo);
				break;
			case QilNodeType.Sequence:
				AnalyzeSequence(nd as QilList, xmlILConstructInfo);
				break;
			case QilNodeType.Conditional:
				AnalyzeConditional(nd as QilTernary, xmlILConstructInfo);
				break;
			case QilNodeType.Choice:
				AnalyzeChoice(nd as QilChoice, xmlILConstructInfo);
				break;
			case QilNodeType.Error:
			case QilNodeType.Warning:
				xmlILConstructInfo.ConstructMethod = XmlILConstructMethod.Writer;
				break;
			case QilNodeType.Nop:
			{
				QilNode child = (nd as QilUnary).Child;
				switch (child.NodeType)
				{
				case QilNodeType.For:
				case QilNodeType.Let:
				case QilNodeType.Parameter:
					AnalyzeCopy(nd, xmlILConstructInfo);
					break;
				default:
					xmlILConstructInfo.ConstructMethod = XmlILConstructMethod.Writer;
					AnalyzeContent(child);
					break;
				}
				break;
			}
			default:
				AnalyzeCopy(nd, xmlILConstructInfo);
				break;
			}
			xmlILConstructInfo.FinalStates = xstates;
			return nd;
		}

		protected virtual void AnalyzeLoop(QilLoop ndLoop, XmlILConstructInfo info)
		{
			XmlQueryType xmlType = ndLoop.XmlType;
			info.ConstructMethod = XmlILConstructMethod.Writer;
			if (!xmlType.IsSingleton)
			{
				StartLoop(xmlType, info);
			}
			ndLoop.Body = AnalyzeContent(ndLoop.Body);
			if (!xmlType.IsSingleton)
			{
				EndLoop(xmlType, info);
			}
		}

		protected virtual void AnalyzeSequence(QilList ndSeq, XmlILConstructInfo info)
		{
			info.ConstructMethod = XmlILConstructMethod.Writer;
			for (int i = 0; i < ndSeq.Count; i++)
			{
				ndSeq[i] = AnalyzeContent(ndSeq[i]);
			}
		}

		protected virtual void AnalyzeConditional(QilTernary ndCond, XmlILConstructInfo info)
		{
			info.ConstructMethod = XmlILConstructMethod.Writer;
			ndCond.Center = AnalyzeContent(ndCond.Center);
			PossibleXmlStates possibleXmlStates = xstates;
			xstates = info.InitialStates;
			ndCond.Right = AnalyzeContent(ndCond.Right);
			if (possibleXmlStates != xstates)
			{
				xstates = PossibleXmlStates.Any;
			}
		}

		protected virtual void AnalyzeChoice(QilChoice ndChoice, XmlILConstructInfo info)
		{
			int num = ndChoice.Branches.Count - 1;
			ndChoice.Branches[num] = AnalyzeContent(ndChoice.Branches[num]);
			PossibleXmlStates possibleXmlStates = xstates;
			while (--num >= 0)
			{
				xstates = info.InitialStates;
				ndChoice.Branches[num] = AnalyzeContent(ndChoice.Branches[num]);
				if (possibleXmlStates != xstates)
				{
					possibleXmlStates = PossibleXmlStates.Any;
				}
			}
			xstates = possibleXmlStates;
		}

		protected virtual void AnalyzeCopy(QilNode ndCopy, XmlILConstructInfo info)
		{
			XmlQueryType xmlType = ndCopy.XmlType;
			if (!xmlType.IsSingleton)
			{
				StartLoop(xmlType, info);
			}
			if (MaybeContent(xmlType))
			{
				if (MaybeAttrNmsp(xmlType))
				{
					if (xstates == PossibleXmlStates.EnumAttrs)
					{
						xstates = PossibleXmlStates.Any;
					}
				}
				else if (xstates == PossibleXmlStates.EnumAttrs || withinElem)
				{
					xstates = PossibleXmlStates.WithinContent;
				}
			}
			if (!xmlType.IsSingleton)
			{
				EndLoop(xmlType, info);
			}
		}

		private void StartLoop(XmlQueryType typ, XmlILConstructInfo info)
		{
			info.BeginLoopStates = xstates;
			if (typ.MaybeMany && xstates == PossibleXmlStates.EnumAttrs && MaybeContent(typ))
			{
				info.BeginLoopStates = (xstates = PossibleXmlStates.Any);
			}
		}

		private void EndLoop(XmlQueryType typ, XmlILConstructInfo info)
		{
			info.EndLoopStates = xstates;
			if (typ.MaybeEmpty && info.InitialStates != xstates)
			{
				xstates = PossibleXmlStates.Any;
			}
		}

		private bool MaybeAttrNmsp(XmlQueryType typ)
		{
			return (typ.NodeKinds & (XmlNodeKindFlags.Attribute | XmlNodeKindFlags.Namespace)) != 0;
		}

		private bool MaybeContent(XmlQueryType typ)
		{
			if (typ.IsNode)
			{
				return (typ.NodeKinds & ~(XmlNodeKindFlags.Attribute | XmlNodeKindFlags.Namespace)) != 0;
			}
			return true;
		}
	}
	internal class XmlILElementAnalyzer : XmlILStateAnalyzer
	{
		private NameTable attrNames = new NameTable();

		private ArrayList dupAttrs = new ArrayList();

		public XmlILElementAnalyzer(QilFactory fac)
			: base(fac)
		{
		}

		public override QilNode Analyze(QilNode ndElem, QilNode ndContent)
		{
			parentInfo = XmlILConstructInfo.Write(ndElem);
			parentInfo.MightHaveNamespacesAfterAttributes = false;
			parentInfo.MightHaveAttributes = false;
			parentInfo.MightHaveDuplicateAttributes = false;
			parentInfo.MightHaveNamespaces = !parentInfo.IsNamespaceInScope;
			dupAttrs.Clear();
			return base.Analyze(ndElem, ndContent);
		}

		protected override void AnalyzeLoop(QilLoop ndLoop, XmlILConstructInfo info)
		{
			if (ndLoop.XmlType.MaybeMany)
			{
				CheckAttributeNamespaceConstruct(ndLoop.XmlType);
			}
			base.AnalyzeLoop(ndLoop, info);
		}

		protected override void AnalyzeCopy(QilNode ndCopy, XmlILConstructInfo info)
		{
			if (ndCopy.NodeType == QilNodeType.AttributeCtor)
			{
				AnalyzeAttributeCtor(ndCopy as QilBinary, info);
			}
			else
			{
				CheckAttributeNamespaceConstruct(ndCopy.XmlType);
			}
			base.AnalyzeCopy(ndCopy, info);
		}

		private void AnalyzeAttributeCtor(QilBinary ndAttr, XmlILConstructInfo info)
		{
			if (ndAttr.Left.NodeType == QilNodeType.LiteralQName)
			{
				QilName qilName = ndAttr.Left as QilName;
				parentInfo.MightHaveAttributes = true;
				if (!parentInfo.MightHaveDuplicateAttributes)
				{
					XmlQualifiedName xmlQualifiedName = new XmlQualifiedName(attrNames.Add(qilName.LocalName), attrNames.Add(qilName.NamespaceUri));
					int i;
					for (i = 0; i < dupAttrs.Count; i++)
					{
						XmlQualifiedName xmlQualifiedName2 = (XmlQualifiedName)dupAttrs[i];
						if ((object)xmlQualifiedName2.Name == xmlQualifiedName.Name && (object)xmlQualifiedName2.Namespace == xmlQualifiedName.Namespace)
						{
							parentInfo.MightHaveDuplicateAttributes = true;
						}
					}
					if (i >= dupAttrs.Count)
					{
						dupAttrs.Add(xmlQualifiedName);
					}
				}
				if (!info.IsNamespaceInScope)
				{
					parentInfo.MightHaveNamespaces = true;
				}
			}
			else
			{
				CheckAttributeNamespaceConstruct(ndAttr.XmlType);
			}
		}

		private void CheckAttributeNamespaceConstruct(XmlQueryType typ)
		{
			if ((typ.NodeKinds & XmlNodeKindFlags.Attribute) != 0)
			{
				parentInfo.MightHaveAttributes = true;
				parentInfo.MightHaveDuplicateAttributes = true;
				parentInfo.MightHaveNamespaces = true;
			}
			if ((typ.NodeKinds & XmlNodeKindFlags.Namespace) != 0)
			{
				parentInfo.MightHaveNamespaces = true;
				if (parentInfo.MightHaveAttributes)
				{
					parentInfo.MightHaveNamespacesAfterAttributes = true;
				}
			}
		}
	}
	internal class XmlILNamespaceAnalyzer
	{
		private XmlNamespaceManager nsmgr = new XmlNamespaceManager(new NameTable());

		private bool addInScopeNmsp;

		private int cntNmsp;

		public void Analyze(QilNode nd, bool defaultNmspInScope)
		{
			addInScopeNmsp = false;
			cntNmsp = 0;
			if (defaultNmspInScope)
			{
				nsmgr.PushScope();
				nsmgr.AddNamespace(string.Empty, string.Empty);
				cntNmsp++;
			}
			AnalyzeContent(nd);
			if (defaultNmspInScope)
			{
				nsmgr.PopScope();
			}
		}

		private void AnalyzeContent(QilNode nd)
		{
			switch (nd.NodeType)
			{
			case QilNodeType.Loop:
				addInScopeNmsp = false;
				AnalyzeContent((nd as QilLoop).Body);
				break;
			case QilNodeType.Sequence:
			{
				foreach (QilNode item in nd)
				{
					AnalyzeContent(item);
				}
				break;
			}
			case QilNodeType.Conditional:
				addInScopeNmsp = false;
				AnalyzeContent((nd as QilTernary).Center);
				AnalyzeContent((nd as QilTernary).Right);
				break;
			case QilNodeType.Choice:
			{
				addInScopeNmsp = false;
				QilList branches = (nd as QilChoice).Branches;
				for (int i = 0; i < branches.Count; i++)
				{
					AnalyzeContent(branches[i]);
				}
				break;
			}
			case QilNodeType.ElementCtor:
			{
				addInScopeNmsp = true;
				nsmgr.PushScope();
				int num = cntNmsp;
				if (CheckNamespaceInScope(nd as QilBinary))
				{
					AnalyzeContent((nd as QilBinary).Right);
				}
				nsmgr.PopScope();
				addInScopeNmsp = false;
				cntNmsp = num;
				break;
			}
			case QilNodeType.AttributeCtor:
				addInScopeNmsp = false;
				CheckNamespaceInScope(nd as QilBinary);
				break;
			case QilNodeType.NamespaceDecl:
				CheckNamespaceInScope(nd as QilBinary);
				break;
			case QilNodeType.Nop:
				AnalyzeContent((nd as QilUnary).Child);
				break;
			default:
				addInScopeNmsp = false;
				break;
			}
		}

		private bool CheckNamespaceInScope(QilBinary nd)
		{
			XPathNodeType nodeKind;
			string text;
			string text2;
			switch (nd.NodeType)
			{
			case QilNodeType.ElementCtor:
			case QilNodeType.AttributeCtor:
				if (nd.Left is QilName qilName)
				{
					text = qilName.Prefix;
					text2 = qilName.NamespaceUri;
					nodeKind = ((nd.NodeType == QilNodeType.ElementCtor) ? XPathNodeType.Element : XPathNodeType.Attribute);
					break;
				}
				return false;
			default:
				text = (QilLiteral)nd.Left;
				text2 = (QilLiteral)nd.Right;
				nodeKind = XPathNodeType.Namespace;
				break;
			}
			if ((nd.NodeType == QilNodeType.AttributeCtor && text2.Length == 0) || (text == "xml" && text2 == "http://www.w3.org/XML/1998/namespace"))
			{
				XmlILConstructInfo.Write(nd).IsNamespaceInScope = true;
				return true;
			}
			if (!ValidateNames.ValidateName(text, string.Empty, text2, nodeKind, ValidateNames.Flags.CheckPrefixMapping))
			{
				return false;
			}
			text = nsmgr.NameTable.Add(text);
			text2 = nsmgr.NameTable.Add(text2);
			for (int i = 0; i < cntNmsp; i++)
			{
				nsmgr.GetNamespaceDeclaration(i, out var prefix, out var uri);
				if ((object)text == prefix)
				{
					if ((object)text2 == uri)
					{
						XmlILConstructInfo.Write(nd).IsNamespaceInScope = true;
					}
					break;
				}
			}
			if (addInScopeNmsp)
			{
				nsmgr.AddNamespace(text, text2);
				cntNmsp++;
			}
			return true;
		}
	}
	internal enum XmlILMethodAttributes
	{
		None,
		NonUser,
		Raw
	}
	internal class XmlILModule
	{
		private const string RuntimeName = "{urn:schemas-microsoft-com:xslt-debug}runtime";

		public static readonly PermissionSet CreateModulePermissionSet;

		private static long AssemblyId;

		private static ModuleBuilder LREModule;

		private TypeBuilder typeBldr;

		private Hashtable methods;

		private Hashtable urlToSymWriter;

		private string modFile;

		private bool persistAsm;

		private bool useLRE;

		private bool emitSymbols;

		private static readonly Guid LanguageGuid;

		private static readonly Guid VendorGuid;

		static XmlILModule()
		{
			LanguageGuid = new Guid(1177373246u, 45655, 19182, 151, 205, 89, 24, 199, 83, 23, 88);
			VendorGuid = new Guid(2571847108u, 59113, 4562, 144, 63, 0, 192, 79, 163, 2, 161);
			CreateModulePermissionSet = new PermissionSet(PermissionState.None);
			CreateModulePermissionSet.AddPermission(new ReflectionPermission(ReflectionPermissionFlag.ReflectionEmit));
			CreateModulePermissionSet.AddPermission(new ReflectionPermission(ReflectionPermissionFlag.MemberAccess));
			CreateModulePermissionSet.AddPermission(new SecurityPermission(SecurityPermissionFlag.ControlEvidence));
			AssemblyId = 0L;
			AssemblyName name = CreateAssemblyName();
			AssemblyBuilder assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(name, AssemblyBuilderAccess.Run);
			try
			{
				CreateModulePermissionSet.Assert();
				assemblyBuilder.SetCustomAttribute(new CustomAttributeBuilder(XmlILConstructors.Transparent, new object[0]));
				LREModule = assemblyBuilder.DefineDynamicModule("System.Xml.Xsl.CompiledQuery", emitSymbolInfo: false);
			}
			finally
			{
				CodeAccessPermission.RevertAssert();
			}
		}

		public XmlILModule(TypeBuilder typeBldr)
		{
			this.typeBldr = typeBldr;
			emitSymbols = ((ModuleBuilder)this.typeBldr.Module).GetSymWriter() != null;
			useLRE = false;
			persistAsm = false;
			methods = new Hashtable();
			if (emitSymbols)
			{
				urlToSymWriter = new Hashtable();
			}
		}

		public XmlILModule(bool useLRE, bool emitSymbols)
		{
			this.useLRE = useLRE;
			this.emitSymbols = emitSymbols;
			persistAsm = false;
			methods = new Hashtable();
			if (!useLRE)
			{
				AssemblyName name = CreateAssemblyName();
				if (XmlILTrace.IsEnabled)
				{
					modFile = "System.Xml.Xsl.CompiledQuery";
					persistAsm = true;
				}
				AssemblyBuilder assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(name, (!persistAsm) ? AssemblyBuilderAccess.Run : AssemblyBuilderAccess.RunAndSave);
				assemblyBuilder.SetCustomAttribute(new CustomAttributeBuilder(XmlILConstructors.Transparent, new object[0]));
				if (emitSymbols)
				{
					urlToSymWriter = new Hashtable();
					DebuggableAttribute.DebuggingModes debuggingModes = DebuggableAttribute.DebuggingModes.Default | DebuggableAttribute.DebuggingModes.DisableOptimizations | DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints;
					assemblyBuilder.SetCustomAttribute(new CustomAttributeBuilder(XmlILConstructors.Debuggable, new object[1] { debuggingModes }));
				}
				typeBldr = ((!persistAsm) ? assemblyBuilder.DefineDynamicModule("System.Xml.Xsl.CompiledQuery", emitSymbols) : assemblyBuilder.DefineDynamicModule("System.Xml.Xsl.CompiledQuery", modFile + ".dll", emitSymbols)).DefineType("System.Xml.Xsl.CompiledQuery.Query", TypeAttributes.Public);
			}
		}

		public MethodInfo DefineMethod(string name, Type returnType, Type[] paramTypes, string[] paramNames, XmlILMethodAttributes xmlAttrs)
		{
			int num = 1;
			string text = name;
			bool flag = (xmlAttrs & XmlILMethodAttributes.Raw) != 0;
			while (methods[name] != null)
			{
				num++;
				name = text + " (" + num + ")";
			}
			if (!flag)
			{
				Type[] array = new Type[paramTypes.Length + 1];
				array[0] = typeof(XmlQueryRuntime);
				Array.Copy(paramTypes, 0, array, 1, paramTypes.Length);
				paramTypes = array;
			}
			MethodInfo methodInfo;
			if (!useLRE)
			{
				MethodBuilder methodBuilder = typeBldr.DefineMethod(name, MethodAttributes.Private | MethodAttributes.Static, returnType, paramTypes);
				if (emitSymbols && (xmlAttrs & XmlILMethodAttributes.NonUser) != 0)
				{
					methodBuilder.SetCustomAttribute(new CustomAttributeBuilder(XmlILConstructors.StepThrough, new object[0]));
					methodBuilder.SetCustomAttribute(new CustomAttributeBuilder(XmlILConstructors.NonUserCode, new object[0]));
				}
				if (!flag)
				{
					methodBuilder.DefineParameter(1, ParameterAttributes.None, "{urn:schemas-microsoft-com:xslt-debug}runtime");
				}
				for (int i = 0; i < paramNames.Length; i++)
				{
					if (paramNames[i] != null && paramNames[i].Length != 0)
					{
						methodBuilder.DefineParameter(i + (flag ? 1 : 2), ParameterAttributes.None, paramNames[i]);
					}
				}
				methodInfo = methodBuilder;
			}
			else
			{
				DynamicMethod dynamicMethod = new DynamicMethod(name, returnType, paramTypes, LREModule);
				dynamicMethod.InitLocals = true;
				if (!flag)
				{
					dynamicMethod.DefineParameter(1, ParameterAttributes.None, "{urn:schemas-microsoft-com:xslt-debug}runtime");
				}
				for (int j = 0; j < paramNames.Length; j++)
				{
					if (paramNames[j] != null && paramNames[j].Length != 0)
					{
						dynamicMethod.DefineParameter(j + (flag ? 1 : 2), ParameterAttributes.None, paramNames[j]);
					}
				}
				methodInfo = dynamicMethod;
			}
			methods[name] = methodInfo;
			return methodInfo;
		}

		public static ILGenerator DefineMethodBody(MethodBase methInfo)
		{
			if (methInfo is DynamicMethod dynamicMethod)
			{
				return dynamicMethod.GetILGenerator();
			}
			if (methInfo is MethodBuilder methodBuilder)
			{
				return methodBuilder.GetILGenerator();
			}
			return ((ConstructorBuilder)methInfo).GetILGenerator();
		}

		public MethodInfo FindMethod(string name)
		{
			return (MethodInfo)methods[name];
		}

		public FieldInfo DefineInitializedData(string name, byte[] data)
		{
			return typeBldr.DefineInitializedData(name, data, FieldAttributes.Private | FieldAttributes.Static);
		}

		public FieldInfo DefineField(string fieldName, Type type)
		{
			return typeBldr.DefineField(fieldName, type, FieldAttributes.Private | FieldAttributes.Static);
		}

		public ConstructorInfo DefineTypeInitializer()
		{
			return typeBldr.DefineTypeInitializer();
		}

		public ISymbolDocumentWriter AddSourceDocument(string fileName)
		{
			ISymbolDocumentWriter symbolDocumentWriter = urlToSymWriter[fileName] as ISymbolDocumentWriter;
			if (symbolDocumentWriter == null)
			{
				symbolDocumentWriter = ((ModuleBuilder)typeBldr.Module).DefineDocument(fileName, LanguageGuid, VendorGuid, Guid.Empty);
				urlToSymWriter.Add(fileName, symbolDocumentWriter);
			}
			return symbolDocumentWriter;
		}

		public void BakeMethods()
		{
			if (useLRE)
			{
				return;
			}
			Type type = typeBldr.CreateType();
			if (persistAsm)
			{
				((AssemblyBuilder)typeBldr.Module.Assembly).Save(modFile + ".dll");
			}
			Hashtable hashtable = new Hashtable(methods.Count);
			foreach (string key in methods.Keys)
			{
				hashtable[key] = type.GetMethod(key, BindingFlags.Static | BindingFlags.NonPublic);
			}
			methods = hashtable;
			typeBldr = null;
			urlToSymWriter = null;
		}

		public Delegate CreateDelegate(string name, Type typDelegate)
		{
			if (!useLRE)
			{
				return Delegate.CreateDelegate(typDelegate, (MethodInfo)methods[name]);
			}
			return ((DynamicMethod)methods[name]).CreateDelegate(typDelegate);
		}

		private static AssemblyName CreateAssemblyName()
		{
			Interlocked.Increment(ref AssemblyId);
			AssemblyName assemblyName = new AssemblyName();
			assemblyName.Name = "System.Xml.Xsl.CompiledQuery." + AssemblyId;
			return assemblyName;
		}
	}
	internal enum XmlILOptimization
	{
		None,
		FoldConstant,
		TailCall,
		AnnotateAncestor,
		AnnotateAncestorSelf,
		AnnotateAttribute,
		AnnotateAttrNmspLoop,
		AnnotateBarrier,
		AnnotateConstruction,
		AnnotateContent,
		AnnotateContentLoop,
		AnnotateDescendant,
		AnnotateDescendantLoop,
		AnnotateDescendantSelf,
		AnnotateDifference,
		AnnotateDod,
		AnnotateDodMerge,
		AnnotateDodReverse,
		AnnotateFilter,
		AnnotateFilterAttributeKind,
		AnnotateFilterContentKind,
		AnnotateFilterElements,
		AnnotateFollowingSibling,
		AnnotateIndex1,
		AnnotateIndex2,
		AnnotateIntersect,
		AnnotateInvoke,
		AnnotateJoinAndDod,
		AnnotateLet,
		AnnotateMaxLengthEq,
		AnnotateMaxLengthGe,
		AnnotateMaxLengthGt,
		AnnotateMaxLengthLe,
		AnnotateMaxLengthLt,
		AnnotateMaxLengthNe,
		AnnotateMaxPositionEq,
		AnnotateMaxPositionLe,
		AnnotateMaxPositionLt,
		AnnotateNamespace,
		AnnotateNodeRange,
		AnnotateParent,
		AnnotatePositionalIterator,
		AnnotatePreceding,
		AnnotatePrecedingSibling,
		AnnotateRoot,
		AnnotateRootLoop,
		AnnotateSingleTextRtf,
		AnnotateSingletonLoop,
		AnnotateTrackCallers,
		AnnotateUnion,
		AnnotateUnionContent,
		AnnotateXPathFollowing,
		AnnotateXPathPreceding,
		CommuteDodFilter,
		CommuteFilterLoop,
		EliminateAdd,
		EliminateAfter,
		EliminateAnd,
		EliminateAverage,
		EliminateBefore,
		EliminateConditional,
		EliminateDifference,
		EliminateDivide,
		EliminateDod,
		EliminateEq,
		EliminateFilter,
		EliminateGe,
		EliminateGt,
		EliminateIntersection,
		EliminateIs,
		EliminateIsEmpty,
		EliminateIsType,
		EliminateIterator,
		EliminateIteratorUsedAtMostOnce,
		EliminateLe,
		EliminateLength,
		EliminateLoop,
		EliminateLt,
		EliminateMaximum,
		EliminateMinimum,
		EliminateModulo,
		EliminateMultiply,
		EliminateNamespaceDecl,
		EliminateNe,
		EliminateNegate,
		EliminateNop,
		EliminateNot,
		EliminateOr,
		EliminatePositionOf,
		EliminateReturnDod,
		EliminateSequence,
		EliminateSort,
		EliminateStrConcat,
		EliminateStrConcatSingle,
		EliminateStrLength,
		EliminateSubtract,
		EliminateSum,
		EliminateTypeAssert,
		EliminateTypeAssertOptional,
		EliminateUnion,
		EliminateUnusedFunctions,
		EliminateXsltConvert,
		FoldConditionalNot,
		FoldNamedDescendants,
		FoldNone,
		FoldXsltConvertLiteral,
		IntroduceDod,
		IntroducePrecedingDod,
		NormalizeAddEq,
		NormalizeAddLiteral,
		NormalizeAttribute,
		NormalizeConditionalText,
		NormalizeDifference,
		NormalizeEqLiteral,
		NormalizeGeLiteral,
		NormalizeGtLiteral,
		NormalizeIdEq,
		NormalizeIdNe,
		NormalizeIntersect,
		NormalizeInvokeEmpty,
		NormalizeLeLiteral,
		NormalizeLengthGt,
		NormalizeLengthNe,
		NormalizeLoopConditional,
		NormalizeLoopInvariant,
		NormalizeLoopLoop,
		NormalizeLoopText,
		NormalizeLtLiteral,
		NormalizeMuenchian,
		NormalizeMultiplyLiteral,
		NormalizeNeLiteral,
		NormalizeNestedSequences,
		NormalizeSingletonLet,
		NormalizeSortXsltConvert,
		NormalizeUnion,
		NormalizeXsltConvertEq,
		NormalizeXsltConvertGe,
		NormalizeXsltConvertGt,
		NormalizeXsltConvertLe,
		NormalizeXsltConvertLt,
		NormalizeXsltConvertNe,
		Last_
	}
}
namespace System.Xml.Xsl.Qil
{
	internal abstract class QilReplaceVisitor : QilVisitor
	{
		protected QilFactory f;

		public QilReplaceVisitor(QilFactory f)
		{
			this.f = f;
		}

		protected override QilNode VisitChildren(QilNode parent)
		{
			XmlQueryType xmlType = parent.XmlType;
			bool flag = false;
			for (int i = 0; i < parent.Count; i++)
			{
				QilNode qilNode = parent[i];
				XmlQueryType objA = qilNode?.XmlType;
				QilNode qilNode2 = ((!IsReference(parent, i)) ? Visit(qilNode) : VisitReference(qilNode));
				if (!object.Equals(qilNode, qilNode2) || (qilNode2 != null && !object.Equals(objA, qilNode2.XmlType)))
				{
					flag = true;
					parent[i] = qilNode2;
				}
			}
			if (flag)
			{
				RecalculateType(parent, xmlType);
			}
			return parent;
		}

		protected virtual void RecalculateType(QilNode node, XmlQueryType oldType)
		{
			XmlQueryType xmlQueryType2 = (node.XmlType = f.TypeChecker.Check(node));
		}
	}
	internal abstract class QilPatternVisitor : QilReplaceVisitor
	{
		internal sealed class QilPatterns
		{
			private BitArray bits;

			private QilPatterns(QilPatterns toCopy)
			{
				bits = new BitArray(toCopy.bits);
			}

			public QilPatterns(int szBits, bool allSet)
			{
				bits = new BitArray(szBits, allSet);
			}

			public QilPatterns Clone()
			{
				return new QilPatterns(this);
			}

			public void ClearAll()
			{
				bits.SetAll(value: false);
			}

			public void Add(int i)
			{
				bits.Set(i, value: true);
			}

			public bool IsSet(int i)
			{
				return bits[i];
			}
		}

		private QilPatterns patterns;

		private int replacementCnt;

		private int lastReplacement;

		private int threshold = int.MaxValue;

		public QilPatterns Patterns
		{
			get
			{
				return patterns;
			}
			set
			{
				patterns = value;
			}
		}

		public int Threshold
		{
			get
			{
				return threshold;
			}
			set
			{
				threshold = value;
			}
		}

		public int ReplacementCount => replacementCnt;

		public int LastReplacement => lastReplacement;

		public bool Matching => ReplacementCount < Threshold;

		public QilPatternVisitor(QilPatterns patterns, QilFactory f)
			: base(f)
		{
			Patterns = patterns;
		}

		protected virtual bool AllowReplace(int pattern, QilNode original)
		{
			if (Matching)
			{
				replacementCnt++;
				lastReplacement = pattern;
				return true;
			}
			return false;
		}

		protected virtual QilNode Replace(int pattern, QilNode original, QilNode replacement)
		{
			replacement.SourceLine = original.SourceLine;
			return replacement;
		}

		protected virtual QilNode NoReplace(QilNode node)
		{
			return node;
		}

		protected override QilNode Visit(QilNode node)
		{
			if (node == null)
			{
				return VisitNull();
			}
			node = VisitChildren(node);
			return base.Visit(node);
		}

		protected override QilNode VisitQilExpression(QilExpression n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitFunctionList(QilList n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitGlobalVariableList(QilList n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitGlobalParameterList(QilList n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitActualParameterList(QilList n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitFormalParameterList(QilList n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitSortKeyList(QilList n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitBranchList(QilList n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitOptimizeBarrier(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitUnknown(QilNode n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitDataSource(QilDataSource n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitNop(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitError(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitWarning(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitFor(QilIterator n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitForReference(QilIterator n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitLet(QilIterator n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitLetReference(QilIterator n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitParameter(QilParameter n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitParameterReference(QilParameter n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitPositionOf(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitTrue(QilNode n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitFalse(QilNode n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitLiteralString(QilLiteral n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitLiteralInt32(QilLiteral n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitLiteralInt64(QilLiteral n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitLiteralDouble(QilLiteral n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitLiteralDecimal(QilLiteral n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitLiteralQName(QilName n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitLiteralType(QilLiteral n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitLiteralObject(QilLiteral n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitAnd(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitOr(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitNot(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitConditional(QilTernary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitChoice(QilChoice n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitLength(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitSequence(QilList n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitUnion(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitIntersection(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitDifference(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitAverage(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitSum(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitMinimum(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitMaximum(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitNegate(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitAdd(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitSubtract(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitMultiply(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitDivide(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitModulo(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitStrLength(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitStrConcat(QilStrConcat n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitStrParseQName(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitNe(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitEq(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitGt(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitGe(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitLt(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitLe(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitIs(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitAfter(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitBefore(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitLoop(QilLoop n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitFilter(QilLoop n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitSort(QilLoop n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitSortKey(QilSortKey n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitDocOrderDistinct(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitFunction(QilFunction n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitFunctionReference(QilFunction n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitInvoke(QilInvoke n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitContent(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitAttribute(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitParent(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitRoot(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitXmlContext(QilNode n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitDescendant(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitDescendantOrSelf(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitAncestor(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitAncestorOrSelf(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitPreceding(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitFollowingSibling(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitPrecedingSibling(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitNodeRange(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitDeref(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitElementCtor(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitAttributeCtor(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitCommentCtor(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitPICtor(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitTextCtor(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitRawTextCtor(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitDocumentCtor(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitNamespaceDecl(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitRtfCtor(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitNameOf(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitLocalNameOf(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitNamespaceUriOf(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitPrefixOf(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitTypeAssert(QilTargetType n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitIsType(QilTargetType n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitIsEmpty(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitXPathNodeValue(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitXPathFollowing(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitXPathPreceding(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitXPathNamespace(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitXsltGenerateId(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitXsltInvokeLateBound(QilInvokeLateBound n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitXsltInvokeEarlyBound(QilInvokeEarlyBound n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitXsltCopy(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitXsltCopyOf(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitXsltConvert(QilTargetType n)
		{
			return NoReplace(n);
		}
	}
}
namespace System.Xml.Xsl.IlGen
{
	internal class XmlILOptimizerVisitor : QilPatternVisitor
	{
		private class NodeCounter : QilVisitor
		{
			protected QilNode target;

			protected int cnt;

			public int Count(QilNode expr, QilNode target)
			{
				cnt = 0;
				this.target = target;
				Visit(expr);
				return cnt;
			}

			protected override QilNode Visit(QilNode n)
			{
				if (n == null)
				{
					return null;
				}
				if (n == target)
				{
					cnt++;
				}
				return VisitChildren(n);
			}

			protected override QilNode VisitReference(QilNode n)
			{
				if (n == target)
				{
					cnt++;
				}
				return n;
			}
		}

		private class NodeFinder : QilVisitor
		{
			protected bool result;

			protected QilNode target;

			protected QilNode parent;

			public bool Find(QilNode expr, QilNode target)
			{
				result = false;
				this.target = target;
				parent = null;
				VisitAssumeReference(expr);
				return result;
			}

			protected override QilNode Visit(QilNode expr)
			{
				if (!result)
				{
					if (expr == target)
					{
						result = OnFound(expr);
					}
					if (!result)
					{
						QilNode qilNode = parent;
						parent = expr;
						VisitChildren(expr);
						parent = qilNode;
					}
				}
				return expr;
			}

			protected override QilNode VisitReference(QilNode expr)
			{
				if (expr == target)
				{
					result = OnFound(expr);
				}
				return expr;
			}

			protected virtual bool OnFound(QilNode expr)
			{
				return true;
			}
		}

		private class PositionOfFinder : NodeFinder
		{
			protected override bool OnFound(QilNode expr)
			{
				if (parent != null)
				{
					return parent.NodeType == QilNodeType.PositionOf;
				}
				return false;
			}
		}

		private class EqualityIndexVisitor : QilVisitor
		{
			protected bool result;

			protected QilNode ctxt;

			protected QilNode key;

			public bool Scan(QilNode expr, QilNode ctxt, QilNode key)
			{
				result = true;
				this.ctxt = ctxt;
				this.key = key;
				Visit(expr);
				return result;
			}

			protected override QilNode VisitReference(QilNode expr)
			{
				if (result && (expr == key || expr == ctxt))
				{
					result = false;
					return expr;
				}
				return expr;
			}

			protected override QilNode VisitRoot(QilUnary root)
			{
				if (root.Child == ctxt)
				{
					return root;
				}
				return VisitChildren(root);
			}
		}

		private static readonly QilPatterns PatternsNoOpt;

		private static readonly QilPatterns PatternsOpt;

		private QilExpression qil;

		private XmlILElementAnalyzer elemAnalyzer;

		private XmlILStateAnalyzer contentAnalyzer;

		private XmlILNamespaceAnalyzer nmspAnalyzer;

		private NodeCounter nodeCounter = new NodeCounter();

		private SubstitutionList subs = new SubstitutionList();

		private bool this[XmlILOptimization ann] => base.Patterns.IsSet((int)ann);

		static XmlILOptimizerVisitor()
		{
			PatternsOpt = new QilPatterns(141, allSet: true);
			PatternsNoOpt = new QilPatterns(141, allSet: false);
			PatternsNoOpt.Add(104);
			PatternsNoOpt.Add(88);
			PatternsNoOpt.Add(97);
			PatternsNoOpt.Add(71);
			PatternsNoOpt.Add(70);
			PatternsNoOpt.Add(58);
			PatternsNoOpt.Add(96);
			PatternsNoOpt.Add(79);
			PatternsNoOpt.Add(78);
			PatternsNoOpt.Add(91);
			PatternsNoOpt.Add(93);
			PatternsNoOpt.Add(134);
			PatternsNoOpt.Add(118);
			PatternsNoOpt.Add(112);
			PatternsNoOpt.Add(41);
			PatternsNoOpt.Add(48);
			PatternsNoOpt.Add(15);
			PatternsNoOpt.Add(8);
			PatternsNoOpt.Add(23);
			PatternsNoOpt.Add(24);
			PatternsNoOpt.Add(7);
			PatternsNoOpt.Add(18);
		}

		public XmlILOptimizerVisitor(QilExpression qil, bool optimize)
			: base(optimize ? PatternsOpt : PatternsNoOpt, qil.Factory)
		{
			this.qil = qil;
			elemAnalyzer = new XmlILElementAnalyzer(qil.Factory);
			contentAnalyzer = new XmlILStateAnalyzer(qil.Factory);
			nmspAnalyzer = new XmlILNamespaceAnalyzer();
		}

		public QilExpression Optimize()
		{
			QilExpression result = (QilExpression)Visit(qil);
			if (this[XmlILOptimization.TailCall])
			{
				TailCallAnalyzer.Analyze(result);
			}
			return result;
		}

		protected override QilNode Visit(QilNode nd)
		{
			if (nd != null && this[XmlILOptimization.EliminateNamespaceDecl])
			{
				switch (nd.NodeType)
				{
				case QilNodeType.QilExpression:
					nmspAnalyzer.Analyze(((QilExpression)nd).Root, defaultNmspInScope: true);
					break;
				case QilNodeType.ElementCtor:
					if (!XmlILConstructInfo.Read(nd).IsNamespaceInScope)
					{
						nmspAnalyzer.Analyze(nd, defaultNmspInScope: false);
					}
					break;
				case QilNodeType.DocumentCtor:
					nmspAnalyzer.Analyze(nd, defaultNmspInScope: true);
					break;
				}
			}
			return base.Visit(nd);
		}

		protected override QilNode VisitReference(QilNode oldNode)
		{
			QilNode qilNode = subs.FindReplacement(oldNode);
			if (qilNode == null)
			{
				qilNode = oldNode;
			}
			if (this[XmlILOptimization.FoldConstant] && qilNode != null && (qilNode.NodeType == QilNodeType.Let || qilNode.NodeType == QilNodeType.For))
			{
				QilNode binding = ((QilIterator)oldNode).Binding;
				if (IsLiteral(binding))
				{
					return Replace(XmlILOptimization.FoldConstant, qilNode, binding.ShallowClone(f));
				}
			}
			return base.VisitReference(qilNode);
		}

		protected bool AllowReplace(XmlILOptimization pattern, QilNode original)
		{
			return base.AllowReplace((int)pattern, original);
		}

		protected QilNode Replace(XmlILOptimization pattern, QilNode original, QilNode replacement)
		{
			return base.Replace((int)pattern, original, replacement);
		}

		protected override QilNode NoReplace(QilNode node)
		{
			if (node != null)
			{
				switch (node.NodeType)
				{
				case QilNodeType.Error:
				case QilNodeType.Warning:
				case QilNodeType.XsltInvokeLateBound:
					OptimizerPatterns.Write(node).AddPattern(OptimizerPatternName.MaybeSideEffects);
					break;
				case QilNodeType.XsltInvokeEarlyBound:
					if (((QilInvokeEarlyBound)node).Name.NamespaceUri.Length != 0)
					{
						goto case QilNodeType.Error;
					}
					goto default;
				case QilNodeType.Invoke:
					if (((QilInvoke)node).Function.MaybeSideEffects)
					{
						goto case QilNodeType.Error;
					}
					goto default;
				default:
				{
					int num = 0;
					while (num < node.Count)
					{
						if (node[num] == null || !OptimizerPatterns.Read(node[num]).MatchesPattern(OptimizerPatternName.MaybeSideEffects))
						{
							num++;
							continue;
						}
						goto case QilNodeType.Error;
					}
					break;
				}
				}
			}
			return node;
		}

		protected override void RecalculateType(QilNode node, XmlQueryType oldType)
		{
			if (node.NodeType != QilNodeType.Let || !qil.GlobalVariableList.Contains(node))
			{
				base.RecalculateType(node, oldType);
			}
		}

		protected override QilNode VisitQilExpression(QilExpression local0)
		{
			_ = local0[0];
			if (this[XmlILOptimization.EliminateUnusedFunctions] && AllowReplace(XmlILOptimization.EliminateUnusedFunctions, local0))
			{
				IList<QilNode> functionList = local0.FunctionList;
				for (int num = functionList.Count - 1; num >= 0; num--)
				{
					if (XmlILConstructInfo.Write(functionList[num]).CallersInfo.Count == 0)
					{
						functionList.RemoveAt(num);
					}
				}
			}
			if (this[XmlILOptimization.AnnotateConstruction] && AllowReplace(XmlILOptimization.AnnotateConstruction, local0))
			{
				foreach (QilFunction function in local0.FunctionList)
				{
					if (IsConstructedExpression(function.Definition))
					{
						function.Definition = contentAnalyzer.Analyze(function, function.Definition);
					}
				}
				local0.Root = contentAnalyzer.Analyze(null, local0.Root);
				XmlILConstructInfo.Write(local0.Root).PushToWriterLast = true;
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitOptimizeBarrier(QilUnary local0)
		{
			QilNode ndSrc = local0[0];
			if (this[XmlILOptimization.AnnotateBarrier] && AllowReplace(XmlILOptimization.AnnotateBarrier, local0))
			{
				OptimizerPatterns.Inherit(ndSrc, local0, OptimizerPatternName.IsDocOrderDistinct);
				OptimizerPatterns.Inherit(ndSrc, local0, OptimizerPatternName.SameDepth);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitDataSource(QilDataSource local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitNop(QilUnary local0)
		{
			QilNode replacement = local0[0];
			if (this[XmlILOptimization.EliminateNop] && AllowReplace(XmlILOptimization.EliminateNop, local0))
			{
				return Replace(XmlILOptimization.EliminateNop, local0, replacement);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitError(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitWarning(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitLet(QilIterator local0)
		{
			QilNode ndSrc = local0[0];
			if (local0.XmlType.IsSingleton && !IsGlobalVariable(local0) && this[XmlILOptimization.NormalizeSingletonLet] && AllowReplace(XmlILOptimization.NormalizeSingletonLet, local0))
			{
				local0.NodeType = QilNodeType.For;
				VisitFor(local0);
			}
			if (this[XmlILOptimization.AnnotateLet] && AllowReplace(XmlILOptimization.AnnotateLet, local0))
			{
				OptimizerPatterns.Inherit(ndSrc, local0, OptimizerPatternName.Step);
				OptimizerPatterns.Inherit(ndSrc, local0, OptimizerPatternName.IsDocOrderDistinct);
				OptimizerPatterns.Inherit(ndSrc, local0, OptimizerPatternName.SameDepth);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitPositionOf(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.EliminatePositionOf] && qilNode.NodeType != QilNodeType.For && AllowReplace(XmlILOptimization.EliminatePositionOf, local0))
			{
				return Replace(XmlILOptimization.EliminatePositionOf, local0, VisitLiteralInt32(f.LiteralInt32(1)));
			}
			if (this[XmlILOptimization.EliminatePositionOf] && qilNode.NodeType == QilNodeType.For)
			{
				QilNode qilNode2 = qilNode[0];
				if (qilNode2.XmlType.IsSingleton && AllowReplace(XmlILOptimization.EliminatePositionOf, local0))
				{
					return Replace(XmlILOptimization.EliminatePositionOf, local0, VisitLiteralInt32(f.LiteralInt32(1)));
				}
			}
			if (this[XmlILOptimization.AnnotatePositionalIterator] && AllowReplace(XmlILOptimization.AnnotatePositionalIterator, local0))
			{
				OptimizerPatterns.Write(qilNode).AddPattern(OptimizerPatternName.IsPositional);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitAnd(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateAnd] && qilNode.NodeType == QilNodeType.True && AllowReplace(XmlILOptimization.EliminateAnd, local0))
			{
				return Replace(XmlILOptimization.EliminateAnd, local0, qilNode2);
			}
			if (this[XmlILOptimization.EliminateAnd] && qilNode.NodeType == QilNodeType.False && AllowReplace(XmlILOptimization.EliminateAnd, local0))
			{
				return Replace(XmlILOptimization.EliminateAnd, local0, qilNode);
			}
			if (this[XmlILOptimization.EliminateAnd] && qilNode2.NodeType == QilNodeType.True && AllowReplace(XmlILOptimization.EliminateAnd, local0))
			{
				return Replace(XmlILOptimization.EliminateAnd, local0, qilNode);
			}
			if (this[XmlILOptimization.EliminateAnd] && qilNode2.NodeType == QilNodeType.False && AllowReplace(XmlILOptimization.EliminateAnd, local0))
			{
				return Replace(XmlILOptimization.EliminateAnd, local0, qilNode2);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitOr(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateOr] && qilNode.NodeType == QilNodeType.True && AllowReplace(XmlILOptimization.EliminateOr, local0))
			{
				return Replace(XmlILOptimization.EliminateOr, local0, qilNode);
			}
			if (this[XmlILOptimization.EliminateOr] && qilNode.NodeType == QilNodeType.False && AllowReplace(XmlILOptimization.EliminateOr, local0))
			{
				return Replace(XmlILOptimization.EliminateOr, local0, qilNode2);
			}
			if (this[XmlILOptimization.EliminateOr] && qilNode2.NodeType == QilNodeType.True && AllowReplace(XmlILOptimization.EliminateOr, local0))
			{
				return Replace(XmlILOptimization.EliminateOr, local0, qilNode2);
			}
			if (this[XmlILOptimization.EliminateOr] && qilNode2.NodeType == QilNodeType.False && AllowReplace(XmlILOptimization.EliminateOr, local0))
			{
				return Replace(XmlILOptimization.EliminateOr, local0, qilNode);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitNot(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.EliminateNot] && qilNode.NodeType == QilNodeType.True && AllowReplace(XmlILOptimization.EliminateNot, local0))
			{
				return Replace(XmlILOptimization.EliminateNot, local0, VisitFalse(f.False()));
			}
			if (this[XmlILOptimization.EliminateNot] && qilNode.NodeType == QilNodeType.False && AllowReplace(XmlILOptimization.EliminateNot, local0))
			{
				return Replace(XmlILOptimization.EliminateNot, local0, VisitTrue(f.True()));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitConditional(QilTernary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			QilNode qilNode3 = local0[2];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.EliminateConditional] && qilNode.NodeType == QilNodeType.True && AllowReplace(XmlILOptimization.EliminateConditional, local0))
			{
				return Replace(XmlILOptimization.EliminateConditional, local0, qilNode2);
			}
			if (this[XmlILOptimization.EliminateConditional] && qilNode.NodeType == QilNodeType.False && AllowReplace(XmlILOptimization.EliminateConditional, local0))
			{
				return Replace(XmlILOptimization.EliminateConditional, local0, qilNode3);
			}
			if (this[XmlILOptimization.EliminateConditional] && qilNode2.NodeType == QilNodeType.True && qilNode3.NodeType == QilNodeType.False && AllowReplace(XmlILOptimization.EliminateConditional, local0))
			{
				return Replace(XmlILOptimization.EliminateConditional, local0, qilNode);
			}
			if (this[XmlILOptimization.EliminateConditional] && qilNode2.NodeType == QilNodeType.False && qilNode3.NodeType == QilNodeType.True && AllowReplace(XmlILOptimization.EliminateConditional, local0))
			{
				return Replace(XmlILOptimization.EliminateConditional, local0, VisitNot(f.Not(qilNode)));
			}
			if (this[XmlILOptimization.FoldConditionalNot] && qilNode.NodeType == QilNodeType.Not)
			{
				QilNode left = qilNode[0];
				if (AllowReplace(XmlILOptimization.FoldConditionalNot, local0))
				{
					return Replace(XmlILOptimization.FoldConditionalNot, local0, VisitConditional(f.Conditional(left, qilNode3, qilNode2)));
				}
			}
			if (this[XmlILOptimization.NormalizeConditionalText] && qilNode2.NodeType == QilNodeType.TextCtor)
			{
				QilNode center = qilNode2[0];
				if (qilNode3.NodeType == QilNodeType.TextCtor)
				{
					QilNode right = qilNode3[0];
					if (AllowReplace(XmlILOptimization.NormalizeConditionalText, local0))
					{
						return Replace(XmlILOptimization.NormalizeConditionalText, local0, VisitTextCtor(f.TextCtor(VisitConditional(f.Conditional(qilNode, center, right)))));
					}
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitChoice(QilChoice local0)
		{
			_ = local0[0];
			_ = local0[1];
			if (this[XmlILOptimization.AnnotateConstruction] && AllowReplace(XmlILOptimization.AnnotateConstruction, local0))
			{
				contentAnalyzer.Analyze(local0, null);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitLength(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.EliminateLength] && qilNode.NodeType == QilNodeType.Sequence && qilNode.Count == 0 && AllowReplace(XmlILOptimization.EliminateLength, local0))
			{
				return Replace(XmlILOptimization.EliminateLength, local0, VisitLiteralInt32(f.LiteralInt32(0)));
			}
			if (this[XmlILOptimization.EliminateLength] && qilNode.XmlType.IsSingleton && !OptimizerPatterns.Read(qilNode).MatchesPattern(OptimizerPatternName.MaybeSideEffects) && AllowReplace(XmlILOptimization.EliminateLength, local0))
			{
				return Replace(XmlILOptimization.EliminateLength, local0, VisitLiteralInt32(f.LiteralInt32(1)));
			}
			if (this[XmlILOptimization.IntroducePrecedingDod] && !IsDocOrderDistinct(qilNode) && (IsStepPattern(qilNode, QilNodeType.XPathPreceding) || IsStepPattern(qilNode, QilNodeType.PrecedingSibling)) && AllowReplace(XmlILOptimization.IntroducePrecedingDod, local0))
			{
				return Replace(XmlILOptimization.IntroducePrecedingDod, local0, VisitLength(f.Length(VisitDocOrderDistinct(f.DocOrderDistinct(qilNode)))));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitSequence(QilList local0)
		{
			if (local0.Count == 1 && this[XmlILOptimization.EliminateSequence] && AllowReplace(XmlILOptimization.EliminateSequence, local0))
			{
				return Replace(XmlILOptimization.EliminateSequence, local0, local0[0]);
			}
			if (HasNestedSequence(local0) && this[XmlILOptimization.NormalizeNestedSequences] && AllowReplace(XmlILOptimization.NormalizeNestedSequences, local0))
			{
				QilNode qilNode = VisitSequence(f.Sequence());
				foreach (QilNode item in local0)
				{
					if (item.NodeType == QilNodeType.Sequence)
					{
						qilNode.Add((IList<QilNode>)item);
					}
					else
					{
						qilNode.Add(item);
					}
				}
				qilNode = VisitSequence((QilList)qilNode);
				return Replace(XmlILOptimization.NormalizeNestedSequences, local0, qilNode);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitUnion(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateUnion] && qilNode2 == qilNode && AllowReplace(XmlILOptimization.EliminateUnion, local0))
			{
				return Replace(XmlILOptimization.EliminateUnion, local0, VisitDocOrderDistinct(f.DocOrderDistinct(qilNode)));
			}
			if (this[XmlILOptimization.EliminateUnion] && qilNode.NodeType == QilNodeType.Sequence && qilNode.Count == 0 && AllowReplace(XmlILOptimization.EliminateUnion, local0))
			{
				return Replace(XmlILOptimization.EliminateUnion, local0, VisitDocOrderDistinct(f.DocOrderDistinct(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateUnion] && qilNode2.NodeType == QilNodeType.Sequence && qilNode2.Count == 0 && AllowReplace(XmlILOptimization.EliminateUnion, local0))
			{
				return Replace(XmlILOptimization.EliminateUnion, local0, VisitDocOrderDistinct(f.DocOrderDistinct(qilNode)));
			}
			if (this[XmlILOptimization.EliminateUnion] && qilNode.NodeType == QilNodeType.XmlContext && qilNode2.NodeType == QilNodeType.XmlContext && AllowReplace(XmlILOptimization.EliminateUnion, local0))
			{
				return Replace(XmlILOptimization.EliminateUnion, local0, qilNode);
			}
			if (this[XmlILOptimization.NormalizeUnion] && (!IsDocOrderDistinct(qilNode) || !IsDocOrderDistinct(qilNode2)) && AllowReplace(XmlILOptimization.NormalizeUnion, local0))
			{
				return Replace(XmlILOptimization.NormalizeUnion, local0, VisitUnion(f.Union(VisitDocOrderDistinct(f.DocOrderDistinct(qilNode)), VisitDocOrderDistinct(f.DocOrderDistinct(qilNode2)))));
			}
			if (this[XmlILOptimization.AnnotateUnion] && AllowReplace(XmlILOptimization.AnnotateUnion, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.IsDocOrderDistinct);
			}
			if (this[XmlILOptimization.AnnotateUnionContent] && (IsStepPattern(qilNode, QilNodeType.Content) || IsStepPattern(qilNode, QilNodeType.Union)) && (IsStepPattern(qilNode2, QilNodeType.Content) || IsStepPattern(qilNode2, QilNodeType.Union)) && OptimizerPatterns.Read(qilNode).GetArgument(OptimizerPatternArgument.StepInput) == OptimizerPatterns.Read(qilNode2).GetArgument(OptimizerPatternArgument.StepInput) && AllowReplace(XmlILOptimization.AnnotateUnionContent, local0))
			{
				AddStepPattern(local0, (QilNode)OptimizerPatterns.Read(qilNode).GetArgument(OptimizerPatternArgument.StepInput));
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.SameDepth);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitIntersection(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateIntersection] && qilNode2 == qilNode && AllowReplace(XmlILOptimization.EliminateIntersection, local0))
			{
				return Replace(XmlILOptimization.EliminateIntersection, local0, VisitDocOrderDistinct(f.DocOrderDistinct(qilNode)));
			}
			if (this[XmlILOptimization.EliminateIntersection] && qilNode.NodeType == QilNodeType.Sequence && qilNode.Count == 0 && AllowReplace(XmlILOptimization.EliminateIntersection, local0))
			{
				return Replace(XmlILOptimization.EliminateIntersection, local0, qilNode);
			}
			if (this[XmlILOptimization.EliminateIntersection] && qilNode2.NodeType == QilNodeType.Sequence && qilNode2.Count == 0 && AllowReplace(XmlILOptimization.EliminateIntersection, local0))
			{
				return Replace(XmlILOptimization.EliminateIntersection, local0, qilNode2);
			}
			if (this[XmlILOptimization.EliminateIntersection] && qilNode.NodeType == QilNodeType.XmlContext && qilNode2.NodeType == QilNodeType.XmlContext && AllowReplace(XmlILOptimization.EliminateIntersection, local0))
			{
				return Replace(XmlILOptimization.EliminateIntersection, local0, qilNode);
			}
			if (this[XmlILOptimization.NormalizeIntersect] && (!IsDocOrderDistinct(qilNode) || !IsDocOrderDistinct(qilNode2)) && AllowReplace(XmlILOptimization.NormalizeIntersect, local0))
			{
				return Replace(XmlILOptimization.NormalizeIntersect, local0, VisitIntersection(f.Intersection(VisitDocOrderDistinct(f.DocOrderDistinct(qilNode)), VisitDocOrderDistinct(f.DocOrderDistinct(qilNode2)))));
			}
			if (this[XmlILOptimization.AnnotateIntersect] && AllowReplace(XmlILOptimization.AnnotateIntersect, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.IsDocOrderDistinct);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitDifference(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateDifference] && qilNode.NodeType == QilNodeType.Sequence && qilNode.Count == 0 && AllowReplace(XmlILOptimization.EliminateDifference, local0))
			{
				return Replace(XmlILOptimization.EliminateDifference, local0, qilNode);
			}
			if (this[XmlILOptimization.EliminateDifference] && qilNode2.NodeType == QilNodeType.Sequence && qilNode2.Count == 0 && AllowReplace(XmlILOptimization.EliminateDifference, local0))
			{
				return Replace(XmlILOptimization.EliminateDifference, local0, VisitDocOrderDistinct(f.DocOrderDistinct(qilNode)));
			}
			if (this[XmlILOptimization.EliminateDifference] && qilNode2 == qilNode && AllowReplace(XmlILOptimization.EliminateDifference, local0))
			{
				return Replace(XmlILOptimization.EliminateDifference, local0, VisitSequence(f.Sequence()));
			}
			if (this[XmlILOptimization.EliminateDifference] && qilNode.NodeType == QilNodeType.XmlContext && qilNode2.NodeType == QilNodeType.XmlContext && AllowReplace(XmlILOptimization.EliminateDifference, local0))
			{
				return Replace(XmlILOptimization.EliminateDifference, local0, VisitSequence(f.Sequence()));
			}
			if (this[XmlILOptimization.NormalizeDifference] && (!IsDocOrderDistinct(qilNode) || !IsDocOrderDistinct(qilNode2)) && AllowReplace(XmlILOptimization.NormalizeDifference, local0))
			{
				return Replace(XmlILOptimization.NormalizeDifference, local0, VisitDifference(f.Difference(VisitDocOrderDistinct(f.DocOrderDistinct(qilNode)), VisitDocOrderDistinct(f.DocOrderDistinct(qilNode2)))));
			}
			if (this[XmlILOptimization.AnnotateDifference] && AllowReplace(XmlILOptimization.AnnotateDifference, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.IsDocOrderDistinct);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitAverage(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.EliminateAverage] && qilNode.XmlType.Cardinality == XmlQueryCardinality.Zero && AllowReplace(XmlILOptimization.EliminateAverage, local0))
			{
				return Replace(XmlILOptimization.EliminateAverage, local0, VisitNop(f.Nop(qilNode)));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitSum(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.EliminateSum] && qilNode.XmlType.Cardinality == XmlQueryCardinality.Zero && AllowReplace(XmlILOptimization.EliminateSum, local0))
			{
				return Replace(XmlILOptimization.EliminateSum, local0, VisitNop(f.Nop(qilNode)));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitMinimum(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.EliminateMinimum] && qilNode.XmlType.Cardinality == XmlQueryCardinality.Zero && AllowReplace(XmlILOptimization.EliminateMinimum, local0))
			{
				return Replace(XmlILOptimization.EliminateMinimum, local0, VisitNop(f.Nop(qilNode)));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitMaximum(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.EliminateMaximum] && qilNode.XmlType.Cardinality == XmlQueryCardinality.Zero && AllowReplace(XmlILOptimization.EliminateMaximum, local0))
			{
				return Replace(XmlILOptimization.EliminateMaximum, local0, VisitNop(f.Nop(qilNode)));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitNegate(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.EliminateNegate] && qilNode.NodeType == QilNodeType.LiteralDecimal)
			{
				decimal num = (decimal)((QilLiteral)qilNode).Value;
				if (AllowReplace(XmlILOptimization.EliminateNegate, local0))
				{
					return Replace(XmlILOptimization.EliminateNegate, local0, VisitLiteralDecimal(f.LiteralDecimal(-num)));
				}
			}
			if (this[XmlILOptimization.EliminateNegate] && qilNode.NodeType == QilNodeType.LiteralDouble)
			{
				double num2 = (double)((QilLiteral)qilNode).Value;
				if (AllowReplace(XmlILOptimization.EliminateNegate, local0))
				{
					return Replace(XmlILOptimization.EliminateNegate, local0, VisitLiteralDouble(f.LiteralDouble(0.0 - num2)));
				}
			}
			if (this[XmlILOptimization.EliminateNegate] && qilNode.NodeType == QilNodeType.LiteralInt32)
			{
				int num3 = (int)((QilLiteral)qilNode).Value;
				if (AllowReplace(XmlILOptimization.EliminateNegate, local0))
				{
					return Replace(XmlILOptimization.EliminateNegate, local0, VisitLiteralInt32(f.LiteralInt32(-num3)));
				}
			}
			if (this[XmlILOptimization.EliminateNegate] && qilNode.NodeType == QilNodeType.LiteralInt64)
			{
				long num4 = (long)((QilLiteral)qilNode).Value;
				if (AllowReplace(XmlILOptimization.EliminateNegate, local0))
				{
					return Replace(XmlILOptimization.EliminateNegate, local0, VisitLiteralInt64(f.LiteralInt64(-num4)));
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitAdd(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateAdd] && IsLiteral(qilNode) && IsLiteral(qilNode2) && CanFoldArithmetic(QilNodeType.Add, (QilLiteral)qilNode, (QilLiteral)qilNode2) && AllowReplace(XmlILOptimization.EliminateAdd, local0))
			{
				return Replace(XmlILOptimization.EliminateAdd, local0, FoldArithmetic(QilNodeType.Add, (QilLiteral)qilNode, (QilLiteral)qilNode2));
			}
			if (this[XmlILOptimization.NormalizeAddLiteral] && IsLiteral(qilNode) && !IsLiteral(qilNode2) && AllowReplace(XmlILOptimization.NormalizeAddLiteral, local0))
			{
				return Replace(XmlILOptimization.NormalizeAddLiteral, local0, VisitAdd(f.Add(qilNode2, qilNode)));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitSubtract(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateSubtract] && IsLiteral(qilNode) && IsLiteral(qilNode2) && CanFoldArithmetic(QilNodeType.Subtract, (QilLiteral)qilNode, (QilLiteral)qilNode2) && AllowReplace(XmlILOptimization.EliminateSubtract, local0))
			{
				return Replace(XmlILOptimization.EliminateSubtract, local0, FoldArithmetic(QilNodeType.Subtract, (QilLiteral)qilNode, (QilLiteral)qilNode2));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitMultiply(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateMultiply] && IsLiteral(qilNode) && IsLiteral(qilNode2) && CanFoldArithmetic(QilNodeType.Multiply, (QilLiteral)qilNode, (QilLiteral)qilNode2) && AllowReplace(XmlILOptimization.EliminateMultiply, local0))
			{
				return Replace(XmlILOptimization.EliminateMultiply, local0, FoldArithmetic(QilNodeType.Multiply, (QilLiteral)qilNode, (QilLiteral)qilNode2));
			}
			if (this[XmlILOptimization.NormalizeMultiplyLiteral] && IsLiteral(qilNode) && !IsLiteral(qilNode2) && AllowReplace(XmlILOptimization.NormalizeMultiplyLiteral, local0))
			{
				return Replace(XmlILOptimization.NormalizeMultiplyLiteral, local0, VisitMultiply(f.Multiply(qilNode2, qilNode)));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitDivide(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateDivide] && IsLiteral(qilNode) && IsLiteral(qilNode2) && CanFoldArithmetic(QilNodeType.Divide, (QilLiteral)qilNode, (QilLiteral)qilNode2) && AllowReplace(XmlILOptimization.EliminateDivide, local0))
			{
				return Replace(XmlILOptimization.EliminateDivide, local0, FoldArithmetic(QilNodeType.Divide, (QilLiteral)qilNode, (QilLiteral)qilNode2));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitModulo(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateModulo] && IsLiteral(qilNode) && IsLiteral(qilNode2) && CanFoldArithmetic(QilNodeType.Modulo, (QilLiteral)qilNode, (QilLiteral)qilNode2) && AllowReplace(XmlILOptimization.EliminateModulo, local0))
			{
				return Replace(XmlILOptimization.EliminateModulo, local0, FoldArithmetic(QilNodeType.Modulo, (QilLiteral)qilNode, (QilLiteral)qilNode2));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitStrLength(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.EliminateStrLength] && qilNode.NodeType == QilNodeType.LiteralString)
			{
				string text = (string)((QilLiteral)qilNode).Value;
				if (AllowReplace(XmlILOptimization.EliminateStrLength, local0))
				{
					return Replace(XmlILOptimization.EliminateStrLength, local0, VisitLiteralInt32(f.LiteralInt32(text.Length)));
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitStrConcat(QilStrConcat local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (qilNode2.XmlType.IsSingleton && this[XmlILOptimization.EliminateStrConcatSingle] && AllowReplace(XmlILOptimization.EliminateStrConcatSingle, local0))
			{
				return Replace(XmlILOptimization.EliminateStrConcatSingle, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateStrConcat] && qilNode.NodeType == QilNodeType.LiteralString)
			{
				string delimiter = (string)((QilLiteral)qilNode).Value;
				if (qilNode2.NodeType == QilNodeType.Sequence && AreLiteralArgs(qilNode2) && AllowReplace(XmlILOptimization.EliminateStrConcat, local0))
				{
					StringConcat stringConcat = default(StringConcat);
					stringConcat.Delimiter = delimiter;
					foreach (QilLiteral item in qilNode2)
					{
						stringConcat.Concat(item);
					}
					return Replace(XmlILOptimization.EliminateStrConcat, local0, VisitLiteralString(f.LiteralString(stringConcat.GetResult())));
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitStrParseQName(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitNe(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateNe] && IsLiteral(qilNode) && IsLiteral(qilNode2) && AllowReplace(XmlILOptimization.EliminateNe, local0))
			{
				return Replace(XmlILOptimization.EliminateNe, local0, FoldComparison(QilNodeType.Ne, qilNode, qilNode2));
			}
			if (this[XmlILOptimization.NormalizeNeLiteral] && IsLiteral(qilNode) && !IsLiteral(qilNode2) && AllowReplace(XmlILOptimization.NormalizeNeLiteral, local0))
			{
				return Replace(XmlILOptimization.NormalizeNeLiteral, local0, VisitNe(f.Ne(qilNode2, qilNode)));
			}
			if (this[XmlILOptimization.NormalizeXsltConvertNe] && qilNode.NodeType == QilNodeType.XsltConvert)
			{
				QilNode qilNode3 = qilNode[0];
				QilNode qilNode4 = qilNode[1];
				if (qilNode4.NodeType == QilNodeType.LiteralType)
				{
					XmlQueryType typ = (XmlQueryType)((QilLiteral)qilNode4).Value;
					if (IsPrimitiveNumeric(qilNode3.XmlType) && IsPrimitiveNumeric(typ) && IsLiteral(qilNode2) && CanFoldXsltConvertNonLossy(qilNode2, qilNode3.XmlType) && AllowReplace(XmlILOptimization.NormalizeXsltConvertNe, local0))
					{
						return Replace(XmlILOptimization.NormalizeXsltConvertNe, local0, VisitNe(f.Ne(qilNode3, FoldXsltConvert(qilNode2, qilNode3.XmlType))));
					}
				}
			}
			if (this[XmlILOptimization.NormalizeIdNe] && qilNode.NodeType == QilNodeType.XsltGenerateId)
			{
				QilNode qilNode5 = qilNode[0];
				if (qilNode5.XmlType.IsSingleton && qilNode2.NodeType == QilNodeType.XsltGenerateId)
				{
					QilNode qilNode6 = qilNode2[0];
					if (qilNode6.XmlType.IsSingleton && AllowReplace(XmlILOptimization.NormalizeIdNe, local0))
					{
						return Replace(XmlILOptimization.NormalizeIdNe, local0, VisitNot(f.Not(VisitIs(f.Is(qilNode5, qilNode6)))));
					}
				}
			}
			if (this[XmlILOptimization.NormalizeLengthNe] && qilNode.NodeType == QilNodeType.Length)
			{
				QilNode child = qilNode[0];
				if (qilNode2.NodeType == QilNodeType.LiteralInt32 && (int)((QilLiteral)qilNode2).Value == 0 && AllowReplace(XmlILOptimization.NormalizeLengthNe, local0))
				{
					return Replace(XmlILOptimization.NormalizeLengthNe, local0, VisitNot(f.Not(VisitIsEmpty(f.IsEmpty(child)))));
				}
			}
			if (this[XmlILOptimization.AnnotateMaxLengthNe] && qilNode.NodeType == QilNodeType.Length && qilNode2.NodeType == QilNodeType.LiteralInt32)
			{
				int num = (int)((QilLiteral)qilNode2).Value;
				if (AllowReplace(XmlILOptimization.AnnotateMaxLengthNe, local0))
				{
					OptimizerPatterns.Write(qilNode).AddPattern(OptimizerPatternName.MaxPosition);
					OptimizerPatterns.Write(qilNode).AddArgument(OptimizerPatternArgument.ElementQName, num);
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitEq(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateEq] && IsLiteral(qilNode) && IsLiteral(qilNode2) && AllowReplace(XmlILOptimization.EliminateEq, local0))
			{
				return Replace(XmlILOptimization.EliminateEq, local0, FoldComparison(QilNodeType.Eq, qilNode, qilNode2));
			}
			if (this[XmlILOptimization.NormalizeEqLiteral] && IsLiteral(qilNode) && !IsLiteral(qilNode2) && AllowReplace(XmlILOptimization.NormalizeEqLiteral, local0))
			{
				return Replace(XmlILOptimization.NormalizeEqLiteral, local0, VisitEq(f.Eq(qilNode2, qilNode)));
			}
			if (this[XmlILOptimization.NormalizeXsltConvertEq] && qilNode.NodeType == QilNodeType.XsltConvert)
			{
				QilNode qilNode3 = qilNode[0];
				QilNode qilNode4 = qilNode[1];
				if (qilNode4.NodeType == QilNodeType.LiteralType)
				{
					XmlQueryType typ = (XmlQueryType)((QilLiteral)qilNode4).Value;
					if (IsPrimitiveNumeric(qilNode3.XmlType) && IsPrimitiveNumeric(typ) && IsLiteral(qilNode2) && CanFoldXsltConvertNonLossy(qilNode2, qilNode3.XmlType) && AllowReplace(XmlILOptimization.NormalizeXsltConvertEq, local0))
					{
						return Replace(XmlILOptimization.NormalizeXsltConvertEq, local0, VisitEq(f.Eq(qilNode3, FoldXsltConvert(qilNode2, qilNode3.XmlType))));
					}
				}
			}
			if (this[XmlILOptimization.NormalizeAddEq] && qilNode.NodeType == QilNodeType.Add)
			{
				QilNode left = qilNode[0];
				QilNode qilNode5 = qilNode[1];
				if (IsLiteral(qilNode5) && IsLiteral(qilNode2) && CanFoldArithmetic(QilNodeType.Subtract, (QilLiteral)qilNode2, (QilLiteral)qilNode5) && AllowReplace(XmlILOptimization.NormalizeAddEq, local0))
				{
					return Replace(XmlILOptimization.NormalizeAddEq, local0, VisitEq(f.Eq(left, FoldArithmetic(QilNodeType.Subtract, (QilLiteral)qilNode2, (QilLiteral)qilNode5))));
				}
			}
			if (this[XmlILOptimization.NormalizeIdEq] && qilNode.NodeType == QilNodeType.XsltGenerateId)
			{
				QilNode qilNode6 = qilNode[0];
				if (qilNode6.XmlType.IsSingleton && qilNode2.NodeType == QilNodeType.XsltGenerateId)
				{
					QilNode qilNode7 = qilNode2[0];
					if (qilNode7.XmlType.IsSingleton && AllowReplace(XmlILOptimization.NormalizeIdEq, local0))
					{
						return Replace(XmlILOptimization.NormalizeIdEq, local0, VisitIs(f.Is(qilNode6, qilNode7)));
					}
				}
			}
			if (this[XmlILOptimization.NormalizeIdEq] && qilNode.NodeType == QilNodeType.XsltGenerateId)
			{
				QilNode qilNode8 = qilNode[0];
				if (qilNode8.XmlType.IsSingleton && qilNode2.NodeType == QilNodeType.StrConcat)
				{
					QilNode qilNode9 = qilNode2[1];
					if (qilNode9.NodeType == QilNodeType.Loop)
					{
						QilNode qilNode10 = qilNode9[0];
						QilNode qilNode11 = qilNode9[1];
						if (qilNode10.NodeType == QilNodeType.For)
						{
							QilNode qilNode12 = qilNode10[0];
							if (!qilNode12.XmlType.MaybeMany && qilNode11.NodeType == QilNodeType.XsltGenerateId)
							{
								QilNode qilNode13 = qilNode11[0];
								if (qilNode13 == qilNode10 && AllowReplace(XmlILOptimization.NormalizeIdEq, local0))
								{
									QilNode qilNode14 = VisitFor(f.For(qilNode12));
									return Replace(XmlILOptimization.NormalizeIdEq, local0, VisitNot(f.Not(VisitIsEmpty(f.IsEmpty(VisitFilter(f.Filter(qilNode14, VisitIs(f.Is(qilNode8, qilNode14)))))))));
								}
							}
						}
					}
				}
			}
			if (this[XmlILOptimization.NormalizeIdEq] && qilNode.NodeType == QilNodeType.StrConcat)
			{
				QilNode qilNode15 = qilNode[1];
				if (qilNode15.NodeType == QilNodeType.Loop)
				{
					QilNode qilNode16 = qilNode15[0];
					QilNode qilNode17 = qilNode15[1];
					if (qilNode16.NodeType == QilNodeType.For)
					{
						QilNode qilNode18 = qilNode16[0];
						if (!qilNode18.XmlType.MaybeMany && qilNode17.NodeType == QilNodeType.XsltGenerateId)
						{
							QilNode qilNode19 = qilNode17[0];
							if (qilNode19 == qilNode16 && qilNode2.NodeType == QilNodeType.XsltGenerateId)
							{
								QilNode qilNode20 = qilNode2[0];
								if (qilNode20.XmlType.IsSingleton && AllowReplace(XmlILOptimization.NormalizeIdEq, local0))
								{
									QilNode qilNode21 = VisitFor(f.For(qilNode18));
									return Replace(XmlILOptimization.NormalizeIdEq, local0, VisitNot(f.Not(VisitIsEmpty(f.IsEmpty(VisitFilter(f.Filter(qilNode21, VisitIs(f.Is(qilNode20, qilNode21)))))))));
								}
							}
						}
					}
				}
			}
			if (this[XmlILOptimization.NormalizeMuenchian] && qilNode.NodeType == QilNodeType.Length)
			{
				QilNode qilNode22 = qilNode[0];
				if (qilNode22.NodeType == QilNodeType.Union)
				{
					QilNode qilNode23 = qilNode22[0];
					QilNode qilNode24 = qilNode22[1];
					if (qilNode23.XmlType.IsSingleton && !qilNode24.XmlType.MaybeMany && qilNode2.NodeType == QilNodeType.LiteralInt32)
					{
						int num = (int)((QilLiteral)qilNode2).Value;
						if (num == 1 && AllowReplace(XmlILOptimization.NormalizeMuenchian, local0))
						{
							QilNode qilNode25 = VisitFor(f.For(qilNode24));
							return Replace(XmlILOptimization.NormalizeMuenchian, local0, VisitIsEmpty(f.IsEmpty(VisitFilter(f.Filter(qilNode25, VisitNot(f.Not(VisitIs(f.Is(qilNode23, qilNode25)))))))));
						}
					}
				}
			}
			if (this[XmlILOptimization.NormalizeMuenchian] && qilNode.NodeType == QilNodeType.Length)
			{
				QilNode qilNode26 = qilNode[0];
				if (qilNode26.NodeType == QilNodeType.Union)
				{
					QilNode qilNode27 = qilNode26[0];
					QilNode qilNode28 = qilNode26[1];
					if (!qilNode27.XmlType.MaybeMany && qilNode28.XmlType.IsSingleton && qilNode2.NodeType == QilNodeType.LiteralInt32)
					{
						int num2 = (int)((QilLiteral)qilNode2).Value;
						if (num2 == 1 && AllowReplace(XmlILOptimization.NormalizeMuenchian, local0))
						{
							QilNode qilNode29 = VisitFor(f.For(qilNode27));
							return Replace(XmlILOptimization.NormalizeMuenchian, local0, VisitIsEmpty(f.IsEmpty(VisitFilter(f.Filter(qilNode29, VisitNot(f.Not(VisitIs(f.Is(qilNode29, qilNode28)))))))));
						}
					}
				}
			}
			if (this[XmlILOptimization.AnnotateMaxLengthEq] && qilNode.NodeType == QilNodeType.Length && qilNode2.NodeType == QilNodeType.LiteralInt32)
			{
				int num3 = (int)((QilLiteral)qilNode2).Value;
				if (AllowReplace(XmlILOptimization.AnnotateMaxLengthEq, local0))
				{
					OptimizerPatterns.Write(qilNode).AddPattern(OptimizerPatternName.MaxPosition);
					OptimizerPatterns.Write(qilNode).AddArgument(OptimizerPatternArgument.ElementQName, num3);
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitGt(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateGt] && IsLiteral(qilNode) && IsLiteral(qilNode2) && AllowReplace(XmlILOptimization.EliminateGt, local0))
			{
				return Replace(XmlILOptimization.EliminateGt, local0, FoldComparison(QilNodeType.Gt, qilNode, qilNode2));
			}
			if (this[XmlILOptimization.NormalizeGtLiteral] && IsLiteral(qilNode) && !IsLiteral(qilNode2) && AllowReplace(XmlILOptimization.NormalizeGtLiteral, local0))
			{
				return Replace(XmlILOptimization.NormalizeGtLiteral, local0, VisitLt(f.Lt(qilNode2, qilNode)));
			}
			if (this[XmlILOptimization.NormalizeXsltConvertGt] && qilNode.NodeType == QilNodeType.XsltConvert)
			{
				QilNode qilNode3 = qilNode[0];
				QilNode qilNode4 = qilNode[1];
				if (qilNode4.NodeType == QilNodeType.LiteralType)
				{
					XmlQueryType typ = (XmlQueryType)((QilLiteral)qilNode4).Value;
					if (IsPrimitiveNumeric(qilNode3.XmlType) && IsPrimitiveNumeric(typ) && IsLiteral(qilNode2) && CanFoldXsltConvertNonLossy(qilNode2, qilNode3.XmlType) && AllowReplace(XmlILOptimization.NormalizeXsltConvertGt, local0))
					{
						return Replace(XmlILOptimization.NormalizeXsltConvertGt, local0, VisitGt(f.Gt(qilNode3, FoldXsltConvert(qilNode2, qilNode3.XmlType))));
					}
				}
			}
			if (this[XmlILOptimization.NormalizeLengthGt] && qilNode.NodeType == QilNodeType.Length)
			{
				QilNode child = qilNode[0];
				if (qilNode2.NodeType == QilNodeType.LiteralInt32 && (int)((QilLiteral)qilNode2).Value == 0 && AllowReplace(XmlILOptimization.NormalizeLengthGt, local0))
				{
					return Replace(XmlILOptimization.NormalizeLengthGt, local0, VisitNot(f.Not(VisitIsEmpty(f.IsEmpty(child)))));
				}
			}
			if (this[XmlILOptimization.AnnotateMaxLengthGt] && qilNode.NodeType == QilNodeType.Length && qilNode2.NodeType == QilNodeType.LiteralInt32)
			{
				int num = (int)((QilLiteral)qilNode2).Value;
				if (AllowReplace(XmlILOptimization.AnnotateMaxLengthGt, local0))
				{
					OptimizerPatterns.Write(qilNode).AddPattern(OptimizerPatternName.MaxPosition);
					OptimizerPatterns.Write(qilNode).AddArgument(OptimizerPatternArgument.ElementQName, num);
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitGe(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateGe] && IsLiteral(qilNode) && IsLiteral(qilNode2) && AllowReplace(XmlILOptimization.EliminateGe, local0))
			{
				return Replace(XmlILOptimization.EliminateGe, local0, FoldComparison(QilNodeType.Ge, qilNode, qilNode2));
			}
			if (this[XmlILOptimization.NormalizeGeLiteral] && IsLiteral(qilNode) && !IsLiteral(qilNode2) && AllowReplace(XmlILOptimization.NormalizeGeLiteral, local0))
			{
				return Replace(XmlILOptimization.NormalizeGeLiteral, local0, VisitLe(f.Le(qilNode2, qilNode)));
			}
			if (this[XmlILOptimization.NormalizeXsltConvertGe] && qilNode.NodeType == QilNodeType.XsltConvert)
			{
				QilNode qilNode3 = qilNode[0];
				QilNode qilNode4 = qilNode[1];
				if (qilNode4.NodeType == QilNodeType.LiteralType)
				{
					XmlQueryType typ = (XmlQueryType)((QilLiteral)qilNode4).Value;
					if (IsPrimitiveNumeric(qilNode3.XmlType) && IsPrimitiveNumeric(typ) && IsLiteral(qilNode2) && CanFoldXsltConvertNonLossy(qilNode2, qilNode3.XmlType) && AllowReplace(XmlILOptimization.NormalizeXsltConvertGe, local0))
					{
						return Replace(XmlILOptimization.NormalizeXsltConvertGe, local0, VisitGe(f.Ge(qilNode3, FoldXsltConvert(qilNode2, qilNode3.XmlType))));
					}
				}
			}
			if (this[XmlILOptimization.AnnotateMaxLengthGe] && qilNode.NodeType == QilNodeType.Length && qilNode2.NodeType == QilNodeType.LiteralInt32)
			{
				int num = (int)((QilLiteral)qilNode2).Value;
				if (AllowReplace(XmlILOptimization.AnnotateMaxLengthGe, local0))
				{
					OptimizerPatterns.Write(qilNode).AddPattern(OptimizerPatternName.MaxPosition);
					OptimizerPatterns.Write(qilNode).AddArgument(OptimizerPatternArgument.ElementQName, num);
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitLt(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateLt] && IsLiteral(qilNode) && IsLiteral(qilNode2) && AllowReplace(XmlILOptimization.EliminateLt, local0))
			{
				return Replace(XmlILOptimization.EliminateLt, local0, FoldComparison(QilNodeType.Lt, qilNode, qilNode2));
			}
			if (this[XmlILOptimization.NormalizeLtLiteral] && IsLiteral(qilNode) && !IsLiteral(qilNode2) && AllowReplace(XmlILOptimization.NormalizeLtLiteral, local0))
			{
				return Replace(XmlILOptimization.NormalizeLtLiteral, local0, VisitGt(f.Gt(qilNode2, qilNode)));
			}
			if (this[XmlILOptimization.NormalizeXsltConvertLt] && qilNode.NodeType == QilNodeType.XsltConvert)
			{
				QilNode qilNode3 = qilNode[0];
				QilNode qilNode4 = qilNode[1];
				if (qilNode4.NodeType == QilNodeType.LiteralType)
				{
					XmlQueryType typ = (XmlQueryType)((QilLiteral)qilNode4).Value;
					if (IsPrimitiveNumeric(qilNode3.XmlType) && IsPrimitiveNumeric(typ) && IsLiteral(qilNode2) && CanFoldXsltConvertNonLossy(qilNode2, qilNode3.XmlType) && AllowReplace(XmlILOptimization.NormalizeXsltConvertLt, local0))
					{
						return Replace(XmlILOptimization.NormalizeXsltConvertLt, local0, VisitLt(f.Lt(qilNode3, FoldXsltConvert(qilNode2, qilNode3.XmlType))));
					}
				}
			}
			if (this[XmlILOptimization.AnnotateMaxLengthLt] && qilNode.NodeType == QilNodeType.Length && qilNode2.NodeType == QilNodeType.LiteralInt32)
			{
				int num = (int)((QilLiteral)qilNode2).Value;
				if (AllowReplace(XmlILOptimization.AnnotateMaxLengthLt, local0))
				{
					OptimizerPatterns.Write(qilNode).AddPattern(OptimizerPatternName.MaxPosition);
					OptimizerPatterns.Write(qilNode).AddArgument(OptimizerPatternArgument.ElementQName, num);
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitLe(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateLe] && IsLiteral(qilNode) && IsLiteral(qilNode2) && AllowReplace(XmlILOptimization.EliminateLe, local0))
			{
				return Replace(XmlILOptimization.EliminateLe, local0, FoldComparison(QilNodeType.Le, qilNode, qilNode2));
			}
			if (this[XmlILOptimization.NormalizeLeLiteral] && IsLiteral(qilNode) && !IsLiteral(qilNode2) && AllowReplace(XmlILOptimization.NormalizeLeLiteral, local0))
			{
				return Replace(XmlILOptimization.NormalizeLeLiteral, local0, VisitGe(f.Ge(qilNode2, qilNode)));
			}
			if (this[XmlILOptimization.NormalizeXsltConvertLe] && qilNode.NodeType == QilNodeType.XsltConvert)
			{
				QilNode qilNode3 = qilNode[0];
				QilNode qilNode4 = qilNode[1];
				if (qilNode4.NodeType == QilNodeType.LiteralType)
				{
					XmlQueryType typ = (XmlQueryType)((QilLiteral)qilNode4).Value;
					if (IsPrimitiveNumeric(qilNode3.XmlType) && IsPrimitiveNumeric(typ) && IsLiteral(qilNode2) && CanFoldXsltConvertNonLossy(qilNode2, qilNode3.XmlType) && AllowReplace(XmlILOptimization.NormalizeXsltConvertLe, local0))
					{
						return Replace(XmlILOptimization.NormalizeXsltConvertLe, local0, VisitLe(f.Le(qilNode3, FoldXsltConvert(qilNode2, qilNode3.XmlType))));
					}
				}
			}
			if (this[XmlILOptimization.AnnotateMaxLengthLe] && qilNode.NodeType == QilNodeType.Length && qilNode2.NodeType == QilNodeType.LiteralInt32)
			{
				int num = (int)((QilLiteral)qilNode2).Value;
				if (AllowReplace(XmlILOptimization.AnnotateMaxLengthLe, local0))
				{
					OptimizerPatterns.Write(qilNode).AddPattern(OptimizerPatternName.MaxPosition);
					OptimizerPatterns.Write(qilNode).AddArgument(OptimizerPatternArgument.ElementQName, num);
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitIs(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateIs] && qilNode2 == qilNode && AllowReplace(XmlILOptimization.EliminateIs, local0))
			{
				return Replace(XmlILOptimization.EliminateIs, local0, VisitTrue(f.True()));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitAfter(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateAfter] && qilNode2 == qilNode && AllowReplace(XmlILOptimization.EliminateAfter, local0))
			{
				return Replace(XmlILOptimization.EliminateAfter, local0, VisitFalse(f.False()));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitBefore(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateBefore] && qilNode2 == qilNode && AllowReplace(XmlILOptimization.EliminateBefore, local0))
			{
				return Replace(XmlILOptimization.EliminateBefore, local0, VisitFalse(f.False()));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitLoop(QilLoop local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode[0])));
			}
			if (this[XmlILOptimization.EliminateIterator] && qilNode.NodeType == QilNodeType.For)
			{
				QilNode qilNode3 = qilNode[0];
				if (qilNode3.NodeType == QilNodeType.For && !OptimizerPatterns.Read(qilNode).MatchesPattern(OptimizerPatternName.IsPositional) && AllowReplace(XmlILOptimization.EliminateIterator, local0))
				{
					return Replace(XmlILOptimization.EliminateIterator, local0, Subs(qilNode2, qilNode, qilNode3));
				}
			}
			if (this[XmlILOptimization.EliminateLoop] && qilNode.NodeType == QilNodeType.For)
			{
				QilNode qilNode4 = qilNode[0];
				if (qilNode4.NodeType == QilNodeType.Sequence && qilNode4.Count == 0 && AllowReplace(XmlILOptimization.EliminateLoop, local0))
				{
					return Replace(XmlILOptimization.EliminateLoop, local0, VisitSequence(f.Sequence()));
				}
			}
			if (this[XmlILOptimization.EliminateLoop] && !OptimizerPatterns.Read(qilNode).MatchesPattern(OptimizerPatternName.MaybeSideEffects) && qilNode2.NodeType == QilNodeType.Sequence && qilNode2.Count == 0 && AllowReplace(XmlILOptimization.EliminateLoop, local0))
			{
				return Replace(XmlILOptimization.EliminateLoop, local0, VisitSequence(f.Sequence()));
			}
			if (this[XmlILOptimization.EliminateLoop] && qilNode2 == qilNode && AllowReplace(XmlILOptimization.EliminateLoop, local0))
			{
				return Replace(XmlILOptimization.EliminateLoop, local0, qilNode[0]);
			}
			if (this[XmlILOptimization.NormalizeLoopText] && qilNode.NodeType == QilNodeType.For)
			{
				QilNode qilNode5 = qilNode[0];
				if (qilNode5.XmlType.IsSingleton && qilNode2.NodeType == QilNodeType.TextCtor)
				{
					QilNode body = qilNode2[0];
					if (AllowReplace(XmlILOptimization.NormalizeLoopText, local0))
					{
						return Replace(XmlILOptimization.NormalizeLoopText, local0, VisitTextCtor(f.TextCtor(VisitLoop(f.Loop(qilNode, body)))));
					}
				}
			}
			if (this[XmlILOptimization.EliminateIteratorUsedAtMostOnce] && (qilNode.NodeType == QilNodeType.Let || qilNode[0].XmlType.IsSingleton) && !OptimizerPatterns.Read(qilNode).MatchesPattern(OptimizerPatternName.MaybeSideEffects) && nodeCounter.Count(qilNode2, qilNode) <= 1 && !OptimizerPatterns.Read(qilNode2).MatchesPattern(OptimizerPatternName.MaybeSideEffects) && AllowReplace(XmlILOptimization.EliminateIteratorUsedAtMostOnce, local0))
			{
				return Replace(XmlILOptimization.EliminateIteratorUsedAtMostOnce, local0, Subs(qilNode2, qilNode, qilNode[0]));
			}
			if (this[XmlILOptimization.NormalizeLoopConditional] && qilNode2.NodeType == QilNodeType.Conditional)
			{
				QilNode child = qilNode2[0];
				QilNode qilNode6 = qilNode2[1];
				QilNode qilNode7 = qilNode2[2];
				if (qilNode6.NodeType == QilNodeType.Sequence && qilNode6.Count == 0 && qilNode7 == qilNode && AllowReplace(XmlILOptimization.NormalizeLoopConditional, local0))
				{
					return Replace(XmlILOptimization.NormalizeLoopConditional, local0, VisitFilter(f.Filter(qilNode, VisitNot(f.Not(child)))));
				}
			}
			if (this[XmlILOptimization.NormalizeLoopConditional] && qilNode2.NodeType == QilNodeType.Conditional)
			{
				QilNode body2 = qilNode2[0];
				QilNode qilNode8 = qilNode2[1];
				QilNode qilNode9 = qilNode2[2];
				if (qilNode8 == qilNode && qilNode9.NodeType == QilNodeType.Sequence && qilNode9.Count == 0 && AllowReplace(XmlILOptimization.NormalizeLoopConditional, local0))
				{
					return Replace(XmlILOptimization.NormalizeLoopConditional, local0, VisitFilter(f.Filter(qilNode, body2)));
				}
			}
			if (this[XmlILOptimization.NormalizeLoopConditional] && qilNode.NodeType == QilNodeType.For && qilNode2.NodeType == QilNodeType.Conditional)
			{
				QilNode child2 = qilNode2[0];
				QilNode qilNode10 = qilNode2[1];
				QilNode expr = qilNode2[2];
				if (qilNode10.NodeType == QilNodeType.Sequence && qilNode10.Count == 0 && NonPositional(expr, qilNode) && AllowReplace(XmlILOptimization.NormalizeLoopConditional, local0))
				{
					QilNode qilNode11 = VisitFor(f.For(VisitFilter(f.Filter(qilNode, VisitNot(f.Not(child2))))));
					return Replace(XmlILOptimization.NormalizeLoopConditional, local0, VisitLoop(f.Loop(qilNode11, Subs(expr, qilNode, qilNode11))));
				}
			}
			if (this[XmlILOptimization.NormalizeLoopConditional] && qilNode.NodeType == QilNodeType.For && qilNode2.NodeType == QilNodeType.Conditional)
			{
				QilNode body3 = qilNode2[0];
				QilNode expr2 = qilNode2[1];
				QilNode qilNode12 = qilNode2[2];
				if (NonPositional(expr2, qilNode) && qilNode12.NodeType == QilNodeType.Sequence && qilNode12.Count == 0 && AllowReplace(XmlILOptimization.NormalizeLoopConditional, local0))
				{
					QilNode qilNode13 = VisitFor(f.For(VisitFilter(f.Filter(qilNode, body3))));
					return Replace(XmlILOptimization.NormalizeLoopConditional, local0, VisitLoop(f.Loop(qilNode13, Subs(expr2, qilNode, qilNode13))));
				}
			}
			if (this[XmlILOptimization.NormalizeLoopLoop] && qilNode2.NodeType == QilNodeType.Loop)
			{
				QilNode qilNode14 = qilNode2[0];
				QilNode expr3 = qilNode2[1];
				if (qilNode14.NodeType == QilNodeType.For)
				{
					QilNode body4 = qilNode14[0];
					if (!DependsOn(expr3, qilNode) && NonPositional(expr3, qilNode14) && AllowReplace(XmlILOptimization.NormalizeLoopLoop, local0))
					{
						QilNode qilNode15 = VisitFor(f.For(VisitLoop(f.Loop(qilNode, body4))));
						return Replace(XmlILOptimization.NormalizeLoopLoop, local0, VisitLoop(f.Loop(qilNode15, Subs(expr3, qilNode14, qilNode15))));
					}
				}
			}
			if (this[XmlILOptimization.AnnotateSingletonLoop] && qilNode.NodeType == QilNodeType.For)
			{
				QilNode qilNode16 = qilNode[0];
				if (!qilNode16.XmlType.MaybeMany && AllowReplace(XmlILOptimization.AnnotateSingletonLoop, local0))
				{
					OptimizerPatterns.Inherit(qilNode2, local0, OptimizerPatternName.IsDocOrderDistinct);
					OptimizerPatterns.Inherit(qilNode2, local0, OptimizerPatternName.SameDepth);
				}
			}
			if (this[XmlILOptimization.AnnotateRootLoop] && IsStepPattern(qilNode2, QilNodeType.Root) && AllowReplace(XmlILOptimization.AnnotateRootLoop, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.SameDepth);
			}
			if (this[XmlILOptimization.AnnotateContentLoop] && qilNode.NodeType == QilNodeType.For)
			{
				QilNode qilNode17 = qilNode[0];
				if (OptimizerPatterns.Read(qilNode17).MatchesPattern(OptimizerPatternName.SameDepth) && (IsStepPattern(qilNode2, QilNodeType.Content) || IsStepPattern(qilNode2, QilNodeType.Union)) && qilNode == OptimizerPatterns.Read(qilNode2).GetArgument(OptimizerPatternArgument.StepInput) && AllowReplace(XmlILOptimization.AnnotateContentLoop, local0))
				{
					OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.SameDepth);
					OptimizerPatterns.Inherit(qilNode17, local0, OptimizerPatternName.IsDocOrderDistinct);
				}
			}
			if (this[XmlILOptimization.AnnotateAttrNmspLoop] && qilNode.NodeType == QilNodeType.For)
			{
				QilNode ndSrc = qilNode[0];
				if ((IsStepPattern(qilNode2, QilNodeType.Attribute) || IsStepPattern(qilNode2, QilNodeType.XPathNamespace) || OptimizerPatterns.Read(qilNode2).MatchesPattern(OptimizerPatternName.FilterAttributeKind)) && qilNode == OptimizerPatterns.Read(qilNode2).GetArgument(OptimizerPatternArgument.StepInput) && AllowReplace(XmlILOptimization.AnnotateAttrNmspLoop, local0))
				{
					OptimizerPatterns.Inherit(ndSrc, local0, OptimizerPatternName.SameDepth);
					OptimizerPatterns.Inherit(ndSrc, local0, OptimizerPatternName.IsDocOrderDistinct);
				}
			}
			if (this[XmlILOptimization.AnnotateDescendantLoop] && qilNode.NodeType == QilNodeType.For)
			{
				QilNode qilNode18 = qilNode[0];
				if (OptimizerPatterns.Read(qilNode18).MatchesPattern(OptimizerPatternName.SameDepth) && (IsStepPattern(qilNode2, QilNodeType.Descendant) || IsStepPattern(qilNode2, QilNodeType.DescendantOrSelf)) && qilNode == OptimizerPatterns.Read(qilNode2).GetArgument(OptimizerPatternArgument.StepInput) && AllowReplace(XmlILOptimization.AnnotateDescendantLoop, local0))
				{
					OptimizerPatterns.Inherit(qilNode18, local0, OptimizerPatternName.IsDocOrderDistinct);
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitFilter(QilLoop local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitLoop(f.Loop(qilNode, qilNode2)));
			}
			if (this[XmlILOptimization.EliminateFilter] && !OptimizerPatterns.Read(qilNode).MatchesPattern(OptimizerPatternName.MaybeSideEffects) && qilNode2.NodeType == QilNodeType.False && AllowReplace(XmlILOptimization.EliminateFilter, local0))
			{
				return Replace(XmlILOptimization.EliminateFilter, local0, VisitSequence(f.Sequence()));
			}
			if (this[XmlILOptimization.EliminateFilter] && qilNode2.NodeType == QilNodeType.True && AllowReplace(XmlILOptimization.EliminateFilter, local0))
			{
				return Replace(XmlILOptimization.EliminateFilter, local0, qilNode[0]);
			}
			if (this[XmlILOptimization.NormalizeAttribute] && qilNode.NodeType == QilNodeType.For)
			{
				QilNode qilNode3 = qilNode[0];
				if (qilNode3.NodeType == QilNodeType.Content)
				{
					QilNode left = qilNode3[0];
					if (qilNode2.NodeType == QilNodeType.And)
					{
						QilNode qilNode4 = qilNode2[0];
						QilNode qilNode5 = qilNode2[1];
						if (qilNode4.NodeType == QilNodeType.IsType)
						{
							QilNode qilNode6 = qilNode4[0];
							QilNode qilNode7 = qilNode4[1];
							if (qilNode6 == qilNode && qilNode7.NodeType == QilNodeType.LiteralType)
							{
								XmlQueryType xmlQueryType = (XmlQueryType)((QilLiteral)qilNode7).Value;
								if (xmlQueryType == XmlQueryTypeFactory.Attribute && qilNode5.NodeType == QilNodeType.Eq)
								{
									QilNode qilNode8 = qilNode5[0];
									QilNode qilNode9 = qilNode5[1];
									if (qilNode8.NodeType == QilNodeType.NameOf)
									{
										QilNode qilNode10 = qilNode8[0];
										if (qilNode10 == qilNode && qilNode9.NodeType == QilNodeType.LiteralQName && AllowReplace(XmlILOptimization.NormalizeAttribute, local0))
										{
											return Replace(XmlILOptimization.NormalizeAttribute, local0, VisitAttribute(f.Attribute(left, qilNode9)));
										}
									}
								}
							}
						}
					}
				}
			}
			if (this[XmlILOptimization.CommuteFilterLoop] && qilNode.NodeType == QilNodeType.For)
			{
				QilNode qilNode11 = qilNode[0];
				if (qilNode11.NodeType == QilNodeType.Loop)
				{
					QilNode variable = qilNode11[0];
					QilNode binding = qilNode11[1];
					if (NonPositional(qilNode2, qilNode) && !IsDocOrderDistinct(qilNode11) && AllowReplace(XmlILOptimization.CommuteFilterLoop, local0))
					{
						QilNode qilNode12 = VisitFor(f.For(binding));
						return Replace(XmlILOptimization.CommuteFilterLoop, local0, VisitLoop(f.Loop(variable, VisitFilter(f.Filter(qilNode12, Subs(qilNode2, qilNode, qilNode12))))));
					}
				}
			}
			if (this[XmlILOptimization.NormalizeLoopInvariant] && !OptimizerPatterns.Read(qilNode).MatchesPattern(OptimizerPatternName.MaybeSideEffects) && qilNode[0].NodeType != QilNodeType.OptimizeBarrier && !DependsOn(qilNode2, qilNode) && !OptimizerPatterns.Read(qilNode2).MatchesPattern(OptimizerPatternName.MaybeSideEffects) && AllowReplace(XmlILOptimization.NormalizeLoopInvariant, local0))
			{
				return Replace(XmlILOptimization.NormalizeLoopInvariant, local0, VisitConditional(f.Conditional(qilNode2, qilNode[0], VisitSequence(f.Sequence()))));
			}
			if (this[XmlILOptimization.AnnotateMaxPositionEq] && qilNode2.NodeType == QilNodeType.Eq)
			{
				QilNode qilNode13 = qilNode2[0];
				QilNode qilNode14 = qilNode2[1];
				if (qilNode13.NodeType == QilNodeType.PositionOf)
				{
					QilNode qilNode15 = qilNode13[0];
					if (qilNode15 == qilNode && qilNode14.NodeType == QilNodeType.LiteralInt32)
					{
						int num = (int)((QilLiteral)qilNode14).Value;
						if (AllowReplace(XmlILOptimization.AnnotateMaxPositionEq, local0))
						{
							OptimizerPatterns.Write(qilNode).AddPattern(OptimizerPatternName.MaxPosition);
							OptimizerPatterns.Write(qilNode).AddArgument(OptimizerPatternArgument.ElementQName, num);
						}
					}
				}
			}
			if (this[XmlILOptimization.AnnotateMaxPositionLe] && qilNode2.NodeType == QilNodeType.Le)
			{
				QilNode qilNode16 = qilNode2[0];
				QilNode qilNode17 = qilNode2[1];
				if (qilNode16.NodeType == QilNodeType.PositionOf)
				{
					QilNode qilNode18 = qilNode16[0];
					if (qilNode18 == qilNode && qilNode17.NodeType == QilNodeType.LiteralInt32)
					{
						int num2 = (int)((QilLiteral)qilNode17).Value;
						if (AllowReplace(XmlILOptimization.AnnotateMaxPositionLe, local0))
						{
							OptimizerPatterns.Write(qilNode).AddPattern(OptimizerPatternName.MaxPosition);
							OptimizerPatterns.Write(qilNode).AddArgument(OptimizerPatternArgument.ElementQName, num2);
						}
					}
				}
			}
			if (this[XmlILOptimization.AnnotateMaxPositionLt] && qilNode2.NodeType == QilNodeType.Lt)
			{
				QilNode qilNode19 = qilNode2[0];
				QilNode qilNode20 = qilNode2[1];
				if (qilNode19.NodeType == QilNodeType.PositionOf)
				{
					QilNode qilNode21 = qilNode19[0];
					if (qilNode21 == qilNode && qilNode20.NodeType == QilNodeType.LiteralInt32)
					{
						int num3 = (int)((QilLiteral)qilNode20).Value;
						if (AllowReplace(XmlILOptimization.AnnotateMaxPositionLt, local0))
						{
							OptimizerPatterns.Write(qilNode).AddPattern(OptimizerPatternName.MaxPosition);
							OptimizerPatterns.Write(qilNode).AddArgument(OptimizerPatternArgument.ElementQName, num3 - 1);
						}
					}
				}
			}
			if (this[XmlILOptimization.AnnotateFilter] && qilNode.NodeType == QilNodeType.For)
			{
				QilNode ndSrc = qilNode[0];
				if (AllowReplace(XmlILOptimization.AnnotateFilter, local0))
				{
					OptimizerPatterns.Inherit(ndSrc, local0, OptimizerPatternName.Step);
					OptimizerPatterns.Inherit(ndSrc, local0, OptimizerPatternName.IsDocOrderDistinct);
					OptimizerPatterns.Inherit(ndSrc, local0, OptimizerPatternName.SameDepth);
				}
			}
			if (this[XmlILOptimization.AnnotateFilterElements] && qilNode.NodeType == QilNodeType.For)
			{
				QilNode nd = qilNode[0];
				if (OptimizerPatterns.Read(nd).MatchesPattern(OptimizerPatternName.Axis) && qilNode2.NodeType == QilNodeType.And)
				{
					QilNode qilNode22 = qilNode2[0];
					QilNode qilNode23 = qilNode2[1];
					if (qilNode22.NodeType == QilNodeType.IsType)
					{
						QilNode qilNode24 = qilNode22[0];
						QilNode qilNode25 = qilNode22[1];
						if (qilNode24 == qilNode && qilNode25.NodeType == QilNodeType.LiteralType)
						{
							XmlQueryType xmlQueryType2 = (XmlQueryType)((QilLiteral)qilNode25).Value;
							if (xmlQueryType2 == XmlQueryTypeFactory.Element && qilNode23.NodeType == QilNodeType.Eq)
							{
								QilNode qilNode26 = qilNode23[0];
								QilNode qilNode27 = qilNode23[1];
								if (qilNode26.NodeType == QilNodeType.NameOf)
								{
									QilNode qilNode28 = qilNode26[0];
									if (qilNode28 == qilNode && qilNode27.NodeType == QilNodeType.LiteralQName && AllowReplace(XmlILOptimization.AnnotateFilterElements, local0))
									{
										OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.FilterElements);
										OptimizerPatterns.Write(local0).AddArgument(OptimizerPatternArgument.ElementQName, qilNode27);
									}
								}
							}
						}
					}
				}
			}
			if (this[XmlILOptimization.AnnotateFilterContentKind] && qilNode.NodeType == QilNodeType.For)
			{
				QilNode nd2 = qilNode[0];
				if (OptimizerPatterns.Read(nd2).MatchesPattern(OptimizerPatternName.Axis) && qilNode2.NodeType == QilNodeType.IsType)
				{
					QilNode qilNode29 = qilNode2[0];
					QilNode qilNode30 = qilNode2[1];
					if (qilNode29 == qilNode && qilNode30.NodeType == QilNodeType.LiteralType)
					{
						XmlQueryType xmlQueryType3 = (XmlQueryType)((QilLiteral)qilNode30).Value;
						if (MatchesContentTest(xmlQueryType3) && AllowReplace(XmlILOptimization.AnnotateFilterContentKind, local0))
						{
							OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.FilterContentKind);
							OptimizerPatterns.Write(local0).AddArgument(OptimizerPatternArgument.ElementQName, xmlQueryType3);
						}
					}
				}
			}
			if (this[XmlILOptimization.AnnotateFilterAttributeKind] && qilNode.NodeType == QilNodeType.For)
			{
				QilNode qilNode31 = qilNode[0];
				if (qilNode31.NodeType == QilNodeType.Content && qilNode2.NodeType == QilNodeType.IsType)
				{
					QilNode qilNode32 = qilNode2[0];
					QilNode qilNode33 = qilNode2[1];
					if (qilNode32 == qilNode && qilNode33.NodeType == QilNodeType.LiteralType)
					{
						XmlQueryType xmlQueryType4 = (XmlQueryType)((QilLiteral)qilNode33).Value;
						if (xmlQueryType4 == XmlQueryTypeFactory.Attribute && AllowReplace(XmlILOptimization.AnnotateFilterAttributeKind, local0))
						{
							OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.FilterAttributeKind);
						}
					}
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitSort(QilLoop local0)
		{
			QilNode qilNode = local0[0];
			_ = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode[0])));
			}
			if (this[XmlILOptimization.EliminateSort] && qilNode.NodeType == QilNodeType.For)
			{
				QilNode qilNode2 = qilNode[0];
				if (qilNode2.XmlType.IsSingleton && AllowReplace(XmlILOptimization.EliminateSort, local0))
				{
					return Replace(XmlILOptimization.EliminateSort, local0, VisitNop(f.Nop(qilNode2)));
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitSortKey(QilSortKey local0)
		{
			QilNode qilNode = local0[0];
			QilNode collation = local0[1];
			if (this[XmlILOptimization.NormalizeSortXsltConvert] && qilNode.NodeType == QilNodeType.XsltConvert)
			{
				QilNode qilNode2 = qilNode[0];
				QilNode qilNode3 = qilNode[1];
				if (qilNode3.NodeType == QilNodeType.LiteralType)
				{
					XmlQueryType xmlQueryType = (XmlQueryType)((QilLiteral)qilNode3).Value;
					if (qilNode2.XmlType == XmlQueryTypeFactory.IntX && xmlQueryType == XmlQueryTypeFactory.DoubleX && AllowReplace(XmlILOptimization.NormalizeSortXsltConvert, local0))
					{
						return Replace(XmlILOptimization.NormalizeSortXsltConvert, local0, VisitSortKey(f.SortKey(qilNode2, collation)));
					}
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitDocOrderDistinct(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.EliminateDod] && IsDocOrderDistinct(qilNode) && AllowReplace(XmlILOptimization.EliminateDod, local0))
			{
				return Replace(XmlILOptimization.EliminateDod, local0, qilNode);
			}
			if (this[XmlILOptimization.FoldNamedDescendants] && qilNode.NodeType == QilNodeType.Loop)
			{
				QilNode qilNode2 = qilNode[0];
				QilNode qilNode3 = qilNode[1];
				if (qilNode2.NodeType == QilNodeType.For)
				{
					QilNode qilNode4 = qilNode2[0];
					if (qilNode4.NodeType == QilNodeType.Loop)
					{
						QilNode variable = qilNode4[0];
						QilNode qilNode5 = qilNode4[1];
						if (qilNode5.NodeType == QilNodeType.DescendantOrSelf)
						{
							QilNode child = qilNode5[0];
							if (qilNode3.NodeType == QilNodeType.Filter)
							{
								QilNode refOld = qilNode3[0];
								QilNode expr = qilNode3[1];
								if ((OptimizerPatterns.Read(qilNode3).MatchesPattern(OptimizerPatternName.FilterElements) || OptimizerPatterns.Read(qilNode3).MatchesPattern(OptimizerPatternName.FilterContentKind)) && IsStepPattern(qilNode3, QilNodeType.Content) && AllowReplace(XmlILOptimization.FoldNamedDescendants, local0))
								{
									QilNode qilNode6 = VisitFor(f.For(VisitDescendant(f.Descendant(child))));
									return Replace(XmlILOptimization.FoldNamedDescendants, local0, VisitDocOrderDistinct(f.DocOrderDistinct(VisitLoop(f.Loop(variable, VisitFilter(f.Filter(qilNode6, Subs(expr, refOld, qilNode6))))))));
								}
							}
						}
					}
				}
			}
			if (this[XmlILOptimization.FoldNamedDescendants] && qilNode.NodeType == QilNodeType.Loop)
			{
				QilNode qilNode7 = qilNode[0];
				QilNode qilNode8 = qilNode[1];
				if (qilNode7.NodeType == QilNodeType.For)
				{
					QilNode qilNode9 = qilNode7[0];
					if (qilNode9.NodeType == QilNodeType.DescendantOrSelf)
					{
						QilNode child2 = qilNode9[0];
						if (qilNode8.NodeType == QilNodeType.Filter)
						{
							QilNode refOld2 = qilNode8[0];
							QilNode expr2 = qilNode8[1];
							if ((OptimizerPatterns.Read(qilNode8).MatchesPattern(OptimizerPatternName.FilterElements) || OptimizerPatterns.Read(qilNode8).MatchesPattern(OptimizerPatternName.FilterContentKind)) && IsStepPattern(qilNode8, QilNodeType.Content) && AllowReplace(XmlILOptimization.FoldNamedDescendants, local0))
							{
								QilNode qilNode10 = VisitFor(f.For(VisitDescendant(f.Descendant(child2))));
								return Replace(XmlILOptimization.FoldNamedDescendants, local0, VisitFilter(f.Filter(qilNode10, Subs(expr2, refOld2, qilNode10))));
							}
						}
					}
				}
			}
			if (this[XmlILOptimization.CommuteDodFilter] && qilNode.NodeType == QilNodeType.Filter)
			{
				QilNode qilNode11 = qilNode[0];
				QilNode expr3 = qilNode[1];
				if (qilNode11.NodeType == QilNodeType.For)
				{
					QilNode child3 = qilNode11[0];
					if (!OptimizerPatterns.Read(qilNode11).MatchesPattern(OptimizerPatternName.IsPositional) && !OptimizerPatterns.Read(qilNode).MatchesPattern(OptimizerPatternName.FilterElements) && !OptimizerPatterns.Read(qilNode).MatchesPattern(OptimizerPatternName.FilterContentKind) && !OptimizerPatterns.Read(qilNode).MatchesPattern(OptimizerPatternName.FilterAttributeKind) && AllowReplace(XmlILOptimization.CommuteDodFilter, local0))
					{
						QilNode qilNode12 = VisitFor(f.For(VisitDocOrderDistinct(f.DocOrderDistinct(child3))));
						return Replace(XmlILOptimization.CommuteDodFilter, local0, VisitFilter(f.Filter(qilNode12, Subs(expr3, qilNode11, qilNode12))));
					}
				}
			}
			if (this[XmlILOptimization.CommuteDodFilter] && qilNode.NodeType == QilNodeType.Loop)
			{
				QilNode qilNode13 = qilNode[0];
				QilNode qilNode14 = qilNode[1];
				if (qilNode14.NodeType == QilNodeType.Filter)
				{
					QilNode qilNode15 = qilNode14[0];
					QilNode expr4 = qilNode14[1];
					if (qilNode15.NodeType == QilNodeType.For)
					{
						QilNode body = qilNode15[0];
						if (!OptimizerPatterns.Read(qilNode15).MatchesPattern(OptimizerPatternName.IsPositional) && !DependsOn(expr4, qilNode13) && !OptimizerPatterns.Read(qilNode14).MatchesPattern(OptimizerPatternName.FilterElements) && !OptimizerPatterns.Read(qilNode14).MatchesPattern(OptimizerPatternName.FilterContentKind) && !OptimizerPatterns.Read(qilNode14).MatchesPattern(OptimizerPatternName.FilterAttributeKind) && AllowReplace(XmlILOptimization.CommuteDodFilter, local0))
						{
							QilNode qilNode16 = VisitFor(f.For(VisitDocOrderDistinct(f.DocOrderDistinct(VisitLoop(f.Loop(qilNode13, body))))));
							return Replace(XmlILOptimization.CommuteDodFilter, local0, VisitFilter(f.Filter(qilNode16, Subs(expr4, qilNode15, qilNode16))));
						}
					}
				}
			}
			if (this[XmlILOptimization.IntroduceDod] && qilNode.NodeType == QilNodeType.Loop)
			{
				QilNode qilNode17 = qilNode[0];
				QilNode expr5 = qilNode[1];
				if (qilNode17.NodeType == QilNodeType.For)
				{
					QilNode qilNode18 = qilNode17[0];
					if (!IsDocOrderDistinct(qilNode18) && !OptimizerPatterns.Read(qilNode17).MatchesPattern(OptimizerPatternName.IsPositional) && qilNode18.XmlType.IsSubtypeOf(XmlQueryTypeFactory.NodeNotRtfS) && !OptimizerPatterns.Read(qilNode).MatchesPattern(OptimizerPatternName.FilterElements) && !OptimizerPatterns.Read(qilNode).MatchesPattern(OptimizerPatternName.FilterContentKind) && !OptimizerPatterns.Read(qilNode).MatchesPattern(OptimizerPatternName.FilterAttributeKind) && AllowReplace(XmlILOptimization.IntroduceDod, local0))
					{
						QilNode qilNode19 = VisitFor(f.For(VisitDocOrderDistinct(f.DocOrderDistinct(qilNode18))));
						return Replace(XmlILOptimization.IntroduceDod, local0, VisitDocOrderDistinct(f.DocOrderDistinct(VisitLoop(f.Loop(qilNode19, Subs(expr5, qilNode17, qilNode19))))));
					}
				}
			}
			if (this[XmlILOptimization.IntroducePrecedingDod] && qilNode.NodeType == QilNodeType.Loop)
			{
				QilNode variable2 = qilNode[0];
				QilNode qilNode20 = qilNode[1];
				if (!IsDocOrderDistinct(qilNode20) && IsStepPattern(qilNode20, QilNodeType.PrecedingSibling) && AllowReplace(XmlILOptimization.IntroducePrecedingDod, local0))
				{
					return Replace(XmlILOptimization.IntroducePrecedingDod, local0, VisitDocOrderDistinct(f.DocOrderDistinct(VisitLoop(f.Loop(variable2, VisitDocOrderDistinct(f.DocOrderDistinct(qilNode20)))))));
				}
			}
			if (this[XmlILOptimization.EliminateReturnDod] && qilNode.NodeType == QilNodeType.Loop)
			{
				QilNode variable3 = qilNode[0];
				QilNode qilNode21 = qilNode[1];
				if (qilNode21.NodeType == QilNodeType.DocOrderDistinct)
				{
					QilNode qilNode22 = qilNode21[0];
					if (!IsStepPattern(qilNode22, QilNodeType.PrecedingSibling) && AllowReplace(XmlILOptimization.EliminateReturnDod, local0))
					{
						return Replace(XmlILOptimization.EliminateReturnDod, local0, VisitDocOrderDistinct(f.DocOrderDistinct(VisitLoop(f.Loop(variable3, qilNode22)))));
					}
				}
			}
			if (this[XmlILOptimization.AnnotateDod] && AllowReplace(XmlILOptimization.AnnotateDod, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.IsDocOrderDistinct);
				OptimizerPatterns.Inherit(qilNode, local0, OptimizerPatternName.SameDepth);
			}
			if (this[XmlILOptimization.AnnotateDodReverse] && AllowDodReverse(qilNode) && AllowReplace(XmlILOptimization.AnnotateDodReverse, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.DodReverse);
				OptimizerPatterns.Write(local0).AddArgument(OptimizerPatternArgument.ElementQName, qilNode);
			}
			if (this[XmlILOptimization.AnnotateJoinAndDod] && qilNode.NodeType == QilNodeType.Loop)
			{
				QilNode qilNode23 = qilNode[0];
				QilNode qilNode24 = qilNode[1];
				if (qilNode23.NodeType == QilNodeType.For)
				{
					QilNode nd = qilNode23[0];
					if (IsDocOrderDistinct(nd) && AllowJoinAndDod(qilNode24) && qilNode23 == OptimizerPatterns.Read(qilNode24).GetArgument(OptimizerPatternArgument.StepInput) && AllowReplace(XmlILOptimization.AnnotateJoinAndDod, local0))
					{
						OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.JoinAndDod);
						OptimizerPatterns.Write(local0).AddArgument(OptimizerPatternArgument.ElementQName, qilNode24);
					}
				}
			}
			if (this[XmlILOptimization.AnnotateDodMerge] && qilNode.NodeType == QilNodeType.Loop)
			{
				QilNode qilNode25 = qilNode[1];
				if (qilNode25.NodeType == QilNodeType.Invoke && IsDocOrderDistinct(qilNode25) && AllowReplace(XmlILOptimization.AnnotateDodMerge, local0))
				{
					OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.DodMerge);
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitFunction(QilFunction local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			_ = local0[2];
			_ = local0.XmlType;
			if (local0.XmlType.IsSubtypeOf(XmlQueryTypeFactory.NodeS) && this[XmlILOptimization.AnnotateIndex1] && qilNode.Count == 2 && qilNode[0].XmlType.IsSubtypeOf(XmlQueryTypeFactory.Node) && qilNode[1].XmlType == XmlQueryTypeFactory.StringX && qilNode2.NodeType == QilNodeType.Filter)
			{
				QilNode qilNode3 = qilNode2[0];
				QilNode qilNode4 = qilNode2[1];
				if (qilNode3.NodeType == QilNodeType.For)
				{
					QilNode expr = qilNode3[0];
					if (qilNode4.NodeType == QilNodeType.Not)
					{
						QilNode qilNode5 = qilNode4[0];
						if (qilNode5.NodeType == QilNodeType.IsEmpty)
						{
							QilNode qilNode6 = qilNode5[0];
							if (qilNode6.NodeType == QilNodeType.Filter)
							{
								QilNode qilNode7 = qilNode6[0];
								QilNode qilNode8 = qilNode6[1];
								if (qilNode7.NodeType == QilNodeType.For)
								{
									QilNode qilNode9 = qilNode7[0];
									if (qilNode8.NodeType == QilNodeType.Eq)
									{
										QilNode qilNode10 = qilNode8[0];
										QilNode qilNode11 = qilNode8[1];
										if (qilNode10 == qilNode7 && qilNode11.NodeType == QilNodeType.Parameter && qilNode11 == qilNode[1] && IsDocOrderDistinct(qilNode2) && AllowReplace(XmlILOptimization.AnnotateIndex1, local0))
										{
											EqualityIndexVisitor equalityIndexVisitor = new EqualityIndexVisitor();
											if (equalityIndexVisitor.Scan(expr, qilNode[0], qilNode11) && equalityIndexVisitor.Scan(qilNode9, qilNode[0], qilNode11))
											{
												OptimizerPatterns optimizerPatterns = OptimizerPatterns.Write(qilNode2);
												optimizerPatterns.AddPattern(OptimizerPatternName.EqualityIndex);
												optimizerPatterns.AddArgument(OptimizerPatternArgument.StepNode, qilNode3);
												optimizerPatterns.AddArgument(OptimizerPatternArgument.StepInput, qilNode9);
											}
										}
									}
								}
							}
						}
					}
				}
			}
			if (local0.XmlType.IsSubtypeOf(XmlQueryTypeFactory.NodeS) && this[XmlILOptimization.AnnotateIndex2] && qilNode.Count == 2 && qilNode[0].XmlType == XmlQueryTypeFactory.Node && qilNode[1].XmlType == XmlQueryTypeFactory.StringX && qilNode2.NodeType == QilNodeType.Filter)
			{
				QilNode qilNode12 = qilNode2[0];
				QilNode qilNode13 = qilNode2[1];
				if (qilNode12.NodeType == QilNodeType.For)
				{
					QilNode expr2 = qilNode12[0];
					if (qilNode13.NodeType == QilNodeType.Eq)
					{
						QilNode qilNode14 = qilNode13[0];
						QilNode qilNode15 = qilNode13[1];
						if (qilNode15.NodeType == QilNodeType.Parameter && qilNode15 == qilNode[1] && IsDocOrderDistinct(qilNode2) && AllowReplace(XmlILOptimization.AnnotateIndex2, local0))
						{
							EqualityIndexVisitor equalityIndexVisitor2 = new EqualityIndexVisitor();
							if (equalityIndexVisitor2.Scan(expr2, qilNode[0], qilNode15) && equalityIndexVisitor2.Scan(qilNode14, qilNode[0], qilNode15))
							{
								OptimizerPatterns optimizerPatterns2 = OptimizerPatterns.Write(qilNode2);
								optimizerPatterns2.AddPattern(OptimizerPatternName.EqualityIndex);
								optimizerPatterns2.AddArgument(OptimizerPatternArgument.StepNode, qilNode12);
								optimizerPatterns2.AddArgument(OptimizerPatternArgument.StepInput, qilNode14);
							}
						}
					}
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitInvoke(QilInvoke local0)
		{
			QilNode qilNode = local0[0];
			_ = local0[1];
			if (this[XmlILOptimization.NormalizeInvokeEmpty] && qilNode.NodeType == QilNodeType.Function)
			{
				QilNode qilNode2 = qilNode[1];
				if (qilNode2.NodeType == QilNodeType.Sequence && qilNode2.Count == 0 && AllowReplace(XmlILOptimization.NormalizeInvokeEmpty, local0))
				{
					return Replace(XmlILOptimization.NormalizeInvokeEmpty, local0, VisitSequence(f.Sequence()));
				}
			}
			if (this[XmlILOptimization.AnnotateTrackCallers] && AllowReplace(XmlILOptimization.AnnotateTrackCallers, local0))
			{
				XmlILConstructInfo.Write(qilNode).CallersInfo.Add(XmlILConstructInfo.Write(local0));
			}
			if (this[XmlILOptimization.AnnotateInvoke] && qilNode.NodeType == QilNodeType.Function)
			{
				QilNode ndSrc = qilNode[1];
				if (AllowReplace(XmlILOptimization.AnnotateInvoke, local0))
				{
					OptimizerPatterns.Inherit(ndSrc, local0, OptimizerPatternName.IsDocOrderDistinct);
					OptimizerPatterns.Inherit(ndSrc, local0, OptimizerPatternName.SameDepth);
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitContent(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.AnnotateContent] && AllowReplace(XmlILOptimization.AnnotateContent, local0))
			{
				AddStepPattern(local0, qilNode);
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.Axis);
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.IsDocOrderDistinct);
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.SameDepth);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitAttribute(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.AnnotateAttribute] && AllowReplace(XmlILOptimization.AnnotateAttribute, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.Axis);
				AddStepPattern(local0, qilNode);
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.IsDocOrderDistinct);
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.SameDepth);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitParent(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.AnnotateParent] && AllowReplace(XmlILOptimization.AnnotateParent, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.Axis);
				AddStepPattern(local0, qilNode);
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.IsDocOrderDistinct);
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.SameDepth);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitRoot(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.AnnotateRoot] && AllowReplace(XmlILOptimization.AnnotateRoot, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.Axis);
				AddStepPattern(local0, qilNode);
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.IsDocOrderDistinct);
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.SameDepth);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitDescendant(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.AnnotateDescendant] && AllowReplace(XmlILOptimization.AnnotateDescendant, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.Axis);
				AddStepPattern(local0, qilNode);
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.IsDocOrderDistinct);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitDescendantOrSelf(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.AnnotateDescendantSelf] && AllowReplace(XmlILOptimization.AnnotateDescendantSelf, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.Axis);
				AddStepPattern(local0, qilNode);
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.IsDocOrderDistinct);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitAncestor(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.AnnotateAncestor] && AllowReplace(XmlILOptimization.AnnotateAncestor, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.Axis);
				AddStepPattern(local0, qilNode);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitAncestorOrSelf(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.AnnotateAncestorSelf] && AllowReplace(XmlILOptimization.AnnotateAncestorSelf, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.Axis);
				AddStepPattern(local0, qilNode);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitPreceding(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.AnnotatePreceding] && AllowReplace(XmlILOptimization.AnnotatePreceding, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.Axis);
				AddStepPattern(local0, qilNode);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitFollowingSibling(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.AnnotateFollowingSibling] && AllowReplace(XmlILOptimization.AnnotateFollowingSibling, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.Axis);
				AddStepPattern(local0, qilNode);
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.IsDocOrderDistinct);
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.SameDepth);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitPrecedingSibling(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.AnnotatePrecedingSibling] && AllowReplace(XmlILOptimization.AnnotatePrecedingSibling, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.Axis);
				AddStepPattern(local0, qilNode);
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.SameDepth);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitNodeRange(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.AnnotateNodeRange] && AllowReplace(XmlILOptimization.AnnotateNodeRange, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.Axis);
				AddStepPattern(local0, qilNode);
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.IsDocOrderDistinct);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitDeref(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitElementCtor(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.AnnotateConstruction] && AllowReplace(XmlILOptimization.AnnotateConstruction, local0))
			{
				local0.Right = elemAnalyzer.Analyze(local0, qilNode2);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitAttributeCtor(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.AnnotateConstruction] && AllowReplace(XmlILOptimization.AnnotateConstruction, local0))
			{
				local0.Right = contentAnalyzer.Analyze(local0, qilNode2);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitCommentCtor(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.AnnotateConstruction] && AllowReplace(XmlILOptimization.AnnotateConstruction, local0))
			{
				local0.Child = contentAnalyzer.Analyze(local0, qilNode);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitPICtor(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.AnnotateConstruction] && AllowReplace(XmlILOptimization.AnnotateConstruction, local0))
			{
				local0.Right = contentAnalyzer.Analyze(local0, qilNode2);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitTextCtor(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.AnnotateConstruction] && AllowReplace(XmlILOptimization.AnnotateConstruction, local0))
			{
				contentAnalyzer.Analyze(local0, null);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitRawTextCtor(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.AnnotateConstruction] && AllowReplace(XmlILOptimization.AnnotateConstruction, local0))
			{
				contentAnalyzer.Analyze(local0, null);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitDocumentCtor(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.AnnotateConstruction] && AllowReplace(XmlILOptimization.AnnotateConstruction, local0))
			{
				local0.Child = contentAnalyzer.Analyze(local0, qilNode);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitNamespaceDecl(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (XmlILConstructInfo.Read(local0).IsNamespaceInScope && this[XmlILOptimization.EliminateNamespaceDecl] && AllowReplace(XmlILOptimization.EliminateNamespaceDecl, local0))
			{
				return Replace(XmlILOptimization.EliminateNamespaceDecl, local0, VisitSequence(f.Sequence()));
			}
			if (this[XmlILOptimization.AnnotateConstruction] && AllowReplace(XmlILOptimization.AnnotateConstruction, local0))
			{
				contentAnalyzer.Analyze(local0, null);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitRtfCtor(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			_ = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.AnnotateConstruction] && AllowReplace(XmlILOptimization.AnnotateConstruction, local0))
			{
				local0.Left = contentAnalyzer.Analyze(local0, qilNode);
			}
			if (this[XmlILOptimization.AnnotateSingleTextRtf] && qilNode.NodeType == QilNodeType.TextCtor)
			{
				QilNode arg = qilNode[0];
				if (AllowReplace(XmlILOptimization.AnnotateSingleTextRtf, local0))
				{
					OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.SingleTextRtf);
					OptimizerPatterns.Write(local0).AddArgument(OptimizerPatternArgument.ElementQName, arg);
					XmlILConstructInfo.Write(local0).PullFromIteratorFirst = true;
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitNameOf(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitLocalNameOf(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitNamespaceUriOf(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitPrefixOf(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitTypeAssert(QilTargetType local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.EliminateTypeAssert] && qilNode2.NodeType == QilNodeType.LiteralType)
			{
				XmlQueryType baseType = (XmlQueryType)((QilLiteral)qilNode2).Value;
				if (qilNode.XmlType.NeverSubtypeOf(baseType) && AllowReplace(XmlILOptimization.EliminateTypeAssert, local0))
				{
					return Replace(XmlILOptimization.EliminateTypeAssert, local0, VisitError(f.Error(VisitLiteralString(f.LiteralString(string.Empty)))));
				}
			}
			if (this[XmlILOptimization.EliminateTypeAssert] && qilNode2.NodeType == QilNodeType.LiteralType)
			{
				XmlQueryType xmlQueryType = (XmlQueryType)((QilLiteral)qilNode2).Value;
				if (qilNode.XmlType.Prime.NeverSubtypeOf(xmlQueryType.Prime) && AllowReplace(XmlILOptimization.EliminateTypeAssert, local0))
				{
					return Replace(XmlILOptimization.EliminateTypeAssert, local0, VisitConditional(f.Conditional(VisitIsEmpty(f.IsEmpty(qilNode)), VisitSequence(f.Sequence()), VisitError(f.Error(VisitLiteralString(f.LiteralString(string.Empty)))))));
				}
			}
			if (this[XmlILOptimization.EliminateTypeAssertOptional] && qilNode2.NodeType == QilNodeType.LiteralType)
			{
				XmlQueryType baseType2 = (XmlQueryType)((QilLiteral)qilNode2).Value;
				if (qilNode.XmlType.IsSubtypeOf(baseType2) && AllowReplace(XmlILOptimization.EliminateTypeAssertOptional, local0))
				{
					return Replace(XmlILOptimization.EliminateTypeAssertOptional, local0, qilNode);
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitIsType(QilTargetType local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.EliminateIsType] && !OptimizerPatterns.Read(qilNode).MatchesPattern(OptimizerPatternName.MaybeSideEffects) && qilNode2.NodeType == QilNodeType.LiteralType)
			{
				XmlQueryType baseType = (XmlQueryType)((QilLiteral)qilNode2).Value;
				if (qilNode.XmlType.IsSubtypeOf(baseType) && AllowReplace(XmlILOptimization.EliminateIsType, local0))
				{
					return Replace(XmlILOptimization.EliminateIsType, local0, VisitTrue(f.True()));
				}
			}
			if (this[XmlILOptimization.EliminateIsType] && !OptimizerPatterns.Read(qilNode).MatchesPattern(OptimizerPatternName.MaybeSideEffects) && qilNode2.NodeType == QilNodeType.LiteralType)
			{
				XmlQueryType baseType2 = (XmlQueryType)((QilLiteral)qilNode2).Value;
				if (qilNode.XmlType.NeverSubtypeOf(baseType2) && AllowReplace(XmlILOptimization.EliminateIsType, local0))
				{
					return Replace(XmlILOptimization.EliminateIsType, local0, VisitFalse(f.False()));
				}
			}
			if (this[XmlILOptimization.EliminateIsType] && qilNode2.NodeType == QilNodeType.LiteralType)
			{
				XmlQueryType xmlQueryType = (XmlQueryType)((QilLiteral)qilNode2).Value;
				if (qilNode.XmlType.Prime.NeverSubtypeOf(xmlQueryType.Prime) && AllowReplace(XmlILOptimization.EliminateIsType, local0))
				{
					return Replace(XmlILOptimization.EliminateIsType, local0, VisitIsEmpty(f.IsEmpty(qilNode)));
				}
			}
			if (this[XmlILOptimization.EliminateIsType] && OptimizerPatterns.Read(qilNode).MatchesPattern(OptimizerPatternName.MaybeSideEffects) && qilNode2.NodeType == QilNodeType.LiteralType)
			{
				XmlQueryType baseType3 = (XmlQueryType)((QilLiteral)qilNode2).Value;
				if (qilNode.XmlType.IsSubtypeOf(baseType3) && AllowReplace(XmlILOptimization.EliminateIsType, local0))
				{
					return Replace(XmlILOptimization.EliminateIsType, local0, VisitLoop(f.Loop(VisitLet(f.Let(qilNode)), VisitTrue(f.True()))));
				}
			}
			if (this[XmlILOptimization.EliminateIsType] && OptimizerPatterns.Read(qilNode).MatchesPattern(OptimizerPatternName.MaybeSideEffects) && qilNode2.NodeType == QilNodeType.LiteralType)
			{
				XmlQueryType baseType4 = (XmlQueryType)((QilLiteral)qilNode2).Value;
				if (qilNode.XmlType.NeverSubtypeOf(baseType4) && AllowReplace(XmlILOptimization.EliminateIsType, local0))
				{
					return Replace(XmlILOptimization.EliminateIsType, local0, VisitLoop(f.Loop(VisitLet(f.Let(qilNode)), VisitFalse(f.False()))));
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitIsEmpty(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.EliminateIsEmpty] && qilNode.NodeType == QilNodeType.Sequence && qilNode.Count == 0 && AllowReplace(XmlILOptimization.EliminateIsEmpty, local0))
			{
				return Replace(XmlILOptimization.EliminateIsEmpty, local0, VisitTrue(f.True()));
			}
			if (this[XmlILOptimization.EliminateIsEmpty] && !qilNode.XmlType.MaybeEmpty && !OptimizerPatterns.Read(qilNode).MatchesPattern(OptimizerPatternName.MaybeSideEffects) && AllowReplace(XmlILOptimization.EliminateIsEmpty, local0))
			{
				return Replace(XmlILOptimization.EliminateIsEmpty, local0, VisitFalse(f.False()));
			}
			if (this[XmlILOptimization.EliminateIsEmpty] && !qilNode.XmlType.MaybeEmpty && AllowReplace(XmlILOptimization.EliminateIsEmpty, local0))
			{
				return Replace(XmlILOptimization.EliminateIsEmpty, local0, VisitLoop(f.Loop(VisitLet(f.Let(qilNode)), VisitFalse(f.False()))));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitXPathNodeValue(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitXPathFollowing(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.AnnotateXPathFollowing] && AllowReplace(XmlILOptimization.AnnotateXPathFollowing, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.Axis);
				AddStepPattern(local0, qilNode);
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.IsDocOrderDistinct);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitXPathPreceding(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.AnnotateXPathPreceding] && AllowReplace(XmlILOptimization.AnnotateXPathPreceding, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.Axis);
				AddStepPattern(local0, qilNode);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitXPathNamespace(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.AnnotateNamespace] && AllowReplace(XmlILOptimization.AnnotateNamespace, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.Axis);
				AddStepPattern(local0, qilNode);
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.IsDocOrderDistinct);
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.SameDepth);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitXsltGenerateId(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitXsltCopy(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.AnnotateConstruction] && AllowReplace(XmlILOptimization.AnnotateConstruction, local0))
			{
				local0.Right = contentAnalyzer.Analyze(local0, qilNode2);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitXsltCopyOf(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.AnnotateConstruction] && AllowReplace(XmlILOptimization.AnnotateConstruction, local0))
			{
				contentAnalyzer.Analyze(local0, null);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitXsltConvert(QilTargetType local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldXsltConvertLiteral] && IsLiteral(qilNode) && qilNode2.NodeType == QilNodeType.LiteralType)
			{
				XmlQueryType typTarget = (XmlQueryType)((QilLiteral)qilNode2).Value;
				if (CanFoldXsltConvert(qilNode, typTarget) && AllowReplace(XmlILOptimization.FoldXsltConvertLiteral, local0))
				{
					return Replace(XmlILOptimization.FoldXsltConvertLiteral, local0, FoldXsltConvert(qilNode, typTarget));
				}
			}
			if (this[XmlILOptimization.EliminateXsltConvert] && qilNode2.NodeType == QilNodeType.LiteralType)
			{
				XmlQueryType xmlQueryType = (XmlQueryType)((QilLiteral)qilNode2).Value;
				if (qilNode.XmlType == xmlQueryType && AllowReplace(XmlILOptimization.EliminateXsltConvert, local0))
				{
					return Replace(XmlILOptimization.EliminateXsltConvert, local0, qilNode);
				}
			}
			return NoReplace(local0);
		}

		private bool DependsOn(QilNode expr, QilNode target)
		{
			return new NodeFinder().Find(expr, target);
		}

		protected bool NonPositional(QilNode expr, QilNode iter)
		{
			return !new PositionOfFinder().Find(expr, iter);
		}

		private QilNode Subs(QilNode expr, QilNode refOld, QilNode refNew)
		{
			subs.AddSubstitutionPair(refOld, refNew);
			QilNode result = ((!(expr is QilReference)) ? Visit(expr) : VisitReference(expr));
			subs.RemoveLastSubstitutionPair();
			return result;
		}

		private bool IsGlobalVariable(QilIterator iter)
		{
			return qil.GlobalVariableList.Contains(iter);
		}

		private bool IsPrimitiveNumeric(XmlQueryType typ)
		{
			if (typ == XmlQueryTypeFactory.IntX)
			{
				return true;
			}
			if (typ == XmlQueryTypeFactory.IntegerX)
			{
				return true;
			}
			if (typ == XmlQueryTypeFactory.DecimalX)
			{
				return true;
			}
			if (typ == XmlQueryTypeFactory.FloatX)
			{
				return true;
			}
			if (typ == XmlQueryTypeFactory.DoubleX)
			{
				return true;
			}
			return false;
		}

		private bool MatchesContentTest(XmlQueryType typ)
		{
			if (typ == XmlQueryTypeFactory.Element)
			{
				return true;
			}
			if (typ == XmlQueryTypeFactory.Text)
			{
				return true;
			}
			if (typ == XmlQueryTypeFactory.Comment)
			{
				return true;
			}
			if (typ == XmlQueryTypeFactory.PI)
			{
				return true;
			}
			if (typ == XmlQueryTypeFactory.Content)
			{
				return true;
			}
			return false;
		}

		private bool IsConstructedExpression(QilNode nd)
		{
			if (qil.IsDebug)
			{
				return true;
			}
			if (nd.XmlType.IsNode)
			{
				switch (nd.NodeType)
				{
				case QilNodeType.Choice:
				case QilNodeType.ElementCtor:
				case QilNodeType.AttributeCtor:
				case QilNodeType.CommentCtor:
				case QilNodeType.PICtor:
				case QilNodeType.TextCtor:
				case QilNodeType.RawTextCtor:
				case QilNodeType.DocumentCtor:
				case QilNodeType.NamespaceDecl:
				case QilNodeType.XsltCopy:
				case QilNodeType.XsltCopyOf:
					return true;
				case QilNodeType.Loop:
					return IsConstructedExpression(((QilLoop)nd).Body);
				case QilNodeType.Sequence:
					if (nd.Count == 0)
					{
						return true;
					}
					foreach (QilNode item in nd)
					{
						if (IsConstructedExpression(item))
						{
							return true;
						}
					}
					break;
				case QilNodeType.Conditional:
				{
					QilTernary qilTernary = (QilTernary)nd;
					if (!IsConstructedExpression(qilTernary.Center))
					{
						return IsConstructedExpression(qilTernary.Right);
					}
					return true;
				}
				case QilNodeType.Invoke:
					return !((QilInvoke)nd).Function.XmlType.IsAtomicValue;
				}
			}
			return false;
		}

		private bool IsLiteral(QilNode nd)
		{
			switch (nd.NodeType)
			{
			case QilNodeType.True:
			case QilNodeType.False:
			case QilNodeType.LiteralString:
			case QilNodeType.LiteralInt32:
			case QilNodeType.LiteralInt64:
			case QilNodeType.LiteralDouble:
			case QilNodeType.LiteralDecimal:
			case QilNodeType.LiteralQName:
				return true;
			default:
				return false;
			}
		}

		private bool AreLiteralArgs(QilNode nd)
		{
			foreach (QilNode item in nd)
			{
				if (!IsLiteral(item))
				{
					return false;
				}
			}
			return true;
		}

		private object ExtractLiteralValue(QilNode nd)
		{
			if (nd.NodeType == QilNodeType.True)
			{
				return true;
			}
			if (nd.NodeType == QilNodeType.False)
			{
				return false;
			}
			if (nd.NodeType == QilNodeType.LiteralQName)
			{
				return nd;
			}
			return ((QilLiteral)nd).Value;
		}

		private bool HasNestedSequence(QilNode nd)
		{
			foreach (QilNode item in nd)
			{
				if (item.NodeType == QilNodeType.Sequence)
				{
					return true;
				}
			}
			return false;
		}

		private bool AllowJoinAndDod(QilNode nd)
		{
			OptimizerPatterns optimizerPatterns = OptimizerPatterns.Read(nd);
			if ((optimizerPatterns.MatchesPattern(OptimizerPatternName.FilterElements) || optimizerPatterns.MatchesPattern(OptimizerPatternName.FilterContentKind)) && (IsStepPattern(optimizerPatterns, QilNodeType.DescendantOrSelf) || IsStepPattern(optimizerPatterns, QilNodeType.Descendant) || IsStepPattern(optimizerPatterns, QilNodeType.Content) || IsStepPattern(optimizerPatterns, QilNodeType.XPathPreceding) || IsStepPattern(optimizerPatterns, QilNodeType.XPathFollowing) || IsStepPattern(optimizerPatterns, QilNodeType.FollowingSibling)))
			{
				return true;
			}
			return false;
		}

		private bool AllowDodReverse(QilNode nd)
		{
			OptimizerPatterns optimizerPatterns = OptimizerPatterns.Read(nd);
			if ((optimizerPatterns.MatchesPattern(OptimizerPatternName.Axis) || optimizerPatterns.MatchesPattern(OptimizerPatternName.FilterElements) || optimizerPatterns.MatchesPattern(OptimizerPatternName.FilterContentKind)) && (IsStepPattern(optimizerPatterns, QilNodeType.Ancestor) || IsStepPattern(optimizerPatterns, QilNodeType.AncestorOrSelf) || IsStepPattern(optimizerPatterns, QilNodeType.XPathPreceding) || IsStepPattern(optimizerPatterns, QilNodeType.PrecedingSibling)))
			{
				return true;
			}
			return false;
		}

		private bool CanFoldXsltConvert(QilNode ndLiteral, XmlQueryType typTarget)
		{
			return FoldXsltConvert(ndLiteral, typTarget).NodeType != QilNodeType.XsltConvert;
		}

		private bool CanFoldXsltConvertNonLossy(QilNode ndLiteral, XmlQueryType typTarget)
		{
			QilNode qilNode = FoldXsltConvert(ndLiteral, typTarget);
			if (qilNode.NodeType == QilNodeType.XsltConvert)
			{
				return false;
			}
			qilNode = FoldXsltConvert(qilNode, ndLiteral.XmlType);
			if (qilNode.NodeType == QilNodeType.XsltConvert)
			{
				return false;
			}
			return ExtractLiteralValue(ndLiteral).Equals(ExtractLiteralValue(qilNode));
		}

		private QilNode FoldXsltConvert(QilNode ndLiteral, XmlQueryType typTarget)
		{
			try
			{
				if (typTarget.IsAtomicValue)
				{
					XmlAtomicValue value = new XmlAtomicValue(ndLiteral.XmlType.SchemaType, ExtractLiteralValue(ndLiteral));
					value = XsltConvert.ConvertToType(value, typTarget);
					if (typTarget == XmlQueryTypeFactory.StringX)
					{
						return f.LiteralString(value.Value);
					}
					if (typTarget == XmlQueryTypeFactory.IntX)
					{
						return f.LiteralInt32(value.ValueAsInt);
					}
					if (typTarget == XmlQueryTypeFactory.IntegerX)
					{
						return f.LiteralInt64(value.ValueAsLong);
					}
					if (typTarget == XmlQueryTypeFactory.DecimalX)
					{
						return f.LiteralDecimal((decimal)value.ValueAs(XsltConvert.DecimalType));
					}
					if (typTarget == XmlQueryTypeFactory.DoubleX)
					{
						return f.LiteralDouble(value.ValueAsDouble);
					}
					if (typTarget == XmlQueryTypeFactory.BooleanX)
					{
						return value.ValueAsBoolean ? f.True() : f.False();
					}
				}
			}
			catch (OverflowException)
			{
			}
			catch (FormatException)
			{
			}
			return f.XsltConvert(ndLiteral, typTarget);
		}

		private QilNode FoldComparison(QilNodeType opType, QilNode left, QilNode right)
		{
			object obj = ExtractLiteralValue(left);
			object obj2 = ExtractLiteralValue(right);
			if (left.NodeType == QilNodeType.LiteralDouble && (double.IsNaN((double)obj) || double.IsNaN((double)obj2)))
			{
				if (opType != QilNodeType.Ne)
				{
					return f.False();
				}
				return f.True();
			}
			switch (opType)
			{
			case QilNodeType.Eq:
				if (!obj.Equals(obj2))
				{
					return f.False();
				}
				return f.True();
			case QilNodeType.Ne:
				if (!obj.Equals(obj2))
				{
					return f.True();
				}
				return f.False();
			default:
			{
				int num = ((left.NodeType != QilNodeType.LiteralString) ? ((IComparable)obj).CompareTo(obj2) : string.CompareOrdinal((string)obj, (string)obj2));
				switch (opType)
				{
				case QilNodeType.Gt:
					if (num <= 0)
					{
						return f.False();
					}
					return f.True();
				case QilNodeType.Ge:
					if (num < 0)
					{
						return f.False();
					}
					return f.True();
				case QilNodeType.Lt:
					if (num >= 0)
					{
						return f.False();
					}
					return f.True();
				case QilNodeType.Le:
					if (num > 0)
					{
						return f.False();
					}
					return f.True();
				default:
					return null;
				}
			}
			}
		}

		private bool CanFoldArithmetic(QilNodeType opType, QilLiteral left, QilLiteral right)
		{
			return FoldArithmetic(opType, left, right) is QilLiteral;
		}

		private QilNode FoldArithmetic(QilNodeType opType, QilLiteral left, QilLiteral right)
		{
			checked
			{
				try
				{
					switch (left.NodeType)
					{
					case QilNodeType.LiteralInt32:
					{
						int num7 = left;
						int num8 = right;
						switch (opType)
						{
						case QilNodeType.Add:
							return f.LiteralInt32(num7 + num8);
						case QilNodeType.Subtract:
							return f.LiteralInt32(num7 - num8);
						case QilNodeType.Multiply:
							return f.LiteralInt32(num7 * num8);
						case QilNodeType.Divide:
							return f.LiteralInt32(unchecked(num7 / num8));
						case QilNodeType.Modulo:
							return f.LiteralInt32(unchecked(num7 % num8));
						}
						break;
					}
					case QilNodeType.LiteralInt64:
					{
						long num5 = left;
						long num6 = right;
						switch (opType)
						{
						case QilNodeType.Add:
							return f.LiteralInt64(num5 + num6);
						case QilNodeType.Subtract:
							return f.LiteralInt64(num5 - num6);
						case QilNodeType.Multiply:
							return f.LiteralInt64(num5 * num6);
						case QilNodeType.Divide:
							return f.LiteralInt64(unchecked(num5 / num6));
						case QilNodeType.Modulo:
							return f.LiteralInt64(unchecked(num5 % num6));
						}
						break;
					}
					case QilNodeType.LiteralDecimal:
					{
						decimal num3 = left;
						decimal num4 = right;
						switch (opType)
						{
						case QilNodeType.Add:
							return f.LiteralDecimal(num3 + num4);
						case QilNodeType.Subtract:
							return f.LiteralDecimal(num3 - num4);
						case QilNodeType.Multiply:
							return f.LiteralDecimal(num3 * num4);
						case QilNodeType.Divide:
							return f.LiteralDecimal(num3 / num4);
						case QilNodeType.Modulo:
							return f.LiteralDecimal(num3 % num4);
						}
						break;
					}
					case QilNodeType.LiteralDouble:
					{
						double num = left;
						double num2 = right;
						switch (opType)
						{
						case QilNodeType.Add:
							return f.LiteralDouble(num + num2);
						case QilNodeType.Subtract:
							return f.LiteralDouble(num - num2);
						case QilNodeType.Multiply:
							return f.LiteralDouble(num * num2);
						case QilNodeType.Divide:
							return f.LiteralDouble(num / num2);
						case QilNodeType.Modulo:
							return f.LiteralDouble(num % num2);
						}
						break;
					}
					}
				}
				catch (OverflowException)
				{
				}
				catch (DivideByZeroException)
				{
				}
				return opType switch
				{
					QilNodeType.Add => f.Add(left, right), 
					QilNodeType.Subtract => f.Subtract(left, right), 
					QilNodeType.Multiply => f.Multiply(left, right), 
					QilNodeType.Divide => f.Divide(left, right), 
					QilNodeType.Modulo => f.Modulo(left, right), 
					_ => null, 
				};
			}
		}

		private void AddStepPattern(QilNode nd, QilNode input)
		{
			OptimizerPatterns optimizerPatterns = OptimizerPatterns.Write(nd);
			optimizerPatterns.AddPattern(OptimizerPatternName.Step);
			optimizerPatterns.AddArgument(OptimizerPatternArgument.StepNode, nd);
			optimizerPatterns.AddArgument(OptimizerPatternArgument.StepInput, input);
		}

		private bool IsDocOrderDistinct(QilNode nd)
		{
			return OptimizerPatterns.Read(nd).MatchesPattern(OptimizerPatternName.IsDocOrderDistinct);
		}

		private bool IsStepPattern(QilNode nd, QilNodeType stepType)
		{
			return IsStepPattern(OptimizerPatterns.Read(nd), stepType);
		}

		private bool IsStepPattern(OptimizerPatterns patt, QilNodeType stepType)
		{
			if (patt.MatchesPattern(OptimizerPatternName.Step))
			{
				return ((QilNode)patt.GetArgument(OptimizerPatternArgument.StepNode)).NodeType == stepType;
			}
			return false;
		}
	}
	internal static class XmlILTrace
	{
		private const int MAX_REWRITES = 200;

		private static string dirName;

		private static bool alreadyCheckedEnabled;

		public static bool IsEnabled
		{
			get
			{
				if (!alreadyCheckedEnabled)
				{
					try
					{
						dirName = Environment.GetEnvironmentVariable("XmlILTrace");
					}
					catch (SecurityException)
					{
					}
					alreadyCheckedEnabled = true;
				}
				return dirName != null;
			}
		}

		public static void PrepareTraceWriter(string fileName)
		{
			if (IsEnabled)
			{
				File.Delete(dirName + "\\" + fileName);
			}
		}

		public static TextWriter GetTraceWriter(string fileName)
		{
			if (!IsEnabled)
			{
				return null;
			}
			return new StreamWriter(dirName + "\\" + fileName, append: true);
		}

		public static void WriteQil(QilExpression qil, string fileName)
		{
			if (!IsEnabled)
			{
				return;
			}
			XmlWriter xmlWriter = XmlWriter.Create(dirName + "\\" + fileName);
			try
			{
				WriteQil(qil, xmlWriter);
			}
			finally
			{
				xmlWriter.Close();
			}
		}

		public static void TraceOptimizations(QilExpression qil, string fileName)
		{
			if (!IsEnabled)
			{
				return;
			}
			XmlWriter xmlWriter = XmlWriter.Create(dirName + "\\" + fileName);
			xmlWriter.WriteStartDocument();
			xmlWriter.WriteProcessingInstruction("xml-stylesheet", "href='qilo.xslt' type='text/xsl'");
			xmlWriter.WriteStartElement("QilOptimizer");
			xmlWriter.WriteAttributeString("timestamp", DateTime.Now.ToString(CultureInfo.InvariantCulture));
			WriteQilRewrite(qil, xmlWriter, null);
			try
			{
				for (int i = 1; i < 200; i++)
				{
					QilExpression qilExpression = (QilExpression)new QilCloneVisitor(qil.Factory).Clone(qil);
					XmlILOptimizerVisitor xmlILOptimizerVisitor = new XmlILOptimizerVisitor(qilExpression, !qilExpression.IsDebug);
					xmlILOptimizerVisitor.Threshold = i;
					qilExpression = xmlILOptimizerVisitor.Optimize();
					WriteQilRewrite(qilExpression, xmlWriter, OptimizationToString(xmlILOptimizerVisitor.LastReplacement));
					if (xmlILOptimizerVisitor.ReplacementCount < i)
					{
						break;
					}
				}
			}
			catch (Exception ex)
			{
				if (!XmlException.IsCatchableException(ex))
				{
					throw;
				}
				xmlWriter.WriteElementString("Exception", null, ex.ToString());
				throw;
			}
			finally
			{
				xmlWriter.WriteEndElement();
				xmlWriter.WriteEndDocument();
				xmlWriter.Flush();
				xmlWriter.Close();
			}
		}

		private static void WriteQil(QilExpression qil, XmlWriter w)
		{
			QilXmlWriter qilXmlWriter = new QilXmlWriter(w);
			qilXmlWriter.ToXml(qil);
		}

		private static void WriteQilRewrite(QilExpression qil, XmlWriter w, string rewriteName)
		{
			w.WriteStartElement("Diff");
			if (rewriteName != null)
			{
				w.WriteAttributeString("rewrite", rewriteName);
			}
			WriteQil(qil, w);
			w.WriteEndElement();
		}

		private static string OptimizationToString(int opt)
		{
			string name = Enum.GetName(typeof(XmlILOptimization), opt);
			if (name.StartsWith("Introduce", StringComparison.Ordinal))
			{
				return name.Substring(9) + " introduction";
			}
			if (name.StartsWith("Eliminate", StringComparison.Ordinal))
			{
				return name.Substring(9) + " elimination";
			}
			if (name.StartsWith("Commute", StringComparison.Ordinal))
			{
				return name.Substring(7) + " commutation";
			}
			if (name.StartsWith("Fold", StringComparison.Ordinal))
			{
				return name.Substring(4) + " folding";
			}
			if (name.StartsWith("Misc", StringComparison.Ordinal))
			{
				return name.Substring(4);
			}
			return name;
		}
	}
	internal class XmlILTypeHelper
	{
		private static readonly Type[] TypeCodeToStorage = new Type[55]
		{
			typeof(XPathItem),
			typeof(XPathItem),
			typeof(XPathNavigator),
			typeof(XPathNavigator),
			typeof(XPathNavigator),
			typeof(XPathNavigator),
			typeof(XPathNavigator),
			typeof(XPathNavigator),
			typeof(XPathNavigator),
			typeof(XPathNavigator),
			typeof(XPathItem),
			typeof(string),
			typeof(string),
			typeof(bool),
			typeof(decimal),
			typeof(float),
			typeof(double),
			typeof(string),
			typeof(DateTime),
			typeof(DateTime),
			typeof(DateTime),
			typeof(DateTime),
			typeof(DateTime),
			typeof(DateTime),
			typeof(DateTime),
			typeof(DateTime),
			typeof(byte[]),
			typeof(byte[]),
			typeof(string),
			typeof(XmlQualifiedName),
			typeof(XmlQualifiedName),
			typeof(string),
			typeof(string),
			typeof(string),
			typeof(string),
			typeof(string),
			typeof(string),
			typeof(string),
			typeof(string),
			typeof(string),
			typeof(long),
			typeof(decimal),
			typeof(decimal),
			typeof(long),
			typeof(int),
			typeof(int),
			typeof(int),
			typeof(decimal),
			typeof(decimal),
			typeof(long),
			typeof(int),
			typeof(int),
			typeof(decimal),
			typeof(TimeSpan),
			typeof(TimeSpan)
		};

		private static readonly Type[] TypeCodeToCachedStorage = new Type[55]
		{
			typeof(IList<XPathItem>),
			typeof(IList<XPathItem>),
			typeof(IList<XPathNavigator>),
			typeof(IList<XPathNavigator>),
			typeof(IList<XPathNavigator>),
			typeof(IList<XPathNavigator>),
			typeof(IList<XPathNavigator>),
			typeof(IList<XPathNavigator>),
			typeof(IList<XPathNavigator>),
			typeof(IList<XPathNavigator>),
			typeof(IList<XPathItem>),
			typeof(IList<string>),
			typeof(IList<string>),
			typeof(IList<bool>),
			typeof(IList<decimal>),
			typeof(IList<float>),
			typeof(IList<double>),
			typeof(IList<string>),
			typeof(IList<DateTime>),
			typeof(IList<DateTime>),
			typeof(IList<DateTime>),
			typeof(IList<DateTime>),
			typeof(IList<DateTime>),
			typeof(IList<DateTime>),
			typeof(IList<DateTime>),
			typeof(IList<DateTime>),
			typeof(IList<byte[]>),
			typeof(IList<byte[]>),
			typeof(IList<string>),
			typeof(IList<XmlQualifiedName>),
			typeof(IList<XmlQualifiedName>),
			typeof(IList<string>),
			typeof(IList<string>),
			typeof(IList<string>),
			typeof(IList<string>),
			typeof(IList<string>),
			typeof(IList<string>),
			typeof(IList<string>),
			typeof(IList<string>),
			typeof(IList<string>),
			typeof(IList<long>),
			typeof(IList<decimal>),
			typeof(IList<decimal>),
			typeof(IList<long>),
			typeof(IList<int>),
			typeof(IList<int>),
			typeof(IList<int>),
			typeof(IList<decimal>),
			typeof(IList<decimal>),
			typeof(IList<long>),
			typeof(IList<int>),
			typeof(IList<int>),
			typeof(IList<decimal>),
			typeof(IList<TimeSpan>),
			typeof(IList<TimeSpan>)
		};

		private XmlILTypeHelper()
		{
		}

		public static Type GetStorageType(XmlQueryType qyTyp)
		{
			Type type;
			if (qyTyp.IsSingleton)
			{
				type = TypeCodeToStorage[(int)qyTyp.TypeCode];
				if (!qyTyp.IsStrict && type != typeof(XPathNavigator))
				{
					return typeof(XPathItem);
				}
			}
			else
			{
				type = TypeCodeToCachedStorage[(int)qyTyp.TypeCode];
				if (!qyTyp.IsStrict && type != typeof(IList<XPathNavigator>))
				{
					return typeof(IList<XPathItem>);
				}
			}
			return type;
		}
	}
}
namespace System.Xml.Xsl.Qil
{
	internal class QilNode : IList<QilNode>, ICollection<QilNode>, IEnumerable<QilNode>, IEnumerable
	{
		protected QilNodeType nodeType;

		protected XmlQueryType xmlType;

		protected ISourceLineInfo sourceLine;

		protected object annotation;

		public QilNodeType NodeType
		{
			get
			{
				return nodeType;
			}
			set
			{
				nodeType = value;
			}
		}

		public virtual XmlQueryType XmlType
		{
			get
			{
				return xmlType;
			}
			set
			{
				xmlType = value;
			}
		}

		public ISourceLineInfo SourceLine
		{
			get
			{
				return sourceLine;
			}
			set
			{
				sourceLine = value;
			}
		}

		public object Annotation
		{
			get
			{
				return annotation;
			}
			set
			{
				annotation = value;
			}
		}

		public virtual int Count => 0;

		public virtual QilNode this[int index]
		{
			get
			{
				throw new IndexOutOfRangeException();
			}
			set
			{
				throw new IndexOutOfRangeException();
			}
		}

		public virtual bool IsReadOnly => false;

		public QilNode(QilNodeType nodeType)
		{
			this.nodeType = nodeType;
		}

		public QilNode(QilNodeType nodeType, XmlQueryType xmlType)
		{
			this.nodeType = nodeType;
			this.xmlType = xmlType;
		}

		public virtual QilNode DeepClone(QilFactory f)
		{
			return new QilCloneVisitor(f).Clone(this);
		}

		public virtual QilNode ShallowClone(QilFactory f)
		{
			return (QilNode)MemberwiseClone();
		}

		public virtual void Insert(int index, QilNode node)
		{
			throw new NotSupportedException();
		}

		public virtual void RemoveAt(int index)
		{
			throw new NotSupportedException();
		}

		public IEnumerator<QilNode> GetEnumerator()
		{
			return new IListEnumerator<QilNode>(this);
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return new IListEnumerator<QilNode>(this);
		}

		public virtual void Add(QilNode node)
		{
			Insert(Count, node);
		}

		public virtual void Add(IList<QilNode> list)
		{
			for (int i = 0; i < list.Count; i++)
			{
				Insert(Count, list[i]);
			}
		}

		public virtual void Clear()
		{
			for (int num = Count - 1; num >= 0; num--)
			{
				RemoveAt(num);
			}
		}

		public virtual bool Contains(QilNode node)
		{
			return IndexOf(node) != -1;
		}

		public virtual void CopyTo(QilNode[] array, int index)
		{
			for (int i = 0; i < Count; i++)
			{
				array[index + i] = this[i];
			}
		}

		public virtual bool Remove(QilNode node)
		{
			int num = IndexOf(node);
			if (num >= 0)
			{
				RemoveAt(num);
				return true;
			}
			return false;
		}

		public virtual int IndexOf(QilNode node)
		{
			for (int i = 0; i < Count; i++)
			{
				if (node.Equals(this[i]))
				{
					return i;
				}
			}
			return -1;
		}
	}
	internal class QilBinary : QilNode
	{
		private QilNode left;

		private QilNode right;

		public override int Count => 2;

		public override QilNode this[int index]
		{
			get
			{
				return index switch
				{
					0 => left, 
					1 => right, 
					_ => throw new IndexOutOfRangeException(), 
				};
			}
			set
			{
				switch (index)
				{
				case 0:
					left = value;
					break;
				case 1:
					right = value;
					break;
				default:
					throw new IndexOutOfRangeException();
				}
			}
		}

		public QilNode Left
		{
			get
			{
				return left;
			}
			set
			{
				left = value;
			}
		}

		public QilNode Right
		{
			get
			{
				return right;
			}
			set
			{
				right = value;
			}
		}

		public QilBinary(QilNodeType nodeType, QilNode left, QilNode right)
			: base(nodeType)
		{
			this.left = left;
			this.right = right;
		}
	}
	internal class QilChoice : QilBinary
	{
		public QilNode Expression
		{
			get
			{
				return base.Left;
			}
			set
			{
				base.Left = value;
			}
		}

		public QilList Branches
		{
			get
			{
				return (QilList)base.Right;
			}
			set
			{
				base.Right = value;
			}
		}

		public QilChoice(QilNodeType nodeType, QilNode expression, QilNode branches)
			: base(nodeType, expression, branches)
		{
		}
	}
	internal class QilScopedVisitor : QilVisitor
	{
		protected virtual void BeginScope(QilNode node)
		{
		}

		protected virtual void EndScope(QilNode node)
		{
		}

		protected virtual void BeforeVisit(QilNode node)
		{
			switch (node.NodeType)
			{
			case QilNodeType.QilExpression:
			{
				QilExpression qilExpression = (QilExpression)node;
				foreach (QilNode globalParameter in qilExpression.GlobalParameterList)
				{
					BeginScope(globalParameter);
				}
				foreach (QilNode globalVariable in qilExpression.GlobalVariableList)
				{
					BeginScope(globalVariable);
				}
				{
					foreach (QilNode function in qilExpression.FunctionList)
					{
						BeginScope(function);
					}
					break;
				}
			}
			case QilNodeType.Function:
			{
				foreach (QilNode argument in ((QilFunction)node).Arguments)
				{
					BeginScope(argument);
				}
				break;
			}
			case QilNodeType.Loop:
			case QilNodeType.Filter:
			case QilNodeType.Sort:
				BeginScope(((QilLoop)node).Variable);
				break;
			}
		}

		protected virtual void AfterVisit(QilNode node)
		{
			switch (node.NodeType)
			{
			case QilNodeType.QilExpression:
			{
				QilExpression qilExpression = (QilExpression)node;
				foreach (QilNode function in qilExpression.FunctionList)
				{
					EndScope(function);
				}
				foreach (QilNode globalVariable in qilExpression.GlobalVariableList)
				{
					EndScope(globalVariable);
				}
				{
					foreach (QilNode globalParameter in qilExpression.GlobalParameterList)
					{
						EndScope(globalParameter);
					}
					break;
				}
			}
			case QilNodeType.Function:
			{
				foreach (QilNode argument in ((QilFunction)node).Arguments)
				{
					EndScope(argument);
				}
				break;
			}
			case QilNodeType.Loop:
			case QilNodeType.Filter:
			case QilNodeType.Sort:
				EndScope(((QilLoop)node).Variable);
				break;
			}
		}

		protected override QilNode Visit(QilNode n)
		{
			BeforeVisit(n);
			QilNode result = base.Visit(n);
			AfterVisit(n);
			return result;
		}
	}
	internal class QilCloneVisitor : QilScopedVisitor
	{
		private QilFactory fac;

		private SubstitutionList subs;

		public QilCloneVisitor(QilFactory fac)
			: this(fac, new SubstitutionList())
		{
		}

		public QilCloneVisitor(QilFactory fac, SubstitutionList subs)
		{
			this.fac = fac;
			this.subs = subs;
		}

		public QilNode Clone(QilNode node)
		{
			QilDepthChecker.Check(node);
			return VisitAssumeReference(node);
		}

		protected override QilNode Visit(QilNode oldNode)
		{
			QilNode qilNode = null;
			if (oldNode == null)
			{
				return null;
			}
			if (oldNode is QilReference)
			{
				qilNode = FindClonedReference(oldNode);
			}
			if (qilNode == null)
			{
				qilNode = oldNode.ShallowClone(fac);
			}
			return base.Visit(qilNode);
		}

		protected override QilNode VisitChildren(QilNode parent)
		{
			for (int i = 0; i < parent.Count; i++)
			{
				QilNode qilNode = parent[i];
				if (IsReference(parent, i))
				{
					parent[i] = VisitReference(qilNode);
					if (parent[i] == null)
					{
						parent[i] = qilNode;
					}
				}
				else
				{
					parent[i] = Visit(qilNode);
				}
			}
			return parent;
		}

		protected override QilNode VisitReference(QilNode oldNode)
		{
			QilNode qilNode = FindClonedReference(oldNode);
			return base.VisitReference((qilNode == null) ? oldNode : qilNode);
		}

		protected override void BeginScope(QilNode node)
		{
			subs.AddSubstitutionPair(node, node.ShallowClone(fac));
		}

		protected override void EndScope(QilNode node)
		{
			subs.RemoveLastSubstitutionPair();
		}

		protected QilNode FindClonedReference(QilNode node)
		{
			return subs.FindReplacement(node);
		}
	}
	internal class QilDataSource : QilBinary
	{
		public QilNode Name
		{
			get
			{
				return base.Left;
			}
			set
			{
				base.Left = value;
			}
		}

		public QilNode BaseUri
		{
			get
			{
				return base.Right;
			}
			set
			{
				base.Right = value;
			}
		}

		public QilDataSource(QilNodeType nodeType, QilNode name, QilNode baseUri)
			: base(nodeType, name, baseUri)
		{
		}
	}
	internal class QilExpression : QilNode
	{
		private QilFactory factory;

		private QilNode isDebug;

		private QilNode defWSet;

		private QilNode wsRules;

		private QilNode gloVars;

		private QilNode gloParams;

		private QilNode earlBnd;

		private QilNode funList;

		private QilNode rootNod;

		public override int Count => 8;

		public override QilNode this[int index]
		{
			get
			{
				return index switch
				{
					0 => isDebug, 
					1 => defWSet, 
					2 => wsRules, 
					3 => gloParams, 
					4 => gloVars, 
					5 => earlBnd, 
					6 => funList, 
					7 => rootNod, 
					_ => throw new IndexOutOfRangeException(), 
				};
			}
			set
			{
				switch (index)
				{
				case 0:
					isDebug = value;
					break;
				case 1:
					defWSet = value;
					break;
				case 2:
					wsRules = value;
					break;
				case 3:
					gloParams = value;
					break;
				case 4:
					gloVars = value;
					break;
				case 5:
					earlBnd = value;
					break;
				case 6:
					funList = value;
					break;
				case 7:
					rootNod = value;
					break;
				default:
					throw new IndexOutOfRangeException();
				}
			}
		}

		public QilFactory Factory
		{
			get
			{
				return factory;
			}
			set
			{
				factory = value;
			}
		}

		public bool IsDebug
		{
			get
			{
				return isDebug.NodeType == QilNodeType.True;
			}
			set
			{
				isDebug = (value ? factory.True() : factory.False());
			}
		}

		public XmlWriterSettings DefaultWriterSettings
		{
			get
			{
				return (XmlWriterSettings)((QilLiteral)defWSet).Value;
			}
			set
			{
				value.ReadOnly = true;
				((QilLiteral)defWSet).Value = value;
			}
		}

		public IList<WhitespaceRule> WhitespaceRules
		{
			get
			{
				return (IList<WhitespaceRule>)((QilLiteral)wsRules).Value;
			}
			set
			{
				((QilLiteral)wsRules).Value = value;
			}
		}

		public QilList GlobalParameterList
		{
			get
			{
				return (QilList)gloParams;
			}
			set
			{
				gloParams = value;
			}
		}

		public QilList GlobalVariableList
		{
			get
			{
				return (QilList)gloVars;
			}
			set
			{
				gloVars = value;
			}
		}

		public IList<EarlyBoundInfo> EarlyBoundTypes
		{
			get
			{
				return (IList<EarlyBoundInfo>)((QilLiteral)earlBnd).Value;
			}
			set
			{
				((QilLiteral)earlBnd).Value = value;
			}
		}

		public QilList FunctionList
		{
			get
			{
				return (QilList)funList;
			}
			set
			{
				funList = value;
			}
		}

		public QilNode Root
		{
			get
			{
				return rootNod;
			}
			set
			{
				rootNod = value;
			}
		}

		public QilExpression(QilNodeType nodeType, QilNode root)
			: this(nodeType, root, new QilFactory())
		{
		}

		public QilExpression(QilNodeType nodeType, QilNode root, QilFactory factory)
			: base(nodeType)
		{
			this.factory = factory;
			isDebug = factory.False();
			defWSet = factory.LiteralObject(new XmlWriterSettings
			{
				ConformanceLevel = ConformanceLevel.Auto
			});
			wsRules = factory.LiteralObject(new List<WhitespaceRule>());
			gloVars = factory.GlobalVariableList();
			gloParams = factory.GlobalParameterList();
			earlBnd = factory.LiteralObject(new List<EarlyBoundInfo>());
			funList = factory.FunctionList();
			rootNod = root;
		}
	}
	internal sealed class QilFactory
	{
		private QilTypeChecker typeCheck;

		public QilTypeChecker TypeChecker => typeCheck;

		public QilFactory()
		{
			typeCheck = new QilTypeChecker();
		}

		public QilExpression QilExpression(QilNode root, QilFactory factory)
		{
			QilExpression qilExpression = new QilExpression(QilNodeType.QilExpression, root, factory);
			qilExpression.XmlType = typeCheck.CheckQilExpression(qilExpression);
			return qilExpression;
		}

		public QilList FunctionList(IList<QilNode> values)
		{
			QilList qilList = FunctionList();
			qilList.Add(values);
			return qilList;
		}

		public QilList GlobalVariableList(IList<QilNode> values)
		{
			QilList qilList = GlobalVariableList();
			qilList.Add(values);
			return qilList;
		}

		public QilList GlobalParameterList(IList<QilNode> values)
		{
			QilList qilList = GlobalParameterList();
			qilList.Add(values);
			return qilList;
		}

		public QilList ActualParameterList(IList<QilNode> values)
		{
			QilList qilList = ActualParameterList();
			qilList.Add(values);
			return qilList;
		}

		public QilList FormalParameterList(IList<QilNode> values)
		{
			QilList qilList = FormalParameterList();
			qilList.Add(values);
			return qilList;
		}

		public QilList SortKeyList(IList<QilNode> values)
		{
			QilList qilList = SortKeyList();
			qilList.Add(values);
			return qilList;
		}

		public QilList BranchList(IList<QilNode> values)
		{
			QilList qilList = BranchList();
			qilList.Add(values);
			return qilList;
		}

		public QilList Sequence(IList<QilNode> values)
		{
			QilList qilList = Sequence();
			qilList.Add(values);
			return qilList;
		}

		public QilParameter Parameter(XmlQueryType xmlType)
		{
			return Parameter(null, null, xmlType);
		}

		public QilStrConcat StrConcat(QilNode values)
		{
			return StrConcat(LiteralString(""), values);
		}

		public QilName LiteralQName(string local)
		{
			return LiteralQName(local, string.Empty, string.Empty);
		}

		public QilTargetType TypeAssert(QilNode expr, XmlQueryType xmlType)
		{
			return TypeAssert(expr, (QilNode)LiteralType(xmlType));
		}

		public QilTargetType IsType(QilNode expr, XmlQueryType xmlType)
		{
			return IsType(expr, (QilNode)LiteralType(xmlType));
		}

		public QilTargetType XsltConvert(QilNode expr, XmlQueryType xmlType)
		{
			return XsltConvert(expr, (QilNode)LiteralType(xmlType));
		}

		public QilFunction Function(QilNode arguments, QilNode sideEffects, XmlQueryType xmlType)
		{
			return Function(arguments, Unknown(xmlType), sideEffects, xmlType);
		}

		public QilExpression QilExpression(QilNode root)
		{
			QilExpression qilExpression = new QilExpression(QilNodeType.QilExpression, root);
			qilExpression.XmlType = typeCheck.CheckQilExpression(qilExpression);
			return qilExpression;
		}

		public QilList FunctionList()
		{
			QilList qilList = new QilList(QilNodeType.FunctionList);
			qilList.XmlType = typeCheck.CheckFunctionList(qilList);
			return qilList;
		}

		public QilList GlobalVariableList()
		{
			QilList qilList = new QilList(QilNodeType.GlobalVariableList);
			qilList.XmlType = typeCheck.CheckGlobalVariableList(qilList);
			return qilList;
		}

		public QilList GlobalParameterList()
		{
			QilList qilList = new QilList(QilNodeType.GlobalParameterList);
			qilList.XmlType = typeCheck.CheckGlobalParameterList(qilList);
			return qilList;
		}

		public QilList ActualParameterList()
		{
			QilList qilList = new QilList(QilNodeType.ActualParameterList);
			qilList.XmlType = typeCheck.CheckActualParameterList(qilList);
			return qilList;
		}

		public QilList FormalParameterList()
		{
			QilList qilList = new QilList(QilNodeType.FormalParameterList);
			qilList.XmlType = typeCheck.CheckFormalParameterList(qilList);
			return qilList;
		}

		public QilList SortKeyList()
		{
			QilList qilList = new QilList(QilNodeType.SortKeyList);
			qilList.XmlType = typeCheck.CheckSortKeyList(qilList);
			return qilList;
		}

		public QilList BranchList()
		{
			QilList qilList = new QilList(QilNodeType.BranchList);
			qilList.XmlType = typeCheck.CheckBranchList(qilList);
			return qilList;
		}

		public QilUnary OptimizeBarrier(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.OptimizeBarrier, child);
			qilUnary.XmlType = typeCheck.CheckOptimizeBarrier(qilUnary);
			return qilUnary;
		}

		public QilNode Unknown(XmlQueryType xmlType)
		{
			QilNode qilNode = new QilNode(QilNodeType.Unknown, xmlType);
			qilNode.XmlType = typeCheck.CheckUnknown(qilNode);
			return qilNode;
		}

		public QilDataSource DataSource(QilNode name, QilNode baseUri)
		{
			QilDataSource qilDataSource = new QilDataSource(QilNodeType.DataSource, name, baseUri);
			qilDataSource.XmlType = typeCheck.CheckDataSource(qilDataSource);
			return qilDataSource;
		}

		public QilUnary Nop(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.Nop, child);
			qilUnary.XmlType = typeCheck.CheckNop(qilUnary);
			return qilUnary;
		}

		public QilUnary Error(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.Error, child);
			qilUnary.XmlType = typeCheck.CheckError(qilUnary);
			return qilUnary;
		}

		public QilUnary Warning(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.Warning, child);
			qilUnary.XmlType = typeCheck.CheckWarning(qilUnary);
			return qilUnary;
		}

		public QilIterator For(QilNode binding)
		{
			QilIterator qilIterator = new QilIterator(QilNodeType.For, binding);
			qilIterator.XmlType = typeCheck.CheckFor(qilIterator);
			return qilIterator;
		}

		public QilIterator Let(QilNode binding)
		{
			QilIterator qilIterator = new QilIterator(QilNodeType.Let, binding);
			qilIterator.XmlType = typeCheck.CheckLet(qilIterator);
			return qilIterator;
		}

		public QilParameter Parameter(QilNode defaultValue, QilNode name, XmlQueryType xmlType)
		{
			QilParameter qilParameter = new QilParameter(QilNodeType.Parameter, defaultValue, name, xmlType);
			qilParameter.XmlType = typeCheck.CheckParameter(qilParameter);
			return qilParameter;
		}

		public QilUnary PositionOf(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.PositionOf, child);
			qilUnary.XmlType = typeCheck.CheckPositionOf(qilUnary);
			return qilUnary;
		}

		public QilNode True()
		{
			QilNode qilNode = new QilNode(QilNodeType.True);
			qilNode.XmlType = typeCheck.CheckTrue(qilNode);
			return qilNode;
		}

		public QilNode False()
		{
			QilNode qilNode = new QilNode(QilNodeType.False);
			qilNode.XmlType = typeCheck.CheckFalse(qilNode);
			return qilNode;
		}

		public QilLiteral LiteralString(string value)
		{
			QilLiteral qilLiteral = new QilLiteral(QilNodeType.LiteralString, value);
			qilLiteral.XmlType = typeCheck.CheckLiteralString(qilLiteral);
			return qilLiteral;
		}

		public QilLiteral LiteralInt32(int value)
		{
			QilLiteral qilLiteral = new QilLiteral(QilNodeType.LiteralInt32, value);
			qilLiteral.XmlType = typeCheck.CheckLiteralInt32(qilLiteral);
			return qilLiteral;
		}

		public QilLiteral LiteralInt64(long value)
		{
			QilLiteral qilLiteral = new QilLiteral(QilNodeType.LiteralInt64, value);
			qilLiteral.XmlType = typeCheck.CheckLiteralInt64(qilLiteral);
			return qilLiteral;
		}

		public QilLiteral LiteralDouble(double value)
		{
			QilLiteral qilLiteral = new QilLiteral(QilNodeType.LiteralDouble, value);
			qilLiteral.XmlType = typeCheck.CheckLiteralDouble(qilLiteral);
			return qilLiteral;
		}

		public QilLiteral LiteralDecimal(decimal value)
		{
			QilLiteral qilLiteral = new QilLiteral(QilNodeType.LiteralDecimal, value);
			qilLiteral.XmlType = typeCheck.CheckLiteralDecimal(qilLiteral);
			return qilLiteral;
		}

		public QilName LiteralQName(string localName, string namespaceUri, string prefix)
		{
			QilName qilName = new QilName(QilNodeType.LiteralQName, localName, namespaceUri, prefix);
			qilName.XmlType = typeCheck.CheckLiteralQName(qilName);
			return qilName;
		}

		public QilLiteral LiteralType(XmlQueryType value)
		{
			QilLiteral qilLiteral = new QilLiteral(QilNodeType.LiteralType, value);
			qilLiteral.XmlType = typeCheck.CheckLiteralType(qilLiteral);
			return qilLiteral;
		}

		public QilLiteral LiteralObject(object value)
		{
			QilLiteral qilLiteral = new QilLiteral(QilNodeType.LiteralObject, value);
			qilLiteral.XmlType = typeCheck.CheckLiteralObject(qilLiteral);
			return qilLiteral;
		}

		public QilBinary And(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.And, left, right);
			qilBinary.XmlType = typeCheck.CheckAnd(qilBinary);
			return qilBinary;
		}

		public QilBinary Or(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.Or, left, right);
			qilBinary.XmlType = typeCheck.CheckOr(qilBinary);
			return qilBinary;
		}

		public QilUnary Not(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.Not, child);
			qilUnary.XmlType = typeCheck.CheckNot(qilUnary);
			return qilUnary;
		}

		public QilTernary Conditional(QilNode left, QilNode center, QilNode right)
		{
			QilTernary qilTernary = new QilTernary(QilNodeType.Conditional, left, center, right);
			qilTernary.XmlType = typeCheck.CheckConditional(qilTernary);
			return qilTernary;
		}

		public QilChoice Choice(QilNode expression, QilNode branches)
		{
			QilChoice qilChoice = new QilChoice(QilNodeType.Choice, expression, branches);
			qilChoice.XmlType = typeCheck.CheckChoice(qilChoice);
			return qilChoice;
		}

		public QilUnary Length(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.Length, child);
			qilUnary.XmlType = typeCheck.CheckLength(qilUnary);
			return qilUnary;
		}

		public QilList Sequence()
		{
			QilList qilList = new QilList(QilNodeType.Sequence);
			qilList.XmlType = typeCheck.CheckSequence(qilList);
			return qilList;
		}

		public QilBinary Union(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.Union, left, right);
			qilBinary.XmlType = typeCheck.CheckUnion(qilBinary);
			return qilBinary;
		}

		public QilBinary Intersection(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.Intersection, left, right);
			qilBinary.XmlType = typeCheck.CheckIntersection(qilBinary);
			return qilBinary;
		}

		public QilBinary Difference(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.Difference, left, right);
			qilBinary.XmlType = typeCheck.CheckDifference(qilBinary);
			return qilBinary;
		}

		public QilUnary Average(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.Average, child);
			qilUnary.XmlType = typeCheck.CheckAverage(qilUnary);
			return qilUnary;
		}

		public QilUnary Sum(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.Sum, child);
			qilUnary.XmlType = typeCheck.CheckSum(qilUnary);
			return qilUnary;
		}

		public QilUnary Minimum(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.Minimum, child);
			qilUnary.XmlType = typeCheck.CheckMinimum(qilUnary);
			return qilUnary;
		}

		public QilUnary Maximum(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.Maximum, child);
			qilUnary.XmlType = typeCheck.CheckMaximum(qilUnary);
			return qilUnary;
		}

		public QilUnary Negate(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.Negate, child);
			qilUnary.XmlType = typeCheck.CheckNegate(qilUnary);
			return qilUnary;
		}

		public QilBinary Add(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.Add, left, right);
			qilBinary.XmlType = typeCheck.CheckAdd(qilBinary);
			return qilBinary;
		}

		public QilBinary Subtract(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.Subtract, left, right);
			qilBinary.XmlType = typeCheck.CheckSubtract(qilBinary);
			return qilBinary;
		}

		public QilBinary Multiply(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.Multiply, left, right);
			qilBinary.XmlType = typeCheck.CheckMultiply(qilBinary);
			return qilBinary;
		}

		public QilBinary Divide(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.Divide, left, right);
			qilBinary.XmlType = typeCheck.CheckDivide(qilBinary);
			return qilBinary;
		}

		public QilBinary Modulo(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.Modulo, left, right);
			qilBinary.XmlType = typeCheck.CheckModulo(qilBinary);
			return qilBinary;
		}

		public QilUnary StrLength(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.StrLength, child);
			qilUnary.XmlType = typeCheck.CheckStrLength(qilUnary);
			return qilUnary;
		}

		public QilStrConcat StrConcat(QilNode delimiter, QilNode values)
		{
			QilStrConcat qilStrConcat = new QilStrConcat(QilNodeType.StrConcat, delimiter, values);
			qilStrConcat.XmlType = typeCheck.CheckStrConcat(qilStrConcat);
			return qilStrConcat;
		}

		public QilBinary StrParseQName(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.StrParseQName, left, right);
			qilBinary.XmlType = typeCheck.CheckStrParseQName(qilBinary);
			return qilBinary;
		}

		public QilBinary Ne(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.Ne, left, right);
			qilBinary.XmlType = typeCheck.CheckNe(qilBinary);
			return qilBinary;
		}

		public QilBinary Eq(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.Eq, left, right);
			qilBinary.XmlType = typeCheck.CheckEq(qilBinary);
			return qilBinary;
		}

		public QilBinary Gt(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.Gt, left, right);
			qilBinary.XmlType = typeCheck.CheckGt(qilBinary);
			return qilBinary;
		}

		public QilBinary Ge(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.Ge, left, right);
			qilBinary.XmlType = typeCheck.CheckGe(qilBinary);
			return qilBinary;
		}

		public QilBinary Lt(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.Lt, left, right);
			qilBinary.XmlType = typeCheck.CheckLt(qilBinary);
			return qilBinary;
		}

		public QilBinary Le(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.Le, left, right);
			qilBinary.XmlType = typeCheck.CheckLe(qilBinary);
			return qilBinary;
		}

		public QilBinary Is(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.Is, left, right);
			qilBinary.XmlType = typeCheck.CheckIs(qilBinary);
			return qilBinary;
		}

		public QilBinary After(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.After, left, right);
			qilBinary.XmlType = typeCheck.CheckAfter(qilBinary);
			return qilBinary;
		}

		public QilBinary Before(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.Before, left, right);
			qilBinary.XmlType = typeCheck.CheckBefore(qilBinary);
			return qilBinary;
		}

		public QilLoop Loop(QilNode variable, QilNode body)
		{
			QilLoop qilLoop = new QilLoop(QilNodeType.Loop, variable, body);
			qilLoop.XmlType = typeCheck.CheckLoop(qilLoop);
			return qilLoop;
		}

		public QilLoop Filter(QilNode variable, QilNode body)
		{
			QilLoop qilLoop = new QilLoop(QilNodeType.Filter, variable, body);
			qilLoop.XmlType = typeCheck.CheckFilter(qilLoop);
			return qilLoop;
		}

		public QilLoop Sort(QilNode variable, QilNode body)
		{
			QilLoop qilLoop = new QilLoop(QilNodeType.Sort, variable, body);
			qilLoop.XmlType = typeCheck.CheckSort(qilLoop);
			return qilLoop;
		}

		public QilSortKey SortKey(QilNode key, QilNode collation)
		{
			QilSortKey qilSortKey = new QilSortKey(QilNodeType.SortKey, key, collation);
			qilSortKey.XmlType = typeCheck.CheckSortKey(qilSortKey);
			return qilSortKey;
		}

		public QilUnary DocOrderDistinct(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.DocOrderDistinct, child);
			qilUnary.XmlType = typeCheck.CheckDocOrderDistinct(qilUnary);
			return qilUnary;
		}

		public QilFunction Function(QilNode arguments, QilNode definition, QilNode sideEffects, XmlQueryType xmlType)
		{
			QilFunction qilFunction = new QilFunction(QilNodeType.Function, arguments, definition, sideEffects, xmlType);
			qilFunction.XmlType = typeCheck.CheckFunction(qilFunction);
			return qilFunction;
		}

		public QilInvoke Invoke(QilNode function, QilNode arguments)
		{
			QilInvoke qilInvoke = new QilInvoke(QilNodeType.Invoke, function, arguments);
			qilInvoke.XmlType = typeCheck.CheckInvoke(qilInvoke);
			return qilInvoke;
		}

		public QilUnary Content(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.Content, child);
			qilUnary.XmlType = typeCheck.CheckContent(qilUnary);
			return qilUnary;
		}

		public QilBinary Attribute(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.Attribute, left, right);
			qilBinary.XmlType = typeCheck.CheckAttribute(qilBinary);
			return qilBinary;
		}

		public QilUnary Parent(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.Parent, child);
			qilUnary.XmlType = typeCheck.CheckParent(qilUnary);
			return qilUnary;
		}

		public QilUnary Root(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.Root, child);
			qilUnary.XmlType = typeCheck.CheckRoot(qilUnary);
			return qilUnary;
		}

		public QilNode XmlContext()
		{
			QilNode qilNode = new QilNode(QilNodeType.XmlContext);
			qilNode.XmlType = typeCheck.CheckXmlContext(qilNode);
			return qilNode;
		}

		public QilUnary Descendant(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.Descendant, child);
			qilUnary.XmlType = typeCheck.CheckDescendant(qilUnary);
			return qilUnary;
		}

		public QilUnary DescendantOrSelf(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.DescendantOrSelf, child);
			qilUnary.XmlType = typeCheck.CheckDescendantOrSelf(qilUnary);
			return qilUnary;
		}

		public QilUnary Ancestor(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.Ancestor, child);
			qilUnary.XmlType = typeCheck.CheckAncestor(qilUnary);
			return qilUnary;
		}

		public QilUnary AncestorOrSelf(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.AncestorOrSelf, child);
			qilUnary.XmlType = typeCheck.CheckAncestorOrSelf(qilUnary);
			return qilUnary;
		}

		public QilUnary Preceding(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.Preceding, child);
			qilUnary.XmlType = typeCheck.CheckPreceding(qilUnary);
			return qilUnary;
		}

		public QilUnary FollowingSibling(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.FollowingSibling, child);
			qilUnary.XmlType = typeCheck.CheckFollowingSibling(qilUnary);
			return qilUnary;
		}

		public QilUnary PrecedingSibling(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.PrecedingSibling, child);
			qilUnary.XmlType = typeCheck.CheckPrecedingSibling(qilUnary);
			return qilUnary;
		}

		public QilBinary NodeRange(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.NodeRange, left, right);
			qilBinary.XmlType = typeCheck.CheckNodeRange(qilBinary);
			return qilBinary;
		}

		public QilBinary Deref(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.Deref, left, right);
			qilBinary.XmlType = typeCheck.CheckDeref(qilBinary);
			return qilBinary;
		}

		public QilBinary ElementCtor(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.ElementCtor, left, right);
			qilBinary.XmlType = typeCheck.CheckElementCtor(qilBinary);
			return qilBinary;
		}

		public QilBinary AttributeCtor(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.AttributeCtor, left, right);
			qilBinary.XmlType = typeCheck.CheckAttributeCtor(qilBinary);
			return qilBinary;
		}

		public QilUnary CommentCtor(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.CommentCtor, child);
			qilUnary.XmlType = typeCheck.CheckCommentCtor(qilUnary);
			return qilUnary;
		}

		public QilBinary PICtor(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.PICtor, left, right);
			qilBinary.XmlType = typeCheck.CheckPICtor(qilBinary);
			return qilBinary;
		}

		public QilUnary TextCtor(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.TextCtor, child);
			qilUnary.XmlType = typeCheck.CheckTextCtor(qilUnary);
			return qilUnary;
		}

		public QilUnary RawTextCtor(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.RawTextCtor, child);
			qilUnary.XmlType = typeCheck.CheckRawTextCtor(qilUnary);
			return qilUnary;
		}

		public QilUnary DocumentCtor(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.DocumentCtor, child);
			qilUnary.XmlType = typeCheck.CheckDocumentCtor(qilUnary);
			return qilUnary;
		}

		public QilBinary NamespaceDecl(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.NamespaceDecl, left, right);
			qilBinary.XmlType = typeCheck.CheckNamespaceDecl(qilBinary);
			return qilBinary;
		}

		public QilBinary RtfCtor(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.RtfCtor, left, right);
			qilBinary.XmlType = typeCheck.CheckRtfCtor(qilBinary);
			return qilBinary;
		}

		public QilUnary NameOf(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.NameOf, child);
			qilUnary.XmlType = typeCheck.CheckNameOf(qilUnary);
			return qilUnary;
		}

		public QilUnary LocalNameOf(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.LocalNameOf, child);
			qilUnary.XmlType = typeCheck.CheckLocalNameOf(qilUnary);
			return qilUnary;
		}

		public QilUnary NamespaceUriOf(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.NamespaceUriOf, child);
			qilUnary.XmlType = typeCheck.CheckNamespaceUriOf(qilUnary);
			return qilUnary;
		}

		public QilUnary PrefixOf(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.PrefixOf, child);
			qilUnary.XmlType = typeCheck.CheckPrefixOf(qilUnary);
			return qilUnary;
		}

		public QilTargetType TypeAssert(QilNode source, QilNode targetType)
		{
			QilTargetType qilTargetType = new QilTargetType(QilNodeType.TypeAssert, source, targetType);
			qilTargetType.XmlType = typeCheck.CheckTypeAssert(qilTargetType);
			return qilTargetType;
		}

		public QilTargetType IsType(QilNode source, QilNode targetType)
		{
			QilTargetType qilTargetType = new QilTargetType(QilNodeType.IsType, source, targetType);
			qilTargetType.XmlType = typeCheck.CheckIsType(qilTargetType);
			return qilTargetType;
		}

		public QilUnary IsEmpty(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.IsEmpty, child);
			qilUnary.XmlType = typeCheck.CheckIsEmpty(qilUnary);
			return qilUnary;
		}

		public QilUnary XPathNodeValue(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.XPathNodeValue, child);
			qilUnary.XmlType = typeCheck.CheckXPathNodeValue(qilUnary);
			return qilUnary;
		}

		public QilUnary XPathFollowing(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.XPathFollowing, child);
			qilUnary.XmlType = typeCheck.CheckXPathFollowing(qilUnary);
			return qilUnary;
		}

		public QilUnary XPathPreceding(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.XPathPreceding, child);
			qilUnary.XmlType = typeCheck.CheckXPathPreceding(qilUnary);
			return qilUnary;
		}

		public QilUnary XPathNamespace(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.XPathNamespace, child);
			qilUnary.XmlType = typeCheck.CheckXPathNamespace(qilUnary);
			return qilUnary;
		}

		public QilUnary XsltGenerateId(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.XsltGenerateId, child);
			qilUnary.XmlType = typeCheck.CheckXsltGenerateId(qilUnary);
			return qilUnary;
		}

		public QilInvokeLateBound XsltInvokeLateBound(QilNode name, QilNode arguments)
		{
			QilInvokeLateBound qilInvokeLateBound = new QilInvokeLateBound(QilNodeType.XsltInvokeLateBound, name, arguments);
			qilInvokeLateBound.XmlType = typeCheck.CheckXsltInvokeLateBound(qilInvokeLateBound);
			return qilInvokeLateBound;
		}

		public QilInvokeEarlyBound XsltInvokeEarlyBound(QilNode name, QilNode clrMethod, QilNode arguments, XmlQueryType xmlType)
		{
			QilInvokeEarlyBound qilInvokeEarlyBound = new QilInvokeEarlyBound(QilNodeType.XsltInvokeEarlyBound, name, clrMethod, arguments, xmlType);
			qilInvokeEarlyBound.XmlType = typeCheck.CheckXsltInvokeEarlyBound(qilInvokeEarlyBound);
			return qilInvokeEarlyBound;
		}

		public QilBinary XsltCopy(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.XsltCopy, left, right);
			qilBinary.XmlType = typeCheck.CheckXsltCopy(qilBinary);
			return qilBinary;
		}

		public QilUnary XsltCopyOf(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.XsltCopyOf, child);
			qilUnary.XmlType = typeCheck.CheckXsltCopyOf(qilUnary);
			return qilUnary;
		}

		public QilTargetType XsltConvert(QilNode source, QilNode targetType)
		{
			QilTargetType qilTargetType = new QilTargetType(QilNodeType.XsltConvert, source, targetType);
			qilTargetType.XmlType = typeCheck.CheckXsltConvert(qilTargetType);
			return qilTargetType;
		}

		[Conditional("QIL_TRACE_NODE_CREATION")]
		public void TraceNode(QilNode n)
		{
		}
	}
	internal class QilReference : QilNode
	{
		private const int MaxDebugNameLength = 1023;

		private string debugName;

		public string DebugName
		{
			get
			{
				return debugName;
			}
			set
			{
				if (value.Length > 1023)
				{
					value = value.Substring(0, 1023);
				}
				debugName = value;
			}
		}

		public QilReference(QilNodeType nodeType)
			: base(nodeType)
		{
		}
	}
	internal class QilFunction : QilReference
	{
		private QilNode arguments;

		private QilNode definition;

		private QilNode sideEffects;

		public override int Count => 3;

		public override QilNode this[int index]
		{
			get
			{
				return index switch
				{
					0 => arguments, 
					1 => definition, 
					2 => sideEffects, 
					_ => throw new IndexOutOfRangeException(), 
				};
			}
			set
			{
				switch (index)
				{
				case 0:
					arguments = value;
					break;
				case 1:
					definition = value;
					break;
				case 2:
					sideEffects = value;
					break;
				default:
					throw new IndexOutOfRangeException();
				}
			}
		}

		public QilList Arguments
		{
			get
			{
				return (QilList)arguments;
			}
			set
			{
				arguments = value;
			}
		}

		public QilNode Definition
		{
			get
			{
				return definition;
			}
			set
			{
				definition = value;
			}
		}

		public bool MaybeSideEffects
		{
			get
			{
				return sideEffects.NodeType == QilNodeType.True;
			}
			set
			{
				sideEffects.NodeType = (value ? QilNodeType.True : QilNodeType.False);
			}
		}

		public QilFunction(QilNodeType nodeType, QilNode arguments, QilNode definition, QilNode sideEffects, XmlQueryType resultType)
			: base(nodeType)
		{
			this.arguments = arguments;
			this.definition = definition;
			this.sideEffects = sideEffects;
			xmlType = resultType;
		}
	}
	internal class QilInvoke : QilBinary
	{
		public QilFunction Function
		{
			get
			{
				return (QilFunction)base.Left;
			}
			set
			{
				base.Left = value;
			}
		}

		public QilList Arguments
		{
			get
			{
				return (QilList)base.Right;
			}
			set
			{
				base.Right = value;
			}
		}

		public QilInvoke(QilNodeType nodeType, QilNode function, QilNode arguments)
			: base(nodeType, function, arguments)
		{
		}
	}
	internal class QilTernary : QilNode
	{
		private QilNode left;

		private QilNode center;

		private QilNode right;

		public override int Count => 3;

		public override QilNode this[int index]
		{
			get
			{
				return index switch
				{
					0 => left, 
					1 => center, 
					2 => right, 
					_ => throw new IndexOutOfRangeException(), 
				};
			}
			set
			{
				switch (index)
				{
				case 0:
					left = value;
					break;
				case 1:
					center = value;
					break;
				case 2:
					right = value;
					break;
				default:
					throw new IndexOutOfRangeException();
				}
			}
		}

		public QilNode Left
		{
			get
			{
				return left;
			}
			set
			{
				left = value;
			}
		}

		public QilNode Center
		{
			get
			{
				return center;
			}
			set
			{
				center = value;
			}
		}

		public QilNode Right
		{
			get
			{
				return right;
			}
			set
			{
				right = value;
			}
		}

		public QilTernary(QilNodeType nodeType, QilNode left, QilNode center, QilNode right)
			: base(nodeType)
		{
			this.left = left;
			this.center = center;
			this.right = right;
		}
	}
	internal class QilInvokeEarlyBound : QilTernary
	{
		public QilName Name
		{
			get
			{
				return (QilName)base.Left;
			}
			set
			{
				base.Left = value;
			}
		}

		public MethodInfo ClrMethod
		{
			get
			{
				return (MethodInfo)((QilLiteral)base.Center).Value;
			}
			set
			{
				((QilLiteral)base.Center).Value = value;
			}
		}

		public QilList Arguments
		{
			get
			{
				return (QilList)base.Right;
			}
			set
			{
				base.Right = value;
			}
		}

		public QilInvokeEarlyBound(QilNodeType nodeType, QilNode name, QilNode method, QilNode arguments, XmlQueryType resultType)
			: base(nodeType, name, method, arguments)
		{
			xmlType = resultType;
		}
	}
	internal class QilInvokeLateBound : QilBinary
	{
		public QilName Name
		{
			get
			{
				return (QilName)base.Left;
			}
			set
			{
				base.Left = value;
			}
		}

		public QilList Arguments
		{
			get
			{
				return (QilList)base.Right;
			}
			set
			{
				base.Right = value;
			}
		}

		public QilInvokeLateBound(QilNodeType nodeType, QilNode name, QilNode arguments)
			: base(nodeType, name, arguments)
		{
		}
	}
	internal class QilIterator : QilReference
	{
		private QilNode binding;

		public override int Count => 1;

		public override QilNode this[int index]
		{
			get
			{
				if (index != 0)
				{
					throw new IndexOutOfRangeException();
				}
				return binding;
			}
			set
			{
				if (index != 0)
				{
					throw new IndexOutOfRangeException();
				}
				binding = value;
			}
		}

		public QilNode Binding
		{
			get
			{
				return binding;
			}
			set
			{
				binding = value;
			}
		}

		public QilIterator(QilNodeType nodeType, QilNode binding)
			: base(nodeType)
		{
			Binding = binding;
		}
	}
	internal class QilList : QilNode
	{
		private int count;

		private QilNode[] members;

		public override XmlQueryType XmlType
		{
			get
			{
				if (xmlType == null)
				{
					XmlQueryType xmlQueryType = XmlQueryTypeFactory.Empty;
					if (count > 0)
					{
						if (nodeType == QilNodeType.Sequence)
						{
							for (int i = 0; i < count; i++)
							{
								xmlQueryType = XmlQueryTypeFactory.Sequence(xmlQueryType, members[i].XmlType);
							}
							if (xmlQueryType.IsDod)
							{
								xmlQueryType = XmlQueryTypeFactory.PrimeProduct(XmlQueryTypeFactory.NodeNotRtfS, xmlQueryType.Cardinality);
							}
						}
						else if (nodeType == QilNodeType.BranchList)
						{
							xmlQueryType = members[0].XmlType;
							for (int j = 1; j < count; j++)
							{
								xmlQueryType = XmlQueryTypeFactory.Choice(xmlQueryType, members[j].XmlType);
							}
						}
					}
					xmlType = xmlQueryType;
				}
				return xmlType;
			}
		}

		public override int Count => count;

		public override QilNode this[int index]
		{
			get
			{
				if (index >= 0 && index < count)
				{
					return members[index];
				}
				throw new IndexOutOfRangeException();
			}
			set
			{
				if (index >= 0 && index < count)
				{
					members[index] = value;
					xmlType = null;
					return;
				}
				throw new IndexOutOfRangeException();
			}
		}

		public QilList(QilNodeType nodeType)
			: base(nodeType)
		{
			members = new QilNode[4];
			xmlType = null;
		}

		public override QilNode ShallowClone(QilFactory f)
		{
			QilList qilList = (QilList)MemberwiseClone();
			qilList.members = (QilNode[])members.Clone();
			return qilList;
		}

		public override void Insert(int index, QilNode node)
		{
			if (index < 0 || index > count)
			{
				throw new IndexOutOfRangeException();
			}
			if (count == members.Length)
			{
				QilNode[] destinationArray = new QilNode[count * 2];
				Array.Copy(members, destinationArray, count);
				members = destinationArray;
			}
			if (index < count)
			{
				Array.Copy(members, index, members, index + 1, count - index);
			}
			count++;
			members[index] = node;
			xmlType = null;
		}

		public override void RemoveAt(int index)
		{
			if (index < 0 || index >= count)
			{
				throw new IndexOutOfRangeException();
			}
			count--;
			if (index < count)
			{
				Array.Copy(members, index + 1, members, index, count - index);
			}
			members[count] = null;
			xmlType = null;
		}
	}
	internal class QilLiteral : QilNode
	{
		private object value;

		public object Value
		{
			get
			{
				return value;
			}
			set
			{
				this.value = value;
			}
		}

		public QilLiteral(QilNodeType nodeType, object value)
			: base(nodeType)
		{
			Value = value;
		}

		public static implicit operator string(QilLiteral literal)
		{
			return (string)literal.value;
		}

		public static implicit operator int(QilLiteral literal)
		{
			return (int)literal.value;
		}

		public static implicit operator long(QilLiteral literal)
		{
			return (long)literal.value;
		}

		public static implicit operator double(QilLiteral literal)
		{
			return (double)literal.value;
		}

		public static implicit operator decimal(QilLiteral literal)
		{
			return (decimal)literal.value;
		}

		public static implicit operator XmlQueryType(QilLiteral literal)
		{
			return (XmlQueryType)literal.value;
		}
	}
	internal class QilLoop : QilBinary
	{
		public QilIterator Variable
		{
			get
			{
				return (QilIterator)base.Left;
			}
			set
			{
				base.Left = value;
			}
		}

		public QilNode Body
		{
			get
			{
				return base.Right;
			}
			set
			{
				base.Right = value;
			}
		}

		public QilLoop(QilNodeType nodeType, QilNode variable, QilNode body)
			: base(nodeType, variable, body)
		{
		}
	}
	internal class QilName : QilLiteral
	{
		private string local;

		private string uri;

		private string prefix;

		public string LocalName
		{
			get
			{
				return local;
			}
			set
			{
				local = value;
			}
		}

		public string NamespaceUri
		{
			get
			{
				return uri;
			}
			set
			{
				uri = value;
			}
		}

		public string Prefix
		{
			get
			{
				return prefix;
			}
			set
			{
				prefix = value;
			}
		}

		public string QualifiedName
		{
			get
			{
				if (prefix.Length == 0)
				{
					return local;
				}
				return prefix + ':' + local;
			}
		}

		public QilName(QilNodeType nodeType, string local, string uri, string prefix)
			: base(nodeType, null)
		{
			LocalName = local;
			NamespaceUri = uri;
			Prefix = prefix;
			base.Value = this;
		}

		public override int GetHashCode()
		{
			return local.GetHashCode();
		}

		public override bool Equals(object other)
		{
			if (!(other is QilName qilName))
			{
				return false;
			}
			if (local == qilName.local)
			{
				return uri == qilName.uri;
			}
			return false;
		}

		public override string ToString()
		{
			if (prefix.Length == 0)
			{
				if (uri.Length == 0)
				{
					return local;
				}
				return "{" + uri + "}" + local;
			}
			return "{" + uri + "}" + prefix + ":" + local;
		}
	}
	internal enum QilNodeType
	{
		QilExpression,
		FunctionList,
		GlobalVariableList,
		GlobalParameterList,
		ActualParameterList,
		FormalParameterList,
		SortKeyList,
		BranchList,
		OptimizeBarrier,
		Unknown,
		DataSource,
		Nop,
		Error,
		Warning,
		For,
		Let,
		Parameter,
		PositionOf,
		True,
		False,
		LiteralString,
		LiteralInt32,
		LiteralInt64,
		LiteralDouble,
		LiteralDecimal,
		LiteralQName,
		LiteralType,
		LiteralObject,
		And,
		Or,
		Not,
		Conditional,
		Choice,
		Length,
		Sequence,
		Union,
		Intersection,
		Difference,
		Average,
		Sum,
		Minimum,
		Maximum,
		Negate,
		Add,
		Subtract,
		Multiply,
		Divide,
		Modulo,
		StrLength,
		StrConcat,
		StrParseQName,
		Ne,
		Eq,
		Gt,
		Ge,
		Lt,
		Le,
		Is,
		After,
		Before,
		Loop,
		Filter,
		Sort,
		SortKey,
		DocOrderDistinct,
		Function,
		Invoke,
		Content,
		Attribute,
		Parent,
		Root,
		XmlContext,
		Descendant,
		DescendantOrSelf,
		Ancestor,
		AncestorOrSelf,
		Preceding,
		FollowingSibling,
		PrecedingSibling,
		NodeRange,
		Deref,
		ElementCtor,
		AttributeCtor,
		CommentCtor,
		PICtor,
		TextCtor,
		RawTextCtor,
		DocumentCtor,
		NamespaceDecl,
		RtfCtor,
		NameOf,
		LocalNameOf,
		NamespaceUriOf,
		PrefixOf,
		TypeAssert,
		IsType,
		IsEmpty,
		XPathNodeValue,
		XPathFollowing,
		XPathPreceding,
		XPathNamespace,
		XsltGenerateId,
		XsltInvokeLateBound,
		XsltInvokeEarlyBound,
		XsltCopy,
		XsltCopyOf,
		XsltConvert
	}
	internal class QilParameter : QilIterator
	{
		private QilNode name;

		public override int Count => 2;

		public override QilNode this[int index]
		{
			get
			{
				return index switch
				{
					0 => base.Binding, 
					1 => name, 
					_ => throw new IndexOutOfRangeException(), 
				};
			}
			set
			{
				switch (index)
				{
				case 0:
					base.Binding = value;
					break;
				case 1:
					name = value;
					break;
				default:
					throw new IndexOutOfRangeException();
				}
			}
		}

		public QilNode DefaultValue
		{
			get
			{
				return base.Binding;
			}
			set
			{
				base.Binding = value;
			}
		}

		public QilName Name
		{
			get
			{
				return (QilName)name;
			}
			set
			{
				name = value;
			}
		}

		public QilParameter(QilNodeType nodeType, QilNode defaultValue, QilNode name, XmlQueryType xmlType)
			: base(nodeType, defaultValue)
		{
			this.name = name;
			base.xmlType = xmlType;
		}
	}
	internal class QilPatternFactory
	{
		private bool debug;

		private QilFactory f;

		public QilFactory BaseFactory => f;

		public bool IsDebug => debug;

		public QilPatternFactory(QilFactory f, bool debug)
		{
			this.f = f;
			this.debug = debug;
		}

		public QilLiteral String(string val)
		{
			return f.LiteralString(val);
		}

		public QilLiteral Int32(int val)
		{
			return f.LiteralInt32(val);
		}

		public QilLiteral Double(double val)
		{
			return f.LiteralDouble(val);
		}

		public QilName QName(string local, string uri, string prefix)
		{
			return f.LiteralQName(local, uri, prefix);
		}

		public QilName QName(string local, string uri)
		{
			return f.LiteralQName(local, uri, string.Empty);
		}

		public QilName QName(string local)
		{
			return f.LiteralQName(local, string.Empty, string.Empty);
		}

		public QilNode Unknown(XmlQueryType t)
		{
			return f.Unknown(t);
		}

		public QilExpression QilExpression(QilNode root, QilFactory factory)
		{
			return f.QilExpression(root, factory);
		}

		public QilList FunctionList()
		{
			return f.FunctionList();
		}

		public QilList GlobalVariableList()
		{
			return f.GlobalVariableList();
		}

		public QilList GlobalParameterList()
		{
			return f.GlobalParameterList();
		}

		public QilList ActualParameterList()
		{
			return f.ActualParameterList();
		}

		public QilList ActualParameterList(QilNode arg1)
		{
			QilList qilList = f.ActualParameterList();
			qilList.Add(arg1);
			return qilList;
		}

		public QilList ActualParameterList(QilNode arg1, QilNode arg2)
		{
			QilList qilList = f.ActualParameterList();
			qilList.Add(arg1);
			qilList.Add(arg2);
			return qilList;
		}

		public QilList ActualParameterList(params QilNode[] args)
		{
			return f.ActualParameterList(args);
		}

		public QilList FormalParameterList()
		{
			return f.FormalParameterList();
		}

		public QilList FormalParameterList(QilNode arg1)
		{
			QilList qilList = f.FormalParameterList();
			qilList.Add(arg1);
			return qilList;
		}

		public QilList FormalParameterList(QilNode arg1, QilNode arg2)
		{
			QilList qilList = f.FormalParameterList();
			qilList.Add(arg1);
			qilList.Add(arg2);
			return qilList;
		}

		public QilList FormalParameterList(params QilNode[] args)
		{
			return f.FormalParameterList(args);
		}

		public QilList SortKeyList()
		{
			return f.SortKeyList();
		}

		public QilList SortKeyList(QilSortKey key)
		{
			QilList qilList = f.SortKeyList();
			qilList.Add(key);
			return qilList;
		}

		public QilList BranchList(params QilNode[] args)
		{
			return f.BranchList(args);
		}

		public QilNode OptimizeBarrier(QilNode child)
		{
			return f.OptimizeBarrier(child);
		}

		public QilNode DataSource(QilNode name, QilNode baseUri)
		{
			return f.DataSource(name, baseUri);
		}

		public QilNode Nop(QilNode child)
		{
			return f.Nop(child);
		}

		public QilNode Error(QilNode text)
		{
			return f.Error(text);
		}

		public QilNode Warning(QilNode text)
		{
			return f.Warning(text);
		}

		public QilIterator For(QilNode binding)
		{
			return f.For(binding);
		}

		public QilIterator Let(QilNode binding)
		{
			return f.Let(binding);
		}

		public QilParameter Parameter(XmlQueryType t)
		{
			return f.Parameter(t);
		}

		public QilParameter Parameter(QilNode defaultValue, QilName name, XmlQueryType t)
		{
			return f.Parameter(defaultValue, name, t);
		}

		public QilNode PositionOf(QilIterator expr)
		{
			return f.PositionOf(expr);
		}

		public QilNode True()
		{
			return f.True();
		}

		public QilNode False()
		{
			return f.False();
		}

		public QilNode Boolean(bool b)
		{
			if (!b)
			{
				return False();
			}
			return True();
		}

		private static void CheckLogicArg(QilNode arg)
		{
		}

		public QilNode And(QilNode left, QilNode right)
		{
			CheckLogicArg(left);
			CheckLogicArg(right);
			if (!debug)
			{
				if (left.NodeType == QilNodeType.True || right.NodeType == QilNodeType.False)
				{
					return right;
				}
				if (left.NodeType == QilNodeType.False || right.NodeType == QilNodeType.True)
				{
					return left;
				}
			}
			return f.And(left, right);
		}

		public QilNode Or(QilNode left, QilNode right)
		{
			CheckLogicArg(left);
			CheckLogicArg(right);
			if (!debug)
			{
				if (left.NodeType == QilNodeType.True || right.NodeType == QilNodeType.False)
				{
					return left;
				}
				if (left.NodeType == QilNodeType.False || right.NodeType == QilNodeType.True)
				{
					return right;
				}
			}
			return f.Or(left, right);
		}

		public QilNode Not(QilNode child)
		{
			if (!debug)
			{
				switch (child.NodeType)
				{
				case QilNodeType.True:
					return f.False();
				case QilNodeType.False:
					return f.True();
				case QilNodeType.Not:
					return ((QilUnary)child).Child;
				}
			}
			return f.Not(child);
		}

		public QilNode Conditional(QilNode condition, QilNode trueBranch, QilNode falseBranch)
		{
			if (!debug)
			{
				switch (condition.NodeType)
				{
				case QilNodeType.True:
					return trueBranch;
				case QilNodeType.False:
					return falseBranch;
				case QilNodeType.Not:
					return Conditional(((QilUnary)condition).Child, falseBranch, trueBranch);
				}
			}
			return f.Conditional(condition, trueBranch, falseBranch);
		}

		public QilNode Choice(QilNode expr, QilList branches)
		{
			if (!debug)
			{
				switch (branches.Count)
				{
				case 1:
					return f.Loop(f.Let(expr), branches[0]);
				case 2:
					return f.Conditional(f.Eq(expr, f.LiteralInt32(0)), branches[0], branches[1]);
				}
			}
			return f.Choice(expr, branches);
		}

		public QilNode Length(QilNode child)
		{
			return f.Length(child);
		}

		public QilNode Sequence()
		{
			return f.Sequence();
		}

		public QilNode Sequence(QilNode child)
		{
			if (!debug)
			{
				return child;
			}
			QilList qilList = f.Sequence();
			qilList.Add(child);
			return qilList;
		}

		public QilNode Sequence(QilNode child1, QilNode child2)
		{
			QilList qilList = f.Sequence();
			qilList.Add(child1);
			qilList.Add(child2);
			return qilList;
		}

		public QilNode Sequence(params QilNode[] args)
		{
			if (!debug)
			{
				switch (args.Length)
				{
				case 0:
					return f.Sequence();
				case 1:
					return args[0];
				}
			}
			QilList qilList = f.Sequence();
			foreach (QilNode node in args)
			{
				qilList.Add(node);
			}
			return qilList;
		}

		public QilNode Union(QilNode left, QilNode right)
		{
			return f.Union(left, right);
		}

		public QilNode Sum(QilNode collection)
		{
			return f.Sum(collection);
		}

		public QilNode Negate(QilNode child)
		{
			return f.Negate(child);
		}

		public QilNode Add(QilNode left, QilNode right)
		{
			return f.Add(left, right);
		}

		public QilNode Subtract(QilNode left, QilNode right)
		{
			return f.Subtract(left, right);
		}

		public QilNode Multiply(QilNode left, QilNode right)
		{
			return f.Multiply(left, right);
		}

		public QilNode Divide(QilNode left, QilNode right)
		{
			return f.Divide(left, right);
		}

		public QilNode Modulo(QilNode left, QilNode right)
		{
			return f.Modulo(left, right);
		}

		public QilNode StrLength(QilNode str)
		{
			return f.StrLength(str);
		}

		public QilNode StrConcat(QilNode values)
		{
			if (!debug && values.XmlType.IsSingleton)
			{
				return values;
			}
			return f.StrConcat(values);
		}

		public QilNode StrConcat(params QilNode[] args)
		{
			return StrConcat((IList<QilNode>)args);
		}

		public QilNode StrConcat(IList<QilNode> args)
		{
			if (!debug)
			{
				switch (args.Count)
				{
				case 0:
					return f.LiteralString(string.Empty);
				case 1:
					return StrConcat(args[0]);
				}
			}
			return StrConcat(f.Sequence(args));
		}

		public QilNode StrParseQName(QilNode str, QilNode ns)
		{
			return f.StrParseQName(str, ns);
		}

		public QilNode Ne(QilNode left, QilNode right)
		{
			return f.Ne(left, right);
		}

		public QilNode Eq(QilNode left, QilNode right)
		{
			return f.Eq(left, right);
		}

		public QilNode Gt(QilNode left, QilNode right)
		{
			return f.Gt(left, right);
		}

		public QilNode Ge(QilNode left, QilNode right)
		{
			return f.Ge(left, right);
		}

		public QilNode Lt(QilNode left, QilNode right)
		{
			return f.Lt(left, right);
		}

		public QilNode Le(QilNode left, QilNode right)
		{
			return f.Le(left, right);
		}

		public QilNode Is(QilNode left, QilNode right)
		{
			return f.Is(left, right);
		}

		public QilNode After(QilNode left, QilNode right)
		{
			return f.After(left, right);
		}

		public QilNode Before(QilNode left, QilNode right)
		{
			return f.Before(left, right);
		}

		public QilNode Loop(QilIterator variable, QilNode body)
		{
			if (!debug && body == variable.Binding)
			{
				return body;
			}
			return f.Loop(variable, body);
		}

		public QilNode Filter(QilIterator variable, QilNode expr)
		{
			if (!debug && expr.NodeType == QilNodeType.True)
			{
				return variable.Binding;
			}
			return f.Filter(variable, expr);
		}

		public QilNode Sort(QilIterator iter, QilNode keys)
		{
			return f.Sort(iter, keys);
		}

		public QilSortKey SortKey(QilNode key, QilNode collation)
		{
			return f.SortKey(key, collation);
		}

		public QilNode DocOrderDistinct(QilNode collection)
		{
			if (collection.NodeType == QilNodeType.DocOrderDistinct)
			{
				return collection;
			}
			return f.DocOrderDistinct(collection);
		}

		public QilFunction Function(QilList args, QilNode sideEffects, XmlQueryType resultType)
		{
			return f.Function(args, sideEffects, resultType);
		}

		public QilFunction Function(QilList args, QilNode defn, QilNode sideEffects)
		{
			return f.Function(args, defn, sideEffects, defn.XmlType);
		}

		public QilNode Invoke(QilFunction func, QilList args)
		{
			return f.Invoke(func, args);
		}

		public QilNode Content(QilNode context)
		{
			return f.Content(context);
		}

		public QilNode Parent(QilNode context)
		{
			return f.Parent(context);
		}

		public QilNode Root(QilNode context)
		{
			return f.Root(context);
		}

		public QilNode XmlContext()
		{
			return f.XmlContext();
		}

		public QilNode Descendant(QilNode expr)
		{
			return f.Descendant(expr);
		}

		public QilNode DescendantOrSelf(QilNode context)
		{
			return f.DescendantOrSelf(context);
		}

		public QilNode Ancestor(QilNode expr)
		{
			return f.Ancestor(expr);
		}

		public QilNode AncestorOrSelf(QilNode expr)
		{
			return f.AncestorOrSelf(expr);
		}

		public QilNode Preceding(QilNode expr)
		{
			return f.Preceding(expr);
		}

		public QilNode FollowingSibling(QilNode expr)
		{
			return f.FollowingSibling(expr);
		}

		public QilNode PrecedingSibling(QilNode expr)
		{
			return f.PrecedingSibling(expr);
		}

		public QilNode NodeRange(QilNode left, QilNode right)
		{
			return f.NodeRange(left, right);
		}

		public QilBinary Deref(QilNode context, QilNode id)
		{
			return f.Deref(context, id);
		}

		public QilNode ElementCtor(QilNode name, QilNode content)
		{
			return f.ElementCtor(name, content);
		}

		public QilNode AttributeCtor(QilNode name, QilNode val)
		{
			return f.AttributeCtor(name, val);
		}

		public QilNode CommentCtor(QilNode content)
		{
			return f.CommentCtor(content);
		}

		public QilNode PICtor(QilNode name, QilNode content)
		{
			return f.PICtor(name, content);
		}

		public QilNode TextCtor(QilNode content)
		{
			return f.TextCtor(content);
		}

		public QilNode RawTextCtor(QilNode content)
		{
			return f.RawTextCtor(content);
		}

		public QilNode DocumentCtor(QilNode child)
		{
			return f.DocumentCtor(child);
		}

		public QilNode NamespaceDecl(QilNode prefix, QilNode uri)
		{
			return f.NamespaceDecl(prefix, uri);
		}

		public QilNode RtfCtor(QilNode content, QilNode baseUri)
		{
			return f.RtfCtor(content, baseUri);
		}

		public QilNode NameOf(QilNode expr)
		{
			return f.NameOf(expr);
		}

		public QilNode LocalNameOf(QilNode expr)
		{
			return f.LocalNameOf(expr);
		}

		public QilNode NamespaceUriOf(QilNode expr)
		{
			return f.NamespaceUriOf(expr);
		}

		public QilNode PrefixOf(QilNode expr)
		{
			return f.PrefixOf(expr);
		}

		public QilNode TypeAssert(QilNode expr, XmlQueryType t)
		{
			return f.TypeAssert(expr, t);
		}

		public QilNode IsType(QilNode expr, XmlQueryType t)
		{
			return f.IsType(expr, t);
		}

		public QilNode IsEmpty(QilNode set)
		{
			return f.IsEmpty(set);
		}

		public QilNode XPathNodeValue(QilNode expr)
		{
			return f.XPathNodeValue(expr);
		}

		public QilNode XPathFollowing(QilNode expr)
		{
			return f.XPathFollowing(expr);
		}

		public QilNode XPathNamespace(QilNode expr)
		{
			return f.XPathNamespace(expr);
		}

		public QilNode XPathPreceding(QilNode expr)
		{
			return f.XPathPreceding(expr);
		}

		public QilNode XsltGenerateId(QilNode expr)
		{
			return f.XsltGenerateId(expr);
		}

		public QilNode XsltInvokeEarlyBound(QilNode name, MethodInfo d, XmlQueryType t, IList<QilNode> args)
		{
			QilList qilList = f.ActualParameterList();
			qilList.Add(args);
			return f.XsltInvokeEarlyBound(name, f.LiteralObject(d), qilList, t);
		}

		public QilNode XsltInvokeLateBound(QilNode name, IList<QilNode> args)
		{
			QilList qilList = f.ActualParameterList();
			qilList.Add(args);
			return f.XsltInvokeLateBound(name, qilList);
		}

		public QilNode XsltCopy(QilNode expr, QilNode content)
		{
			return f.XsltCopy(expr, content);
		}

		public QilNode XsltCopyOf(QilNode expr)
		{
			return f.XsltCopyOf(expr);
		}

		public QilNode XsltConvert(QilNode expr, XmlQueryType t)
		{
			return f.XsltConvert(expr, t);
		}
	}
	internal class QilSortKey : QilBinary
	{
		public QilNode Key
		{
			get
			{
				return base.Left;
			}
			set
			{
				base.Left = value;
			}
		}

		public QilNode Collation
		{
			get
			{
				return base.Right;
			}
			set
			{
				base.Right = value;
			}
		}

		public QilSortKey(QilNodeType nodeType, QilNode key, QilNode collation)
			: base(nodeType, key, collation)
		{
		}
	}
	internal class QilStrConcat : QilBinary
	{
		public QilNode Delimiter
		{
			get
			{
				return base.Left;
			}
			set
			{
				base.Left = value;
			}
		}

		public QilNode Values
		{
			get
			{
				return base.Right;
			}
			set
			{
				base.Right = value;
			}
		}

		public QilStrConcat(QilNodeType nodeType, QilNode delimiter, QilNode values)
			: base(nodeType, delimiter, values)
		{
		}
	}
	internal class QilTargetType : QilBinary
	{
		public QilNode Source
		{
			get
			{
				return base.Left;
			}
			set
			{
				base.Left = value;
			}
		}

		public XmlQueryType TargetType
		{
			get
			{
				return (XmlQueryType)((QilLiteral)base.Right).Value;
			}
			set
			{
				((QilLiteral)base.Right).Value = value;
			}
		}

		public QilTargetType(QilNodeType nodeType, QilNode expr, QilNode targetType)
			: base(nodeType, expr, targetType)
		{
		}
	}
	internal class QilTypeChecker
	{
		public XmlQueryType Check(QilNode n)
		{
			return n.NodeType switch
			{
				QilNodeType.QilExpression => CheckQilExpression((QilExpression)n), 
				QilNodeType.FunctionList => CheckFunctionList((QilList)n), 
				QilNodeType.GlobalVariableList => CheckGlobalVariableList((QilList)n), 
				QilNodeType.GlobalParameterList => CheckGlobalParameterList((QilList)n), 
				QilNodeType.ActualParameterList => CheckActualParameterList((QilList)n), 
				QilNodeType.FormalParameterList => CheckFormalParameterList((QilList)n), 
				QilNodeType.SortKeyList => CheckSortKeyList((QilList)n), 
				QilNodeType.BranchList => CheckBranchList((QilList)n), 
				QilNodeType.OptimizeBarrier => CheckOptimizeBarrier((QilUnary)n), 
				QilNodeType.Unknown => CheckUnknown(n), 
				QilNodeType.DataSource => CheckDataSource((QilDataSource)n), 
				QilNodeType.Nop => CheckNop((QilUnary)n), 
				QilNodeType.Error => CheckError((QilUnary)n), 
				QilNodeType.Warning => CheckWarning((QilUnary)n), 
				QilNodeType.For => CheckFor((QilIterator)n), 
				QilNodeType.Let => CheckLet((QilIterator)n), 
				QilNodeType.Parameter => CheckParameter((QilParameter)n), 
				QilNodeType.PositionOf => CheckPositionOf((QilUnary)n), 
				QilNodeType.True => CheckTrue(n), 
				QilNodeType.False => CheckFalse(n), 
				QilNodeType.LiteralString => CheckLiteralString((QilLiteral)n), 
				QilNodeType.LiteralInt32 => CheckLiteralInt32((QilLiteral)n), 
				QilNodeType.LiteralInt64 => CheckLiteralInt64((QilLiteral)n), 
				QilNodeType.LiteralDouble => CheckLiteralDouble((QilLiteral)n), 
				QilNodeType.LiteralDecimal => CheckLiteralDecimal((QilLiteral)n), 
				QilNodeType.LiteralQName => CheckLiteralQName((QilName)n), 
				QilNodeType.LiteralType => CheckLiteralType((QilLiteral)n), 
				QilNodeType.LiteralObject => CheckLiteralObject((QilLiteral)n), 
				QilNodeType.And => CheckAnd((QilBinary)n), 
				QilNodeType.Or => CheckOr((QilBinary)n), 
				QilNodeType.Not => CheckNot((QilUnary)n), 
				QilNodeType.Conditional => CheckConditional((QilTernary)n), 
				QilNodeType.Choice => CheckChoice((QilChoice)n), 
				QilNodeType.Length => CheckLength((QilUnary)n), 
				QilNodeType.Sequence => CheckSequence((QilList)n), 
				QilNodeType.Union => CheckUnion((QilBinary)n), 
				QilNodeType.Intersection => CheckIntersection((QilBinary)n), 
				QilNodeType.Difference => CheckDifference((QilBinary)n), 
				QilNodeType.Average => CheckAverage((QilUnary)n), 
				QilNodeType.Sum => CheckSum((QilUnary)n), 
				QilNodeType.Minimum => CheckMinimum((QilUnary)n), 
				QilNodeType.Maximum => CheckMaximum((QilUnary)n), 
				QilNodeType.Negate => CheckNegate((QilUnary)n), 
				QilNodeType.Add => CheckAdd((QilBinary)n), 
				QilNodeType.Subtract => CheckSubtract((QilBinary)n), 
				QilNodeType.Multiply => CheckMultiply((QilBinary)n), 
				QilNodeType.Divide => CheckDivide((QilBinary)n), 
				QilNodeType.Modulo => CheckModulo((QilBinary)n), 
				QilNodeType.StrLength => CheckStrLength((QilUnary)n), 
				QilNodeType.StrConcat => CheckStrConcat((QilStrConcat)n), 
				QilNodeType.StrParseQName => CheckStrParseQName((QilBinary)n), 
				QilNodeType.Ne => CheckNe((QilBinary)n), 
				QilNodeType.Eq => CheckEq((QilBinary)n), 
				QilNodeType.Gt => CheckGt((QilBinary)n), 
				QilNodeType.Ge => CheckGe((QilBinary)n), 
				QilNodeType.Lt => CheckLt((QilBinary)n), 
				QilNodeType.Le => CheckLe((QilBinary)n), 
				QilNodeType.Is => CheckIs((QilBinary)n), 
				QilNodeType.After => CheckAfter((QilBinary)n), 
				QilNodeType.Before => CheckBefore((QilBinary)n), 
				QilNodeType.Loop => CheckLoop((QilLoop)n), 
				QilNodeType.Filter => CheckFilter((QilLoop)n), 
				QilNodeType.Sort => CheckSort((QilLoop)n), 
				QilNodeType.SortKey => CheckSortKey((QilSortKey)n), 
				QilNodeType.DocOrderDistinct => CheckDocOrderDistinct((QilUnary)n), 
				QilNodeType.Function => CheckFunction((QilFunction)n), 
				QilNodeType.Invoke => CheckInvoke((QilInvoke)n), 
				QilNodeType.Content => CheckContent((QilUnary)n), 
				QilNodeType.Attribute => CheckAttribute((QilBinary)n), 
				QilNodeType.Parent => CheckParent((QilUnary)n), 
				QilNodeType.Root => CheckRoot((QilUnary)n), 
				QilNodeType.XmlContext => CheckXmlContext(n), 
				QilNodeType.Descendant => CheckDescendant((QilUnary)n), 
				QilNodeType.DescendantOrSelf => CheckDescendantOrSelf((QilUnary)n), 
				QilNodeType.Ancestor => CheckAncestor((QilUnary)n), 
				QilNodeType.AncestorOrSelf => CheckAncestorOrSelf((QilUnary)n), 
				QilNodeType.Preceding => CheckPreceding((QilUnary)n), 
				QilNodeType.FollowingSibling => CheckFollowingSibling((QilUnary)n), 
				QilNodeType.PrecedingSibling => CheckPrecedingSibling((QilUnary)n), 
				QilNodeType.NodeRange => CheckNodeRange((QilBinary)n), 
				QilNodeType.Deref => CheckDeref((QilBinary)n), 
				QilNodeType.ElementCtor => CheckElementCtor((QilBinary)n), 
				QilNodeType.AttributeCtor => CheckAttributeCtor((QilBinary)n), 
				QilNodeType.CommentCtor => CheckCommentCtor((QilUnary)n), 
				QilNodeType.PICtor => CheckPICtor((QilBinary)n), 
				QilNodeType.TextCtor => CheckTextCtor((QilUnary)n), 
				QilNodeType.RawTextCtor => CheckRawTextCtor((QilUnary)n), 
				QilNodeType.DocumentCtor => CheckDocumentCtor((QilUnary)n), 
				QilNodeType.NamespaceDecl => CheckNamespaceDecl((QilBinary)n), 
				QilNodeType.RtfCtor => CheckRtfCtor((QilBinary)n), 
				QilNodeType.NameOf => CheckNameOf((QilUnary)n), 
				QilNodeType.LocalNameOf => CheckLocalNameOf((QilUnary)n), 
				QilNodeType.NamespaceUriOf => CheckNamespaceUriOf((QilUnary)n), 
				QilNodeType.PrefixOf => CheckPrefixOf((QilUnary)n), 
				QilNodeType.TypeAssert => CheckTypeAssert((QilTargetType)n), 
				QilNodeType.IsType => CheckIsType((QilTargetType)n), 
				QilNodeType.IsEmpty => CheckIsEmpty((QilUnary)n), 
				QilNodeType.XPathNodeValue => CheckXPathNodeValue((QilUnary)n), 
				QilNodeType.XPathFollowing => CheckXPathFollowing((QilUnary)n), 
				QilNodeType.XPathPreceding => CheckXPathPreceding((QilUnary)n), 
				QilNodeType.XPathNamespace => CheckXPathNamespace((QilUnary)n), 
				QilNodeType.XsltGenerateId => CheckXsltGenerateId((QilUnary)n), 
				QilNodeType.XsltInvokeLateBound => CheckXsltInvokeLateBound((QilInvokeLateBound)n), 
				QilNodeType.XsltInvokeEarlyBound => CheckXsltInvokeEarlyBound((QilInvokeEarlyBound)n), 
				QilNodeType.XsltCopy => CheckXsltCopy((QilBinary)n), 
				QilNodeType.XsltCopyOf => CheckXsltCopyOf((QilUnary)n), 
				QilNodeType.XsltConvert => CheckXsltConvert((QilTargetType)n), 
				_ => CheckUnknown(n), 
			};
		}

		public XmlQueryType CheckQilExpression(QilExpression node)
		{
			return XmlQueryTypeFactory.ItemS;
		}

		public XmlQueryType CheckFunctionList(QilList node)
		{
			foreach (QilNode item in node)
			{
				_ = item;
			}
			return node.XmlType;
		}

		public XmlQueryType CheckGlobalVariableList(QilList node)
		{
			foreach (QilNode item in node)
			{
				_ = item;
			}
			return node.XmlType;
		}

		public XmlQueryType CheckGlobalParameterList(QilList node)
		{
			foreach (QilNode item in node)
			{
				_ = item;
			}
			return node.XmlType;
		}

		public XmlQueryType CheckActualParameterList(QilList node)
		{
			return node.XmlType;
		}

		public XmlQueryType CheckFormalParameterList(QilList node)
		{
			foreach (QilNode item in node)
			{
				_ = item;
			}
			return node.XmlType;
		}

		public XmlQueryType CheckSortKeyList(QilList node)
		{
			foreach (QilNode item in node)
			{
				_ = item;
			}
			return node.XmlType;
		}

		public XmlQueryType CheckBranchList(QilList node)
		{
			return node.XmlType;
		}

		public XmlQueryType CheckOptimizeBarrier(QilUnary node)
		{
			return node.Child.XmlType;
		}

		public XmlQueryType CheckNoDefaultValue(QilNode node)
		{
			return XmlQueryTypeFactory.None;
		}

		public XmlQueryType CheckUnknown(QilNode node)
		{
			return node.XmlType;
		}

		public XmlQueryType CheckDataSource(QilDataSource node)
		{
			return XmlQueryTypeFactory.NodeNotRtfQ;
		}

		public XmlQueryType CheckNop(QilUnary node)
		{
			return node.Child.XmlType;
		}

		public XmlQueryType CheckError(QilUnary node)
		{
			return XmlQueryTypeFactory.None;
		}

		public XmlQueryType CheckWarning(QilUnary node)
		{
			return XmlQueryTypeFactory.Empty;
		}

		public XmlQueryType CheckFor(QilIterator node)
		{
			return node.Binding.XmlType.Prime;
		}

		public XmlQueryType CheckLet(QilIterator node)
		{
			return node.Binding.XmlType;
		}

		public XmlQueryType CheckParameter(QilParameter node)
		{
			return node.XmlType;
		}

		public XmlQueryType CheckPositionOf(QilUnary node)
		{
			return XmlQueryTypeFactory.IntX;
		}

		public XmlQueryType CheckTrue(QilNode node)
		{
			return XmlQueryTypeFactory.BooleanX;
		}

		public XmlQueryType CheckFalse(QilNode node)
		{
			return XmlQueryTypeFactory.BooleanX;
		}

		public XmlQueryType CheckLiteralString(QilLiteral node)
		{
			return XmlQueryTypeFactory.StringX;
		}

		public XmlQueryType CheckLiteralInt32(QilLiteral node)
		{
			return XmlQueryTypeFactory.IntX;
		}

		public XmlQueryType CheckLiteralInt64(QilLiteral node)
		{
			return XmlQueryTypeFactory.IntegerX;
		}

		public XmlQueryType CheckLiteralDouble(QilLiteral node)
		{
			return XmlQueryTypeFactory.DoubleX;
		}

		public XmlQueryType CheckLiteralDecimal(QilLiteral node)
		{
			return XmlQueryTypeFactory.DecimalX;
		}

		public XmlQueryType CheckLiteralQName(QilName node)
		{
			return XmlQueryTypeFactory.QNameX;
		}

		public XmlQueryType CheckLiteralType(QilLiteral node)
		{
			return node;
		}

		public XmlQueryType CheckLiteralObject(QilLiteral node)
		{
			return XmlQueryTypeFactory.ItemS;
		}

		public XmlQueryType CheckAnd(QilBinary node)
		{
			return XmlQueryTypeFactory.BooleanX;
		}

		public XmlQueryType CheckOr(QilBinary node)
		{
			return CheckAnd(node);
		}

		public XmlQueryType CheckNot(QilUnary node)
		{
			return XmlQueryTypeFactory.BooleanX;
		}

		public XmlQueryType CheckConditional(QilTernary node)
		{
			return XmlQueryTypeFactory.Choice(node.Center.XmlType, node.Right.XmlType);
		}

		public XmlQueryType CheckChoice(QilChoice node)
		{
			return node.Branches.XmlType;
		}

		public XmlQueryType CheckLength(QilUnary node)
		{
			return XmlQueryTypeFactory.IntX;
		}

		public XmlQueryType CheckSequence(QilList node)
		{
			return node.XmlType;
		}

		public XmlQueryType CheckUnion(QilBinary node)
		{
			return DistinctType(XmlQueryTypeFactory.Sequence(node.Left.XmlType, node.Right.XmlType));
		}

		public XmlQueryType CheckIntersection(QilBinary node)
		{
			return CheckUnion(node);
		}

		public XmlQueryType CheckDifference(QilBinary node)
		{
			return XmlQueryTypeFactory.AtMost(node.Left.XmlType, node.Left.XmlType.Cardinality);
		}

		public XmlQueryType CheckAverage(QilUnary node)
		{
			XmlQueryType xmlType = node.Child.XmlType;
			return XmlQueryTypeFactory.PrimeProduct(xmlType, xmlType.MaybeEmpty ? XmlQueryCardinality.ZeroOrOne : XmlQueryCardinality.One);
		}

		public XmlQueryType CheckSum(QilUnary node)
		{
			return CheckAverage(node);
		}

		public XmlQueryType CheckMinimum(QilUnary node)
		{
			return CheckAverage(node);
		}

		public XmlQueryType CheckMaximum(QilUnary node)
		{
			return CheckAverage(node);
		}

		public XmlQueryType CheckNegate(QilUnary node)
		{
			return node.Child.XmlType;
		}

		public XmlQueryType CheckAdd(QilBinary node)
		{
			if (node.Left.XmlType.TypeCode != 0)
			{
				return node.Left.XmlType;
			}
			return node.Right.XmlType;
		}

		public XmlQueryType CheckSubtract(QilBinary node)
		{
			return CheckAdd(node);
		}

		public XmlQueryType CheckMultiply(QilBinary node)
		{
			return CheckAdd(node);
		}

		public XmlQueryType CheckDivide(QilBinary node)
		{
			return CheckAdd(node);
		}

		public XmlQueryType CheckModulo(QilBinary node)
		{
			return CheckAdd(node);
		}

		public XmlQueryType CheckStrLength(QilUnary node)
		{
			return XmlQueryTypeFactory.IntX;
		}

		public XmlQueryType CheckStrConcat(QilStrConcat node)
		{
			return XmlQueryTypeFactory.StringX;
		}

		public XmlQueryType CheckStrParseQName(QilBinary node)
		{
			return XmlQueryTypeFactory.QNameX;
		}

		public XmlQueryType CheckNe(QilBinary node)
		{
			return XmlQueryTypeFactory.BooleanX;
		}

		public XmlQueryType CheckEq(QilBinary node)
		{
			return CheckNe(node);
		}

		public XmlQueryType CheckGt(QilBinary node)
		{
			return CheckNe(node);
		}

		public XmlQueryType CheckGe(QilBinary node)
		{
			return CheckNe(node);
		}

		public XmlQueryType CheckLt(QilBinary node)
		{
			return CheckNe(node);
		}

		public XmlQueryType CheckLe(QilBinary node)
		{
			return CheckNe(node);
		}

		public XmlQueryType CheckIs(QilBinary node)
		{
			return XmlQueryTypeFactory.BooleanX;
		}

		public XmlQueryType CheckAfter(QilBinary node)
		{
			return CheckIs(node);
		}

		public XmlQueryType CheckBefore(QilBinary node)
		{
			return CheckIs(node);
		}

		public XmlQueryType CheckLoop(QilLoop node)
		{
			XmlQueryType xmlType = node.Body.XmlType;
			XmlQueryCardinality xmlQueryCardinality = ((node.Variable.NodeType == QilNodeType.Let) ? XmlQueryCardinality.One : node.Variable.Binding.XmlType.Cardinality);
			if (xmlType.IsDod)
			{
				return XmlQueryTypeFactory.PrimeProduct(XmlQueryTypeFactory.NodeNotRtfS, xmlQueryCardinality * xmlType.Cardinality);
			}
			return XmlQueryTypeFactory.PrimeProduct(xmlType, xmlQueryCardinality * xmlType.Cardinality);
		}

		public XmlQueryType CheckFilter(QilLoop node)
		{
			XmlQueryType xmlQueryType = FindFilterType(node.Variable, node.Body);
			if (xmlQueryType != null)
			{
				return xmlQueryType;
			}
			return XmlQueryTypeFactory.AtMost(node.Variable.Binding.XmlType, node.Variable.Binding.XmlType.Cardinality);
		}

		public XmlQueryType CheckSort(QilLoop node)
		{
			XmlQueryType xmlType = node.Variable.Binding.XmlType;
			if (xmlType.IsDod)
			{
				return XmlQueryTypeFactory.PrimeProduct(XmlQueryTypeFactory.NodeNotRtfS, xmlType.Cardinality);
			}
			return node.Variable.Binding.XmlType;
		}

		public XmlQueryType CheckSortKey(QilSortKey node)
		{
			return node.Key.XmlType;
		}

		public XmlQueryType CheckDocOrderDistinct(QilUnary node)
		{
			return DistinctType(node.Child.XmlType);
		}

		public XmlQueryType CheckFunction(QilFunction node)
		{
			return node.XmlType;
		}

		public XmlQueryType CheckInvoke(QilInvoke node)
		{
			return node.Function.XmlType;
		}

		public XmlQueryType CheckContent(QilUnary node)
		{
			return XmlQueryTypeFactory.AttributeOrContentS;
		}

		public XmlQueryType CheckAttribute(QilBinary node)
		{
			return XmlQueryTypeFactory.AttributeQ;
		}

		public XmlQueryType CheckParent(QilUnary node)
		{
			return XmlQueryTypeFactory.DocumentOrElementQ;
		}

		public XmlQueryType CheckRoot(QilUnary node)
		{
			return XmlQueryTypeFactory.NodeNotRtf;
		}

		public XmlQueryType CheckXmlContext(QilNode node)
		{
			return XmlQueryTypeFactory.NodeNotRtf;
		}

		public XmlQueryType CheckDescendant(QilUnary node)
		{
			return XmlQueryTypeFactory.ContentS;
		}

		public XmlQueryType CheckDescendantOrSelf(QilUnary node)
		{
			return XmlQueryTypeFactory.Choice(node.Child.XmlType, XmlQueryTypeFactory.ContentS);
		}

		public XmlQueryType CheckAncestor(QilUnary node)
		{
			return XmlQueryTypeFactory.DocumentOrElementS;
		}

		public XmlQueryType CheckAncestorOrSelf(QilUnary node)
		{
			return XmlQueryTypeFactory.Choice(node.Child.XmlType, XmlQueryTypeFactory.DocumentOrElementS);
		}

		public XmlQueryType CheckPreceding(QilUnary node)
		{
			return XmlQueryTypeFactory.DocumentOrContentS;
		}

		public XmlQueryType CheckFollowingSibling(QilUnary node)
		{
			return XmlQueryTypeFactory.ContentS;
		}

		public XmlQueryType CheckPrecedingSibling(QilUnary node)
		{
			return XmlQueryTypeFactory.ContentS;
		}

		public XmlQueryType CheckNodeRange(QilBinary node)
		{
			return XmlQueryTypeFactory.Choice(node.Left.XmlType, XmlQueryTypeFactory.ContentS, node.Right.XmlType);
		}

		public XmlQueryType CheckDeref(QilBinary node)
		{
			return XmlQueryTypeFactory.ElementS;
		}

		public XmlQueryType CheckElementCtor(QilBinary node)
		{
			return XmlQueryTypeFactory.UntypedElement;
		}

		public XmlQueryType CheckAttributeCtor(QilBinary node)
		{
			return XmlQueryTypeFactory.UntypedAttribute;
		}

		public XmlQueryType CheckCommentCtor(QilUnary node)
		{
			return XmlQueryTypeFactory.Comment;
		}

		public XmlQueryType CheckPICtor(QilBinary node)
		{
			return XmlQueryTypeFactory.PI;
		}

		public XmlQueryType CheckTextCtor(QilUnary node)
		{
			return XmlQueryTypeFactory.Text;
		}

		public XmlQueryType CheckRawTextCtor(QilUnary node)
		{
			return XmlQueryTypeFactory.Text;
		}

		public XmlQueryType CheckDocumentCtor(QilUnary node)
		{
			return XmlQueryTypeFactory.UntypedDocument;
		}

		public XmlQueryType CheckNamespaceDecl(QilBinary node)
		{
			return XmlQueryTypeFactory.Namespace;
		}

		public XmlQueryType CheckRtfCtor(QilBinary node)
		{
			return XmlQueryTypeFactory.Node;
		}

		public XmlQueryType CheckNameOf(QilUnary node)
		{
			return XmlQueryTypeFactory.QNameX;
		}

		public XmlQueryType CheckLocalNameOf(QilUnary node)
		{
			return XmlQueryTypeFactory.StringX;
		}

		public XmlQueryType CheckNamespaceUriOf(QilUnary node)
		{
			return XmlQueryTypeFactory.StringX;
		}

		public XmlQueryType CheckPrefixOf(QilUnary node)
		{
			return XmlQueryTypeFactory.StringX;
		}

		public XmlQueryType CheckDeepCopy(QilUnary node)
		{
			return node.XmlType;
		}

		public XmlQueryType CheckTypeAssert(QilTargetType node)
		{
			return node.TargetType;
		}

		public XmlQueryType CheckIsType(QilTargetType node)
		{
			return XmlQueryTypeFactory.BooleanX;
		}

		public XmlQueryType CheckIsEmpty(QilUnary node)
		{
			return XmlQueryTypeFactory.BooleanX;
		}

		public XmlQueryType CheckXPathNodeValue(QilUnary node)
		{
			return XmlQueryTypeFactory.StringX;
		}

		public XmlQueryType CheckXPathFollowing(QilUnary node)
		{
			return XmlQueryTypeFactory.ContentS;
		}

		public XmlQueryType CheckXPathPreceding(QilUnary node)
		{
			return XmlQueryTypeFactory.ContentS;
		}

		public XmlQueryType CheckXPathNamespace(QilUnary node)
		{
			return XmlQueryTypeFactory.NamespaceS;
		}

		public XmlQueryType CheckXsltGenerateId(QilUnary node)
		{
			return XmlQueryTypeFactory.StringX;
		}

		public XmlQueryType CheckXsltInvokeLateBound(QilInvokeLateBound node)
		{
			return XmlQueryTypeFactory.ItemS;
		}

		public XmlQueryType CheckXsltInvokeEarlyBound(QilInvokeEarlyBound node)
		{
			return node.XmlType;
		}

		public XmlQueryType CheckXsltCopy(QilBinary node)
		{
			return XmlQueryTypeFactory.Choice(node.Left.XmlType, node.Right.XmlType);
		}

		public XmlQueryType CheckXsltCopyOf(QilUnary node)
		{
			if ((node.Child.XmlType.NodeKinds & XmlNodeKindFlags.Document) != 0)
			{
				return XmlQueryTypeFactory.NodeNotRtfS;
			}
			return node.Child.XmlType;
		}

		public XmlQueryType CheckXsltConvert(QilTargetType node)
		{
			return node.TargetType;
		}

		[Conditional("DEBUG")]
		private void Check(bool value, QilNode node, string message)
		{
		}

		[Conditional("DEBUG")]
		private void CheckLiteralValue(QilNode node, Type clrTypeValue)
		{
			((QilLiteral)node).Value.GetType();
		}

		[Conditional("DEBUG")]
		private void CheckClass(QilNode node, Type clrTypeClass)
		{
		}

		[Conditional("DEBUG")]
		private void CheckClassAndNodeType(QilNode node, Type clrTypeClass, QilNodeType nodeType)
		{
		}

		[Conditional("DEBUG")]
		private void CheckXmlType(QilNode node, XmlQueryType xmlType)
		{
		}

		[Conditional("DEBUG")]
		private void CheckNumericX(QilNode node)
		{
		}

		[Conditional("DEBUG")]
		private void CheckNumericXS(QilNode node)
		{
		}

		[Conditional("DEBUG")]
		private void CheckAtomicX(QilNode node)
		{
		}

		[Conditional("DEBUG")]
		private void CheckNotDisjoint(QilBinary node)
		{
		}

		private XmlQueryType DistinctType(XmlQueryType type)
		{
			if (type.Cardinality == XmlQueryCardinality.More)
			{
				return XmlQueryTypeFactory.PrimeProduct(type, XmlQueryCardinality.OneOrMore);
			}
			if (type.Cardinality == XmlQueryCardinality.NotOne)
			{
				return XmlQueryTypeFactory.PrimeProduct(type, XmlQueryCardinality.ZeroOrMore);
			}
			return type;
		}

		private XmlQueryType FindFilterType(QilIterator variable, QilNode body)
		{
			if (body.XmlType.TypeCode == XmlTypeCode.None)
			{
				return XmlQueryTypeFactory.None;
			}
			switch (body.NodeType)
			{
			case QilNodeType.False:
				return XmlQueryTypeFactory.Empty;
			case QilNodeType.IsType:
				if (object.Equals(((QilTargetType)body).Source, variable))
				{
					return XmlQueryTypeFactory.AtMost(((QilTargetType)body).TargetType, variable.Binding.XmlType.Cardinality);
				}
				break;
			case QilNodeType.And:
			{
				XmlQueryType xmlQueryType = FindFilterType(variable, ((QilBinary)body).Left);
				if (xmlQueryType != null)
				{
					return xmlQueryType;
				}
				return FindFilterType(variable, ((QilBinary)body).Right);
			}
			case QilNodeType.Eq:
			{
				QilBinary qilBinary = (QilBinary)body;
				if (qilBinary.Left.NodeType == QilNodeType.PositionOf && object.Equals(((QilUnary)qilBinary.Left).Child, variable))
				{
					return XmlQueryTypeFactory.AtMost(variable.Binding.XmlType, XmlQueryCardinality.ZeroOrOne);
				}
				break;
			}
			}
			return null;
		}
	}
	internal class QilUnary : QilNode
	{
		private QilNode child;

		public override int Count => 1;

		public override QilNode this[int index]
		{
			get
			{
				if (index != 0)
				{
					throw new IndexOutOfRangeException();
				}
				return child;
			}
			set
			{
				if (index != 0)
				{
					throw new IndexOutOfRangeException();
				}
				child = value;
			}
		}

		public QilNode Child
		{
			get
			{
				return child;
			}
			set
			{
				child = value;
			}
		}

		public QilUnary(QilNodeType nodeType, QilNode child)
			: base(nodeType)
		{
			this.child = child;
		}
	}
	internal class QilValidationVisitor : QilScopedVisitor
	{
		private SubstitutionList subs = new SubstitutionList();

		private QilTypeChecker typeCheck = new QilTypeChecker();

		[Conditional("DEBUG")]
		public static void Validate(QilNode node)
		{
			new QilValidationVisitor().VisitAssumeReference(node);
		}

		protected QilValidationVisitor()
		{
		}

		[Conditional("DEBUG")]
		internal static void SetError(QilNode n, string message)
		{
			message = System.Xml.Utils.Res.GetString("Qil_Validation", message);
			if (n.Annotation is string text)
			{
				message = text + "\n" + message;
			}
			n.Annotation = message;
		}
	}
	internal class QilDepthChecker
	{
		private const int MAX_QIL_DEPTH = 800;

		private Dictionary<QilNode, bool> visitedRef = new Dictionary<QilNode, bool>();

		public static void Check(QilNode input)
		{
			if (XsltConfigSection.LimitXPathComplexity)
			{
				new QilDepthChecker().Check(input, 0);
			}
		}

		private void Check(QilNode input, int depth)
		{
			if (depth > 800)
			{
				throw XsltException.Create("Xslt_CompileError2");
			}
			if (input is QilReference)
			{
				if (visitedRef.ContainsKey(input))
				{
					return;
				}
				visitedRef[input] = true;
			}
			int depth2 = depth + 1;
			for (int i = 0; i < input.Count; i++)
			{
				QilNode qilNode = input[i];
				if (qilNode != null)
				{
					Check(qilNode, depth2);
				}
			}
		}
	}
	internal sealed class QilXmlReader
	{
		private class ReaderAnnotation
		{
			public string Id;

			public QilName Name;

			public XmlQueryType XmlType;

			public string ClrNamespace;
		}

		private static Regex lineInfoRegex;

		private static Regex typeInfoRegex;

		private static Dictionary<string, MethodInfo> nameToFactoryMethod;

		private QilFactory f;

		private XmlReader r;

		private Stack<QilList> stk;

		private bool inFwdDecls;

		private Dictionary<string, QilNode> scope;

		private Dictionary<string, QilNode> fwdDecls;

		static QilXmlReader()
		{
			lineInfoRegex = new Regex("\\[(\\d+),(\\d+) -- (\\d+),(\\d+)\\]");
			typeInfoRegex = new Regex("(\\w+);([\\w|\\|]+);(\\w+)");
			nameToFactoryMethod = new Dictionary<string, MethodInfo>();
			MethodInfo[] methods = typeof(QilFactory).GetMethods(BindingFlags.Instance | BindingFlags.Public);
			foreach (MethodInfo methodInfo in methods)
			{
				ParameterInfo[] parameters = methodInfo.GetParameters();
				int j;
				for (j = 0; j < parameters.Length && parameters[j].ParameterType == typeof(QilNode); j++)
				{
				}
				if (j == parameters.Length && (!nameToFactoryMethod.ContainsKey(methodInfo.Name) || nameToFactoryMethod[methodInfo.Name].GetParameters().Length < parameters.Length))
				{
					nameToFactoryMethod[methodInfo.Name] = methodInfo;
				}
			}
		}

		public QilXmlReader(XmlReader r)
		{
			this.r = r;
			f = new QilFactory();
		}

		public QilExpression Read()
		{
			stk = new Stack<QilList>();
			inFwdDecls = false;
			scope = new Dictionary<string, QilNode>();
			fwdDecls = new Dictionary<string, QilNode>();
			stk.Push(f.Sequence());
			while (r.Read())
			{
				switch (r.NodeType)
				{
				case XmlNodeType.Element:
				{
					bool isEmptyElement = r.IsEmptyElement;
					if (StartElement() && isEmptyElement)
					{
						EndElement();
					}
					break;
				}
				case XmlNodeType.EndElement:
					EndElement();
					break;
				}
			}
			return (QilExpression)stk.Peek()[0];
		}

		private bool StartElement()
		{
			ReaderAnnotation readerAnnotation = new ReaderAnnotation();
			_ = r.LocalName;
			QilNode qilNode;
			switch (r.LocalName)
			{
			case "LiteralString":
				qilNode = f.LiteralString(ReadText());
				break;
			case "LiteralInt32":
				qilNode = f.LiteralInt32(int.Parse(ReadText(), CultureInfo.InvariantCulture));
				break;
			case "LiteralInt64":
				qilNode = f.LiteralInt64(long.Parse(ReadText(), CultureInfo.InvariantCulture));
				break;
			case "LiteralDouble":
				qilNode = f.LiteralDouble(double.Parse(ReadText(), CultureInfo.InvariantCulture));
				break;
			case "LiteralDecimal":
				qilNode = f.LiteralDecimal(decimal.Parse(ReadText(), CultureInfo.InvariantCulture));
				break;
			case "LiteralType":
				qilNode = f.LiteralType(ParseType(ReadText()));
				break;
			case "LiteralQName":
				qilNode = ParseName(r.GetAttribute("name"));
				break;
			case "For":
			case "Let":
			case "Parameter":
			case "Function":
			case "RefTo":
				readerAnnotation.Id = r.GetAttribute("id");
				readerAnnotation.Name = ParseName(r.GetAttribute("name"));
				goto default;
			case "XsltInvokeEarlyBound":
				readerAnnotation.ClrNamespace = r.GetAttribute("clrNamespace");
				goto default;
			case "ForwardDecls":
				inFwdDecls = true;
				goto default;
			default:
				qilNode = f.Sequence();
				break;
			}
			readerAnnotation.XmlType = ParseType(r.GetAttribute("xmlType"));
			qilNode.SourceLine = ParseLineInfo(r.GetAttribute("lineInfo"));
			qilNode.Annotation = readerAnnotation;
			if (qilNode is QilList)
			{
				stk.Push((QilList)qilNode);
				return true;
			}
			stk.Peek().Add(qilNode);
			return false;
		}

		private void EndElement()
		{
			MethodInfo methodInfo = null;
			QilList qilList = stk.Pop();
			ReaderAnnotation readerAnnotation = (ReaderAnnotation)qilList.Annotation;
			_ = r.LocalName;
			QilNode qilNode;
			switch (r.LocalName)
			{
			case "QilExpression":
			{
				QilExpression qilExpression = f.QilExpression(qilList[qilList.Count - 1]);
				for (int k = 0; k < qilList.Count - 1; k++)
				{
					switch (qilList[k].NodeType)
					{
					case QilNodeType.True:
					case QilNodeType.False:
						qilExpression.IsDebug = qilList[k].NodeType == QilNodeType.True;
						break;
					case QilNodeType.FunctionList:
						qilExpression.FunctionList = (QilList)qilList[k];
						break;
					case QilNodeType.GlobalVariableList:
						qilExpression.GlobalVariableList = (QilList)qilList[k];
						break;
					case QilNodeType.GlobalParameterList:
						qilExpression.GlobalParameterList = (QilList)qilList[k];
						break;
					}
				}
				qilNode = qilExpression;
				break;
			}
			case "ForwardDecls":
				inFwdDecls = false;
				return;
			case "Parameter":
			case "Let":
			case "For":
			case "Function":
			{
				string id2 = readerAnnotation.Id;
				QilName name = readerAnnotation.Name;
				qilNode = r.LocalName switch
				{
					"Parameter" => (!inFwdDecls && qilList.Count != 0) ? f.Parameter(qilList[0], name, readerAnnotation.XmlType) : f.Parameter(null, name, readerAnnotation.XmlType), 
					"Let" => (!inFwdDecls) ? f.Let(qilList[0]) : f.Let(f.Unknown(readerAnnotation.XmlType)), 
					"For" => f.For(qilList[0]), 
					_ => (!inFwdDecls) ? f.Function(qilList[0], qilList[1], qilList[2], (readerAnnotation.XmlType != null) ? readerAnnotation.XmlType : qilList[1].XmlType) : f.Function(qilList[0], qilList[1], readerAnnotation.XmlType), 
				};
				if (name != null)
				{
					((QilReference)qilNode).DebugName = name.ToString();
				}
				if (inFwdDecls)
				{
					fwdDecls[id2] = qilNode;
					scope[id2] = qilNode;
				}
				else if (fwdDecls.ContainsKey(id2))
				{
					qilNode = fwdDecls[id2];
					fwdDecls.Remove(id2);
					if (qilList.Count > 0)
					{
						qilNode[0] = qilList[0];
					}
					if (qilList.Count > 1)
					{
						qilNode[1] = qilList[1];
					}
				}
				else
				{
					scope[id2] = qilNode;
				}
				qilNode.Annotation = readerAnnotation;
				break;
			}
			case "RefTo":
			{
				string id = readerAnnotation.Id;
				stk.Peek().Add(scope[id]);
				return;
			}
			case "Sequence":
				qilNode = f.Sequence(qilList);
				break;
			case "FunctionList":
				qilNode = f.FunctionList(qilList);
				break;
			case "GlobalVariableList":
				qilNode = f.GlobalVariableList(qilList);
				break;
			case "GlobalParameterList":
				qilNode = f.GlobalParameterList(qilList);
				break;
			case "ActualParameterList":
				qilNode = f.ActualParameterList(qilList);
				break;
			case "FormalParameterList":
				qilNode = f.FormalParameterList(qilList);
				break;
			case "SortKeyList":
				qilNode = f.SortKeyList(qilList);
				break;
			case "BranchList":
				qilNode = f.BranchList(qilList);
				break;
			case "XsltInvokeEarlyBound":
			{
				MethodInfo value = null;
				QilName qilName = (QilName)qilList[0];
				Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
				foreach (Assembly assembly in assemblies)
				{
					Type type = assembly.GetType(readerAnnotation.ClrNamespace);
					if (type != null)
					{
						value = type.GetMethod(qilName.LocalName);
						break;
					}
				}
				qilNode = f.XsltInvokeEarlyBound(qilName, f.LiteralObject(value), qilList[1], readerAnnotation.XmlType);
				break;
			}
			default:
			{
				methodInfo = nameToFactoryMethod[r.LocalName];
				object[] array = new object[qilList.Count];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = qilList[i];
				}
				qilNode = (QilNode)methodInfo.Invoke(f, array);
				break;
			}
			}
			qilNode.SourceLine = qilList.SourceLine;
			stk.Peek().Add(qilNode);
		}

		private string ReadText()
		{
			string text = string.Empty;
			if (!r.IsEmptyElement)
			{
				for (; r.Read(); text += r.Value)
				{
					switch (r.NodeType)
					{
					case XmlNodeType.Text:
					case XmlNodeType.Whitespace:
					case XmlNodeType.SignificantWhitespace:
						continue;
					}
					break;
				}
			}
			return text;
		}

		private ISourceLineInfo ParseLineInfo(string s)
		{
			if (s != null && s.Length > 0)
			{
				Match match = lineInfoRegex.Match(s);
				return new SourceLineInfo("", int.Parse(match.Groups[1].Value, CultureInfo.InvariantCulture), int.Parse(match.Groups[2].Value, CultureInfo.InvariantCulture), int.Parse(match.Groups[3].Value, CultureInfo.InvariantCulture), int.Parse(match.Groups[4].Value, CultureInfo.InvariantCulture));
			}
			return null;
		}

		private XmlQueryType ParseType(string s)
		{
			if (s != null && s.Length > 0)
			{
				Match match = typeInfoRegex.Match(s);
				XmlQueryCardinality c = new XmlQueryCardinality(match.Groups[1].Value);
				bool isStrict = bool.Parse(match.Groups[3].Value);
				string[] array = match.Groups[2].Value.Split('|');
				XmlQueryType[] array2 = new XmlQueryType[array.Length];
				for (int i = 0; i < array.Length; i++)
				{
					array2[i] = XmlQueryTypeFactory.Type((XmlTypeCode)Enum.Parse(typeof(XmlTypeCode), array[i]), isStrict);
				}
				return XmlQueryTypeFactory.Product(XmlQueryTypeFactory.Choice(array2), c);
			}
			return null;
		}

		private QilName ParseName(string name)
		{
			if (name != null && name.Length > 0)
			{
				int num = name.LastIndexOf('}');
				string namespaceUri;
				if (num != -1 && name[0] == '{')
				{
					namespaceUri = name.Substring(1, num - 1);
					name = name.Substring(num + 1);
				}
				else
				{
					namespaceUri = string.Empty;
				}
				ValidateNames.ParseQNameThrow(name, out var prefix, out var localName);
				return f.LiteralQName(localName, namespaceUri, prefix);
			}
			return null;
		}
	}
	internal class QilXmlWriter : QilScopedVisitor
	{
		[Flags]
		public enum Options
		{
			None = 0,
			Annotations = 1,
			TypeInfo = 2,
			RoundTripTypeInfo = 4,
			LineInfo = 8,
			NodeIdentity = 0x10,
			NodeLocation = 0x20
		}

		internal class ForwardRefFinder : QilVisitor
		{
			private List<QilNode> fwdrefs = new List<QilNode>();

			private List<QilNode> backrefs = new List<QilNode>();

			public IList<QilNode> Find(QilExpression qil)
			{
				Visit(qil);
				return fwdrefs;
			}

			protected override QilNode Visit(QilNode node)
			{
				if (node is QilIterator || node is QilFunction)
				{
					backrefs.Add(node);
				}
				return base.Visit(node);
			}

			protected override QilNode VisitReference(QilNode node)
			{
				if (!backrefs.Contains(node) && !fwdrefs.Contains(node))
				{
					fwdrefs.Add(node);
				}
				return node;
			}
		}

		private sealed class NameGenerator
		{
			private class NameAnnotation : ListBase<object>
			{
				public string Name;

				public object PriorAnnotation;

				public override int Count => 1;

				public override object this[int index]
				{
					get
					{
						if (index == 0)
						{
							return PriorAnnotation;
						}
						throw new IndexOutOfRangeException();
					}
					set
					{
						throw new NotSupportedException();
					}
				}

				public NameAnnotation(string s, object a)
				{
					Name = s;
					PriorAnnotation = a;
				}
			}

			private StringBuilder name;

			private int len;

			private int zero;

			private char start;

			private char end;

			public NameGenerator()
			{
				string text = "$";
				len = (zero = text.Length);
				start = 'a';
				end = 'z';
				name = new StringBuilder(text, len + 2);
				name.Append(start);
			}

			public string NextName()
			{
				string result = name.ToString();
				char c = name[len];
				if (c != end)
				{
					c = (name[len] = (char)(c + 1));
				}
				else
				{
					name[len] = start;
					int num = len;
					while (num-- > zero && name[num] == end)
					{
						name[num] = start;
					}
					if (num < zero)
					{
						len++;
						name.Append(start);
					}
					else
					{
						name[num] += '\u0001';
					}
				}
				return result;
			}

			public string NameOf(QilNode n)
			{
				string text = null;
				object annotation = n.Annotation;
				if (!(annotation is NameAnnotation nameAnnotation))
				{
					text = NextName();
					n.Annotation = new NameAnnotation(text, annotation);
				}
				else
				{
					text = nameAnnotation.Name;
				}
				return text;
			}

			public void ClearName(QilNode n)
			{
				if (n.Annotation is NameAnnotation)
				{
					n.Annotation = ((NameAnnotation)n.Annotation).PriorAnnotation;
				}
			}
		}

		protected XmlWriter writer;

		protected Options options;

		private NameGenerator ngen;

		public QilXmlWriter(XmlWriter writer)
			: this(writer, Options.Annotations | Options.TypeInfo | Options.LineInfo | Options.NodeIdentity | Options.NodeLocation)
		{
		}

		public QilXmlWriter(XmlWriter writer, Options options)
		{
			this.writer = writer;
			ngen = new NameGenerator();
			this.options = options;
		}

		public void ToXml(QilNode node)
		{
			VisitAssumeReference(node);
		}

		protected virtual void WriteAnnotations(object ann)
		{
			string text = null;
			string text2 = null;
			if (ann == null)
			{
				return;
			}
			if (ann is string)
			{
				text = ann as string;
			}
			else if (ann is IQilAnnotation)
			{
				IQilAnnotation qilAnnotation = ann as IQilAnnotation;
				text2 = qilAnnotation.Name;
				text = ann.ToString();
			}
			else if (ann is IList<object>)
			{
				IList<object> list = (IList<object>)ann;
				{
					foreach (object item in list)
					{
						WriteAnnotations(item);
					}
					return;
				}
			}
			if (text != null && text.Length != 0)
			{
				writer.WriteComment((text2 != null && text2.Length != 0) ? (text2 + ": " + text) : text);
			}
		}

		protected virtual void WriteLineInfo(QilNode node)
		{
			writer.WriteAttributeString("lineInfo", string.Format(CultureInfo.InvariantCulture, "[{0},{1} -- {2},{3}]", node.SourceLine.StartLine, node.SourceLine.StartPos, node.SourceLine.EndLine, node.SourceLine.EndPos));
		}

		protected virtual void WriteXmlType(QilNode node)
		{
			writer.WriteAttributeString("xmlType", node.XmlType.ToString(((options & Options.RoundTripTypeInfo) != 0) ? "S" : "G"));
		}

		protected override QilNode VisitChildren(QilNode node)
		{
			if (node is QilLiteral)
			{
				writer.WriteValue(Convert.ToString(((QilLiteral)node).Value, CultureInfo.InvariantCulture));
				return node;
			}
			if (node is QilReference)
			{
				QilReference qilReference = (QilReference)node;
				writer.WriteAttributeString("id", ngen.NameOf(node));
				if (qilReference.DebugName != null)
				{
					writer.WriteAttributeString("name", qilReference.DebugName.ToString());
				}
				if (node.NodeType == QilNodeType.Parameter)
				{
					QilParameter qilParameter = (QilParameter)node;
					if (qilParameter.DefaultValue != null)
					{
						Visit(qilParameter.DefaultValue);
					}
					return node;
				}
			}
			return base.VisitChildren(node);
		}

		protected override QilNode VisitReference(QilNode node)
		{
			QilReference qilReference = (QilReference)node;
			string text = ngen.NameOf(node);
			if (text == null)
			{
				text = "OUT-OF-SCOPE REFERENCE";
			}
			writer.WriteStartElement("RefTo");
			writer.WriteAttributeString("id", text);
			if (qilReference.DebugName != null)
			{
				writer.WriteAttributeString("name", qilReference.DebugName.ToString());
			}
			writer.WriteEndElement();
			return node;
		}

		protected override QilNode VisitQilExpression(QilExpression qil)
		{
			IList<QilNode> list = new ForwardRefFinder().Find(qil);
			if (list != null && list.Count > 0)
			{
				writer.WriteStartElement("ForwardDecls");
				foreach (QilNode item in list)
				{
					writer.WriteStartElement(Enum.GetName(typeof(QilNodeType), item.NodeType));
					writer.WriteAttributeString("id", ngen.NameOf(item));
					WriteXmlType(item);
					if (item.NodeType == QilNodeType.Function)
					{
						Visit(item[0]);
						Visit(item[2]);
					}
					writer.WriteEndElement();
				}
				writer.WriteEndElement();
			}
			return VisitChildren(qil);
		}

		protected override QilNode VisitLiteralType(QilLiteral value)
		{
			writer.WriteString(((XmlQueryType)value).ToString(((options & Options.TypeInfo) != 0) ? "G" : "S"));
			return value;
		}

		protected override QilNode VisitLiteralQName(QilName value)
		{
			writer.WriteAttributeString("name", value.ToString());
			return value;
		}

		protected override void BeginScope(QilNode node)
		{
			ngen.NameOf(node);
		}

		protected override void EndScope(QilNode node)
		{
			ngen.ClearName(node);
		}

		protected override void BeforeVisit(QilNode node)
		{
			base.BeforeVisit(node);
			if ((options & Options.Annotations) != 0)
			{
				WriteAnnotations(node.Annotation);
			}
			writer.WriteStartElement("", Enum.GetName(typeof(QilNodeType), node.NodeType), "");
			if ((options & (Options.TypeInfo | Options.RoundTripTypeInfo)) != 0)
			{
				WriteXmlType(node);
			}
			if ((options & Options.LineInfo) != 0 && node.SourceLine != null)
			{
				WriteLineInfo(node);
			}
		}

		protected override void AfterVisit(QilNode node)
		{
			writer.WriteEndElement();
			base.AfterVisit(node);
		}
	}
	internal enum SerializationHints
	{
		None,
		CData,
		DisableOutputEscaping
	}
	internal sealed class SubstitutionList
	{
		private ArrayList s;

		public SubstitutionList()
		{
			s = new ArrayList(4);
		}

		public void AddSubstitutionPair(QilNode find, QilNode replace)
		{
			s.Add(find);
			s.Add(replace);
		}

		public void RemoveLastSubstitutionPair()
		{
			s.RemoveRange(s.Count - 2, 2);
		}

		public void RemoveLastNSubstitutionPairs(int n)
		{
			if (n > 0)
			{
				n *= 2;
				s.RemoveRange(s.Count - n, n);
			}
		}

		public QilNode FindReplacement(QilNode n)
		{
			for (int num = s.Count - 2; num >= 0; num -= 2)
			{
				if (s[num] == n)
				{
					return (QilNode)s[num + 1];
				}
			}
			return null;
		}
	}
	internal class WhitespaceRule
	{
		private string localName;

		private string namespaceName;

		private bool preserveSpace;

		public string LocalName
		{
			get
			{
				return localName;
			}
			set
			{
				localName = value;
			}
		}

		public string NamespaceName
		{
			get
			{
				return namespaceName;
			}
			set
			{
				namespaceName = value;
			}
		}

		public bool PreserveSpace => preserveSpace;

		protected WhitespaceRule()
		{
		}

		public WhitespaceRule(string localName, string namespaceName, bool preserveSpace)
		{
			Init(localName, namespaceName, preserveSpace);
		}

		protected void Init(string localName, string namespaceName, bool preserveSpace)
		{
			this.localName = localName;
			this.namespaceName = namespaceName;
			this.preserveSpace = preserveSpace;
		}

		public void GetObjectData(XmlQueryDataWriter writer)
		{
			writer.WriteStringQ(localName);
			writer.WriteStringQ(namespaceName);
			writer.Write(preserveSpace);
		}

		public WhitespaceRule(XmlQueryDataReader reader)
		{
			localName = reader.ReadStringQ();
			namespaceName = reader.ReadStringQ();
			preserveSpace = reader.ReadBoolean();
		}
	}
}
namespace System.Xml.Xsl.Runtime
{
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct ContentIterator
	{
		private XPathNavigator navCurrent;

		private bool needFirst;

		public XPathNavigator Current => navCurrent;

		public void Create(XPathNavigator context)
		{
			navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, context);
			needFirst = true;
		}

		public bool MoveNext()
		{
			if (needFirst)
			{
				needFirst = !navCurrent.MoveToFirstChild();
				return !needFirst;
			}
			return navCurrent.MoveToNext();
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct ElementContentIterator
	{
		private string localName;

		private string ns;

		private XPathNavigator navCurrent;

		private bool needFirst;

		public XPathNavigator Current => navCurrent;

		public void Create(XPathNavigator context, string localName, string ns)
		{
			navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, context);
			this.localName = localName;
			this.ns = ns;
			needFirst = true;
		}

		public bool MoveNext()
		{
			if (needFirst)
			{
				needFirst = !navCurrent.MoveToChild(localName, ns);
				return !needFirst;
			}
			return navCurrent.MoveToNext(localName, ns);
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct NodeKindContentIterator
	{
		private XPathNodeType nodeType;

		private XPathNavigator navCurrent;

		private bool needFirst;

		public XPathNavigator Current => navCurrent;

		public void Create(XPathNavigator context, XPathNodeType nodeType)
		{
			navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, context);
			this.nodeType = nodeType;
			needFirst = true;
		}

		public bool MoveNext()
		{
			if (needFirst)
			{
				needFirst = !navCurrent.MoveToChild(nodeType);
				return !needFirst;
			}
			return navCurrent.MoveToNext(nodeType);
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct AttributeIterator
	{
		private XPathNavigator navCurrent;

		private bool needFirst;

		public XPathNavigator Current => navCurrent;

		public void Create(XPathNavigator context)
		{
			navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, context);
			needFirst = true;
		}

		public bool MoveNext()
		{
			if (needFirst)
			{
				needFirst = !navCurrent.MoveToFirstAttribute();
				return !needFirst;
			}
			return navCurrent.MoveToNextAttribute();
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct NamespaceIterator
	{
		private XPathNavigator navCurrent;

		private XmlNavigatorStack navStack;

		public XPathNavigator Current => navCurrent;

		public void Create(XPathNavigator context)
		{
			navStack.Reset();
			if (!context.MoveToFirstNamespace(XPathNamespaceScope.All))
			{
				return;
			}
			do
			{
				if (context.LocalName.Length != 0 || context.Value.Length != 0)
				{
					navStack.Push(context.Clone());
				}
			}
			while (context.MoveToNextNamespace(XPathNamespaceScope.All));
			context.MoveToParent();
		}

		public bool MoveNext()
		{
			if (navStack.IsEmpty)
			{
				return false;
			}
			navCurrent = navStack.Pop();
			return true;
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct AttributeContentIterator
	{
		private XPathNavigator navCurrent;

		private bool needFirst;

		public XPathNavigator Current => navCurrent;

		public void Create(XPathNavigator context)
		{
			navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, context);
			needFirst = true;
		}

		public bool MoveNext()
		{
			if (needFirst)
			{
				needFirst = !XmlNavNeverFilter.MoveToFirstAttributeContent(navCurrent);
				return !needFirst;
			}
			return XmlNavNeverFilter.MoveToNextAttributeContent(navCurrent);
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct ContentMergeIterator
	{
		private enum IteratorState
		{
			NeedCurrent,
			HaveCurrentNeedNext,
			HaveCurrentNoNext,
			HaveCurrentHaveNext
		}

		private XmlNavigatorFilter filter;

		private XPathNavigator navCurrent;

		private XPathNavigator navNext;

		private XmlNavigatorStack navStack;

		private IteratorState state;

		public XPathNavigator Current => navCurrent;

		public void Create(XmlNavigatorFilter filter)
		{
			this.filter = filter;
			navStack.Reset();
			state = IteratorState.NeedCurrent;
		}

		public IteratorResult MoveNext(XPathNavigator input)
		{
			return MoveNext(input, isContent: true);
		}

		internal IteratorResult MoveNext(XPathNavigator input, bool isContent)
		{
			switch (state)
			{
			case IteratorState.NeedCurrent:
				if (input == null)
				{
					return IteratorResult.NoMoreNodes;
				}
				navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, input);
				if (isContent ? filter.MoveToContent(navCurrent) : filter.MoveToFollowingSibling(navCurrent))
				{
					state = IteratorState.HaveCurrentNeedNext;
				}
				return IteratorResult.NeedInputNode;
			case IteratorState.HaveCurrentNeedNext:
				if (input == null)
				{
					state = IteratorState.HaveCurrentNoNext;
					return IteratorResult.HaveCurrentNode;
				}
				navNext = XmlQueryRuntime.SyncToNavigator(navNext, input);
				if (isContent ? filter.MoveToContent(navNext) : filter.MoveToFollowingSibling(navNext))
				{
					state = IteratorState.HaveCurrentHaveNext;
					return DocOrderMerge();
				}
				return IteratorResult.NeedInputNode;
			case IteratorState.HaveCurrentNoNext:
			case IteratorState.HaveCurrentHaveNext:
				if (isContent ? (!filter.MoveToNextContent(navCurrent)) : (!filter.MoveToFollowingSibling(navCurrent)))
				{
					if (navStack.IsEmpty)
					{
						if (state == IteratorState.HaveCurrentNoNext)
						{
							return IteratorResult.NoMoreNodes;
						}
						navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, navNext);
						state = IteratorState.HaveCurrentNeedNext;
						return IteratorResult.NeedInputNode;
					}
					navCurrent = navStack.Pop();
				}
				if (state == IteratorState.HaveCurrentNoNext)
				{
					return IteratorResult.HaveCurrentNode;
				}
				return DocOrderMerge();
			default:
				return IteratorResult.NoMoreNodes;
			}
		}

		private IteratorResult DocOrderMerge()
		{
			switch (navCurrent.ComparePosition(navNext))
			{
			case XmlNodeOrder.Before:
			case XmlNodeOrder.Unknown:
				return IteratorResult.HaveCurrentNode;
			case XmlNodeOrder.After:
				navStack.Push(navCurrent);
				navCurrent = navNext;
				navNext = null;
				break;
			}
			state = IteratorState.HaveCurrentNeedNext;
			return IteratorResult.NeedInputNode;
		}
	}
	internal class DecimalFormat
	{
		public NumberFormatInfo info;

		public char digit;

		public char zeroDigit;

		public char patternSeparator;

		internal DecimalFormat(NumberFormatInfo info, char digit, char zeroDigit, char patternSeparator)
		{
			this.info = info;
			this.digit = digit;
			this.zeroDigit = zeroDigit;
			this.patternSeparator = patternSeparator;
		}
	}
	internal class DecimalFormatter
	{
		private const string ClrSpecialChars = "0#.,%‰Ee\\'\";";

		private const char EscChar = '\a';

		private NumberFormatInfo posFormatInfo;

		private NumberFormatInfo negFormatInfo;

		private string posFormat;

		private string negFormat;

		private char zeroDigit;

		public DecimalFormatter(string formatPicture, DecimalFormat decimalFormat)
		{
			if (formatPicture.Length == 0)
			{
				throw XsltException.Create("Xslt_InvalidFormat");
			}
			zeroDigit = decimalFormat.zeroDigit;
			posFormatInfo = (NumberFormatInfo)decimalFormat.info.Clone();
			StringBuilder stringBuilder = new StringBuilder();
			bool flag = true;
			bool flag2 = false;
			bool flag3 = false;
			bool flag4 = false;
			bool flag5 = false;
			bool flag6 = false;
			char c = posFormatInfo.NumberDecimalSeparator[0];
			char c2 = posFormatInfo.NumberGroupSeparator[0];
			char c3 = posFormatInfo.PercentSymbol[0];
			char c4 = posFormatInfo.PerMilleSymbol[0];
			int num = 0;
			int num2 = 0;
			int num3 = -1;
			int num4 = -1;
			for (int i = 0; i < formatPicture.Length; i++)
			{
				char c5 = formatPicture[i];
				if (c5 == decimalFormat.digit)
				{
					if (flag3 && flag)
					{
						throw XsltException.Create("Xslt_InvalidFormat1", formatPicture);
					}
					num4 = stringBuilder.Length;
					flag4 = (flag6 = true);
					stringBuilder.Append('#');
				}
				else if (c5 == decimalFormat.zeroDigit)
				{
					if (flag4 && !flag)
					{
						throw XsltException.Create("Xslt_InvalidFormat2", formatPicture);
					}
					num4 = stringBuilder.Length;
					flag3 = (flag6 = true);
					stringBuilder.Append('0');
				}
				else if (c5 == decimalFormat.patternSeparator)
				{
					if (!flag6)
					{
						throw XsltException.Create("Xslt_InvalidFormat8");
					}
					if (flag2)
					{
						throw XsltException.Create("Xslt_InvalidFormat3", formatPicture);
					}
					flag2 = true;
					if (num3 < 0)
					{
						num3 = num4 + 1;
					}
					num2 = RemoveTrailingComma(stringBuilder, num, num3);
					if (num2 > 9)
					{
						num2 = 0;
					}
					posFormatInfo.NumberGroupSizes = new int[1] { num2 };
					if (!flag5)
					{
						posFormatInfo.NumberDecimalDigits = 0;
					}
					posFormat = stringBuilder.ToString();
					stringBuilder.Length = 0;
					num3 = -1;
					num4 = -1;
					num = 0;
					flag4 = (flag3 = (flag6 = false));
					flag5 = false;
					flag = true;
					negFormatInfo = (NumberFormatInfo)decimalFormat.info.Clone();
					negFormatInfo.NegativeSign = string.Empty;
				}
				else if (c5 == c)
				{
					if (flag5)
					{
						throw XsltException.Create("Xslt_InvalidFormat5", formatPicture);
					}
					num3 = stringBuilder.Length;
					flag5 = true;
					flag4 = (flag3 = (flag = false));
					stringBuilder.Append('.');
				}
				else if (c5 == c2)
				{
					num = stringBuilder.Length;
					num4 = num;
					stringBuilder.Append(',');
				}
				else if (c5 == c3)
				{
					stringBuilder.Append('%');
				}
				else if (c5 == c4)
				{
					stringBuilder.Append('‰');
				}
				else if (c5 == '\'')
				{
					int num5 = formatPicture.IndexOf('\'', i + 1);
					if (num5 < 0)
					{
						num5 = formatPicture.Length - 1;
					}
					stringBuilder.Append(formatPicture, i, num5 - i + 1);
					i = num5;
				}
				else
				{
					if ((('0' <= c5 && c5 <= '9') || c5 == '\a') && decimalFormat.zeroDigit != '0')
					{
						stringBuilder.Append('\a');
					}
					if ("0#.,%‰Ee\\'\";".IndexOf(c5) >= 0)
					{
						stringBuilder.Append('\\');
					}
					stringBuilder.Append(c5);
				}
			}
			if (!flag6)
			{
				throw XsltException.Create("Xslt_InvalidFormat8");
			}
			NumberFormatInfo numberFormatInfo = (flag2 ? negFormatInfo : posFormatInfo);
			if (num3 < 0)
			{
				num3 = num4 + 1;
			}
			num2 = RemoveTrailingComma(stringBuilder, num, num3);
			if (num2 > 9)
			{
				num2 = 0;
			}
			numberFormatInfo.NumberGroupSizes = new int[1] { num2 };
			if (!flag5)
			{
				numberFormatInfo.NumberDecimalDigits = 0;
			}
			if (flag2)
			{
				negFormat = stringBuilder.ToString();
			}
			else
			{
				posFormat = stringBuilder.ToString();
			}
		}

		private static int RemoveTrailingComma(StringBuilder builder, int commaIndex, int decimalIndex)
		{
			if (commaIndex > 0 && commaIndex == decimalIndex - 1)
			{
				builder.Remove(decimalIndex - 1, 1);
			}
			else if (decimalIndex > commaIndex)
			{
				return decimalIndex - commaIndex - 1;
			}
			return 0;
		}

		public string Format(double value)
		{
			NumberFormatInfo numberFormatInfo;
			string text;
			if (value < 0.0 && negFormatInfo != null)
			{
				numberFormatInfo = negFormatInfo;
				text = negFormat;
			}
			else
			{
				numberFormatInfo = posFormatInfo;
				text = posFormat;
			}
			string text2 = value.ToString(text, numberFormatInfo);
			if (zeroDigit != '0')
			{
				StringBuilder stringBuilder = new StringBuilder(text2.Length);
				int num = zeroDigit - 48;
				for (int i = 0; i < text2.Length; i++)
				{
					char c = text2[i];
					switch (c)
					{
					case '0':
					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
					case '8':
					case '9':
						c = (char)(c + (ushort)num);
						break;
					case '\a':
						c = text2[++i];
						break;
					}
					stringBuilder.Append(c);
				}
				text2 = stringBuilder.ToString();
			}
			return text2;
		}

		public static string Format(double value, string formatPicture, DecimalFormat decimalFormat)
		{
			return new DecimalFormatter(formatPicture, decimalFormat).Format(value);
		}
	}
	internal class DocumentOrderComparer : IComparer<XPathNavigator>
	{
		private List<XPathNavigator> roots;

		public int Compare(XPathNavigator navThis, XPathNavigator navThat)
		{
			switch (navThis.ComparePosition(navThat))
			{
			case XmlNodeOrder.Before:
				return -1;
			case XmlNodeOrder.Same:
				return 0;
			case XmlNodeOrder.After:
				return 1;
			default:
				if (roots == null)
				{
					roots = new List<XPathNavigator>();
				}
				if (GetDocumentIndex(navThis) >= GetDocumentIndex(navThat))
				{
					return 1;
				}
				return -1;
			}
		}

		public int GetDocumentIndex(XPathNavigator nav)
		{
			if (roots == null)
			{
				roots = new List<XPathNavigator>();
			}
			XPathNavigator xPathNavigator = nav.Clone();
			xPathNavigator.MoveToRoot();
			for (int i = 0; i < roots.Count; i++)
			{
				if (xPathNavigator.IsSamePosition(roots[i]))
				{
					return i;
				}
			}
			roots.Add(xPathNavigator);
			return roots.Count - 1;
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct DodSequenceMerge
	{
		private IList<XPathNavigator> firstSequence;

		private List<IEnumerator<XPathNavigator>> sequencesToMerge;

		private int nodeCount;

		private XmlQueryRuntime runtime;

		public void Create(XmlQueryRuntime runtime)
		{
			firstSequence = null;
			sequencesToMerge = null;
			nodeCount = 0;
			this.runtime = runtime;
		}

		public void AddSequence(IList<XPathNavigator> sequence)
		{
			if (sequence.Count == 0)
			{
				return;
			}
			if (firstSequence == null)
			{
				firstSequence = sequence;
				return;
			}
			if (sequencesToMerge == null)
			{
				sequencesToMerge = new List<IEnumerator<XPathNavigator>>();
				MoveAndInsertSequence(firstSequence.GetEnumerator());
				nodeCount = firstSequence.Count;
			}
			MoveAndInsertSequence(sequence.GetEnumerator());
			nodeCount += sequence.Count;
		}

		public IList<XPathNavigator> MergeSequences()
		{
			if (firstSequence == null)
			{
				return XmlQueryNodeSequence.Empty;
			}
			if (sequencesToMerge == null || sequencesToMerge.Count <= 1)
			{
				return firstSequence;
			}
			XmlQueryNodeSequence xmlQueryNodeSequence = new XmlQueryNodeSequence(nodeCount);
			while (sequencesToMerge.Count != 1)
			{
				IEnumerator<XPathNavigator> enumerator = sequencesToMerge[sequencesToMerge.Count - 1];
				sequencesToMerge.RemoveAt(sequencesToMerge.Count - 1);
				xmlQueryNodeSequence.Add(enumerator.Current);
				MoveAndInsertSequence(enumerator);
			}
			do
			{
				xmlQueryNodeSequence.Add(sequencesToMerge[0].Current);
			}
			while (sequencesToMerge[0].MoveNext());
			return xmlQueryNodeSequence;
		}

		private void MoveAndInsertSequence(IEnumerator<XPathNavigator> sequence)
		{
			if (sequence.MoveNext())
			{
				InsertSequence(sequence);
			}
		}

		private void InsertSequence(IEnumerator<XPathNavigator> sequence)
		{
			for (int num = sequencesToMerge.Count - 1; num >= 0; num--)
			{
				switch (runtime.ComparePosition(sequence.Current, sequencesToMerge[num].Current))
				{
				case -1:
					sequencesToMerge.Insert(num + 1, sequence);
					return;
				case 0:
					if (!sequence.MoveNext())
					{
						return;
					}
					break;
				}
			}
			sequencesToMerge.Insert(0, sequence);
		}
	}
	internal sealed class EarlyBoundInfo
	{
		private string namespaceUri;

		private ConstructorInfo constrInfo;

		public string NamespaceUri => namespaceUri;

		public Type EarlyBoundType => constrInfo.DeclaringType;

		public EarlyBoundInfo(string namespaceUri, Type ebType)
		{
			this.namespaceUri = namespaceUri;
			constrInfo = ebType.GetConstructor(Type.EmptyTypes);
		}

		public object CreateObject()
		{
			return constrInfo.Invoke(new object[0]);
		}

		public override bool Equals(object obj)
		{
			if (!(obj is EarlyBoundInfo earlyBoundInfo))
			{
				return false;
			}
			if (namespaceUri == earlyBoundInfo.namespaceUri)
			{
				return constrInfo == earlyBoundInfo.constrInfo;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return namespaceUri.GetHashCode();
		}
	}
	internal static class CharUtil
	{
		public static bool IsAlphaNumeric(char ch)
		{
			int unicodeCategory = (int)char.GetUnicodeCategory(ch);
			if (unicodeCategory > 4)
			{
				if (unicodeCategory <= 10)
				{
					return unicodeCategory >= 8;
				}
				return false;
			}
			return true;
		}

		public static bool IsDecimalDigitOne(char ch)
		{
			int unicodeCategory = (int)char.GetUnicodeCategory(ch = (char)(ch - 1));
			if (unicodeCategory == 8)
			{
				return char.GetNumericValue(ch) == 0.0;
			}
			return false;
		}
	}
	internal enum NumberingSequence
	{
		Nil = -1,
		FirstDecimal = 0,
		Arabic = 0,
		DArabic = 1,
		Hindi3 = 2,
		Thai2 = 3,
		FEDecimal = 4,
		KorDbNum1 = 5,
		LastNum = 5,
		FirstAlpha = 6,
		UCLetter = 6,
		LCLetter = 7,
		UCRus = 8,
		LCRus = 9,
		Thai1 = 10,
		Hindi1 = 11,
		Hindi2 = 12,
		Aiueo = 13,
		DAiueo = 14,
		Iroha = 15,
		DIroha = 16,
		DChosung = 17,
		Ganada = 18,
		ArabicScript = 19,
		LastAlpha = 19,
		FirstSpecial = 20,
		UCRoman = 20,
		LCRoman = 21,
		Hebrew = 22,
		DbNum3 = 23,
		ChnCmplx = 24,
		KorDbNum3 = 25,
		Zodiac1 = 26,
		Zodiac2 = 27,
		Zodiac3 = 28,
		LastSpecial = 28
	}
	internal class NumberFormatterBase
	{
		protected const int MaxAlphabeticValue = int.MaxValue;

		private const int MaxAlphabeticLength = 7;

		protected const int MaxRomanValue = 32767;

		private const string RomanDigitsUC = "IIVIXXLXCCDCM";

		private const string RomanDigitsLC = "iivixxlxccdcm";

		private const string hiraganaAiueo = "あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわをん";

		private const string hiraganaIroha = "いろはにほへとちりぬるをわかよたれそつねならむうゐのおくやまけふこえてあさきゆめみしゑひもせす";

		private const string katakanaAiueo = "アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン";

		private const string katakanaIroha = "イロハニホヘトチリヌルヲワカヨタレソツネナラムウヰノオクヤマケフコエテアサキユメミシヱヒモセスン";

		private const string katakanaAiueoHw = "ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐﾑﾒﾓﾔﾕﾖﾗﾘﾙﾚﾛﾜｦﾝ";

		private const string katakanaIrohaHw = "ｲﾛﾊﾆﾎﾍﾄﾁﾘﾇﾙｦﾜｶﾖﾀﾚｿﾂﾈﾅﾗﾑｳヰﾉｵｸﾔﾏｹﾌｺｴﾃｱｻｷﾕﾒﾐｼヱﾋﾓｾｽﾝ";

		private const string cjkIdeographic = "〇一二三四五六七八九";

		private static readonly int[] RomanDigitValue = new int[13]
		{
			1, 4, 5, 9, 10, 40, 50, 90, 100, 400,
			500, 900, 1000
		};

		public static void ConvertToAlphabetic(StringBuilder sb, double val, char firstChar, int totalChars)
		{
			char[] array = new char[7];
			int num = 7;
			int num2 = (int)val;
			while (num2 > totalChars)
			{
				int num3 = --num2 / totalChars;
				array[--num] = (char)(firstChar + (num2 - num3 * totalChars));
				num2 = num3;
			}
			array[--num] = (char)(firstChar + --num2);
			sb.Append(array, num, 7 - num);
		}

		public static void ConvertToRoman(StringBuilder sb, double val, bool upperCase)
		{
			int num = (int)val;
			string value = (upperCase ? "IIVIXXLXCCDCM" : "iivixxlxccdcm");
			int num2 = RomanDigitValue.Length;
			while (num2-- != 0)
			{
				while (num >= RomanDigitValue[num2])
				{
					num -= RomanDigitValue[num2];
					sb.Append(value, num2, 1 + (num2 & 1));
				}
			}
		}
	}
	internal abstract class RtfNavigator : XPathNavigator
	{
		public override XPathNodeType NodeType => XPathNodeType.Root;

		public override string LocalName => string.Empty;

		public override string NamespaceURI => string.Empty;

		public override string Name => string.Empty;

		public override string Prefix => string.Empty;

		public override bool IsEmptyElement => false;

		public override XmlNameTable NameTable
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public abstract void CopyToWriter(XmlWriter writer);

		public abstract XPathNavigator ToNavigator();

		public override bool MoveToFirstAttribute()
		{
			throw new NotSupportedException();
		}

		public override bool MoveToNextAttribute()
		{
			throw new NotSupportedException();
		}

		public override bool MoveToFirstNamespace(XPathNamespaceScope namespaceScope)
		{
			throw new NotSupportedException();
		}

		public override bool MoveToNextNamespace(XPathNamespaceScope namespaceScope)
		{
			throw new NotSupportedException();
		}

		public override bool MoveToNext()
		{
			throw new NotSupportedException();
		}

		public override bool MoveToPrevious()
		{
			throw new NotSupportedException();
		}

		public override bool MoveToFirstChild()
		{
			throw new NotSupportedException();
		}

		public override bool MoveToParent()
		{
			throw new NotSupportedException();
		}

		public override bool MoveToId(string id)
		{
			throw new NotSupportedException();
		}

		public override bool IsSamePosition(XPathNavigator other)
		{
			throw new NotSupportedException();
		}
	}
	internal sealed class RtfTreeNavigator : RtfNavigator
	{
		private XmlEventCache events;

		private NavigatorConstructor constr;

		private XmlNameTable nameTable;

		public override string Value => events.EventsToString();

		public override string BaseURI => events.BaseUri;

		public RtfTreeNavigator(XmlEventCache events, XmlNameTable nameTable)
		{
			this.events = events;
			constr = new NavigatorConstructor();
			this.nameTable = nameTable;
		}

		public RtfTreeNavigator(RtfTreeNavigator that)
		{
			events = that.events;
			constr = that.constr;
			nameTable = that.nameTable;
		}

		public override void CopyToWriter(XmlWriter writer)
		{
			events.EventsToWriter(writer);
		}

		public override XPathNavigator ToNavigator()
		{
			return constr.GetNavigator(events, nameTable);
		}

		public override XPathNavigator Clone()
		{
			return new RtfTreeNavigator(this);
		}

		public override bool MoveTo(XPathNavigator other)
		{
			if (other is RtfTreeNavigator rtfTreeNavigator)
			{
				events = rtfTreeNavigator.events;
				constr = rtfTreeNavigator.constr;
				nameTable = rtfTreeNavigator.nameTable;
				return true;
			}
			return false;
		}
	}
	internal sealed class RtfTextNavigator : RtfNavigator
	{
		private string text;

		private string baseUri;

		private NavigatorConstructor constr;

		public override string Value => text;

		public override string BaseURI => baseUri;

		public RtfTextNavigator(string text, string baseUri)
		{
			this.text = text;
			this.baseUri = baseUri;
			constr = new NavigatorConstructor();
		}

		public RtfTextNavigator(RtfTextNavigator that)
		{
			text = that.text;
			baseUri = that.baseUri;
			constr = that.constr;
		}

		public override void CopyToWriter(XmlWriter writer)
		{
			writer.WriteString(Value);
		}

		public override XPathNavigator ToNavigator()
		{
			return constr.GetNavigator(text, baseUri, new NameTable());
		}

		public override XPathNavigator Clone()
		{
			return new RtfTextNavigator(this);
		}

		public override bool MoveTo(XPathNavigator other)
		{
			if (other is RtfTextNavigator rtfTextNavigator)
			{
				text = rtfTextNavigator.text;
				baseUri = rtfTextNavigator.baseUri;
				constr = rtfTextNavigator.constr;
				return true;
			}
			return false;
		}
	}
	internal sealed class NavigatorConstructor
	{
		private object cache;

		public XPathNavigator GetNavigator(XmlEventCache events, XmlNameTable nameTable)
		{
			if (cache == null)
			{
				XPathDocument xPathDocument = new XPathDocument(nameTable);
				XmlRawWriter xmlRawWriter = xPathDocument.LoadFromWriter(XPathDocument.LoadFlags.AtomizeNames | ((!events.HasRootNode) ? XPathDocument.LoadFlags.Fragment : XPathDocument.LoadFlags.None), events.BaseUri);
				events.EventsToWriter(xmlRawWriter);
				xmlRawWriter.Close();
				cache = xPathDocument;
			}
			return ((XPathDocument)cache).CreateNavigator();
		}

		public XPathNavigator GetNavigator(string text, string baseUri, XmlNameTable nameTable)
		{
			if (cache == null)
			{
				XPathDocument xPathDocument = new XPathDocument(nameTable);
				XmlRawWriter xmlRawWriter = xPathDocument.LoadFromWriter(XPathDocument.LoadFlags.AtomizeNames, baseUri);
				xmlRawWriter.WriteString(text);
				xmlRawWriter.Close();
				cache = xPathDocument;
			}
			return ((XPathDocument)cache).CreateNavigator();
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public enum SetIteratorResult
	{
		NoMoreNodes,
		InitRightIterator,
		NeedLeftNode,
		NeedRightNode,
		HaveCurrentNode
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct UnionIterator
	{
		private enum IteratorState
		{
			InitLeft,
			NeedLeft,
			NeedRight,
			LeftIsCurrent,
			RightIsCurrent
		}

		private XmlQueryRuntime runtime;

		private XPathNavigator navCurr;

		private XPathNavigator navOther;

		private IteratorState state;

		public XPathNavigator Current => navCurr;

		public void Create(XmlQueryRuntime runtime)
		{
			this.runtime = runtime;
			state = IteratorState.InitLeft;
		}

		public SetIteratorResult MoveNext(XPathNavigator nestedNavigator)
		{
			switch (state)
			{
			case IteratorState.InitLeft:
				navOther = nestedNavigator;
				state = IteratorState.NeedRight;
				return SetIteratorResult.InitRightIterator;
			case IteratorState.NeedLeft:
				navCurr = nestedNavigator;
				state = IteratorState.LeftIsCurrent;
				break;
			case IteratorState.NeedRight:
				navCurr = nestedNavigator;
				state = IteratorState.RightIsCurrent;
				break;
			case IteratorState.LeftIsCurrent:
				state = IteratorState.NeedLeft;
				return SetIteratorResult.NeedLeftNode;
			case IteratorState.RightIsCurrent:
				state = IteratorState.NeedRight;
				return SetIteratorResult.NeedRightNode;
			}
			if (navCurr == null)
			{
				if (navOther == null)
				{
					return SetIteratorResult.NoMoreNodes;
				}
				Swap();
			}
			else if (navOther != null)
			{
				int num = runtime.ComparePosition(navOther, navCurr);
				if (num == 0)
				{
					if (state == IteratorState.LeftIsCurrent)
					{
						state = IteratorState.NeedLeft;
						return SetIteratorResult.NeedLeftNode;
					}
					state = IteratorState.NeedRight;
					return SetIteratorResult.NeedRightNode;
				}
				if (num < 0)
				{
					Swap();
				}
			}
			return SetIteratorResult.HaveCurrentNode;
		}

		private void Swap()
		{
			XPathNavigator xPathNavigator = navCurr;
			navCurr = navOther;
			navOther = xPathNavigator;
			if (state == IteratorState.LeftIsCurrent)
			{
				state = IteratorState.RightIsCurrent;
			}
			else
			{
				state = IteratorState.LeftIsCurrent;
			}
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct IntersectIterator
	{
		private enum IteratorState
		{
			InitLeft,
			NeedLeft,
			NeedRight,
			NeedLeftAndRight,
			HaveCurrent
		}

		private XmlQueryRuntime runtime;

		private XPathNavigator navLeft;

		private XPathNavigator navRight;

		private IteratorState state;

		public XPathNavigator Current => navLeft;

		public void Create(XmlQueryRuntime runtime)
		{
			this.runtime = runtime;
			state = IteratorState.InitLeft;
		}

		public SetIteratorResult MoveNext(XPathNavigator nestedNavigator)
		{
			switch (state)
			{
			case IteratorState.InitLeft:
				navLeft = nestedNavigator;
				state = IteratorState.NeedRight;
				return SetIteratorResult.InitRightIterator;
			case IteratorState.NeedLeft:
				navLeft = nestedNavigator;
				break;
			case IteratorState.NeedRight:
				navRight = nestedNavigator;
				break;
			case IteratorState.NeedLeftAndRight:
				navLeft = nestedNavigator;
				state = IteratorState.NeedRight;
				return SetIteratorResult.NeedRightNode;
			case IteratorState.HaveCurrent:
				state = IteratorState.NeedLeftAndRight;
				return SetIteratorResult.NeedLeftNode;
			}
			if (navLeft == null || navRight == null)
			{
				return SetIteratorResult.NoMoreNodes;
			}
			int num = runtime.ComparePosition(navLeft, navRight);
			if (num < 0)
			{
				state = IteratorState.NeedLeft;
				return SetIteratorResult.NeedLeftNode;
			}
			if (num > 0)
			{
				state = IteratorState.NeedRight;
				return SetIteratorResult.NeedRightNode;
			}
			state = IteratorState.HaveCurrent;
			return SetIteratorResult.HaveCurrentNode;
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct DifferenceIterator
	{
		private enum IteratorState
		{
			InitLeft,
			NeedLeft,
			NeedRight,
			NeedLeftAndRight,
			HaveCurrent
		}

		private XmlQueryRuntime runtime;

		private XPathNavigator navLeft;

		private XPathNavigator navRight;

		private IteratorState state;

		public XPathNavigator Current => navLeft;

		public void Create(XmlQueryRuntime runtime)
		{
			this.runtime = runtime;
			state = IteratorState.InitLeft;
		}

		public SetIteratorResult MoveNext(XPathNavigator nestedNavigator)
		{
			switch (state)
			{
			case IteratorState.InitLeft:
				navLeft = nestedNavigator;
				state = IteratorState.NeedRight;
				return SetIteratorResult.InitRightIterator;
			case IteratorState.NeedLeft:
				navLeft = nestedNavigator;
				break;
			case IteratorState.NeedRight:
				navRight = nestedNavigator;
				break;
			case IteratorState.NeedLeftAndRight:
				navLeft = nestedNavigator;
				state = IteratorState.NeedRight;
				return SetIteratorResult.NeedRightNode;
			case IteratorState.HaveCurrent:
				state = IteratorState.NeedLeft;
				return SetIteratorResult.NeedLeftNode;
			}
			if (navLeft == null)
			{
				return SetIteratorResult.NoMoreNodes;
			}
			if (navRight != null)
			{
				int num = runtime.ComparePosition(navLeft, navRight);
				if (num == 0)
				{
					state = IteratorState.NeedLeftAndRight;
					return SetIteratorResult.NeedLeftNode;
				}
				if (num > 0)
				{
					state = IteratorState.NeedRight;
					return SetIteratorResult.NeedRightNode;
				}
			}
			state = IteratorState.HaveCurrent;
			return SetIteratorResult.HaveCurrentNode;
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct FollowingSiblingIterator
	{
		private XmlNavigatorFilter filter;

		private XPathNavigator navCurrent;

		public XPathNavigator Current => navCurrent;

		public void Create(XPathNavigator context, XmlNavigatorFilter filter)
		{
			navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, context);
			this.filter = filter;
		}

		public bool MoveNext()
		{
			return filter.MoveToFollowingSibling(navCurrent);
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct FollowingSiblingMergeIterator
	{
		private ContentMergeIterator wrapped;

		public XPathNavigator Current => wrapped.Current;

		public void Create(XmlNavigatorFilter filter)
		{
			wrapped.Create(filter);
		}

		public IteratorResult MoveNext(XPathNavigator navigator)
		{
			return wrapped.MoveNext(navigator, isContent: false);
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct PrecedingSiblingIterator
	{
		private XmlNavigatorFilter filter;

		private XPathNavigator navCurrent;

		public XPathNavigator Current => navCurrent;

		public void Create(XPathNavigator context, XmlNavigatorFilter filter)
		{
			navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, context);
			this.filter = filter;
		}

		public bool MoveNext()
		{
			return filter.MoveToPreviousSibling(navCurrent);
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct PrecedingSiblingDocOrderIterator
	{
		private XmlNavigatorFilter filter;

		private XPathNavigator navCurrent;

		private XPathNavigator navEnd;

		private bool needFirst;

		private bool useCompPos;

		public XPathNavigator Current => navCurrent;

		public void Create(XPathNavigator context, XmlNavigatorFilter filter)
		{
			this.filter = filter;
			navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, context);
			navEnd = XmlQueryRuntime.SyncToNavigator(navEnd, context);
			needFirst = true;
			useCompPos = this.filter.IsFiltered(context);
		}

		public bool MoveNext()
		{
			if (needFirst)
			{
				if (!navCurrent.MoveToParent())
				{
					return false;
				}
				if (!filter.MoveToContent(navCurrent))
				{
					return false;
				}
				needFirst = false;
			}
			else if (!filter.MoveToFollowingSibling(navCurrent))
			{
				return false;
			}
			if (useCompPos)
			{
				return navCurrent.ComparePosition(navEnd) == XmlNodeOrder.Before;
			}
			if (navCurrent.IsSamePosition(navEnd))
			{
				useCompPos = true;
				return false;
			}
			return true;
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct StringConcat
	{
		private string s1;

		private string s2;

		private string s3;

		private string s4;

		private string delimiter;

		private List<string> strList;

		private int idxStr;

		public string Delimiter
		{
			get
			{
				return delimiter;
			}
			set
			{
				delimiter = value;
			}
		}

		internal int Count => idxStr;

		public void Clear()
		{
			idxStr = 0;
			delimiter = null;
		}

		public void Concat(string value)
		{
			if (delimiter != null && idxStr != 0)
			{
				ConcatNoDelimiter(delimiter);
			}
			ConcatNoDelimiter(value);
		}

		public string GetResult()
		{
			return idxStr switch
			{
				0 => string.Empty, 
				1 => s1, 
				2 => s1 + s2, 
				3 => s1 + s2 + s3, 
				4 => s1 + s2 + s3 + s4, 
				_ => string.Concat(strList.ToArray()), 
			};
		}

		internal void ConcatNoDelimiter(string s)
		{
			switch (idxStr)
			{
			case 0:
				s1 = s;
				break;
			case 1:
				s2 = s;
				break;
			case 2:
				s3 = s;
				break;
			case 3:
				s4 = s;
				break;
			case 4:
			{
				int capacity = ((strList == null) ? 8 : strList.Count);
				List<string> list = (strList = new List<string>(capacity));
				list.Add(s1);
				list.Add(s2);
				list.Add(s3);
				list.Add(s4);
				goto default;
			}
			default:
				strList.Add(s);
				break;
			}
			idxStr++;
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct DescendantIterator
	{
		private XmlNavigatorFilter filter;

		private XPathNavigator navCurrent;

		private XPathNavigator navEnd;

		private bool hasFirst;

		public XPathNavigator Current => navCurrent;

		public void Create(XPathNavigator input, XmlNavigatorFilter filter, bool orSelf)
		{
			navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, input);
			this.filter = filter;
			if (input.NodeType == XPathNodeType.Root)
			{
				navEnd = null;
			}
			else
			{
				navEnd = XmlQueryRuntime.SyncToNavigator(navEnd, input);
				navEnd.MoveToNonDescendant();
			}
			hasFirst = orSelf && !this.filter.IsFiltered(navCurrent);
		}

		public bool MoveNext()
		{
			if (hasFirst)
			{
				hasFirst = false;
				return true;
			}
			return filter.MoveToFollowing(navCurrent, navEnd);
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct DescendantMergeIterator
	{
		private enum IteratorState
		{
			NoPrevious,
			NeedCurrent,
			NeedDescendant
		}

		private XmlNavigatorFilter filter;

		private XPathNavigator navCurrent;

		private XPathNavigator navRoot;

		private XPathNavigator navEnd;

		private IteratorState state;

		private bool orSelf;

		public XPathNavigator Current => navCurrent;

		public void Create(XmlNavigatorFilter filter, bool orSelf)
		{
			this.filter = filter;
			state = IteratorState.NoPrevious;
			this.orSelf = orSelf;
		}

		public IteratorResult MoveNext(XPathNavigator input)
		{
			if (state != IteratorState.NeedDescendant)
			{
				if (input == null)
				{
					return IteratorResult.NoMoreNodes;
				}
				if (state != 0 && navRoot.IsDescendant(input))
				{
					return IteratorResult.NeedInputNode;
				}
				navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, input);
				navRoot = XmlQueryRuntime.SyncToNavigator(navRoot, input);
				navEnd = XmlQueryRuntime.SyncToNavigator(navEnd, input);
				navEnd.MoveToNonDescendant();
				state = IteratorState.NeedDescendant;
				if (orSelf && !filter.IsFiltered(input))
				{
					return IteratorResult.HaveCurrentNode;
				}
			}
			if (filter.MoveToFollowing(navCurrent, navEnd))
			{
				return IteratorResult.HaveCurrentNode;
			}
			state = IteratorState.NeedCurrent;
			return IteratorResult.NeedInputNode;
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct ParentIterator
	{
		private XPathNavigator navCurrent;

		private bool haveCurrent;

		public XPathNavigator Current => navCurrent;

		public void Create(XPathNavigator context, XmlNavigatorFilter filter)
		{
			navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, context);
			haveCurrent = navCurrent.MoveToParent() && !filter.IsFiltered(navCurrent);
		}

		public bool MoveNext()
		{
			if (haveCurrent)
			{
				haveCurrent = false;
				return true;
			}
			return false;
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct AncestorIterator
	{
		private XmlNavigatorFilter filter;

		private XPathNavigator navCurrent;

		private bool haveCurrent;

		public XPathNavigator Current => navCurrent;

		public void Create(XPathNavigator context, XmlNavigatorFilter filter, bool orSelf)
		{
			this.filter = filter;
			navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, context);
			haveCurrent = orSelf && !this.filter.IsFiltered(navCurrent);
		}

		public bool MoveNext()
		{
			if (haveCurrent)
			{
				haveCurrent = false;
				return true;
			}
			while (navCurrent.MoveToParent())
			{
				if (!filter.IsFiltered(navCurrent))
				{
					return true;
				}
			}
			return false;
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct AncestorDocOrderIterator
	{
		private XmlNavigatorStack stack;

		private XPathNavigator navCurrent;

		public XPathNavigator Current => navCurrent;

		public void Create(XPathNavigator context, XmlNavigatorFilter filter, bool orSelf)
		{
			AncestorIterator ancestorIterator = default(AncestorIterator);
			ancestorIterator.Create(context, filter, orSelf);
			stack.Reset();
			while (ancestorIterator.MoveNext())
			{
				stack.Push(ancestorIterator.Current.Clone());
			}
		}

		public bool MoveNext()
		{
			if (stack.IsEmpty)
			{
				return false;
			}
			navCurrent = stack.Pop();
			return true;
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct XPathFollowingIterator
	{
		private XmlNavigatorFilter filter;

		private XPathNavigator navCurrent;

		private bool needFirst;

		public XPathNavigator Current => navCurrent;

		public void Create(XPathNavigator input, XmlNavigatorFilter filter)
		{
			navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, input);
			this.filter = filter;
			needFirst = true;
		}

		public bool MoveNext()
		{
			if (needFirst)
			{
				if (!MoveFirst(filter, navCurrent))
				{
					return false;
				}
				needFirst = false;
				return true;
			}
			return filter.MoveToFollowing(navCurrent, null);
		}

		internal static bool MoveFirst(XmlNavigatorFilter filter, XPathNavigator nav)
		{
			if (nav.NodeType == XPathNodeType.Attribute || nav.NodeType == XPathNodeType.Namespace)
			{
				if (!nav.MoveToParent())
				{
					return false;
				}
				if (!filter.MoveToFollowing(nav, null))
				{
					return false;
				}
			}
			else
			{
				if (!nav.MoveToNonDescendant())
				{
					return false;
				}
				if (filter.IsFiltered(nav) && !filter.MoveToFollowing(nav, null))
				{
					return false;
				}
			}
			return true;
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct XPathFollowingMergeIterator
	{
		private enum IteratorState
		{
			NeedCandidateCurrent,
			HaveCandidateCurrent,
			HaveCurrentNeedNext,
			HaveCurrentHaveNext,
			HaveCurrentNoNext
		}

		private XmlNavigatorFilter filter;

		private IteratorState state;

		private XPathNavigator navCurrent;

		private XPathNavigator navNext;

		public XPathNavigator Current => navCurrent;

		public void Create(XmlNavigatorFilter filter)
		{
			this.filter = filter;
			state = IteratorState.NeedCandidateCurrent;
		}

		public IteratorResult MoveNext(XPathNavigator input)
		{
			switch (state)
			{
			case IteratorState.NeedCandidateCurrent:
				if (input == null)
				{
					return IteratorResult.NoMoreNodes;
				}
				navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, input);
				state = IteratorState.HaveCandidateCurrent;
				return IteratorResult.NeedInputNode;
			case IteratorState.HaveCandidateCurrent:
				if (input == null)
				{
					state = IteratorState.HaveCurrentNoNext;
					return MoveFirst();
				}
				if (navCurrent.IsDescendant(input))
				{
					goto case IteratorState.NeedCandidateCurrent;
				}
				state = IteratorState.HaveCurrentNeedNext;
				goto case IteratorState.HaveCurrentNeedNext;
			case IteratorState.HaveCurrentNeedNext:
				if (input == null)
				{
					state = IteratorState.HaveCurrentNoNext;
					return MoveFirst();
				}
				if (navCurrent.ComparePosition(input) != XmlNodeOrder.Unknown)
				{
					return IteratorResult.NeedInputNode;
				}
				navNext = XmlQueryRuntime.SyncToNavigator(navNext, input);
				state = IteratorState.HaveCurrentHaveNext;
				return MoveFirst();
			default:
				if (!filter.MoveToFollowing(navCurrent, null))
				{
					return MoveFailed();
				}
				return IteratorResult.HaveCurrentNode;
			}
		}

		private IteratorResult MoveFailed()
		{
			if (state == IteratorState.HaveCurrentNoNext)
			{
				state = IteratorState.NeedCandidateCurrent;
				return IteratorResult.NoMoreNodes;
			}
			state = IteratorState.HaveCandidateCurrent;
			XPathNavigator xPathNavigator = navCurrent;
			navCurrent = navNext;
			navNext = xPathNavigator;
			return IteratorResult.NeedInputNode;
		}

		private IteratorResult MoveFirst()
		{
			if (!XPathFollowingIterator.MoveFirst(filter, navCurrent))
			{
				return MoveFailed();
			}
			return IteratorResult.HaveCurrentNode;
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct PrecedingIterator
	{
		private XmlNavigatorStack stack;

		private XPathNavigator navCurrent;

		public XPathNavigator Current => navCurrent;

		public void Create(XPathNavigator context, XmlNavigatorFilter filter)
		{
			navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, context);
			navCurrent.MoveToRoot();
			stack.Reset();
			if (!navCurrent.IsSamePosition(context))
			{
				if (!filter.IsFiltered(navCurrent))
				{
					stack.Push(navCurrent.Clone());
				}
				while (filter.MoveToFollowing(navCurrent, context))
				{
					stack.Push(navCurrent.Clone());
				}
			}
		}

		public bool MoveNext()
		{
			if (stack.IsEmpty)
			{
				return false;
			}
			navCurrent = stack.Pop();
			return true;
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct XPathPrecedingIterator
	{
		private XmlNavigatorStack stack;

		private XPathNavigator navCurrent;

		public XPathNavigator Current => navCurrent;

		public void Create(XPathNavigator context, XmlNavigatorFilter filter)
		{
			XPathPrecedingDocOrderIterator xPathPrecedingDocOrderIterator = default(XPathPrecedingDocOrderIterator);
			xPathPrecedingDocOrderIterator.Create(context, filter);
			stack.Reset();
			while (xPathPrecedingDocOrderIterator.MoveNext())
			{
				stack.Push(xPathPrecedingDocOrderIterator.Current.Clone());
			}
		}

		public bool MoveNext()
		{
			if (stack.IsEmpty)
			{
				return false;
			}
			navCurrent = stack.Pop();
			return true;
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct XPathPrecedingDocOrderIterator
	{
		private XmlNavigatorFilter filter;

		private XPathNavigator navCurrent;

		private XmlNavigatorStack navStack;

		public XPathNavigator Current => navCurrent;

		public void Create(XPathNavigator input, XmlNavigatorFilter filter)
		{
			navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, input);
			this.filter = filter;
			PushAncestors();
		}

		public bool MoveNext()
		{
			if (!navStack.IsEmpty)
			{
				do
				{
					if (filter.MoveToFollowing(navCurrent, navStack.Peek()))
					{
						return true;
					}
					navCurrent.MoveTo(navStack.Pop());
				}
				while (!navStack.IsEmpty);
			}
			return false;
		}

		private void PushAncestors()
		{
			navStack.Reset();
			do
			{
				navStack.Push(navCurrent.Clone());
			}
			while (navCurrent.MoveToParent());
			navStack.Pop();
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct XPathPrecedingMergeIterator
	{
		private enum IteratorState
		{
			NeedCandidateCurrent,
			HaveCandidateCurrent,
			HaveCurrentHaveNext,
			HaveCurrentNoNext
		}

		private XmlNavigatorFilter filter;

		private IteratorState state;

		private XPathNavigator navCurrent;

		private XPathNavigator navNext;

		private XmlNavigatorStack navStack;

		public XPathNavigator Current => navCurrent;

		public void Create(XmlNavigatorFilter filter)
		{
			this.filter = filter;
			state = IteratorState.NeedCandidateCurrent;
		}

		public IteratorResult MoveNext(XPathNavigator input)
		{
			switch (state)
			{
			case IteratorState.NeedCandidateCurrent:
				if (input == null)
				{
					return IteratorResult.NoMoreNodes;
				}
				navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, input);
				state = IteratorState.HaveCandidateCurrent;
				return IteratorResult.NeedInputNode;
			case IteratorState.HaveCandidateCurrent:
				if (input == null)
				{
					state = IteratorState.HaveCurrentNoNext;
				}
				else
				{
					if (navCurrent.ComparePosition(input) != XmlNodeOrder.Unknown)
					{
						navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, input);
						return IteratorResult.NeedInputNode;
					}
					navNext = XmlQueryRuntime.SyncToNavigator(navNext, input);
					state = IteratorState.HaveCurrentHaveNext;
				}
				PushAncestors();
				break;
			}
			if (!navStack.IsEmpty)
			{
				do
				{
					if (filter.MoveToFollowing(navCurrent, navStack.Peek()))
					{
						return IteratorResult.HaveCurrentNode;
					}
					navCurrent.MoveTo(navStack.Pop());
				}
				while (!navStack.IsEmpty);
			}
			if (state == IteratorState.HaveCurrentNoNext)
			{
				state = IteratorState.NeedCandidateCurrent;
				return IteratorResult.NoMoreNodes;
			}
			navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, navNext);
			state = IteratorState.HaveCandidateCurrent;
			return IteratorResult.HaveCurrentNode;
		}

		private void PushAncestors()
		{
			navStack.Reset();
			do
			{
				navStack.Push(navCurrent.Clone());
			}
			while (navCurrent.MoveToParent());
			navStack.Pop();
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct NodeRangeIterator
	{
		private enum IteratorState
		{
			HaveCurrent,
			NeedCurrent,
			HaveCurrentNoNext,
			NoNext
		}

		private XmlNavigatorFilter filter;

		private XPathNavigator navCurrent;

		private XPathNavigator navEnd;

		private IteratorState state;

		public XPathNavigator Current => navCurrent;

		public void Create(XPathNavigator start, XmlNavigatorFilter filter, XPathNavigator end)
		{
			navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, start);
			navEnd = XmlQueryRuntime.SyncToNavigator(navEnd, end);
			this.filter = filter;
			if (start.IsSamePosition(end))
			{
				state = ((!filter.IsFiltered(start)) ? IteratorState.HaveCurrentNoNext : IteratorState.NoNext);
			}
			else
			{
				state = (filter.IsFiltered(start) ? IteratorState.NeedCurrent : IteratorState.HaveCurrent);
			}
		}

		public bool MoveNext()
		{
			switch (state)
			{
			case IteratorState.HaveCurrent:
				state = IteratorState.NeedCurrent;
				return true;
			case IteratorState.NeedCurrent:
				if (!filter.MoveToFollowing(navCurrent, navEnd))
				{
					if (filter.IsFiltered(navEnd))
					{
						state = IteratorState.NoNext;
						return false;
					}
					navCurrent.MoveTo(navEnd);
					state = IteratorState.NoNext;
				}
				return true;
			case IteratorState.HaveCurrentNoNext:
				state = IteratorState.NoNext;
				return true;
			default:
				return false;
			}
		}
	}
	internal class WhitespaceRuleLookup
	{
		private class InternalWhitespaceRule : WhitespaceRule
		{
			private int priority;

			private int hashCode;

			public int Priority => priority;

			public InternalWhitespaceRule()
			{
			}

			public InternalWhitespaceRule(string localName, string namespaceName, bool preserveSpace, int priority)
			{
				Init(localName, namespaceName, preserveSpace, priority);
			}

			public void Init(string localName, string namespaceName, bool preserveSpace, int priority)
			{
				Init(localName, namespaceName, preserveSpace);
				this.priority = priority;
				if (localName != null && namespaceName != null)
				{
					hashCode = localName.GetHashCode();
				}
			}

			public void Atomize(XmlNameTable nameTable)
			{
				if (base.LocalName != null)
				{
					base.LocalName = nameTable.Add(base.LocalName);
				}
				if (base.NamespaceName != null)
				{
					base.NamespaceName = nameTable.Add(base.NamespaceName);
				}
			}

			public override int GetHashCode()
			{
				return hashCode;
			}

			public override bool Equals(object obj)
			{
				InternalWhitespaceRule internalWhitespaceRule = obj as InternalWhitespaceRule;
				if ((object)base.LocalName == base.LocalName)
				{
					return (object)base.NamespaceName == internalWhitespaceRule.NamespaceName;
				}
				return false;
			}
		}

		private Hashtable qnames;

		private ArrayList wildcards;

		private InternalWhitespaceRule ruleTemp;

		private XmlNameTable nameTable;

		public WhitespaceRuleLookup()
		{
			qnames = new Hashtable();
			wildcards = new ArrayList();
		}

		public WhitespaceRuleLookup(IList<WhitespaceRule> rules)
			: this()
		{
			for (int num = rules.Count - 1; num >= 0; num--)
			{
				WhitespaceRule whitespaceRule = rules[num];
				InternalWhitespaceRule internalWhitespaceRule = new InternalWhitespaceRule(whitespaceRule.LocalName, whitespaceRule.NamespaceName, whitespaceRule.PreserveSpace, -num);
				if (whitespaceRule.LocalName == null || whitespaceRule.NamespaceName == null)
				{
					wildcards.Add(internalWhitespaceRule);
				}
				else
				{
					qnames[internalWhitespaceRule] = internalWhitespaceRule;
				}
			}
			ruleTemp = new InternalWhitespaceRule();
		}

		public void Atomize(XmlNameTable nameTable)
		{
			if (nameTable == this.nameTable)
			{
				return;
			}
			this.nameTable = nameTable;
			foreach (InternalWhitespaceRule value in qnames.Values)
			{
				value.Atomize(nameTable);
			}
			foreach (InternalWhitespaceRule wildcard in wildcards)
			{
				wildcard.Atomize(nameTable);
			}
		}

		public bool ShouldStripSpace(string localName, string namespaceName)
		{
			ruleTemp.Init(localName, namespaceName, preserveSpace: false, 0);
			InternalWhitespaceRule internalWhitespaceRule = qnames[ruleTemp] as InternalWhitespaceRule;
			int count = wildcards.Count;
			while (count-- != 0)
			{
				InternalWhitespaceRule internalWhitespaceRule2 = wildcards[count] as InternalWhitespaceRule;
				if (internalWhitespaceRule != null)
				{
					if (internalWhitespaceRule.Priority > internalWhitespaceRule2.Priority)
					{
						return !internalWhitespaceRule.PreserveSpace;
					}
					if (internalWhitespaceRule.PreserveSpace == internalWhitespaceRule2.PreserveSpace)
					{
						continue;
					}
				}
				if ((internalWhitespaceRule2.LocalName == null || (object)internalWhitespaceRule2.LocalName == localName) && (internalWhitespaceRule2.NamespaceName == null || (object)internalWhitespaceRule2.NamespaceName == namespaceName))
				{
					return !internalWhitespaceRule2.PreserveSpace;
				}
			}
			if (internalWhitespaceRule != null)
			{
				return !internalWhitespaceRule.PreserveSpace;
			}
			return false;
		}
	}
	internal class WhitespaceRuleReader : XmlWrappingReader
	{
		private WhitespaceRuleLookup wsRules;

		private BitStack stkStrip;

		private bool shouldStrip;

		private bool preserveAdjacent;

		private string val;

		private XmlCharType xmlCharType = XmlCharType.Instance;

		public override string Value
		{
			get
			{
				if (val != null)
				{
					return val;
				}
				return base.Value;
			}
		}

		public static XmlReader CreateReader(XmlReader baseReader, WhitespaceRuleLookup wsRules)
		{
			if (wsRules == null)
			{
				return baseReader;
			}
			XmlReaderSettings settings = baseReader.Settings;
			if (settings != null)
			{
				if (settings.IgnoreWhitespace)
				{
					return baseReader;
				}
			}
			else
			{
				if (baseReader is XmlTextReader xmlTextReader && xmlTextReader.WhitespaceHandling == WhitespaceHandling.None)
				{
					return baseReader;
				}
				if (baseReader is XmlTextReaderImpl xmlTextReaderImpl && xmlTextReaderImpl.WhitespaceHandling == WhitespaceHandling.None)
				{
					return baseReader;
				}
			}
			return new WhitespaceRuleReader(baseReader, wsRules);
		}

		private WhitespaceRuleReader(XmlReader baseReader, WhitespaceRuleLookup wsRules)
			: base(baseReader)
		{
			val = null;
			stkStrip = new BitStack();
			shouldStrip = false;
			preserveAdjacent = false;
			this.wsRules = wsRules;
			this.wsRules.Atomize(baseReader.NameTable);
		}

		public override bool Read()
		{
			XmlCharType instance = XmlCharType.Instance;
			string text = null;
			val = null;
			while (base.Read())
			{
				switch (base.NodeType)
				{
				case XmlNodeType.Element:
					if (!base.IsEmptyElement)
					{
						stkStrip.PushBit(shouldStrip);
						shouldStrip = wsRules.ShouldStripSpace(base.LocalName, base.NamespaceURI) && base.XmlSpace != XmlSpace.Preserve;
					}
					break;
				case XmlNodeType.EndElement:
					shouldStrip = stkStrip.PopBit();
					break;
				case XmlNodeType.Text:
				case XmlNodeType.CDATA:
					if (preserveAdjacent)
					{
						return true;
					}
					if (!shouldStrip)
					{
						break;
					}
					if (!instance.IsOnlyWhitespace(base.Value))
					{
						if (text != null)
						{
							val = text + base.Value;
						}
						preserveAdjacent = true;
						return true;
					}
					goto case XmlNodeType.Whitespace;
				case XmlNodeType.Whitespace:
				case XmlNodeType.SignificantWhitespace:
					if (preserveAdjacent)
					{
						return true;
					}
					if (shouldStrip)
					{
						text = ((text != null) ? (text + base.Value) : base.Value);
						continue;
					}
					break;
				case XmlNodeType.EntityReference:
					reader.ResolveEntity();
					break;
				case XmlNodeType.EndEntity:
					continue;
				}
				preserveAdjacent = false;
				return true;
			}
			return false;
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct Int32Aggregator
	{
		private int result;

		private int cnt;

		public int SumResult => result;

		public int AverageResult => result / cnt;

		public int MinimumResult => result;

		public int MaximumResult => result;

		public bool IsEmpty => cnt == 0;

		public void Create()
		{
			cnt = 0;
		}

		public void Sum(int value)
		{
			if (cnt == 0)
			{
				result = value;
				cnt = 1;
			}
			else
			{
				result += value;
			}
		}

		public void Average(int value)
		{
			if (cnt == 0)
			{
				result = value;
			}
			else
			{
				result += value;
			}
			cnt++;
		}

		public void Minimum(int value)
		{
			if (cnt == 0 || value < result)
			{
				result = value;
			}
			cnt = 1;
		}

		public void Maximum(int value)
		{
			if (cnt == 0 || value > result)
			{
				result = value;
			}
			cnt = 1;
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct Int64Aggregator
	{
		private long result;

		private int cnt;

		public long SumResult => result;

		public long AverageResult => result / cnt;

		public long MinimumResult => result;

		public long MaximumResult => result;

		public bool IsEmpty => cnt == 0;

		public void Create()
		{
			cnt = 0;
		}

		public void Sum(long value)
		{
			if (cnt == 0)
			{
				result = value;
				cnt = 1;
			}
			else
			{
				result += value;
			}
		}

		public void Average(long value)
		{
			if (cnt == 0)
			{
				result = value;
			}
			else
			{
				result += value;
			}
			cnt++;
		}

		public void Minimum(long value)
		{
			if (cnt == 0 || value < result)
			{
				result = value;
			}
			cnt = 1;
		}

		public void Maximum(long value)
		{
			if (cnt == 0 || value > result)
			{
				result = value;
			}
			cnt = 1;
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct DecimalAggregator
	{
		private decimal result;

		private int cnt;

		public decimal SumResult => result;

		public decimal AverageResult => result / (decimal)cnt;

		public decimal MinimumResult => result;

		public decimal MaximumResult => result;

		public bool IsEmpty => cnt == 0;

		public void Create()
		{
			cnt = 0;
		}

		public void Sum(decimal value)
		{
			if (cnt == 0)
			{
				result = value;
				cnt = 1;
			}
			else
			{
				result += value;
			}
		}

		public void Average(decimal value)
		{
			if (cnt == 0)
			{
				result = value;
			}
			else
			{
				result += value;
			}
			cnt++;
		}

		public void Minimum(decimal value)
		{
			if (cnt == 0 || value < result)
			{
				result = value;
			}
			cnt = 1;
		}

		public void Maximum(decimal value)
		{
			if (cnt == 0 || value > result)
			{
				result = value;
			}
			cnt = 1;
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct DoubleAggregator
	{
		private double result;

		private int cnt;

		public double SumResult => result;

		public double AverageResult => result / (double)cnt;

		public double MinimumResult => result;

		public double MaximumResult => result;

		public bool IsEmpty => cnt == 0;

		public void Create()
		{
			cnt = 0;
		}

		public void Sum(double value)
		{
			if (cnt == 0)
			{
				result = value;
				cnt = 1;
			}
			else
			{
				result += value;
			}
		}

		public void Average(double value)
		{
			if (cnt == 0)
			{
				result = value;
			}
			else
			{
				result += value;
			}
			cnt++;
		}

		public void Minimum(double value)
		{
			if (cnt == 0 || value < result || double.IsNaN(value))
			{
				result = value;
			}
			cnt = 1;
		}

		public void Maximum(double value)
		{
			if (cnt == 0 || value > result || double.IsNaN(value))
			{
				result = value;
			}
			cnt = 1;
		}
	}
	internal sealed class XmlAttributeCache : XmlRawWriter, IRemovableWriter
	{
		private struct AttrNameVal
		{
			private string localName;

			private string prefix;

			private string namespaceName;

			private string text;

			private XmlAtomicValue value;

			private int hashCode;

			private int nextNameIndex;

			public string LocalName => localName;

			public string Prefix => prefix;

			public string Namespace => namespaceName;

			public string Text => text;

			public XmlAtomicValue Value => value;

			public int NextNameIndex
			{
				get
				{
					return nextNameIndex;
				}
				set
				{
					nextNameIndex = value;
				}
			}

			public void Init(string prefix, string localName, string ns, int hashCode)
			{
				this.localName = localName;
				this.prefix = prefix;
				namespaceName = ns;
				this.hashCode = hashCode;
				nextNameIndex = 0;
			}

			public void Init(string text)
			{
				this.text = text;
				value = null;
			}

			public void Init(XmlAtomicValue value)
			{
				text = null;
				this.value = value;
			}

			public bool IsDuplicate(string localName, string ns, int hashCode)
			{
				if (this.localName != null && this.hashCode == hashCode && this.localName.Equals(localName) && namespaceName.Equals(ns))
				{
					this.localName = null;
					return true;
				}
				return false;
			}
		}

		private const int DefaultCacheSize = 32;

		private XmlRawWriter wrapped;

		private OnRemoveWriter onRemove;

		private AttrNameVal[] arrAttrs;

		private int numEntries;

		private int idxLastName;

		private int hashCodeUnion;

		public int Count => numEntries;

		public OnRemoveWriter OnRemoveWriterEvent
		{
			get
			{
				return onRemove;
			}
			set
			{
				onRemove = value;
			}
		}

		public void Init(XmlRawWriter wrapped)
		{
			SetWrappedWriter(wrapped);
			numEntries = 0;
			idxLastName = 0;
			hashCodeUnion = 0;
		}

		private void SetWrappedWriter(XmlRawWriter writer)
		{
			if (writer is IRemovableWriter removableWriter)
			{
				removableWriter.OnRemoveWriterEvent = SetWrappedWriter;
			}
			wrapped = writer;
		}

		public override void WriteStartAttribute(string prefix, string localName, string ns)
		{
			int num = 0;
			int num2 = 1 << (localName[0] & 0x1F);
			if ((hashCodeUnion & num2) != 0)
			{
				while (!arrAttrs[num].IsDuplicate(localName, ns, num2))
				{
					num = arrAttrs[num].NextNameIndex;
					if (num == 0)
					{
						break;
					}
				}
			}
			else
			{
				hashCodeUnion |= num2;
			}
			EnsureAttributeCache();
			if (numEntries != 0)
			{
				arrAttrs[idxLastName].NextNameIndex = numEntries;
			}
			idxLastName = numEntries++;
			arrAttrs[idxLastName].Init(prefix, localName, ns, num2);
		}

		public override void WriteEndAttribute()
		{
		}

		internal override void WriteNamespaceDeclaration(string prefix, string ns)
		{
			FlushAttributes();
			wrapped.WriteNamespaceDeclaration(prefix, ns);
		}

		public override void WriteString(string text)
		{
			EnsureAttributeCache();
			arrAttrs[numEntries++].Init(text);
		}

		public override void WriteValue(object value)
		{
			EnsureAttributeCache();
			arrAttrs[numEntries++].Init((XmlAtomicValue)value);
		}

		public override void WriteValue(string value)
		{
			WriteValue(value);
		}

		internal override void StartElementContent()
		{
			FlushAttributes();
			wrapped.StartElementContent();
		}

		public override void WriteStartElement(string prefix, string localName, string ns)
		{
		}

		internal override void WriteEndElement(string prefix, string localName, string ns)
		{
		}

		public override void WriteComment(string text)
		{
		}

		public override void WriteProcessingInstruction(string name, string text)
		{
		}

		public override void WriteEntityRef(string name)
		{
		}

		public override void Close()
		{
			wrapped.Close();
		}

		public override void Flush()
		{
			wrapped.Flush();
		}

		private void FlushAttributes()
		{
			int num = 0;
			while (num != numEntries)
			{
				int nextNameIndex = arrAttrs[num].NextNameIndex;
				if (nextNameIndex == 0)
				{
					nextNameIndex = numEntries;
				}
				string localName = arrAttrs[num].LocalName;
				if (localName != null)
				{
					string prefix = arrAttrs[num].Prefix;
					string @namespace = arrAttrs[num].Namespace;
					wrapped.WriteStartAttribute(prefix, localName, @namespace);
					while (++num != nextNameIndex)
					{
						string text = arrAttrs[num].Text;
						if (text != null)
						{
							wrapped.WriteString(text);
						}
						else
						{
							wrapped.WriteValue(arrAttrs[num].Value);
						}
					}
					wrapped.WriteEndAttribute();
				}
				else
				{
					num = nextNameIndex;
				}
			}
			if (onRemove != null)
			{
				onRemove(wrapped);
			}
		}

		private void EnsureAttributeCache()
		{
			if (arrAttrs == null)
			{
				arrAttrs = new AttrNameVal[32];
			}
			else if (numEntries >= arrAttrs.Length)
			{
				AttrNameVal[] destinationArray = new AttrNameVal[numEntries * 2];
				Array.Copy(arrAttrs, destinationArray, numEntries);
				arrAttrs = destinationArray;
			}
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public sealed class XmlCollation
	{
		private const int deDE = 1031;

		private const int huHU = 1038;

		private const int jaJP = 1041;

		private const int kaGE = 1079;

		private const int koKR = 1042;

		private const int zhTW = 1028;

		private const int zhCN = 2052;

		private const int zhHK = 3076;

		private const int zhSG = 4100;

		private const int zhMO = 5124;

		private const int zhTWbopo = 197636;

		private const int deDEphon = 66567;

		private const int huHUtech = 66574;

		private const int kaGEmode = 66615;

		private const int strksort = 2;

		private const int unicsort = 1;

		private const string ignoreCaseStr = "IGNORECASE";

		private const string ignoreKanatypeStr = "IGNOREKANATYPE";

		private const string ignoreNonspaceStr = "IGNORENONSPACE";

		private const string ignoreSymbolsStr = "IGNORESYMBOLS";

		private const string ignoreWidthStr = "IGNOREWIDTH";

		private const string upperFirstStr = "UPPERFIRST";

		private const string emptyGreatestStr = "EMPTYGREATEST";

		private const string descendingOrderStr = "DESCENDINGORDER";

		private const string sortStr = "SORT";

		private const int FlagUpperFirst = 4096;

		private const int FlagEmptyGreatest = 8192;

		private const int FlagDescendingOrder = 16384;

		private const int CollationFlagsMask = 28672;

		private const int LOCALE_CURRENT = -1;

		private bool upperFirst;

		private bool emptyGreatest;

		private bool descendingOrder;

		private CultureInfo cultinfo;

		private CompareOptions compops;

		private static XmlCollation cp = new XmlCollation(CultureInfo.InvariantCulture, CompareOptions.Ordinal);

		internal static XmlCollation CodePointCollation => cp;

		internal bool EmptyGreatest => emptyGreatest;

		internal bool DescendingOrder => descendingOrder;

		internal CultureInfo Culture
		{
			get
			{
				if (cultinfo == null)
				{
					return CultureInfo.CurrentCulture;
				}
				return cultinfo;
			}
		}

		private XmlCollation()
			: this(null, CompareOptions.None)
		{
		}

		private XmlCollation(CultureInfo cultureInfo, CompareOptions compareOptions)
		{
			cultinfo = cultureInfo;
			compops = compareOptions;
		}

		internal static XmlCollation Create(string collationLiteral)
		{
			if (collationLiteral == "http://www.w3.org/2004/10/xpath-functions/collation/codepoint")
			{
				return CodePointCollation;
			}
			XmlCollation xmlCollation = new XmlCollation();
			Uri uri = new Uri(collationLiteral);
			string leftPart = uri.GetLeftPart(UriPartial.Authority);
			if (leftPart == "http://collations.microsoft.com")
			{
				string text = uri.LocalPath.Substring(1);
				if (text.Length != 0)
				{
					try
					{
						xmlCollation.cultinfo = new CultureInfo(text);
					}
					catch (ArgumentException)
					{
						throw new XslTransformException("Coll_UnsupportedLanguage", text);
					}
				}
			}
			else
			{
				if (!uri.IsBaseOf(new Uri("http://www.w3.org/2004/10/xpath-functions/collation/codepoint")))
				{
					throw new XslTransformException("Coll_Unsupported", collationLiteral);
				}
				xmlCollation.compops = CompareOptions.Ordinal;
			}
			string query = uri.Query;
			string text2 = null;
			if (query.Length != 0)
			{
				string[] array = query.Substring(1).Split('&');
				foreach (string text3 in array)
				{
					string[] array2 = text3.Split('=');
					if (array2.Length != 2)
					{
						throw new XslTransformException("Coll_BadOptFormat", text3);
					}
					string text4 = array2[0].ToUpper(CultureInfo.InvariantCulture);
					string text5 = array2[1].ToUpper(CultureInfo.InvariantCulture);
					if (text4 == "SORT")
					{
						text2 = text5;
						continue;
					}
					switch (text5)
					{
					case "1":
					case "TRUE":
						switch (text4)
						{
						case "IGNORECASE":
							xmlCollation.compops |= CompareOptions.IgnoreCase;
							break;
						case "IGNOREKANATYPE":
							xmlCollation.compops |= CompareOptions.IgnoreKanaType;
							break;
						case "IGNORENONSPACE":
							xmlCollation.compops |= CompareOptions.IgnoreNonSpace;
							break;
						case "IGNORESYMBOLS":
							xmlCollation.compops |= CompareOptions.IgnoreSymbols;
							break;
						case "IGNOREWIDTH":
							xmlCollation.compops |= CompareOptions.IgnoreWidth;
							break;
						case "UPPERFIRST":
							xmlCollation.upperFirst = true;
							break;
						case "EMPTYGREATEST":
							xmlCollation.emptyGreatest = true;
							break;
						case "DESCENDINGORDER":
							xmlCollation.descendingOrder = true;
							break;
						default:
							throw new XslTransformException("Coll_UnsupportedOpt", array2[0]);
						}
						break;
					case "0":
					case "FALSE":
						switch (text4)
						{
						case "IGNORECASE":
							xmlCollation.compops &= ~CompareOptions.IgnoreCase;
							break;
						case "IGNOREKANATYPE":
							xmlCollation.compops &= ~CompareOptions.IgnoreKanaType;
							break;
						case "IGNORENONSPACE":
							xmlCollation.compops &= ~CompareOptions.IgnoreNonSpace;
							break;
						case "IGNORESYMBOLS":
							xmlCollation.compops &= ~CompareOptions.IgnoreSymbols;
							break;
						case "IGNOREWIDTH":
							xmlCollation.compops &= ~CompareOptions.IgnoreWidth;
							break;
						case "UPPERFIRST":
							xmlCollation.upperFirst = false;
							break;
						case "EMPTYGREATEST":
							xmlCollation.emptyGreatest = false;
							break;
						case "DESCENDINGORDER":
							xmlCollation.descendingOrder = false;
							break;
						default:
							throw new XslTransformException("Coll_UnsupportedOpt", array2[0]);
						}
						break;
					default:
						throw new XslTransformException("Coll_UnsupportedOptVal", array2[0], array2[1]);
					}
				}
			}
			if (xmlCollation.upperFirst && (xmlCollation.compops & CompareOptions.IgnoreCase) != 0)
			{
				xmlCollation.upperFirst = false;
			}
			if ((xmlCollation.compops & CompareOptions.Ordinal) != 0)
			{
				xmlCollation.compops = CompareOptions.Ordinal;
				xmlCollation.upperFirst = false;
			}
			if (text2 != null && xmlCollation.cultinfo != null)
			{
				int langID = GetLangID(xmlCollation.cultinfo.LCID);
				switch (text2)
				{
				case "bopo":
					if (langID == 1028)
					{
						xmlCollation.cultinfo = new CultureInfo(197636);
					}
					break;
				case "strk":
					if (langID == 2052 || langID == 3076 || langID == 4100 || langID == 5124)
					{
						xmlCollation.cultinfo = new CultureInfo(MakeLCID(xmlCollation.cultinfo.LCID, 2));
					}
					break;
				case "uni":
					if (langID == 1041 || langID == 1042)
					{
						xmlCollation.cultinfo = new CultureInfo(MakeLCID(xmlCollation.cultinfo.LCID, 1));
					}
					break;
				case "phn":
					if (langID == 1031)
					{
						xmlCollation.cultinfo = new CultureInfo(66567);
					}
					break;
				case "tech":
					if (langID == 1038)
					{
						xmlCollation.cultinfo = new CultureInfo(66574);
					}
					break;
				case "mod":
					if (langID == 1079)
					{
						xmlCollation.cultinfo = new CultureInfo(66615);
					}
					break;
				default:
					throw new XslTransformException("Coll_UnsupportedSortOpt", text2);
				case "pron":
				case "dict":
				case "trad":
					break;
				}
			}
			return xmlCollation;
		}

		private int GetOptions()
		{
			int num = (int)compops;
			if (upperFirst)
			{
				num |= 0x1000;
			}
			if (emptyGreatest)
			{
				num |= 0x2000;
			}
			if (descendingOrder)
			{
				num |= 0x4000;
			}
			return num;
		}

		private void SetOptions(int options)
		{
			upperFirst = (options & 0x1000) != 0;
			emptyGreatest = (options & 0x2000) != 0;
			descendingOrder = (options & 0x4000) != 0;
			compops = (CompareOptions)(options & -28673);
		}

		public override bool Equals(object obj)
		{
			if (this == obj)
			{
				return true;
			}
			if (obj is XmlCollation xmlCollation && GetOptions() == xmlCollation.GetOptions())
			{
				return object.Equals(cultinfo, xmlCollation.cultinfo);
			}
			return false;
		}

		public override int GetHashCode()
		{
			int num = GetOptions();
			if (cultinfo != null)
			{
				num ^= cultinfo.GetHashCode();
			}
			return num;
		}

		internal void GetObjectData(BinaryWriter writer)
		{
			writer.Write((cultinfo != null) ? cultinfo.LCID : (-1));
			writer.Write(GetOptions());
		}

		internal XmlCollation(BinaryReader reader)
		{
			int num = reader.ReadInt32();
			cultinfo = ((num != -1) ? new CultureInfo(num) : null);
			SetOptions(reader.ReadInt32());
		}

		internal XmlSortKey CreateSortKey(string s)
		{
			System.Globalization.SortKey sortKey = Culture.CompareInfo.GetSortKey(s, compops);
			if (!upperFirst)
			{
				return new XmlStringSortKey(sortKey, descendingOrder);
			}
			byte[] keyData = sortKey.KeyData;
			if (upperFirst && keyData.Length != 0)
			{
				int i;
				for (i = 0; keyData[i] != 1; i++)
				{
				}
				do
				{
					i++;
				}
				while (keyData[i] != 1);
				do
				{
					i++;
					keyData[i] ^= byte.MaxValue;
				}
				while (keyData[i] != 254);
			}
			return new XmlStringSortKey(keyData, descendingOrder);
		}

		private static int MakeLCID(int langid, int sortid)
		{
			return (langid & 0xFFFF) | ((sortid & 0xF) << 16);
		}

		private static int GetLangID(int lcid)
		{
			return lcid & 0xFFFF;
		}
	}
	internal class XmlExtensionFunctionTable
	{
		private Dictionary<XmlExtensionFunction, XmlExtensionFunction> table;

		private XmlExtensionFunction funcCached;

		public XmlExtensionFunctionTable()
		{
			table = new Dictionary<XmlExtensionFunction, XmlExtensionFunction>();
		}

		public XmlExtensionFunction Bind(string name, string namespaceUri, int numArgs, Type objectType, BindingFlags flags)
		{
			if (funcCached == null)
			{
				funcCached = new XmlExtensionFunction();
			}
			funcCached.Init(name, namespaceUri, numArgs, objectType, flags);
			if (!table.TryGetValue(funcCached, out var value))
			{
				value = funcCached;
				funcCached = null;
				value.Bind();
				table.Add(value, value);
			}
			return value;
		}
	}
	internal class XmlExtensionFunction
	{
		private string namespaceUri;

		private string name;

		private int numArgs;

		private Type objectType;

		private BindingFlags flags;

		private int hashCode;

		private MethodInfo meth;

		private Type[] argClrTypes;

		private Type retClrType;

		private XmlQueryType[] argXmlTypes;

		private XmlQueryType retXmlType;

		public MethodInfo Method => meth;

		public Type ClrReturnType => retClrType;

		public XmlQueryType XmlReturnType => retXmlType;

		public XmlExtensionFunction()
		{
		}

		public XmlExtensionFunction(string name, string namespaceUri, MethodInfo meth)
		{
			this.name = name;
			this.namespaceUri = namespaceUri;
			Bind(meth);
		}

		public XmlExtensionFunction(string name, string namespaceUri, int numArgs, Type objectType, BindingFlags flags)
		{
			Init(name, namespaceUri, numArgs, objectType, flags);
		}

		public void Init(string name, string namespaceUri, int numArgs, Type objectType, BindingFlags flags)
		{
			this.name = name;
			this.namespaceUri = namespaceUri;
			this.numArgs = numArgs;
			this.objectType = objectType;
			this.flags = flags;
			meth = null;
			argClrTypes = null;
			retClrType = null;
			argXmlTypes = null;
			retXmlType = null;
			hashCode = namespaceUri.GetHashCode() ^ name.GetHashCode() ^ ((int)flags << 16) ^ numArgs;
		}

		public Type GetClrArgumentType(int index)
		{
			return argClrTypes[index];
		}

		public XmlQueryType GetXmlArgumentType(int index)
		{
			return argXmlTypes[index];
		}

		public bool CanBind()
		{
			MethodInfo[] methods = objectType.GetMethods(flags);
			StringComparison comparisonType = (((flags & BindingFlags.IgnoreCase) != 0) ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal);
			MethodInfo[] array = methods;
			foreach (MethodInfo methodInfo in array)
			{
				if (methodInfo.Name.Equals(name, comparisonType) && (numArgs == -1 || methodInfo.GetParameters().Length == numArgs) && !methodInfo.IsGenericMethodDefinition)
				{
					return true;
				}
			}
			return false;
		}

		public void Bind()
		{
			MethodInfo[] methods = objectType.GetMethods(flags);
			MethodInfo methodInfo = null;
			StringComparison comparisonType = (((flags & BindingFlags.IgnoreCase) != 0) ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal);
			MethodInfo[] array = methods;
			foreach (MethodInfo methodInfo2 in array)
			{
				if (methodInfo2.Name.Equals(name, comparisonType) && (numArgs == -1 || methodInfo2.GetParameters().Length == numArgs))
				{
					if (methodInfo != null)
					{
						throw new XslTransformException("XmlIl_AmbiguousExtensionMethod", namespaceUri, name, numArgs.ToString(CultureInfo.InvariantCulture));
					}
					methodInfo = methodInfo2;
				}
			}
			if (methodInfo == null)
			{
				methods = objectType.GetMethods(flags | BindingFlags.NonPublic);
				MethodInfo[] array2 = methods;
				foreach (MethodInfo methodInfo3 in array2)
				{
					if (methodInfo3.Name.Equals(name, comparisonType) && methodInfo3.GetParameters().Length == numArgs)
					{
						throw new XslTransformException("XmlIl_NonPublicExtensionMethod", namespaceUri, name);
					}
				}
				throw new XslTransformException("XmlIl_NoExtensionMethod", namespaceUri, name, numArgs.ToString(CultureInfo.InvariantCulture));
			}
			if (methodInfo.IsGenericMethodDefinition)
			{
				throw new XslTransformException("XmlIl_GenericExtensionMethod", namespaceUri, name);
			}
			Bind(methodInfo);
		}

		private void Bind(MethodInfo meth)
		{
			ParameterInfo[] parameters = meth.GetParameters();
			this.meth = meth;
			argClrTypes = new Type[parameters.Length];
			for (int i = 0; i < parameters.Length; i++)
			{
				argClrTypes[i] = GetClrType(parameters[i].ParameterType);
			}
			retClrType = GetClrType(this.meth.ReturnType);
			argXmlTypes = new XmlQueryType[parameters.Length];
			for (int i = 0; i < parameters.Length; i++)
			{
				argXmlTypes[i] = InferXmlType(argClrTypes[i]);
				if (namespaceUri.Length == 0)
				{
					if (object.Equals(argXmlTypes[i], XmlQueryTypeFactory.NodeNotRtf))
					{
						argXmlTypes[i] = XmlQueryTypeFactory.Node;
					}
					else if (object.Equals(argXmlTypes[i], XmlQueryTypeFactory.NodeDodS))
					{
						argXmlTypes[i] = XmlQueryTypeFactory.NodeS;
					}
				}
				else if (object.Equals(argXmlTypes[i], XmlQueryTypeFactory.NodeDodS))
				{
					argXmlTypes[i] = XmlQueryTypeFactory.NodeNotRtfS;
				}
			}
			retXmlType = InferXmlType(retClrType);
		}

		public object Invoke(object extObj, object[] args)
		{
			try
			{
				return meth.Invoke(extObj, flags, null, args, CultureInfo.InvariantCulture);
			}
			catch (TargetInvocationException ex)
			{
				throw new XslTransformException(ex.InnerException, "XmlIl_ExtensionError", name);
			}
			catch (Exception ex2)
			{
				if (!XmlException.IsCatchableException(ex2))
				{
					throw;
				}
				throw new XslTransformException(ex2, "XmlIl_ExtensionError", name);
			}
		}

		public override bool Equals(object other)
		{
			XmlExtensionFunction xmlExtensionFunction = other as XmlExtensionFunction;
			if (hashCode == xmlExtensionFunction.hashCode && name == xmlExtensionFunction.name && namespaceUri == xmlExtensionFunction.namespaceUri && numArgs == xmlExtensionFunction.numArgs && objectType == xmlExtensionFunction.objectType)
			{
				return flags == xmlExtensionFunction.flags;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return hashCode;
		}

		private Type GetClrType(Type clrType)
		{
			if (clrType.IsEnum)
			{
				return Enum.GetUnderlyingType(clrType);
			}
			if (clrType.IsByRef)
			{
				throw new XslTransformException("XmlIl_ByRefType", namespaceUri, name);
			}
			return clrType;
		}

		private XmlQueryType InferXmlType(Type clrType)
		{
			return XsltConvert.InferXsltType(clrType);
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public sealed class XmlILIndex
	{
		private Dictionary<string, XmlQueryNodeSequence> table;

		internal XmlILIndex()
		{
			table = new Dictionary<string, XmlQueryNodeSequence>();
		}

		public void Add(string key, XPathNavigator navigator)
		{
			if (!table.TryGetValue(key, out var value))
			{
				value = new XmlQueryNodeSequence();
				value.AddClone(navigator);
				table.Add(key, value);
			}
			else if (!navigator.IsSamePosition(value[value.Count - 1]))
			{
				value.AddClone(navigator);
			}
		}

		public XmlQueryNodeSequence Lookup(string key)
		{
			if (!table.TryGetValue(key, out var value))
			{
				return new XmlQueryNodeSequence();
			}
			return value;
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public static class XmlILStorageConverter
	{
		public static XmlAtomicValue StringToAtomicValue(string value, int index, XmlQueryRuntime runtime)
		{
			return new XmlAtomicValue(runtime.GetXmlType(index).SchemaType, value);
		}

		public static XmlAtomicValue DecimalToAtomicValue(decimal value, int index, XmlQueryRuntime runtime)
		{
			return new XmlAtomicValue(runtime.GetXmlType(index).SchemaType, value);
		}

		public static XmlAtomicValue Int64ToAtomicValue(long value, int index, XmlQueryRuntime runtime)
		{
			return new XmlAtomicValue(runtime.GetXmlType(index).SchemaType, value);
		}

		public static XmlAtomicValue Int32ToAtomicValue(int value, int index, XmlQueryRuntime runtime)
		{
			return new XmlAtomicValue(runtime.GetXmlType(index).SchemaType, value);
		}

		public static XmlAtomicValue BooleanToAtomicValue(bool value, int index, XmlQueryRuntime runtime)
		{
			return new XmlAtomicValue(runtime.GetXmlType(index).SchemaType, value);
		}

		public static XmlAtomicValue DoubleToAtomicValue(double value, int index, XmlQueryRuntime runtime)
		{
			return new XmlAtomicValue(runtime.GetXmlType(index).SchemaType, value);
		}

		public static XmlAtomicValue SingleToAtomicValue(float value, int index, XmlQueryRuntime runtime)
		{
			return new XmlAtomicValue(runtime.GetXmlType(index).SchemaType, value);
		}

		public static XmlAtomicValue DateTimeToAtomicValue(DateTime value, int index, XmlQueryRuntime runtime)
		{
			return new XmlAtomicValue(runtime.GetXmlType(index).SchemaType, value);
		}

		public static XmlAtomicValue XmlQualifiedNameToAtomicValue(XmlQualifiedName value, int index, XmlQueryRuntime runtime)
		{
			return new XmlAtomicValue(runtime.GetXmlType(index).SchemaType, value);
		}

		public static XmlAtomicValue TimeSpanToAtomicValue(TimeSpan value, int index, XmlQueryRuntime runtime)
		{
			return new XmlAtomicValue(runtime.GetXmlType(index).SchemaType, value);
		}

		public static XmlAtomicValue BytesToAtomicValue(byte[] value, int index, XmlQueryRuntime runtime)
		{
			return new XmlAtomicValue(runtime.GetXmlType(index).SchemaType, value);
		}

		public static IList<XPathItem> NavigatorsToItems(IList<XPathNavigator> listNavigators)
		{
			if (listNavigators is IList<XPathItem> result)
			{
				return result;
			}
			return new XmlQueryNodeSequence(listNavigators);
		}

		public static IList<XPathNavigator> ItemsToNavigators(IList<XPathItem> listItems)
		{
			if (listItems is IList<XPathNavigator> result)
			{
				return result;
			}
			XmlQueryNodeSequence xmlQueryNodeSequence = new XmlQueryNodeSequence(listItems.Count);
			for (int i = 0; i < listItems.Count; i++)
			{
				xmlQueryNodeSequence.Add((XPathNavigator)listItems[i]);
			}
			return xmlQueryNodeSequence;
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public enum IteratorResult
	{
		NoMoreNodes,
		NeedInputNode,
		HaveCurrentNode
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct IdIterator
	{
		private XPathNavigator navCurrent;

		private string[] idrefs;

		private int idx;

		public XPathNavigator Current => navCurrent;

		public void Create(XPathNavigator context, string value)
		{
			navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, context);
			idrefs = XmlConvert.SplitString(value);
			idx = -1;
		}

		public bool MoveNext()
		{
			do
			{
				idx++;
				if (idx >= idrefs.Length)
				{
					return false;
				}
			}
			while (!navCurrent.MoveToId(idrefs[idx]));
			return true;
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public abstract class XmlNavigatorFilter
	{
		public abstract bool MoveToContent(XPathNavigator navigator);

		public abstract bool MoveToNextContent(XPathNavigator navigator);

		public abstract bool MoveToFollowingSibling(XPathNavigator navigator);

		public abstract bool MoveToPreviousSibling(XPathNavigator navigator);

		public abstract bool MoveToFollowing(XPathNavigator navigator, XPathNavigator navigatorEnd);

		public abstract bool IsFiltered(XPathNavigator navigator);
	}
	internal class XmlNavNameFilter : XmlNavigatorFilter
	{
		private string localName;

		private string namespaceUri;

		public static XmlNavigatorFilter Create(string localName, string namespaceUri)
		{
			return new XmlNavNameFilter(localName, namespaceUri);
		}

		private XmlNavNameFilter(string localName, string namespaceUri)
		{
			this.localName = localName;
			this.namespaceUri = namespaceUri;
		}

		public override bool MoveToContent(XPathNavigator navigator)
		{
			return navigator.MoveToChild(localName, namespaceUri);
		}

		public override bool MoveToNextContent(XPathNavigator navigator)
		{
			return navigator.MoveToNext(localName, namespaceUri);
		}

		public override bool MoveToFollowingSibling(XPathNavigator navigator)
		{
			return navigator.MoveToNext(localName, namespaceUri);
		}

		public override bool MoveToPreviousSibling(XPathNavigator navigator)
		{
			return navigator.MoveToPrevious(localName, namespaceUri);
		}

		public override bool MoveToFollowing(XPathNavigator navigator, XPathNavigator navEnd)
		{
			return navigator.MoveToFollowing(localName, namespaceUri, navEnd);
		}

		public override bool IsFiltered(XPathNavigator navigator)
		{
			if (!(navigator.LocalName != localName))
			{
				return navigator.NamespaceURI != namespaceUri;
			}
			return true;
		}
	}
	internal class XmlNavTypeFilter : XmlNavigatorFilter
	{
		private static XmlNavigatorFilter[] TypeFilters;

		private XPathNodeType nodeType;

		private int mask;

		static XmlNavTypeFilter()
		{
			TypeFilters = new XmlNavigatorFilter[9];
			TypeFilters[1] = new XmlNavTypeFilter(XPathNodeType.Element);
			TypeFilters[4] = new XmlNavTypeFilter(XPathNodeType.Text);
			TypeFilters[7] = new XmlNavTypeFilter(XPathNodeType.ProcessingInstruction);
			TypeFilters[8] = new XmlNavTypeFilter(XPathNodeType.Comment);
		}

		public static XmlNavigatorFilter Create(XPathNodeType nodeType)
		{
			return TypeFilters[(int)nodeType];
		}

		private XmlNavTypeFilter(XPathNodeType nodeType)
		{
			this.nodeType = nodeType;
			mask = XPathNavigator.GetContentKindMask(nodeType);
		}

		public override bool MoveToContent(XPathNavigator navigator)
		{
			return navigator.MoveToChild(nodeType);
		}

		public override bool MoveToNextContent(XPathNavigator navigator)
		{
			return navigator.MoveToNext(nodeType);
		}

		public override bool MoveToFollowingSibling(XPathNavigator navigator)
		{
			return navigator.MoveToNext(nodeType);
		}

		public override bool MoveToPreviousSibling(XPathNavigator navigator)
		{
			return navigator.MoveToPrevious(nodeType);
		}

		public override bool MoveToFollowing(XPathNavigator navigator, XPathNavigator navEnd)
		{
			return navigator.MoveToFollowing(nodeType, navEnd);
		}

		public override bool IsFiltered(XPathNavigator navigator)
		{
			return ((1 << (int)navigator.NodeType) & mask) == 0;
		}
	}
	internal class XmlNavAttrFilter : XmlNavigatorFilter
	{
		private static XmlNavigatorFilter Singleton = new XmlNavAttrFilter();

		public static XmlNavigatorFilter Create()
		{
			return Singleton;
		}

		private XmlNavAttrFilter()
		{
		}

		public override bool MoveToContent(XPathNavigator navigator)
		{
			return navigator.MoveToFirstChild();
		}

		public override bool MoveToNextContent(XPathNavigator navigator)
		{
			return navigator.MoveToNext();
		}

		public override bool MoveToFollowingSibling(XPathNavigator navigator)
		{
			return navigator.MoveToNext();
		}

		public override bool MoveToPreviousSibling(XPathNavigator navigator)
		{
			return navigator.MoveToPrevious();
		}

		public override bool MoveToFollowing(XPathNavigator navigator, XPathNavigator navEnd)
		{
			return navigator.MoveToFollowing(XPathNodeType.All, navEnd);
		}

		public override bool IsFiltered(XPathNavigator navigator)
		{
			return navigator.NodeType == XPathNodeType.Attribute;
		}
	}
	internal class XmlNavNeverFilter : XmlNavigatorFilter
	{
		private static XmlNavigatorFilter Singleton = new XmlNavNeverFilter();

		public static XmlNavigatorFilter Create()
		{
			return Singleton;
		}

		private XmlNavNeverFilter()
		{
		}

		public override bool MoveToContent(XPathNavigator navigator)
		{
			return MoveToFirstAttributeContent(navigator);
		}

		public override bool MoveToNextContent(XPathNavigator navigator)
		{
			return MoveToNextAttributeContent(navigator);
		}

		public override bool MoveToFollowingSibling(XPathNavigator navigator)
		{
			return navigator.MoveToNext();
		}

		public override bool MoveToPreviousSibling(XPathNavigator navigator)
		{
			return navigator.MoveToPrevious();
		}

		public override bool MoveToFollowing(XPathNavigator navigator, XPathNavigator navEnd)
		{
			return navigator.MoveToFollowing(XPathNodeType.All, navEnd);
		}

		public override bool IsFiltered(XPathNavigator navigator)
		{
			return false;
		}

		public static bool MoveToFirstAttributeContent(XPathNavigator navigator)
		{
			if (!navigator.MoveToFirstAttribute())
			{
				return navigator.MoveToFirstChild();
			}
			return true;
		}

		public static bool MoveToNextAttributeContent(XPathNavigator navigator)
		{
			if (navigator.NodeType == XPathNodeType.Attribute)
			{
				if (!navigator.MoveToNextAttribute())
				{
					navigator.MoveToParent();
					if (!navigator.MoveToFirstChild())
					{
						navigator.MoveToFirstAttribute();
						while (navigator.MoveToNextAttribute())
						{
						}
						return false;
					}
				}
				return true;
			}
			return navigator.MoveToNext();
		}
	}
	internal struct XmlNavigatorStack
	{
		private const int InitialStackSize = 8;

		private XPathNavigator[] stkNav;

		private int sp;

		public bool IsEmpty => sp == 0;

		public void Push(XPathNavigator nav)
		{
			if (stkNav == null)
			{
				stkNav = new XPathNavigator[8];
			}
			else if (sp >= stkNav.Length)
			{
				XPathNavigator[] sourceArray = stkNav;
				stkNav = new XPathNavigator[2 * sp];
				Array.Copy(sourceArray, stkNav, sp);
			}
			stkNav[sp++] = nav;
		}

		public XPathNavigator Pop()
		{
			return stkNav[--sp];
		}

		public XPathNavigator Peek()
		{
			return stkNav[sp - 1];
		}

		public void Reset()
		{
			sp = 0;
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public sealed class XmlQueryContext
	{
		private XmlQueryRuntime runtime;

		private XPathNavigator defaultDataSource;

		private XmlResolver dataSources;

		private Hashtable dataSourceCache;

		private XsltArgumentList argList;

		private XmlExtensionFunctionTable extFuncsLate;

		private WhitespaceRuleLookup wsRules;

		private QueryReaderSettings readerSettings;

		public XmlNameTable QueryNameTable => readerSettings.NameTable;

		public XmlNameTable DefaultNameTable
		{
			get
			{
				if (defaultDataSource == null)
				{
					return null;
				}
				return defaultDataSource.NameTable;
			}
		}

		public XPathNavigator DefaultDataSource
		{
			get
			{
				if (defaultDataSource == null)
				{
					throw new XslTransformException("XmlIl_NoDefaultDocument", string.Empty);
				}
				return defaultDataSource;
			}
		}

		internal XmlQueryContext(XmlQueryRuntime runtime, object defaultDataSource, XmlResolver dataSources, XsltArgumentList argList, WhitespaceRuleLookup wsRules)
		{
			this.runtime = runtime;
			this.dataSources = dataSources;
			dataSourceCache = new Hashtable();
			this.argList = argList;
			this.wsRules = wsRules;
			if (defaultDataSource is XmlReader)
			{
				readerSettings = new QueryReaderSettings((XmlReader)defaultDataSource);
			}
			else
			{
				readerSettings = new QueryReaderSettings(new NameTable());
			}
			if (defaultDataSource is string)
			{
				this.defaultDataSource = GetDataSource(defaultDataSource as string, null);
				if (this.defaultDataSource == null)
				{
					throw new XslTransformException("XmlIl_UnknownDocument", defaultDataSource as string);
				}
			}
			else if (defaultDataSource != null)
			{
				this.defaultDataSource = ConstructDocument(defaultDataSource, null, null);
			}
		}

		public XPathNavigator GetDataSource(string uriRelative, string uriBase)
		{
			XPathNavigator xPathNavigator = null;
			try
			{
				Uri baseUri = ((uriBase != null) ? dataSources.ResolveUri(null, uriBase) : null);
				Uri uri = dataSources.ResolveUri(baseUri, uriRelative);
				if (uri != null)
				{
					xPathNavigator = dataSourceCache[uri] as XPathNavigator;
				}
				if (xPathNavigator == null)
				{
					object entity = dataSources.GetEntity(uri, null, null);
					if (entity != null)
					{
						xPathNavigator = ConstructDocument(entity, uriRelative, uri);
						dataSourceCache.Add(uri, xPathNavigator);
						return xPathNavigator;
					}
					return xPathNavigator;
				}
				return xPathNavigator;
			}
			catch (XslTransformException)
			{
				throw;
			}
			catch (Exception ex2)
			{
				if (!XmlException.IsCatchableException(ex2))
				{
					throw;
				}
				throw new XslTransformException(ex2, "XmlIl_DocumentLoadError", uriRelative);
			}
		}

		private XPathNavigator ConstructDocument(object dataSource, string uriRelative, Uri uriResolved)
		{
			if (dataSource is Stream stream)
			{
				XmlReader xmlReader = readerSettings.CreateReader(stream, (uriResolved != null) ? uriResolved.ToString() : null);
				try
				{
					return new XPathDocument(WhitespaceRuleReader.CreateReader(xmlReader, wsRules), XmlSpace.Preserve).CreateNavigator();
				}
				finally
				{
					xmlReader.Close();
				}
			}
			if (dataSource is XmlReader)
			{
				return new XPathDocument(WhitespaceRuleReader.CreateReader(dataSource as XmlReader, wsRules), XmlSpace.Preserve).CreateNavigator();
			}
			if (dataSource is IXPathNavigable)
			{
				if (wsRules != null)
				{
					throw new XslTransformException("XmlIl_CantStripNav", string.Empty);
				}
				return (dataSource as IXPathNavigable).CreateNavigator();
			}
			throw new XslTransformException("XmlIl_CantResolveEntity", uriRelative, dataSource.GetType().ToString());
		}

		public object GetParameter(string localName, string namespaceUri)
		{
			if (argList == null)
			{
				return null;
			}
			return argList.GetParam(localName, namespaceUri);
		}

		public object GetLateBoundObject(string namespaceUri)
		{
			if (argList == null)
			{
				return null;
			}
			return argList.GetExtensionObject(namespaceUri);
		}

		public bool LateBoundFunctionExists(string name, string namespaceUri)
		{
			if (argList == null)
			{
				return false;
			}
			object extensionObject = argList.GetExtensionObject(namespaceUri);
			if (extensionObject == null)
			{
				return false;
			}
			return new XmlExtensionFunction(name, namespaceUri, -1, extensionObject.GetType(), BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public).CanBind();
		}

		public IList<XPathItem> InvokeXsltLateBoundFunction(string name, string namespaceUri, IList<XPathItem>[] args)
		{
			object obj = ((argList != null) ? argList.GetExtensionObject(namespaceUri) : null);
			if (obj == null)
			{
				throw new XslTransformException("Xslt_ScriptInvalidPrefix", namespaceUri);
			}
			if (extFuncsLate == null)
			{
				extFuncsLate = new XmlExtensionFunctionTable();
			}
			XmlExtensionFunction xmlExtensionFunction = extFuncsLate.Bind(name, namespaceUri, args.Length, obj.GetType(), BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public);
			object[] array = new object[args.Length];
			for (int i = 0; i < args.Length; i++)
			{
				XmlQueryType xmlArgumentType = xmlExtensionFunction.GetXmlArgumentType(i);
				switch (xmlArgumentType.TypeCode)
				{
				case XmlTypeCode.Boolean:
					array[i] = XsltConvert.ToBoolean(args[i]);
					break;
				case XmlTypeCode.Double:
					array[i] = XsltConvert.ToDouble(args[i]);
					break;
				case XmlTypeCode.String:
					array[i] = XsltConvert.ToString(args[i]);
					break;
				case XmlTypeCode.Node:
					if (xmlArgumentType.IsSingleton)
					{
						array[i] = XsltConvert.ToNode(args[i]);
					}
					else
					{
						array[i] = XsltConvert.ToNodeSet(args[i]);
					}
					break;
				case XmlTypeCode.Item:
					array[i] = args[i];
					break;
				}
				Type clrArgumentType = xmlExtensionFunction.GetClrArgumentType(i);
				if (xmlArgumentType.TypeCode == XmlTypeCode.Item || !clrArgumentType.IsAssignableFrom(array[i].GetType()))
				{
					array[i] = runtime.ChangeTypeXsltArgument(xmlArgumentType, array[i], clrArgumentType);
				}
			}
			object obj2 = xmlExtensionFunction.Invoke(obj, array);
			if (obj2 == null && xmlExtensionFunction.ClrReturnType == XsltConvert.VoidType)
			{
				return XmlQueryNodeSequence.Empty;
			}
			return (IList<XPathItem>)runtime.ChangeTypeXsltResult(XmlQueryTypeFactory.ItemS, obj2);
		}

		public void OnXsltMessageEncountered(string message)
		{
			XsltMessageEncounteredEventHandler xsltMessageEncounteredEventHandler = ((argList != null) ? argList.xsltMessageEncountered : null);
			if (xsltMessageEncounteredEventHandler != null)
			{
				xsltMessageEncounteredEventHandler(this, new XmlILQueryEventArgs(message));
			}
			else
			{
				Console.WriteLine(message);
			}
		}
	}
	internal class XmlILQueryEventArgs : XsltMessageEncounteredEventArgs
	{
		private string message;

		public override string Message => message;

		public XmlILQueryEventArgs(string message)
		{
			this.message = message;
		}
	}
	internal enum XmlState
	{
		WithinSequence,
		EnumAttrs,
		WithinContent,
		WithinAttr,
		WithinNmsp,
		WithinComment,
		WithinPI
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public sealed class XmlQueryOutput : XmlWriter
	{
		private XmlRawWriter xwrt;

		private XmlQueryRuntime runtime;

		private XmlAttributeCache attrCache;

		private int depth;

		private XmlState xstate;

		private XmlSequenceWriter seqwrt;

		private XmlNamespaceManager nsmgr;

		private int cntNmsp;

		private Hashtable conflictPrefixes;

		private int prefixIndex;

		private string piTarget;

		private StringConcat nodeText;

		private Stack stkNames;

		private XPathNodeType rootType;

		private bool useDefNmsp;

		internal XmlSequenceWriter SequenceWriter => seqwrt;

		internal XmlRawWriter Writer
		{
			get
			{
				return xwrt;
			}
			set
			{
				if (value is IRemovableWriter removableWriter)
				{
					removableWriter.OnRemoveWriterEvent = SetWrappedWriter;
				}
				xwrt = value;
			}
		}

		public override WriteState WriteState
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public override XmlSpace XmlSpace
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public override string XmlLang
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		internal XmlQueryOutput(XmlQueryRuntime runtime, XmlSequenceWriter seqwrt)
		{
			this.runtime = runtime;
			this.seqwrt = seqwrt;
			xstate = XmlState.WithinSequence;
		}

		internal XmlQueryOutput(XmlQueryRuntime runtime, XmlEventCache xwrt)
		{
			this.runtime = runtime;
			this.xwrt = xwrt;
			xstate = XmlState.WithinContent;
			depth = 1;
			rootType = XPathNodeType.Root;
		}

		private void SetWrappedWriter(XmlRawWriter writer)
		{
			if (Writer is XmlAttributeCache)
			{
				attrCache = (XmlAttributeCache)Writer;
			}
			Writer = writer;
		}

		public override void WriteStartDocument()
		{
			throw new NotSupportedException();
		}

		public override void WriteStartDocument(bool standalone)
		{
			throw new NotSupportedException();
		}

		public override void WriteEndDocument()
		{
			throw new NotSupportedException();
		}

		public override void WriteDocType(string name, string pubid, string sysid, string subset)
		{
			throw new NotSupportedException();
		}

		public override void WriteStartElement(string prefix, string localName, string ns)
		{
			ConstructWithinContent(XPathNodeType.Element);
			WriteStartElementUnchecked(prefix, localName, ns);
			WriteNamespaceDeclarationUnchecked(prefix, ns);
			if (attrCache == null)
			{
				attrCache = new XmlAttributeCache();
			}
			attrCache.Init(Writer);
			Writer = attrCache;
			attrCache = null;
			PushElementNames(prefix, localName, ns);
		}

		public override void WriteEndElement()
		{
			if (xstate == XmlState.EnumAttrs)
			{
				StartElementContentUnchecked();
			}
			PopElementNames(out var prefix, out var localName, out var ns);
			WriteEndElementUnchecked(prefix, localName, ns);
			if (depth == 0)
			{
				EndTree();
			}
		}

		public override void WriteFullEndElement()
		{
			WriteEndElement();
		}

		public override void WriteStartAttribute(string prefix, string localName, string ns)
		{
			if (prefix.Length == 5 && prefix == "xmlns")
			{
				WriteStartNamespace(localName);
				return;
			}
			ConstructInEnumAttrs(XPathNodeType.Attribute);
			if (ns.Length != 0 && depth != 0)
			{
				prefix = CheckAttributePrefix(prefix, ns);
			}
			WriteStartAttributeUnchecked(prefix, localName, ns);
		}

		public override void WriteEndAttribute()
		{
			if (xstate == XmlState.WithinNmsp)
			{
				WriteEndNamespace();
				return;
			}
			WriteEndAttributeUnchecked();
			if (depth == 0)
			{
				EndTree();
			}
		}

		public override void WriteComment(string text)
		{
			WriteStartComment();
			WriteCommentString(text);
			WriteEndComment();
		}

		public override void WriteProcessingInstruction(string target, string text)
		{
			WriteStartProcessingInstruction(target);
			WriteProcessingInstructionString(text);
			WriteEndProcessingInstruction();
		}

		public override void WriteEntityRef(string name)
		{
			throw new NotSupportedException();
		}

		public override void WriteCharEntity(char ch)
		{
			throw new NotSupportedException();
		}

		public override void WriteSurrogateCharEntity(char lowChar, char highChar)
		{
			throw new NotSupportedException();
		}

		public override void WriteWhitespace(string ws)
		{
			throw new NotSupportedException();
		}

		public override void WriteString(string text)
		{
			WriteString(text, disableOutputEscaping: false);
		}

		public override void WriteChars(char[] buffer, int index, int count)
		{
			throw new NotSupportedException();
		}

		public override void WriteRaw(char[] buffer, int index, int count)
		{
			throw new NotSupportedException();
		}

		public override void WriteRaw(string data)
		{
			WriteString(data, disableOutputEscaping: true);
		}

		public override void WriteCData(string text)
		{
			WriteString(text, disableOutputEscaping: false);
		}

		public override void WriteBase64(byte[] buffer, int index, int count)
		{
			throw new NotSupportedException();
		}

		public override void Close()
		{
		}

		public override void Flush()
		{
		}

		public override string LookupPrefix(string ns)
		{
			throw new NotSupportedException();
		}

		public void StartTree(XPathNodeType rootType)
		{
			Writer = seqwrt.StartTree(rootType, nsmgr, runtime.NameTable);
			this.rootType = rootType;
			xstate = ((rootType == XPathNodeType.Attribute || rootType == XPathNodeType.Namespace) ? XmlState.EnumAttrs : XmlState.WithinContent);
		}

		public void EndTree()
		{
			seqwrt.EndTree();
			xstate = XmlState.WithinSequence;
			Writer = null;
		}

		public void WriteStartElementUnchecked(string prefix, string localName, string ns)
		{
			if (nsmgr != null)
			{
				nsmgr.PushScope();
			}
			Writer.WriteStartElement(prefix, localName, ns);
			xstate = XmlState.EnumAttrs;
			depth++;
			useDefNmsp = ns.Length == 0;
		}

		public void WriteStartElementUnchecked(string localName)
		{
			WriteStartElementUnchecked(string.Empty, localName, string.Empty);
		}

		public void StartElementContentUnchecked()
		{
			if (cntNmsp != 0)
			{
				WriteCachedNamespaces();
			}
			Writer.StartElementContent();
			xstate = XmlState.WithinContent;
			useDefNmsp = false;
		}

		public void WriteEndElementUnchecked(string prefix, string localName, string ns)
		{
			Writer.WriteEndElement(prefix, localName, ns);
			xstate = XmlState.WithinContent;
			depth--;
			if (nsmgr != null)
			{
				nsmgr.PopScope();
			}
		}

		public void WriteEndElementUnchecked(string localName)
		{
			WriteEndElementUnchecked(string.Empty, localName, string.Empty);
		}

		public void WriteStartAttributeUnchecked(string prefix, string localName, string ns)
		{
			Writer.WriteStartAttribute(prefix, localName, ns);
			xstate = XmlState.WithinAttr;
			depth++;
		}

		public void WriteStartAttributeUnchecked(string localName)
		{
			WriteStartAttributeUnchecked(string.Empty, localName, string.Empty);
		}

		public void WriteEndAttributeUnchecked()
		{
			Writer.WriteEndAttribute();
			xstate = XmlState.EnumAttrs;
			depth--;
		}

		public void WriteNamespaceDeclarationUnchecked(string prefix, string ns)
		{
			if (depth == 0)
			{
				Writer.WriteNamespaceDeclaration(prefix, ns);
				return;
			}
			if (nsmgr == null)
			{
				if (ns.Length == 0 && prefix.Length == 0)
				{
					return;
				}
				nsmgr = new XmlNamespaceManager(runtime.NameTable);
				nsmgr.PushScope();
			}
			if (nsmgr.LookupNamespace(prefix) != ns)
			{
				AddNamespace(prefix, ns);
			}
		}

		public void WriteStringUnchecked(string text)
		{
			Writer.WriteString(text);
		}

		public void WriteRawUnchecked(string text)
		{
			Writer.WriteRaw(text);
		}

		public void WriteStartRoot()
		{
			if (xstate != 0)
			{
				ThrowInvalidStateError(XPathNodeType.Root);
			}
			StartTree(XPathNodeType.Root);
			depth++;
		}

		public void WriteEndRoot()
		{
			depth--;
			EndTree();
		}

		public void WriteStartElementLocalName(string localName)
		{
			WriteStartElement(string.Empty, localName, string.Empty);
		}

		public void WriteStartAttributeLocalName(string localName)
		{
			WriteStartAttribute(string.Empty, localName, string.Empty);
		}

		public void WriteStartElementComputed(string tagName, int prefixMappingsIndex)
		{
			WriteStartComputed(XPathNodeType.Element, tagName, prefixMappingsIndex);
		}

		public void WriteStartElementComputed(string tagName, string ns)
		{
			WriteStartComputed(XPathNodeType.Element, tagName, ns);
		}

		public void WriteStartElementComputed(XPathNavigator navigator)
		{
			WriteStartComputed(XPathNodeType.Element, navigator);
		}

		public void WriteStartElementComputed(XmlQualifiedName name)
		{
			WriteStartComputed(XPathNodeType.Element, name);
		}

		public void WriteStartAttributeComputed(string tagName, int prefixMappingsIndex)
		{
			WriteStartComputed(XPathNodeType.Attribute, tagName, prefixMappingsIndex);
		}

		public void WriteStartAttributeComputed(string tagName, string ns)
		{
			WriteStartComputed(XPathNodeType.Attribute, tagName, ns);
		}

		public void WriteStartAttributeComputed(XPathNavigator navigator)
		{
			WriteStartComputed(XPathNodeType.Attribute, navigator);
		}

		public void WriteStartAttributeComputed(XmlQualifiedName name)
		{
			WriteStartComputed(XPathNodeType.Attribute, name);
		}

		public void WriteNamespaceDeclaration(string prefix, string ns)
		{
			ConstructInEnumAttrs(XPathNodeType.Namespace);
			if (nsmgr == null)
			{
				WriteNamespaceDeclarationUnchecked(prefix, ns);
			}
			else
			{
				string text = nsmgr.LookupNamespace(prefix);
				if (ns != text)
				{
					if (text != null && (prefix.Length != 0 || text.Length != 0 || useDefNmsp))
					{
						throw new XslTransformException("XmlIl_NmspConflict", (prefix.Length == 0) ? "" : ":", prefix, ns, text);
					}
					AddNamespace(prefix, ns);
				}
			}
			if (depth == 0)
			{
				EndTree();
			}
		}

		public void WriteStartNamespace(string prefix)
		{
			ConstructInEnumAttrs(XPathNodeType.Namespace);
			piTarget = prefix;
			nodeText.Clear();
			xstate = XmlState.WithinNmsp;
			depth++;
		}

		public void WriteNamespaceString(string text)
		{
			nodeText.ConcatNoDelimiter(text);
		}

		public void WriteEndNamespace()
		{
			xstate = XmlState.EnumAttrs;
			depth--;
			WriteNamespaceDeclaration(piTarget, nodeText.GetResult());
			if (depth == 0)
			{
				EndTree();
			}
		}

		public void WriteStartComment()
		{
			ConstructWithinContent(XPathNodeType.Comment);
			nodeText.Clear();
			xstate = XmlState.WithinComment;
			depth++;
		}

		public void WriteCommentString(string text)
		{
			nodeText.ConcatNoDelimiter(text);
		}

		public void WriteEndComment()
		{
			Writer.WriteComment(nodeText.GetResult());
			xstate = XmlState.WithinContent;
			depth--;
			if (depth == 0)
			{
				EndTree();
			}
		}

		public void WriteStartProcessingInstruction(string target)
		{
			ConstructWithinContent(XPathNodeType.ProcessingInstruction);
			ValidateNames.ValidateNameThrow("", target, "", XPathNodeType.ProcessingInstruction, ValidateNames.Flags.AllExceptPrefixMapping);
			piTarget = target;
			nodeText.Clear();
			xstate = XmlState.WithinPI;
			depth++;
		}

		public void WriteProcessingInstructionString(string text)
		{
			nodeText.ConcatNoDelimiter(text);
		}

		public void WriteEndProcessingInstruction()
		{
			Writer.WriteProcessingInstruction(piTarget, nodeText.GetResult());
			xstate = XmlState.WithinContent;
			depth--;
			if (depth == 0)
			{
				EndTree();
			}
		}

		public void WriteItem(XPathItem item)
		{
			if (item.IsNode)
			{
				XPathNavigator xPathNavigator = (XPathNavigator)item;
				if (xstate == XmlState.WithinSequence)
				{
					seqwrt.WriteItem(xPathNavigator);
				}
				else
				{
					CopyNode(xPathNavigator);
				}
			}
			else
			{
				seqwrt.WriteItem(item);
			}
		}

		public void XsltCopyOf(XPathNavigator navigator)
		{
			if (navigator is RtfNavigator rtfNavigator)
			{
				rtfNavigator.CopyToWriter(this);
			}
			else if (navigator.NodeType == XPathNodeType.Root)
			{
				if (navigator.MoveToFirstChild())
				{
					do
					{
						CopyNode(navigator);
					}
					while (navigator.MoveToNext());
					navigator.MoveToParent();
				}
			}
			else
			{
				CopyNode(navigator);
			}
		}

		public bool StartCopy(XPathNavigator navigator)
		{
			if (navigator.NodeType == XPathNodeType.Root)
			{
				return true;
			}
			if (StartCopy(navigator, callChk: true))
			{
				CopyNamespaces(navigator, XPathNamespaceScope.ExcludeXml);
				return true;
			}
			return false;
		}

		public void EndCopy(XPathNavigator navigator)
		{
			if (navigator.NodeType == XPathNodeType.Element)
			{
				WriteEndElement();
			}
		}

		private void AddNamespace(string prefix, string ns)
		{
			nsmgr.AddNamespace(prefix, ns);
			cntNmsp++;
			if (ns.Length == 0)
			{
				useDefNmsp = true;
			}
		}

		private void WriteString(string text, bool disableOutputEscaping)
		{
			switch (xstate)
			{
			case XmlState.WithinSequence:
				StartTree(XPathNodeType.Text);
				goto case XmlState.WithinContent;
			case XmlState.WithinContent:
				if (disableOutputEscaping)
				{
					WriteRawUnchecked(text);
				}
				else
				{
					WriteStringUnchecked(text);
				}
				break;
			case XmlState.EnumAttrs:
				StartElementContentUnchecked();
				goto case XmlState.WithinContent;
			case XmlState.WithinAttr:
				WriteStringUnchecked(text);
				break;
			case XmlState.WithinNmsp:
				WriteNamespaceString(text);
				break;
			case XmlState.WithinComment:
				WriteCommentString(text);
				break;
			case XmlState.WithinPI:
				WriteProcessingInstructionString(text);
				break;
			}
			if (depth == 0)
			{
				EndTree();
			}
		}

		private void CopyNode(XPathNavigator navigator)
		{
			int num = depth;
			while (true)
			{
				if (StartCopy(navigator, depth == num))
				{
					_ = navigator.NodeType;
					if (navigator.MoveToFirstAttribute())
					{
						do
						{
							StartCopy(navigator, callChk: false);
						}
						while (navigator.MoveToNextAttribute());
						navigator.MoveToParent();
					}
					CopyNamespaces(navigator, (depth - 1 == num) ? XPathNamespaceScope.ExcludeXml : XPathNamespaceScope.Local);
					StartElementContentUnchecked();
					if (navigator.MoveToFirstChild())
					{
						continue;
					}
					EndCopy(navigator, depth - 1 == num);
				}
				while (true)
				{
					if (depth == num)
					{
						return;
					}
					if (navigator.MoveToNext())
					{
						break;
					}
					navigator.MoveToParent();
					EndCopy(navigator, depth - 1 == num);
				}
			}
		}

		private bool StartCopy(XPathNavigator navigator, bool callChk)
		{
			bool result = false;
			switch (navigator.NodeType)
			{
			case XPathNodeType.Element:
				if (callChk)
				{
					WriteStartElement(navigator.Prefix, navigator.LocalName, navigator.NamespaceURI);
				}
				else
				{
					WriteStartElementUnchecked(navigator.Prefix, navigator.LocalName, navigator.NamespaceURI);
				}
				result = true;
				break;
			case XPathNodeType.Attribute:
				if (callChk)
				{
					WriteStartAttribute(navigator.Prefix, navigator.LocalName, navigator.NamespaceURI);
				}
				else
				{
					WriteStartAttributeUnchecked(navigator.Prefix, navigator.LocalName, navigator.NamespaceURI);
				}
				WriteString(navigator.Value);
				if (callChk)
				{
					WriteEndAttribute();
				}
				else
				{
					WriteEndAttributeUnchecked();
				}
				break;
			case XPathNodeType.Namespace:
				if (callChk)
				{
					if (Writer is XmlAttributeCache xmlAttributeCache && xmlAttributeCache.Count != 0)
					{
						throw new XslTransformException("XmlIl_NmspAfterAttr", string.Empty);
					}
					WriteNamespaceDeclaration(navigator.LocalName, navigator.Value);
				}
				else
				{
					WriteNamespaceDeclarationUnchecked(navigator.LocalName, navigator.Value);
				}
				break;
			case XPathNodeType.Text:
			case XPathNodeType.SignificantWhitespace:
			case XPathNodeType.Whitespace:
				if (callChk)
				{
					WriteString(navigator.Value, disableOutputEscaping: false);
				}
				else
				{
					WriteStringUnchecked(navigator.Value);
				}
				break;
			case XPathNodeType.Root:
				ThrowInvalidStateError(XPathNodeType.Root);
				break;
			case XPathNodeType.Comment:
				WriteStartComment();
				WriteCommentString(navigator.Value);
				WriteEndComment();
				break;
			case XPathNodeType.ProcessingInstruction:
				WriteStartProcessingInstruction(navigator.LocalName);
				WriteProcessingInstructionString(navigator.Value);
				WriteEndProcessingInstruction();
				break;
			}
			return result;
		}

		private void EndCopy(XPathNavigator navigator, bool callChk)
		{
			if (callChk)
			{
				WriteEndElement();
			}
			else
			{
				WriteEndElementUnchecked(navigator.Prefix, navigator.LocalName, navigator.NamespaceURI);
			}
		}

		private void CopyNamespaces(XPathNavigator navigator, XPathNamespaceScope nsScope)
		{
			if (navigator.NamespaceURI.Length == 0)
			{
				WriteNamespaceDeclarationUnchecked(string.Empty, string.Empty);
			}
			if (navigator.MoveToFirstNamespace(nsScope))
			{
				CopyNamespacesHelper(navigator, nsScope);
				navigator.MoveToParent();
			}
		}

		private void CopyNamespacesHelper(XPathNavigator navigator, XPathNamespaceScope nsScope)
		{
			string localName = navigator.LocalName;
			string value = navigator.Value;
			if (navigator.MoveToNextNamespace(nsScope))
			{
				CopyNamespacesHelper(navigator, nsScope);
			}
			WriteNamespaceDeclarationUnchecked(localName, value);
		}

		private void ConstructWithinContent(XPathNodeType rootType)
		{
			switch (xstate)
			{
			case XmlState.WithinSequence:
				StartTree(rootType);
				xstate = XmlState.WithinContent;
				break;
			case XmlState.EnumAttrs:
				StartElementContentUnchecked();
				break;
			default:
				ThrowInvalidStateError(rootType);
				break;
			case XmlState.WithinContent:
				break;
			}
		}

		private void ConstructInEnumAttrs(XPathNodeType rootType)
		{
			switch (xstate)
			{
			case XmlState.WithinSequence:
				StartTree(rootType);
				xstate = XmlState.EnumAttrs;
				break;
			default:
				ThrowInvalidStateError(rootType);
				break;
			case XmlState.EnumAttrs:
				break;
			}
		}

		private void WriteCachedNamespaces()
		{
			while (cntNmsp != 0)
			{
				cntNmsp--;
				nsmgr.GetNamespaceDeclaration(cntNmsp, out var prefix, out var uri);
				Writer.WriteNamespaceDeclaration(prefix, uri);
			}
		}

		private XPathNodeType XmlStateToNodeType(XmlState xstate)
		{
			return xstate switch
			{
				XmlState.EnumAttrs => XPathNodeType.Element, 
				XmlState.WithinContent => XPathNodeType.Element, 
				XmlState.WithinAttr => XPathNodeType.Attribute, 
				XmlState.WithinComment => XPathNodeType.Comment, 
				XmlState.WithinPI => XPathNodeType.ProcessingInstruction, 
				_ => XPathNodeType.Element, 
			};
		}

		private string CheckAttributePrefix(string prefix, string ns)
		{
			if (nsmgr == null)
			{
				WriteNamespaceDeclarationUnchecked(prefix, ns);
			}
			else
			{
				while (true)
				{
					string text = nsmgr.LookupNamespace(prefix);
					if (!(text != ns))
					{
						break;
					}
					if (text != null)
					{
						prefix = RemapPrefix(prefix, ns, isElemPrefix: false);
						continue;
					}
					AddNamespace(prefix, ns);
					break;
				}
			}
			return prefix;
		}

		private string RemapPrefix(string prefix, string ns, bool isElemPrefix)
		{
			if (conflictPrefixes == null)
			{
				conflictPrefixes = new Hashtable(16);
			}
			if (nsmgr == null)
			{
				nsmgr = new XmlNamespaceManager(runtime.NameTable);
				nsmgr.PushScope();
			}
			string text = nsmgr.LookupPrefix(ns);
			if (text == null || (!isElemPrefix && text.Length == 0))
			{
				text = conflictPrefixes[ns] as string;
				if (text == null || !(text != prefix) || (!isElemPrefix && text.Length == 0))
				{
					text = string.Format(CultureInfo.InvariantCulture, "xp_{0}", prefixIndex++);
				}
			}
			conflictPrefixes[ns] = text;
			return text;
		}

		private void WriteStartComputed(XPathNodeType nodeType, string tagName, int prefixMappingsIndex)
		{
			runtime.ParseTagName(tagName, prefixMappingsIndex, out var prefix, out var localName, out var ns);
			prefix = EnsureValidName(prefix, localName, ns, nodeType);
			if (nodeType == XPathNodeType.Element)
			{
				WriteStartElement(prefix, localName, ns);
			}
			else
			{
				WriteStartAttribute(prefix, localName, ns);
			}
		}

		private void WriteStartComputed(XPathNodeType nodeType, string tagName, string ns)
		{
			ValidateNames.ParseQNameThrow(tagName, out var prefix, out var localName);
			prefix = EnsureValidName(prefix, localName, ns, nodeType);
			if (nodeType == XPathNodeType.Element)
			{
				WriteStartElement(prefix, localName, ns);
			}
			else
			{
				WriteStartAttribute(prefix, localName, ns);
			}
		}

		private void WriteStartComputed(XPathNodeType nodeType, XPathNavigator navigator)
		{
			string prefix = navigator.Prefix;
			string localName = navigator.LocalName;
			string namespaceURI = navigator.NamespaceURI;
			if (navigator.NodeType != nodeType)
			{
				prefix = EnsureValidName(prefix, localName, namespaceURI, nodeType);
			}
			if (nodeType == XPathNodeType.Element)
			{
				WriteStartElement(prefix, localName, namespaceURI);
			}
			else
			{
				WriteStartAttribute(prefix, localName, namespaceURI);
			}
		}

		private void WriteStartComputed(XPathNodeType nodeType, XmlQualifiedName name)
		{
			string prefix = ((name.Namespace.Length != 0) ? RemapPrefix(string.Empty, name.Namespace, nodeType == XPathNodeType.Element) : string.Empty);
			prefix = EnsureValidName(prefix, name.Name, name.Namespace, nodeType);
			if (nodeType == XPathNodeType.Element)
			{
				WriteStartElement(prefix, name.Name, name.Namespace);
			}
			else
			{
				WriteStartAttribute(prefix, name.Name, name.Namespace);
			}
		}

		private string EnsureValidName(string prefix, string localName, string ns, XPathNodeType nodeType)
		{
			if (!ValidateNames.ValidateName(prefix, localName, ns, nodeType, ValidateNames.Flags.AllExceptNCNames))
			{
				prefix = ((ns.Length != 0) ? RemapPrefix(string.Empty, ns, nodeType == XPathNodeType.Element) : string.Empty);
				ValidateNames.ValidateNameThrow(prefix, localName, ns, nodeType, ValidateNames.Flags.AllExceptNCNames);
			}
			return prefix;
		}

		private void PushElementNames(string prefix, string localName, string ns)
		{
			if (stkNames == null)
			{
				stkNames = new Stack();
			}
			stkNames.Push(prefix);
			stkNames.Push(localName);
			stkNames.Push(ns);
		}

		private void PopElementNames(out string prefix, out string localName, out string ns)
		{
			ns = stkNames.Pop() as string;
			localName = stkNames.Pop() as string;
			prefix = stkNames.Pop() as string;
		}

		private void ThrowInvalidStateError(XPathNodeType constructorType)
		{
			switch (constructorType)
			{
			case XPathNodeType.Root:
			case XPathNodeType.Element:
			case XPathNodeType.Text:
			case XPathNodeType.ProcessingInstruction:
			case XPathNodeType.Comment:
				throw new XslTransformException("XmlIl_BadXmlState", constructorType.ToString(), XmlStateToNodeType(xstate).ToString());
			case XPathNodeType.Attribute:
			case XPathNodeType.Namespace:
				if (depth == 1)
				{
					throw new XslTransformException("XmlIl_BadXmlState", constructorType.ToString(), rootType.ToString());
				}
				if (xstate == XmlState.WithinContent)
				{
					throw new XslTransformException("XmlIl_BadXmlStateAttr", string.Empty);
				}
				goto case XPathNodeType.Root;
			default:
				throw new XslTransformException("XmlIl_BadXmlState", "Unknown", XmlStateToNodeType(xstate).ToString());
			}
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public sealed class XmlQueryRuntime
	{
		internal const BindingFlags EarlyBoundFlags = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public;

		internal const BindingFlags LateBoundFlags = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public;

		private XmlQueryContext ctxt;

		private XsltLibrary xsltLib;

		private EarlyBoundInfo[] earlyInfo;

		private object[] earlyObjects;

		private string[] globalNames;

		private object[] globalValues;

		private XmlNameTable nameTableQuery;

		private string[] atomizedNames;

		private XmlNavigatorFilter[] filters;

		private StringPair[][] prefixMappingsList;

		private XmlQueryType[] types;

		private XmlCollation[] collations;

		private DocumentOrderComparer docOrderCmp;

		private ArrayList[] indexes;

		private XmlQueryOutput output;

		private Stack<XmlQueryOutput> stkOutput;

		public XmlQueryContext ExternalContext => ctxt;

		public XsltLibrary XsltFunctions
		{
			get
			{
				if (xsltLib == null)
				{
					xsltLib = new XsltLibrary(this);
				}
				return xsltLib;
			}
		}

		public XmlNameTable NameTable => nameTableQuery;

		internal XmlQueryType[] XmlTypes => types;

		public XmlQueryOutput Output => output;

		internal XmlQueryRuntime(XmlQueryStaticData data, object defaultDataSource, XmlResolver dataSources, XsltArgumentList argList, XmlSequenceWriter seqWrt)
		{
			string[] names = data.Names;
			Int32Pair[] array = data.Filters;
			WhitespaceRuleLookup wsRules = ((data.WhitespaceRules != null && data.WhitespaceRules.Count != 0) ? new WhitespaceRuleLookup(data.WhitespaceRules) : null);
			ctxt = new XmlQueryContext(this, defaultDataSource, dataSources, argList, wsRules);
			xsltLib = null;
			earlyInfo = data.EarlyBound;
			earlyObjects = ((earlyInfo != null) ? new object[earlyInfo.Length] : null);
			globalNames = data.GlobalNames;
			globalValues = ((globalNames != null) ? new object[globalNames.Length] : null);
			nameTableQuery = ctxt.QueryNameTable;
			atomizedNames = null;
			if (names != null)
			{
				XmlNameTable defaultNameTable = ctxt.DefaultNameTable;
				atomizedNames = new string[names.Length];
				if (defaultNameTable != nameTableQuery && defaultNameTable != null)
				{
					for (int i = 0; i < names.Length; i++)
					{
						string text = defaultNameTable.Get(names[i]);
						atomizedNames[i] = nameTableQuery.Add(text ?? names[i]);
					}
				}
				else
				{
					for (int i = 0; i < names.Length; i++)
					{
						atomizedNames[i] = nameTableQuery.Add(names[i]);
					}
				}
			}
			filters = null;
			if (array != null)
			{
				filters = new XmlNavigatorFilter[array.Length];
				for (int i = 0; i < array.Length; i++)
				{
					filters[i] = XmlNavNameFilter.Create(atomizedNames[array[i].Left], atomizedNames[array[i].Right]);
				}
			}
			prefixMappingsList = data.PrefixMappingsList;
			types = data.Types;
			collations = data.Collations;
			docOrderCmp = new DocumentOrderComparer();
			indexes = null;
			stkOutput = new Stack<XmlQueryOutput>(16);
			output = new XmlQueryOutput(this, seqWrt);
		}

		public string[] DebugGetGlobalNames()
		{
			return globalNames;
		}

		public IList DebugGetGlobalValue(string name)
		{
			for (int i = 0; i < globalNames.Length; i++)
			{
				if (globalNames[i] == name)
				{
					return (IList)globalValues[i];
				}
			}
			return null;
		}

		public void DebugSetGlobalValue(string name, object value)
		{
			for (int i = 0; i < globalNames.Length; i++)
			{
				if (globalNames[i] == name)
				{
					globalValues[i] = (IList<XPathItem>)XmlAnyListConverter.ItemList.ChangeType(value, typeof(XPathItem[]), null);
					break;
				}
			}
		}

		public object DebugGetXsltValue(IList seq)
		{
			if (seq != null && seq.Count == 1)
			{
				XPathItem xPathItem = seq[0] as XPathItem;
				if (xPathItem != null && !xPathItem.IsNode)
				{
					return xPathItem.TypedValue;
				}
				if (xPathItem is RtfNavigator)
				{
					return ((RtfNavigator)xPathItem).ToNavigator();
				}
			}
			return seq;
		}

		public object GetEarlyBoundObject(int index)
		{
			object obj = earlyObjects[index];
			if (obj == null)
			{
				obj = earlyInfo[index].CreateObject();
				earlyObjects[index] = obj;
			}
			return obj;
		}

		public bool EarlyBoundFunctionExists(string name, string namespaceUri)
		{
			if (earlyInfo == null)
			{
				return false;
			}
			for (int i = 0; i < earlyInfo.Length; i++)
			{
				if (namespaceUri == earlyInfo[i].NamespaceUri)
				{
					return new XmlExtensionFunction(name, namespaceUri, -1, earlyInfo[i].EarlyBoundType, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public).CanBind();
				}
			}
			return false;
		}

		public bool IsGlobalComputed(int index)
		{
			return globalValues[index] != null;
		}

		public object GetGlobalValue(int index)
		{
			return globalValues[index];
		}

		public void SetGlobalValue(int index, object value)
		{
			globalValues[index] = value;
		}

		public string GetAtomizedName(int index)
		{
			return atomizedNames[index];
		}

		public XmlNavigatorFilter GetNameFilter(int index)
		{
			return filters[index];
		}

		public XmlNavigatorFilter GetTypeFilter(XPathNodeType nodeType)
		{
			return nodeType switch
			{
				XPathNodeType.All => XmlNavNeverFilter.Create(), 
				XPathNodeType.Attribute => XmlNavAttrFilter.Create(), 
				_ => XmlNavTypeFilter.Create(nodeType), 
			};
		}

		public XmlQualifiedName ParseTagName(string tagName, int indexPrefixMappings)
		{
			ParseTagName(tagName, indexPrefixMappings, out var _, out var localName, out var ns);
			return new XmlQualifiedName(localName, ns);
		}

		public XmlQualifiedName ParseTagName(string tagName, string ns)
		{
			ValidateNames.ParseQNameThrow(tagName, out var _, out var localName);
			return new XmlQualifiedName(localName, ns);
		}

		internal void ParseTagName(string tagName, int idxPrefixMappings, out string prefix, out string localName, out string ns)
		{
			ValidateNames.ParseQNameThrow(tagName, out prefix, out localName);
			ns = null;
			StringPair[] array = prefixMappingsList[idxPrefixMappings];
			for (int i = 0; i < array.Length; i++)
			{
				StringPair stringPair = array[i];
				if (prefix == stringPair.Left)
				{
					ns = stringPair.Right;
					break;
				}
			}
			if (ns != null)
			{
				return;
			}
			if (prefix.Length == 0)
			{
				ns = "";
				return;
			}
			if (prefix.Equals("xml"))
			{
				ns = "http://www.w3.org/XML/1998/namespace";
				return;
			}
			if (prefix.Equals("xmlns"))
			{
				ns = "http://www.w3.org/2000/xmlns/";
				return;
			}
			throw new XslTransformException("Xslt_InvalidPrefix", prefix);
		}

		public bool IsQNameEqual(XPathNavigator n1, XPathNavigator n2)
		{
			if (n1.NameTable == n2.NameTable)
			{
				if ((object)n1.LocalName == n2.LocalName)
				{
					return (object)n1.NamespaceURI == n2.NamespaceURI;
				}
				return false;
			}
			if (n1.LocalName == n2.LocalName)
			{
				return n1.NamespaceURI == n2.NamespaceURI;
			}
			return false;
		}

		public bool IsQNameEqual(XPathNavigator navigator, int indexLocalName, int indexNamespaceUri)
		{
			if (navigator.NameTable == nameTableQuery)
			{
				if ((object)GetAtomizedName(indexLocalName) == navigator.LocalName)
				{
					return (object)GetAtomizedName(indexNamespaceUri) == navigator.NamespaceURI;
				}
				return false;
			}
			if (GetAtomizedName(indexLocalName) == navigator.LocalName)
			{
				return GetAtomizedName(indexNamespaceUri) == navigator.NamespaceURI;
			}
			return false;
		}

		internal XmlQueryType GetXmlType(int idxType)
		{
			return types[idxType];
		}

		public object ChangeTypeXsltArgument(int indexType, object value, Type destinationType)
		{
			return ChangeTypeXsltArgument(GetXmlType(indexType), value, destinationType);
		}

		internal object ChangeTypeXsltArgument(XmlQueryType xmlType, object value, Type destinationType)
		{
			switch (xmlType.TypeCode)
			{
			case XmlTypeCode.String:
				if (destinationType == XsltConvert.DateTimeType)
				{
					value = XsltConvert.ToDateTime((string)value);
				}
				break;
			case XmlTypeCode.Double:
				if (destinationType != XsltConvert.DoubleType)
				{
					value = Convert.ChangeType(value, destinationType, CultureInfo.InvariantCulture);
				}
				break;
			case XmlTypeCode.Node:
				if (destinationType == XsltConvert.XPathNodeIteratorType)
				{
					value = new XPathArrayIterator((IList)value);
				}
				else if (destinationType == XsltConvert.XPathNavigatorArrayType)
				{
					IList<XPathNavigator> list2 = (IList<XPathNavigator>)value;
					XPathNavigator[] array = new XPathNavigator[list2.Count];
					for (int i = 0; i < list2.Count; i++)
					{
						array[i] = list2[i];
					}
					value = array;
				}
				break;
			case XmlTypeCode.Item:
			{
				if (destinationType != XsltConvert.ObjectType)
				{
					throw new XslTransformException("Xslt_UnsupportedClrType", destinationType.Name);
				}
				IList<XPathItem> list = (IList<XPathItem>)value;
				if (list.Count == 1)
				{
					XPathItem xPathItem = list[0];
					value = ((!xPathItem.IsNode) ? xPathItem.TypedValue : ((!(xPathItem is RtfNavigator rtfNavigator)) ? ((ICloneable)new XPathArrayIterator((IList)value)) : ((ICloneable)rtfNavigator.ToNavigator())));
				}
				else
				{
					value = new XPathArrayIterator((IList)value);
				}
				break;
			}
			}
			return value;
		}

		public object ChangeTypeXsltResult(int indexType, object value)
		{
			return ChangeTypeXsltResult(GetXmlType(indexType), value);
		}

		internal object ChangeTypeXsltResult(XmlQueryType xmlType, object value)
		{
			if (value == null)
			{
				throw new XslTransformException("Xslt_ItemNull", string.Empty);
			}
			switch (xmlType.TypeCode)
			{
			case XmlTypeCode.String:
				if (value.GetType() == XsltConvert.DateTimeType)
				{
					value = XsltConvert.ToString((DateTime)value);
				}
				break;
			case XmlTypeCode.Double:
				if (value.GetType() != XsltConvert.DoubleType)
				{
					value = ((IConvertible)value).ToDouble(null);
				}
				break;
			case XmlTypeCode.Node:
				if (xmlType.IsSingleton)
				{
					break;
				}
				if (value is XPathArrayIterator xPathArrayIterator && xPathArrayIterator.AsList is XmlQueryNodeSequence)
				{
					value = xPathArrayIterator.AsList as XmlQueryNodeSequence;
				}
				else
				{
					XmlQueryNodeSequence xmlQueryNodeSequence = new XmlQueryNodeSequence();
					if (value is IList list)
					{
						for (int i = 0; i < list.Count; i++)
						{
							xmlQueryNodeSequence.Add(EnsureNavigator(list[i]));
						}
					}
					else
					{
						foreach (object item in (IEnumerable)value)
						{
							xmlQueryNodeSequence.Add(EnsureNavigator(item));
						}
					}
					value = xmlQueryNodeSequence;
				}
				value = ((XmlQueryNodeSequence)value).DocOrderDistinct(docOrderCmp);
				break;
			case XmlTypeCode.Item:
			{
				Type type = value.GetType();
				switch (XsltConvert.InferXsltType(type).TypeCode)
				{
				case XmlTypeCode.Boolean:
					value = new XmlQueryItemSequence(new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean), value));
					break;
				case XmlTypeCode.Double:
					value = new XmlQueryItemSequence(new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Double), ((IConvertible)value).ToDouble(null)));
					break;
				case XmlTypeCode.String:
					value = ((type != XsltConvert.DateTimeType) ? new XmlQueryItemSequence(new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), value)) : new XmlQueryItemSequence(new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), XsltConvert.ToString((DateTime)value))));
					break;
				case XmlTypeCode.Node:
					value = ChangeTypeXsltResult(XmlQueryTypeFactory.NodeS, value);
					break;
				case XmlTypeCode.Item:
					if (value is XPathNodeIterator)
					{
						value = ChangeTypeXsltResult(XmlQueryTypeFactory.NodeS, value);
						break;
					}
					if (!(value is IXPathNavigable iXPathNavigable))
					{
						throw new XslTransformException("Xslt_UnsupportedClrType", type.Name);
					}
					value = ((!(value is XPathNavigator)) ? new XmlQueryNodeSequence(iXPathNavigable.CreateNavigator()) : new XmlQueryNodeSequence((XPathNavigator)value));
					break;
				}
				break;
			}
			}
			return value;
		}

		private static XPathNavigator EnsureNavigator(object value)
		{
			if (!(value is XPathNavigator result))
			{
				throw new XslTransformException("Xslt_ItemNull", string.Empty);
			}
			return result;
		}

		public bool MatchesXmlType(IList<XPathItem> seq, int indexType)
		{
			XmlQueryType xmlType = GetXmlType(indexType);
			if (!(seq.Count switch
			{
				0 => XmlQueryCardinality.Zero, 
				1 => XmlQueryCardinality.One, 
				_ => XmlQueryCardinality.More, 
			} <= xmlType.Cardinality))
			{
				return false;
			}
			xmlType = xmlType.Prime;
			for (int i = 0; i < seq.Count; i++)
			{
				if (!CreateXmlType(seq[0]).IsSubtypeOf(xmlType))
				{
					return false;
				}
			}
			return true;
		}

		public bool MatchesXmlType(XPathItem item, int indexType)
		{
			return CreateXmlType(item).IsSubtypeOf(GetXmlType(indexType));
		}

		public bool MatchesXmlType(IList<XPathItem> seq, XmlTypeCode code)
		{
			if (seq.Count != 1)
			{
				return false;
			}
			return MatchesXmlType(seq[0], code);
		}

		public bool MatchesXmlType(XPathItem item, XmlTypeCode code)
		{
			if (code > XmlTypeCode.AnyAtomicType)
			{
				if (!item.IsNode)
				{
					return item.XmlType.TypeCode == code;
				}
				return false;
			}
			switch (code)
			{
			case XmlTypeCode.AnyAtomicType:
				return !item.IsNode;
			case XmlTypeCode.Node:
				return item.IsNode;
			case XmlTypeCode.Item:
				return true;
			default:
				if (!item.IsNode)
				{
					return false;
				}
				return ((XPathNavigator)item).NodeType switch
				{
					XPathNodeType.Root => code == XmlTypeCode.Document, 
					XPathNodeType.Element => code == XmlTypeCode.Element, 
					XPathNodeType.Attribute => code == XmlTypeCode.Attribute, 
					XPathNodeType.Namespace => code == XmlTypeCode.Namespace, 
					XPathNodeType.Text => code == XmlTypeCode.Text, 
					XPathNodeType.SignificantWhitespace => code == XmlTypeCode.Text, 
					XPathNodeType.Whitespace => code == XmlTypeCode.Text, 
					XPathNodeType.ProcessingInstruction => code == XmlTypeCode.ProcessingInstruction, 
					XPathNodeType.Comment => code == XmlTypeCode.Comment, 
					_ => false, 
				};
			}
		}

		private XmlQueryType CreateXmlType(XPathItem item)
		{
			if (item.IsNode)
			{
				if (item is RtfNavigator)
				{
					return XmlQueryTypeFactory.Node;
				}
				XPathNavigator xPathNavigator = (XPathNavigator)item;
				switch (xPathNavigator.NodeType)
				{
				case XPathNodeType.Root:
				case XPathNodeType.Element:
					if (xPathNavigator.XmlType == null)
					{
						return XmlQueryTypeFactory.Type(xPathNavigator.NodeType, XmlQualifiedNameTest.New(xPathNavigator.LocalName, xPathNavigator.NamespaceURI), XmlSchemaComplexType.UntypedAnyType, isNillable: false);
					}
					return XmlQueryTypeFactory.Type(xPathNavigator.NodeType, XmlQualifiedNameTest.New(xPathNavigator.LocalName, xPathNavigator.NamespaceURI), xPathNavigator.XmlType, xPathNavigator.SchemaInfo.SchemaElement.IsNillable);
				case XPathNodeType.Attribute:
					if (xPathNavigator.XmlType == null)
					{
						return XmlQueryTypeFactory.Type(xPathNavigator.NodeType, XmlQualifiedNameTest.New(xPathNavigator.LocalName, xPathNavigator.NamespaceURI), DatatypeImplementation.UntypedAtomicType, isNillable: false);
					}
					return XmlQueryTypeFactory.Type(xPathNavigator.NodeType, XmlQualifiedNameTest.New(xPathNavigator.LocalName, xPathNavigator.NamespaceURI), xPathNavigator.XmlType, isNillable: false);
				default:
					return XmlQueryTypeFactory.Type(xPathNavigator.NodeType, XmlQualifiedNameTest.Wildcard, XmlSchemaComplexType.AnyType, isNillable: false);
				}
			}
			return XmlQueryTypeFactory.Type((XmlSchemaSimpleType)item.XmlType, isStrict: true);
		}

		public XmlCollation GetCollation(int index)
		{
			return collations[index];
		}

		public XmlCollation CreateCollation(string collation)
		{
			return XmlCollation.Create(collation);
		}

		public int ComparePosition(XPathNavigator navigatorThis, XPathNavigator navigatorThat)
		{
			return docOrderCmp.Compare(navigatorThis, navigatorThat);
		}

		public IList<XPathNavigator> DocOrderDistinct(IList<XPathNavigator> seq)
		{
			if (seq.Count <= 1)
			{
				return seq;
			}
			XmlQueryNodeSequence xmlQueryNodeSequence = (XmlQueryNodeSequence)seq;
			if (xmlQueryNodeSequence == null)
			{
				xmlQueryNodeSequence = new XmlQueryNodeSequence(seq);
			}
			return xmlQueryNodeSequence.DocOrderDistinct(docOrderCmp);
		}

		public string GenerateId(XPathNavigator navigator)
		{
			return "ID" + docOrderCmp.GetDocumentIndex(navigator).ToString(CultureInfo.InvariantCulture) + navigator.UniqueId;
		}

		public bool FindIndex(XPathNavigator context, int indexId, out XmlILIndex index)
		{
			XPathNavigator xPathNavigator = context.Clone();
			xPathNavigator.MoveToRoot();
			if (indexes != null && indexId < indexes.Length)
			{
				ArrayList arrayList = indexes[indexId];
				if (arrayList != null)
				{
					for (int i = 0; i < arrayList.Count; i += 2)
					{
						if (((XPathNavigator)arrayList[i]).IsSamePosition(xPathNavigator))
						{
							index = (XmlILIndex)arrayList[i + 1];
							return true;
						}
					}
				}
			}
			index = new XmlILIndex();
			return false;
		}

		public void AddNewIndex(XPathNavigator context, int indexId, XmlILIndex index)
		{
			XPathNavigator xPathNavigator = context.Clone();
			xPathNavigator.MoveToRoot();
			if (indexes == null)
			{
				indexes = new ArrayList[indexId + 4];
			}
			else if (indexId >= indexes.Length)
			{
				ArrayList[] destinationArray = new ArrayList[indexId + 4];
				Array.Copy(indexes, 0, destinationArray, 0, indexes.Length);
				indexes = destinationArray;
			}
			ArrayList arrayList = indexes[indexId];
			if (arrayList == null)
			{
				arrayList = new ArrayList();
				indexes[indexId] = arrayList;
			}
			arrayList.Add(xPathNavigator);
			arrayList.Add(index);
		}

		public void StartSequenceConstruction(out XmlQueryOutput output)
		{
			stkOutput.Push(this.output);
			output = (this.output = new XmlQueryOutput(this, new XmlCachedSequenceWriter()));
		}

		public IList<XPathItem> EndSequenceConstruction(out XmlQueryOutput output)
		{
			IList<XPathItem> resultSequence = ((XmlCachedSequenceWriter)this.output.SequenceWriter).ResultSequence;
			output = (this.output = stkOutput.Pop());
			return resultSequence;
		}

		public void StartRtfConstruction(string baseUri, out XmlQueryOutput output)
		{
			stkOutput.Push(this.output);
			output = (this.output = new XmlQueryOutput(this, new XmlEventCache(baseUri, hasRootNode: true)));
		}

		public XPathNavigator EndRtfConstruction(out XmlQueryOutput output)
		{
			XmlEventCache xmlEventCache = (XmlEventCache)this.output.Writer;
			output = (this.output = stkOutput.Pop());
			xmlEventCache.EndEvents();
			return new RtfTreeNavigator(xmlEventCache, nameTableQuery);
		}

		public XPathNavigator TextRtfConstruction(string text, string baseUri)
		{
			return new RtfTextNavigator(text, baseUri);
		}

		public void SendMessage(string message)
		{
			ctxt.OnXsltMessageEncountered(message);
		}

		public void ThrowException(string text)
		{
			throw new XslTransformException(text);
		}

		internal static XPathNavigator SyncToNavigator(XPathNavigator navigatorThis, XPathNavigator navigatorThat)
		{
			if (navigatorThis == null || !navigatorThis.MoveTo(navigatorThat))
			{
				return navigatorThat.Clone();
			}
			return navigatorThis;
		}

		public static int OnCurrentNodeChanged(XPathNavigator currentNode)
		{
			if (currentNode is IXmlLineInfo xmlLineInfo && (currentNode.NodeType != XPathNodeType.Namespace || !IsInheritedNamespace(currentNode)))
			{
				OnCurrentNodeChanged2(currentNode.BaseURI, xmlLineInfo.LineNumber, xmlLineInfo.LinePosition);
			}
			return 0;
		}

		private static bool IsInheritedNamespace(XPathNavigator node)
		{
			XPathNavigator xPathNavigator = node.Clone();
			if (xPathNavigator.MoveToParent() && xPathNavigator.MoveToFirstNamespace(XPathNamespaceScope.Local))
			{
				do
				{
					if ((object)xPathNavigator.LocalName == node.LocalName)
					{
						return false;
					}
				}
				while (xPathNavigator.MoveToNextNamespace(XPathNamespaceScope.Local));
			}
			return true;
		}

		private static void OnCurrentNodeChanged2(string baseUri, int lineNumber, int linePosition)
		{
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public class XmlQuerySequence<T> : IList<T>, ICollection<T>, IEnumerable<T>, IList, ICollection, IEnumerable
	{
		private const int DefaultCacheSize = 16;

		public static readonly XmlQuerySequence<T> Empty = new XmlQuerySequence<T>();

		private static readonly Type XPathItemType = typeof(XPathItem);

		private T[] items;

		private int size;

		public int Count => size;

		bool ICollection.IsSynchronized => false;

		object ICollection.SyncRoot => this;

		bool ICollection<T>.IsReadOnly => true;

		bool IList.IsFixedSize => true;

		bool IList.IsReadOnly => true;

		object IList.this[int index]
		{
			get
			{
				if (index >= size)
				{
					throw new ArgumentOutOfRangeException();
				}
				return items[index];
			}
			set
			{
				throw new NotSupportedException();
			}
		}

		public T this[int index]
		{
			get
			{
				if (index >= size)
				{
					throw new ArgumentOutOfRangeException();
				}
				return items[index];
			}
			set
			{
				throw new NotSupportedException();
			}
		}

		public static XmlQuerySequence<T> CreateOrReuse(XmlQuerySequence<T> seq)
		{
			if (seq != null)
			{
				seq.Clear();
				return seq;
			}
			return new XmlQuerySequence<T>();
		}

		public static XmlQuerySequence<T> CreateOrReuse(XmlQuerySequence<T> seq, T item)
		{
			if (seq != null)
			{
				seq.Clear();
				seq.Add(item);
				return seq;
			}
			return new XmlQuerySequence<T>(item);
		}

		public XmlQuerySequence()
		{
			items = new T[16];
		}

		public XmlQuerySequence(int capacity)
		{
			items = new T[capacity];
		}

		public XmlQuerySequence(T[] array, int size)
		{
			items = array;
			this.size = size;
		}

		public XmlQuerySequence(T value)
		{
			items = new T[1];
			items[0] = value;
			size = 1;
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return new IListEnumerator<T>(this);
		}

		public IEnumerator<T> GetEnumerator()
		{
			return new IListEnumerator<T>(this);
		}

		void ICollection.CopyTo(Array array, int index)
		{
			if (size != 0)
			{
				Array.Copy(items, 0, array, index, size);
			}
		}

		void ICollection<T>.Add(T value)
		{
			throw new NotSupportedException();
		}

		void ICollection<T>.Clear()
		{
			throw new NotSupportedException();
		}

		public bool Contains(T value)
		{
			return IndexOf(value) != -1;
		}

		public void CopyTo(T[] array, int index)
		{
			for (int i = 0; i < Count; i++)
			{
				array[index + i] = this[i];
			}
		}

		bool ICollection<T>.Remove(T value)
		{
			throw new NotSupportedException();
		}

		int IList.Add(object value)
		{
			throw new NotSupportedException();
		}

		void IList.Clear()
		{
			throw new NotSupportedException();
		}

		bool IList.Contains(object value)
		{
			return Contains((T)value);
		}

		int IList.IndexOf(object value)
		{
			return IndexOf((T)value);
		}

		void IList.Insert(int index, object value)
		{
			throw new NotSupportedException();
		}

		void IList.Remove(object value)
		{
			throw new NotSupportedException();
		}

		void IList.RemoveAt(int index)
		{
			throw new NotSupportedException();
		}

		public int IndexOf(T value)
		{
			int num = Array.IndexOf(items, value);
			if (num >= size)
			{
				return -1;
			}
			return num;
		}

		void IList<T>.Insert(int index, T value)
		{
			throw new NotSupportedException();
		}

		void IList<T>.RemoveAt(int index)
		{
			throw new NotSupportedException();
		}

		public void Clear()
		{
			size = 0;
			OnItemsChanged();
		}

		public void Add(T value)
		{
			EnsureCache();
			items[size++] = value;
			OnItemsChanged();
		}

		public void SortByKeys(Array keys)
		{
			if (size > 1)
			{
				Array.Sort(keys, items, 0, size);
				OnItemsChanged();
			}
		}

		private void EnsureCache()
		{
			if (size >= items.Length)
			{
				T[] array = new T[size * 2];
				CopyTo(array, 0);
				items = array;
			}
		}

		protected virtual void OnItemsChanged()
		{
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public sealed class XmlQueryItemSequence : XmlQuerySequence<XPathItem>
	{
		public new static readonly XmlQueryItemSequence Empty = new XmlQueryItemSequence();

		public static XmlQueryItemSequence CreateOrReuse(XmlQueryItemSequence seq)
		{
			if (seq != null)
			{
				seq.Clear();
				return seq;
			}
			return new XmlQueryItemSequence();
		}

		public static XmlQueryItemSequence CreateOrReuse(XmlQueryItemSequence seq, XPathItem item)
		{
			if (seq != null)
			{
				seq.Clear();
				seq.Add(item);
				return seq;
			}
			return new XmlQueryItemSequence(item);
		}

		public XmlQueryItemSequence()
		{
		}

		public XmlQueryItemSequence(int capacity)
			: base(capacity)
		{
		}

		public XmlQueryItemSequence(XPathItem item)
			: base(1)
		{
			AddClone(item);
		}

		public void AddClone(XPathItem item)
		{
			if (item.IsNode)
			{
				Add(((XPathNavigator)item).Clone());
			}
			else
			{
				Add(item);
			}
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public sealed class XmlQueryNodeSequence : XmlQuerySequence<XPathNavigator>, IList<XPathItem>, ICollection<XPathItem>, IEnumerable<XPathItem>, IEnumerable
	{
		public new static readonly XmlQueryNodeSequence Empty = new XmlQueryNodeSequence();

		private XmlQueryNodeSequence docOrderDistinct;

		public bool IsDocOrderDistinct
		{
			get
			{
				if (docOrderDistinct != this)
				{
					return base.Count <= 1;
				}
				return true;
			}
			set
			{
				docOrderDistinct = (value ? this : null);
			}
		}

		bool ICollection<XPathItem>.IsReadOnly => true;

		XPathItem IList<XPathItem>.this[int index]
		{
			get
			{
				if (index >= base.Count)
				{
					throw new ArgumentOutOfRangeException();
				}
				return base[index];
			}
			set
			{
				throw new NotSupportedException();
			}
		}

		public static XmlQueryNodeSequence CreateOrReuse(XmlQueryNodeSequence seq)
		{
			if (seq != null)
			{
				seq.Clear();
				return seq;
			}
			return new XmlQueryNodeSequence();
		}

		public static XmlQueryNodeSequence CreateOrReuse(XmlQueryNodeSequence seq, XPathNavigator navigator)
		{
			if (seq != null)
			{
				seq.Clear();
				seq.Add(navigator);
				return seq;
			}
			return new XmlQueryNodeSequence(navigator);
		}

		public XmlQueryNodeSequence()
		{
		}

		public XmlQueryNodeSequence(int capacity)
			: base(capacity)
		{
		}

		public XmlQueryNodeSequence(IList<XPathNavigator> list)
			: base(list.Count)
		{
			for (int i = 0; i < list.Count; i++)
			{
				AddClone(list[i]);
			}
		}

		public XmlQueryNodeSequence(XPathNavigator[] array, int size)
			: base(array, size)
		{
		}

		public XmlQueryNodeSequence(XPathNavigator navigator)
			: base(1)
		{
			AddClone(navigator);
		}

		public XmlQueryNodeSequence DocOrderDistinct(IComparer<XPathNavigator> comparer)
		{
			if (docOrderDistinct != null)
			{
				return docOrderDistinct;
			}
			if (base.Count <= 1)
			{
				return this;
			}
			XPathNavigator[] array = new XPathNavigator[base.Count];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = base[i];
			}
			Array.Sort(array, 0, base.Count, comparer);
			int num = 0;
			for (int i = 1; i < array.Length; i++)
			{
				if (!array[num].IsSamePosition(array[i]))
				{
					num++;
					if (num != i)
					{
						array[num] = array[i];
					}
				}
			}
			docOrderDistinct = new XmlQueryNodeSequence(array, num + 1);
			docOrderDistinct.docOrderDistinct = docOrderDistinct;
			return docOrderDistinct;
		}

		public void AddClone(XPathNavigator navigator)
		{
			Add(navigator.Clone());
		}

		protected override void OnItemsChanged()
		{
			docOrderDistinct = null;
		}

		IEnumerator<XPathItem> IEnumerable<XPathItem>.GetEnumerator()
		{
			return new IListEnumerator<XPathItem>(this);
		}

		void ICollection<XPathItem>.Add(XPathItem value)
		{
			throw new NotSupportedException();
		}

		void ICollection<XPathItem>.Clear()
		{
			throw new NotSupportedException();
		}

		bool ICollection<XPathItem>.Contains(XPathItem value)
		{
			return IndexOf((XPathNavigator)value) != -1;
		}

		void ICollection<XPathItem>.CopyTo(XPathItem[] array, int index)
		{
			for (int i = 0; i < base.Count; i++)
			{
				array[index + i] = base[i];
			}
		}

		bool ICollection<XPathItem>.Remove(XPathItem value)
		{
			throw new NotSupportedException();
		}

		int IList<XPathItem>.IndexOf(XPathItem value)
		{
			return IndexOf((XPathNavigator)value);
		}

		void IList<XPathItem>.Insert(int index, XPathItem value)
		{
			throw new NotSupportedException();
		}

		void IList<XPathItem>.RemoveAt(int index)
		{
			throw new NotSupportedException();
		}
	}
	internal class XmlQueryStaticData
	{
		public const string DataFieldName = "staticData";

		public const string TypesFieldName = "ebTypes";

		private const int CurrentFormatVersion = 0;

		private XmlWriterSettings defaultWriterSettings;

		private IList<WhitespaceRule> whitespaceRules;

		private string[] names;

		private StringPair[][] prefixMappingsList;

		private Int32Pair[] filters;

		private XmlQueryType[] types;

		private XmlCollation[] collations;

		private string[] globalNames;

		private EarlyBoundInfo[] earlyBound;

		public XmlWriterSettings DefaultWriterSettings => defaultWriterSettings;

		public IList<WhitespaceRule> WhitespaceRules => whitespaceRules;

		public string[] Names => names;

		public StringPair[][] PrefixMappingsList => prefixMappingsList;

		public Int32Pair[] Filters => filters;

		public XmlQueryType[] Types => types;

		public XmlCollation[] Collations => collations;

		public string[] GlobalNames => globalNames;

		public EarlyBoundInfo[] EarlyBound => earlyBound;

		public XmlQueryStaticData(XmlWriterSettings defaultWriterSettings, IList<WhitespaceRule> whitespaceRules, StaticDataManager staticData)
		{
			this.defaultWriterSettings = defaultWriterSettings;
			this.whitespaceRules = whitespaceRules;
			names = staticData.Names;
			prefixMappingsList = staticData.PrefixMappingsList;
			filters = staticData.NameFilters;
			types = staticData.XmlTypes;
			collations = staticData.Collations;
			globalNames = staticData.GlobalNames;
			earlyBound = staticData.EarlyBound;
		}

		public XmlQueryStaticData(byte[] data, Type[] ebTypes)
		{
			MemoryStream input = new MemoryStream(data, writable: false);
			XmlQueryDataReader xmlQueryDataReader = new XmlQueryDataReader(input);
			int num = xmlQueryDataReader.ReadInt32Encoded();
			if ((num & -256) > 0)
			{
				throw new NotSupportedException();
			}
			defaultWriterSettings = new XmlWriterSettings(xmlQueryDataReader);
			int num2 = xmlQueryDataReader.ReadInt32();
			if (num2 != 0)
			{
				whitespaceRules = new WhitespaceRule[num2];
				for (int i = 0; i < num2; i++)
				{
					whitespaceRules[i] = new WhitespaceRule(xmlQueryDataReader);
				}
			}
			num2 = xmlQueryDataReader.ReadInt32();
			if (num2 != 0)
			{
				names = new string[num2];
				for (int j = 0; j < num2; j++)
				{
					names[j] = xmlQueryDataReader.ReadString();
				}
			}
			num2 = xmlQueryDataReader.ReadInt32();
			if (num2 != 0)
			{
				prefixMappingsList = new StringPair[num2][];
				for (int k = 0; k < num2; k++)
				{
					int num3 = xmlQueryDataReader.ReadInt32();
					prefixMappingsList[k] = new StringPair[num3];
					for (int l = 0; l < num3; l++)
					{
						ref StringPair reference = ref prefixMappingsList[k][l];
						reference = new StringPair(xmlQueryDataReader.ReadString(), xmlQueryDataReader.ReadString());
					}
				}
			}
			num2 = xmlQueryDataReader.ReadInt32();
			if (num2 != 0)
			{
				filters = new Int32Pair[num2];
				for (int m = 0; m < num2; m++)
				{
					ref Int32Pair reference2 = ref filters[m];
					reference2 = new Int32Pair(xmlQueryDataReader.ReadInt32Encoded(), xmlQueryDataReader.ReadInt32Encoded());
				}
			}
			num2 = xmlQueryDataReader.ReadInt32();
			if (num2 != 0)
			{
				types = new XmlQueryType[num2];
				for (int n = 0; n < num2; n++)
				{
					types[n] = XmlQueryTypeFactory.Deserialize(xmlQueryDataReader);
				}
			}
			num2 = xmlQueryDataReader.ReadInt32();
			if (num2 != 0)
			{
				collations = new XmlCollation[num2];
				for (int num4 = 0; num4 < num2; num4++)
				{
					collations[num4] = new XmlCollation(xmlQueryDataReader);
				}
			}
			num2 = xmlQueryDataReader.ReadInt32();
			if (num2 != 0)
			{
				globalNames = new string[num2];
				for (int num5 = 0; num5 < num2; num5++)
				{
					globalNames[num5] = xmlQueryDataReader.ReadString();
				}
			}
			num2 = xmlQueryDataReader.ReadInt32();
			if (num2 != 0)
			{
				earlyBound = new EarlyBoundInfo[num2];
				for (int num6 = 0; num6 < num2; num6++)
				{
					earlyBound[num6] = new EarlyBoundInfo(xmlQueryDataReader.ReadString(), ebTypes[num6]);
				}
			}
			xmlQueryDataReader.Close();
		}

		public void GetObjectData(out byte[] data, out Type[] ebTypes)
		{
			MemoryStream memoryStream = new MemoryStream(4096);
			XmlQueryDataWriter xmlQueryDataWriter = new XmlQueryDataWriter(memoryStream);
			xmlQueryDataWriter.WriteInt32Encoded(0);
			defaultWriterSettings.GetObjectData(xmlQueryDataWriter);
			if (whitespaceRules == null)
			{
				xmlQueryDataWriter.Write(0);
			}
			else
			{
				xmlQueryDataWriter.Write(whitespaceRules.Count);
				foreach (WhitespaceRule whitespaceRule in whitespaceRules)
				{
					whitespaceRule.GetObjectData(xmlQueryDataWriter);
				}
			}
			if (names == null)
			{
				xmlQueryDataWriter.Write(0);
			}
			else
			{
				xmlQueryDataWriter.Write(names.Length);
				string[] array = names;
				foreach (string value in array)
				{
					xmlQueryDataWriter.Write(value);
				}
			}
			if (prefixMappingsList == null)
			{
				xmlQueryDataWriter.Write(0);
			}
			else
			{
				xmlQueryDataWriter.Write(prefixMappingsList.Length);
				StringPair[][] array2 = prefixMappingsList;
				foreach (StringPair[] array3 in array2)
				{
					xmlQueryDataWriter.Write(array3.Length);
					StringPair[] array4 = array3;
					for (int k = 0; k < array4.Length; k++)
					{
						StringPair stringPair = array4[k];
						xmlQueryDataWriter.Write(stringPair.Left);
						xmlQueryDataWriter.Write(stringPair.Right);
					}
				}
			}
			if (filters == null)
			{
				xmlQueryDataWriter.Write(0);
			}
			else
			{
				xmlQueryDataWriter.Write(filters.Length);
				Int32Pair[] array5 = filters;
				for (int l = 0; l < array5.Length; l++)
				{
					Int32Pair int32Pair = array5[l];
					xmlQueryDataWriter.WriteInt32Encoded(int32Pair.Left);
					xmlQueryDataWriter.WriteInt32Encoded(int32Pair.Right);
				}
			}
			if (types == null)
			{
				xmlQueryDataWriter.Write(0);
			}
			else
			{
				xmlQueryDataWriter.Write(types.Length);
				XmlQueryType[] array6 = types;
				foreach (XmlQueryType type in array6)
				{
					XmlQueryTypeFactory.Serialize(xmlQueryDataWriter, type);
				}
			}
			if (collations == null)
			{
				xmlQueryDataWriter.Write(0);
			}
			else
			{
				xmlQueryDataWriter.Write(collations.Length);
				XmlCollation[] array7 = collations;
				foreach (XmlCollation xmlCollation in array7)
				{
					xmlCollation.GetObjectData(xmlQueryDataWriter);
				}
			}
			if (globalNames == null)
			{
				xmlQueryDataWriter.Write(0);
			}
			else
			{
				xmlQueryDataWriter.Write(globalNames.Length);
				string[] array8 = globalNames;
				foreach (string value2 in array8)
				{
					xmlQueryDataWriter.Write(value2);
				}
			}
			if (earlyBound == null)
			{
				xmlQueryDataWriter.Write(0);
				ebTypes = null;
			}
			else
			{
				xmlQueryDataWriter.Write(earlyBound.Length);
				ebTypes = new Type[earlyBound.Length];
				int num2 = 0;
				EarlyBoundInfo[] array9 = earlyBound;
				foreach (EarlyBoundInfo earlyBoundInfo in array9)
				{
					xmlQueryDataWriter.Write(earlyBoundInfo.NamespaceUri);
					ebTypes[num2++] = earlyBoundInfo.EarlyBoundType;
				}
			}
			xmlQueryDataWriter.Close();
			data = memoryStream.ToArray();
		}
	}
	internal class XmlQueryDataReader : BinaryReader
	{
		public XmlQueryDataReader(Stream input)
			: base(input)
		{
		}

		public int ReadInt32Encoded()
		{
			return Read7BitEncodedInt();
		}

		public string ReadStringQ()
		{
			if (!ReadBoolean())
			{
				return null;
			}
			return ReadString();
		}

		public sbyte ReadSByte(sbyte minValue, sbyte maxValue)
		{
			sbyte b = ReadSByte();
			if (b < minValue || maxValue < b)
			{
				throw new ArgumentOutOfRangeException();
			}
			return b;
		}
	}
	internal class XmlQueryDataWriter : BinaryWriter
	{
		public XmlQueryDataWriter(Stream output)
			: base(output)
		{
		}

		public void WriteInt32Encoded(int value)
		{
			Write7BitEncodedInt(value);
		}

		public void WriteStringQ(string value)
		{
			Write(value != null);
			if (value != null)
			{
				Write(value);
			}
		}
	}
	internal sealed class XmlRawWriterWrapper : XmlRawWriter
	{
		private XmlWriter wrapped;

		public override XmlWriterSettings Settings => wrapped.Settings;

		public XmlRawWriterWrapper(XmlWriter writer)
		{
			wrapped = writer;
		}

		public override void WriteDocType(string name, string pubid, string sysid, string subset)
		{
			wrapped.WriteDocType(name, pubid, sysid, subset);
		}

		public override void WriteStartElement(string prefix, string localName, string ns)
		{
			wrapped.WriteStartElement(prefix, localName, ns);
		}

		public override void WriteStartAttribute(string prefix, string localName, string ns)
		{
			wrapped.WriteStartAttribute(prefix, localName, ns);
		}

		public override void WriteEndAttribute()
		{
			wrapped.WriteEndAttribute();
		}

		public override void WriteCData(string text)
		{
			wrapped.WriteCData(text);
		}

		public override void WriteComment(string text)
		{
			wrapped.WriteComment(text);
		}

		public override void WriteProcessingInstruction(string name, string text)
		{
			wrapped.WriteProcessingInstruction(name, text);
		}

		public override void WriteWhitespace(string ws)
		{
			wrapped.WriteWhitespace(ws);
		}

		public override void WriteString(string text)
		{
			wrapped.WriteString(text);
		}

		public override void WriteChars(char[] buffer, int index, int count)
		{
			wrapped.WriteChars(buffer, index, count);
		}

		public override void WriteRaw(char[] buffer, int index, int count)
		{
			wrapped.WriteRaw(buffer, index, count);
		}

		public override void WriteRaw(string data)
		{
			wrapped.WriteRaw(data);
		}

		public override void WriteEntityRef(string name)
		{
			wrapped.WriteEntityRef(name);
		}

		public override void WriteCharEntity(char ch)
		{
			wrapped.WriteCharEntity(ch);
		}

		public override void WriteSurrogateCharEntity(char lowChar, char highChar)
		{
			wrapped.WriteSurrogateCharEntity(lowChar, highChar);
		}

		public override void Close()
		{
			wrapped.Close();
		}

		public override void Flush()
		{
			wrapped.Flush();
		}

		public override void WriteValue(object value)
		{
			wrapped.WriteValue(value);
		}

		public override void WriteValue(string value)
		{
			wrapped.WriteValue(value);
		}

		public override void WriteValue(bool value)
		{
			wrapped.WriteValue(value);
		}

		public override void WriteValue(DateTime value)
		{
			wrapped.WriteValue(value);
		}

		public override void WriteValue(float value)
		{
			wrapped.WriteValue(value);
		}

		public override void WriteValue(decimal value)
		{
			wrapped.WriteValue(value);
		}

		public override void WriteValue(double value)
		{
			wrapped.WriteValue(value);
		}

		public override void WriteValue(int value)
		{
			wrapped.WriteValue(value);
		}

		public override void WriteValue(long value)
		{
			wrapped.WriteValue(value);
		}

		protected override void Dispose(bool disposing)
		{
			try
			{
				((IDisposable)wrapped).Dispose();
			}
			finally
			{
				base.Dispose(disposing);
			}
		}

		internal override void WriteXmlDeclaration(XmlStandalone standalone)
		{
		}

		internal override void WriteXmlDeclaration(string xmldecl)
		{
		}

		internal override void StartElementContent()
		{
		}

		internal override void WriteEndElement(string prefix, string localName, string ns)
		{
			wrapped.WriteEndElement();
		}

		internal override void WriteFullEndElement(string prefix, string localName, string ns)
		{
			wrapped.WriteFullEndElement();
		}

		internal override void WriteNamespaceDeclaration(string prefix, string ns)
		{
			if (prefix.Length == 0)
			{
				wrapped.WriteAttributeString(string.Empty, "xmlns", "http://www.w3.org/2000/xmlns/", ns);
			}
			else
			{
				wrapped.WriteAttributeString("xmlns", prefix, "http://www.w3.org/2000/xmlns/", ns);
			}
		}
	}
	internal abstract class XmlSequenceWriter
	{
		public abstract XmlRawWriter StartTree(XPathNodeType rootType, IXmlNamespaceResolver nsResolver, XmlNameTable nameTable);

		public abstract void EndTree();

		public abstract void WriteItem(XPathItem item);
	}
	internal class XmlCachedSequenceWriter : XmlSequenceWriter
	{
		private XmlQueryItemSequence seqTyped;

		private XPathDocument doc;

		private XmlRawWriter writer;

		public XmlQueryItemSequence ResultSequence => seqTyped;

		public XmlCachedSequenceWriter()
		{
			seqTyped = new XmlQueryItemSequence();
		}

		public override XmlRawWriter StartTree(XPathNodeType rootType, IXmlNamespaceResolver nsResolver, XmlNameTable nameTable)
		{
			doc = new XPathDocument(nameTable);
			writer = doc.LoadFromWriter(XPathDocument.LoadFlags.AtomizeNames | ((rootType != 0) ? XPathDocument.LoadFlags.Fragment : XPathDocument.LoadFlags.None), string.Empty);
			writer.NamespaceResolver = nsResolver;
			return writer;
		}

		public override void EndTree()
		{
			writer.Close();
			seqTyped.Add(doc.CreateNavigator());
		}

		public override void WriteItem(XPathItem item)
		{
			seqTyped.AddClone(item);
		}
	}
	internal class XmlMergeSequenceWriter : XmlSequenceWriter
	{
		private XmlRawWriter xwrt;

		private bool lastItemWasAtomic;

		public XmlMergeSequenceWriter(XmlRawWriter xwrt)
		{
			this.xwrt = xwrt;
			lastItemWasAtomic = false;
		}

		public override XmlRawWriter StartTree(XPathNodeType rootType, IXmlNamespaceResolver nsResolver, XmlNameTable nameTable)
		{
			if (rootType == XPathNodeType.Attribute || rootType == XPathNodeType.Namespace)
			{
				throw new XslTransformException("XmlIl_TopLevelAttrNmsp", string.Empty);
			}
			xwrt.NamespaceResolver = nsResolver;
			return xwrt;
		}

		public override void EndTree()
		{
			lastItemWasAtomic = false;
		}

		public override void WriteItem(XPathItem item)
		{
			if (item.IsNode)
			{
				XPathNavigator xPathNavigator = item as XPathNavigator;
				if (xPathNavigator.NodeType == XPathNodeType.Attribute || xPathNavigator.NodeType == XPathNodeType.Namespace)
				{
					throw new XslTransformException("XmlIl_TopLevelAttrNmsp", string.Empty);
				}
				CopyNode(xPathNavigator);
				lastItemWasAtomic = false;
			}
			else
			{
				WriteString(item.Value);
			}
		}

		private void WriteString(string value)
		{
			if (lastItemWasAtomic)
			{
				xwrt.WriteWhitespace(" ");
			}
			else
			{
				lastItemWasAtomic = true;
			}
			xwrt.WriteString(value);
		}

		private void CopyNode(XPathNavigator nav)
		{
			int num = 0;
			while (true)
			{
				if (CopyShallowNode(nav))
				{
					XPathNodeType nodeType = nav.NodeType;
					if (nodeType == XPathNodeType.Element)
					{
						if (nav.MoveToFirstAttribute())
						{
							do
							{
								CopyShallowNode(nav);
							}
							while (nav.MoveToNextAttribute());
							nav.MoveToParent();
						}
						XPathNamespaceScope xPathNamespaceScope = ((num == 0) ? XPathNamespaceScope.ExcludeXml : XPathNamespaceScope.Local);
						if (nav.MoveToFirstNamespace(xPathNamespaceScope))
						{
							CopyNamespaces(nav, xPathNamespaceScope);
							nav.MoveToParent();
						}
						xwrt.StartElementContent();
					}
					if (nav.MoveToFirstChild())
					{
						num++;
						continue;
					}
					if (nav.NodeType == XPathNodeType.Element)
					{
						xwrt.WriteEndElement(nav.Prefix, nav.LocalName, nav.NamespaceURI);
					}
				}
				while (true)
				{
					if (num == 0)
					{
						return;
					}
					if (nav.MoveToNext())
					{
						break;
					}
					num--;
					nav.MoveToParent();
					if (nav.NodeType == XPathNodeType.Element)
					{
						xwrt.WriteFullEndElement(nav.Prefix, nav.LocalName, nav.NamespaceURI);
					}
				}
			}
		}

		private bool CopyShallowNode(XPathNavigator nav)
		{
			bool result = false;
			switch (nav.NodeType)
			{
			case XPathNodeType.Element:
				xwrt.WriteStartElement(nav.Prefix, nav.LocalName, nav.NamespaceURI);
				result = true;
				break;
			case XPathNodeType.Attribute:
				xwrt.WriteStartAttribute(nav.Prefix, nav.LocalName, nav.NamespaceURI);
				xwrt.WriteString(nav.Value);
				xwrt.WriteEndAttribute();
				break;
			case XPathNodeType.Text:
				xwrt.WriteString(nav.Value);
				break;
			case XPathNodeType.SignificantWhitespace:
			case XPathNodeType.Whitespace:
				xwrt.WriteWhitespace(nav.Value);
				break;
			case XPathNodeType.Root:
				result = true;
				break;
			case XPathNodeType.Comment:
				xwrt.WriteComment(nav.Value);
				break;
			case XPathNodeType.ProcessingInstruction:
				xwrt.WriteProcessingInstruction(nav.LocalName, nav.Value);
				break;
			case XPathNodeType.Namespace:
				xwrt.WriteNamespaceDeclaration(nav.LocalName, nav.Value);
				break;
			}
			return result;
		}

		private void CopyNamespaces(XPathNavigator nav, XPathNamespaceScope nsScope)
		{
			string localName = nav.LocalName;
			string value = nav.Value;
			if (nav.MoveToNextNamespace(nsScope))
			{
				CopyNamespaces(nav, nsScope);
			}
			xwrt.WriteNamespaceDeclaration(localName, value);
		}
	}
	internal abstract class XmlSortKey : IComparable
	{
		private int priority;

		private XmlSortKey nextKey;

		public int Priority
		{
			set
			{
				for (XmlSortKey xmlSortKey = this; xmlSortKey != null; xmlSortKey = xmlSortKey.nextKey)
				{
					xmlSortKey.priority = value;
				}
			}
		}

		public XmlSortKey AddSortKey(XmlSortKey sortKey)
		{
			if (nextKey != null)
			{
				nextKey.AddSortKey(sortKey);
			}
			else
			{
				nextKey = sortKey;
			}
			return this;
		}

		protected int BreakSortingTie(XmlSortKey that)
		{
			if (nextKey != null)
			{
				return nextKey.CompareTo(that.nextKey);
			}
			if (priority >= that.priority)
			{
				return 1;
			}
			return -1;
		}

		protected int CompareToEmpty(object obj)
		{
			XmlEmptySortKey xmlEmptySortKey = obj as XmlEmptySortKey;
			if (!xmlEmptySortKey.IsEmptyGreatest)
			{
				return 1;
			}
			return -1;
		}

		public abstract int CompareTo(object that);
	}
	internal class XmlEmptySortKey : XmlSortKey
	{
		private bool isEmptyGreatest;

		public bool IsEmptyGreatest => isEmptyGreatest;

		public XmlEmptySortKey(XmlCollation collation)
		{
			isEmptyGreatest = collation.EmptyGreatest != collation.DescendingOrder;
		}

		public override int CompareTo(object obj)
		{
			if (!(obj is XmlEmptySortKey that))
			{
				return -(obj as XmlSortKey).CompareTo(this);
			}
			return BreakSortingTie(that);
		}
	}
	internal class XmlDecimalSortKey : XmlSortKey
	{
		private decimal decVal;

		public XmlDecimalSortKey(decimal value, XmlCollation collation)
		{
			decVal = (collation.DescendingOrder ? (-value) : value);
		}

		public override int CompareTo(object obj)
		{
			if (!(obj is XmlDecimalSortKey xmlDecimalSortKey))
			{
				return CompareToEmpty(obj);
			}
			int num = decimal.Compare(decVal, xmlDecimalSortKey.decVal);
			if (num == 0)
			{
				return BreakSortingTie(xmlDecimalSortKey);
			}
			return num;
		}
	}
	internal class XmlIntegerSortKey : XmlSortKey
	{
		private long longVal;

		public XmlIntegerSortKey(long value, XmlCollation collation)
		{
			longVal = (collation.DescendingOrder ? (~value) : value);
		}

		public override int CompareTo(object obj)
		{
			if (!(obj is XmlIntegerSortKey xmlIntegerSortKey))
			{
				return CompareToEmpty(obj);
			}
			if (longVal == xmlIntegerSortKey.longVal)
			{
				return BreakSortingTie(xmlIntegerSortKey);
			}
			if (longVal >= xmlIntegerSortKey.longVal)
			{
				return 1;
			}
			return -1;
		}
	}
	internal class XmlIntSortKey : XmlSortKey
	{
		private int intVal;

		public XmlIntSortKey(int value, XmlCollation collation)
		{
			intVal = (collation.DescendingOrder ? (~value) : value);
		}

		public override int CompareTo(object obj)
		{
			if (!(obj is XmlIntSortKey xmlIntSortKey))
			{
				return CompareToEmpty(obj);
			}
			if (intVal == xmlIntSortKey.intVal)
			{
				return BreakSortingTie(xmlIntSortKey);
			}
			if (intVal >= xmlIntSortKey.intVal)
			{
				return 1;
			}
			return -1;
		}
	}
	internal class XmlStringSortKey : XmlSortKey
	{
		private System.Globalization.SortKey sortKey;

		private byte[] sortKeyBytes;

		private bool descendingOrder;

		public XmlStringSortKey(System.Globalization.SortKey sortKey, bool descendingOrder)
		{
			this.sortKey = sortKey;
			this.descendingOrder = descendingOrder;
		}

		public XmlStringSortKey(byte[] sortKey, bool descendingOrder)
		{
			sortKeyBytes = sortKey;
			this.descendingOrder = descendingOrder;
		}

		public override int CompareTo(object obj)
		{
			if (!(obj is XmlStringSortKey xmlStringSortKey))
			{
				return CompareToEmpty(obj);
			}
			int num;
			if (sortKey != null)
			{
				num = System.Globalization.SortKey.Compare(sortKey, xmlStringSortKey.sortKey);
			}
			else
			{
				int num2 = ((sortKeyBytes.Length < xmlStringSortKey.sortKeyBytes.Length) ? sortKeyBytes.Length : xmlStringSortKey.sortKeyBytes.Length);
				int num3 = 0;
				while (true)
				{
					if (num3 < num2)
					{
						if (sortKeyBytes[num3] < xmlStringSortKey.sortKeyBytes[num3])
						{
							num = -1;
							break;
						}
						if (sortKeyBytes[num3] > xmlStringSortKey.sortKeyBytes[num3])
						{
							num = 1;
							break;
						}
						num3++;
						continue;
					}
					num = ((sortKeyBytes.Length >= xmlStringSortKey.sortKeyBytes.Length) ? ((sortKeyBytes.Length > xmlStringSortKey.sortKeyBytes.Length) ? 1 : 0) : (-1));
					break;
				}
			}
			if (num == 0)
			{
				return BreakSortingTie(xmlStringSortKey);
			}
			if (!descendingOrder)
			{
				return num;
			}
			return -num;
		}
	}
	internal class XmlDoubleSortKey : XmlSortKey
	{
		private double dblVal;

		private bool isNaN;

		public XmlDoubleSortKey(double value, XmlCollation collation)
		{
			if (double.IsNaN(value))
			{
				isNaN = true;
				dblVal = ((collation.EmptyGreatest != collation.DescendingOrder) ? double.PositiveInfinity : double.NegativeInfinity);
			}
			else
			{
				dblVal = (collation.DescendingOrder ? (0.0 - value) : value);
			}
		}

		public override int CompareTo(object obj)
		{
			if (!(obj is XmlDoubleSortKey xmlDoubleSortKey))
			{
				if (isNaN)
				{
					return BreakSortingTie(obj as XmlSortKey);
				}
				return CompareToEmpty(obj);
			}
			if (dblVal == xmlDoubleSortKey.dblVal)
			{
				if (isNaN)
				{
					if (xmlDoubleSortKey.isNaN)
					{
						return BreakSortingTie(xmlDoubleSortKey);
					}
					if (dblVal != double.NegativeInfinity)
					{
						return 1;
					}
					return -1;
				}
				if (xmlDoubleSortKey.isNaN)
				{
					if (xmlDoubleSortKey.dblVal != double.NegativeInfinity)
					{
						return -1;
					}
					return 1;
				}
				return BreakSortingTie(xmlDoubleSortKey);
			}
			if (!(dblVal < xmlDoubleSortKey.dblVal))
			{
				return 1;
			}
			return -1;
		}
	}
	internal class XmlDateTimeSortKey : XmlIntegerSortKey
	{
		public XmlDateTimeSortKey(DateTime value, XmlCollation collation)
			: base(value.Ticks, collation)
		{
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct XmlSortKeyAccumulator
	{
		private const int DefaultSortKeyCount = 64;

		private XmlSortKey[] keys;

		private int pos;

		public Array Keys => keys;

		public void Create()
		{
			if (keys == null)
			{
				keys = new XmlSortKey[64];
			}
			pos = 0;
			keys[0] = null;
		}

		public void AddStringSortKey(XmlCollation collation, string value)
		{
			AppendSortKey(collation.CreateSortKey(value));
		}

		public void AddDecimalSortKey(XmlCollation collation, decimal value)
		{
			AppendSortKey(new XmlDecimalSortKey(value, collation));
		}

		public void AddIntegerSortKey(XmlCollation collation, long value)
		{
			AppendSortKey(new XmlIntegerSortKey(value, collation));
		}

		public void AddIntSortKey(XmlCollation collation, int value)
		{
			AppendSortKey(new XmlIntSortKey(value, collation));
		}

		public void AddDoubleSortKey(XmlCollation collation, double value)
		{
			AppendSortKey(new XmlDoubleSortKey(value, collation));
		}

		public void AddDateTimeSortKey(XmlCollation collation, DateTime value)
		{
			AppendSortKey(new XmlDateTimeSortKey(value, collation));
		}

		public void AddEmptySortKey(XmlCollation collation)
		{
			AppendSortKey(new XmlEmptySortKey(collation));
		}

		public void FinishSortKeys()
		{
			pos++;
			if (pos >= keys.Length)
			{
				XmlSortKey[] destinationArray = new XmlSortKey[pos * 2];
				Array.Copy(keys, 0, destinationArray, 0, keys.Length);
				keys = destinationArray;
			}
			keys[pos] = null;
		}

		private void AppendSortKey(XmlSortKey key)
		{
			key.Priority = pos;
			if (keys[pos] == null)
			{
				keys[pos] = key;
			}
			else
			{
				keys[pos].AddSortKey(key);
			}
		}
	}
	internal class TokenInfo
	{
		public char startChar;

		public int startIdx;

		public string formatString;

		public int length;

		private TokenInfo()
		{
		}

		[Conditional("DEBUG")]
		public void AssertSeparator(bool isSeparator)
		{
		}

		public static TokenInfo CreateSeparator(string formatString, int startIdx, int tokLen)
		{
			TokenInfo tokenInfo = new TokenInfo();
			tokenInfo.startIdx = startIdx;
			tokenInfo.formatString = formatString;
			tokenInfo.length = tokLen;
			return tokenInfo;
		}

		public static TokenInfo CreateFormat(string formatString, int startIdx, int tokLen)
		{
			TokenInfo tokenInfo = new TokenInfo();
			tokenInfo.formatString = null;
			tokenInfo.length = 1;
			bool flag = false;
			char c = formatString[startIdx];
			switch (c)
			{
			default:
				if (CharUtil.IsDecimalDigitOne(c))
				{
					break;
				}
				if (CharUtil.IsDecimalDigitOne((char)(c + 1)))
				{
					int num = startIdx;
					do
					{
						tokenInfo.length++;
					}
					while (--tokLen > 0 && c == formatString[++num]);
					if (formatString[num] == (c = (char)(c + 1)))
					{
						break;
					}
				}
				flag = true;
				break;
			case '1':
			case 'A':
			case 'I':
			case 'a':
			case 'i':
				break;
			}
			if (tokLen != 1)
			{
				flag = true;
			}
			if (flag)
			{
				tokenInfo.startChar = '1';
				tokenInfo.length = 1;
			}
			else
			{
				tokenInfo.startChar = c;
			}
			return tokenInfo;
		}
	}
	internal class NumberFormatter : NumberFormatterBase
	{
		public const char DefaultStartChar = '1';

		private string formatString;

		private int lang;

		private string letterValue;

		private string groupingSeparator;

		private int groupingSize;

		private List<TokenInfo> tokens;

		private static readonly TokenInfo DefaultFormat = TokenInfo.CreateFormat("0", 0, 1);

		private static readonly TokenInfo DefaultSeparator = TokenInfo.CreateSeparator(".", 0, 1);

		public NumberFormatter(string formatString, int lang, string letterValue, string groupingSeparator, int groupingSize)
		{
			this.formatString = formatString;
			this.lang = lang;
			this.letterValue = letterValue;
			this.groupingSeparator = groupingSeparator;
			this.groupingSize = ((groupingSeparator.Length > 0) ? groupingSize : 0);
			if (formatString == "1" || formatString.Length == 0)
			{
				return;
			}
			tokens = new List<TokenInfo>();
			int num = 0;
			bool flag = CharUtil.IsAlphaNumeric(formatString[num]);
			if (flag)
			{
				tokens.Add(null);
			}
			for (int i = 0; i <= formatString.Length; i++)
			{
				if (i == formatString.Length || flag != CharUtil.IsAlphaNumeric(formatString[i]))
				{
					if (flag)
					{
						tokens.Add(TokenInfo.CreateFormat(formatString, num, i - num));
					}
					else
					{
						tokens.Add(TokenInfo.CreateSeparator(formatString, num, i - num));
					}
					num = i;
					flag = !flag;
				}
			}
		}

		public string FormatSequence(IList<XPathItem> val)
		{
			StringBuilder stringBuilder = new StringBuilder();
			if (val.Count == 1 && val[0].ValueType == typeof(double))
			{
				double valueAsDouble = val[0].ValueAsDouble;
				if (!(0.5 <= valueAsDouble) || !(valueAsDouble < double.PositiveInfinity))
				{
					return XPathConvert.DoubleToString(valueAsDouble);
				}
			}
			if (tokens == null)
			{
				for (int i = 0; i < val.Count; i++)
				{
					if (i > 0)
					{
						stringBuilder.Append('.');
					}
					FormatItem(stringBuilder, val[i], '1', 1);
				}
			}
			else
			{
				int num = tokens.Count;
				TokenInfo tokenInfo = tokens[0];
				TokenInfo tokenInfo2 = ((num % 2 != 0) ? tokens[--num] : null);
				TokenInfo tokenInfo3 = ((2 < num) ? tokens[num - 2] : DefaultSeparator);
				TokenInfo tokenInfo4 = ((0 < num) ? tokens[num - 1] : DefaultFormat);
				if (tokenInfo != null)
				{
					stringBuilder.Append(tokenInfo.formatString, tokenInfo.startIdx, tokenInfo.length);
				}
				int count = val.Count;
				for (int j = 0; j < count; j++)
				{
					int num2 = j * 2;
					bool flag = num2 < num;
					if (j > 0)
					{
						TokenInfo tokenInfo5 = (flag ? tokens[num2] : tokenInfo3);
						stringBuilder.Append(tokenInfo5.formatString, tokenInfo5.startIdx, tokenInfo5.length);
					}
					TokenInfo tokenInfo6 = (flag ? tokens[num2 + 1] : tokenInfo4);
					FormatItem(stringBuilder, val[j], tokenInfo6.startChar, tokenInfo6.length);
				}
				if (tokenInfo2 != null)
				{
					stringBuilder.Append(tokenInfo2.formatString, tokenInfo2.startIdx, tokenInfo2.length);
				}
			}
			return stringBuilder.ToString();
		}

		private void FormatItem(StringBuilder sb, XPathItem item, char startChar, int length)
		{
			double num = ((item.ValueType != typeof(int)) ? XsltFunctions.Round(item.ValueAsDouble) : ((double)item.ValueAsInt));
			char zero = '0';
			switch (startChar)
			{
			case 'A':
			case 'a':
				if (num <= 2147483647.0)
				{
					NumberFormatterBase.ConvertToAlphabetic(sb, num, startChar, 26);
					return;
				}
				break;
			case 'I':
			case 'i':
				if (num <= 32767.0)
				{
					NumberFormatterBase.ConvertToRoman(sb, num, startChar == 'I');
					return;
				}
				break;
			default:
				zero = (char)(startChar - 1);
				break;
			case '1':
				break;
			}
			sb.Append(ConvertToDecimal(num, length, zero, groupingSeparator, groupingSize));
		}

		private unsafe static string ConvertToDecimal(double val, int minLen, char zero, string groupSeparator, int groupSize)
		{
			string text = XPathConvert.DoubleToString(val);
			int num = zero - 48;
			int length = text.Length;
			int num2 = Math.Max(length, minLen);
			checked
			{
				if (groupSize != 0)
				{
					num2 += unchecked(checked(num2 - 1) / groupSize);
				}
				if (num2 == length && num == 0)
				{
					return text;
				}
				if (groupSize == 0 && num == 0)
				{
					return text.PadLeft(num2, zero);
				}
			}
			char* ptr = (char*)stackalloc byte[2 * num2];
			char c = ((groupSeparator.Length > 0) ? groupSeparator[0] : ' ');
			fixed (char* ptr2 = text)
			{
				char* ptr3 = ptr2 + length - 1;
				char* ptr4 = ptr + num2 - 1;
				int num3 = groupSize;
				while (true)
				{
					char* intPtr = ptr4;
					ptr4 = intPtr - 1;
					int num4;
					if (ptr3 < ptr2)
					{
						num4 = zero;
					}
					else
					{
						char* intPtr2 = ptr3;
						ptr3 = intPtr2 - 1;
						num4 = (ushort)(*intPtr2 + num);
					}
					*intPtr = (char)num4;
					if (ptr4 < ptr)
					{
						break;
					}
					if (--num3 == 0)
					{
						char* intPtr3 = ptr4;
						ptr4 = intPtr3 - 1;
						*intPtr3 = c;
						num3 = groupSize;
					}
				}
			}
			return new string(ptr, 0, num2);
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public static class XsltConvert
	{
		internal static readonly Type BooleanType = typeof(bool);

		internal static readonly Type ByteArrayType = typeof(byte[]);

		internal static readonly Type ByteType = typeof(byte);

		internal static readonly Type DateTimeType = typeof(DateTime);

		internal static readonly Type DecimalType = typeof(decimal);

		internal static readonly Type DoubleType = typeof(double);

		internal static readonly Type ICollectionType = typeof(ICollection);

		internal static readonly Type IEnumerableType = typeof(IEnumerable);

		internal static readonly Type IListType = typeof(IList);

		internal static readonly Type Int16Type = typeof(short);

		internal static readonly Type Int32Type = typeof(int);

		internal static readonly Type Int64Type = typeof(long);

		internal static readonly Type IXPathNavigableType = typeof(IXPathNavigable);

		internal static readonly Type ObjectType = typeof(object);

		internal static readonly Type SByteType = typeof(sbyte);

		internal static readonly Type SingleType = typeof(float);

		internal static readonly Type StringType = typeof(string);

		internal static readonly Type TimeSpanType = typeof(TimeSpan);

		internal static readonly Type UInt16Type = typeof(ushort);

		internal static readonly Type UInt32Type = typeof(uint);

		internal static readonly Type UInt64Type = typeof(ulong);

		internal static readonly Type UriType = typeof(Uri);

		internal static readonly Type VoidType = typeof(void);

		internal static readonly Type XmlAtomicValueType = typeof(XmlAtomicValue);

		internal static readonly Type XmlQualifiedNameType = typeof(XmlQualifiedName);

		internal static readonly Type XPathItemType = typeof(XPathItem);

		internal static readonly Type XPathNavigatorArrayType = typeof(XPathNavigator[]);

		internal static readonly Type XPathNavigatorType = typeof(XPathNavigator);

		internal static readonly Type XPathNodeIteratorType = typeof(XPathNodeIterator);

		public static bool ToBoolean(XPathItem item)
		{
			if (item.IsNode)
			{
				return true;
			}
			Type valueType = item.ValueType;
			if (valueType == StringType)
			{
				return item.Value.Length != 0;
			}
			if (valueType == DoubleType)
			{
				double valueAsDouble = item.ValueAsDouble;
				if (!(valueAsDouble < 0.0))
				{
					return 0.0 < valueAsDouble;
				}
				return true;
			}
			return item.ValueAsBoolean;
		}

		public static bool ToBoolean(IList<XPathItem> listItems)
		{
			if (listItems.Count == 0)
			{
				return false;
			}
			return ToBoolean(listItems[0]);
		}

		public static double ToDouble(string value)
		{
			return XPathConvert.StringToDouble(value);
		}

		public static double ToDouble(XPathItem item)
		{
			if (item.IsNode)
			{
				return XPathConvert.StringToDouble(item.Value);
			}
			Type valueType = item.ValueType;
			if (valueType == StringType)
			{
				return XPathConvert.StringToDouble(item.Value);
			}
			if (valueType == DoubleType)
			{
				return item.ValueAsDouble;
			}
			if (!item.ValueAsBoolean)
			{
				return 0.0;
			}
			return 1.0;
		}

		public static double ToDouble(IList<XPathItem> listItems)
		{
			if (listItems.Count == 0)
			{
				return double.NaN;
			}
			return ToDouble(listItems[0]);
		}

		public static XPathNavigator ToNode(XPathItem item)
		{
			if (!item.IsNode)
			{
				XPathDocument xPathDocument = new XPathDocument();
				XmlRawWriter xmlRawWriter = xPathDocument.LoadFromWriter(XPathDocument.LoadFlags.AtomizeNames, string.Empty);
				xmlRawWriter.WriteString(ToString(item));
				xmlRawWriter.Close();
				return xPathDocument.CreateNavigator();
			}
			if (item is RtfNavigator rtfNavigator)
			{
				return rtfNavigator.ToNavigator();
			}
			return (XPathNavigator)item;
		}

		public static XPathNavigator ToNode(IList<XPathItem> listItems)
		{
			if (listItems.Count == 1)
			{
				return ToNode(listItems[0]);
			}
			throw new XslTransformException("Xslt_NodeSetNotNode", string.Empty);
		}

		public static IList<XPathNavigator> ToNodeSet(XPathItem item)
		{
			return new XmlQueryNodeSequence(ToNode(item));
		}

		public static IList<XPathNavigator> ToNodeSet(IList<XPathItem> listItems)
		{
			if (listItems.Count == 1)
			{
				return new XmlQueryNodeSequence(ToNode(listItems[0]));
			}
			return XmlILStorageConverter.ItemsToNavigators(listItems);
		}

		public static string ToString(double value)
		{
			return XPathConvert.DoubleToString(value);
		}

		public static string ToString(XPathItem item)
		{
			if (!item.IsNode && item.ValueType == DoubleType)
			{
				return XPathConvert.DoubleToString(item.ValueAsDouble);
			}
			return item.Value;
		}

		public static string ToString(IList<XPathItem> listItems)
		{
			if (listItems.Count == 0)
			{
				return string.Empty;
			}
			return ToString(listItems[0]);
		}

		public static string ToString(DateTime value)
		{
			return new XsdDateTime(value, XsdDateTimeFlags.DateTime).ToString();
		}

		public static double ToDouble(decimal value)
		{
			return (double)value;
		}

		public static double ToDouble(int value)
		{
			return value;
		}

		public static double ToDouble(long value)
		{
			return value;
		}

		public static decimal ToDecimal(double value)
		{
			return (decimal)value;
		}

		public static int ToInt(double value)
		{
			return checked((int)value);
		}

		public static long ToLong(double value)
		{
			return checked((long)value);
		}

		public static DateTime ToDateTime(string value)
		{
			return new XsdDateTime(value, XsdDateTimeFlags.AllXsd);
		}

		internal static XmlAtomicValue ConvertToType(XmlAtomicValue value, XmlQueryType destinationType)
		{
			switch (destinationType.TypeCode)
			{
			case XmlTypeCode.Boolean:
				switch (value.XmlType.TypeCode)
				{
				case XmlTypeCode.String:
				case XmlTypeCode.Boolean:
				case XmlTypeCode.Double:
					return new XmlAtomicValue(destinationType.SchemaType, ToBoolean(value));
				}
				break;
			case XmlTypeCode.DateTime:
				if (value.XmlType.TypeCode == XmlTypeCode.String)
				{
					return new XmlAtomicValue(destinationType.SchemaType, ToDateTime(value.Value));
				}
				break;
			case XmlTypeCode.Decimal:
				if (value.XmlType.TypeCode == XmlTypeCode.Double)
				{
					return new XmlAtomicValue(destinationType.SchemaType, ToDecimal(value.ValueAsDouble));
				}
				break;
			case XmlTypeCode.Double:
				switch (value.XmlType.TypeCode)
				{
				case XmlTypeCode.String:
				case XmlTypeCode.Boolean:
				case XmlTypeCode.Double:
					return new XmlAtomicValue(destinationType.SchemaType, ToDouble(value));
				case XmlTypeCode.Decimal:
					return new XmlAtomicValue(destinationType.SchemaType, ToDouble((decimal)value.ValueAs(DecimalType, null)));
				case XmlTypeCode.Long:
				case XmlTypeCode.Int:
					return new XmlAtomicValue(destinationType.SchemaType, ToDouble(value.ValueAsLong));
				}
				break;
			case XmlTypeCode.Long:
			case XmlTypeCode.Int:
				if (value.XmlType.TypeCode == XmlTypeCode.Double)
				{
					return new XmlAtomicValue(destinationType.SchemaType, ToLong(value.ValueAsDouble));
				}
				break;
			case XmlTypeCode.String:
				switch (value.XmlType.TypeCode)
				{
				case XmlTypeCode.String:
				case XmlTypeCode.Boolean:
				case XmlTypeCode.Double:
					return new XmlAtomicValue(destinationType.SchemaType, ToString(value));
				case XmlTypeCode.DateTime:
					return new XmlAtomicValue(destinationType.SchemaType, ToString(value.ValueAsDateTime));
				}
				break;
			}
			return value;
		}

		public static IList<XPathNavigator> EnsureNodeSet(IList<XPathItem> listItems)
		{
			if (listItems.Count == 1)
			{
				XPathItem xPathItem = listItems[0];
				if (!xPathItem.IsNode)
				{
					throw new XslTransformException("XPath_NodeSetExpected", string.Empty);
				}
				if (xPathItem is RtfNavigator)
				{
					throw new XslTransformException("XPath_RtfInPathExpr", string.Empty);
				}
			}
			return XmlILStorageConverter.ItemsToNavigators(listItems);
		}

		internal static XmlQueryType InferXsltType(Type clrType)
		{
			if (clrType == BooleanType)
			{
				return XmlQueryTypeFactory.BooleanX;
			}
			if (clrType == ByteType)
			{
				return XmlQueryTypeFactory.DoubleX;
			}
			if (clrType == DecimalType)
			{
				return XmlQueryTypeFactory.DoubleX;
			}
			if (clrType == DateTimeType)
			{
				return XmlQueryTypeFactory.StringX;
			}
			if (clrType == DoubleType)
			{
				return XmlQueryTypeFactory.DoubleX;
			}
			if (clrType == Int16Type)
			{
				return XmlQueryTypeFactory.DoubleX;
			}
			if (clrType == Int32Type)
			{
				return XmlQueryTypeFactory.DoubleX;
			}
			if (clrType == Int64Type)
			{
				return XmlQueryTypeFactory.DoubleX;
			}
			if (clrType == IXPathNavigableType)
			{
				return XmlQueryTypeFactory.NodeNotRtf;
			}
			if (clrType == SByteType)
			{
				return XmlQueryTypeFactory.DoubleX;
			}
			if (clrType == SingleType)
			{
				return XmlQueryTypeFactory.DoubleX;
			}
			if (clrType == StringType)
			{
				return XmlQueryTypeFactory.StringX;
			}
			if (clrType == UInt16Type)
			{
				return XmlQueryTypeFactory.DoubleX;
			}
			if (clrType == UInt32Type)
			{
				return XmlQueryTypeFactory.DoubleX;
			}
			if (clrType == UInt64Type)
			{
				return XmlQueryTypeFactory.DoubleX;
			}
			if (clrType == XPathNavigatorArrayType)
			{
				return XmlQueryTypeFactory.NodeDodS;
			}
			if (clrType == XPathNavigatorType)
			{
				return XmlQueryTypeFactory.NodeNotRtf;
			}
			if (clrType == XPathNodeIteratorType)
			{
				return XmlQueryTypeFactory.NodeDodS;
			}
			if (clrType.IsEnum)
			{
				return XmlQueryTypeFactory.DoubleX;
			}
			if (clrType == VoidType)
			{
				return XmlQueryTypeFactory.Empty;
			}
			return XmlQueryTypeFactory.ItemS;
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public static class XsltFunctions
	{
		private struct SystemTime
		{
			[MarshalAs(UnmanagedType.U2)]
			public ushort Year;

			[MarshalAs(UnmanagedType.U2)]
			public ushort Month;

			[MarshalAs(UnmanagedType.U2)]
			public ushort DayOfWeek;

			[MarshalAs(UnmanagedType.U2)]
			public ushort Day;

			[MarshalAs(UnmanagedType.U2)]
			public ushort Hour;

			[MarshalAs(UnmanagedType.U2)]
			public ushort Minute;

			[MarshalAs(UnmanagedType.U2)]
			public ushort Second;

			[MarshalAs(UnmanagedType.U2)]
			public ushort Milliseconds;

			public SystemTime(DateTime dateTime)
			{
				Year = (ushort)dateTime.Year;
				Month = (ushort)dateTime.Month;
				DayOfWeek = (ushort)dateTime.DayOfWeek;
				Day = (ushort)dateTime.Day;
				Hour = (ushort)dateTime.Hour;
				Minute = (ushort)dateTime.Minute;
				Second = (ushort)dateTime.Second;
				Milliseconds = (ushort)dateTime.Millisecond;
			}
		}

		private static readonly CompareInfo compareInfo = CultureInfo.InvariantCulture.CompareInfo;

		public static bool StartsWith(string s1, string s2)
		{
			if (s1.Length >= s2.Length)
			{
				return string.CompareOrdinal(s1, 0, s2, 0, s2.Length) == 0;
			}
			return false;
		}

		public static bool Contains(string s1, string s2)
		{
			return compareInfo.IndexOf(s1, s2, CompareOptions.Ordinal) >= 0;
		}

		public static string SubstringBefore(string s1, string s2)
		{
			if (s2.Length == 0)
			{
				return s2;
			}
			int num = compareInfo.IndexOf(s1, s2, CompareOptions.Ordinal);
			if (num >= 1)
			{
				return s1.Substring(0, num);
			}
			return string.Empty;
		}

		public static string SubstringAfter(string s1, string s2)
		{
			if (s2.Length == 0)
			{
				return s1;
			}
			int num = compareInfo.IndexOf(s1, s2, CompareOptions.Ordinal);
			if (num >= 0)
			{
				return s1.Substring(num + s2.Length);
			}
			return string.Empty;
		}

		public static string Substring(string value, double startIndex)
		{
			startIndex = Round(startIndex);
			if (startIndex <= 0.0)
			{
				return value;
			}
			if (startIndex <= (double)value.Length)
			{
				return value.Substring((int)startIndex - 1);
			}
			return string.Empty;
		}

		public static string Substring(string value, double startIndex, double length)
		{
			startIndex = Round(startIndex) - 1.0;
			if (startIndex >= (double)value.Length)
			{
				return string.Empty;
			}
			double num = startIndex + Round(length);
			startIndex = ((startIndex <= 0.0) ? 0.0 : startIndex);
			if (startIndex < num)
			{
				if (num > (double)value.Length)
				{
					num = value.Length;
				}
				return value.Substring((int)startIndex, (int)(num - startIndex));
			}
			return string.Empty;
		}

		public static string NormalizeSpace(string value)
		{
			XmlCharType instance = XmlCharType.Instance;
			StringBuilder stringBuilder = null;
			int num = 0;
			int num2 = 0;
			int i;
			for (i = 0; i < value.Length; i++)
			{
				if (!instance.IsWhiteSpace(value[i]))
				{
					continue;
				}
				if (i == num)
				{
					num++;
				}
				else if (value[i] != ' ' || num2 == i)
				{
					if (stringBuilder == null)
					{
						stringBuilder = new StringBuilder(value.Length);
					}
					else
					{
						stringBuilder.Append(' ');
					}
					if (num2 == i)
					{
						stringBuilder.Append(value, num, i - num - 1);
					}
					else
					{
						stringBuilder.Append(value, num, i - num);
					}
					num = i + 1;
				}
				else
				{
					num2 = i + 1;
				}
			}
			if (stringBuilder == null)
			{
				if (num == i)
				{
					return string.Empty;
				}
				if (num == 0 && num2 != i)
				{
					return value;
				}
				stringBuilder = new StringBuilder(value.Length);
			}
			else if (i != num)
			{
				stringBuilder.Append(' ');
			}
			if (num2 == i)
			{
				stringBuilder.Append(value, num, i - num - 1);
			}
			else
			{
				stringBuilder.Append(value, num, i - num);
			}
			return stringBuilder.ToString();
		}

		public static string Translate(string arg, string mapString, string transString)
		{
			if (mapString.Length == 0)
			{
				return arg;
			}
			StringBuilder stringBuilder = new StringBuilder(arg.Length);
			for (int i = 0; i < arg.Length; i++)
			{
				int num = mapString.IndexOf(arg[i]);
				if (num < 0)
				{
					stringBuilder.Append(arg[i]);
				}
				else if (num < transString.Length)
				{
					stringBuilder.Append(transString[num]);
				}
			}
			return stringBuilder.ToString();
		}

		public static bool Lang(string value, XPathNavigator context)
		{
			string xmlLang = context.XmlLang;
			if (!xmlLang.StartsWith(value, StringComparison.OrdinalIgnoreCase))
			{
				return false;
			}
			if (xmlLang.Length != value.Length)
			{
				return xmlLang[value.Length] == '-';
			}
			return true;
		}

		public static double Round(double value)
		{
			double num = Math.Round(value);
			if (value - num != 0.5)
			{
				return num;
			}
			return num + 1.0;
		}

		public static XPathItem SystemProperty(XmlQualifiedName name)
		{
			if (name.Namespace == "http://www.w3.org/1999/XSL/Transform")
			{
				switch (name.Name)
				{
				case "version":
					return new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Double), 1.0);
				case "vendor":
					return new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), "Microsoft");
				case "vendor-url":
					return new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), "http://www.microsoft.com");
				}
			}
			else if (name.Namespace == "urn:schemas-microsoft-com:xslt" && name.Name == "version")
			{
				return new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), typeof(XsltLibrary).Assembly.ImageRuntimeVersion);
			}
			return new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), string.Empty);
		}

		public static string BaseUri(XPathNavigator navigator)
		{
			return navigator.BaseURI;
		}

		public static string OuterXml(XPathNavigator navigator)
		{
			if (!(navigator is RtfNavigator rtfNavigator))
			{
				return navigator.OuterXml;
			}
			StringBuilder stringBuilder = new StringBuilder();
			XmlWriterSettings xmlWriterSettings = new XmlWriterSettings();
			xmlWriterSettings.OmitXmlDeclaration = true;
			xmlWriterSettings.ConformanceLevel = ConformanceLevel.Fragment;
			xmlWriterSettings.CheckCharacters = false;
			XmlWriter xmlWriter = XmlWriter.Create(stringBuilder, xmlWriterSettings);
			rtfNavigator.CopyToWriter(xmlWriter);
			xmlWriter.Close();
			return stringBuilder.ToString();
		}

		public static string EXslObjectType(IList<XPathItem> value)
		{
			if (value.Count != 1)
			{
				return "node-set";
			}
			XPathItem xPathItem = value[0];
			if (xPathItem is RtfNavigator)
			{
				return "RTF";
			}
			if (xPathItem.IsNode)
			{
				return "node-set";
			}
			object typedValue = xPathItem.TypedValue;
			if (typedValue is string)
			{
				return "string";
			}
			if (typedValue is double)
			{
				return "number";
			}
			if (typedValue is bool)
			{
				return "boolean";
			}
			return "external";
		}

		public static double MSNumber(IList<XPathItem> value)
		{
			if (value.Count == 0)
			{
				return double.NaN;
			}
			XPathItem xPathItem = value[0];
			string value2;
			if (xPathItem.IsNode)
			{
				value2 = xPathItem.Value;
			}
			else
			{
				Type valueType = xPathItem.ValueType;
				if (valueType != XsltConvert.StringType)
				{
					if (valueType == XsltConvert.DoubleType)
					{
						return xPathItem.ValueAsDouble;
					}
					if (!xPathItem.ValueAsBoolean)
					{
						return 0.0;
					}
					return 1.0;
				}
				value2 = xPathItem.Value;
			}
			if (XmlConvert.TryToDouble(value2, out var result) != null)
			{
				return double.NaN;
			}
			return result;
		}

		[DllImport("kernel32.dll", CharSet = CharSet.Auto)]
		private static extern int GetDateFormat(int locale, uint dwFlags, ref SystemTime sysTime, string format, StringBuilder sb, int sbSize);

		[DllImport("kernel32.dll", CharSet = CharSet.Auto)]
		private static extern int GetTimeFormat(int locale, uint dwFlags, ref SystemTime sysTime, string format, StringBuilder sb, int sbSize);

		public static string MSFormatDateTime(string dateTime, string format, string lang, bool isDate)
		{
			try
			{
				int lCID = GetCultureInfo(lang).LCID;
				if (!XsdDateTime.TryParse(dateTime, XsdDateTimeFlags.AllXsd | XsdDateTimeFlags.XdrDateTime | XsdDateTimeFlags.XdrTimeNoTz, out var result))
				{
					return string.Empty;
				}
				SystemTime sysTime = new SystemTime(result.ToZulu());
				StringBuilder stringBuilder = new StringBuilder(format.Length + 16);
				if (format.Length == 0)
				{
					format = null;
				}
				if (isDate)
				{
					if (GetDateFormat(lCID, 0u, ref sysTime, format, stringBuilder, stringBuilder.Capacity) == 0)
					{
						int dateFormat = GetDateFormat(lCID, 0u, ref sysTime, format, stringBuilder, 0);
						if (dateFormat != 0)
						{
							stringBuilder = new StringBuilder(dateFormat);
							dateFormat = GetDateFormat(lCID, 0u, ref sysTime, format, stringBuilder, stringBuilder.Capacity);
						}
					}
				}
				else if (GetTimeFormat(lCID, 0u, ref sysTime, format, stringBuilder, stringBuilder.Capacity) == 0)
				{
					int timeFormat = GetTimeFormat(lCID, 0u, ref sysTime, format, stringBuilder, 0);
					if (timeFormat != 0)
					{
						stringBuilder = new StringBuilder(timeFormat);
						timeFormat = GetTimeFormat(lCID, 0u, ref sysTime, format, stringBuilder, stringBuilder.Capacity);
					}
				}
				return stringBuilder.ToString();
			}
			catch (ArgumentException)
			{
				return string.Empty;
			}
		}

		public static double MSStringCompare(string s1, string s2, string lang, string options)
		{
			CultureInfo cultureInfo = GetCultureInfo(lang);
			CompareOptions compareOptions = CompareOptions.None;
			bool flag = false;
			for (int i = 0; i < options.Length; i++)
			{
				switch (options[i])
				{
				case 'i':
					compareOptions = CompareOptions.IgnoreCase | CompareOptions.IgnoreKanaType | CompareOptions.IgnoreWidth;
					break;
				case 'u':
					flag = true;
					break;
				default:
					flag = true;
					compareOptions = CompareOptions.IgnoreCase;
					break;
				}
			}
			if (flag)
			{
				if (compareOptions != 0)
				{
					throw new XslTransformException("Xslt_InvalidCompareOption", options);
				}
				compareOptions = CompareOptions.IgnoreCase;
			}
			int num = cultureInfo.CompareInfo.Compare(s1, s2, compareOptions);
			if (flag && num == 0)
			{
				num = -cultureInfo.CompareInfo.Compare(s1, s2, CompareOptions.None);
			}
			return num;
		}

		public static string MSUtc(string dateTime)
		{
			XsdDateTime result;
			DateTime dt;
			try
			{
				if (!XsdDateTime.TryParse(dateTime, XsdDateTimeFlags.AllXsd | XsdDateTimeFlags.XdrDateTime | XsdDateTimeFlags.XdrTimeNoTz, out result))
				{
					return string.Empty;
				}
				dt = result.ToZulu();
			}
			catch (ArgumentException)
			{
				return string.Empty;
			}
			char[] array = "----------T00:00:00.000".ToCharArray();
			switch (result.TypeCode)
			{
			case XmlTypeCode.DateTime:
				PrintDate(array, dt);
				PrintTime(array, dt);
				break;
			case XmlTypeCode.Time:
				PrintTime(array, dt);
				break;
			case XmlTypeCode.Date:
				PrintDate(array, dt);
				break;
			case XmlTypeCode.GYearMonth:
				PrintYear(array, dt.Year);
				ShortToCharArray(array, 5, dt.Month);
				break;
			case XmlTypeCode.GYear:
				PrintYear(array, dt.Year);
				break;
			case XmlTypeCode.GMonthDay:
				ShortToCharArray(array, 5, dt.Month);
				ShortToCharArray(array, 8, dt.Day);
				break;
			case XmlTypeCode.GDay:
				ShortToCharArray(array, 8, dt.Day);
				break;
			case XmlTypeCode.GMonth:
				ShortToCharArray(array, 5, dt.Month);
				break;
			}
			return new string(array);
		}

		public static string MSLocalName(string name)
		{
			int colonOffset;
			int num = ValidateNames.ParseQName(name, 0, out colonOffset);
			if (num != name.Length)
			{
				return string.Empty;
			}
			if (colonOffset == 0)
			{
				return name;
			}
			return name.Substring(colonOffset + 1);
		}

		public static string MSNamespaceUri(string name, XPathNavigator currentNode)
		{
			int colonOffset;
			int num = ValidateNames.ParseQName(name, 0, out colonOffset);
			if (num != name.Length)
			{
				return string.Empty;
			}
			string text = name.Substring(0, colonOffset);
			if (text == "xmlns")
			{
				return string.Empty;
			}
			string text2 = currentNode.LookupNamespace(text);
			if (text2 != null)
			{
				return text2;
			}
			if (text == "xml")
			{
				return "http://www.w3.org/XML/1998/namespace";
			}
			return string.Empty;
		}

		private static CultureInfo GetCultureInfo(string lang)
		{
			if (lang.Length == 0)
			{
				return CultureInfo.CurrentCulture;
			}
			try
			{
				return new CultureInfo(lang);
			}
			catch (ArgumentException)
			{
				throw new XslTransformException("Xslt_InvalidLanguage", lang);
			}
		}

		private static void PrintDate(char[] text, DateTime dt)
		{
			PrintYear(text, dt.Year);
			ShortToCharArray(text, 5, dt.Month);
			ShortToCharArray(text, 8, dt.Day);
		}

		private static void PrintTime(char[] text, DateTime dt)
		{
			ShortToCharArray(text, 11, dt.Hour);
			ShortToCharArray(text, 14, dt.Minute);
			ShortToCharArray(text, 17, dt.Second);
			PrintMsec(text, dt.Millisecond);
		}

		private static void PrintYear(char[] text, int value)
		{
			text[0] = (char)(value / 1000 % 10 + 48);
			text[1] = (char)(value / 100 % 10 + 48);
			text[2] = (char)(value / 10 % 10 + 48);
			text[3] = (char)(value / 1 % 10 + 48);
		}

		private static void PrintMsec(char[] text, int value)
		{
			if (value != 0)
			{
				text[20] = (char)(value / 100 % 10 + 48);
				text[21] = (char)(value / 10 % 10 + 48);
				text[22] = (char)(value / 1 % 10 + 48);
			}
		}

		private static void ShortToCharArray(char[] text, int start, int value)
		{
			text[start] = (char)(value / 10 + 48);
			text[start + 1] = (char)(value % 10 + 48);
		}
	}
	internal static class XsltMethods
	{
		public static readonly MethodInfo FormatMessage = GetMethod(typeof(XsltLibrary), "FormatMessage");

		public static readonly MethodInfo EnsureNodeSet = GetMethod(typeof(XsltConvert), "EnsureNodeSet", typeof(IList<XPathItem>));

		public static readonly MethodInfo EqualityOperator = GetMethod(typeof(XsltLibrary), "EqualityOperator");

		public static readonly MethodInfo RelationalOperator = GetMethod(typeof(XsltLibrary), "RelationalOperator");

		public static readonly MethodInfo StartsWith = GetMethod(typeof(XsltFunctions), "StartsWith");

		public static readonly MethodInfo Contains = GetMethod(typeof(XsltFunctions), "Contains");

		public static readonly MethodInfo SubstringBefore = GetMethod(typeof(XsltFunctions), "SubstringBefore");

		public static readonly MethodInfo SubstringAfter = GetMethod(typeof(XsltFunctions), "SubstringAfter");

		public static readonly MethodInfo Substring2 = GetMethod(typeof(XsltFunctions), "Substring", typeof(string), typeof(double));

		public static readonly MethodInfo Substring3 = GetMethod(typeof(XsltFunctions), "Substring", typeof(string), typeof(double), typeof(double));

		public static readonly MethodInfo NormalizeSpace = GetMethod(typeof(XsltFunctions), "NormalizeSpace");

		public static readonly MethodInfo Translate = GetMethod(typeof(XsltFunctions), "Translate");

		public static readonly MethodInfo Lang = GetMethod(typeof(XsltFunctions), "Lang");

		public static readonly MethodInfo Floor = GetMethod(typeof(Math), "Floor", typeof(double));

		public static readonly MethodInfo Ceiling = GetMethod(typeof(Math), "Ceiling", typeof(double));

		public static readonly MethodInfo Round = GetMethod(typeof(XsltFunctions), "Round");

		public static readonly MethodInfo SystemProperty = GetMethod(typeof(XsltFunctions), "SystemProperty");

		public static readonly MethodInfo BaseUri = GetMethod(typeof(XsltFunctions), "BaseUri");

		public static readonly MethodInfo OuterXml = GetMethod(typeof(XsltFunctions), "OuterXml");

		public static readonly MethodInfo OnCurrentNodeChanged = GetMethod(typeof(XmlQueryRuntime), "OnCurrentNodeChanged");

		public static readonly MethodInfo MSFormatDateTime = GetMethod(typeof(XsltFunctions), "MSFormatDateTime");

		public static readonly MethodInfo MSStringCompare = GetMethod(typeof(XsltFunctions), "MSStringCompare");

		public static readonly MethodInfo MSUtc = GetMethod(typeof(XsltFunctions), "MSUtc");

		public static readonly MethodInfo MSNumber = GetMethod(typeof(XsltFunctions), "MSNumber");

		public static readonly MethodInfo MSLocalName = GetMethod(typeof(XsltFunctions), "MSLocalName");

		public static readonly MethodInfo MSNamespaceUri = GetMethod(typeof(XsltFunctions), "MSNamespaceUri");

		public static readonly MethodInfo EXslObjectType = GetMethod(typeof(XsltFunctions), "EXslObjectType");

		public static readonly MethodInfo CheckScriptNamespace = GetMethod(typeof(XsltLibrary), "CheckScriptNamespace");

		public static readonly MethodInfo FunctionAvailable = GetMethod(typeof(XsltLibrary), "FunctionAvailable");

		public static readonly MethodInfo ElementAvailable = GetMethod(typeof(XsltLibrary), "ElementAvailable");

		public static readonly MethodInfo RegisterDecimalFormat = GetMethod(typeof(XsltLibrary), "RegisterDecimalFormat");

		public static readonly MethodInfo RegisterDecimalFormatter = GetMethod(typeof(XsltLibrary), "RegisterDecimalFormatter");

		public static readonly MethodInfo FormatNumberStatic = GetMethod(typeof(XsltLibrary), "FormatNumberStatic");

		public static readonly MethodInfo FormatNumberDynamic = GetMethod(typeof(XsltLibrary), "FormatNumberDynamic");

		public static readonly MethodInfo IsSameNodeSort = GetMethod(typeof(XsltLibrary), "IsSameNodeSort");

		public static readonly MethodInfo LangToLcid = GetMethod(typeof(XsltLibrary), "LangToLcid");

		public static readonly MethodInfo NumberFormat = GetMethod(typeof(XsltLibrary), "NumberFormat");

		public static MethodInfo GetMethod(Type className, string methName)
		{
			return className.GetMethod(methName);
		}

		public static MethodInfo GetMethod(Type className, string methName, params Type[] args)
		{
			return className.GetMethod(methName, args);
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public sealed class XsltLibrary
	{
		internal enum ComparisonOperator
		{
			Eq,
			Ne,
			Lt,
			Le,
			Gt,
			Ge
		}

		internal const int InvariantCultureLcid = 127;

		private XmlQueryRuntime runtime;

		private HybridDictionary functionsAvail;

		private DecimalFormats decimalFormats;

		private List<DecimalFormatter> decimalFormatters;

		internal XsltLibrary(XmlQueryRuntime runtime)
		{
			this.runtime = runtime;
		}

		public string FormatMessage(string res, IList<string> args)
		{
			string[] array = new string[args.Count];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = args[i];
			}
			return XslTransformException.CreateMessage(res, array);
		}

		public int CheckScriptNamespace(string nsUri)
		{
			if (runtime.ExternalContext.GetLateBoundObject(nsUri) != null)
			{
				throw new XslTransformException("Xslt_ScriptAndExtensionClash", nsUri);
			}
			return 0;
		}

		public bool ElementAvailable(XmlQualifiedName name)
		{
			return QilGenerator.IsElementAvailable(name);
		}

		public bool FunctionAvailable(XmlQualifiedName name)
		{
			if (functionsAvail == null)
			{
				functionsAvail = new HybridDictionary();
			}
			else
			{
				object obj = functionsAvail[name];
				if (obj != null)
				{
					return (bool)obj;
				}
			}
			bool flag = FunctionAvailableHelper(name);
			functionsAvail[name] = flag;
			return flag;
		}

		private bool FunctionAvailableHelper(XmlQualifiedName name)
		{
			if (QilGenerator.IsFunctionAvailable(name.Name, name.Namespace))
			{
				return true;
			}
			if (name.Namespace.Length == 0 || name.Namespace == "http://www.w3.org/1999/XSL/Transform")
			{
				return false;
			}
			if (runtime.ExternalContext.LateBoundFunctionExists(name.Name, name.Namespace))
			{
				return true;
			}
			return runtime.EarlyBoundFunctionExists(name.Name, name.Namespace);
		}

		public int RegisterDecimalFormat(XmlQualifiedName name, string infinitySymbol, string nanSymbol, string characters)
		{
			if (decimalFormats == null)
			{
				decimalFormats = new DecimalFormats();
			}
			DecimalFormatDecl item = new DecimalFormatDecl(name, infinitySymbol, nanSymbol, characters);
			decimalFormats.Add(item);
			return 0;
		}

		private DecimalFormatter CreateDecimalFormatter(string formatPicture, string infinitySymbol, string nanSymbol, string characters)
		{
			NumberFormatInfo numberFormatInfo = new NumberFormatInfo();
			numberFormatInfo.NumberDecimalSeparator = char.ToString(characters[0]);
			numberFormatInfo.NumberGroupSeparator = char.ToString(characters[1]);
			numberFormatInfo.PositiveInfinitySymbol = infinitySymbol;
			numberFormatInfo.NegativeSign = char.ToString(characters[7]);
			numberFormatInfo.NaNSymbol = nanSymbol;
			numberFormatInfo.PercentSymbol = char.ToString(characters[2]);
			numberFormatInfo.PerMilleSymbol = char.ToString(characters[3]);
			numberFormatInfo.NegativeInfinitySymbol = numberFormatInfo.NegativeSign + numberFormatInfo.PositiveInfinitySymbol;
			DecimalFormat decimalFormat = new DecimalFormat(numberFormatInfo, characters[5], characters[4], characters[6]);
			return new DecimalFormatter(formatPicture, decimalFormat);
		}

		public double RegisterDecimalFormatter(string formatPicture, string infinitySymbol, string nanSymbol, string characters)
		{
			if (decimalFormatters == null)
			{
				decimalFormatters = new List<DecimalFormatter>();
			}
			decimalFormatters.Add(CreateDecimalFormatter(formatPicture, infinitySymbol, nanSymbol, characters));
			return decimalFormatters.Count - 1;
		}

		public string FormatNumberStatic(double value, double decimalFormatterIndex)
		{
			int index = (int)decimalFormatterIndex;
			return decimalFormatters[index].Format(value);
		}

		public string FormatNumberDynamic(double value, string formatPicture, XmlQualifiedName decimalFormatName, string errorMessageName)
		{
			DecimalFormatDecl decimalFormatDecl;
			if (decimalFormats != null && decimalFormats.Contains(decimalFormatName))
			{
				decimalFormatDecl = decimalFormats[decimalFormatName];
			}
			else
			{
				if (decimalFormatName != DecimalFormatDecl.Default.Name)
				{
					throw new XslTransformException("Xslt_NoDecimalFormat", errorMessageName);
				}
				decimalFormatDecl = DecimalFormatDecl.Default;
			}
			DecimalFormatter decimalFormatter = CreateDecimalFormatter(formatPicture, decimalFormatDecl.InfinitySymbol, decimalFormatDecl.NanSymbol, new string(decimalFormatDecl.Characters));
			return decimalFormatter.Format(value);
		}

		public string NumberFormat(IList<XPathItem> value, string formatString, double lang, string letterValue, string groupingSeparator, double groupingSize)
		{
			NumberFormatter numberFormatter = new NumberFormatter(formatString, (int)lang, letterValue, groupingSeparator, (int)groupingSize);
			return numberFormatter.FormatSequence(value);
		}

		public int LangToLcid(string lang, bool forwardCompatibility)
		{
			return LangToLcidInternal(lang, forwardCompatibility, null);
		}

		internal static int LangToLcidInternal(string lang, bool forwardCompatibility, IErrorHelper errorHelper)
		{
			int result = 127;
			if (lang != null)
			{
				if (lang.Length != 0)
				{
					try
					{
						result = new CultureInfo(lang).LCID;
						return result;
					}
					catch (ArgumentException)
					{
						if (!forwardCompatibility)
						{
							if (errorHelper != null)
							{
								errorHelper.ReportError("Xslt_InvalidLanguage", lang);
								return result;
							}
							throw new XslTransformException("Xslt_InvalidLanguage", lang);
						}
						return result;
					}
				}
				if (!forwardCompatibility)
				{
					if (errorHelper == null)
					{
						throw new XslTransformException("Xslt_InvalidAttrValue", "lang", lang);
					}
					errorHelper.ReportError("Xslt_InvalidAttrValue", "lang", lang);
				}
			}
			return result;
		}

		private static TypeCode GetTypeCode(XPathItem item)
		{
			Type valueType = item.ValueType;
			if (valueType == XsltConvert.StringType)
			{
				return TypeCode.String;
			}
			if (valueType == XsltConvert.DoubleType)
			{
				return TypeCode.Double;
			}
			return TypeCode.Boolean;
		}

		private static TypeCode WeakestTypeCode(TypeCode typeCode1, TypeCode typeCode2)
		{
			if (typeCode1 >= typeCode2)
			{
				return typeCode2;
			}
			return typeCode1;
		}

		private static bool CompareNumbers(ComparisonOperator op, double left, double right)
		{
			return op switch
			{
				ComparisonOperator.Eq => left == right, 
				ComparisonOperator.Ne => left != right, 
				ComparisonOperator.Lt => left < right, 
				ComparisonOperator.Le => left <= right, 
				ComparisonOperator.Gt => left > right, 
				_ => left >= right, 
			};
		}

		private static bool CompareValues(ComparisonOperator op, XPathItem left, XPathItem right, TypeCode compType)
		{
			return compType switch
			{
				TypeCode.Double => CompareNumbers(op, XsltConvert.ToDouble(left), XsltConvert.ToDouble(right)), 
				TypeCode.String => XsltConvert.ToString(left) == XsltConvert.ToString(right) == (op == ComparisonOperator.Eq), 
				_ => XsltConvert.ToBoolean(left) == XsltConvert.ToBoolean(right) == (op == ComparisonOperator.Eq), 
			};
		}

		private static bool CompareNodeSetAndValue(ComparisonOperator op, IList<XPathNavigator> nodeset, XPathItem val, TypeCode compType)
		{
			if (compType == TypeCode.Boolean)
			{
				return CompareNumbers(op, (nodeset.Count != 0) ? 1 : 0, XsltConvert.ToBoolean(val) ? 1 : 0);
			}
			int count = nodeset.Count;
			for (int i = 0; i < count; i++)
			{
				if (CompareValues(op, nodeset[i], val, compType))
				{
					return true;
				}
			}
			return false;
		}

		private static bool CompareNodeSetAndNodeSet(ComparisonOperator op, IList<XPathNavigator> left, IList<XPathNavigator> right, TypeCode compType)
		{
			int count = left.Count;
			int count2 = right.Count;
			for (int i = 0; i < count; i++)
			{
				for (int j = 0; j < count2; j++)
				{
					if (CompareValues(op, left[i], right[j], compType))
					{
						return true;
					}
				}
			}
			return false;
		}

		public bool EqualityOperator(double opCode, IList<XPathItem> left, IList<XPathItem> right)
		{
			ComparisonOperator op = (ComparisonOperator)opCode;
			if (IsNodeSetOrRtf(left))
			{
				if (IsNodeSetOrRtf(right))
				{
					return CompareNodeSetAndNodeSet(op, ToNodeSetOrRtf(left), ToNodeSetOrRtf(right), TypeCode.String);
				}
				XPathItem xPathItem = right[0];
				return CompareNodeSetAndValue(op, ToNodeSetOrRtf(left), xPathItem, GetTypeCode(xPathItem));
			}
			if (IsNodeSetOrRtf(right))
			{
				XPathItem xPathItem2 = left[0];
				return CompareNodeSetAndValue(op, ToNodeSetOrRtf(right), xPathItem2, GetTypeCode(xPathItem2));
			}
			XPathItem xPathItem3 = left[0];
			XPathItem xPathItem4 = right[0];
			return CompareValues(op, xPathItem3, xPathItem4, WeakestTypeCode(GetTypeCode(xPathItem3), GetTypeCode(xPathItem4)));
		}

		private static ComparisonOperator InvertOperator(ComparisonOperator op)
		{
			return op switch
			{
				ComparisonOperator.Lt => ComparisonOperator.Gt, 
				ComparisonOperator.Le => ComparisonOperator.Ge, 
				ComparisonOperator.Gt => ComparisonOperator.Lt, 
				ComparisonOperator.Ge => ComparisonOperator.Le, 
				_ => op, 
			};
		}

		public bool RelationalOperator(double opCode, IList<XPathItem> left, IList<XPathItem> right)
		{
			ComparisonOperator op = (ComparisonOperator)opCode;
			if (IsNodeSetOrRtf(left))
			{
				if (IsNodeSetOrRtf(right))
				{
					return CompareNodeSetAndNodeSet(op, ToNodeSetOrRtf(left), ToNodeSetOrRtf(right), TypeCode.Double);
				}
				XPathItem xPathItem = right[0];
				return CompareNodeSetAndValue(op, ToNodeSetOrRtf(left), xPathItem, WeakestTypeCode(GetTypeCode(xPathItem), TypeCode.Double));
			}
			if (IsNodeSetOrRtf(right))
			{
				XPathItem xPathItem2 = left[0];
				op = InvertOperator(op);
				return CompareNodeSetAndValue(op, ToNodeSetOrRtf(right), xPathItem2, WeakestTypeCode(GetTypeCode(xPathItem2), TypeCode.Double));
			}
			XPathItem left2 = left[0];
			XPathItem right2 = right[0];
			return CompareValues(op, left2, right2, TypeCode.Double);
		}

		public bool IsSameNodeSort(XPathNavigator nav1, XPathNavigator nav2)
		{
			XPathNodeType nodeType = nav1.NodeType;
			XPathNodeType nodeType2 = nav2.NodeType;
			if (XPathNodeType.Text <= nodeType && nodeType <= XPathNodeType.Whitespace)
			{
				if (XPathNodeType.Text <= nodeType2)
				{
					return nodeType2 <= XPathNodeType.Whitespace;
				}
				return false;
			}
			if (nodeType == nodeType2 && Ref.Equal(nav1.LocalName, nav2.LocalName))
			{
				return Ref.Equal(nav1.NamespaceURI, nav2.NamespaceURI);
			}
			return false;
		}

		[Conditional("DEBUG")]
		internal static void CheckXsltValue(XPathItem item)
		{
		}

		[Conditional("DEBUG")]
		internal static void CheckXsltValue(IList<XPathItem> val)
		{
			if (val.Count == 1)
			{
				XsltFunctions.EXslObjectType(val);
				return;
			}
			int count = val.Count;
			for (int i = 0; i < count && val[i].IsNode; i++)
			{
				if (i == 1)
				{
					i += Math.Max(count - 4, 0);
				}
			}
		}

		private static bool IsNodeSetOrRtf(IList<XPathItem> val)
		{
			if (val.Count == 1)
			{
				return val[0].IsNode;
			}
			return true;
		}

		private static IList<XPathNavigator> ToNodeSetOrRtf(IList<XPathItem> val)
		{
			return XmlILStorageConverter.ItemsToNavigators(val);
		}
	}
}
namespace System.Xml.Xsl.XPath
{
	internal interface IXPathBuilder<Node>
	{
		void StartBuild();

		Node EndBuild(Node result);

		Node String(string value);

		Node Number(double value);

		Node Operator(XPathOperator op, Node left, Node right);

		Node Axis(XPathAxis xpathAxis, XPathNodeType nodeType, string prefix, string name);

		Node JoinStep(Node left, Node right);

		Node Predicate(Node node, Node condition, bool reverseStep);

		Node Variable(string prefix, string name);

		Node Function(string prefix, string name, IList<Node> args);
	}
	internal interface IFocus
	{
		QilNode GetCurrent();

		QilNode GetPosition();

		QilNode GetLast();
	}
	internal interface IXPathEnvironment : IFocus
	{
		XPathQilFactory Factory { get; }

		QilNode ResolveVariable(string prefix, string name);

		QilNode ResolveFunction(string prefix, string name, IList<QilNode> args, IFocus env);

		string ResolvePrefix(string prefix);
	}
	internal enum XPathAxis
	{
		Unknown,
		Ancestor,
		AncestorOrSelf,
		Attribute,
		Child,
		Descendant,
		DescendantOrSelf,
		Following,
		FollowingSibling,
		Namespace,
		Parent,
		Preceding,
		PrecedingSibling,
		Self,
		Root
	}
	internal class XPathBuilder : IXPathBuilder<QilNode>, IXPathEnvironment, IFocus
	{
		private enum XPathOperatorGroup
		{
			Unknown,
			Logical,
			Equality,
			Relational,
			Arithmetic,
			Negate,
			Union
		}

		internal enum FuncId
		{
			Last,
			Position,
			Count,
			LocalName,
			NamespaceUri,
			Name,
			String,
			Number,
			Boolean,
			True,
			False,
			Not,
			Id,
			Concat,
			StartsWith,
			Contains,
			SubstringBefore,
			SubstringAfter,
			Substring,
			StringLength,
			Normalize,
			Translate,
			Lang,
			Sum,
			Floor,
			Ceiling,
			Round
		}

		private class FixupVisitor : QilReplaceVisitor
		{
			private new QilPatternFactory f;

			private QilNode fixupCurrent;

			private QilNode fixupPosition;

			private QilNode fixupLast;

			private QilIterator current;

			private QilNode last;

			private bool justCount;

			private IXPathEnvironment environment;

			public int numCurrent;

			public int numPosition;

			public int numLast;

			public FixupVisitor(QilPatternFactory f, QilNode fixupCurrent, QilNode fixupPosition, QilNode fixupLast)
				: base(f.BaseFactory)
			{
				this.f = f;
				this.fixupCurrent = fixupCurrent;
				this.fixupPosition = fixupPosition;
				this.fixupLast = fixupLast;
			}

			public QilNode Fixup(QilNode inExpr, QilIterator current, QilNode last)
			{
				QilDepthChecker.Check(inExpr);
				this.current = current;
				this.last = last;
				justCount = false;
				environment = null;
				numCurrent = (numPosition = (numLast = 0));
				inExpr = VisitAssumeReference(inExpr);
				return inExpr;
			}

			public QilNode Fixup(QilNode inExpr, IXPathEnvironment environment)
			{
				QilDepthChecker.Check(inExpr);
				justCount = false;
				current = null;
				this.environment = environment;
				numCurrent = (numPosition = (numLast = 0));
				inExpr = VisitAssumeReference(inExpr);
				return inExpr;
			}

			public int CountUnfixedLast(QilNode inExpr)
			{
				justCount = true;
				numCurrent = (numPosition = (numLast = 0));
				VisitAssumeReference(inExpr);
				return numLast;
			}

			protected override QilNode VisitUnknown(QilNode unknown)
			{
				if (unknown == fixupCurrent)
				{
					numCurrent++;
					if (!justCount)
					{
						if (environment != null)
						{
							unknown = environment.GetCurrent();
						}
						else if (current != null)
						{
							unknown = current;
						}
					}
				}
				else if (unknown == fixupPosition)
				{
					numPosition++;
					if (!justCount)
					{
						if (environment != null)
						{
							unknown = environment.GetPosition();
						}
						else if (current != null)
						{
							unknown = f.XsltConvert(f.PositionOf(current), XmlQueryTypeFactory.DoubleX);
						}
					}
				}
				else if (unknown == fixupLast)
				{
					numLast++;
					if (!justCount)
					{
						if (environment != null)
						{
							unknown = environment.GetLast();
						}
						else if (current != null)
						{
							unknown = last;
						}
					}
				}
				return unknown;
			}
		}

		internal class FunctionInfo<T>
		{
			public const int Infinity = int.MaxValue;

			public T id;

			public int minArgs;

			public int maxArgs;

			public XmlTypeCode[] argTypes;

			public FunctionInfo(T id, int minArgs, int maxArgs, XmlTypeCode[] argTypes)
			{
				this.id = id;
				this.minArgs = minArgs;
				this.maxArgs = maxArgs;
				this.argTypes = argTypes;
			}

			public static void CheckArity(int minArgs, int maxArgs, string name, int numArgs)
			{
				if (minArgs <= numArgs && numArgs <= maxArgs)
				{
					return;
				}
				string resId = ((minArgs == maxArgs) ? "XPath_NArgsExpected" : ((maxArgs == minArgs + 1) ? "XPath_NOrMArgsExpected" : ((numArgs >= minArgs) ? "XPath_AtMostMArgsExpected" : "XPath_AtLeastNArgsExpected")));
				throw new XPathCompileException(resId, name, minArgs.ToString(CultureInfo.InvariantCulture), maxArgs.ToString(CultureInfo.InvariantCulture));
			}

			public void CastArguments(IList<QilNode> args, string name, XPathQilFactory f)
			{
				CheckArity(minArgs, maxArgs, name, args.Count);
				if (maxArgs == int.MaxValue)
				{
					for (int i = 0; i < args.Count; i++)
					{
						args[i] = f.ConvertToType(XmlTypeCode.String, args[i]);
					}
					return;
				}
				for (int j = 0; j < args.Count; j++)
				{
					if (argTypes[j] == XmlTypeCode.Node && f.CannotBeNodeSet(args[j]))
					{
						throw new XPathCompileException("XPath_NodeSetArgumentExpected", name, (j + 1).ToString(CultureInfo.InvariantCulture));
					}
					args[j] = f.ConvertToType(argTypes[j], args[j]);
				}
			}
		}

		private XPathQilFactory f;

		private IXPathEnvironment environment;

		private bool inTheBuild;

		protected QilNode fixupCurrent;

		protected QilNode fixupPosition;

		protected QilNode fixupLast;

		protected int numFixupCurrent;

		protected int numFixupPosition;

		protected int numFixupLast;

		private FixupVisitor fixupVisitor;

		private static XmlNodeKindFlags[] XPathNodeType2QilXmlNodeKind = new XmlNodeKindFlags[10]
		{
			XmlNodeKindFlags.Document,
			XmlNodeKindFlags.Element,
			XmlNodeKindFlags.Attribute,
			XmlNodeKindFlags.Namespace,
			XmlNodeKindFlags.Text,
			XmlNodeKindFlags.Text,
			XmlNodeKindFlags.Text,
			XmlNodeKindFlags.PI,
			XmlNodeKindFlags.Comment,
			XmlNodeKindFlags.Any
		};

		private static XPathOperatorGroup[] OperatorGroup = new XPathOperatorGroup[16]
		{
			XPathOperatorGroup.Unknown,
			XPathOperatorGroup.Logical,
			XPathOperatorGroup.Logical,
			XPathOperatorGroup.Equality,
			XPathOperatorGroup.Equality,
			XPathOperatorGroup.Relational,
			XPathOperatorGroup.Relational,
			XPathOperatorGroup.Relational,
			XPathOperatorGroup.Relational,
			XPathOperatorGroup.Arithmetic,
			XPathOperatorGroup.Arithmetic,
			XPathOperatorGroup.Arithmetic,
			XPathOperatorGroup.Arithmetic,
			XPathOperatorGroup.Arithmetic,
			XPathOperatorGroup.Negate,
			XPathOperatorGroup.Union
		};

		private static QilNodeType[] QilOperator = new QilNodeType[16]
		{
			QilNodeType.Unknown,
			QilNodeType.Or,
			QilNodeType.And,
			QilNodeType.Eq,
			QilNodeType.Ne,
			QilNodeType.Lt,
			QilNodeType.Le,
			QilNodeType.Gt,
			QilNodeType.Ge,
			QilNodeType.Add,
			QilNodeType.Subtract,
			QilNodeType.Multiply,
			QilNodeType.Divide,
			QilNodeType.Modulo,
			QilNodeType.Negate,
			QilNodeType.Sequence
		};

		private static XmlNodeKindFlags[] XPathAxisMask = new XmlNodeKindFlags[15]
		{
			XmlNodeKindFlags.None,
			XmlNodeKindFlags.Document | XmlNodeKindFlags.Element,
			XmlNodeKindFlags.Any,
			XmlNodeKindFlags.Attribute,
			XmlNodeKindFlags.Content,
			XmlNodeKindFlags.Content,
			XmlNodeKindFlags.Any,
			XmlNodeKindFlags.Content,
			XmlNodeKindFlags.Content,
			XmlNodeKindFlags.Namespace,
			XmlNodeKindFlags.Document | XmlNodeKindFlags.Element,
			XmlNodeKindFlags.Content,
			XmlNodeKindFlags.Content,
			XmlNodeKindFlags.Any,
			XmlNodeKindFlags.Document
		};

		public static readonly XmlTypeCode[] argAny = new XmlTypeCode[1] { XmlTypeCode.Item };

		public static readonly XmlTypeCode[] argNodeSet = new XmlTypeCode[1] { XmlTypeCode.Node };

		public static readonly XmlTypeCode[] argBoolean = new XmlTypeCode[1] { XmlTypeCode.Boolean };

		public static readonly XmlTypeCode[] argDouble = new XmlTypeCode[1] { XmlTypeCode.Double };

		public static readonly XmlTypeCode[] argString = new XmlTypeCode[1] { XmlTypeCode.String };

		public static readonly XmlTypeCode[] argString2 = new XmlTypeCode[2]
		{
			XmlTypeCode.String,
			XmlTypeCode.String
		};

		public static readonly XmlTypeCode[] argString3 = new XmlTypeCode[3]
		{
			XmlTypeCode.String,
			XmlTypeCode.String,
			XmlTypeCode.String
		};

		public static readonly XmlTypeCode[] argFnSubstr = new XmlTypeCode[3]
		{
			XmlTypeCode.String,
			XmlTypeCode.Double,
			XmlTypeCode.Double
		};

		public static Dictionary<string, FunctionInfo<FuncId>> FunctionTable = CreateFunctionTable();

		XPathQilFactory IXPathEnvironment.Factory => f;

		QilNode IFocus.GetCurrent()
		{
			return GetCurrentNode();
		}

		QilNode IFocus.GetPosition()
		{
			return GetCurrentPosition();
		}

		QilNode IFocus.GetLast()
		{
			return GetLastPosition();
		}

		QilNode IXPathEnvironment.ResolveVariable(string prefix, string name)
		{
			return Variable(prefix, name);
		}

		QilNode IXPathEnvironment.ResolveFunction(string prefix, string name, IList<QilNode> args, IFocus env)
		{
			return null;
		}

		string IXPathEnvironment.ResolvePrefix(string prefix)
		{
			return environment.ResolvePrefix(prefix);
		}

		public XPathBuilder(IXPathEnvironment environment)
		{
			this.environment = environment;
			f = this.environment.Factory;
			fixupCurrent = f.Unknown(XmlQueryTypeFactory.NodeNotRtf);
			fixupPosition = f.Unknown(XmlQueryTypeFactory.DoubleX);
			fixupLast = f.Unknown(XmlQueryTypeFactory.DoubleX);
			fixupVisitor = new FixupVisitor(f, fixupCurrent, fixupPosition, fixupLast);
		}

		public virtual void StartBuild()
		{
			inTheBuild = true;
			numFixupCurrent = (numFixupPosition = (numFixupLast = 0));
		}

		public virtual QilNode EndBuild(QilNode result)
		{
			if (result == null)
			{
				inTheBuild = false;
				return result;
			}
			if (result.XmlType.MaybeMany && result.XmlType.IsNode && result.XmlType.IsNotRtf)
			{
				result = f.DocOrderDistinct(result);
			}
			result = fixupVisitor.Fixup(result, environment);
			numFixupCurrent -= fixupVisitor.numCurrent;
			numFixupPosition -= fixupVisitor.numPosition;
			numFixupLast -= fixupVisitor.numLast;
			inTheBuild = false;
			return result;
		}

		private QilNode GetCurrentNode()
		{
			numFixupCurrent++;
			return fixupCurrent;
		}

		private QilNode GetCurrentPosition()
		{
			numFixupPosition++;
			return fixupPosition;
		}

		private QilNode GetLastPosition()
		{
			numFixupLast++;
			return fixupLast;
		}

		public virtual QilNode String(string value)
		{
			return f.String(value);
		}

		public virtual QilNode Number(double value)
		{
			return f.Double(value);
		}

		public virtual QilNode Operator(XPathOperator op, QilNode left, QilNode right)
		{
			return OperatorGroup[(int)op] switch
			{
				XPathOperatorGroup.Logical => LogicalOperator(op, left, right), 
				XPathOperatorGroup.Equality => EqualityOperator(op, left, right), 
				XPathOperatorGroup.Relational => RelationalOperator(op, left, right), 
				XPathOperatorGroup.Arithmetic => ArithmeticOperator(op, left, right), 
				XPathOperatorGroup.Negate => NegateOperator(op, left, right), 
				XPathOperatorGroup.Union => UnionOperator(op, left, right), 
				_ => null, 
			};
		}

		private QilNode LogicalOperator(XPathOperator op, QilNode left, QilNode right)
		{
			left = f.ConvertToBoolean(left);
			right = f.ConvertToBoolean(right);
			if (op != XPathOperator.Or)
			{
				return f.And(left, right);
			}
			return f.Or(left, right);
		}

		private QilNode CompareValues(XPathOperator op, QilNode left, QilNode right, XmlTypeCode compType)
		{
			left = f.ConvertToType(compType, left);
			right = f.ConvertToType(compType, right);
			return op switch
			{
				XPathOperator.Eq => f.Eq(left, right), 
				XPathOperator.Ne => f.Ne(left, right), 
				XPathOperator.Lt => f.Lt(left, right), 
				XPathOperator.Le => f.Le(left, right), 
				XPathOperator.Gt => f.Gt(left, right), 
				XPathOperator.Ge => f.Ge(left, right), 
				_ => null, 
			};
		}

		private QilNode CompareNodeSetAndValue(XPathOperator op, QilNode nodeset, QilNode val, XmlTypeCode compType)
		{
			if (compType == XmlTypeCode.Boolean || nodeset.XmlType.IsSingleton)
			{
				return CompareValues(op, nodeset, val, compType);
			}
			QilIterator qilIterator = f.For(nodeset);
			return f.Not(f.IsEmpty(f.Filter(qilIterator, CompareValues(op, f.XPathNodeValue(qilIterator), val, compType))));
		}

		private static XPathOperator InvertOp(XPathOperator op)
		{
			return op switch
			{
				XPathOperator.Ge => XPathOperator.Le, 
				XPathOperator.Gt => XPathOperator.Lt, 
				XPathOperator.Le => XPathOperator.Ge, 
				XPathOperator.Lt => XPathOperator.Gt, 
				_ => op, 
			};
		}

		private QilNode CompareNodeSetAndNodeSet(XPathOperator op, QilNode left, QilNode right, XmlTypeCode compType)
		{
			if (right.XmlType.IsSingleton)
			{
				return CompareNodeSetAndValue(op, left, right, compType);
			}
			if (left.XmlType.IsSingleton)
			{
				op = InvertOp(op);
				return CompareNodeSetAndValue(op, right, left, compType);
			}
			QilIterator qilIterator = f.For(left);
			QilIterator qilIterator2 = f.For(right);
			return f.Not(f.IsEmpty(f.Loop(qilIterator, f.Filter(qilIterator2, CompareValues(op, f.XPathNodeValue(qilIterator), f.XPathNodeValue(qilIterator2), compType)))));
		}

		private QilNode EqualityOperator(XPathOperator op, QilNode left, QilNode right)
		{
			XmlQueryType xmlType = left.XmlType;
			XmlQueryType xmlType2 = right.XmlType;
			if (f.IsAnyType(left) || f.IsAnyType(right))
			{
				return f.InvokeEqualityOperator(QilOperator[(int)op], left, right);
			}
			if (xmlType.IsNode && xmlType2.IsNode)
			{
				return CompareNodeSetAndNodeSet(op, left, right, XmlTypeCode.String);
			}
			if (xmlType.IsNode)
			{
				return CompareNodeSetAndValue(op, left, right, xmlType2.TypeCode);
			}
			if (xmlType2.IsNode)
			{
				return CompareNodeSetAndValue(op, right, left, xmlType.TypeCode);
			}
			XmlTypeCode compType = ((xmlType.TypeCode == XmlTypeCode.Boolean || xmlType2.TypeCode == XmlTypeCode.Boolean) ? XmlTypeCode.Boolean : ((xmlType.TypeCode == XmlTypeCode.Double || xmlType2.TypeCode == XmlTypeCode.Double) ? XmlTypeCode.Double : XmlTypeCode.String));
			return CompareValues(op, left, right, compType);
		}

		private QilNode RelationalOperator(XPathOperator op, QilNode left, QilNode right)
		{
			XmlQueryType xmlType = left.XmlType;
			XmlQueryType xmlType2 = right.XmlType;
			if (f.IsAnyType(left) || f.IsAnyType(right))
			{
				return f.InvokeRelationalOperator(QilOperator[(int)op], left, right);
			}
			if (xmlType.IsNode && xmlType2.IsNode)
			{
				return CompareNodeSetAndNodeSet(op, left, right, XmlTypeCode.Double);
			}
			if (xmlType.IsNode)
			{
				XmlTypeCode compType = ((xmlType2.TypeCode == XmlTypeCode.Boolean) ? XmlTypeCode.Boolean : XmlTypeCode.Double);
				return CompareNodeSetAndValue(op, left, right, compType);
			}
			if (xmlType2.IsNode)
			{
				XmlTypeCode compType2 = ((xmlType.TypeCode == XmlTypeCode.Boolean) ? XmlTypeCode.Boolean : XmlTypeCode.Double);
				op = InvertOp(op);
				return CompareNodeSetAndValue(op, right, left, compType2);
			}
			return CompareValues(op, left, right, XmlTypeCode.Double);
		}

		private QilNode NegateOperator(XPathOperator op, QilNode left, QilNode right)
		{
			return f.Negate(f.ConvertToNumber(left));
		}

		private QilNode ArithmeticOperator(XPathOperator op, QilNode left, QilNode right)
		{
			left = f.ConvertToNumber(left);
			right = f.ConvertToNumber(right);
			return op switch
			{
				XPathOperator.Plus => f.Add(left, right), 
				XPathOperator.Minus => f.Subtract(left, right), 
				XPathOperator.Multiply => f.Multiply(left, right), 
				XPathOperator.Divide => f.Divide(left, right), 
				XPathOperator.Modulo => f.Modulo(left, right), 
				_ => null, 
			};
		}

		private QilNode UnionOperator(XPathOperator op, QilNode left, QilNode right)
		{
			if (left == null)
			{
				return f.EnsureNodeSet(right);
			}
			left = f.EnsureNodeSet(left);
			right = f.EnsureNodeSet(right);
			if (left.NodeType == QilNodeType.Sequence)
			{
				((QilList)left).Add(right);
				return left;
			}
			return f.Union(left, right);
		}

		public static XmlNodeKindFlags AxisTypeMask(XmlNodeKindFlags inputTypeMask, XPathNodeType nodeType, XPathAxis xpathAxis)
		{
			return inputTypeMask & XPathNodeType2QilXmlNodeKind[(int)nodeType] & XPathAxisMask[(int)xpathAxis];
		}

		private QilNode BuildAxisFilter(QilNode qilAxis, XPathAxis xpathAxis, XPathNodeType nodeType, string name, string nsUri)
		{
			XmlNodeKindFlags nodeKinds = qilAxis.XmlType.NodeKinds;
			XmlNodeKindFlags xmlNodeKindFlags = AxisTypeMask(nodeKinds, nodeType, xpathAxis);
			if (xmlNodeKindFlags == XmlNodeKindFlags.None)
			{
				return f.Sequence();
			}
			QilIterator expr;
			if (xmlNodeKindFlags != nodeKinds)
			{
				qilAxis = f.Filter(expr = f.For(qilAxis), f.IsType(expr, XmlQueryTypeFactory.NodeChoice(xmlNodeKindFlags)));
				qilAxis.XmlType = XmlQueryTypeFactory.PrimeProduct(XmlQueryTypeFactory.NodeChoice(xmlNodeKindFlags), qilAxis.XmlType.Cardinality);
				if (qilAxis.NodeType == QilNodeType.Filter)
				{
					QilLoop qilLoop = (QilLoop)qilAxis;
					qilLoop.Body = f.And(qilLoop.Body, (name != null && nsUri != null) ? f.Eq(f.NameOf(expr), f.QName(name, nsUri)) : ((nsUri != null) ? f.Eq(f.NamespaceUriOf(expr), f.String(nsUri)) : ((name != null) ? f.Eq(f.LocalNameOf(expr), f.String(name)) : f.True())));
					return qilLoop;
				}
			}
			return f.Filter(expr = f.For(qilAxis), (name != null && nsUri != null) ? f.Eq(f.NameOf(expr), f.QName(name, nsUri)) : ((nsUri != null) ? f.Eq(f.NamespaceUriOf(expr), f.String(nsUri)) : ((name != null) ? f.Eq(f.LocalNameOf(expr), f.String(name)) : f.True())));
		}

		private QilNode BuildAxis(XPathAxis xpathAxis, XPathNodeType nodeType, string nsUri, string name)
		{
			QilNode currentNode = GetCurrentNode();
			QilNode qilAxis;
			switch (xpathAxis)
			{
			case XPathAxis.Ancestor:
				qilAxis = f.Ancestor(currentNode);
				break;
			case XPathAxis.AncestorOrSelf:
				qilAxis = f.AncestorOrSelf(currentNode);
				break;
			case XPathAxis.Attribute:
				qilAxis = f.Content(currentNode);
				break;
			case XPathAxis.Child:
				qilAxis = f.Content(currentNode);
				break;
			case XPathAxis.Descendant:
				qilAxis = f.Descendant(currentNode);
				break;
			case XPathAxis.DescendantOrSelf:
				qilAxis = f.DescendantOrSelf(currentNode);
				break;
			case XPathAxis.Following:
				qilAxis = f.XPathFollowing(currentNode);
				break;
			case XPathAxis.FollowingSibling:
				qilAxis = f.FollowingSibling(currentNode);
				break;
			case XPathAxis.Namespace:
				qilAxis = f.XPathNamespace(currentNode);
				break;
			case XPathAxis.Parent:
				qilAxis = f.Parent(currentNode);
				break;
			case XPathAxis.Preceding:
				qilAxis = f.XPathPreceding(currentNode);
				break;
			case XPathAxis.PrecedingSibling:
				qilAxis = f.PrecedingSibling(currentNode);
				break;
			case XPathAxis.Self:
				qilAxis = currentNode;
				break;
			case XPathAxis.Root:
				return f.Root(currentNode);
			default:
				qilAxis = null;
				break;
			}
			QilNode qilNode = BuildAxisFilter(qilAxis, xpathAxis, nodeType, name, nsUri);
			if (xpathAxis == XPathAxis.Ancestor || xpathAxis == XPathAxis.Preceding || xpathAxis == XPathAxis.AncestorOrSelf || xpathAxis == XPathAxis.PrecedingSibling)
			{
				qilNode = f.BaseFactory.DocOrderDistinct(qilNode);
			}
			return qilNode;
		}

		public virtual QilNode Axis(XPathAxis xpathAxis, XPathNodeType nodeType, string prefix, string name)
		{
			string nsUri = ((prefix == null) ? null : environment.ResolvePrefix(prefix));
			return BuildAxis(xpathAxis, nodeType, nsUri, name);
		}

		public virtual QilNode JoinStep(QilNode left, QilNode right)
		{
			QilIterator qilIterator = f.For(f.EnsureNodeSet(left));
			right = fixupVisitor.Fixup(right, qilIterator, null);
			numFixupCurrent -= fixupVisitor.numCurrent;
			numFixupPosition -= fixupVisitor.numPosition;
			numFixupLast -= fixupVisitor.numLast;
			return f.DocOrderDistinct(f.Loop(qilIterator, right));
		}

		public virtual QilNode Predicate(QilNode nodeset, QilNode predicate, bool isReverseStep)
		{
			if (isReverseStep)
			{
				nodeset = ((QilUnary)nodeset).Child;
			}
			nodeset = f.EnsureNodeSet(nodeset);
			QilIterator qilIterator;
			predicate = (f.IsAnyType(predicate) ? f.Loop(qilIterator = f.Let(predicate), f.Conditional(f.IsType(qilIterator, XmlQueryTypeFactory.Double), f.Eq(GetCurrentPosition(), f.TypeAssert(qilIterator, XmlQueryTypeFactory.DoubleX)), f.ConvertToBoolean(qilIterator))) : ((predicate.XmlType.TypeCode != XmlTypeCode.Double) ? f.ConvertToBoolean(predicate) : f.Eq(GetCurrentPosition(), predicate)));
			QilNode qilNode;
			if (numFixupLast != 0 && fixupVisitor.CountUnfixedLast(predicate) != 0)
			{
				QilIterator qilIterator2 = f.Let(nodeset);
				QilIterator qilIterator3 = f.Let(f.XsltConvert(f.Length(qilIterator2), XmlQueryTypeFactory.DoubleX));
				QilIterator qilIterator4 = f.For(qilIterator2);
				predicate = fixupVisitor.Fixup(predicate, qilIterator4, qilIterator3);
				numFixupCurrent -= fixupVisitor.numCurrent;
				numFixupPosition -= fixupVisitor.numPosition;
				numFixupLast -= fixupVisitor.numLast;
				qilNode = f.Loop(qilIterator2, f.Loop(qilIterator3, f.Filter(qilIterator4, predicate)));
			}
			else
			{
				QilIterator qilIterator5 = f.For(nodeset);
				predicate = fixupVisitor.Fixup(predicate, qilIterator5, null);
				numFixupCurrent -= fixupVisitor.numCurrent;
				numFixupPosition -= fixupVisitor.numPosition;
				numFixupLast -= fixupVisitor.numLast;
				qilNode = f.Filter(qilIterator5, predicate);
			}
			if (isReverseStep)
			{
				qilNode = f.DocOrderDistinct(qilNode);
			}
			return qilNode;
		}

		public virtual QilNode Variable(string prefix, string name)
		{
			return environment.ResolveVariable(prefix, name);
		}

		public virtual QilNode Function(string prefix, string name, IList<QilNode> args)
		{
			if (prefix.Length == 0 && FunctionTable.TryGetValue(name, out var value))
			{
				value.CastArguments(args, name, f);
				switch (value.id)
				{
				case FuncId.Not:
					return f.Not(args[0]);
				case FuncId.Last:
					return GetLastPosition();
				case FuncId.Position:
					return GetCurrentPosition();
				case FuncId.Count:
					return f.XsltConvert(f.Length(f.DocOrderDistinct(args[0])), XmlQueryTypeFactory.DoubleX);
				case FuncId.LocalName:
					if (args.Count != 0)
					{
						return LocalNameOfFirstNode(args[0]);
					}
					return f.LocalNameOf(GetCurrentNode());
				case FuncId.NamespaceUri:
					if (args.Count != 0)
					{
						return NamespaceOfFirstNode(args[0]);
					}
					return f.NamespaceUriOf(GetCurrentNode());
				case FuncId.Name:
					if (args.Count != 0)
					{
						return NameOfFirstNode(args[0]);
					}
					return NameOf(GetCurrentNode());
				case FuncId.String:
					if (args.Count != 0)
					{
						return f.ConvertToString(args[0]);
					}
					return f.XPathNodeValue(GetCurrentNode());
				case FuncId.Number:
					if (args.Count != 0)
					{
						return f.ConvertToNumber(args[0]);
					}
					return f.XsltConvert(f.XPathNodeValue(GetCurrentNode()), XmlQueryTypeFactory.DoubleX);
				case FuncId.Boolean:
					return f.ConvertToBoolean(args[0]);
				case FuncId.True:
					return f.True();
				case FuncId.False:
					return f.False();
				case FuncId.Id:
					return f.DocOrderDistinct(f.Id(GetCurrentNode(), args[0]));
				case FuncId.Concat:
					return f.StrConcat(args);
				case FuncId.StartsWith:
					return f.InvokeStartsWith(args[0], args[1]);
				case FuncId.Contains:
					return f.InvokeContains(args[0], args[1]);
				case FuncId.SubstringBefore:
					return f.InvokeSubstringBefore(args[0], args[1]);
				case FuncId.SubstringAfter:
					return f.InvokeSubstringAfter(args[0], args[1]);
				case FuncId.Substring:
					if (args.Count != 2)
					{
						return f.InvokeSubstring(args[0], args[1], args[2]);
					}
					return f.InvokeSubstring(args[0], args[1]);
				case FuncId.StringLength:
					return f.XsltConvert(f.StrLength((args.Count == 0) ? f.XPathNodeValue(GetCurrentNode()) : args[0]), XmlQueryTypeFactory.DoubleX);
				case FuncId.Normalize:
					return f.InvokeNormalizeSpace((args.Count == 0) ? f.XPathNodeValue(GetCurrentNode()) : args[0]);
				case FuncId.Translate:
					return f.InvokeTranslate(args[0], args[1], args[2]);
				case FuncId.Lang:
					return f.InvokeLang(args[0], GetCurrentNode());
				case FuncId.Sum:
					return Sum(f.DocOrderDistinct(args[0]));
				case FuncId.Floor:
					return f.InvokeFloor(args[0]);
				case FuncId.Ceiling:
					return f.InvokeCeiling(args[0]);
				case FuncId.Round:
					return f.InvokeRound(args[0]);
				default:
					return null;
				}
			}
			return environment.ResolveFunction(prefix, name, args, this);
		}

		private QilNode LocalNameOfFirstNode(QilNode arg)
		{
			if (arg.XmlType.IsSingleton)
			{
				return f.LocalNameOf(arg);
			}
			QilIterator expr;
			return f.StrConcat(f.Loop(expr = f.FirstNode(arg), f.LocalNameOf(expr)));
		}

		private QilNode NamespaceOfFirstNode(QilNode arg)
		{
			if (arg.XmlType.IsSingleton)
			{
				return f.NamespaceUriOf(arg);
			}
			QilIterator expr;
			return f.StrConcat(f.Loop(expr = f.FirstNode(arg), f.NamespaceUriOf(expr)));
		}

		private QilNode NameOf(QilNode arg)
		{
			QilIterator qilIterator;
			QilIterator qilIterator2;
			if (arg is QilIterator)
			{
				return f.Loop(qilIterator = f.Let(f.PrefixOf(arg)), f.Loop(qilIterator2 = f.Let(f.LocalNameOf(arg)), f.Conditional(f.Eq(f.StrLength(qilIterator), f.Int32(0)), qilIterator2, f.StrConcat(qilIterator, f.String(":"), qilIterator2))));
			}
			QilIterator qilIterator3 = f.Let(arg);
			return f.Loop(qilIterator3, NameOf(qilIterator3));
		}

		private QilNode NameOfFirstNode(QilNode arg)
		{
			if (arg.XmlType.IsSingleton)
			{
				return NameOf(arg);
			}
			QilIterator arg2;
			return f.StrConcat(f.Loop(arg2 = f.FirstNode(arg), NameOf(arg2)));
		}

		private QilNode Sum(QilNode arg)
		{
			QilIterator n;
			return f.Sum(f.Sequence(f.Double(0.0), f.Loop(n = f.For(arg), f.ConvertToNumber(n))));
		}

		private static Dictionary<string, FunctionInfo<FuncId>> CreateFunctionTable()
		{
			Dictionary<string, FunctionInfo<FuncId>> dictionary = new Dictionary<string, FunctionInfo<FuncId>>(36);
			dictionary.Add("last", new FunctionInfo<FuncId>(FuncId.Last, 0, 0, null));
			dictionary.Add("position", new FunctionInfo<FuncId>(FuncId.Position, 0, 0, null));
			dictionary.Add("name", new FunctionInfo<FuncId>(FuncId.Name, 0, 1, argNodeSet));
			dictionary.Add("namespace-uri", new FunctionInfo<FuncId>(FuncId.NamespaceUri, 0, 1, argNodeSet));
			dictionary.Add("local-name", new FunctionInfo<FuncId>(FuncId.LocalName, 0, 1, argNodeSet));
			dictionary.Add("count", new FunctionInfo<FuncId>(FuncId.Count, 1, 1, argNodeSet));
			dictionary.Add("id", new FunctionInfo<FuncId>(FuncId.Id, 1, 1, argAny));
			dictionary.Add("string", new FunctionInfo<FuncId>(FuncId.String, 0, 1, argAny));
			dictionary.Add("concat", new FunctionInfo<FuncId>(FuncId.Concat, 2, int.MaxValue, null));
			dictionary.Add("starts-with", new FunctionInfo<FuncId>(FuncId.StartsWith, 2, 2, argString2));
			dictionary.Add("contains", new FunctionInfo<FuncId>(FuncId.Contains, 2, 2, argString2));
			dictionary.Add("substring-before", new FunctionInfo<FuncId>(FuncId.SubstringBefore, 2, 2, argString2));
			dictionary.Add("substring-after", new FunctionInfo<FuncId>(FuncId.SubstringAfter, 2, 2, argString2));
			dictionary.Add("substring", new FunctionInfo<FuncId>(FuncId.Substring, 2, 3, argFnSubstr));
			dictionary.Add("string-length", new FunctionInfo<FuncId>(FuncId.StringLength, 0, 1, argString));
			dictionary.Add("normalize-space", new FunctionInfo<FuncId>(FuncId.Normalize, 0, 1, argString));
			dictionary.Add("translate", new FunctionInfo<FuncId>(FuncId.Translate, 3, 3, argString3));
			dictionary.Add("boolean", new FunctionInfo<FuncId>(FuncId.Boolean, 1, 1, argAny));
			dictionary.Add("not", new FunctionInfo<FuncId>(FuncId.Not, 1, 1, argBoolean));
			dictionary.Add("true", new FunctionInfo<FuncId>(FuncId.True, 0, 0, null));
			dictionary.Add("false", new FunctionInfo<FuncId>(FuncId.False, 0, 0, null));
			dictionary.Add("lang", new FunctionInfo<FuncId>(FuncId.Lang, 1, 1, argString));
			dictionary.Add("number", new FunctionInfo<FuncId>(FuncId.Number, 0, 1, argAny));
			dictionary.Add("sum", new FunctionInfo<FuncId>(FuncId.Sum, 1, 1, argNodeSet));
			dictionary.Add("floor", new FunctionInfo<FuncId>(FuncId.Floor, 1, 1, argDouble));
			dictionary.Add("ceiling", new FunctionInfo<FuncId>(FuncId.Ceiling, 1, 1, argDouble));
			dictionary.Add("round", new FunctionInfo<FuncId>(FuncId.Round, 1, 1, argDouble));
			return dictionary;
		}

		public static bool IsFunctionAvailable(string localName, string nsUri)
		{
			if (nsUri.Length != 0)
			{
				return false;
			}
			return FunctionTable.ContainsKey(localName);
		}
	}
	[Serializable]
	internal class XPathCompileException : XslLoadException
	{
		private enum TrimType
		{
			Left,
			Right,
			Middle
		}

		public string queryString;

		public int startChar;

		public int endChar;

		protected XPathCompileException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
			queryString = (string)info.GetValue("QueryString", typeof(string));
			startChar = (int)info.GetValue("StartChar", typeof(int));
			endChar = (int)info.GetValue("EndChar", typeof(int));
		}

		[SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
		public override void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			base.GetObjectData(info, context);
			info.AddValue("QueryString", queryString);
			info.AddValue("StartChar", startChar);
			info.AddValue("EndChar", endChar);
		}

		internal XPathCompileException(string queryString, int startChar, int endChar, string resId, params string[] args)
			: base(resId, args)
		{
			this.queryString = queryString;
			this.startChar = startChar;
			this.endChar = endChar;
		}

		internal XPathCompileException(string resId, params string[] args)
			: base(resId, args)
		{
		}

		private static void AppendTrimmed(StringBuilder sb, string value, int startIndex, int count, TrimType trimType)
		{
			if (count <= 32)
			{
				sb.Append(value, startIndex, count);
				return;
			}
			switch (trimType)
			{
			case TrimType.Left:
				sb.Append("...");
				sb.Append(value, startIndex + count - 32, 32);
				break;
			case TrimType.Right:
				sb.Append(value, startIndex, 32);
				sb.Append("...");
				break;
			case TrimType.Middle:
				sb.Append(value, startIndex, 16);
				sb.Append("...");
				sb.Append(value, startIndex + count - 16, 16);
				break;
			}
		}

		internal string MarkOutError()
		{
			if (queryString == null || queryString.Trim(' ').Length == 0)
			{
				return null;
			}
			int num = endChar - startChar;
			StringBuilder stringBuilder = new StringBuilder();
			AppendTrimmed(stringBuilder, queryString, 0, startChar, TrimType.Left);
			if (num > 0)
			{
				stringBuilder.Append(" -->");
				AppendTrimmed(stringBuilder, queryString, startChar, num, TrimType.Middle);
			}
			stringBuilder.Append("<-- ");
			AppendTrimmed(stringBuilder, queryString, endChar, queryString.Length - endChar, TrimType.Right);
			return stringBuilder.ToString();
		}

		internal override string FormatDetailedMessage()
		{
			string text = Message;
			string text2 = MarkOutError();
			if (text2 != null && text2.Length > 0)
			{
				if (text.Length > 0)
				{
					text += Environment.NewLine;
				}
				text += text2;
			}
			return text;
		}
	}
	internal enum XPathOperator
	{
		Unknown = 0,
		Or = 1,
		And = 2,
		Eq = 3,
		Ne = 4,
		Lt = 5,
		Le = 6,
		Gt = 7,
		Ge = 8,
		Plus = 9,
		Minus = 10,
		Multiply = 11,
		Divide = 12,
		Modulo = 13,
		UnaryMinus = 14,
		Union = 15,
		LastXPath1Operator = 15,
		UnaryPlus = 16,
		Idiv = 17,
		Is = 18,
		After = 19,
		Before = 20,
		Range = 21,
		Except = 22,
		Intersect = 23,
		ValEq = 24,
		ValNe = 25,
		ValLt = 26,
		ValLe = 27,
		ValGt = 28,
		ValGe = 29
	}
	internal class XPathParser<Node>
	{
		private const int MaxParseRelativePathDepth = 512;

		private const int MaxParseSubExprDepth = 1024;

		private XPathScanner scanner;

		private IXPathBuilder<Node> builder;

		private Stack<int> posInfo = new Stack<int>();

		private int parseRelativePath;

		private int parseSubExprDepth;

		public Node Parse(XPathScanner scanner, IXPathBuilder<Node> builder, LexKind endLex)
		{
			Node result = default(Node);
			this.scanner = scanner;
			this.builder = builder;
			posInfo.Clear();
			try
			{
				builder.StartBuild();
				result = ParseExpr();
				scanner.CheckToken(endLex);
			}
			catch (XPathCompileException ex)
			{
				if (ex.queryString == null)
				{
					ex.queryString = scanner.Source;
					PopPosInfo(out ex.startChar, out ex.endChar);
				}
				throw;
			}
			finally
			{
				result = builder.EndBuild(result);
			}
			return result;
		}

		internal static bool IsStep(LexKind lexKind)
		{
			if (lexKind != LexKind.Dot && lexKind != LexKind.DotDot && lexKind != LexKind.At && lexKind != LexKind.Axis && lexKind != LexKind.Star)
			{
				return lexKind == LexKind.Name;
			}
			return true;
		}

		private Node ParseLocationPath()
		{
			if (scanner.Kind == LexKind.Slash)
			{
				scanner.NextLex();
				Node val = builder.Axis(XPathAxis.Root, XPathNodeType.All, null, null);
				if (IsStep(scanner.Kind))
				{
					val = builder.JoinStep(val, ParseRelativeLocationPath());
				}
				return val;
			}
			if (scanner.Kind == LexKind.SlashSlash)
			{
				scanner.NextLex();
				return builder.JoinStep(builder.Axis(XPathAxis.Root, XPathNodeType.All, null, null), builder.JoinStep(builder.Axis(XPathAxis.DescendantOrSelf, XPathNodeType.All, null, null), ParseRelativeLocationPath()));
			}
			return ParseRelativeLocationPath();
		}

		private Node ParseRelativeLocationPath()
		{
			if (++parseRelativePath > 512 && XsltConfigSection.LimitXPathComplexity)
			{
				throw scanner.CreateException("Xslt_CompileError2");
			}
			Node val = ParseStep();
			if (scanner.Kind == LexKind.Slash)
			{
				scanner.NextLex();
				val = builder.JoinStep(val, ParseRelativeLocationPath());
			}
			else if (scanner.Kind == LexKind.SlashSlash)
			{
				scanner.NextLex();
				val = builder.JoinStep(val, builder.JoinStep(builder.Axis(XPathAxis.DescendantOrSelf, XPathNodeType.All, null, null), ParseRelativeLocationPath()));
			}
			parseRelativePath--;
			return val;
		}

		internal static XPathAxis GetAxis(string axisName, XPathScanner scanner)
		{
			return axisName switch
			{
				"ancestor" => XPathAxis.Ancestor, 
				"ancestor-or-self" => XPathAxis.AncestorOrSelf, 
				"attribute" => XPathAxis.Attribute, 
				"child" => XPathAxis.Child, 
				"descendant" => XPathAxis.Descendant, 
				"descendant-or-self" => XPathAxis.DescendantOrSelf, 
				"following" => XPathAxis.Following, 
				"following-sibling" => XPathAxis.FollowingSibling, 
				"namespace" => XPathAxis.Namespace, 
				"parent" => XPathAxis.Parent, 
				"preceding" => XPathAxis.Preceding, 
				"preceding-sibling" => XPathAxis.PrecedingSibling, 
				"self" => XPathAxis.Self, 
				_ => throw scanner.CreateException("XPath_UnknownAxis", axisName), 
			};
		}

		private Node ParseStep()
		{
			Node val;
			if (LexKind.Dot == scanner.Kind)
			{
				scanner.NextLex();
				val = builder.Axis(XPathAxis.Self, XPathNodeType.All, null, null);
				if (LexKind.LBracket == scanner.Kind)
				{
					throw scanner.CreateException("XPath_PredicateAfterDot");
				}
			}
			else if (LexKind.DotDot == scanner.Kind)
			{
				scanner.NextLex();
				val = builder.Axis(XPathAxis.Parent, XPathNodeType.All, null, null);
				if (LexKind.LBracket == scanner.Kind)
				{
					throw scanner.CreateException("XPath_PredicateAfterDotDot");
				}
			}
			else
			{
				XPathAxis axis;
				switch (scanner.Kind)
				{
				case LexKind.Axis:
					axis = GetAxis(scanner.Name, scanner);
					scanner.NextLex();
					break;
				case LexKind.At:
					axis = XPathAxis.Attribute;
					scanner.NextLex();
					break;
				case LexKind.Star:
				case LexKind.Name:
					axis = XPathAxis.Child;
					break;
				default:
					throw scanner.CreateException("XPath_UnexpectedToken", scanner.RawValue);
				}
				val = ParseNodeTest(axis);
				while (LexKind.LBracket == scanner.Kind)
				{
					val = builder.Predicate(val, ParsePredicate(), IsReverseAxis(axis));
				}
			}
			return val;
		}

		private static bool IsReverseAxis(XPathAxis axis)
		{
			if (axis != XPathAxis.Ancestor && axis != XPathAxis.Preceding && axis != XPathAxis.AncestorOrSelf)
			{
				return axis == XPathAxis.PrecedingSibling;
			}
			return true;
		}

		private Node ParseNodeTest(XPathAxis axis)
		{
			int lexStart = scanner.LexStart;
			InternalParseNodeTest(scanner, axis, out var nodeType, out var nodePrefix, out var nodeName);
			PushPosInfo(lexStart, scanner.PrevLexEnd);
			Node result = builder.Axis(axis, nodeType, nodePrefix, nodeName);
			PopPosInfo();
			return result;
		}

		private static bool IsNodeType(XPathScanner scanner)
		{
			if (scanner.Prefix.Length == 0)
			{
				if (!(scanner.Name == "node") && !(scanner.Name == "text") && !(scanner.Name == "processing-instruction"))
				{
					return scanner.Name == "comment";
				}
				return true;
			}
			return false;
		}

		private static XPathNodeType PrincipalNodeType(XPathAxis axis)
		{
			return axis switch
			{
				XPathAxis.Namespace => XPathNodeType.Namespace, 
				XPathAxis.Attribute => XPathNodeType.Attribute, 
				_ => XPathNodeType.Element, 
			};
		}

		internal static void InternalParseNodeTest(XPathScanner scanner, XPathAxis axis, out XPathNodeType nodeType, out string nodePrefix, out string nodeName)
		{
			switch (scanner.Kind)
			{
			case LexKind.Name:
				if (scanner.CanBeFunction && IsNodeType(scanner))
				{
					nodePrefix = null;
					nodeName = null;
					switch (scanner.Name)
					{
					case "comment":
						nodeType = XPathNodeType.Comment;
						break;
					case "text":
						nodeType = XPathNodeType.Text;
						break;
					case "node":
						nodeType = XPathNodeType.All;
						break;
					default:
						nodeType = XPathNodeType.ProcessingInstruction;
						break;
					}
					scanner.NextLex();
					scanner.PassToken(LexKind.LParens);
					if (nodeType == XPathNodeType.ProcessingInstruction && scanner.Kind != LexKind.RParens)
					{
						scanner.CheckToken(LexKind.String);
						nodePrefix = string.Empty;
						nodeName = scanner.StringValue;
						scanner.NextLex();
					}
					scanner.PassToken(LexKind.RParens);
				}
				else
				{
					nodePrefix = scanner.Prefix;
					nodeName = scanner.Name;
					nodeType = PrincipalNodeType(axis);
					scanner.NextLex();
					if (nodeName == "*")
					{
						nodeName = null;
					}
				}
				break;
			case LexKind.Star:
				nodePrefix = null;
				nodeName = null;
				nodeType = PrincipalNodeType(axis);
				scanner.NextLex();
				break;
			default:
				throw scanner.CreateException("XPath_NodeTestExpected", scanner.RawValue);
			}
		}

		private Node ParsePredicate()
		{
			scanner.PassToken(LexKind.LBracket);
			Node result = ParseExpr();
			scanner.PassToken(LexKind.RBracket);
			return result;
		}

		private Node ParseExpr()
		{
			if (++parseSubExprDepth > 1024 && XsltConfigSection.LimitXPathComplexity)
			{
				throw scanner.CreateException("Xslt_CompileError2");
			}
			Node val = ParseAndExpr();
			while (scanner.IsKeyword("or"))
			{
				scanner.NextLex();
				val = builder.Operator(XPathOperator.Or, val, ParseAndExpr());
			}
			parseSubExprDepth--;
			return val;
		}

		private Node ParseAndExpr()
		{
			Node val = ParseEqualityExpr();
			while (scanner.IsKeyword("and"))
			{
				scanner.NextLex();
				val = builder.Operator(XPathOperator.And, val, ParseEqualityExpr());
			}
			return val;
		}

		private Node ParseEqualityExpr()
		{
			Node val = ParseRelationalExpr();
			bool flag;
			while ((flag = scanner.Kind == LexKind.Eq) || scanner.Kind == LexKind.Ne)
			{
				XPathOperator op = (flag ? XPathOperator.Eq : XPathOperator.Ne);
				scanner.NextLex();
				val = builder.Operator(op, val, ParseRelationalExpr());
			}
			return val;
		}

		private Node ParseRelationalExpr()
		{
			Node val = ParseAdditiveExpr();
			while (true)
			{
				XPathOperator op;
				switch (scanner.Kind)
				{
				case LexKind.Lt:
					op = XPathOperator.Lt;
					break;
				case LexKind.Le:
					op = XPathOperator.Le;
					break;
				case LexKind.Gt:
					op = XPathOperator.Gt;
					break;
				case LexKind.Ge:
					op = XPathOperator.Ge;
					break;
				default:
					return val;
				}
				scanner.NextLex();
				val = builder.Operator(op, val, ParseAdditiveExpr());
			}
		}

		private Node ParseAdditiveExpr()
		{
			Node val = ParseMultiplicativeExpr();
			bool flag;
			while ((flag = scanner.Kind == LexKind.Plus) || scanner.Kind == LexKind.Minus)
			{
				XPathOperator op = (flag ? XPathOperator.Plus : XPathOperator.Minus);
				scanner.NextLex();
				val = builder.Operator(op, val, ParseMultiplicativeExpr());
			}
			return val;
		}

		private Node ParseMultiplicativeExpr()
		{
			Node val = ParseUnaryExpr();
			while (true)
			{
				XPathOperator op;
				if (scanner.Kind == LexKind.Star)
				{
					op = XPathOperator.Multiply;
				}
				else if (scanner.IsKeyword("div"))
				{
					op = XPathOperator.Divide;
				}
				else
				{
					if (!scanner.IsKeyword("mod"))
					{
						break;
					}
					op = XPathOperator.Modulo;
				}
				scanner.NextLex();
				val = builder.Operator(op, val, ParseUnaryExpr());
			}
			return val;
		}

		private Node ParseUnaryExpr()
		{
			if (scanner.Kind == LexKind.Minus)
			{
				scanner.NextLex();
				return builder.Operator(XPathOperator.UnaryMinus, ParseUnaryExpr(), default(Node));
			}
			return ParseUnionExpr();
		}

		private Node ParseUnionExpr()
		{
			int lexStart = scanner.LexStart;
			Node val = ParsePathExpr();
			if (scanner.Kind == LexKind.Union)
			{
				PushPosInfo(lexStart, scanner.PrevLexEnd);
				val = builder.Operator(XPathOperator.Union, default(Node), val);
				PopPosInfo();
				while (scanner.Kind == LexKind.Union)
				{
					scanner.NextLex();
					lexStart = scanner.LexStart;
					Node right = ParsePathExpr();
					PushPosInfo(lexStart, scanner.PrevLexEnd);
					val = builder.Operator(XPathOperator.Union, val, right);
					PopPosInfo();
				}
			}
			return val;
		}

		private Node ParsePathExpr()
		{
			if (IsPrimaryExpr())
			{
				int lexStart = scanner.LexStart;
				Node val = ParseFilterExpr();
				int prevLexEnd = scanner.PrevLexEnd;
				if (scanner.Kind == LexKind.Slash)
				{
					scanner.NextLex();
					PushPosInfo(lexStart, prevLexEnd);
					val = builder.JoinStep(val, ParseRelativeLocationPath());
					PopPosInfo();
				}
				else if (scanner.Kind == LexKind.SlashSlash)
				{
					scanner.NextLex();
					PushPosInfo(lexStart, prevLexEnd);
					val = builder.JoinStep(val, builder.JoinStep(builder.Axis(XPathAxis.DescendantOrSelf, XPathNodeType.All, null, null), ParseRelativeLocationPath()));
					PopPosInfo();
				}
				return val;
			}
			return ParseLocationPath();
		}

		private Node ParseFilterExpr()
		{
			int lexStart = scanner.LexStart;
			Node val = ParsePrimaryExpr();
			int prevLexEnd = scanner.PrevLexEnd;
			while (scanner.Kind == LexKind.LBracket)
			{
				PushPosInfo(lexStart, prevLexEnd);
				val = builder.Predicate(val, ParsePredicate(), reverseStep: false);
				PopPosInfo();
			}
			return val;
		}

		private bool IsPrimaryExpr()
		{
			if (scanner.Kind != LexKind.String && scanner.Kind != LexKind.Number && scanner.Kind != LexKind.Dollar && scanner.Kind != LexKind.LParens)
			{
				if (scanner.Kind == LexKind.Name && scanner.CanBeFunction)
				{
					return !IsNodeType(scanner);
				}
				return false;
			}
			return true;
		}

		private Node ParsePrimaryExpr()
		{
			Node result;
			switch (scanner.Kind)
			{
			case LexKind.String:
				result = builder.String(scanner.StringValue);
				scanner.NextLex();
				break;
			case LexKind.Number:
				result = builder.Number(scanner.NumberValue);
				scanner.NextLex();
				break;
			case LexKind.Dollar:
			{
				int lexStart = scanner.LexStart;
				scanner.NextLex();
				scanner.CheckToken(LexKind.Name);
				PushPosInfo(lexStart, scanner.LexStart + scanner.LexSize);
				result = builder.Variable(scanner.Prefix, scanner.Name);
				PopPosInfo();
				scanner.NextLex();
				break;
			}
			case LexKind.LParens:
				scanner.NextLex();
				result = ParseExpr();
				scanner.PassToken(LexKind.RParens);
				break;
			default:
				result = ParseFunctionCall();
				break;
			}
			return result;
		}

		private Node ParseFunctionCall()
		{
			List<Node> list = new List<Node>();
			string name = scanner.Name;
			string prefix = scanner.Prefix;
			int lexStart = scanner.LexStart;
			scanner.PassToken(LexKind.Name);
			scanner.PassToken(LexKind.LParens);
			if (scanner.Kind != LexKind.RParens)
			{
				while (true)
				{
					list.Add(ParseExpr());
					if (scanner.Kind != LexKind.Comma)
					{
						break;
					}
					scanner.NextLex();
				}
				scanner.CheckToken(LexKind.RParens);
			}
			scanner.NextLex();
			PushPosInfo(lexStart, scanner.PrevLexEnd);
			Node result = builder.Function(prefix, name, list);
			PopPosInfo();
			return result;
		}

		private void PushPosInfo(int startChar, int endChar)
		{
			posInfo.Push(startChar);
			posInfo.Push(endChar);
		}

		private void PopPosInfo()
		{
			posInfo.Pop();
			posInfo.Pop();
		}

		private void PopPosInfo(out int startChar, out int endChar)
		{
			endChar = posInfo.Pop();
			startChar = posInfo.Pop();
		}
	}
	internal class XPathQilFactory : QilPatternFactory
	{
		public XPathQilFactory(QilFactory f, bool debug)
			: base(f, debug)
		{
		}

		public QilNode Error(string res, QilNode args)
		{
			return Error(InvokeFormatMessage(String(res), args));
		}

		public QilNode Error(ISourceLineInfo lineInfo, string res, params string[] args)
		{
			return Error(String(XslLoadException.CreateMessage(lineInfo, res, args)));
		}

		public QilIterator FirstNode(QilNode n)
		{
			QilIterator qilIterator = For(DocOrderDistinct(n));
			return For(Filter(qilIterator, Eq(PositionOf(qilIterator), Int32(1))));
		}

		public bool IsAnyType(QilNode n)
		{
			XmlQueryType xmlType = n.XmlType;
			return !xmlType.IsStrict && !xmlType.IsNode;
		}

		[Conditional("DEBUG")]
		public void CheckAny(QilNode n)
		{
		}

		[Conditional("DEBUG")]
		public void CheckNode(QilNode n)
		{
		}

		[Conditional("DEBUG")]
		public void CheckNodeSet(QilNode n)
		{
		}

		[Conditional("DEBUG")]
		public void CheckNodeNotRtf(QilNode n)
		{
		}

		[Conditional("DEBUG")]
		public void CheckString(QilNode n)
		{
		}

		[Conditional("DEBUG")]
		public void CheckStringS(QilNode n)
		{
		}

		[Conditional("DEBUG")]
		public void CheckDouble(QilNode n)
		{
		}

		[Conditional("DEBUG")]
		public void CheckBool(QilNode n)
		{
		}

		public bool CannotBeNodeSet(QilNode n)
		{
			XmlQueryType xmlType = n.XmlType;
			if (xmlType.IsAtomicValue && !xmlType.IsEmpty)
			{
				return !(n is QilIterator);
			}
			return false;
		}

		public QilNode SafeDocOrderDistinct(QilNode n)
		{
			XmlQueryType xmlType = n.XmlType;
			if (xmlType.MaybeMany)
			{
				if (xmlType.IsNode && xmlType.IsNotRtf)
				{
					return DocOrderDistinct(n);
				}
				QilIterator qilIterator;
				if (!xmlType.IsAtomicValue)
				{
					return Loop(qilIterator = Let(n), Conditional(Gt(Length(qilIterator), Int32(1)), DocOrderDistinct(TypeAssert(qilIterator, XmlQueryTypeFactory.NodeNotRtfS)), qilIterator));
				}
			}
			return n;
		}

		public QilNode InvokeFormatMessage(QilNode res, QilNode args)
		{
			return XsltInvokeEarlyBound(QName("format-message"), XsltMethods.FormatMessage, XmlQueryTypeFactory.StringX, new QilNode[2] { res, args });
		}

		public QilNode InvokeEqualityOperator(QilNodeType op, QilNode left, QilNode right)
		{
			left = TypeAssert(left, XmlQueryTypeFactory.ItemS);
			right = TypeAssert(right, XmlQueryTypeFactory.ItemS);
			double val = ((op != QilNodeType.Eq) ? 1.0 : 0.0);
			return XsltInvokeEarlyBound(QName("EqualityOperator"), XsltMethods.EqualityOperator, XmlQueryTypeFactory.BooleanX, new QilNode[3]
			{
				Double(val),
				left,
				right
			});
		}

		public QilNode InvokeRelationalOperator(QilNodeType op, QilNode left, QilNode right)
		{
			left = TypeAssert(left, XmlQueryTypeFactory.ItemS);
			right = TypeAssert(right, XmlQueryTypeFactory.ItemS);
			double val = op switch
			{
				QilNodeType.Lt => 2.0, 
				QilNodeType.Le => 3.0, 
				QilNodeType.Gt => 4.0, 
				_ => 5.0, 
			};
			return XsltInvokeEarlyBound(QName("RelationalOperator"), XsltMethods.RelationalOperator, XmlQueryTypeFactory.BooleanX, new QilNode[3]
			{
				Double(val),
				left,
				right
			});
		}

		[Conditional("DEBUG")]
		private void ExpectAny(QilNode n)
		{
		}

		public QilNode ConvertToType(XmlTypeCode requiredType, QilNode n)
		{
			return requiredType switch
			{
				XmlTypeCode.String => ConvertToString(n), 
				XmlTypeCode.Double => ConvertToNumber(n), 
				XmlTypeCode.Boolean => ConvertToBoolean(n), 
				XmlTypeCode.Node => EnsureNodeSet(n), 
				XmlTypeCode.Item => n, 
				_ => null, 
			};
		}

		public QilNode ConvertToString(QilNode n)
		{
			switch (n.XmlType.TypeCode)
			{
			case XmlTypeCode.Boolean:
				if (n.NodeType != QilNodeType.True)
				{
					if (n.NodeType != QilNodeType.False)
					{
						return Conditional(n, String("true"), String("false"));
					}
					return String("false");
				}
				return String("true");
			case XmlTypeCode.Double:
				if (n.NodeType != QilNodeType.LiteralDouble)
				{
					return XsltConvert(n, XmlQueryTypeFactory.StringX);
				}
				return String(XPathConvert.DoubleToString((QilLiteral)n));
			case XmlTypeCode.String:
				return n;
			default:
				if (n.XmlType.IsNode)
				{
					return XPathNodeValue(SafeDocOrderDistinct(n));
				}
				return XsltConvert(n, XmlQueryTypeFactory.StringX);
			}
		}

		public QilNode ConvertToBoolean(QilNode n)
		{
			switch (n.XmlType.TypeCode)
			{
			case XmlTypeCode.Boolean:
				return n;
			case XmlTypeCode.Double:
			{
				QilIterator qilIterator;
				if (n.NodeType != QilNodeType.LiteralDouble)
				{
					return Loop(qilIterator = Let(n), Or(Lt(qilIterator, Double(0.0)), Lt(Double(0.0), qilIterator)));
				}
				return Boolean((double)(QilLiteral)n < 0.0 || 0.0 < (double)(QilLiteral)n);
			}
			case XmlTypeCode.String:
				if (n.NodeType != QilNodeType.LiteralString)
				{
					return Ne(StrLength(n), Int32(0));
				}
				return Boolean(((string)(QilLiteral)n).Length != 0);
			default:
				if (n.XmlType.IsNode)
				{
					return Not(IsEmpty(n));
				}
				return XsltConvert(n, XmlQueryTypeFactory.BooleanX);
			}
		}

		public QilNode ConvertToNumber(QilNode n)
		{
			switch (n.XmlType.TypeCode)
			{
			case XmlTypeCode.Boolean:
				if (n.NodeType != QilNodeType.True)
				{
					if (n.NodeType != QilNodeType.False)
					{
						return Conditional(n, Double(1.0), Double(0.0));
					}
					return Double(0.0);
				}
				return Double(1.0);
			case XmlTypeCode.Double:
				return n;
			case XmlTypeCode.String:
				return XsltConvert(n, XmlQueryTypeFactory.DoubleX);
			default:
				if (n.XmlType.IsNode)
				{
					return XsltConvert(XPathNodeValue(SafeDocOrderDistinct(n)), XmlQueryTypeFactory.DoubleX);
				}
				return XsltConvert(n, XmlQueryTypeFactory.DoubleX);
			}
		}

		public QilNode ConvertToNode(QilNode n)
		{
			if (n.XmlType.IsNode && n.XmlType.IsNotRtf && n.XmlType.IsSingleton)
			{
				return n;
			}
			return XsltConvert(n, XmlQueryTypeFactory.NodeNotRtf);
		}

		public QilNode ConvertToNodeSet(QilNode n)
		{
			if (n.XmlType.IsNode && n.XmlType.IsNotRtf)
			{
				return n;
			}
			return XsltConvert(n, XmlQueryTypeFactory.NodeNotRtfS);
		}

		public QilNode EnsureNodeSet(QilNode n)
		{
			if (n.XmlType.IsNode && n.XmlType.IsNotRtf)
			{
				return n;
			}
			if (CannotBeNodeSet(n))
			{
				throw new XPathCompileException("XPath_NodeSetExpected");
			}
			return InvokeEnsureNodeSet(n);
		}

		public QilNode InvokeEnsureNodeSet(QilNode n)
		{
			return XsltInvokeEarlyBound(QName("ensure-node-set"), XsltMethods.EnsureNodeSet, XmlQueryTypeFactory.NodeDodS, new QilNode[1] { n });
		}

		public QilNode Id(QilNode context, QilNode id)
		{
			if (id.XmlType.IsSingleton)
			{
				return Deref(context, ConvertToString(id));
			}
			QilIterator n;
			return Loop(n = For(id), Deref(context, ConvertToString(n)));
		}

		public QilNode InvokeStartsWith(QilNode str1, QilNode str2)
		{
			return XsltInvokeEarlyBound(QName("starts-with"), XsltMethods.StartsWith, XmlQueryTypeFactory.BooleanX, new QilNode[2] { str1, str2 });
		}

		public QilNode InvokeContains(QilNode str1, QilNode str2)
		{
			return XsltInvokeEarlyBound(QName("contains"), XsltMethods.Contains, XmlQueryTypeFactory.BooleanX, new QilNode[2] { str1, str2 });
		}

		public QilNode InvokeSubstringBefore(QilNode str1, QilNode str2)
		{
			return XsltInvokeEarlyBound(QName("substring-before"), XsltMethods.SubstringBefore, XmlQueryTypeFactory.StringX, new QilNode[2] { str1, str2 });
		}

		public QilNode InvokeSubstringAfter(QilNode str1, QilNode str2)
		{
			return XsltInvokeEarlyBound(QName("substring-after"), XsltMethods.SubstringAfter, XmlQueryTypeFactory.StringX, new QilNode[2] { str1, str2 });
		}

		public QilNode InvokeSubstring(QilNode str, QilNode start)
		{
			return XsltInvokeEarlyBound(QName("substring"), XsltMethods.Substring2, XmlQueryTypeFactory.StringX, new QilNode[2] { str, start });
		}

		public QilNode InvokeSubstring(QilNode str, QilNode start, QilNode length)
		{
			return XsltInvokeEarlyBound(QName("substring"), XsltMethods.Substring3, XmlQueryTypeFactory.StringX, new QilNode[3] { str, start, length });
		}

		public QilNode InvokeNormalizeSpace(QilNode str)
		{
			return XsltInvokeEarlyBound(QName("normalize-space"), XsltMethods.NormalizeSpace, XmlQueryTypeFactory.StringX, new QilNode[1] { str });
		}

		public QilNode InvokeTranslate(QilNode str1, QilNode str2, QilNode str3)
		{
			return XsltInvokeEarlyBound(QName("translate"), XsltMethods.Translate, XmlQueryTypeFactory.StringX, new QilNode[3] { str1, str2, str3 });
		}

		public QilNode InvokeLang(QilNode lang, QilNode context)
		{
			return XsltInvokeEarlyBound(QName("lang"), XsltMethods.Lang, XmlQueryTypeFactory.BooleanX, new QilNode[2] { lang, context });
		}

		public QilNode InvokeFloor(QilNode value)
		{
			return XsltInvokeEarlyBound(QName("floor"), XsltMethods.Floor, XmlQueryTypeFactory.DoubleX, new QilNode[1] { value });
		}

		public QilNode InvokeCeiling(QilNode value)
		{
			return XsltInvokeEarlyBound(QName("ceiling"), XsltMethods.Ceiling, XmlQueryTypeFactory.DoubleX, new QilNode[1] { value });
		}

		public QilNode InvokeRound(QilNode value)
		{
			return XsltInvokeEarlyBound(QName("round"), XsltMethods.Round, XmlQueryTypeFactory.DoubleX, new QilNode[1] { value });
		}
	}
	internal enum LexKind
	{
		Comma = 44,
		Slash = 47,
		At = 64,
		Dot = 46,
		LParens = 40,
		RParens = 41,
		LBracket = 91,
		RBracket = 93,
		LBrace = 123,
		RBrace = 125,
		Star = 42,
		Plus = 43,
		Minus = 45,
		Eq = 61,
		Lt = 60,
		Gt = 62,
		Bang = 33,
		Dollar = 36,
		Union = 124,
		Ne = 78,
		Le = 76,
		Ge = 71,
		DotDot = 68,
		SlashSlash = 83,
		Name = 110,
		String = 115,
		Number = 100,
		Axis = 97,
		Unknown = 85,
		Eof = 69
	}
	internal sealed class XPathScanner
	{
		private string xpathExpr;

		private int curIndex;

		private char curChar;

		private LexKind kind;

		private string name;

		private string prefix;

		private string stringValue;

		private double numberValue = double.NaN;

		private bool canBeFunction;

		private int lexStart;

		private int prevLexEnd;

		private XmlCharType xmlCharType = XmlCharType.Instance;

		public string Source => xpathExpr;

		public LexKind Kind => kind;

		public int LexStart => lexStart;

		public int LexSize => curIndex - lexStart;

		public int PrevLexEnd => prevLexEnd;

		public string Name => name;

		public string Prefix => prefix;

		public string RawValue
		{
			get
			{
				if (kind == LexKind.Eof)
				{
					return LexKindToString(kind);
				}
				return xpathExpr.Substring(lexStart, curIndex - lexStart);
			}
		}

		public string StringValue => stringValue;

		public double NumberValue => numberValue;

		public bool CanBeFunction => canBeFunction;

		public XPathScanner(string xpathExpr)
			: this(xpathExpr, 0)
		{
		}

		public XPathScanner(string xpathExpr, int startFrom)
		{
			this.xpathExpr = xpathExpr;
			SetSourceIndex(startFrom);
			NextLex();
		}

		private void SetSourceIndex(int index)
		{
			curIndex = index - 1;
			NextChar();
		}

		private bool NextChar()
		{
			curIndex++;
			if (curIndex < xpathExpr.Length)
			{
				curChar = xpathExpr[curIndex];
				return true;
			}
			curChar = '\0';
			return false;
		}

		public bool IsKeyword(string keyword)
		{
			if (kind == LexKind.Name && prefix.Length == 0)
			{
				return name.Equals(keyword);
			}
			return false;
		}

		private void SkipSpace()
		{
			while (xmlCharType.IsWhiteSpace(curChar) && NextChar())
			{
			}
		}

		public bool NextLex()
		{
			prevLexEnd = curIndex;
			SkipSpace();
			lexStart = curIndex;
			switch (curChar)
			{
			case '\0':
				kind = LexKind.Eof;
				return false;
			case '#':
			case '$':
			case '(':
			case ')':
			case '*':
			case '+':
			case ',':
			case '-':
			case '=':
			case '@':
			case '[':
			case ']':
			case '{':
			case '|':
			case '}':
				kind = (LexKind)curChar;
				NextChar();
				break;
			case '<':
				kind = LexKind.Lt;
				NextChar();
				if (curChar == '=')
				{
					kind = LexKind.Le;
					NextChar();
				}
				break;
			case '>':
				kind = LexKind.Gt;
				NextChar();
				if (curChar == '=')
				{
					kind = LexKind.Ge;
					NextChar();
				}
				break;
			case '!':
				kind = LexKind.Bang;
				NextChar();
				if (curChar == '=')
				{
					kind = LexKind.Ne;
					NextChar();
				}
				break;
			case '.':
				kind = LexKind.Dot;
				NextChar();
				if (curChar == '.')
				{
					kind = LexKind.DotDot;
					NextChar();
				}
				else if (xmlCharType.IsDigit(curChar))
				{
					ScanFraction();
				}
				break;
			case '/':
				kind = LexKind.Slash;
				NextChar();
				if (curChar == '/')
				{
					kind = LexKind.SlashSlash;
					NextChar();
				}
				break;
			case '"':
			case '\'':
				ScanString();
				break;
			default:
				if (xmlCharType.IsDigit(curChar))
				{
					ScanNumber();
				}
				else if (xmlCharType.IsStartNCNameChar(curChar))
				{
					kind = LexKind.Name;
					name = ScanNCName();
					prefix = string.Empty;
					int sourceIndex = curIndex;
					if (curChar == ':')
					{
						NextChar();
						if (curChar == ':')
						{
							NextChar();
							kind = LexKind.Axis;
						}
						else if (curChar == '*')
						{
							NextChar();
							prefix = name;
							name = "*";
						}
						else if (xmlCharType.IsStartNCNameChar(curChar))
						{
							prefix = name;
							name = ScanNCName();
						}
						else
						{
							SetSourceIndex(sourceIndex);
						}
					}
					else
					{
						SkipSpace();
						if (curChar == ':')
						{
							NextChar();
							if (curChar == ':')
							{
								NextChar();
								kind = LexKind.Axis;
							}
							else
							{
								SetSourceIndex(sourceIndex);
							}
						}
					}
					sourceIndex = curIndex;
					SkipSpace();
					canBeFunction = curChar == '(';
					SetSourceIndex(sourceIndex);
				}
				else
				{
					kind = LexKind.Unknown;
					NextChar();
				}
				break;
			}
			return true;
		}

		private void ScanNumber()
		{
			int num = curIndex;
			while (xmlCharType.IsDigit(curChar))
			{
				NextChar();
			}
			if (curChar == '.')
			{
				NextChar();
				while (xmlCharType.IsDigit(curChar))
				{
					NextChar();
				}
			}
			if ((curChar & -33) == 69)
			{
				NextChar();
				if (curChar == '+' || curChar == '-')
				{
					NextChar();
				}
				while (xmlCharType.IsDigit(curChar))
				{
					NextChar();
				}
				throw CreateException("XPath_ScientificNotation");
			}
			kind = LexKind.Number;
			numberValue = XPathConvert.StringToDouble(xpathExpr.Substring(num, curIndex - num));
		}

		private void ScanFraction()
		{
			int num = curIndex - 1;
			while (xmlCharType.IsDigit(curChar))
			{
				NextChar();
			}
			kind = LexKind.Number;
			numberValue = XPathConvert.StringToDouble(xpathExpr.Substring(num, curIndex - num));
		}

		private void ScanString()
		{
			char c = curChar;
			int num = curIndex + 1;
			do
			{
				if (!NextChar())
				{
					throw CreateException("XPath_UnclosedString");
				}
			}
			while (curChar != c);
			kind = LexKind.String;
			stringValue = xpathExpr.Substring(num, curIndex - num);
			NextChar();
		}

		private string ScanNCName()
		{
			int num = curIndex;
			while (xmlCharType.IsNCNameChar(curChar))
			{
				NextChar();
			}
			return xpathExpr.Substring(num, curIndex - num);
		}

		public void PassToken(LexKind t)
		{
			CheckToken(t);
			NextLex();
		}

		public void CheckToken(LexKind t)
		{
			if (kind != t)
			{
				if (t == LexKind.Eof)
				{
					throw CreateException("XPath_EofExpected", RawValue);
				}
				throw CreateException("XPath_TokenExpected", LexKindToString(t), RawValue);
			}
		}

		public string LexKindToString(LexKind t)
		{
			if (",/@.()[]{}*+-=<>!$|".IndexOf((char)t) >= 0)
			{
				return ((char)t).ToString();
			}
			return t switch
			{
				LexKind.Ne => "!=", 
				LexKind.Le => "<=", 
				LexKind.Ge => ">=", 
				LexKind.DotDot => "..", 
				LexKind.SlashSlash => "//", 
				LexKind.Name => "<name>", 
				LexKind.String => "<string literal>", 
				LexKind.Number => "<number literal>", 
				LexKind.Axis => "<axis>", 
				LexKind.Unknown => "<unknown>", 
				LexKind.Eof => "<eof>", 
				_ => string.Empty, 
			};
		}

		public XPathCompileException CreateException(string resId, params string[] args)
		{
			return new XPathCompileException(xpathExpr, lexStart, curIndex, resId, args);
		}
	}
}
namespace System.Xml.Xsl.Xslt
{
	internal enum XslVersion
	{
		Version10 = 0,
		ForwardsCompatible = 1,
		Current = 0
	}
	internal class Compiler
	{
		public XsltSettings Settings;

		public bool IsDebug;

		public string ScriptAssemblyPath;

		public CompilerResults CompilerResults;

		public Stylesheet PrincipalStylesheet;

		public int CurrentPrecedence;

		public XslNode StartApplyTemplates;

		public Scripts Scripts;

		public Output Output = new Output();

		public List<VarPar> ExternalPars = new List<VarPar>();

		public List<VarPar> GlobalVars = new List<VarPar>();

		public List<WhitespaceRule> WhitespaceRules = new List<WhitespaceRule>();

		public DecimalFormats DecimalFormats = new DecimalFormats();

		public Keys Keys = new Keys();

		public List<ProtoTemplate> AllTemplates = new List<ProtoTemplate>();

		public Dictionary<QilName, VarPar> AllGlobalVarPars = new Dictionary<QilName, VarPar>();

		public Dictionary<QilName, Template> NamedTemplates = new Dictionary<QilName, Template>();

		public Dictionary<QilName, AttributeSet> AttributeSets = new Dictionary<QilName, AttributeSet>();

		public Dictionary<string, NsAlias> NsAliases = new Dictionary<string, NsAlias>();

		public Dictionary<QilName, XslFlags> ModeFlags = new Dictionary<QilName, XslFlags>();

		public Dictionary<QilName, List<QilFunction>> ApplyTemplatesFunctions = new Dictionary<QilName, List<QilFunction>>();

		public readonly string PhantomNCName = "error";

		private int phantomNsCounter;

		private int savedErrorCount = -1;

		private int ErrorCount
		{
			get
			{
				return CompilerResults.Errors.Count;
			}
			set
			{
				for (int num = ErrorCount - 1; num >= value; num--)
				{
					CompilerResults.Errors.RemoveAt(num);
				}
			}
		}

		public Compiler(XsltSettings settings, bool debug, string scriptAssemblyPath)
		{
			TempFileCollection tempFileCollection = settings.TempFiles ?? new TempFileCollection();
			if (XmlILTrace.IsEnabled)
			{
				tempFileCollection.KeepFiles = true;
			}
			Settings = settings;
			IsDebug = settings.IncludeDebugInformation || debug;
			ScriptAssemblyPath = scriptAssemblyPath;
			CompilerResults = new CompilerResults(tempFileCollection);
			Scripts = new Scripts(this);
		}

		public CompilerResults Compile(object stylesheet, XmlResolver xmlResolver, out QilExpression qil)
		{
			new XsltLoader().Load(this, stylesheet, xmlResolver);
			qil = QilGenerator.CompileStylesheet(this);
			return CompilerResults;
		}

		public Stylesheet CreateStylesheet()
		{
			Stylesheet stylesheet = new Stylesheet(this, CurrentPrecedence);
			if (CurrentPrecedence-- == 0)
			{
				PrincipalStylesheet = stylesheet;
			}
			return stylesheet;
		}

		public void ApplyNsAliases(ref string prefix, ref string nsUri)
		{
			if (NsAliases.TryGetValue(nsUri, out var value))
			{
				nsUri = value.ResultNsUri;
				prefix = value.ResultPrefix;
			}
		}

		public bool SetNsAlias(string ssheetNsUri, string resultNsUri, string resultPrefix, int importPrecedence)
		{
			if (NsAliases.TryGetValue(ssheetNsUri, out var value) && (importPrecedence < value.ImportPrecedence || resultNsUri == value.ResultNsUri))
			{
				return false;
			}
			NsAliases[ssheetNsUri] = new NsAlias(resultNsUri, resultPrefix, importPrecedence);
			return value != null;
		}

		private void MergeWhitespaceRules(Stylesheet sheet)
		{
			for (int i = 0; i <= 2; i++)
			{
				sheet.WhitespaceRules[i].Reverse();
				WhitespaceRules.AddRange(sheet.WhitespaceRules[i]);
			}
			sheet.WhitespaceRules = null;
		}

		private void MergeAttributeSets(Stylesheet sheet)
		{
			foreach (QilName key in sheet.AttributeSets.Keys)
			{
				if (!AttributeSets.TryGetValue(key, out var value))
				{
					AttributeSets[key] = sheet.AttributeSets[key];
				}
				else
				{
					value.MergeContent(sheet.AttributeSets[key]);
				}
			}
			sheet.AttributeSets = null;
		}

		private void MergeGlobalVarPars(Stylesheet sheet)
		{
			foreach (VarPar globalVarPar in sheet.GlobalVarPars)
			{
				if (!AllGlobalVarPars.ContainsKey(globalVarPar.Name))
				{
					if (globalVarPar.NodeType == XslNodeType.Variable)
					{
						GlobalVars.Add(globalVarPar);
					}
					else
					{
						ExternalPars.Add(globalVarPar);
					}
					AllGlobalVarPars[globalVarPar.Name] = globalVarPar;
				}
			}
			sheet.GlobalVarPars = null;
		}

		public void MergeWithStylesheet(Stylesheet sheet)
		{
			MergeWhitespaceRules(sheet);
			MergeAttributeSets(sheet);
			MergeGlobalVarPars(sheet);
		}

		public static string ConstructQName(string prefix, string localName)
		{
			if (prefix.Length == 0)
			{
				return localName;
			}
			return prefix + ':' + localName;
		}

		public bool ParseQName(string qname, out string prefix, out string localName, IErrorHelper errorHelper)
		{
			try
			{
				ValidateNames.ParseQNameThrow(qname, out prefix, out localName);
				return true;
			}
			catch (XmlException ex)
			{
				errorHelper.ReportError(ex.Message, (string[])null);
				prefix = PhantomNCName;
				localName = PhantomNCName;
				return false;
			}
		}

		public bool ParseNameTest(string nameTest, out string prefix, out string localName, IErrorHelper errorHelper)
		{
			try
			{
				ValidateNames.ParseNameTestThrow(nameTest, out prefix, out localName);
				return true;
			}
			catch (XmlException ex)
			{
				errorHelper.ReportError(ex.Message, (string[])null);
				prefix = PhantomNCName;
				localName = PhantomNCName;
				return false;
			}
		}

		public void ValidatePiName(string name, IErrorHelper errorHelper)
		{
			try
			{
				ValidateNames.ValidateNameThrow(string.Empty, name, string.Empty, XPathNodeType.ProcessingInstruction, ValidateNames.Flags.AllExceptPrefixMapping);
			}
			catch (XmlException ex)
			{
				errorHelper.ReportError(ex.Message, (string[])null);
			}
		}

		public string CreatePhantomNamespace()
		{
			return "\0namespace" + phantomNsCounter++;
		}

		public bool IsPhantomNamespace(string namespaceName)
		{
			if (namespaceName.Length > 0)
			{
				return namespaceName[0] == '\0';
			}
			return false;
		}

		public bool IsPhantomName(QilName qname)
		{
			string namespaceUri = qname.NamespaceUri;
			if (namespaceUri.Length > 0)
			{
				return namespaceUri[0] == '\0';
			}
			return false;
		}

		public void EnterForwardsCompatible()
		{
			savedErrorCount = ErrorCount;
		}

		public bool ExitForwardsCompatible(bool fwdCompat)
		{
			if (fwdCompat && ErrorCount > savedErrorCount)
			{
				ErrorCount = savedErrorCount;
				return false;
			}
			return true;
		}

		public CompilerError CreateError(ISourceLineInfo lineInfo, string res, params string[] args)
		{
			return new CompilerError(lineInfo.Uri, lineInfo.StartLine, lineInfo.StartPos, string.Empty, XslTransformException.CreateMessage(res, args));
		}

		public void ReportError(ISourceLineInfo lineInfo, string res, params string[] args)
		{
			CompilerError value = CreateError(lineInfo, res, args);
			CompilerResults.Errors.Add(value);
		}

		public void ReportWarning(ISourceLineInfo lineInfo, string res, params string[] args)
		{
			int num = 1;
			if (0 > Settings.WarningLevel || Settings.WarningLevel >= num)
			{
				CompilerError compilerError = CreateError(lineInfo, res, args);
				if (Settings.TreatWarningsAsErrors)
				{
					compilerError.ErrorText = XslTransformException.CreateMessage("Xslt_WarningAsError", compilerError.ErrorText);
					CompilerResults.Errors.Add(compilerError);
				}
				else
				{
					compilerError.IsWarning = true;
					CompilerResults.Errors.Add(compilerError);
				}
			}
		}
	}
	internal class Output
	{
		public const int NeverDeclaredPrec = int.MinValue;

		public XmlWriterSettings Settings;

		public string Version;

		public string Encoding;

		public XmlQualifiedName Method;

		public int MethodPrec = int.MinValue;

		public int VersionPrec = int.MinValue;

		public int EncodingPrec = int.MinValue;

		public int OmitXmlDeclarationPrec = int.MinValue;

		public int StandalonePrec = int.MinValue;

		public int DocTypePublicPrec = int.MinValue;

		public int DocTypeSystemPrec = int.MinValue;

		public int IndentPrec = int.MinValue;

		public int MediaTypePrec = int.MinValue;

		public Output()
		{
			Settings = new XmlWriterSettings();
			Settings.OutputMethod = XmlOutputMethod.AutoDetect;
			Settings.AutoXmlDeclaration = true;
			Settings.ConformanceLevel = ConformanceLevel.Auto;
			Settings.MergeCDataSections = true;
		}
	}
	internal class DecimalFormats : KeyedCollection<XmlQualifiedName, DecimalFormatDecl>
	{
		protected override XmlQualifiedName GetKeyForItem(DecimalFormatDecl format)
		{
			return format.Name;
		}
	}
	internal class DecimalFormatDecl
	{
		public readonly XmlQualifiedName Name;

		public readonly string InfinitySymbol;

		public readonly string NanSymbol;

		public readonly char[] Characters;

		public static DecimalFormatDecl Default = new DecimalFormatDecl(new XmlQualifiedName(), "Infinity", "NaN", ".,%‰0#;-");

		public DecimalFormatDecl(XmlQualifiedName name, string infinitySymbol, string nanSymbol, string characters)
		{
			Name = name;
			InfinitySymbol = infinitySymbol;
			NanSymbol = nanSymbol;
			Characters = characters.ToCharArray();
		}
	}
	internal class NsAlias
	{
		public readonly string ResultNsUri;

		public readonly string ResultPrefix;

		public readonly int ImportPrecedence;

		public NsAlias(string resultNsUri, string resultPrefix, int importPrecedence)
		{
			ResultNsUri = resultNsUri;
			ResultPrefix = resultPrefix;
			ImportPrecedence = importPrecedence;
		}
	}
	internal sealed class CompilerScopeManager<V> : IEnumerable where V : class
	{
		public struct ScopeRecord
		{
			public int scopeCount;

			public string ncName;

			public string nsUri;

			public V value;

			public bool IsVariable => value != null;

			public bool IsNamespace
			{
				get
				{
					if (value == null)
					{
						return ncName != null;
					}
					return false;
				}
			}

			public bool IsExNamespace
			{
				get
				{
					if (value == null)
					{
						return ncName == null;
					}
					return false;
				}
			}
		}

		private sealed class NamespaceEnumerator : IEnumerator
		{
			private CompilerScopeManager<V> scope;

			private int lastRecord;

			private int currentRecord;

			public object Current => scope.records[currentRecord];

			public NamespaceEnumerator(CompilerScopeManager<V> scope)
			{
				this.scope = scope;
				lastRecord = scope.lastRecord;
				Reset();
			}

			public void Reset()
			{
				currentRecord = lastRecord + 1;
			}

			public bool MoveNext()
			{
				while (0 < --currentRecord)
				{
					if (scope.records[currentRecord].IsNamespace && scope.LookupNamespace(scope.records[currentRecord].ncName, lastRecord, currentRecord + 1) == null)
					{
						return true;
					}
				}
				return false;
			}
		}

		private const int LastPredefRecord = 0;

		private ScopeRecord[] records = new ScopeRecord[32];

		private int lastRecord;

		private int lastScopes;

		public CompilerScopeManager()
		{
			Reset();
		}

		private void Reset()
		{
			records[0].ncName = "xml";
			records[0].nsUri = "http://www.w3.org/XML/1998/namespace";
			lastRecord = 0;
		}

		public void PushScope()
		{
			lastScopes++;
		}

		public void PopScope()
		{
			if (0 < lastScopes)
			{
				lastScopes--;
				return;
			}
			while (records[--lastRecord].scopeCount == 0)
			{
			}
			lastScopes = records[lastRecord].scopeCount;
			lastScopes--;
		}

		private void AddRecord(string ncName, string uri, V value)
		{
			records[lastRecord].scopeCount = lastScopes;
			if (++lastRecord == records.Length)
			{
				ScopeRecord[] destinationArray = new ScopeRecord[lastRecord * 2];
				Array.Copy(records, 0, destinationArray, 0, lastRecord);
				records = destinationArray;
			}
			lastScopes = 0;
			records[lastRecord].ncName = ncName;
			records[lastRecord].nsUri = uri;
			records[lastRecord].value = value;
		}

		public void AddNamespace(string prefix, string uri)
		{
			AddRecord(prefix, uri, null);
		}

		public void AddVariable(QilName varName, V value)
		{
			AddRecord(varName.LocalName, varName.NamespaceUri, value);
		}

		private string LookupNamespace(string prefix, int from, int to)
		{
			int num = from;
			while (to <= num)
			{
				if (records[num].IsNamespace && records[num].ncName == prefix)
				{
					return records[num].nsUri;
				}
				num--;
			}
			return null;
		}

		public string LookupNamespace(string prefix)
		{
			return LookupNamespace(prefix, lastRecord, 0);
		}

		public bool IsExNamespace(string nsUri)
		{
			int num = lastRecord;
			while (0 <= num)
			{
				if (records[num].IsExNamespace && records[num].nsUri == nsUri)
				{
					return true;
				}
				num--;
			}
			return false;
		}

		private int SearchVariable(string localName, string uri)
		{
			int num = lastRecord;
			while (0 <= num)
			{
				if (records[num].IsVariable && records[num].ncName == localName && records[num].nsUri == uri)
				{
					return num;
				}
				num--;
			}
			return -1;
		}

		public V LookupVariable(string localName, string uri)
		{
			int num = SearchVariable(localName, uri);
			if (num >= 0)
			{
				return records[num].value;
			}
			return null;
		}

		public bool IsLocalVariable(string localName, string uri)
		{
			int num = SearchVariable(localName, uri);
			while (0 <= --num)
			{
				if (records[num].scopeCount != 0)
				{
					return true;
				}
			}
			return false;
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return new NamespaceEnumerator(this);
		}
	}
	internal enum SingletonFocusType
	{
		None,
		InitialDocumentNode,
		InitialContextNode,
		Iterator
	}
	internal struct SingletonFocus : IFocus
	{
		private XPathQilFactory f;

		private SingletonFocusType focusType;

		private QilIterator current;

		public SingletonFocus(XPathQilFactory f)
		{
			this.f = f;
			focusType = SingletonFocusType.None;
			current = null;
		}

		public void SetFocus(SingletonFocusType focusType)
		{
			this.focusType = focusType;
		}

		public void SetFocus(QilIterator current)
		{
			if (current != null)
			{
				focusType = SingletonFocusType.Iterator;
				this.current = current;
			}
			else
			{
				focusType = SingletonFocusType.None;
				this.current = null;
			}
		}

		[Conditional("DEBUG")]
		private void CheckFocus()
		{
		}

		public QilNode GetCurrent()
		{
			return focusType switch
			{
				SingletonFocusType.InitialDocumentNode => f.Root(f.XmlContext()), 
				SingletonFocusType.InitialContextNode => f.XmlContext(), 
				_ => current, 
			};
		}

		public QilNode GetPosition()
		{
			return f.Double(1.0);
		}

		public QilNode GetLast()
		{
			return f.Double(1.0);
		}
	}
	internal struct FunctionFocus : IFocus
	{
		private bool isSet;

		private QilParameter current;

		private QilParameter position;

		private QilParameter last;

		public bool IsFocusSet => isSet;

		public void StartFocus(IList<QilNode> args, XslFlags flags)
		{
			int num = 0;
			if ((flags & XslFlags.Current) != 0)
			{
				current = (QilParameter)args[num++];
			}
			if ((flags & XslFlags.Position) != 0)
			{
				position = (QilParameter)args[num++];
			}
			if ((flags & XslFlags.Last) != 0)
			{
				last = (QilParameter)args[num++];
			}
			isSet = true;
		}

		public void StopFocus()
		{
			isSet = false;
			current = (position = (last = null));
		}

		public QilNode GetCurrent()
		{
			return current;
		}

		public QilNode GetPosition()
		{
			return position;
		}

		public QilNode GetLast()
		{
			return last;
		}
	}
	internal struct LoopFocus : IFocus
	{
		private XPathQilFactory f;

		private QilIterator current;

		private QilIterator cached;

		private QilIterator last;

		public bool IsFocusSet => current != null;

		public LoopFocus(XPathQilFactory f)
		{
			this.f = f;
			current = (cached = (last = null));
		}

		public void SetFocus(QilIterator current)
		{
			this.current = current;
			cached = (last = null);
		}

		public QilNode GetCurrent()
		{
			return current;
		}

		public QilNode GetPosition()
		{
			return f.XsltConvert(f.PositionOf(current), XmlQueryTypeFactory.DoubleX);
		}

		public QilNode GetLast()
		{
			if (last == null)
			{
				last = f.Let(f.Double(0.0));
			}
			return last;
		}

		public void EnsureCache()
		{
			if (cached == null)
			{
				cached = f.Let(current.Binding);
				current.Binding = cached;
			}
		}

		public void Sort(QilNode sortKeys)
		{
			if (sortKeys != null)
			{
				EnsureCache();
				current = f.For(f.Sort(current, sortKeys));
			}
		}

		public QilLoop ConstructLoop(QilNode body)
		{
			if (last != null)
			{
				EnsureCache();
				last.Binding = f.XsltConvert(f.Length(cached), XmlQueryTypeFactory.DoubleX);
			}
			QilLoop qilLoop = f.BaseFactory.Loop(current, body);
			if (last != null)
			{
				qilLoop = f.BaseFactory.Loop(last, qilLoop);
			}
			if (cached != null)
			{
				qilLoop = f.BaseFactory.Loop(cached, qilLoop);
			}
			return qilLoop;
		}
	}
}
namespace System.Xml.Xsl
{
	internal interface IErrorHelper
	{
		void ReportError(string res, params string[] args);

		void ReportWarning(string res, params string[] args);
	}
}
namespace System.Xml.Xsl.Xslt
{
	internal class InvokeGenerator : QilCloneVisitor
	{
		private bool debug;

		private Stack<QilIterator> iterStack;

		private QilList formalArgs;

		private QilList invokeArgs;

		private int curArg;

		private XsltQilFactory fac;

		public InvokeGenerator(XsltQilFactory f, bool debug)
			: base(f.BaseFactory)
		{
			this.debug = debug;
			fac = f;
			iterStack = new Stack<QilIterator>();
		}

		public QilNode GenerateInvoke(QilFunction func, IList<XslNode> actualArgs)
		{
			iterStack.Clear();
			formalArgs = func.Arguments;
			invokeArgs = fac.ActualParameterList();
			for (curArg = 0; curArg < formalArgs.Count; curArg++)
			{
				QilParameter qilParameter = (QilParameter)formalArgs[curArg];
				QilNode qilNode = FindActualArg(qilParameter, actualArgs);
				if (qilNode == null)
				{
					qilNode = ((!debug) ? Clone(qilParameter.DefaultValue) : ((!(qilParameter.Name.NamespaceUri == "urn:schemas-microsoft-com:xslt-debug")) ? fac.DefaultValueMarker() : Clone(qilParameter.DefaultValue)));
				}
				XmlQueryType xmlType = qilParameter.XmlType;
				XmlQueryType xmlType2 = qilNode.XmlType;
				if (!xmlType2.IsSubtypeOf(xmlType))
				{
					qilNode = fac.TypeAssert(qilNode, xmlType);
				}
				invokeArgs.Add(qilNode);
			}
			QilNode qilNode2 = fac.Invoke(func, invokeArgs);
			while (iterStack.Count != 0)
			{
				qilNode2 = fac.Loop(iterStack.Pop(), qilNode2);
			}
			return qilNode2;
		}

		private QilNode FindActualArg(QilParameter formalArg, IList<XslNode> actualArgs)
		{
			QilName name = formalArg.Name;
			foreach (XslNode actualArg in actualArgs)
			{
				if (actualArg.Name.Equals(name))
				{
					return ((VarPar)actualArg).Value;
				}
			}
			return null;
		}

		protected override QilNode VisitReference(QilNode n)
		{
			QilNode qilNode = FindClonedReference(n);
			if (qilNode != null)
			{
				return qilNode;
			}
			for (int i = 0; i < curArg; i++)
			{
				if (n == formalArgs[i])
				{
					if (invokeArgs[i] is QilLiteral)
					{
						return invokeArgs[i].ShallowClone(fac.BaseFactory);
					}
					if (!(invokeArgs[i] is QilIterator))
					{
						QilIterator qilIterator = fac.BaseFactory.Let(invokeArgs[i]);
						iterStack.Push(qilIterator);
						invokeArgs[i] = qilIterator;
					}
					return invokeArgs[i];
				}
			}
			return n;
		}

		protected override QilNode VisitFunction(QilFunction n)
		{
			return n;
		}
	}
	internal class XPathPatternParser
	{
		public interface IPatternBuilder : IXPathBuilder<QilNode>
		{
			IXPathBuilder<QilNode> GetPredicateBuilder(QilNode context);
		}

		private const int MaxParseRelativePathDepth = 512;

		private System.Xml.Xsl.XPath.XPathScanner scanner;

		private IPatternBuilder ptrnBuilder;

		private XPathParser<QilNode> predicateParser = new XPathParser<QilNode>();

		private int parseRelativePath;

		public QilNode Parse(System.Xml.Xsl.XPath.XPathScanner scanner, IPatternBuilder ptrnBuilder)
		{
			QilNode result = null;
			ptrnBuilder.StartBuild();
			try
			{
				this.scanner = scanner;
				this.ptrnBuilder = ptrnBuilder;
				result = ParsePattern();
				this.scanner.CheckToken(LexKind.Eof);
			}
			finally
			{
				result = ptrnBuilder.EndBuild(result);
			}
			return result;
		}

		private QilNode ParsePattern()
		{
			QilNode qilNode = ParseLocationPathPattern();
			while (scanner.Kind == LexKind.Union)
			{
				scanner.NextLex();
				qilNode = ptrnBuilder.Operator(XPathOperator.Union, qilNode, ParseLocationPathPattern());
			}
			return qilNode;
		}

		private QilNode ParseLocationPathPattern()
		{
			switch (scanner.Kind)
			{
			case LexKind.Slash:
			{
				scanner.NextLex();
				QilNode qilNode = ptrnBuilder.Axis(XPathAxis.Root, XPathNodeType.All, null, null);
				if (XPathParser<QilNode>.IsStep(scanner.Kind))
				{
					qilNode = ptrnBuilder.JoinStep(qilNode, ParseRelativePathPattern());
				}
				return qilNode;
			}
			case LexKind.SlashSlash:
				scanner.NextLex();
				return ptrnBuilder.JoinStep(ptrnBuilder.Axis(XPathAxis.Root, XPathNodeType.All, null, null), ptrnBuilder.JoinStep(ptrnBuilder.Axis(XPathAxis.DescendantOrSelf, XPathNodeType.All, null, null), ParseRelativePathPattern()));
			case LexKind.Name:
				if (scanner.CanBeFunction && scanner.Prefix.Length == 0 && (scanner.Name == "id" || scanner.Name == "key"))
				{
					QilNode qilNode = ParseIdKeyPattern();
					switch (scanner.Kind)
					{
					case LexKind.Slash:
						scanner.NextLex();
						qilNode = ptrnBuilder.JoinStep(qilNode, ParseRelativePathPattern());
						break;
					case LexKind.SlashSlash:
						scanner.NextLex();
						qilNode = ptrnBuilder.JoinStep(qilNode, ptrnBuilder.JoinStep(ptrnBuilder.Axis(XPathAxis.DescendantOrSelf, XPathNodeType.All, null, null), ParseRelativePathPattern()));
						break;
					}
					return qilNode;
				}
				break;
			}
			return ParseRelativePathPattern();
		}

		private QilNode ParseIdKeyPattern()
		{
			List<QilNode> list = new List<QilNode>(2);
			if (scanner.Name == "id")
			{
				scanner.NextLex();
				scanner.PassToken(LexKind.LParens);
				scanner.CheckToken(LexKind.String);
				list.Add(ptrnBuilder.String(scanner.StringValue));
				scanner.NextLex();
				scanner.PassToken(LexKind.RParens);
				return ptrnBuilder.Function("", "id", list);
			}
			scanner.NextLex();
			scanner.PassToken(LexKind.LParens);
			scanner.CheckToken(LexKind.String);
			list.Add(ptrnBuilder.String(scanner.StringValue));
			scanner.NextLex();
			scanner.PassToken(LexKind.Comma);
			scanner.CheckToken(LexKind.String);
			list.Add(ptrnBuilder.String(scanner.StringValue));
			scanner.NextLex();
			scanner.PassToken(LexKind.RParens);
			return ptrnBuilder.Function("", "key", list);
		}

		private QilNode ParseRelativePathPattern()
		{
			if (++parseRelativePath > 512 && XsltConfigSection.LimitXPathComplexity)
			{
				throw scanner.CreateException("Xslt_CompileError2");
			}
			QilNode qilNode = ParseStepPattern();
			if (scanner.Kind == LexKind.Slash)
			{
				scanner.NextLex();
				qilNode = ptrnBuilder.JoinStep(qilNode, ParseRelativePathPattern());
			}
			else if (scanner.Kind == LexKind.SlashSlash)
			{
				scanner.NextLex();
				qilNode = ptrnBuilder.JoinStep(qilNode, ptrnBuilder.JoinStep(ptrnBuilder.Axis(XPathAxis.DescendantOrSelf, XPathNodeType.All, null, null), ParseRelativePathPattern()));
			}
			parseRelativePath--;
			return qilNode;
		}

		private QilNode ParseStepPattern()
		{
			XPathAxis xPathAxis;
			switch (scanner.Kind)
			{
			case LexKind.Dot:
			case LexKind.DotDot:
				throw scanner.CreateException("XPath_InvalidAxisInPattern");
			case LexKind.At:
				xPathAxis = XPathAxis.Attribute;
				scanner.NextLex();
				break;
			case LexKind.Axis:
				xPathAxis = XPathParser<QilNode>.GetAxis(scanner.Name, scanner);
				if (xPathAxis != XPathAxis.Child && xPathAxis != XPathAxis.Attribute)
				{
					throw scanner.CreateException("XPath_InvalidAxisInPattern");
				}
				scanner.NextLex();
				break;
			case LexKind.Star:
			case LexKind.Name:
				xPathAxis = XPathAxis.Child;
				break;
			default:
				throw scanner.CreateException("XPath_UnexpectedToken", scanner.RawValue);
			}
			XPathParser<QilNode>.InternalParseNodeTest(scanner, xPathAxis, out var nodeType, out var nodePrefix, out var nodeName);
			QilNode qilNode = ptrnBuilder.Axis(xPathAxis, nodeType, nodePrefix, nodeName);
			while (scanner.Kind == LexKind.LBracket)
			{
				qilNode = ptrnBuilder.Predicate(qilNode, ParsePredicate(qilNode), reverseStep: false);
			}
			return qilNode;
		}

		private QilNode ParsePredicate(QilNode context)
		{
			scanner.NextLex();
			QilNode result = predicateParser.Parse(scanner, ptrnBuilder.GetPredicateBuilder(context), LexKind.RBracket);
			scanner.NextLex();
			return result;
		}
	}
	internal class KeyMatchBuilder : XPathBuilder, XPathPatternParser.IPatternBuilder, IXPathBuilder<QilNode>
	{
		internal class PathConvertor : QilReplaceVisitor
		{
			private new XPathQilFactory f;

			private QilNode fixup;

			public PathConvertor(XPathQilFactory f)
				: base(f.BaseFactory)
			{
				this.f = f;
			}

			public QilNode ConvertReletive2Absolute(QilNode node, QilNode fixup)
			{
				QilDepthChecker.Check(node);
				this.fixup = fixup;
				return Visit(node);
			}

			protected override QilNode Visit(QilNode n)
			{
				if (n.NodeType == QilNodeType.Union || n.NodeType == QilNodeType.DocOrderDistinct || n.NodeType == QilNodeType.Filter || n.NodeType == QilNodeType.Loop)
				{
					return base.Visit(n);
				}
				return n;
			}

			protected override QilNode VisitLoop(QilLoop n)
			{
				if (n.Variable.Binding.NodeType == QilNodeType.Root || n.Variable.Binding.NodeType == QilNodeType.Deref)
				{
					return n;
				}
				if (n.Variable.Binding.NodeType == QilNodeType.Content)
				{
					QilUnary qilUnary = (QilUnary)n.Variable.Binding;
					QilIterator variable = (QilIterator)(qilUnary.Child = f.For(f.DescendantOrSelf(f.Root(fixup))));
					n.Variable.Binding = f.Loop(variable, qilUnary);
					return n;
				}
				n.Variable.Binding = Visit(n.Variable.Binding);
				return n;
			}

			protected override QilNode VisitFilter(QilLoop n)
			{
				return VisitLoop(n);
			}
		}

		private int depth;

		private PathConvertor convertor;

		public KeyMatchBuilder(IXPathEnvironment env)
			: base(env)
		{
			convertor = new PathConvertor(env.Factory);
		}

		public override void StartBuild()
		{
			if (depth == 0)
			{
				base.StartBuild();
			}
			depth++;
		}

		public override QilNode EndBuild(QilNode result)
		{
			depth--;
			if (result == null)
			{
				return base.EndBuild(result);
			}
			if (depth == 0)
			{
				result = convertor.ConvertReletive2Absolute(result, fixupCurrent);
				result = base.EndBuild(result);
			}
			return result;
		}

		public virtual IXPathBuilder<QilNode> GetPredicateBuilder(QilNode ctx)
		{
			return this;
		}
	}
	internal class KeywordsTable
	{
		public string ApplyImports;

		public string ApplyTemplates;

		public string Assembly;

		public string Attribute;

		public string AttributeSet;

		public string CallTemplate;

		public string CaseOrder;

		public string CDataSectionElements;

		public string Choose;

		public string Comment;

		public string Copy;

		public string CopyOf;

		public string Count;

		public string DataType;

		public string DecimalFormat;

		public string DecimalSeparator;

		public string Digit;

		public string DisableOutputEscaping;

		public string DocTypePublic;

		public string DocTypeSystem;

		public string Element;

		public string Elements;

		public string Encoding;

		public string ExcludeResultPrefixes;

		public string ExtensionElementPrefixes;

		public string Fallback;

		public string ForEach;

		public string Format;

		public string From;

		public string GroupingSeparator;

		public string GroupingSize;

		public string Href;

		public string Id;

		public string If;

		public string ImplementsPrefix;

		public string Import;

		public string Include;

		public string Indent;

		public string Infinity;

		public string Key;

		public string Lang;

		public string Language;

		public string LetterValue;

		public string Level;

		public string Match;

		public string MediaType;

		public string Message;

		public string Method;

		public string MinusSign;

		public string Mode;

		public string Name;

		public string Namespace;

		public string NamespaceAlias;

		public string NaN;

		public string Number;

		public string OmitXmlDeclaration;

		public string Order;

		public string Otherwise;

		public string Output;

		public string Param;

		public string PatternSeparator;

		public string Percent;

		public string PerMille;

		public string PreserveSpace;

		public string Priority;

		public string ProcessingInstruction;

		public string ResultPrefix;

		public string Script;

		public string Select;

		public string Sort;

		public string Space;

		public string Standalone;

		public string StripSpace;

		public string Stylesheet;

		public string StylesheetPrefix;

		public string Template;

		public string Terminate;

		public string Test;

		public string Text;

		public string Transform;

		public string UrnMsxsl;

		public string UriXml;

		public string UriXsl;

		public string UriWdXsl;

		public string Use;

		public string UseAttributeSets;

		public string Using;

		public string Value;

		public string ValueOf;

		public string Variable;

		public string Version;

		public string When;

		public string WithParam;

		public string Xml;

		public string ZeroDigit;

		public KeywordsTable(XmlNameTable nt)
		{
			ApplyImports = nt.Add("apply-imports");
			ApplyTemplates = nt.Add("apply-templates");
			Assembly = nt.Add("assembly");
			Attribute = nt.Add("attribute");
			AttributeSet = nt.Add("attribute-set");
			CallTemplate = nt.Add("call-template");
			CaseOrder = nt.Add("case-order");
			CDataSectionElements = nt.Add("cdata-section-elements");
			Choose = nt.Add("choose");
			Comment = nt.Add("comment");
			Copy = nt.Add("copy");
			CopyOf = nt.Add("copy-of");
			Count = nt.Add("count");
			DataType = nt.Add("data-type");
			DecimalFormat = nt.Add("decimal-format");
			DecimalSeparator = nt.Add("decimal-separator");
			Digit = nt.Add("digit");
			DisableOutputEscaping = nt.Add("disable-output-escaping");
			DocTypePublic = nt.Add("doctype-public");
			DocTypeSystem = nt.Add("doctype-system");
			Element = nt.Add("element");
			Elements = nt.Add("elements");
			Encoding = nt.Add("encoding");
			ExcludeResultPrefixes = nt.Add("exclude-result-prefixes");
			ExtensionElementPrefixes = nt.Add("extension-element-prefixes");
			Fallback = nt.Add("fallback");
			ForEach = nt.Add("for-each");
			Format = nt.Add("format");
			From = nt.Add("from");
			GroupingSeparator = nt.Add("grouping-separator");
			GroupingSize = nt.Add("grouping-size");
			Href = nt.Add("href");
			Id = nt.Add("id");
			If = nt.Add("if");
			ImplementsPrefix = nt.Add("implements-prefix");
			Import = nt.Add("import");
			Include = nt.Add("include");
			Indent = nt.Add("indent");
			Infinity = nt.Add("infinity");
			Key = nt.Add("key");
			Lang = nt.Add("lang");
			Language = nt.Add("language");
			LetterValue = nt.Add("letter-value");
			Level = nt.Add("level");
			Match = nt.Add("match");
			MediaType = nt.Add("media-type");
			Message = nt.Add("message");
			Method = nt.Add("method");
			MinusSign = nt.Add("minus-sign");
			Mode = nt.Add("mode");
			Name = nt.Add("name");
			Namespace = nt.Add("namespace");
			NamespaceAlias = nt.Add("namespace-alias");
			NaN = nt.Add("NaN");
			Number = nt.Add("number");
			OmitXmlDeclaration = nt.Add("omit-xml-declaration");
			Otherwise = nt.Add("otherwise");
			Order = nt.Add("order");
			Output = nt.Add("output");
			Param = nt.Add("param");
			PatternSeparator = nt.Add("pattern-separator");
			Percent = nt.Add("percent");
			PerMille = nt.Add("per-mille");
			PreserveSpace = nt.Add("preserve-space");
			Priority = nt.Add("priority");
			ProcessingInstruction = nt.Add("processing-instruction");
			ResultPrefix = nt.Add("result-prefix");
			Script = nt.Add("script");
			Select = nt.Add("select");
			Sort = nt.Add("sort");
			Space = nt.Add("space");
			Standalone = nt.Add("standalone");
			StripSpace = nt.Add("strip-space");
			Stylesheet = nt.Add("stylesheet");
			StylesheetPrefix = nt.Add("stylesheet-prefix");
			Template = nt.Add("template");
			Terminate = nt.Add("terminate");
			Test = nt.Add("test");
			Text = nt.Add("text");
			Transform = nt.Add("transform");
			UrnMsxsl = nt.Add("urn:schemas-microsoft-com:xslt");
			UriXml = nt.Add("http://www.w3.org/XML/1998/namespace");
			UriXsl = nt.Add("http://www.w3.org/1999/XSL/Transform");
			UriWdXsl = nt.Add("http://www.w3.org/TR/WD-xsl");
			Use = nt.Add("use");
			UseAttributeSets = nt.Add("use-attribute-sets");
			Using = nt.Add("using");
			Value = nt.Add("value");
			ValueOf = nt.Add("value-of");
			Variable = nt.Add("variable");
			Version = nt.Add("version");
			When = nt.Add("when");
			WithParam = nt.Add("with-param");
			Xml = nt.Add("xml");
			ZeroDigit = nt.Add("zero-digit");
		}
	}
	internal class TemplateMatch
	{
		internal class TemplateMatchComparer : IComparer<TemplateMatch>
		{
			public int Compare(TemplateMatch x, TemplateMatch y)
			{
				if (!(x.priority > y.priority))
				{
					if (!(x.priority < y.priority))
					{
						return x.template.OrderNumber - y.template.OrderNumber;
					}
					return -1;
				}
				return 1;
			}
		}

		public static readonly TemplateMatchComparer Comparer = new TemplateMatchComparer();

		private Template template;

		private double priority;

		private XmlNodeKindFlags nodeKind;

		private QilName qname;

		private QilIterator iterator;

		private QilNode condition;

		public XmlNodeKindFlags NodeKind => nodeKind;

		public QilName QName => qname;

		public QilIterator Iterator => iterator;

		public QilNode Condition => condition;

		public QilFunction TemplateFunction => template.Function;

		public TemplateMatch(Template template, QilLoop filter)
		{
			this.template = template;
			priority = (double.IsNaN(template.Priority) ? XPathPatternBuilder.GetPriority(filter) : template.Priority);
			iterator = filter.Variable;
			condition = filter.Body;
			XPathPatternBuilder.CleanAnnotation(filter);
			NipOffTypeNameCheck();
		}

		private void NipOffTypeNameCheck()
		{
			QilBinary[] array = new QilBinary[4];
			int num = -1;
			QilNode left = condition;
			nodeKind = XmlNodeKindFlags.None;
			qname = null;
			while (left.NodeType == QilNodeType.And)
			{
				left = (array[++num & 3] = (QilBinary)left).Left;
			}
			if (left.NodeType != QilNodeType.IsType)
			{
				return;
			}
			QilBinary qilBinary = (QilBinary)left;
			if (qilBinary.Left != iterator || qilBinary.Right.NodeType != QilNodeType.LiteralType)
			{
				return;
			}
			XmlNodeKindFlags nodeKinds = qilBinary.Right.XmlType.NodeKinds;
			if (!Bits.ExactlyOne((uint)nodeKinds))
			{
				return;
			}
			nodeKind = nodeKinds;
			QilBinary qilBinary2 = array[num & 3];
			if (qilBinary2 != null && qilBinary2.Right.NodeType == QilNodeType.Eq)
			{
				QilBinary qilBinary3 = (QilBinary)qilBinary2.Right;
				if (qilBinary3.Left.NodeType == QilNodeType.NameOf && ((QilUnary)qilBinary3.Left).Child == iterator && qilBinary3.Right.NodeType == QilNodeType.LiteralQName)
				{
					qname = (QilName)((QilLiteral)qilBinary3.Right).Value;
					num--;
				}
			}
			QilBinary qilBinary4 = array[num & 3];
			QilBinary qilBinary5 = array[--num & 3];
			if (qilBinary5 != null)
			{
				qilBinary5.Left = qilBinary4.Right;
			}
			else if (qilBinary4 != null)
			{
				condition = qilBinary4.Right;
			}
			else
			{
				condition = null;
			}
		}
	}
	internal struct Pattern
	{
		public readonly TemplateMatch Match;

		public readonly int Priority;

		public Pattern(TemplateMatch match, int priority)
		{
			Match = match;
			Priority = priority;
		}
	}
	internal class PatternBag
	{
		public Dictionary<QilName, List<Pattern>> FixedNamePatterns = new Dictionary<QilName, List<Pattern>>();

		public List<QilName> FixedNamePatternsNames = new List<QilName>();

		public List<Pattern> NonFixedNamePatterns = new List<Pattern>();

		public void Clear()
		{
			FixedNamePatterns.Clear();
			FixedNamePatternsNames.Clear();
			NonFixedNamePatterns.Clear();
		}

		public void Add(Pattern pattern)
		{
			QilName qName = pattern.Match.QName;
			List<Pattern> value;
			if (qName == null)
			{
				value = NonFixedNamePatterns;
			}
			else if (!FixedNamePatterns.TryGetValue(qName, out value))
			{
				FixedNamePatternsNames.Add(qName);
				List<Pattern> list2 = (FixedNamePatterns[qName] = new List<Pattern>());
				value = list2;
			}
			value.Add(pattern);
		}
	}
	internal class MatcherBuilder
	{
		private const int NoMatch = -1;

		private XPathQilFactory f;

		private ReferenceReplacer refReplacer;

		private InvokeGenerator invkGen;

		private int priority = -1;

		private PatternBag elementPatterns = new PatternBag();

		private PatternBag attributePatterns = new PatternBag();

		private List<Pattern> textPatterns = new List<Pattern>();

		private List<Pattern> documentPatterns = new List<Pattern>();

		private List<Pattern> commentPatterns = new List<Pattern>();

		private PatternBag piPatterns = new PatternBag();

		private List<Pattern> heterogenousPatterns = new List<Pattern>();

		private List<List<TemplateMatch>> allMatches = new List<List<TemplateMatch>>();

		public MatcherBuilder(XPathQilFactory f, ReferenceReplacer refReplacer, InvokeGenerator invkGen)
		{
			this.f = f;
			this.refReplacer = refReplacer;
			this.invkGen = invkGen;
		}

		private void Clear()
		{
			priority = -1;
			elementPatterns.Clear();
			attributePatterns.Clear();
			textPatterns.Clear();
			documentPatterns.Clear();
			commentPatterns.Clear();
			piPatterns.Clear();
			heterogenousPatterns.Clear();
			allMatches.Clear();
		}

		private void AddPatterns(List<TemplateMatch> matches)
		{
			foreach (TemplateMatch match in matches)
			{
				Pattern pattern = new Pattern(match, ++priority);
				switch (match.NodeKind)
				{
				case XmlNodeKindFlags.Element:
					elementPatterns.Add(pattern);
					break;
				case XmlNodeKindFlags.Attribute:
					attributePatterns.Add(pattern);
					break;
				case XmlNodeKindFlags.Text:
					textPatterns.Add(pattern);
					break;
				case XmlNodeKindFlags.Document:
					documentPatterns.Add(pattern);
					break;
				case XmlNodeKindFlags.Comment:
					commentPatterns.Add(pattern);
					break;
				case XmlNodeKindFlags.PI:
					piPatterns.Add(pattern);
					break;
				default:
					heterogenousPatterns.Add(pattern);
					break;
				}
			}
		}

		private void CollectPatterns(Stylesheet sheet, QilName mode)
		{
			Stylesheet[] imports = sheet.Imports;
			foreach (Stylesheet sheet2 in imports)
			{
				CollectPatterns(sheet2, mode);
			}
			if (sheet.TemplateMatches.TryGetValue(mode, out var value))
			{
				AddPatterns(value);
				allMatches.Add(value);
			}
		}

		public void CollectPatterns(Stylesheet sheet, QilName mode, bool applyImports)
		{
			Clear();
			if (applyImports)
			{
				Stylesheet[] imports = sheet.Imports;
				foreach (Stylesheet sheet2 in imports)
				{
					CollectPatterns(sheet2, mode);
				}
			}
			else
			{
				CollectPatterns(sheet, mode);
			}
		}

		private QilNode MatchPattern(QilIterator it, TemplateMatch match)
		{
			QilNode condition = match.Condition;
			if (condition == null)
			{
				return f.True();
			}
			condition = condition.DeepClone(f.BaseFactory);
			return refReplacer.Replace(condition, match.Iterator, it);
		}

		private QilNode MatchPatterns(QilIterator it, List<Pattern> patternList)
		{
			QilNode qilNode = f.Int32(-1);
			foreach (Pattern pattern in patternList)
			{
				qilNode = f.Conditional(MatchPattern(it, pattern.Match), f.Int32(pattern.Priority), qilNode);
			}
			return qilNode;
		}

		private QilNode MatchPatterns(QilIterator it, XmlQueryType xt, List<Pattern> patternList, QilNode otherwise)
		{
			if (patternList.Count == 0)
			{
				return otherwise;
			}
			return f.Conditional(f.IsType(it, xt), MatchPatterns(it, patternList), otherwise);
		}

		private bool IsNoMatch(QilNode matcher)
		{
			if (matcher.NodeType == QilNodeType.LiteralInt32)
			{
				return true;
			}
			return false;
		}

		private QilNode MatchPatternsWhosePriorityGreater(QilIterator it, List<Pattern> patternList, QilNode matcher)
		{
			if (patternList.Count == 0)
			{
				return matcher;
			}
			if (IsNoMatch(matcher))
			{
				return MatchPatterns(it, patternList);
			}
			QilIterator qilIterator = f.Let(matcher);
			QilNode qilNode = f.Int32(-1);
			int num = -1;
			foreach (Pattern pattern in patternList)
			{
				if (pattern.Priority > num + 1)
				{
					qilNode = f.Conditional(f.Gt(qilIterator, f.Int32(num)), qilIterator, qilNode);
				}
				qilNode = f.Conditional(MatchPattern(it, pattern.Match), f.Int32(pattern.Priority), qilNode);
				num = pattern.Priority;
			}
			if (num != priority)
			{
				qilNode = f.Conditional(f.Gt(qilIterator, f.Int32(num)), qilIterator, qilNode);
			}
			return f.Loop(qilIterator, qilNode);
		}

		private QilNode MatchPatterns(QilIterator it, XmlQueryType xt, PatternBag patternBag, QilNode otherwise)
		{
			if (patternBag.FixedNamePatternsNames.Count == 0)
			{
				return MatchPatterns(it, xt, patternBag.NonFixedNamePatterns, otherwise);
			}
			QilNode qilNode = f.Int32(-1);
			foreach (QilName fixedNamePatternsName in patternBag.FixedNamePatternsNames)
			{
				qilNode = f.Conditional(f.Eq(f.NameOf(it), fixedNamePatternsName.ShallowClone(f.BaseFactory)), MatchPatterns(it, patternBag.FixedNamePatterns[fixedNamePatternsName]), qilNode);
			}
			qilNode = MatchPatternsWhosePriorityGreater(it, patternBag.NonFixedNamePatterns, qilNode);
			return f.Conditional(f.IsType(it, xt), qilNode, otherwise);
		}

		public QilNode BuildMatcher(QilIterator it, IList<XslNode> actualArgs, QilNode otherwise)
		{
			QilNode otherwise2 = f.Int32(-1);
			otherwise2 = MatchPatterns(it, XmlQueryTypeFactory.PI, piPatterns, otherwise2);
			otherwise2 = MatchPatterns(it, XmlQueryTypeFactory.Comment, commentPatterns, otherwise2);
			otherwise2 = MatchPatterns(it, XmlQueryTypeFactory.Document, documentPatterns, otherwise2);
			otherwise2 = MatchPatterns(it, XmlQueryTypeFactory.Text, textPatterns, otherwise2);
			otherwise2 = MatchPatterns(it, XmlQueryTypeFactory.Attribute, attributePatterns, otherwise2);
			otherwise2 = MatchPatterns(it, XmlQueryTypeFactory.Element, elementPatterns, otherwise2);
			otherwise2 = MatchPatternsWhosePriorityGreater(it, heterogenousPatterns, otherwise2);
			if (IsNoMatch(otherwise2))
			{
				return otherwise;
			}
			QilNode[] array = new QilNode[priority + 2];
			int num = -1;
			foreach (List<TemplateMatch> allMatch in allMatches)
			{
				foreach (TemplateMatch item in allMatch)
				{
					array[++num] = invkGen.GenerateInvoke(item.TemplateFunction, actualArgs);
				}
			}
			array[++num] = otherwise;
			return f.Choice(otherwise2, f.BranchList(array));
		}
	}
	internal class OutputScopeManager
	{
		public struct ScopeReord
		{
			public int scopeCount;

			public string prefix;

			public string nsUri;
		}

		private ScopeReord[] records = new ScopeReord[32];

		private int lastRecord;

		private int lastScopes;

		public OutputScopeManager()
		{
			Reset();
		}

		public void Reset()
		{
			records[0].prefix = null;
			records[0].nsUri = null;
			PushScope();
		}

		public void PushScope()
		{
			lastScopes++;
		}

		public void PopScope()
		{
			if (0 < lastScopes)
			{
				lastScopes--;
				return;
			}
			while (records[--lastRecord].scopeCount == 0)
			{
			}
			lastScopes = records[lastRecord].scopeCount;
			lastScopes--;
		}

		public void AddNamespace(string prefix, string uri)
		{
			AddRecord(prefix, uri);
		}

		private void AddRecord(string prefix, string uri)
		{
			records[lastRecord].scopeCount = lastScopes;
			lastRecord++;
			if (lastRecord == records.Length)
			{
				ScopeReord[] destinationArray = new ScopeReord[lastRecord * 2];
				Array.Copy(records, 0, destinationArray, 0, lastRecord);
				records = destinationArray;
			}
			lastScopes = 0;
			records[lastRecord].prefix = prefix;
			records[lastRecord].nsUri = uri;
		}

		public void InvalidateAllPrefixes()
		{
			if (records[lastRecord].prefix != null)
			{
				AddRecord(null, null);
			}
		}

		public void InvalidateNonDefaultPrefixes()
		{
			string text = LookupNamespace(string.Empty);
			if (text == null)
			{
				InvalidateAllPrefixes();
			}
			else if (records[lastRecord].prefix.Length != 0 || records[lastRecord - 1].prefix != null)
			{
				AddRecord(null, null);
				AddRecord(string.Empty, text);
			}
		}

		public string LookupNamespace(string prefix)
		{
			int num = lastRecord;
			while (records[num].prefix != null)
			{
				if (records[num].prefix == prefix)
				{
					return records[num].nsUri;
				}
				num--;
			}
			return null;
		}
	}
	internal class ReferenceReplacer : QilReplaceVisitor
	{
		private QilReference lookFor;

		private QilReference replaceBy;

		public ReferenceReplacer(QilFactory f)
			: base(f)
		{
		}

		public QilNode Replace(QilNode expr, QilReference lookFor, QilReference replaceBy)
		{
			QilDepthChecker.Check(expr);
			this.lookFor = lookFor;
			this.replaceBy = replaceBy;
			return VisitAssumeReference(expr);
		}

		protected override QilNode VisitReference(QilNode n)
		{
			if (n != lookFor)
			{
				return n;
			}
			return replaceBy;
		}
	}
	internal class QilGenerator : IErrorHelper, IXPathEnvironment, IFocus
	{
		private class VariableHelper
		{
			private Stack<QilIterator> vars = new Stack<QilIterator>();

			private XPathQilFactory f;

			public VariableHelper(XPathQilFactory f)
			{
				this.f = f;
			}

			public int StartVariables()
			{
				return vars.Count;
			}

			public void AddVariable(QilIterator let)
			{
				vars.Push(let);
			}

			public QilNode FinishVariables(QilNode node, int varScope)
			{
				int num = vars.Count - varScope;
				while (num-- != 0)
				{
					node = f.Loop(vars.Pop(), node);
				}
				return node;
			}

			[Conditional("DEBUG")]
			public void CheckEmpty()
			{
			}
		}

		[StructLayout(LayoutKind.Sequential, Size = 1)]
		private struct ThrowErrorHelper : IErrorHelper
		{
			public void ReportError(string res, params string[] args)
			{
				throw new XslLoadException("Xml_UserException", res);
			}

			public void ReportWarning(string res, params string[] args)
			{
			}
		}

		public enum FuncId
		{
			Current,
			Document,
			Key,
			FormatNumber,
			UnparsedEntityUri,
			GenerateId,
			SystemProperty,
			ElementAvailable,
			FunctionAvailable
		}

		private const XmlNodeKindFlags InvalidatingNodes = XmlNodeKindFlags.Attribute | XmlNodeKindFlags.Namespace;

		private CompilerScopeManager<QilIterator> scope;

		private OutputScopeManager outputScope;

		private HybridDictionary prefixesInUse;

		private XsltQilFactory f;

		private XPathBuilder xpathBuilder;

		private XPathParser<QilNode> xpathParser;

		private XPathPatternBuilder ptrnBuilder;

		private XPathPatternParser ptrnParser;

		private ReferenceReplacer refReplacer;

		private KeyMatchBuilder keyMatchBuilder;

		private InvokeGenerator invkGen;

		private MatcherBuilder matcherBuilder;

		private QilStrConcatenator strConcat;

		private VariableHelper varHelper;

		private Compiler compiler;

		private QilList functions;

		private QilFunction generalKey;

		private bool formatNumberDynamicUsed;

		private QilList extPars;

		private QilList gloVars;

		private QilList nsVars;

		private XmlQueryType elementOrDocumentType;

		private XmlQueryType textOrAttributeType;

		private XslNode lastScope;

		private XslVersion xslVersion;

		private QilName nameCurrent;

		private QilName namePosition;

		private QilName nameLast;

		private QilName nameNamespaces;

		private SingletonFocus singlFocus;

		private FunctionFocus funcFocus;

		private LoopFocus curLoop;

		private int formatterCnt;

		private readonly StringBuilder unescapedText = new StringBuilder();

		private static readonly char[] curlyBraces = new char[2] { '{', '}' };

		private bool allowVariables = true;

		private bool allowCurrent = true;

		private bool allowKey = true;

		private static readonly XmlTypeCode[] argFnDocument = new XmlTypeCode[2]
		{
			XmlTypeCode.Item,
			XmlTypeCode.Node
		};

		private static readonly XmlTypeCode[] argFnKey = new XmlTypeCode[2]
		{
			XmlTypeCode.String,
			XmlTypeCode.Item
		};

		private static readonly XmlTypeCode[] argFnFormatNumber = new XmlTypeCode[3]
		{
			XmlTypeCode.Double,
			XmlTypeCode.String,
			XmlTypeCode.String
		};

		public static Dictionary<string, XPathBuilder.FunctionInfo<FuncId>> FunctionTable = CreateFunctionTable();

		private bool IsDebug => compiler.IsDebug;

		private bool EvaluateFuncCalls => !IsDebug;

		private bool InferXPathTypes => !IsDebug;

		XPathQilFactory IXPathEnvironment.Factory => f;

		public static QilExpression CompileStylesheet(Compiler compiler)
		{
			return new QilGenerator(compiler.IsDebug).Compile(compiler);
		}

		private QilGenerator(bool debug)
		{
			scope = new CompilerScopeManager<QilIterator>();
			outputScope = new OutputScopeManager();
			prefixesInUse = new HybridDictionary();
			f = new XsltQilFactory(new QilFactory(), debug);
			xpathBuilder = new XPathBuilder(this);
			xpathParser = new XPathParser<QilNode>();
			ptrnBuilder = new XPathPatternBuilder(this);
			ptrnParser = new XPathPatternParser();
			refReplacer = new ReferenceReplacer(f.BaseFactory);
			invkGen = new InvokeGenerator(f, debug);
			matcherBuilder = new MatcherBuilder(f, refReplacer, invkGen);
			singlFocus = new SingletonFocus(f);
			funcFocus = default(FunctionFocus);
			curLoop = new LoopFocus(f);
			strConcat = new QilStrConcatenator(f);
			varHelper = new VariableHelper(f);
			elementOrDocumentType = XmlQueryTypeFactory.DocumentOrElement;
			textOrAttributeType = XmlQueryTypeFactory.NodeChoice(XmlNodeKindFlags.Attribute | XmlNodeKindFlags.Text);
			nameCurrent = f.QName("current", "urn:schemas-microsoft-com:xslt-debug");
			namePosition = f.QName("position", "urn:schemas-microsoft-com:xslt-debug");
			nameLast = f.QName("last", "urn:schemas-microsoft-com:xslt-debug");
			nameNamespaces = f.QName("namespaces", "urn:schemas-microsoft-com:xslt-debug");
			formatterCnt = 0;
		}

		private QilExpression Compile(Compiler compiler)
		{
			this.compiler = compiler;
			functions = f.FunctionList();
			extPars = f.GlobalParameterList();
			gloVars = f.GlobalVariableList();
			nsVars = f.GlobalVariableList();
			compiler.Scripts.CompileScripts();
			if (!IsDebug)
			{
				new XslAstAnalyzer().Analyze(compiler);
			}
			CreateGlobalVarPars();
			try
			{
				CompileKeys();
				CompileAndSortMatches(compiler.PrincipalStylesheet);
				PrecompileProtoTemplatesHeaders();
				CompileGlobalVariables();
				foreach (ProtoTemplate allTemplate in compiler.AllTemplates)
				{
					CompileProtoTemplate(allTemplate);
				}
			}
			catch (XslLoadException ex)
			{
				ex.SetSourceLineInfo(lastScope.SourceLine);
				throw;
			}
			catch (Exception ex2)
			{
				if (!XmlException.IsCatchableException(ex2))
				{
					throw;
				}
				throw new XslLoadException(ex2, lastScope.SourceLine);
			}
			QilNode root = CompileRootExpression(compiler.StartApplyTemplates);
			foreach (ProtoTemplate allTemplate2 in compiler.AllTemplates)
			{
				foreach (QilParameter argument in allTemplate2.Function.Arguments)
				{
					if (!IsDebug || argument.Name.Equals(nameNamespaces))
					{
						argument.DefaultValue = null;
					}
				}
			}
			Dictionary<string, Type> scriptClasses = compiler.Scripts.ScriptClasses;
			List<EarlyBoundInfo> list = new List<EarlyBoundInfo>(scriptClasses.Count);
			foreach (KeyValuePair<string, Type> item in scriptClasses)
			{
				if (item.Value != null)
				{
					list.Add(new EarlyBoundInfo(item.Key, item.Value));
				}
			}
			QilExpression qilExpression = f.QilExpression(root, f.BaseFactory);
			qilExpression.EarlyBoundTypes = list;
			qilExpression.FunctionList = functions;
			qilExpression.GlobalParameterList = extPars;
			qilExpression.GlobalVariableList = gloVars;
			qilExpression.WhitespaceRules = compiler.WhitespaceRules;
			qilExpression.IsDebug = IsDebug;
			qilExpression.DefaultWriterSettings = compiler.Output.Settings;
			QilDepthChecker.Check(qilExpression);
			return qilExpression;
		}

		private QilNode InvokeOnCurrentNodeChanged()
		{
			return f.Loop(f.Let(f.InvokeOnCurrentNodeChanged(curLoop.GetCurrent())), f.Sequence());
		}

		[Conditional("DEBUG")]
		private void CheckSingletonFocus()
		{
		}

		private QilNode CompileRootExpression(XslNode applyTmpls)
		{
			QilNode qilNode = f.Int32(0);
			if (formatNumberDynamicUsed || IsDebug)
			{
				foreach (DecimalFormatDecl decimalFormat in compiler.DecimalFormats)
				{
					qilNode = f.Add(qilNode, f.InvokeRegisterDecimalFormat(decimalFormat));
				}
			}
			foreach (string key in compiler.Scripts.ScriptClasses.Keys)
			{
				qilNode = f.Add(qilNode, f.InvokeCheckScriptNamespace(key));
			}
			singlFocus.SetFocus(SingletonFocusType.InitialContextNode);
			QilNode qilNode2 = GenerateApply(null, applyTmpls);
			singlFocus.SetFocus(null);
			if (qilNode.NodeType == QilNodeType.Add)
			{
				qilNode2 = f.Conditional(f.Eq(qilNode, f.Int32(0)), qilNode2, f.Sequence());
			}
			return f.DocumentCtor(qilNode2);
		}

		private QilList EnterScope(XslNode node)
		{
			lastScope = node;
			xslVersion = node.XslVersion;
			scope.PushScope();
			bool flag = false;
			NsDecl nsDecl = node.Namespaces;
			while (nsDecl != null)
			{
				scope.AddNamespace(nsDecl.Prefix, nsDecl.NsUri);
				nsDecl = nsDecl.Prev;
				flag = true;
			}
			if (flag)
			{
				return BuildDebuggerNamespaces();
			}
			return null;
		}

		private void ExitScope()
		{
			scope.PopScope();
		}

		private QilList BuildDebuggerNamespaces()
		{
			if (IsDebug)
			{
				QilList qilList = f.BaseFactory.Sequence();
				{
					foreach (CompilerScopeManager<QilIterator>.ScopeRecord item in (IEnumerable)scope)
					{
						qilList.Add(f.NamespaceDecl(f.String(item.ncName), f.String(item.nsUri)));
					}
					return qilList;
				}
			}
			return null;
		}

		private QilNode GetCurrentNode()
		{
			if (curLoop.IsFocusSet)
			{
				return curLoop.GetCurrent();
			}
			if (funcFocus.IsFocusSet)
			{
				return funcFocus.GetCurrent();
			}
			return singlFocus.GetCurrent();
		}

		private QilNode GetCurrentPosition()
		{
			if (curLoop.IsFocusSet)
			{
				return curLoop.GetPosition();
			}
			if (funcFocus.IsFocusSet)
			{
				return funcFocus.GetPosition();
			}
			return singlFocus.GetPosition();
		}

		private QilNode GetLastPosition()
		{
			if (curLoop.IsFocusSet)
			{
				return curLoop.GetLast();
			}
			if (funcFocus.IsFocusSet)
			{
				return funcFocus.GetLast();
			}
			return singlFocus.GetLast();
		}

		private XmlQueryType ChooseBestType(VarPar var)
		{
			if (IsDebug || !InferXPathTypes)
			{
				return XmlQueryTypeFactory.ItemS;
			}
			return (var.Flags & XslFlags.TypeFilter) switch
			{
				XslFlags.String => XmlQueryTypeFactory.StringX, 
				XslFlags.Number => XmlQueryTypeFactory.DoubleX, 
				XslFlags.Boolean => XmlQueryTypeFactory.BooleanX, 
				XslFlags.Node => XmlQueryTypeFactory.NodeNotRtf, 
				XslFlags.Nodeset => XmlQueryTypeFactory.NodeNotRtfS, 
				XslFlags.Rtf => XmlQueryTypeFactory.Node, 
				XslFlags.Node | XslFlags.Rtf => XmlQueryTypeFactory.Node, 
				XslFlags.Node | XslFlags.Nodeset => XmlQueryTypeFactory.NodeNotRtfS, 
				XslFlags.Nodeset | XslFlags.Rtf => XmlQueryTypeFactory.NodeS, 
				XslFlags.Node | XslFlags.Nodeset | XslFlags.Rtf => XmlQueryTypeFactory.NodeS, 
				_ => XmlQueryTypeFactory.ItemS, 
			};
		}

		private QilIterator GetNsVar(QilList nsList)
		{
			foreach (QilIterator nsVar in nsVars)
			{
				QilList qilList = (QilList)nsVar.Binding;
				if (qilList.Count != nsList.Count)
				{
					continue;
				}
				bool flag = true;
				for (int i = 0; i < nsList.Count; i++)
				{
					if (((QilLiteral)((QilBinary)nsList[i]).Right).Value != ((QilLiteral)((QilBinary)qilList[i]).Right).Value || ((QilLiteral)((QilBinary)nsList[i]).Left).Value != ((QilLiteral)((QilBinary)qilList[i]).Left).Value)
					{
						flag = false;
						break;
					}
				}
				if (flag)
				{
					return nsVar;
				}
			}
			QilIterator qilIterator2 = f.Let(nsList);
			qilIterator2.DebugName = f.QName("ns" + nsVars.Count, "urn:schemas-microsoft-com:xslt-debug").ToString();
			gloVars.Add(qilIterator2);
			nsVars.Add(qilIterator2);
			return qilIterator2;
		}

		private void PrecompileProtoTemplatesHeaders()
		{
			List<VarPar> list = null;
			Dictionary<VarPar, Template> dictionary = null;
			Dictionary<VarPar, QilFunction> dictionary2 = null;
			foreach (ProtoTemplate allTemplate in compiler.AllTemplates)
			{
				QilList qilList = f.FormalParameterList();
				XslFlags xslFlags = ((!IsDebug) ? allTemplate.Flags : XslFlags.FocusFilter);
				QilList qilList2 = EnterScope(allTemplate);
				if ((xslFlags & XslFlags.Current) != 0)
				{
					qilList.Add(CreateXslParam(CloneName(nameCurrent), XmlQueryTypeFactory.NodeNotRtf));
				}
				if ((xslFlags & XslFlags.Position) != 0)
				{
					qilList.Add(CreateXslParam(CloneName(namePosition), XmlQueryTypeFactory.DoubleX));
				}
				if ((xslFlags & XslFlags.Last) != 0)
				{
					qilList.Add(CreateXslParam(CloneName(nameLast), XmlQueryTypeFactory.DoubleX));
				}
				if (IsDebug && qilList2 != null)
				{
					QilParameter qilParameter = CreateXslParam(CloneName(nameNamespaces), XmlQueryTypeFactory.NamespaceS);
					qilParameter.DefaultValue = GetNsVar(qilList2);
					qilList.Add(qilParameter);
				}
				if (allTemplate is Template template)
				{
					funcFocus.StartFocus(qilList, xslFlags);
					for (int i = 0; i < allTemplate.Content.Count; i++)
					{
						XslNode xslNode = allTemplate.Content[i];
						if (xslNode.NodeType == XslNodeType.Text)
						{
							continue;
						}
						if (xslNode.NodeType != XslNodeType.Param)
						{
							break;
						}
						VarPar varPar = (VarPar)xslNode;
						EnterScope(varPar);
						if (scope.IsLocalVariable(varPar.Name.LocalName, varPar.Name.NamespaceUri))
						{
							ReportError("Xslt_DupLocalVariable", varPar.Name.QualifiedName);
						}
						QilParameter qilParameter2 = CreateXslParam(varPar.Name, ChooseBestType(varPar));
						if (IsDebug)
						{
							qilParameter2.Annotation = varPar;
						}
						else if ((varPar.DefValueFlags & XslFlags.HasCalls) == 0)
						{
							qilParameter2.DefaultValue = CompileVarParValue(varPar);
						}
						else
						{
							QilList qilList3 = f.FormalParameterList();
							QilList qilList4 = f.ActualParameterList();
							for (int j = 0; j < qilList.Count; j++)
							{
								QilParameter qilParameter3 = f.Parameter(qilList[j].XmlType);
								qilParameter3.DebugName = ((QilParameter)qilList[j]).DebugName;
								qilParameter3.Name = CloneName(((QilParameter)qilList[j]).Name);
								SetLineInfo(qilParameter3, qilList[j].SourceLine);
								qilList3.Add(qilParameter3);
								qilList4.Add(qilList[j]);
							}
							varPar.Flags |= template.Flags & XslFlags.FocusFilter;
							QilFunction qilFunction = f.Function(qilList3, ((varPar.DefValueFlags & XslFlags.SideEffects) == 0) ? f.False() : f.True(), ChooseBestType(varPar));
							qilFunction.SourceLine = SourceLineInfo.NoSource;
							qilFunction.DebugName = "<xsl:param name=\"" + varPar.Name.QualifiedName + "\">";
							qilParameter2.DefaultValue = f.Invoke(qilFunction, qilList4);
							if (list == null)
							{
								list = new List<VarPar>();
								dictionary = new Dictionary<VarPar, Template>();
								dictionary2 = new Dictionary<VarPar, QilFunction>();
							}
							list.Add(varPar);
							dictionary.Add(varPar, template);
							dictionary2.Add(varPar, qilFunction);
						}
						SetLineInfo(qilParameter2, varPar.SourceLine);
						ExitScope();
						scope.AddVariable(varPar.Name, qilParameter2);
						qilList.Add(qilParameter2);
					}
					funcFocus.StopFocus();
				}
				ExitScope();
				allTemplate.Function = f.Function(qilList, ((allTemplate.Flags & XslFlags.SideEffects) == 0) ? f.False() : f.True(), (allTemplate is AttributeSet) ? XmlQueryTypeFactory.AttributeS : XmlQueryTypeFactory.NodeNotRtfS);
				allTemplate.Function.DebugName = allTemplate.GetDebugName();
				SetLineInfo(allTemplate.Function, allTemplate.SourceLine ?? SourceLineInfo.NoSource);
				functions.Add(allTemplate.Function);
			}
			if (list == null)
			{
				return;
			}
			foreach (VarPar item in list)
			{
				Template node = dictionary[item];
				QilFunction qilFunction2 = dictionary2[item];
				funcFocus.StartFocus(qilFunction2.Arguments, item.Flags);
				EnterScope(node);
				EnterScope(item);
				foreach (QilParameter argument in qilFunction2.Arguments)
				{
					scope.AddVariable(argument.Name, argument);
				}
				qilFunction2.Definition = CompileVarParValue(item);
				SetLineInfo(qilFunction2.Definition, item.SourceLine);
				ExitScope();
				ExitScope();
				funcFocus.StopFocus();
				functions.Add(qilFunction2);
			}
		}

		private QilParameter CreateXslParam(QilName name, XmlQueryType xt)
		{
			QilParameter qilParameter = f.Parameter(xt);
			qilParameter.DebugName = name.ToString();
			qilParameter.Name = name;
			return qilParameter;
		}

		private void CompileProtoTemplate(ProtoTemplate tmpl)
		{
			EnterScope(tmpl);
			funcFocus.StartFocus(tmpl.Function.Arguments, (!IsDebug) ? tmpl.Flags : XslFlags.FocusFilter);
			foreach (QilParameter argument in tmpl.Function.Arguments)
			{
				if (argument.Name.NamespaceUri != "urn:schemas-microsoft-com:xslt-debug")
				{
					if (IsDebug)
					{
						VarPar node = (VarPar)argument.Annotation;
						QilList nsList = EnterScope(node);
						argument.DefaultValue = CompileVarParValue(node);
						ExitScope();
						argument.DefaultValue = SetDebugNs(argument.DefaultValue, nsList);
					}
					scope.AddVariable(argument.Name, argument);
				}
			}
			tmpl.Function.Definition = CompileInstructions(tmpl.Content);
			funcFocus.StopFocus();
			ExitScope();
		}

		private QilList InstructionList()
		{
			return f.BaseFactory.Sequence();
		}

		private QilNode CompileInstructions(IList<XslNode> instructions)
		{
			return CompileInstructions(instructions, 0, InstructionList());
		}

		private QilNode CompileInstructions(IList<XslNode> instructions, int from)
		{
			return CompileInstructions(instructions, from, InstructionList());
		}

		private QilNode CompileInstructions(IList<XslNode> instructions, QilList content)
		{
			return CompileInstructions(instructions, 0, content);
		}

		private QilNode CompileInstructions(IList<XslNode> instructions, int from, QilList content)
		{
			for (int i = from; i < instructions.Count; i++)
			{
				XslNode xslNode = instructions[i];
				XslNodeType nodeType = xslNode.NodeType;
				if (nodeType == XslNodeType.Param)
				{
					continue;
				}
				QilList nsList = EnterScope(xslNode);
				QilNode qilNode = nodeType switch
				{
					XslNodeType.ApplyImports => CompileApplyImports(xslNode), 
					XslNodeType.ApplyTemplates => CompileApplyTemplates((XslNodeEx)xslNode), 
					XslNodeType.Attribute => CompileAttribute((NodeCtor)xslNode), 
					XslNodeType.CallTemplate => CompileCallTemplate((XslNodeEx)xslNode), 
					XslNodeType.Choose => CompileChoose(xslNode), 
					XslNodeType.Comment => CompileComment(xslNode), 
					XslNodeType.Copy => CompileCopy(xslNode), 
					XslNodeType.CopyOf => CompileCopyOf(xslNode), 
					XslNodeType.Element => CompileElement((NodeCtor)xslNode), 
					XslNodeType.Error => CompileError(xslNode), 
					XslNodeType.ForEach => CompileForEach((XslNodeEx)xslNode), 
					XslNodeType.If => CompileIf(xslNode), 
					XslNodeType.List => CompileList(xslNode), 
					XslNodeType.LiteralAttribute => CompileLiteralAttribute(xslNode), 
					XslNodeType.LiteralElement => CompileLiteralElement(xslNode), 
					XslNodeType.Message => CompileMessage(xslNode), 
					XslNodeType.Nop => CompileNop(xslNode), 
					XslNodeType.Number => CompileNumber((Number)xslNode), 
					XslNodeType.PI => CompilePI(xslNode), 
					XslNodeType.Text => CompileText((Text)xslNode), 
					XslNodeType.UseAttributeSet => CompileUseAttributeSet(xslNode), 
					XslNodeType.ValueOf => CompileValueOf(xslNode), 
					XslNodeType.ValueOfDoe => CompileValueOfDoe(xslNode), 
					XslNodeType.Variable => CompileVariable(xslNode), 
					_ => null, 
				};
				ExitScope();
				if (qilNode.NodeType != QilNodeType.Sequence || qilNode.Count != 0)
				{
					if (nodeType != XslNodeType.LiteralAttribute && nodeType != XslNodeType.UseAttributeSet)
					{
						SetLineInfoCheck(qilNode, xslNode.SourceLine);
					}
					qilNode = SetDebugNs(qilNode, nsList);
					if (nodeType == XslNodeType.Variable)
					{
						QilIterator qilIterator = f.Let(qilNode);
						qilIterator.DebugName = xslNode.Name.ToString();
						scope.AddVariable(xslNode.Name, qilIterator);
						qilNode = f.Loop(qilIterator, CompileInstructions(instructions, i + 1));
						i = instructions.Count;
					}
					content.Add(qilNode);
				}
			}
			if (!IsDebug && content.Count == 1)
			{
				return content[0];
			}
			return content;
		}

		private QilNode CompileList(XslNode node)
		{
			return CompileInstructions(node.Content);
		}

		private QilNode CompileNop(XslNode node)
		{
			return f.Nop(f.Sequence());
		}

		private void AddNsDecl(QilList content, string prefix, string nsUri)
		{
			if (!(outputScope.LookupNamespace(prefix) == nsUri))
			{
				outputScope.AddNamespace(prefix, nsUri);
				content.Add(f.NamespaceDecl(f.String(prefix), f.String(nsUri)));
			}
		}

		private QilNode CompileLiteralElement(XslNode node)
		{
			bool flag = true;
			QilName name;
			string prefix;
			string nsUri;
			QilList content;
			while (true)
			{
				IL_0002:
				prefixesInUse.Clear();
				name = node.Name;
				prefix = name.Prefix;
				nsUri = name.NamespaceUri;
				compiler.ApplyNsAliases(ref prefix, ref nsUri);
				if (flag)
				{
					prefixesInUse.Add(prefix, nsUri);
				}
				else
				{
					prefix = name.Prefix;
				}
				outputScope.PushScope();
				content = InstructionList();
				foreach (CompilerScopeManager<QilIterator>.ScopeRecord item in (IEnumerable)scope)
				{
					string prefix2 = item.ncName;
					string nsUri2 = item.nsUri;
					if (!(nsUri2 != "http://www.w3.org/1999/XSL/Transform") || scope.IsExNamespace(nsUri2))
					{
						continue;
					}
					compiler.ApplyNsAliases(ref prefix2, ref nsUri2);
					if (flag)
					{
						if (prefixesInUse.Contains(prefix2))
						{
							if ((string)prefixesInUse[prefix2] != nsUri2)
							{
								outputScope.PopScope();
								flag = false;
								goto IL_0002;
							}
						}
						else
						{
							prefixesInUse.Add(prefix2, nsUri2);
						}
					}
					else
					{
						prefix2 = item.ncName;
					}
					AddNsDecl(content, prefix2, nsUri2);
				}
				break;
			}
			QilNode content2 = CompileInstructions(node.Content, content);
			outputScope.PopScope();
			name.Prefix = prefix;
			name.NamespaceUri = nsUri;
			return f.ElementCtor(name, content2);
		}

		private QilNode CompileElement(NodeCtor node)
		{
			QilNode qilNode = CompileStringAvt(node.NsAvt);
			QilNode qilNode2 = CompileStringAvt(node.NameAvt);
			QilNode name;
			if (qilNode2.NodeType != QilNodeType.LiteralString || (qilNode != null && qilNode.NodeType != QilNodeType.LiteralString))
			{
				name = ((qilNode == null) ? ResolveQNameDynamic(ignoreDefaultNs: false, qilNode2) : f.StrParseQName(qilNode2, qilNode));
			}
			else
			{
				string qname = (QilLiteral)qilNode2;
				string prefix;
				string localName;
				bool flag = compiler.ParseQName(qname, out prefix, out localName, this);
				string uri = ((qilNode != null) ? ((string)(QilLiteral)qilNode) : (flag ? ResolvePrefix(ignoreDefaultNs: false, prefix) : compiler.CreatePhantomNamespace()));
				name = f.QName(localName, uri, prefix);
			}
			outputScope.PushScope();
			outputScope.InvalidateAllPrefixes();
			QilNode content = CompileInstructions(node.Content);
			outputScope.PopScope();
			return f.ElementCtor(name, content);
		}

		private QilNode CompileLiteralAttribute(XslNode node)
		{
			QilName name = node.Name;
			string prefix = name.Prefix;
			string nsUri = name.NamespaceUri;
			if (prefix.Length != 0)
			{
				compiler.ApplyNsAliases(ref prefix, ref nsUri);
			}
			name.Prefix = prefix;
			name.NamespaceUri = nsUri;
			return f.AttributeCtor(name, CompileTextAvt(node.Select));
		}

		private QilNode CompileAttribute(NodeCtor node)
		{
			QilNode qilNode = CompileStringAvt(node.NsAvt);
			QilNode qilNode2 = CompileStringAvt(node.NameAvt);
			bool flag = false;
			QilNode name;
			if (qilNode2.NodeType != QilNodeType.LiteralString || (qilNode != null && qilNode.NodeType != QilNodeType.LiteralString))
			{
				name = ((qilNode == null) ? ResolveQNameDynamic(ignoreDefaultNs: true, qilNode2) : f.StrParseQName(qilNode2, qilNode));
			}
			else
			{
				string text = (QilLiteral)qilNode2;
				string prefix;
				string localName;
				bool flag2 = compiler.ParseQName(text, out prefix, out localName, this);
				string text2;
				if (qilNode == null)
				{
					text2 = (flag2 ? ResolvePrefix(ignoreDefaultNs: true, prefix) : compiler.CreatePhantomNamespace());
				}
				else
				{
					text2 = (QilLiteral)qilNode;
					flag = true;
				}
				if (text == "xmlns" || (localName == "xmlns" && text2.Length == 0))
				{
					ReportError("Xslt_XmlnsAttr", "name", text);
				}
				name = f.QName(localName, text2, prefix);
			}
			if (flag)
			{
				outputScope.InvalidateNonDefaultPrefixes();
			}
			return f.AttributeCtor(name, CompileInstructions(node.Content));
		}

		private QilNode ExtractText(string source, ref int pos)
		{
			int num = pos;
			unescapedText.Length = 0;
			int i;
			for (i = pos; i < source.Length; i++)
			{
				char c = source[i];
				if (c != '{' && c != '}')
				{
					continue;
				}
				if (i + 1 < source.Length && source[i + 1] == c)
				{
					i++;
					unescapedText.Append(source, num, i - num);
					num = i + 1;
					continue;
				}
				if (c == '{')
				{
					break;
				}
				pos = source.Length;
				if (xslVersion != XslVersion.ForwardsCompatible)
				{
					ReportError("Xslt_SingleRightBraceInAvt", source);
					return null;
				}
				return f.Error(lastScope.SourceLine, "Xslt_SingleRightBraceInAvt", source);
			}
			pos = i;
			if (unescapedText.Length == 0)
			{
				if (i <= num)
				{
					return null;
				}
				return f.String(source.Substring(num, i - num));
			}
			unescapedText.Append(source, num, i - num);
			return f.String(unescapedText.ToString());
		}

		private QilNode CompileAvt(string source)
		{
			QilList qilList = f.BaseFactory.Sequence();
			int pos = 0;
			while (pos < source.Length)
			{
				QilNode qilNode = ExtractText(source, ref pos);
				if (qilNode != null)
				{
					qilList.Add(qilNode);
				}
				if (pos < source.Length)
				{
					pos++;
					QilNode n = CompileXPathExpressionWithinAvt(source, ref pos);
					qilList.Add(f.ConvertToString(n));
				}
			}
			if (qilList.Count == 1)
			{
				return qilList[0];
			}
			return qilList;
		}

		private QilNode CompileStringAvt(string avt)
		{
			if (avt == null)
			{
				return null;
			}
			if (avt.IndexOfAny(curlyBraces) == -1)
			{
				return f.String(avt);
			}
			return f.StrConcat(CompileAvt(avt));
		}

		private QilNode CompileTextAvt(string avt)
		{
			if (avt.IndexOfAny(curlyBraces) == -1)
			{
				return f.TextCtor(f.String(avt));
			}
			QilNode qilNode = CompileAvt(avt);
			if (qilNode.NodeType == QilNodeType.Sequence)
			{
				QilList qilList = InstructionList();
				{
					foreach (QilNode item in qilNode)
					{
						qilList.Add(f.TextCtor(item));
					}
					return qilList;
				}
			}
			return f.TextCtor(qilNode);
		}

		private QilNode CompileText(Text node)
		{
			if (node.Hints == SerializationHints.None)
			{
				return f.TextCtor(f.String(node.Select));
			}
			return f.RawTextCtor(f.String(node.Select));
		}

		private QilNode CompilePI(XslNode node)
		{
			QilNode qilNode = CompileStringAvt(node.Select);
			if (qilNode.NodeType == QilNodeType.LiteralString)
			{
				string name = (QilLiteral)qilNode;
				compiler.ValidatePiName(name, this);
			}
			return f.PICtor(qilNode, CompileInstructions(node.Content));
		}

		private QilNode CompileComment(XslNode node)
		{
			return f.CommentCtor(CompileInstructions(node.Content));
		}

		private QilNode CompileError(XslNode node)
		{
			return f.Error(f.String(node.Select));
		}

		private QilNode WrapLoopBody(ISourceLineInfo before, QilNode expr, ISourceLineInfo after)
		{
			if (IsDebug)
			{
				return f.Sequence(SetLineInfo(InvokeOnCurrentNodeChanged(), before), expr, SetLineInfo(f.Nop(f.Sequence()), after));
			}
			return expr;
		}

		private QilNode CompileForEach(XslNodeEx node)
		{
			IList<XslNode> content = node.Content;
			LoopFocus parentLoop = curLoop;
			QilIterator focus = f.For(CompileNodeSetExpression(node.Select));
			curLoop.SetFocus(focus);
			int varScope = varHelper.StartVariables();
			curLoop.Sort(CompileSorts(content, ref parentLoop));
			QilNode expr = CompileInstructions(content);
			expr = WrapLoopBody(node.ElemNameLi, expr, node.EndTagLi);
			expr = AddCurrentPositionLast(expr);
			expr = curLoop.ConstructLoop(expr);
			expr = varHelper.FinishVariables(expr, varScope);
			curLoop = parentLoop;
			return expr;
		}

		private QilNode CompileApplyTemplates(XslNodeEx node)
		{
			IList<XslNode> content = node.Content;
			int varScope = varHelper.StartVariables();
			QilIterator qilIterator = f.Let(CompileNodeSetExpression(node.Select));
			varHelper.AddVariable(qilIterator);
			for (int i = 0; i < content.Count; i++)
			{
				if (content[i] is VarPar varPar)
				{
					CompileWithParam(varPar);
					QilNode value = varPar.Value;
					if (IsDebug || (!(value is QilIterator) && !(value is QilLiteral)))
					{
						QilIterator qilIterator2 = f.Let(value);
						qilIterator2.DebugName = f.QName("with-param " + varPar.Name.QualifiedName, "urn:schemas-microsoft-com:xslt-debug").ToString();
						varHelper.AddVariable(qilIterator2);
						varPar.Value = qilIterator2;
					}
				}
			}
			LoopFocus parentLoop = curLoop;
			QilIterator focus = f.For(qilIterator);
			curLoop.SetFocus(focus);
			curLoop.Sort(CompileSorts(content, ref parentLoop));
			QilNode expr = GenerateApply(null, node);
			expr = WrapLoopBody(node.ElemNameLi, expr, node.EndTagLi);
			expr = AddCurrentPositionLast(expr);
			expr = curLoop.ConstructLoop(expr);
			curLoop = parentLoop;
			return varHelper.FinishVariables(expr, varScope);
		}

		private QilNode CompileNodeSetExpression(string expr)
		{
			QilNode n = CompileXPathExpression(expr);
			if (f.CannotBeNodeSet(n))
			{
				XPathCompileException ex = new XPathCompileException(expr, 0, expr.Length, "XPath_NodeSetExpected", (string[])null);
				if (xslVersion != XslVersion.ForwardsCompatible)
				{
					ReportErrorInXPath(ex);
				}
				return f.Error(f.String(ex.Message));
			}
			return f.EnsureNodeSet(n);
		}

		private QilNode CompileApplyImports(XslNode node)
		{
			return GenerateApply((Stylesheet)node.Arg, node);
		}

		private QilNode CompileCallTemplate(XslNodeEx node)
		{
			int varScope = varHelper.StartVariables();
			IList<XslNode> content = node.Content;
			foreach (VarPar item in content)
			{
				CompileWithParam(item);
				if (IsDebug)
				{
					QilNode value = item.Value;
					QilIterator qilIterator = f.Let(value);
					qilIterator.DebugName = f.QName("with-param " + item.Name.QualifiedName, "urn:schemas-microsoft-com:xslt-debug").ToString();
					varHelper.AddVariable(qilIterator);
					item.Value = qilIterator;
				}
			}
			QilNode qilNode;
			if (compiler.NamedTemplates.TryGetValue(node.Name, out var value2))
			{
				qilNode = GenerateCall(value2.Function, node);
			}
			else
			{
				if (!compiler.IsPhantomName(node.Name))
				{
					compiler.ReportError(node.SourceLine, "Xslt_InvalidCallTemplate", node.Name.QualifiedName);
				}
				qilNode = f.Sequence();
			}
			if (content.Count > 0)
			{
				qilNode = SetLineInfo(qilNode, node.ElemNameLi);
			}
			qilNode = varHelper.FinishVariables(qilNode, varScope);
			if (IsDebug)
			{
				return f.Nop(qilNode);
			}
			return qilNode;
		}

		private QilNode CompileUseAttributeSet(XslNode node)
		{
			outputScope.InvalidateAllPrefixes();
			if (compiler.AttributeSets.TryGetValue(node.Name, out var value))
			{
				return GenerateCall(value.Function, node);
			}
			if (!compiler.IsPhantomName(node.Name))
			{
				compiler.ReportError(node.SourceLine, "Xslt_NoAttributeSet", node.Name.QualifiedName);
			}
			return f.Sequence();
		}

		private QilNode CompileCopy(XslNode copy)
		{
			QilNode currentNode = GetCurrentNode();
			if ((currentNode.XmlType.NodeKinds & (XmlNodeKindFlags.Attribute | XmlNodeKindFlags.Namespace)) != 0)
			{
				outputScope.InvalidateAllPrefixes();
			}
			if (currentNode.XmlType.NodeKinds == XmlNodeKindFlags.Element)
			{
				QilList qilList = InstructionList();
				qilList.Add(f.XPathNamespace(currentNode));
				outputScope.PushScope();
				outputScope.InvalidateAllPrefixes();
				QilNode content = CompileInstructions(copy.Content, qilList);
				outputScope.PopScope();
				return f.ElementCtor(f.NameOf(currentNode), content);
			}
			if (currentNode.XmlType.NodeKinds == XmlNodeKindFlags.Document)
			{
				return CompileInstructions(copy.Content);
			}
			if ((currentNode.XmlType.NodeKinds & (XmlNodeKindFlags.Document | XmlNodeKindFlags.Element)) == 0)
			{
				return currentNode;
			}
			return f.XsltCopy(currentNode, CompileInstructions(copy.Content));
		}

		private QilNode CompileCopyOf(XslNode node)
		{
			QilNode qilNode = CompileXPathExpression(node.Select);
			if (qilNode.XmlType.IsNode)
			{
				if ((qilNode.XmlType.NodeKinds & (XmlNodeKindFlags.Attribute | XmlNodeKindFlags.Namespace)) != 0)
				{
					outputScope.InvalidateAllPrefixes();
				}
				if (qilNode.XmlType.IsNotRtf && (qilNode.XmlType.NodeKinds & XmlNodeKindFlags.Document) == 0)
				{
					return qilNode;
				}
				if (qilNode.XmlType.IsSingleton)
				{
					return f.XsltCopyOf(qilNode);
				}
				QilIterator expr;
				return f.Loop(expr = f.For(qilNode), f.XsltCopyOf(expr));
			}
			if (qilNode.XmlType.IsAtomicValue)
			{
				return f.TextCtor(f.ConvertToString(qilNode));
			}
			outputScope.InvalidateAllPrefixes();
			QilIterator expr2;
			return f.Loop(expr2 = f.For(qilNode), f.Conditional(f.IsType(expr2, XmlQueryTypeFactory.Node), f.XsltCopyOf(f.TypeAssert(expr2, XmlQueryTypeFactory.Node)), f.TextCtor(f.XsltConvert(expr2, XmlQueryTypeFactory.StringX))));
		}

		private QilNode CompileValueOf(XslNode valueOf)
		{
			return f.TextCtor(f.ConvertToString(CompileXPathExpression(valueOf.Select)));
		}

		private QilNode CompileValueOfDoe(XslNode valueOf)
		{
			return f.RawTextCtor(f.ConvertToString(CompileXPathExpression(valueOf.Select)));
		}

		private QilNode CompileWhen(XslNode whenNode, QilNode otherwise)
		{
			return f.Conditional(f.ConvertToBoolean(CompileXPathExpression(whenNode.Select)), CompileInstructions(whenNode.Content), otherwise);
		}

		private QilNode CompileIf(XslNode ifNode)
		{
			return CompileWhen(ifNode, InstructionList());
		}

		private QilNode CompileChoose(XslNode node)
		{
			IList<XslNode> content = node.Content;
			QilNode qilNode = null;
			int num = content.Count - 1;
			while (0 <= num)
			{
				XslNode xslNode = content[num];
				QilList nsList = EnterScope(xslNode);
				qilNode = ((xslNode.NodeType != XslNodeType.Otherwise) ? CompileWhen(xslNode, qilNode ?? InstructionList()) : CompileInstructions(xslNode.Content));
				ExitScope();
				SetLineInfoCheck(qilNode, xslNode.SourceLine);
				qilNode = SetDebugNs(qilNode, nsList);
				num--;
			}
			if (qilNode == null)
			{
				return f.Sequence();
			}
			if (!IsDebug)
			{
				return qilNode;
			}
			return f.Sequence(qilNode);
		}

		private QilNode CompileMessage(XslNode node)
		{
			string uri = lastScope.SourceLine.Uri;
			QilNode n = f.RtfCtor(CompileInstructions(node.Content), f.String(uri));
			n = f.InvokeOuterXml(n);
			if (!(bool)node.Arg)
			{
				return f.Warning(n);
			}
			QilIterator text;
			return f.Loop(text = f.Let(n), f.Sequence(f.Warning(text), f.Error(text)));
		}

		private QilNode CompileVariable(XslNode node)
		{
			if (scope.IsLocalVariable(node.Name.LocalName, node.Name.NamespaceUri))
			{
				ReportError("Xslt_DupLocalVariable", node.Name.QualifiedName);
			}
			return CompileVarParValue(node);
		}

		private QilNode CompileVarParValue(XslNode node)
		{
			string uri = lastScope.SourceLine.Uri;
			IList<XslNode> content = node.Content;
			string select = node.Select;
			QilNode qilNode;
			if (select != null)
			{
				QilList qilList = InstructionList();
				qilList.Add(CompileXPathExpression(select));
				qilNode = CompileInstructions(content, qilList);
			}
			else if (content.Count != 0)
			{
				outputScope.PushScope();
				outputScope.InvalidateAllPrefixes();
				qilNode = f.RtfCtor(CompileInstructions(content), f.String(uri));
				outputScope.PopScope();
			}
			else
			{
				qilNode = f.String(string.Empty);
			}
			if (IsDebug)
			{
				qilNode = f.TypeAssert(qilNode, XmlQueryTypeFactory.ItemS);
			}
			return qilNode;
		}

		private void CompileWithParam(VarPar withParam)
		{
			QilList nsList = EnterScope(withParam);
			QilNode n = CompileVarParValue(withParam);
			ExitScope();
			SetLineInfo(n, withParam.SourceLine);
			n = (withParam.Value = SetDebugNs(n, nsList));
		}

		private QilNode CompileSorts(IList<XslNode> content, ref LoopFocus parentLoop)
		{
			QilList qilList = f.BaseFactory.SortKeyList();
			int num = 0;
			while (num < content.Count)
			{
				if (content[num] is Sort sort)
				{
					CompileSort(sort, qilList, ref parentLoop);
					content.RemoveAt(num);
				}
				else
				{
					num++;
				}
			}
			if (qilList.Count == 0)
			{
				return null;
			}
			return qilList;
		}

		private QilNode CompileLangAttribute(string attValue, bool fwdCompat)
		{
			QilNode qilNode = CompileStringAvt(attValue);
			if (qilNode != null)
			{
				if (qilNode.NodeType == QilNodeType.LiteralString)
				{
					string lang = (QilLiteral)qilNode;
					int num = XsltLibrary.LangToLcidInternal(lang, fwdCompat, this);
					if (num == 127)
					{
						qilNode = null;
					}
				}
				else
				{
					QilIterator qilIterator;
					qilNode = f.Loop(qilIterator = f.Let(qilNode), f.Conditional(f.Eq(f.InvokeLangToLcid(qilIterator, fwdCompat), f.Int32(127)), f.String(string.Empty), qilIterator));
				}
			}
			return qilNode;
		}

		private QilNode CompileLangAttributeToLcid(string attValue, bool fwdCompat)
		{
			return CompileLangToLcid(CompileStringAvt(attValue), fwdCompat);
		}

		private QilNode CompileLangToLcid(QilNode lang, bool fwdCompat)
		{
			if (lang == null)
			{
				return f.Double(127.0);
			}
			if (lang.NodeType == QilNodeType.LiteralString)
			{
				return f.Double(XsltLibrary.LangToLcidInternal((QilLiteral)lang, fwdCompat, this));
			}
			return f.XsltConvert(f.InvokeLangToLcid(lang, fwdCompat), XmlQueryTypeFactory.DoubleX);
		}

		private void CompileDataTypeAttribute(string attValue, bool fwdCompat, ref QilNode select, out QilNode select2)
		{
			QilNode qilNode = CompileStringAvt(attValue);
			if (qilNode != null)
			{
				if (qilNode.NodeType != QilNodeType.LiteralString)
				{
					QilIterator qilIterator;
					qilNode = f.Loop(qilIterator = f.Let(qilNode), f.Conditional(f.Eq(qilIterator, f.String("number")), f.False(), f.Conditional(f.Eq(qilIterator, f.String("text")), f.True(), fwdCompat ? f.True() : f.Loop(f.Let(ResolveQNameDynamic(ignoreDefaultNs: true, qilIterator)), f.Error(lastScope.SourceLine, "Xslt_BistateAttribute", "data-type", "text", "number")))));
					QilIterator qilIterator2 = f.Let(qilNode);
					varHelper.AddVariable(qilIterator2);
					select2 = select.DeepClone(f.BaseFactory);
					select = f.Conditional(qilIterator2, f.ConvertToString(select), f.String(string.Empty));
					select2 = f.Conditional(qilIterator2, f.Double(0.0), f.ConvertToNumber(select2));
					return;
				}
				string text = (QilLiteral)qilNode;
				if (text == "number")
				{
					select = f.ConvertToNumber(select);
					select2 = null;
					return;
				}
				if (!(text == "text") && !fwdCompat)
				{
					string prefix;
					string localName;
					string text2 = (compiler.ParseQName(text, out prefix, out localName, this) ? ResolvePrefix(ignoreDefaultNs: true, prefix) : compiler.CreatePhantomNamespace());
					_ = text2.Length;
					ReportError("Xslt_BistateAttribute", "data-type", "text", "number");
				}
			}
			select = f.ConvertToString(select);
			select2 = null;
		}

		private QilNode CompileOrderAttribute(string attName, string attValue, string value0, string value1, bool fwdCompat)
		{
			QilNode qilNode = CompileStringAvt(attValue);
			if (qilNode != null)
			{
				if (qilNode.NodeType == QilNodeType.LiteralString)
				{
					string text = (QilLiteral)qilNode;
					if (text == value1)
					{
						qilNode = f.String("1");
					}
					else
					{
						if (text != value0 && !fwdCompat)
						{
							ReportError("Xslt_BistateAttribute", attName, value0, value1);
						}
						qilNode = f.String("0");
					}
				}
				else
				{
					QilIterator left;
					qilNode = f.Loop(left = f.Let(qilNode), f.Conditional(f.Eq(left, f.String(value1)), f.String("1"), fwdCompat ? f.String("0") : f.Conditional(f.Eq(left, f.String(value0)), f.String("0"), f.Error(lastScope.SourceLine, "Xslt_BistateAttribute", attName, value0, value1))));
				}
			}
			return qilNode;
		}

		private void CompileSort(Sort sort, QilList keyList, ref LoopFocus parentLoop)
		{
			EnterScope(sort);
			bool forwardsCompatible = sort.ForwardsCompatible;
			QilNode select = CompileXPathExpression(sort.Select);
			QilNode value;
			QilNode select2;
			QilNode qilNode;
			QilNode qilNode2;
			if (sort.Lang != null || sort.DataType != null || sort.Order != null || sort.CaseOrder != null)
			{
				LoopFocus loopFocus = curLoop;
				curLoop = parentLoop;
				value = CompileLangAttribute(sort.Lang, forwardsCompatible);
				CompileDataTypeAttribute(sort.DataType, forwardsCompatible, ref select, out select2);
				qilNode = CompileOrderAttribute("order", sort.Order, "ascending", "descending", forwardsCompatible);
				qilNode2 = CompileOrderAttribute("case-order", sort.CaseOrder, "lower-first", "upper-first", forwardsCompatible);
				curLoop = loopFocus;
			}
			else
			{
				select = f.ConvertToString(select);
				select2 = (value = (qilNode = (qilNode2 = null)));
			}
			strConcat.Reset();
			strConcat.Append("http://collations.microsoft.com");
			strConcat.Append('/');
			strConcat.Append(value);
			char value2 = '?';
			if (qilNode != null)
			{
				strConcat.Append(value2);
				strConcat.Append("descendingOrder=");
				strConcat.Append(qilNode);
				value2 = '&';
			}
			if (qilNode2 != null)
			{
				strConcat.Append(value2);
				strConcat.Append("upperFirst=");
				strConcat.Append(qilNode2);
				value2 = '&';
			}
			QilNode qilNode3 = strConcat.ToQil();
			QilSortKey node = f.SortKey(select, qilNode3);
			keyList.Add(node);
			if (select2 != null)
			{
				node = f.SortKey(select2, qilNode3.DeepClone(f.BaseFactory));
				keyList.Add(node);
			}
			ExitScope();
		}

		private QilNode MatchPattern(QilNode pattern, QilIterator testNode)
		{
			if (pattern.NodeType == QilNodeType.Error)
			{
				return pattern;
			}
			QilList qilList;
			if (pattern.NodeType == QilNodeType.Sequence)
			{
				qilList = (QilList)pattern;
			}
			else
			{
				qilList = f.BaseFactory.Sequence();
				qilList.Add(pattern);
			}
			QilNode qilNode = f.False();
			int num = qilList.Count - 1;
			while (0 <= num)
			{
				QilLoop qilLoop = (QilLoop)qilList[num];
				qilNode = f.Or(refReplacer.Replace(qilLoop.Body, qilLoop.Variable, testNode), qilNode);
				num--;
			}
			return qilNode;
		}

		private QilNode MatchCountPattern(QilNode countPattern, QilIterator testNode)
		{
			if (countPattern != null)
			{
				return MatchPattern(countPattern, testNode);
			}
			QilNode currentNode = GetCurrentNode();
			XmlNodeKindFlags nodeKinds = currentNode.XmlType.NodeKinds;
			if ((nodeKinds & (nodeKinds - 1)) != 0)
			{
				return f.InvokeIsSameNodeSort(testNode, currentNode);
			}
			QilNode left;
			switch (nodeKinds)
			{
			case XmlNodeKindFlags.Document:
				return f.IsType(testNode, XmlQueryTypeFactory.Document);
			case XmlNodeKindFlags.Element:
				left = f.IsType(testNode, XmlQueryTypeFactory.Element);
				break;
			case XmlNodeKindFlags.Attribute:
				left = f.IsType(testNode, XmlQueryTypeFactory.Attribute);
				break;
			case XmlNodeKindFlags.Text:
				return f.IsType(testNode, XmlQueryTypeFactory.Text);
			case XmlNodeKindFlags.Comment:
				return f.IsType(testNode, XmlQueryTypeFactory.Comment);
			case XmlNodeKindFlags.PI:
				return f.And(f.IsType(testNode, XmlQueryTypeFactory.PI), f.Eq(f.LocalNameOf(testNode), f.LocalNameOf(currentNode)));
			case XmlNodeKindFlags.Namespace:
				return f.And(f.IsType(testNode, XmlQueryTypeFactory.Namespace), f.Eq(f.LocalNameOf(testNode), f.LocalNameOf(currentNode)));
			default:
				return f.False();
			}
			return f.And(left, f.And(f.Eq(f.LocalNameOf(testNode), f.LocalNameOf(currentNode)), f.Eq(f.NamespaceUriOf(testNode), f.NamespaceUriOf(GetCurrentNode()))));
		}

		private QilNode PlaceMarker(QilNode countPattern, QilNode fromPattern, bool multiple)
		{
			QilNode countPattern2 = countPattern?.DeepClone(f.BaseFactory);
			QilIterator testNode;
			QilNode qilNode = f.Filter(testNode = f.For(f.AncestorOrSelf(GetCurrentNode())), MatchCountPattern(countPattern, testNode));
			QilNode qilNode2 = ((!multiple) ? f.Filter(testNode = f.For(qilNode), f.Eq(f.PositionOf(testNode), f.Int32(1))) : f.DocOrderDistinct(qilNode));
			QilNode binding;
			QilIterator right;
			if (fromPattern == null)
			{
				binding = qilNode2;
			}
			else
			{
				QilNode binding2 = f.Filter(testNode = f.For(f.AncestorOrSelf(GetCurrentNode())), MatchPattern(fromPattern, testNode));
				QilNode binding3 = f.Filter(testNode = f.For(binding2), f.Eq(f.PositionOf(testNode), f.Int32(1)));
				binding = f.Loop(testNode = f.For(binding3), f.Filter(right = f.For(qilNode2), f.Before(testNode, right)));
			}
			return f.Loop(right = f.For(binding), f.Add(f.Int32(1), f.Length(f.Filter(testNode = f.For(f.PrecedingSibling(right)), MatchCountPattern(countPattern2, testNode)))));
		}

		private QilNode PlaceMarkerAny(QilNode countPattern, QilNode fromPattern)
		{
			QilNode child;
			QilIterator testNode2;
			if (fromPattern == null)
			{
				QilNode binding = f.NodeRange(f.Root(GetCurrentNode()), GetCurrentNode());
				QilIterator testNode;
				child = f.Filter(testNode = f.For(binding), MatchCountPattern(countPattern, testNode));
			}
			else
			{
				QilIterator testNode;
				QilNode binding2 = f.Filter(testNode = f.For(f.Preceding(GetCurrentNode())), MatchPattern(fromPattern, testNode));
				QilNode binding3 = f.Filter(testNode = f.For(binding2), f.Eq(f.PositionOf(testNode), f.Int32(1)));
				QilIterator right;
				child = f.Loop(testNode = f.For(binding3), f.Filter(right = f.For(f.Filter(testNode2 = f.For(f.NodeRange(testNode, GetCurrentNode())), MatchCountPattern(countPattern, testNode2))), f.Not(f.Is(testNode, right))));
			}
			return f.Loop(testNode2 = f.Let(f.Length(child)), f.Conditional(f.Eq(testNode2, f.Int32(0)), f.Sequence(), testNode2));
		}

		private QilNode CompileLetterValueAttribute(string attValue, bool fwdCompat)
		{
			QilNode qilNode = CompileStringAvt(attValue);
			if (qilNode != null)
			{
				if (qilNode.NodeType == QilNodeType.LiteralString)
				{
					string text = (QilLiteral)qilNode;
					if (text != "alphabetic" && text != "traditional")
					{
						if (fwdCompat)
						{
							return f.String("default");
						}
						ReportError("Xslt_BistateAttribute", "letter-value", "alphabetic", "traditional");
					}
					return qilNode;
				}
				QilIterator qilIterator = f.Let(qilNode);
				return f.Loop(qilIterator, f.Conditional(f.Or(f.Eq(qilIterator, f.String("alphabetic")), f.Eq(qilIterator, f.String("traditional"))), qilIterator, fwdCompat ? f.String("default") : f.Error(lastScope.SourceLine, "Xslt_BistateAttribute", "letter-value", "alphabetic", "traditional")));
			}
			return f.String("default");
		}

		private QilNode CompileGroupingSeparatorAttribute(string attValue, bool fwdCompat)
		{
			QilNode qilNode = CompileStringAvt(attValue);
			if (qilNode == null)
			{
				qilNode = f.String(string.Empty);
			}
			else if (qilNode.NodeType == QilNodeType.LiteralString)
			{
				string text = (QilLiteral)qilNode;
				if (text.Length != 1)
				{
					if (!fwdCompat)
					{
						ReportError("Xslt_CharAttribute", "grouping-separator");
					}
					qilNode = f.String(string.Empty);
				}
			}
			else
			{
				QilIterator qilIterator = f.Let(qilNode);
				qilNode = f.Loop(qilIterator, f.Conditional(f.Eq(f.StrLength(qilIterator), f.Int32(1)), qilIterator, fwdCompat ? f.String(string.Empty) : f.Error(lastScope.SourceLine, "Xslt_CharAttribute", "grouping-separator")));
			}
			return qilNode;
		}

		private QilNode CompileGroupingSizeAttribute(string attValue, bool fwdCompat)
		{
			QilNode qilNode = CompileStringAvt(attValue);
			if (qilNode == null)
			{
				return f.Double(0.0);
			}
			if (qilNode.NodeType == QilNodeType.LiteralString)
			{
				string s = (QilLiteral)qilNode;
				double num = XsltFunctions.Round(XPathConvert.StringToDouble(s));
				if (0.0 <= num && num <= 2147483647.0)
				{
					return f.Double(num);
				}
				return f.Double(0.0);
			}
			QilIterator qilIterator = f.Let(f.ConvertToNumber(qilNode));
			return f.Loop(qilIterator, f.Conditional(f.And(f.Lt(f.Double(0.0), qilIterator), f.Lt(qilIterator, f.Double(2147483647.0))), qilIterator, f.Double(0.0)));
		}

		private QilNode CompileNumber(Number num)
		{
			QilNode value;
			if (num.Value != null)
			{
				value = f.ConvertToNumber(CompileXPathExpression(num.Value));
			}
			else
			{
				QilNode countPattern = ((num.Count != null) ? CompileNumberPattern(num.Count) : null);
				QilNode fromPattern = ((num.From != null) ? CompileNumberPattern(num.From) : null);
				value = num.Level switch
				{
					NumberLevel.Single => PlaceMarker(countPattern, fromPattern, multiple: false), 
					NumberLevel.Multiple => PlaceMarker(countPattern, fromPattern, multiple: true), 
					_ => PlaceMarkerAny(countPattern, fromPattern), 
				};
			}
			bool forwardsCompatible = num.ForwardsCompatible;
			return f.TextCtor(f.InvokeNumberFormat(value, CompileStringAvt(num.Format), CompileLangAttributeToLcid(num.Lang, forwardsCompatible), CompileLetterValueAttribute(num.LetterValue, forwardsCompatible), CompileGroupingSeparatorAttribute(num.GroupingSeparator, forwardsCompatible), CompileGroupingSizeAttribute(num.GroupingSize, forwardsCompatible)));
		}

		private void CompileAndSortMatches(Stylesheet sheet)
		{
			foreach (Template template in sheet.Templates)
			{
				if (template.Match == null)
				{
					continue;
				}
				EnterScope(template);
				QilNode qilNode = CompileMatchPattern(template.Match);
				if (qilNode.NodeType == QilNodeType.Sequence)
				{
					QilList qilList = (QilList)qilNode;
					for (int i = 0; i < qilList.Count; i++)
					{
						sheet.AddTemplateMatch(template, (QilLoop)qilList[i]);
					}
				}
				else
				{
					sheet.AddTemplateMatch(template, (QilLoop)qilNode);
				}
				ExitScope();
			}
			sheet.SortTemplateMatches();
			Stylesheet[] imports = sheet.Imports;
			foreach (Stylesheet sheet2 in imports)
			{
				CompileAndSortMatches(sheet2);
			}
		}

		private void CompileKeys()
		{
			for (int i = 0; i < compiler.Keys.Count; i++)
			{
				foreach (Key item in compiler.Keys[i])
				{
					EnterScope(item);
					QilParameter qilParameter = f.Parameter(XmlQueryTypeFactory.NodeNotRtf);
					singlFocus.SetFocus(qilParameter);
					QilIterator qilIterator = f.For(f.OptimizeBarrier(CompileKeyMatch(item.Match)));
					singlFocus.SetFocus(qilIterator);
					QilIterator qilIterator2 = f.For(CompileKeyUse(item.Use));
					qilIterator2 = f.For(f.OptimizeBarrier(f.Loop(qilIterator2, f.ConvertToString(qilIterator2))));
					QilParameter qilParameter2 = f.Parameter(XmlQueryTypeFactory.StringX);
					QilFunction qilFunction = f.Function(f.FormalParameterList(qilParameter, qilParameter2), f.Filter(qilIterator, f.Not(f.IsEmpty(f.Filter(qilIterator2, f.Eq(qilIterator2, qilParameter2))))), f.False());
					qilFunction.DebugName = item.GetDebugName();
					SetLineInfo(qilFunction, item.SourceLine);
					item.Function = qilFunction;
					functions.Add(qilFunction);
					ExitScope();
				}
			}
			singlFocus.SetFocus(null);
		}

		private void CreateGlobalVarPars()
		{
			foreach (VarPar externalPar in compiler.ExternalPars)
			{
				CreateGlobalVarPar(externalPar);
			}
			foreach (VarPar globalVar in compiler.GlobalVars)
			{
				CreateGlobalVarPar(globalVar);
			}
		}

		private void CreateGlobalVarPar(VarPar varPar)
		{
			XmlQueryType t = ChooseBestType(varPar);
			QilIterator qilIterator = ((varPar.NodeType != XslNodeType.Variable) ? f.Parameter(null, varPar.Name, t) : f.Let(f.Unknown(t)));
			qilIterator.DebugName = varPar.Name.ToString();
			varPar.Value = qilIterator;
			SetLineInfo(qilIterator, varPar.SourceLine);
			scope.AddVariable(varPar.Name, qilIterator);
		}

		private void CompileGlobalVariables()
		{
			singlFocus.SetFocus(SingletonFocusType.InitialDocumentNode);
			foreach (VarPar externalPar in compiler.ExternalPars)
			{
				extPars.Add(CompileGlobalVarPar(externalPar));
			}
			foreach (VarPar globalVar in compiler.GlobalVars)
			{
				gloVars.Add(CompileGlobalVarPar(globalVar));
			}
			singlFocus.SetFocus(null);
		}

		private QilIterator CompileGlobalVarPar(VarPar varPar)
		{
			QilIterator qilIterator = (QilIterator)varPar.Value;
			QilList nsList = EnterScope(varPar);
			QilNode qilNode = CompileVarParValue(varPar);
			SetLineInfo(qilNode, qilIterator.SourceLine);
			qilNode = AddCurrentPositionLast(qilNode);
			qilNode = SetDebugNs(qilNode, nsList);
			qilIterator.SourceLine = SourceLineInfo.NoSource;
			qilIterator.Binding = qilNode;
			ExitScope();
			return qilIterator;
		}

		private void ReportErrorInXPath(XslLoadException e)
		{
			string text = ((e is XPathCompileException ex) ? ex.FormatDetailedMessage() : e.Message);
			compiler.ReportError(lastScope.SourceLine, "Xml_UserException", text);
		}

		private QilNode PhantomXPathExpression()
		{
			return f.TypeAssert(f.Sequence(), XmlQueryTypeFactory.ItemS);
		}

		private QilNode PhantomKeyMatch()
		{
			return f.TypeAssert(f.Sequence(), XmlQueryTypeFactory.NodeNotRtfS);
		}

		private QilNode CompileXPathExpression(string expr)
		{
			SetEnvironmentFlags(allowVariables: true, allowCurrent: true, allowKey: true);
			QilNode qilNode;
			if (expr == null)
			{
				qilNode = PhantomXPathExpression();
			}
			else
			{
				try
				{
					System.Xml.Xsl.XPath.XPathScanner scanner = new System.Xml.Xsl.XPath.XPathScanner(expr);
					qilNode = xpathParser.Parse(scanner, xpathBuilder, LexKind.Eof);
				}
				catch (XslLoadException ex)
				{
					if (xslVersion != XslVersion.ForwardsCompatible)
					{
						ReportErrorInXPath(ex);
					}
					qilNode = f.Error(f.String(ex.Message));
				}
			}
			if (qilNode is QilIterator)
			{
				qilNode = f.Nop(qilNode);
			}
			return qilNode;
		}

		private QilNode CompileXPathExpressionWithinAvt(string expr, ref int pos)
		{
			SetEnvironmentFlags(allowVariables: true, allowCurrent: true, allowKey: true);
			QilNode qilNode;
			try
			{
				System.Xml.Xsl.XPath.XPathScanner xPathScanner = new System.Xml.Xsl.XPath.XPathScanner(expr, pos);
				qilNode = xpathParser.Parse(xPathScanner, xpathBuilder, LexKind.RBrace);
				pos = xPathScanner.LexStart + 1;
			}
			catch (XslLoadException ex)
			{
				if (xslVersion != XslVersion.ForwardsCompatible)
				{
					ReportErrorInXPath(ex);
				}
				qilNode = f.Error(f.String(ex.Message));
				pos = expr.Length;
			}
			if (qilNode is QilIterator)
			{
				qilNode = f.Nop(qilNode);
			}
			return qilNode;
		}

		private QilNode CompileMatchPattern(string pttrn)
		{
			SetEnvironmentFlags(allowVariables: false, allowCurrent: false, allowKey: true);
			try
			{
				System.Xml.Xsl.XPath.XPathScanner scanner = new System.Xml.Xsl.XPath.XPathScanner(pttrn);
				return ptrnParser.Parse(scanner, ptrnBuilder);
			}
			catch (XslLoadException ex)
			{
				if (xslVersion != XslVersion.ForwardsCompatible)
				{
					ReportErrorInXPath(ex);
				}
				QilNode qilNode = f.Loop(f.For(ptrnBuilder.FixupNode), f.Error(f.String(ex.Message)));
				XPathPatternBuilder.SetPriority(qilNode, 0.5);
				return qilNode;
			}
		}

		private QilNode CompileNumberPattern(string pttrn)
		{
			SetEnvironmentFlags(allowVariables: true, allowCurrent: false, allowKey: true);
			try
			{
				System.Xml.Xsl.XPath.XPathScanner scanner = new System.Xml.Xsl.XPath.XPathScanner(pttrn);
				return ptrnParser.Parse(scanner, ptrnBuilder);
			}
			catch (XslLoadException ex)
			{
				if (xslVersion != XslVersion.ForwardsCompatible)
				{
					ReportErrorInXPath(ex);
				}
				return f.Error(f.String(ex.Message));
			}
		}

		private QilNode CompileKeyMatch(string pttrn)
		{
			if (keyMatchBuilder == null)
			{
				keyMatchBuilder = new KeyMatchBuilder(this);
			}
			SetEnvironmentFlags(allowVariables: false, allowCurrent: false, allowKey: false);
			if (pttrn == null)
			{
				return PhantomKeyMatch();
			}
			try
			{
				System.Xml.Xsl.XPath.XPathScanner scanner = new System.Xml.Xsl.XPath.XPathScanner(pttrn);
				return ptrnParser.Parse(scanner, keyMatchBuilder);
			}
			catch (XslLoadException ex)
			{
				if (xslVersion != XslVersion.ForwardsCompatible)
				{
					ReportErrorInXPath(ex);
				}
				return f.Error(f.String(ex.Message));
			}
		}

		private QilNode CompileKeyUse(string expr)
		{
			SetEnvironmentFlags(allowVariables: false, allowCurrent: true, allowKey: false);
			QilNode qilNode;
			if (expr == null)
			{
				qilNode = PhantomXPathExpression();
			}
			else
			{
				try
				{
					System.Xml.Xsl.XPath.XPathScanner scanner = new System.Xml.Xsl.XPath.XPathScanner(expr);
					qilNode = xpathParser.Parse(scanner, xpathBuilder, LexKind.Eof);
				}
				catch (XslLoadException ex)
				{
					if (xslVersion != XslVersion.ForwardsCompatible)
					{
						ReportErrorInXPath(ex);
					}
					qilNode = f.Error(f.String(ex.Message));
				}
			}
			if (qilNode is QilIterator)
			{
				qilNode = f.Nop(qilNode);
			}
			return qilNode;
		}

		private QilNode ResolveQNameDynamic(bool ignoreDefaultNs, QilNode qilName)
		{
			QilList qilList = f.BaseFactory.Sequence();
			if (ignoreDefaultNs)
			{
				qilList.Add(f.NamespaceDecl(f.String(string.Empty), f.String(string.Empty)));
			}
			foreach (CompilerScopeManager<QilIterator>.ScopeRecord item in (IEnumerable)scope)
			{
				string ncName = item.ncName;
				string nsUri = item.nsUri;
				if (!ignoreDefaultNs || ncName.Length != 0)
				{
					qilList.Add(f.NamespaceDecl(f.String(ncName), f.String(nsUri)));
				}
			}
			return f.StrParseQName(qilName, qilList);
		}

		private QilNode GenerateCall(QilFunction func, XslNode node)
		{
			AddImplicitArgs(node);
			return invkGen.GenerateInvoke(func, node.Content);
		}

		private QilNode GenerateApply(Stylesheet sheet, XslNode node)
		{
			if (compiler.Settings.CheckOnly)
			{
				return f.Sequence();
			}
			AddImplicitArgs(node);
			return InvokeApplyFunction(sheet, node.Name, node.Content);
		}

		private void AddImplicitArgs(XslNode node)
		{
			XslFlags value = XslFlags.None;
			if (IsDebug)
			{
				value = XslFlags.FocusFilter;
			}
			else if (node.NodeType == XslNodeType.CallTemplate)
			{
				if (compiler.NamedTemplates.TryGetValue(node.Name, out var value2))
				{
					value = value2.Flags;
				}
			}
			else if (node.NodeType == XslNodeType.UseAttributeSet)
			{
				if (compiler.AttributeSets.TryGetValue(node.Name, out var value3))
				{
					value = value3.Flags;
				}
			}
			else
			{
				if (!compiler.ModeFlags.TryGetValue(node.Name, out value))
				{
					value = XslFlags.None;
				}
				value |= XslFlags.Current;
			}
			List<XslNode> list = new List<XslNode>();
			if ((value & XslFlags.Current) != 0)
			{
				list.Add(CreateWithParam(nameCurrent, GetCurrentNode()));
			}
			if ((value & XslFlags.Position) != 0)
			{
				list.Add(CreateWithParam(namePosition, GetCurrentPosition()));
			}
			if ((value & XslFlags.Last) != 0)
			{
				list.Add(CreateWithParam(nameLast, GetLastPosition()));
			}
			node.InsertContent(list);
		}

		public static VarPar CreateWithParam(QilName name, QilNode value)
		{
			VarPar varPar = AstFactory.WithParam(name);
			varPar.Value = value;
			return varPar;
		}

		private bool FillupInvokeArgs(IList<QilNode> formalArgs, IList<XslNode> actualArgs, QilList invokeArgs)
		{
			if (actualArgs.Count != formalArgs.Count)
			{
				return false;
			}
			invokeArgs.Clear();
			for (int i = 0; i < formalArgs.Count; i++)
			{
				QilName name = ((QilParameter)formalArgs[i]).Name;
				XmlQueryType xmlType = formalArgs[i].XmlType;
				QilNode qilNode = null;
				for (int j = 0; j < actualArgs.Count; j++)
				{
					VarPar varPar = (VarPar)actualArgs[j];
					if (name.Equals(varPar.Name))
					{
						QilNode value = varPar.Value;
						XmlQueryType xmlType2 = value.XmlType;
						if (xmlType2 != xmlType && (!xmlType2.IsNode || !xmlType.IsNode || !xmlType2.IsSubtypeOf(xmlType)))
						{
							return false;
						}
						qilNode = value;
						break;
					}
				}
				if (qilNode == null)
				{
					return false;
				}
				invokeArgs.Add(qilNode);
			}
			return true;
		}

		private QilNode InvokeApplyFunction(Stylesheet sheet, QilName mode, IList<XslNode> actualArgs)
		{
			if (!compiler.ModeFlags.TryGetValue(mode, out var value))
			{
				value = XslFlags.None;
			}
			if (IsDebug)
			{
				value = XslFlags.FocusFilter;
			}
			value |= XslFlags.Current;
			QilList qilList = f.ActualParameterList();
			QilFunction qilFunction = null;
			Dictionary<QilName, List<QilFunction>> dictionary = ((sheet == null) ? compiler.ApplyTemplatesFunctions : sheet.ApplyImportsFunctions);
			if (!dictionary.TryGetValue(mode, out var value2))
			{
				List<QilFunction> list2 = (dictionary[mode] = new List<QilFunction>());
				value2 = list2;
			}
			foreach (QilFunction item in value2)
			{
				if (FillupInvokeArgs(item.Arguments, actualArgs, qilList))
				{
					qilFunction = item;
					break;
				}
			}
			if (qilFunction == null)
			{
				qilList.Clear();
				QilList qilList2 = f.FormalParameterList();
				for (int i = 0; i < actualArgs.Count; i++)
				{
					VarPar varPar = (VarPar)actualArgs[i];
					qilList.Add(varPar.Value);
					QilParameter qilParameter = f.Parameter((i == 0) ? XmlQueryTypeFactory.NodeNotRtf : varPar.Value.XmlType);
					qilParameter.Name = CloneName(varPar.Name);
					qilList2.Add(qilParameter);
					varPar.Value = qilParameter;
				}
				qilFunction = f.Function(qilList2, f.False(), XmlQueryTypeFactory.NodeNotRtfS);
				string text = ((mode.LocalName.Length == 0) ? string.Empty : (" mode=\"" + mode.QualifiedName + '"'));
				qilFunction.DebugName = ((sheet == null) ? "<xsl:apply-templates" : "<xsl:apply-imports") + text + '>';
				value2.Add(qilFunction);
				functions.Add(qilFunction);
				QilIterator qilIterator = (QilIterator)qilList2[0];
				QilTernary qilTernary = f.BaseFactory.Conditional(f.IsType(qilIterator, elementOrDocumentType), f.BaseFactory.Nop(f.BaseFactory.Unknown(XmlQueryTypeFactory.NodeNotRtfS)), f.Conditional(f.IsType(qilIterator, textOrAttributeType), f.TextCtor(f.XPathNodeValue(qilIterator)), f.Sequence()));
				matcherBuilder.CollectPatterns(sheet ?? compiler.PrincipalStylesheet, mode, sheet != null);
				qilFunction.Definition = matcherBuilder.BuildMatcher(qilIterator, actualArgs, qilTernary);
				QilIterator qilIterator2 = f.For(f.Content(qilIterator));
				QilNode qilNode = f.Filter(qilIterator2, f.IsType(qilIterator2, XmlQueryTypeFactory.Content));
				qilNode.XmlType = XmlQueryTypeFactory.ContentS;
				LoopFocus loopFocus = curLoop;
				curLoop.SetFocus(f.For(qilNode));
				if ((value & XslFlags.Last) != 0)
				{
					curLoop.GetLast();
				}
				List<XslNode> list3 = new List<XslNode>(3);
				int num = 0;
				if ((value & XslFlags.Current) != 0)
				{
					list3.Add(actualArgs[num++]);
				}
				if ((value & XslFlags.Position) != 0)
				{
					list3.Add(actualArgs[num++]);
				}
				if ((value & XslFlags.Last) != 0)
				{
					list3.Add(actualArgs[num++]);
				}
				actualArgs = list3;
				int num2 = 0;
				if ((value & XslFlags.Current) != 0)
				{
					((VarPar)actualArgs[num2++]).Value = GetCurrentNode();
				}
				if ((value & XslFlags.Position) != 0)
				{
					((VarPar)actualArgs[num2++]).Value = GetCurrentPosition();
				}
				if ((value & XslFlags.Last) != 0)
				{
					((VarPar)actualArgs[num2++]).Value = GetLastPosition();
				}
				QilNode qilNode2 = InvokeApplyFunction(null, mode, actualArgs);
				if (IsDebug)
				{
					qilNode2 = f.Sequence(InvokeOnCurrentNodeChanged(), qilNode2);
				}
				QilLoop child = curLoop.ConstructLoop(qilNode2);
				curLoop = loopFocus;
				((QilUnary)qilTernary.Center).Child = child;
			}
			return f.Invoke(qilFunction, qilList);
		}

		public void ReportError(string res, params string[] args)
		{
			compiler.ReportError(lastScope.SourceLine, res, args);
		}

		public void ReportWarning(string res, params string[] args)
		{
			compiler.ReportWarning(lastScope.SourceLine, res, args);
		}

		[Conditional("DEBUG")]
		private void VerifyXPathQName(QilName qname)
		{
		}

		private string ResolvePrefix(bool ignoreDefaultNs, string prefix)
		{
			if (ignoreDefaultNs && prefix.Length == 0)
			{
				return string.Empty;
			}
			string text = scope.LookupNamespace(prefix);
			if (text == null)
			{
				if (prefix.Length == 0)
				{
					text = string.Empty;
				}
				else
				{
					ReportError("Xslt_InvalidPrefix", prefix);
					text = compiler.CreatePhantomNamespace();
				}
			}
			return text;
		}

		private void SetLineInfoCheck(QilNode n, ISourceLineInfo lineInfo)
		{
			if (n.SourceLine == null)
			{
				SetLineInfo(n, lineInfo);
			}
		}

		private static QilNode SetLineInfo(QilNode n, ISourceLineInfo lineInfo)
		{
			if (lineInfo != null && 0 < lineInfo.StartLine && lineInfo.StartLine <= lineInfo.EndLine)
			{
				n.SourceLine = lineInfo;
			}
			return n;
		}

		private QilNode AddDebugVariable(QilName name, QilNode value, QilNode content)
		{
			QilIterator qilIterator = f.Let(value);
			qilIterator.DebugName = name.ToString();
			return f.Loop(qilIterator, content);
		}

		private QilNode SetDebugNs(QilNode n, QilList nsList)
		{
			if (n != null && nsList != null)
			{
				QilNode qilNode = GetNsVar(nsList);
				if (qilNode.XmlType.Cardinality == XmlQueryCardinality.One)
				{
					qilNode = f.TypeAssert(qilNode, XmlQueryTypeFactory.NamespaceS);
				}
				n = AddDebugVariable(CloneName(nameNamespaces), qilNode, n);
			}
			return n;
		}

		private QilNode AddCurrentPositionLast(QilNode content)
		{
			if (IsDebug)
			{
				content = AddDebugVariable(CloneName(nameLast), GetLastPosition(), content);
				content = AddDebugVariable(CloneName(namePosition), GetCurrentPosition(), content);
				content = AddDebugVariable(CloneName(nameCurrent), GetCurrentNode(), content);
			}
			return content;
		}

		private QilName CloneName(QilName name)
		{
			return (QilName)name.ShallowClone(f.BaseFactory);
		}

		private void SetEnvironmentFlags(bool allowVariables, bool allowCurrent, bool allowKey)
		{
			this.allowVariables = allowVariables;
			this.allowCurrent = allowCurrent;
			this.allowKey = allowKey;
		}

		QilNode IFocus.GetCurrent()
		{
			return GetCurrentNode();
		}

		QilNode IFocus.GetPosition()
		{
			return GetCurrentPosition();
		}

		QilNode IFocus.GetLast()
		{
			return GetLastPosition();
		}

		string IXPathEnvironment.ResolvePrefix(string prefix)
		{
			return ResolvePrefixThrow(ignoreDefaultNs: true, prefix);
		}

		QilNode IXPathEnvironment.ResolveVariable(string prefix, string name)
		{
			if (!allowVariables)
			{
				throw new XslLoadException("Xslt_VariablesNotAllowed");
			}
			string uri = ResolvePrefixThrow(ignoreDefaultNs: true, prefix);
			QilNode qilNode = scope.LookupVariable(name, uri);
			if (qilNode == null)
			{
				throw new XslLoadException("Xslt_InvalidVariable", Compiler.ConstructQName(prefix, name));
			}
			XmlQueryType xmlType = qilNode.XmlType;
			if (qilNode.NodeType == QilNodeType.Parameter && xmlType.IsNode && xmlType.IsNotRtf && xmlType.MaybeMany && !xmlType.IsDod)
			{
				qilNode = f.TypeAssert(qilNode, XmlQueryTypeFactory.NodeDodS);
			}
			return qilNode;
		}

		QilNode IXPathEnvironment.ResolveFunction(string prefix, string name, IList<QilNode> args, IFocus env)
		{
			if (prefix.Length == 0)
			{
				if (FunctionTable.TryGetValue(name, out var value))
				{
					value.CastArguments(args, name, f);
					switch (value.id)
					{
					case FuncId.Current:
						if (!allowCurrent)
						{
							throw new XslLoadException("Xslt_CurrentNotAllowed");
						}
						return ((IFocus)this).GetCurrent();
					case FuncId.Key:
						if (!allowKey)
						{
							throw new XslLoadException("Xslt_KeyNotAllowed");
						}
						return CompileFnKey(args[0], args[1], env);
					case FuncId.Document:
						return CompileFnDocument(args[0], (args.Count > 1) ? args[1] : null);
					case FuncId.FormatNumber:
						return CompileFormatNumber(args[0], args[1], (args.Count > 2) ? args[2] : null);
					case FuncId.UnparsedEntityUri:
						return CompileUnparsedEntityUri(args[0]);
					case FuncId.GenerateId:
						return CompileGenerateId((args.Count > 0) ? args[0] : env.GetCurrent());
					case FuncId.SystemProperty:
						return CompileSystemProperty(args[0]);
					case FuncId.ElementAvailable:
						return CompileElementAvailable(args[0]);
					case FuncId.FunctionAvailable:
						return CompileFunctionAvailable(args[0]);
					default:
						return null;
					}
				}
				throw new XslLoadException("Xslt_UnknownXsltFunction", Compiler.ConstructQName(prefix, name));
			}
			string text = ResolvePrefixThrow(ignoreDefaultNs: true, prefix);
			if (text == "urn:schemas-microsoft-com:xslt")
			{
				switch (name)
				{
				case "node-set":
					XPathBuilder.FunctionInfo<FuncId>.CheckArity(1, 1, name, args.Count);
					return CompileMsNodeSet(args[0]);
				case "string-compare":
					XPathBuilder.FunctionInfo<FuncId>.CheckArity(2, 4, name, args.Count);
					return f.InvokeMsStringCompare(f.ConvertToString(args[0]), f.ConvertToString(args[1]), (2 < args.Count) ? f.ConvertToString(args[2]) : f.String(string.Empty), (3 < args.Count) ? f.ConvertToString(args[3]) : f.String(string.Empty));
				case "utc":
					XPathBuilder.FunctionInfo<FuncId>.CheckArity(1, 1, name, args.Count);
					return f.InvokeMsUtc(f.ConvertToString(args[0]));
				case "format-date":
				case "format-time":
					XPathBuilder.FunctionInfo<FuncId>.CheckArity(1, 3, name, args.Count);
					return f.InvokeMsFormatDateTime(f.ConvertToString(args[0]), (1 < args.Count) ? f.ConvertToString(args[1]) : f.String(string.Empty), (2 < args.Count) ? f.ConvertToString(args[2]) : f.String(string.Empty), f.Boolean(name == "format-date"));
				case "local-name":
					XPathBuilder.FunctionInfo<FuncId>.CheckArity(1, 1, name, args.Count);
					return f.InvokeMsLocalName(f.ConvertToString(args[0]));
				case "namespace-uri":
					XPathBuilder.FunctionInfo<FuncId>.CheckArity(1, 1, name, args.Count);
					return f.InvokeMsNamespaceUri(f.ConvertToString(args[0]), env.GetCurrent());
				case "number":
					XPathBuilder.FunctionInfo<FuncId>.CheckArity(1, 1, name, args.Count);
					return f.InvokeMsNumber(args[0]);
				}
			}
			if (text == "http://exslt.org/common")
			{
				if (name == "node-set")
				{
					XPathBuilder.FunctionInfo<FuncId>.CheckArity(1, 1, name, args.Count);
					return CompileMsNodeSet(args[0]);
				}
				if (name == "object-type")
				{
					XPathBuilder.FunctionInfo<FuncId>.CheckArity(1, 1, name, args.Count);
					return EXslObjectType(args[0]);
				}
			}
			for (int i = 0; i < args.Count; i++)
			{
				args[i] = f.SafeDocOrderDistinct(args[i]);
			}
			if (compiler.Settings.EnableScript)
			{
				XmlExtensionFunction xmlExtensionFunction = compiler.Scripts.ResolveFunction(name, text, args.Count, this);
				if (xmlExtensionFunction != null)
				{
					return GenerateScriptCall(f.QName(name, text, prefix), xmlExtensionFunction, args);
				}
			}
			else if (compiler.Scripts.ScriptClasses.ContainsKey(text))
			{
				ReportWarning("Xslt_ScriptsProhibited");
				return f.Error(lastScope.SourceLine, "Xslt_ScriptsProhibited");
			}
			return f.XsltInvokeLateBound(f.QName(name, text, prefix), args);
		}

		private QilNode GenerateScriptCall(QilName name, XmlExtensionFunction scrFunc, IList<QilNode> args)
		{
			for (int i = 0; i < args.Count; i++)
			{
				XmlQueryType xmlArgumentType = scrFunc.GetXmlArgumentType(i);
				switch (xmlArgumentType.TypeCode)
				{
				case XmlTypeCode.Boolean:
					args[i] = f.ConvertToBoolean(args[i]);
					break;
				case XmlTypeCode.Double:
					args[i] = f.ConvertToNumber(args[i]);
					break;
				case XmlTypeCode.String:
					args[i] = f.ConvertToString(args[i]);
					break;
				case XmlTypeCode.Node:
					args[i] = (xmlArgumentType.IsSingleton ? f.ConvertToNode(args[i]) : f.ConvertToNodeSet(args[i]));
					break;
				}
			}
			return f.XsltInvokeEarlyBound(name, scrFunc.Method, scrFunc.XmlReturnType, args);
		}

		private string ResolvePrefixThrow(bool ignoreDefaultNs, string prefix)
		{
			if (ignoreDefaultNs && prefix.Length == 0)
			{
				return string.Empty;
			}
			string text = scope.LookupNamespace(prefix);
			if (text == null)
			{
				if (prefix.Length != 0)
				{
					throw new XslLoadException("Xslt_InvalidPrefix", prefix);
				}
				text = string.Empty;
			}
			return text;
		}

		private static Dictionary<string, XPathBuilder.FunctionInfo<FuncId>> CreateFunctionTable()
		{
			Dictionary<string, XPathBuilder.FunctionInfo<FuncId>> dictionary = new Dictionary<string, XPathBuilder.FunctionInfo<FuncId>>(16);
			dictionary.Add("current", new XPathBuilder.FunctionInfo<FuncId>(FuncId.Current, 0, 0, null));
			dictionary.Add("document", new XPathBuilder.FunctionInfo<FuncId>(FuncId.Document, 1, 2, argFnDocument));
			dictionary.Add("key", new XPathBuilder.FunctionInfo<FuncId>(FuncId.Key, 2, 2, argFnKey));
			dictionary.Add("format-number", new XPathBuilder.FunctionInfo<FuncId>(FuncId.FormatNumber, 2, 3, argFnFormatNumber));
			dictionary.Add("unparsed-entity-uri", new XPathBuilder.FunctionInfo<FuncId>(FuncId.UnparsedEntityUri, 1, 1, XPathBuilder.argString));
			dictionary.Add("generate-id", new XPathBuilder.FunctionInfo<FuncId>(FuncId.GenerateId, 0, 1, XPathBuilder.argNodeSet));
			dictionary.Add("system-property", new XPathBuilder.FunctionInfo<FuncId>(FuncId.SystemProperty, 1, 1, XPathBuilder.argString));
			dictionary.Add("element-available", new XPathBuilder.FunctionInfo<FuncId>(FuncId.ElementAvailable, 1, 1, XPathBuilder.argString));
			dictionary.Add("function-available", new XPathBuilder.FunctionInfo<FuncId>(FuncId.FunctionAvailable, 1, 1, XPathBuilder.argString));
			return dictionary;
		}

		public static bool IsFunctionAvailable(string localName, string nsUri)
		{
			if (XPathBuilder.IsFunctionAvailable(localName, nsUri))
			{
				return true;
			}
			if (nsUri.Length == 0)
			{
				if (FunctionTable.ContainsKey(localName))
				{
					return localName != "unparsed-entity-uri";
				}
				return false;
			}
			if (nsUri == "urn:schemas-microsoft-com:xslt")
			{
				switch (localName)
				{
				default:
					return localName == "utc";
				case "node-set":
				case "format-date":
				case "format-time":
				case "local-name":
				case "namespace-uri":
				case "number":
				case "string-compare":
					return true;
				}
			}
			if (nsUri == "http://exslt.org/common")
			{
				if (!(localName == "node-set"))
				{
					return localName == "object-type";
				}
				return true;
			}
			return false;
		}

		public static bool IsElementAvailable(XmlQualifiedName name)
		{
			if (name.Namespace == "http://www.w3.org/1999/XSL/Transform")
			{
				string name2 = name.Name;
				switch (name2)
				{
				default:
					return name2 == "variable";
				case "apply-imports":
				case "apply-templates":
				case "attribute":
				case "call-template":
				case "choose":
				case "comment":
				case "copy":
				case "copy-of":
				case "element":
				case "fallback":
				case "for-each":
				case "if":
				case "message":
				case "number":
				case "processing-instruction":
				case "text":
				case "value-of":
					return true;
				}
			}
			return false;
		}

		private QilNode CompileFnKey(QilNode name, QilNode keys, IFocus env)
		{
			QilIterator name2;
			QilIterator expr;
			QilIterator n;
			QilNode collection = (keys.XmlType.IsNode ? ((!keys.XmlType.IsSingleton) ? f.Loop(n = f.For(keys), CompileSingleKey(name, f.ConvertToString(n), env)) : CompileSingleKey(name, f.ConvertToString(keys), env)) : ((!keys.XmlType.IsAtomicValue) ? f.Loop(name2 = f.Let(name), f.Loop(expr = f.Let(keys), f.Conditional(f.Not(f.IsType(expr, XmlQueryTypeFactory.AnyAtomicType)), f.Loop(n = f.For(f.TypeAssert(expr, XmlQueryTypeFactory.NodeS)), CompileSingleKey(name2, f.ConvertToString(n), env)), CompileSingleKey(name2, f.XsltConvert(expr, XmlQueryTypeFactory.StringX), env)))) : CompileSingleKey(name, f.ConvertToString(keys), env)));
			return f.DocOrderDistinct(collection);
		}

		private QilNode CompileSingleKey(QilNode name, QilNode key, IFocus env)
		{
			if (name.NodeType == QilNodeType.LiteralString)
			{
				string text = (QilLiteral)name;
				compiler.ParseQName(text, out var prefix, out var localName, default(ThrowErrorHelper));
				string uri = ResolvePrefixThrow(ignoreDefaultNs: true, prefix);
				QilName key2 = f.QName(localName, uri, prefix);
				if (!compiler.Keys.Contains(key2))
				{
					throw new XslLoadException("Xslt_UndefinedKey", text);
				}
				return CompileSingleKey(compiler.Keys[key2], key, env);
			}
			if (generalKey == null)
			{
				generalKey = CreateGeneralKeyFunction();
			}
			QilIterator qilIterator = f.Let(name);
			QilNode qilNode = ResolveQNameDynamic(ignoreDefaultNs: true, qilIterator);
			QilNode body = f.Invoke(generalKey, f.ActualParameterList(qilIterator, qilNode, key, env.GetCurrent()));
			return f.Loop(qilIterator, body);
		}

		private QilNode CompileSingleKey(List<Key> defList, QilNode key, IFocus env)
		{
			if (defList.Count == 1)
			{
				return f.Invoke(defList[0].Function, f.ActualParameterList(env.GetCurrent(), key));
			}
			QilIterator qilIterator = f.Let(key);
			QilNode qilNode = f.Sequence();
			foreach (Key def in defList)
			{
				qilNode.Add(f.Invoke(def.Function, f.ActualParameterList(env.GetCurrent(), qilIterator)));
			}
			return f.Loop(qilIterator, qilNode);
		}

		private QilNode CompileSingleKey(List<Key> defList, QilIterator key, QilIterator context)
		{
			QilList qilList = f.BaseFactory.Sequence();
			QilNode qilNode = null;
			foreach (Key def in defList)
			{
				qilNode = f.Invoke(def.Function, f.ActualParameterList(context, key));
				qilList.Add(qilNode);
			}
			if (defList.Count != 1)
			{
				return qilList;
			}
			return qilNode;
		}

		private QilFunction CreateGeneralKeyFunction()
		{
			QilIterator qilIterator = f.Parameter(XmlQueryTypeFactory.StringX);
			QilIterator qilIterator2 = f.Parameter(XmlQueryTypeFactory.QNameX);
			QilIterator qilIterator3 = f.Parameter(XmlQueryTypeFactory.StringX);
			QilIterator qilIterator4 = f.Parameter(XmlQueryTypeFactory.NodeNotRtf);
			QilNode qilNode = f.Error("Xslt_UndefinedKey", qilIterator);
			for (int i = 0; i < compiler.Keys.Count; i++)
			{
				qilNode = f.Conditional(f.Eq(qilIterator2, compiler.Keys[i][0].Name.DeepClone(f.BaseFactory)), CompileSingleKey(compiler.Keys[i], qilIterator3, qilIterator4), qilNode);
			}
			QilFunction qilFunction = f.Function(f.FormalParameterList(qilIterator, qilIterator2, qilIterator3, qilIterator4), qilNode, f.False());
			qilFunction.DebugName = "key";
			functions.Add(qilFunction);
			return qilFunction;
		}

		private QilNode CompileFnDocument(QilNode uris, QilNode baseNode)
		{
			if (!compiler.Settings.EnableDocumentFunction)
			{
				ReportWarning("Xslt_DocumentFuncProhibited");
				return f.Error(lastScope.SourceLine, "Xslt_DocumentFuncProhibited");
			}
			QilIterator qilIterator;
			if (uris.XmlType.IsNode)
			{
				return f.DocOrderDistinct(f.Loop(qilIterator = f.For(uris), CompileSingleDocument(f.ConvertToString(qilIterator), baseNode ?? qilIterator)));
			}
			if (uris.XmlType.IsAtomicValue)
			{
				return CompileSingleDocument(f.ConvertToString(uris), baseNode);
			}
			QilIterator qilIterator2 = f.Let(uris);
			QilIterator qilIterator3 = ((baseNode != null) ? f.Let(baseNode) : null);
			QilNode qilNode = f.Conditional(f.Not(f.IsType(qilIterator2, XmlQueryTypeFactory.AnyAtomicType)), f.DocOrderDistinct(f.Loop(qilIterator = f.For(f.TypeAssert(qilIterator2, XmlQueryTypeFactory.NodeS)), CompileSingleDocument(f.ConvertToString(qilIterator), qilIterator3 ?? qilIterator))), CompileSingleDocument(f.XsltConvert(qilIterator2, XmlQueryTypeFactory.StringX), qilIterator3));
			qilNode = ((baseNode != null) ? f.Loop(qilIterator3, qilNode) : qilNode);
			return f.Loop(qilIterator2, qilNode);
		}

		private QilNode CompileSingleDocument(QilNode uri, QilNode baseNode)
		{
			QilIterator n;
			QilNode baseUri = ((baseNode == null) ? f.String(lastScope.SourceLine.Uri) : ((!baseNode.XmlType.IsSingleton) ? f.StrConcat(f.Loop(n = f.FirstNode(baseNode), f.InvokeBaseUri(n))) : f.InvokeBaseUri(baseNode)));
			return f.DataSource(uri, baseUri);
		}

		private QilNode CompileFormatNumber(QilNode value, QilNode formatPicture, QilNode formatName)
		{
			XmlQualifiedName xmlQualifiedName;
			if (formatName != null)
			{
				xmlQualifiedName = ((formatName.NodeType != QilNodeType.LiteralString) ? null : ResolveQNameThrow(ignoreDefaultNs: true, formatName));
			}
			else
			{
				xmlQualifiedName = new XmlQualifiedName();
				formatName = f.String(string.Empty);
			}
			if (xmlQualifiedName != null)
			{
				DecimalFormatDecl format;
				if (compiler.DecimalFormats.Contains(xmlQualifiedName))
				{
					format = compiler.DecimalFormats[xmlQualifiedName];
				}
				else
				{
					if (xmlQualifiedName != DecimalFormatDecl.Default.Name)
					{
						throw new XslLoadException("Xslt_NoDecimalFormat", (QilLiteral)formatName);
					}
					format = DecimalFormatDecl.Default;
				}
				if (formatPicture.NodeType == QilNodeType.LiteralString)
				{
					QilIterator qilIterator = f.Let(f.InvokeRegisterDecimalFormatter(formatPicture, format));
					qilIterator.DebugName = f.QName("formatter" + formatterCnt++, "urn:schemas-microsoft-com:xslt-debug").ToString();
					gloVars.Add(qilIterator);
					return f.InvokeFormatNumberStatic(value, qilIterator);
				}
				formatNumberDynamicUsed = true;
				QilNode decimalFormatName = f.QName(xmlQualifiedName.Name, xmlQualifiedName.Namespace);
				return f.InvokeFormatNumberDynamic(value, formatPicture, decimalFormatName, formatName);
			}
			formatNumberDynamicUsed = true;
			QilIterator qilIterator2 = f.Let(formatName);
			QilNode decimalFormatName2 = ResolveQNameDynamic(ignoreDefaultNs: true, qilIterator2);
			return f.Loop(qilIterator2, f.InvokeFormatNumberDynamic(value, formatPicture, decimalFormatName2, qilIterator2));
		}

		private QilNode CompileUnparsedEntityUri(QilNode n)
		{
			return f.Error(lastScope.SourceLine, "Xslt_UnsupportedXsltFunction", "unparsed-entity-uri");
		}

		private QilNode CompileGenerateId(QilNode n)
		{
			if (n.XmlType.IsSingleton)
			{
				return f.XsltGenerateId(n);
			}
			QilIterator expr;
			return f.StrConcat(f.Loop(expr = f.FirstNode(n), f.XsltGenerateId(expr)));
		}

		private XmlQualifiedName ResolveQNameThrow(bool ignoreDefaultNs, QilNode qilName)
		{
			string qname = (QilLiteral)qilName;
			compiler.ParseQName(qname, out var prefix, out var localName, default(ThrowErrorHelper));
			string ns = ResolvePrefixThrow(ignoreDefaultNs, prefix);
			return new XmlQualifiedName(localName, ns);
		}

		private QilNode CompileSystemProperty(QilNode name)
		{
			if (name.NodeType == QilNodeType.LiteralString)
			{
				XmlQualifiedName xmlQualifiedName = ResolveQNameThrow(ignoreDefaultNs: true, name);
				if (EvaluateFuncCalls)
				{
					XPathItem xPathItem = XsltFunctions.SystemProperty(xmlQualifiedName);
					if (xPathItem.ValueType == XsltConvert.StringType)
					{
						return f.String(xPathItem.Value);
					}
					return f.Double(xPathItem.ValueAsDouble);
				}
				name = f.QName(xmlQualifiedName.Name, xmlQualifiedName.Namespace);
			}
			else
			{
				name = ResolveQNameDynamic(ignoreDefaultNs: true, name);
			}
			return f.InvokeSystemProperty(name);
		}

		private QilNode CompileElementAvailable(QilNode name)
		{
			if (name.NodeType == QilNodeType.LiteralString)
			{
				XmlQualifiedName xmlQualifiedName = ResolveQNameThrow(ignoreDefaultNs: false, name);
				if (EvaluateFuncCalls)
				{
					return f.Boolean(IsElementAvailable(xmlQualifiedName));
				}
				name = f.QName(xmlQualifiedName.Name, xmlQualifiedName.Namespace);
			}
			else
			{
				name = ResolveQNameDynamic(ignoreDefaultNs: false, name);
			}
			return f.InvokeElementAvailable(name);
		}

		private QilNode CompileFunctionAvailable(QilNode name)
		{
			if (name.NodeType == QilNodeType.LiteralString)
			{
				XmlQualifiedName xmlQualifiedName = ResolveQNameThrow(ignoreDefaultNs: true, name);
				if (EvaluateFuncCalls && (xmlQualifiedName.Namespace.Length == 0 || xmlQualifiedName.Namespace == "http://www.w3.org/1999/XSL/Transform"))
				{
					return f.Boolean(IsFunctionAvailable(xmlQualifiedName.Name, xmlQualifiedName.Namespace));
				}
				name = f.QName(xmlQualifiedName.Name, xmlQualifiedName.Namespace);
			}
			else
			{
				name = ResolveQNameDynamic(ignoreDefaultNs: true, name);
			}
			return f.InvokeFunctionAvailable(name);
		}

		private QilNode CompileMsNodeSet(QilNode n)
		{
			if (n.XmlType.IsNode && n.XmlType.IsNotRtf)
			{
				return n;
			}
			return f.XsltConvert(n, XmlQueryTypeFactory.NodeDodS);
		}

		private QilNode EXslObjectType(QilNode n)
		{
			if (EvaluateFuncCalls)
			{
				switch (n.XmlType.TypeCode)
				{
				case XmlTypeCode.Boolean:
					return f.String("boolean");
				case XmlTypeCode.Double:
					return f.String("number");
				case XmlTypeCode.String:
					return f.String("string");
				}
				if (n.XmlType.IsNode && n.XmlType.IsNotRtf)
				{
					return f.String("node-set");
				}
			}
			return f.InvokeEXslObjectType(n);
		}
	}
	internal class QilStrConcatenator
	{
		private XPathQilFactory f;

		private BufferBuilder builder;

		private QilList concat;

		private bool inUse;

		public QilStrConcatenator(XPathQilFactory f)
		{
			this.f = f;
			builder = new BufferBuilder();
		}

		public void Reset()
		{
			inUse = true;
			builder.Clear();
			concat = null;
		}

		private void FlushBuilder()
		{
			if (concat == null)
			{
				concat = f.BaseFactory.Sequence();
			}
			if (builder.Length != 0)
			{
				concat.Add(f.String(builder.ToString()));
				builder.Length = 0;
			}
		}

		public void Append(string value)
		{
			builder.Append(value);
		}

		public void Append(char value)
		{
			builder.Append(value);
		}

		public void Append(QilNode value)
		{
			if (value != null)
			{
				if (value.NodeType == QilNodeType.LiteralString)
				{
					builder.Append((QilLiteral)value);
					return;
				}
				FlushBuilder();
				concat.Add(value);
			}
		}

		public QilNode ToQil()
		{
			inUse = false;
			if (concat == null)
			{
				return f.String(builder.ToString());
			}
			FlushBuilder();
			return f.StrConcat(concat);
		}
	}
	internal class ScriptClass
	{
		public string ns;

		public CompilerInfo compilerInfo;

		public StringCollection refAssemblies = new StringCollection();

		public StringCollection nsImports = new StringCollection();

		public StringCollection scriptFiles = new StringCollection();

		public CodeTypeDeclaration typeDecl;

		public bool refAssembliesByHref;

		public string endFileName;

		public int endLine;

		public int endPos;

		private static long scriptClassCounter;

		public ScriptClass(string ns, CompilerInfo compilerInfo)
		{
			this.ns = ns;
			this.compilerInfo = compilerInfo;
			typeDecl = new CodeTypeDeclaration(GenerateUniqueClassName());
		}

		private static string GenerateUniqueClassName()
		{
			return "Script" + Interlocked.Increment(ref scriptClassCounter);
		}

		public void AddScriptBlock(string source, string uriString, int lineNumber, int endLine, int endPos)
		{
			CodeSnippetTypeMember codeSnippetTypeMember = new CodeSnippetTypeMember(source);
			string fileName = SourceLineInfo.GetFileName(uriString);
			if (lineNumber > 0)
			{
				codeSnippetTypeMember.LinePragma = new CodeLinePragma(fileName, lineNumber);
				scriptFiles.Add(fileName);
			}
			typeDecl.Members.Add(codeSnippetTypeMember);
			endFileName = fileName;
			this.endLine = endLine;
			this.endPos = endPos;
		}

		public CompilerError CreateCompileExceptionError(Exception e)
		{
			string errorText = XslTransformException.CreateMessage("Xslt_ScriptCompileException", e.Message);
			return new CompilerError(endFileName, endLine, endPos, string.Empty, errorText);
		}
	}
	internal class Scripts
	{
		private const string ScriptClassesNamespace = "System.Xml.Xsl.CompiledQuery";

		private Compiler compiler;

		private List<ScriptClass> scriptClasses = new List<ScriptClass>();

		private Dictionary<string, Type> nsToType = new Dictionary<string, Type>();

		private XmlExtensionFunctionTable extFuncs = new XmlExtensionFunctionTable();

		private static readonly string[] defaultNamespaces = new string[7] { "System", "System.Collections", "System.Text", "System.Text.RegularExpressions", "System.Xml", "System.Xml.Xsl", "System.Xml.XPath" };

		private int assemblyCounter;

		private static readonly StringComparison fileNameComparison = StringComparison.OrdinalIgnoreCase;

		public Dictionary<string, Type> ScriptClasses => nsToType;

		public Scripts(Compiler compiler)
		{
			this.compiler = compiler;
		}

		public XmlExtensionFunction ResolveFunction(string name, string ns, int numArgs, IErrorHelper errorHelper)
		{
			if (nsToType.TryGetValue(ns, out var value))
			{
				try
				{
					return extFuncs.Bind(name, ns, numArgs, value, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public);
				}
				catch (XslTransformException ex)
				{
					errorHelper.ReportError(ex.Message);
				}
			}
			return null;
		}

		public ScriptClass GetScriptClass(string ns, string language, IErrorHelper errorHelper)
		{
			CompilerInfo compilerInfo;
			try
			{
				compilerInfo = CodeDomProvider.GetCompilerInfo(language);
			}
			catch (ConfigurationException)
			{
				errorHelper.ReportError("Xslt_ScriptInvalidLanguage", language);
				return null;
			}
			foreach (ScriptClass scriptClass2 in scriptClasses)
			{
				if (ns == scriptClass2.ns)
				{
					if (compilerInfo != scriptClass2.compilerInfo)
					{
						errorHelper.ReportError("Xslt_ScriptMixedLanguages", ns);
						return null;
					}
					return scriptClass2;
				}
			}
			ScriptClass scriptClass = new ScriptClass(ns, compilerInfo);
			scriptClass.typeDecl.TypeAttributes = TypeAttributes.Public;
			scriptClasses.Add(scriptClass);
			return scriptClass;
		}

		public void CompileScripts()
		{
			List<ScriptClass> list = new List<ScriptClass>();
			for (int i = 0; i < scriptClasses.Count; i++)
			{
				if (scriptClasses[i] == null)
				{
					continue;
				}
				CompilerInfo compilerInfo = scriptClasses[i].compilerInfo;
				list.Clear();
				for (int j = i; j < scriptClasses.Count; j++)
				{
					if (scriptClasses[j] != null && scriptClasses[j].compilerInfo == compilerInfo)
					{
						list.Add(scriptClasses[j]);
						scriptClasses[j] = null;
					}
				}
				Assembly assembly = CompileAssembly(list);
				if (assembly == null)
				{
					continue;
				}
				foreach (ScriptClass item in list)
				{
					Type type = assembly.GetType("System.Xml.Xsl.CompiledQuery" + Type.Delimiter + item.typeDecl.Name);
					if (type != null)
					{
						nsToType.Add(item.ns, type);
					}
				}
			}
		}

		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		private Assembly CompileAssembly(List<ScriptClass> scriptsForLang)
		{
			TempFileCollection tempFiles = compiler.CompilerResults.TempFiles;
			CompilerErrorCollection errors = compiler.CompilerResults.Errors;
			ScriptClass scriptClass = scriptsForLang[scriptsForLang.Count - 1];
			bool flag = false;
			CodeDomProvider codeDomProvider;
			try
			{
				codeDomProvider = scriptClass.compilerInfo.CreateProvider();
			}
			catch (ConfigurationException e)
			{
				errors.Add(scriptClass.CreateCompileExceptionError(e));
				return null;
			}
			flag = codeDomProvider is VBCodeProvider;
			CodeCompileUnit[] array = new CodeCompileUnit[scriptsForLang.Count];
			CompilerParameters compilerParameters = scriptClass.compilerInfo.CreateDefaultCompilerParameters();
			compilerParameters.ReferencedAssemblies.Add(typeof(Res).Assembly.Location);
			compilerParameters.ReferencedAssemblies.Add("System.dll");
			if (flag)
			{
				compilerParameters.ReferencedAssemblies.Add("Microsoft.VisualBasic.dll");
			}
			bool flag2 = false;
			for (int i = 0; i < scriptsForLang.Count; i++)
			{
				ScriptClass scriptClass2 = scriptsForLang[i];
				CodeNamespace codeNamespace = new CodeNamespace("System.Xml.Xsl.CompiledQuery");
				string[] array2 = defaultNamespaces;
				foreach (string nameSpace in array2)
				{
					codeNamespace.Imports.Add(new CodeNamespaceImport(nameSpace));
				}
				if (flag)
				{
					codeNamespace.Imports.Add(new CodeNamespaceImport("Microsoft.VisualBasic"));
				}
				StringEnumerator enumerator = scriptClass2.nsImports.GetEnumerator();
				try
				{
					while (enumerator.MoveNext())
					{
						string current = enumerator.Current;
						codeNamespace.Imports.Add(new CodeNamespaceImport(current));
					}
				}
				finally
				{
					if (enumerator is IDisposable disposable)
					{
						disposable.Dispose();
					}
				}
				codeNamespace.Types.Add(scriptClass2.typeDecl);
				CodeCompileUnit codeCompileUnit = new CodeCompileUnit();
				codeCompileUnit.Namespaces.Add(codeNamespace);
				if (flag)
				{
					codeCompileUnit.UserData["AllowLateBound"] = true;
					codeCompileUnit.UserData["RequireVariableDeclaration"] = false;
				}
				if (i == 0)
				{
					codeCompileUnit.AssemblyCustomAttributes.Add(new CodeAttributeDeclaration("System.Security.SecurityTransparentAttribute"));
				}
				array[i] = codeCompileUnit;
				StringEnumerator enumerator2 = scriptClass2.refAssemblies.GetEnumerator();
				try
				{
					while (enumerator2.MoveNext())
					{
						string current2 = enumerator2.Current;
						compilerParameters.ReferencedAssemblies.Add(current2);
					}
				}
				finally
				{
					if (enumerator2 is IDisposable disposable2)
					{
						disposable2.Dispose();
					}
				}
				flag2 |= scriptClass2.refAssembliesByHref;
			}
			XsltSettings settings = compiler.Settings;
			compilerParameters.WarningLevel = ((settings.WarningLevel >= 0) ? settings.WarningLevel : compilerParameters.WarningLevel);
			compilerParameters.TreatWarningsAsErrors = settings.TreatWarningsAsErrors;
			compilerParameters.IncludeDebugInformation = compiler.IsDebug;
			string text = compiler.ScriptAssemblyPath;
			if (text != null && scriptsForLang.Count < scriptClasses.Count)
			{
				text = Path.ChangeExtension(text, "." + GetLanguageName(scriptClass.compilerInfo) + Path.GetExtension(text));
			}
			compilerParameters.OutputAssembly = text;
			string tempDir = ((settings.TempFiles != null) ? settings.TempFiles.TempDir : null);
			compilerParameters.TempFiles = new TempFileCollection(tempDir);
			bool keepFiles = ((compiler.IsDebug && text == null) || XmlILTrace.IsEnabled) && !settings.CheckOnly;
			compilerParameters.TempFiles.KeepFiles = keepFiles;
			compilerParameters.GenerateInMemory = (text == null && !compiler.IsDebug && !flag2) || settings.CheckOnly;
			CompilerResults compilerResults;
			try
			{
				compilerResults = codeDomProvider.CompileAssemblyFromDom(compilerParameters, array);
			}
			catch (ExternalException e2)
			{
				compilerResults = new CompilerResults(compilerParameters.TempFiles);
				compilerResults.Errors.Add(scriptClass.CreateCompileExceptionError(e2));
			}
			if (!settings.CheckOnly)
			{
				foreach (string tempFile in compilerResults.TempFiles)
				{
					tempFiles.AddFile(tempFile, tempFiles.KeepFiles);
				}
			}
			foreach (CompilerError error in compilerResults.Errors)
			{
				FixErrorPosition(error, scriptsForLang);
			}
			errors.AddRange(compilerResults.Errors);
			if (!compilerResults.Errors.HasErrors)
			{
				return compilerResults.CompiledAssembly;
			}
			return null;
		}

		private string GetLanguageName(CompilerInfo compilerInfo)
		{
			Regex regex = new Regex("^[0-9a-zA-Z]+$");
			string[] languages = compilerInfo.GetLanguages();
			foreach (string text in languages)
			{
				if (regex.IsMatch(text))
				{
					return text;
				}
			}
			return "script" + (++assemblyCounter).ToString(CultureInfo.InvariantCulture);
		}

		private static void FixErrorPosition(CompilerError error, List<ScriptClass> scriptsForLang)
		{
			string fileName = error.FileName;
			foreach (ScriptClass item in scriptsForLang)
			{
				StringEnumerator enumerator2 = item.scriptFiles.GetEnumerator();
				try
				{
					while (enumerator2.MoveNext())
					{
						string current2 = enumerator2.Current;
						if (fileName.Equals(current2, fileNameComparison))
						{
							error.FileName = current2;
							return;
						}
					}
				}
				finally
				{
					if (enumerator2 is IDisposable disposable)
					{
						disposable.Dispose();
					}
				}
			}
			ScriptClass scriptClass = scriptsForLang[scriptsForLang.Count - 1];
			fileName = Path.GetFileNameWithoutExtension(fileName);
			int num;
			if ((num = fileName.LastIndexOf('.')) >= 0 && int.TryParse(fileName.Substring(num + 1), NumberStyles.None, NumberFormatInfo.InvariantInfo, out var result) && (uint)result < scriptsForLang.Count)
			{
				scriptClass = scriptsForLang[result];
			}
			error.FileName = scriptClass.endFileName;
			error.Line = scriptClass.endLine;
			error.Column = scriptClass.endPos;
		}
	}
	internal class Stylesheet
	{
		private Compiler compiler;

		public List<Uri> ImportHrefs = new List<Uri>();

		public Stylesheet[] Imports;

		public List<Template> Templates = new List<Template>();

		public List<XslNode> GlobalVarPars = new List<XslNode>();

		public Dictionary<QilName, AttributeSet> AttributeSets = new Dictionary<QilName, AttributeSet>();

		public Dictionary<QilName, List<TemplateMatch>> TemplateMatches = new Dictionary<QilName, List<TemplateMatch>>();

		public Dictionary<QilName, List<QilFunction>> ApplyImportsFunctions = new Dictionary<QilName, List<QilFunction>>();

		private int importPrecedence;

		private int orderNumber;

		public List<WhitespaceRule>[] WhitespaceRules = new List<WhitespaceRule>[3];

		public int ImportPrecedence => importPrecedence;

		public Stylesheet(Compiler compiler, int importPrecedence)
		{
			this.compiler = compiler;
			this.importPrecedence = importPrecedence;
			WhitespaceRules[0] = new List<WhitespaceRule>();
			WhitespaceRules[1] = new List<WhitespaceRule>();
			WhitespaceRules[2] = new List<WhitespaceRule>();
		}

		public void AddWhitespaceRule(int index, WhitespaceRule rule)
		{
			WhitespaceRules[index].Add(rule);
		}

		public bool AddVarPar(VarPar var)
		{
			foreach (XslNode globalVarPar in GlobalVarPars)
			{
				if (globalVarPar.Name.Equals(var.Name))
				{
					return compiler.AllGlobalVarPars.ContainsKey(var.Name);
				}
			}
			GlobalVarPars.Add(var);
			return true;
		}

		public bool AddTemplate(Template template)
		{
			template.ImportPrecedence = importPrecedence;
			template.OrderNumber = orderNumber++;
			compiler.AllTemplates.Add(template);
			if (template.Name != null)
			{
				if (!compiler.NamedTemplates.TryGetValue(template.Name, out var value))
				{
					compiler.NamedTemplates[template.Name] = template;
				}
				else if (value.ImportPrecedence == template.ImportPrecedence)
				{
					return false;
				}
			}
			if (template.Match != null)
			{
				Templates.Add(template);
			}
			return true;
		}

		public void AddTemplateMatch(Template template, QilLoop filter)
		{
			if (!TemplateMatches.TryGetValue(template.Mode, out var value))
			{
				List<TemplateMatch> list2 = (TemplateMatches[template.Mode] = new List<TemplateMatch>());
				value = list2;
			}
			value.Add(new TemplateMatch(template, filter));
		}

		public void SortTemplateMatches()
		{
			foreach (QilName key in TemplateMatches.Keys)
			{
				TemplateMatches[key].Sort(TemplateMatch.Comparer);
			}
		}
	}
	internal class XPathPatternBuilder : XPathPatternParser.IPatternBuilder, IXPathBuilder<QilNode>
	{
		private class Annotation
		{
			public double Priority;

			public QilLoop Parent;
		}

		private class XPathPredicateEnvironment : IXPathEnvironment, IFocus
		{
			internal class Cloner : QilCloneVisitor
			{
				public Cloner(QilFactory f)
					: base(f)
				{
				}

				protected override QilNode VisitUnknown(QilNode n)
				{
					return n;
				}
			}

			private IXPathEnvironment baseEnvironment;

			private QilLoop baseContext;

			private XPathQilFactory f;

			private Cloner cloner;

			public XPathQilFactory Factory => f;

			public XPathPredicateEnvironment(IXPathEnvironment baseEnvironment)
			{
				this.baseEnvironment = baseEnvironment;
				f = baseEnvironment.Factory;
				cloner = new Cloner(f.BaseFactory);
			}

			public void SetContext(QilLoop filter)
			{
				baseContext = filter;
			}

			public QilNode ResolveVariable(string prefix, string name)
			{
				return baseEnvironment.ResolveVariable(prefix, name);
			}

			public QilNode ResolveFunction(string prefix, string name, IList<QilNode> args, IFocus env)
			{
				return baseEnvironment.ResolveFunction(prefix, name, args, env);
			}

			public string ResolvePrefix(string prefix)
			{
				return baseEnvironment.ResolvePrefix(prefix);
			}

			public QilNode GetCurrent()
			{
				return baseContext.Variable;
			}

			public QilNode GetPosition()
			{
				QilLoop qilLoop = (QilLoop)cloner.Clone(baseContext);
				XmlNodeKindFlags nodeKinds = baseContext.XmlType.NodeKinds;
				if (nodeKinds == XmlNodeKindFlags.Attribute)
				{
					QilIterator qilIterator = f.For(f.Parent(GetCurrent()));
					qilLoop.Variable.Binding = f.Content(qilIterator);
					qilLoop.Body = f.And(qilLoop.Body, f.Before(qilLoop.Variable, GetCurrent()));
					qilLoop = f.BaseFactory.Loop(qilIterator, qilLoop);
				}
				else
				{
					qilLoop.Variable.Binding = f.PrecedingSibling(GetCurrent());
				}
				return f.Add(f.Double(1.0), f.XsltConvert(f.Length(qilLoop), XmlQueryTypeFactory.DoubleX));
			}

			public QilNode GetLast()
			{
				QilLoop qilLoop = (QilLoop)cloner.Clone(baseContext);
				QilIterator qilIterator = f.For(f.Parent(GetCurrent()));
				qilLoop.Variable.Binding = f.Content(qilIterator);
				return f.XsltConvert(f.Length(f.Loop(qilIterator, qilLoop)), XmlQueryTypeFactory.DoubleX);
			}
		}

		private class XsltFunctionFocus : IFocus
		{
			private QilIterator current;

			public XsltFunctionFocus(QilIterator current)
			{
				this.current = current;
			}

			public QilNode GetCurrent()
			{
				return current;
			}

			public QilNode GetPosition()
			{
				return null;
			}

			public QilNode GetLast()
			{
				return null;
			}
		}

		private XPathPredicateEnvironment predicateEnvironment;

		private XPathBuilder predicateBuilder;

		private bool inTheBuild;

		private XPathQilFactory f;

		private QilNode fixupNode;

		private IXPathEnvironment environment;

		public QilNode FixupNode => fixupNode;

		public XPathPatternBuilder(IXPathEnvironment environment)
		{
			this.environment = environment;
			f = environment.Factory;
			predicateEnvironment = new XPathPredicateEnvironment(environment);
			predicateBuilder = new XPathBuilder(predicateEnvironment);
			fixupNode = f.Unknown(XmlQueryTypeFactory.NodeNotRtfS);
		}

		public virtual void StartBuild()
		{
			inTheBuild = true;
		}

		[Conditional("DEBUG")]
		public void AssertFilter(QilLoop filter)
		{
		}

		private void FixupFilterBinding(QilLoop filter, QilNode newBinding)
		{
			filter.Variable.Binding = newBinding;
		}

		public virtual QilNode EndBuild(QilNode result)
		{
			inTheBuild = false;
			return result;
		}

		public QilNode Operator(XPathOperator op, QilNode left, QilNode right)
		{
			if (left.NodeType == QilNodeType.Sequence)
			{
				((QilList)left).Add(right);
				return left;
			}
			return f.Sequence(left, right);
		}

		private static QilLoop BuildAxisFilter(QilPatternFactory f, QilIterator itr, XPathAxis xpathAxis, XPathNodeType nodeType, string name, string nsUri)
		{
			QilNode right = ((name != null && nsUri != null) ? f.Eq(f.NameOf(itr), f.QName(name, nsUri)) : ((nsUri != null) ? f.Eq(f.NamespaceUriOf(itr), f.String(nsUri)) : ((name != null) ? f.Eq(f.LocalNameOf(itr), f.String(name)) : f.True())));
			XmlNodeKindFlags xmlNodeKindFlags = XPathBuilder.AxisTypeMask(itr.XmlType.NodeKinds, nodeType, xpathAxis);
			QilNode left = ((xmlNodeKindFlags == XmlNodeKindFlags.None) ? f.False() : ((xmlNodeKindFlags == itr.XmlType.NodeKinds) ? f.True() : f.IsType(itr, XmlQueryTypeFactory.NodeChoice(xmlNodeKindFlags))));
			QilLoop qilLoop = f.BaseFactory.Filter(itr, f.And(left, right));
			qilLoop.XmlType = XmlQueryTypeFactory.PrimeProduct(XmlQueryTypeFactory.NodeChoice(xmlNodeKindFlags), qilLoop.XmlType.Cardinality);
			return qilLoop;
		}

		public QilNode Axis(XPathAxis xpathAxis, XPathNodeType nodeType, string prefix, string name)
		{
			QilLoop qilLoop;
			double priority;
			switch (xpathAxis)
			{
			case XPathAxis.DescendantOrSelf:
				return f.Nop(fixupNode);
			case XPathAxis.Root:
			{
				QilIterator expr;
				qilLoop = f.BaseFactory.Filter(expr = f.For(fixupNode), f.IsType(expr, XmlQueryTypeFactory.Document));
				priority = 0.5;
				break;
			}
			default:
			{
				string nsUri = ((prefix == null) ? null : environment.ResolvePrefix(prefix));
				qilLoop = BuildAxisFilter(f, f.For(fixupNode), xpathAxis, nodeType, name, nsUri);
				switch (nodeType)
				{
				case XPathNodeType.Element:
				case XPathNodeType.Attribute:
					priority = ((name == null) ? ((prefix == null) ? (-0.5) : (-0.25)) : 0.0);
					break;
				case XPathNodeType.ProcessingInstruction:
					priority = ((name != null) ? 0.0 : (-0.5));
					break;
				default:
					priority = -0.5;
					break;
				}
				break;
			}
			}
			SetPriority(qilLoop, priority);
			SetLastParent(qilLoop, qilLoop);
			return qilLoop;
		}

		public QilNode JoinStep(QilNode left, QilNode right)
		{
			if (left.NodeType == QilNodeType.Nop)
			{
				QilUnary qilUnary = (QilUnary)left;
				qilUnary.Child = right;
				return qilUnary;
			}
			CleanAnnotation(left);
			QilLoop qilLoop = (QilLoop)left;
			bool flag = false;
			if (right.NodeType == QilNodeType.Nop)
			{
				flag = true;
				QilUnary qilUnary2 = (QilUnary)right;
				right = qilUnary2.Child;
			}
			QilLoop lastParent = GetLastParent(right);
			FixupFilterBinding(qilLoop, flag ? f.Ancestor(lastParent.Variable) : f.Parent(lastParent.Variable));
			lastParent.Body = f.And(lastParent.Body, f.Not(f.IsEmpty(qilLoop)));
			SetPriority(right, 0.5);
			SetLastParent(right, qilLoop);
			return right;
		}

		public QilNode Predicate(QilNode node, QilNode condition, bool isReverseStep)
		{
			QilLoop qilLoop = (QilLoop)node;
			if (condition.XmlType.TypeCode == XmlTypeCode.Double)
			{
				predicateEnvironment.SetContext(qilLoop);
				condition = f.Eq(condition, predicateEnvironment.GetPosition());
			}
			else
			{
				condition = f.ConvertToBoolean(condition);
			}
			qilLoop.Body = f.And(qilLoop.Body, condition);
			SetPriority(node, 0.5);
			return node;
		}

		public QilNode Function(string prefix, string name, IList<QilNode> args)
		{
			QilIterator qilIterator = f.For(fixupNode);
			QilNode binding = ((!(name == "id")) ? environment.ResolveFunction(prefix, name, args, new XsltFunctionFocus(qilIterator)) : f.Id(qilIterator, args[0]));
			QilIterator left;
			QilLoop qilLoop = f.BaseFactory.Filter(qilIterator, f.Not(f.IsEmpty(f.Filter(left = f.For(binding), f.Is(left, qilIterator)))));
			SetPriority(qilLoop, 0.5);
			SetLastParent(qilLoop, qilLoop);
			return qilLoop;
		}

		public QilNode String(string value)
		{
			return f.String(value);
		}

		public QilNode Number(double value)
		{
			return UnexpectedToken("Literal number");
		}

		public QilNode Variable(string prefix, string name)
		{
			return UnexpectedToken("Variable");
		}

		private QilNode UnexpectedToken(string tokenName)
		{
			string message = string.Format(CultureInfo.InvariantCulture, "Internal Error: {0} is not allowed in XSLT pattern outside of predicate.", tokenName);
			throw new Exception(message);
		}

		public static void SetPriority(QilNode node, double priority)
		{
			Annotation annotation = ((Annotation)node.Annotation) ?? new Annotation();
			annotation.Priority = priority;
			node.Annotation = annotation;
		}

		public static double GetPriority(QilNode node)
		{
			return ((Annotation)node.Annotation).Priority;
		}

		private static void SetLastParent(QilNode node, QilLoop parent)
		{
			Annotation annotation = ((Annotation)node.Annotation) ?? new Annotation();
			annotation.Parent = parent;
			node.Annotation = annotation;
		}

		private static QilLoop GetLastParent(QilNode node)
		{
			return ((Annotation)node.Annotation).Parent;
		}

		public static void CleanAnnotation(QilNode node)
		{
			node.Annotation = null;
		}

		public IXPathBuilder<QilNode> GetPredicateBuilder(QilNode ctx)
		{
			QilLoop context = (QilLoop)ctx;
			predicateEnvironment.SetContext(context);
			return predicateBuilder;
		}
	}
	internal enum XslNodeType
	{
		Unknown,
		ApplyImports,
		ApplyTemplates,
		Attribute,
		AttributeSet,
		CallTemplate,
		Choose,
		Comment,
		Copy,
		CopyOf,
		Element,
		Error,
		ForEach,
		If,
		Key,
		List,
		LiteralAttribute,
		LiteralElement,
		Message,
		Nop,
		Number,
		Otherwise,
		Param,
		PI,
		Sort,
		Template,
		Text,
		UseAttributeSet,
		ValueOf,
		ValueOfDoe,
		Variable,
		WithParam
	}
	internal class NsDecl
	{
		public readonly NsDecl Prev;

		public readonly string Prefix;

		public readonly string NsUri;

		public NsDecl(NsDecl prev, string prefix, string nsUri)
		{
			Prev = prev;
			Prefix = prefix;
			NsUri = nsUri;
		}
	}
	internal class XslNode
	{
		public readonly XslNodeType NodeType;

		public ISourceLineInfo SourceLine;

		public NsDecl Namespaces;

		public readonly QilName Name;

		public readonly object Arg;

		public readonly XslVersion XslVersion;

		public XslFlags Flags;

		private List<XslNode> content;

		private static readonly IList<XslNode> EmptyList = new List<XslNode>().AsReadOnly();

		public string Select => (string)Arg;

		public bool ForwardsCompatible => XslVersion == XslVersion.ForwardsCompatible;

		public IList<XslNode> Content => content ?? EmptyList;

		internal string TraceName => null;

		public XslNode(XslNodeType nodeType, QilName name, object arg, XslVersion xslVer)
		{
			NodeType = nodeType;
			Name = name;
			Arg = arg;
			XslVersion = xslVer;
		}

		public XslNode(XslNodeType nodeType)
		{
			NodeType = nodeType;
			XslVersion = XslVersion.Version10;
		}

		public void SetContent(List<XslNode> content)
		{
			this.content = content;
		}

		public void AddContent(XslNode node)
		{
			if (content == null)
			{
				content = new List<XslNode>();
			}
			content.Add(node);
		}

		public void InsertContent(IEnumerable<XslNode> collection)
		{
			if (content == null)
			{
				content = new List<XslNode>(collection);
			}
			else
			{
				content.InsertRange(0, collection);
			}
		}
	}
	internal abstract class ProtoTemplate : XslNode
	{
		public QilFunction Function;

		public ProtoTemplate(XslNodeType nt, QilName name, XslVersion xslVer)
			: base(nt, name, null, xslVer)
		{
		}

		public abstract string GetDebugName();
	}
	internal enum CycleCheck
	{
		NotStarted,
		Processing,
		Completed
	}
	internal class AttributeSet : ProtoTemplate
	{
		public readonly List<QilName> UsedAttributeSets = new List<QilName>();

		public CycleCheck CycleCheck;

		public AttributeSet(QilName name, XslVersion xslVer)
			: base(XslNodeType.AttributeSet, name, xslVer)
		{
		}

		public override string GetDebugName()
		{
			BufferBuilder bufferBuilder = new BufferBuilder();
			bufferBuilder.Append("<xsl:attribute-set name=\"");
			bufferBuilder.Append(Name.QualifiedName);
			bufferBuilder.Append("\">");
			return bufferBuilder.ToString();
		}

		public new void AddContent(XslNode node)
		{
			base.AddContent(node);
		}

		public void MergeContent(AttributeSet other)
		{
			UsedAttributeSets.InsertRange(0, other.UsedAttributeSets);
			InsertContent(other.Content);
		}
	}
	internal class Template : ProtoTemplate
	{
		public readonly string Match;

		public readonly QilName Mode;

		public readonly double Priority;

		public int ImportPrecedence;

		public int OrderNumber;

		public Template(QilName name, string match, QilName mode, double priority, XslVersion xslVer)
			: base(XslNodeType.Template, name, xslVer)
		{
			Match = match;
			Mode = mode;
			Priority = priority;
		}

		public override string GetDebugName()
		{
			BufferBuilder bufferBuilder = new BufferBuilder();
			bufferBuilder.Append("<xsl:template");
			if (Match != null)
			{
				bufferBuilder.Append(" match=\"");
				bufferBuilder.Append(Match);
				bufferBuilder.Append('"');
			}
			if (Name != null)
			{
				bufferBuilder.Append(" name=\"");
				bufferBuilder.Append(Name.QualifiedName);
				bufferBuilder.Append('"');
			}
			if (!double.IsNaN(Priority))
			{
				bufferBuilder.Append(" priority=\"");
				bufferBuilder.Append(Priority.ToString(CultureInfo.InvariantCulture));
				bufferBuilder.Append('"');
			}
			if (Mode.LocalName.Length != 0)
			{
				bufferBuilder.Append(" mode=\"");
				bufferBuilder.Append(Mode.QualifiedName);
				bufferBuilder.Append('"');
			}
			bufferBuilder.Append('>');
			return bufferBuilder.ToString();
		}
	}
	internal class VarPar : XslNode
	{
		public XslFlags DefValueFlags;

		public QilNode Value;

		public VarPar(XslNodeType nt, QilName name, string select, XslVersion xslVer)
			: base(nt, name, select, xslVer)
		{
		}
	}
	internal class Sort : XslNode
	{
		public readonly string Lang;

		public readonly string DataType;

		public readonly string Order;

		public readonly string CaseOrder;

		public Sort(string select, string lang, string dataType, string order, string caseOrder, XslVersion xslVer)
			: base(XslNodeType.Sort, null, select, xslVer)
		{
			Lang = lang;
			DataType = dataType;
			Order = order;
			CaseOrder = caseOrder;
		}
	}
	internal class Keys : KeyedCollection<QilName, List<Key>>
	{
		protected override QilName GetKeyForItem(List<Key> list)
		{
			return list[0].Name;
		}
	}
	internal class Key : XslNode
	{
		public readonly string Match;

		public readonly string Use;

		public QilFunction Function;

		public Key(QilName name, string match, string use, XslVersion xslVer)
			: base(XslNodeType.Key, name, null, xslVer)
		{
			Match = match;
			Use = use;
		}

		public string GetDebugName()
		{
			BufferBuilder bufferBuilder = new BufferBuilder();
			bufferBuilder.Append("<xsl:key name=\"");
			bufferBuilder.Append(Name.QualifiedName);
			bufferBuilder.Append('"');
			if (Match != null)
			{
				bufferBuilder.Append(" match=\"");
				bufferBuilder.Append(Match);
				bufferBuilder.Append('"');
			}
			if (Use != null)
			{
				bufferBuilder.Append(" use=\"");
				bufferBuilder.Append(Use);
				bufferBuilder.Append('"');
			}
			bufferBuilder.Append('>');
			return bufferBuilder.ToString();
		}
	}
	internal enum NumberLevel
	{
		Single,
		Multiple,
		Any
	}
	internal class Number : XslNode
	{
		public readonly NumberLevel Level;

		public readonly string Count;

		public readonly string From;

		public readonly string Value;

		public readonly string Format;

		public readonly string Lang;

		public readonly string LetterValue;

		public readonly string GroupingSeparator;

		public readonly string GroupingSize;

		public Number(NumberLevel level, string count, string from, string value, string format, string lang, string letterValue, string groupingSeparator, string groupingSize, XslVersion xslVer)
			: base(XslNodeType.Number, null, null, xslVer)
		{
			Level = level;
			Count = count;
			From = from;
			Value = value;
			Format = format;
			Lang = lang;
			LetterValue = letterValue;
			GroupingSeparator = groupingSeparator;
			GroupingSize = groupingSize;
		}
	}
	internal class NodeCtor : XslNode
	{
		public readonly string NameAvt;

		public readonly string NsAvt;

		public NodeCtor(XslNodeType nt, string nameAvt, string nsAvt, XslVersion xslVer)
			: base(nt, null, null, xslVer)
		{
			NameAvt = nameAvt;
			NsAvt = nsAvt;
		}
	}
	internal class Text : XslNode
	{
		public readonly SerializationHints Hints;

		public Text(string data, SerializationHints hints, XslVersion xslVer)
			: base(XslNodeType.Text, null, data, xslVer)
		{
			Hints = hints;
		}
	}
	internal class XslNodeEx : XslNode
	{
		public readonly ISourceLineInfo ElemNameLi;

		public readonly ISourceLineInfo EndTagLi;

		public XslNodeEx(XslNodeType t, QilName name, object arg, XsltInput.ContextInfo ctxInfo, XslVersion xslVer)
			: base(t, name, arg, xslVer)
		{
			ElemNameLi = ctxInfo.elemNameLi;
			EndTagLi = ctxInfo.endTagLi;
		}

		public XslNodeEx(XslNodeType t, QilName name, object arg, XslVersion xslVer)
			: base(t, name, arg, xslVer)
		{
		}
	}
	internal static class AstFactory
	{
		private static QilFactory f = new QilFactory();

		public static XslNode XslNode(XslNodeType nodeType, QilName name, string arg, XslVersion xslVer)
		{
			return new XslNode(nodeType, name, arg, xslVer);
		}

		public static XslNode ApplyImports(QilName mode, Stylesheet sheet, XslVersion xslVer)
		{
			return new XslNode(XslNodeType.ApplyImports, mode, sheet, xslVer);
		}

		public static XslNodeEx ApplyTemplates(QilName mode, string select, XsltInput.ContextInfo ctxInfo, XslVersion xslVer)
		{
			return new XslNodeEx(XslNodeType.ApplyTemplates, mode, select, ctxInfo, xslVer);
		}

		public static XslNodeEx ApplyTemplates(QilName mode)
		{
			return new XslNodeEx(XslNodeType.ApplyTemplates, mode, null, XslVersion.Version10);
		}

		public static NodeCtor Attribute(string nameAvt, string nsAvt, XslVersion xslVer)
		{
			return new NodeCtor(XslNodeType.Attribute, nameAvt, nsAvt, xslVer);
		}

		public static AttributeSet AttributeSet(QilName name)
		{
			return new AttributeSet(name, XslVersion.Version10);
		}

		public static XslNodeEx CallTemplate(QilName name, XsltInput.ContextInfo ctxInfo)
		{
			return new XslNodeEx(XslNodeType.CallTemplate, name, null, ctxInfo, XslVersion.Version10);
		}

		public static XslNode Choose()
		{
			return new XslNode(XslNodeType.Choose);
		}

		public static XslNode Comment()
		{
			return new XslNode(XslNodeType.Comment);
		}

		public static XslNode Copy()
		{
			return new XslNode(XslNodeType.Copy);
		}

		public static XslNode CopyOf(string select, XslVersion xslVer)
		{
			return new XslNode(XslNodeType.CopyOf, null, select, xslVer);
		}

		public static NodeCtor Element(string nameAvt, string nsAvt, XslVersion xslVer)
		{
			return new NodeCtor(XslNodeType.Element, nameAvt, nsAvt, xslVer);
		}

		public static XslNode Error(string message)
		{
			return new XslNode(XslNodeType.Error, null, message, XslVersion.Version10);
		}

		public static XslNodeEx ForEach(string select, XsltInput.ContextInfo ctxInfo, XslVersion xslVer)
		{
			return new XslNodeEx(XslNodeType.ForEach, null, select, ctxInfo, xslVer);
		}

		public static XslNode If(string test, XslVersion xslVer)
		{
			return new XslNode(XslNodeType.If, null, test, xslVer);
		}

		public static Key Key(QilName name, string match, string use, XslVersion xslVer)
		{
			return new Key(name, match, use, xslVer);
		}

		public static XslNode List()
		{
			return new XslNode(XslNodeType.List);
		}

		public static XslNode LiteralAttribute(QilName name, string value, XslVersion xslVer)
		{
			return new XslNode(XslNodeType.LiteralAttribute, name, value, xslVer);
		}

		public static XslNode LiteralElement(QilName name)
		{
			return new XslNode(XslNodeType.LiteralElement, name, null, XslVersion.Version10);
		}

		public static XslNode Message(bool term)
		{
			return new XslNode(XslNodeType.Message, null, term, XslVersion.Version10);
		}

		public static XslNode Nop()
		{
			return new XslNode(XslNodeType.Nop);
		}

		public static Number Number(NumberLevel level, string count, string from, string value, string format, string lang, string letterValue, string groupingSeparator, string groupingSize, XslVersion xslVer)
		{
			return new Number(level, count, from, value, format, lang, letterValue, groupingSeparator, groupingSize, xslVer);
		}

		public static XslNode Otherwise()
		{
			return new XslNode(XslNodeType.Otherwise);
		}

		public static XslNode PI(string name, XslVersion xslVer)
		{
			return new XslNode(XslNodeType.PI, null, name, xslVer);
		}

		public static Sort Sort(string select, string lang, string dataType, string order, string caseOrder, XslVersion xslVer)
		{
			return new Sort(select, lang, dataType, order, caseOrder, xslVer);
		}

		public static Template Template(QilName name, string match, QilName mode, double priority, XslVersion xslVer)
		{
			return new Template(name, match, mode, priority, xslVer);
		}

		public static XslNode Text(string data)
		{
			return new Text(data, SerializationHints.None, XslVersion.Version10);
		}

		public static XslNode Text(string data, SerializationHints hints)
		{
			return new Text(data, hints, XslVersion.Version10);
		}

		public static XslNode UseAttributeSet(QilName name)
		{
			return new XslNode(XslNodeType.UseAttributeSet, name, null, XslVersion.Version10);
		}

		public static VarPar VarPar(XslNodeType nt, QilName name, string select, XslVersion xslVer)
		{
			return new VarPar(nt, name, select, xslVer);
		}

		public static VarPar WithParam(QilName name)
		{
			return VarPar(XslNodeType.WithParam, name, null, XslVersion.Version10);
		}

		public static QilName QName(string local, string uri, string prefix)
		{
			return f.LiteralQName(local, uri, prefix);
		}

		public static QilName QName(string local)
		{
			return f.LiteralQName(local);
		}
	}
	internal abstract class XslVisitor<T>
	{
		protected virtual T Visit(XslNode node)
		{
			return node.NodeType switch
			{
				XslNodeType.ApplyImports => VisitApplyImports(node), 
				XslNodeType.ApplyTemplates => VisitApplyTemplates(node), 
				XslNodeType.Attribute => VisitAttribute((NodeCtor)node), 
				XslNodeType.AttributeSet => VisitAttributeSet((AttributeSet)node), 
				XslNodeType.CallTemplate => VisitCallTemplate(node), 
				XslNodeType.Choose => VisitChoose(node), 
				XslNodeType.Comment => VisitComment(node), 
				XslNodeType.Copy => VisitCopy(node), 
				XslNodeType.CopyOf => VisitCopyOf(node), 
				XslNodeType.Element => VisitElement((NodeCtor)node), 
				XslNodeType.Error => VisitError(node), 
				XslNodeType.ForEach => VisitForEach(node), 
				XslNodeType.If => VisitIf(node), 
				XslNodeType.Key => VisitKey((Key)node), 
				XslNodeType.List => VisitList(node), 
				XslNodeType.LiteralAttribute => VisitLiteralAttribute(node), 
				XslNodeType.LiteralElement => VisitLiteralElement(node), 
				XslNodeType.Message => VisitMessage(node), 
				XslNodeType.Nop => VisitNop(node), 
				XslNodeType.Number => VisitNumber((Number)node), 
				XslNodeType.Otherwise => VisitOtherwise(node), 
				XslNodeType.Param => VisitParam((VarPar)node), 
				XslNodeType.PI => VisitPI(node), 
				XslNodeType.Sort => VisitSort((Sort)node), 
				XslNodeType.Template => VisitTemplate((Template)node), 
				XslNodeType.Text => VisitText((Text)node), 
				XslNodeType.UseAttributeSet => VisitUseAttributeSet(node), 
				XslNodeType.ValueOf => VisitValueOf(node), 
				XslNodeType.ValueOfDoe => VisitValueOfDoe(node), 
				XslNodeType.Variable => VisitVariable((VarPar)node), 
				XslNodeType.WithParam => VisitWithParam((VarPar)node), 
				_ => VisitUnknown(node), 
			};
		}

		protected virtual T VisitApplyImports(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitApplyTemplates(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitAttribute(NodeCtor node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitAttributeSet(AttributeSet node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitCallTemplate(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitChoose(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitComment(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitCopy(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitCopyOf(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitElement(NodeCtor node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitError(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitForEach(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitIf(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitKey(Key node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitList(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitLiteralAttribute(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitLiteralElement(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitMessage(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitNop(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitNumber(Number node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitOtherwise(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitParam(VarPar node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitPI(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitSort(Sort node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitTemplate(Template node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitText(Text node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitUseAttributeSet(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitValueOf(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitValueOfDoe(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitVariable(VarPar node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitWithParam(VarPar node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitUnknown(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitChildren(XslNode node)
		{
			foreach (XslNode item in node.Content)
			{
				Visit(item);
			}
			return default(T);
		}
	}
	internal class XslAstAnalyzer : XslVisitor<XslFlags>
	{
		internal class Graph<V> : Dictionary<V, List<V>> where V : XslNode
		{
			private static IList<V> empty = new List<V>().AsReadOnly();

			public IEnumerable<V> GetAdjList(V v)
			{
				if (TryGetValue(v, out var value) && value != null)
				{
					return value;
				}
				return empty;
			}

			public void AddEdge(V v1, V v2)
			{
				if (v1 != v2)
				{
					if (!TryGetValue(v1, out var value) || value == null)
					{
						List<V> list2 = (base[v1] = new List<V>());
						value = list2;
					}
					value.Add(v2);
					if (!TryGetValue(v2, out value))
					{
						base[v2] = null;
					}
				}
			}

			public void PropagateFlag(XslFlags flag)
			{
				foreach (V key in base.Keys)
				{
					key.Flags &= ~XslFlags.Stop;
				}
				foreach (V key2 in base.Keys)
				{
					if ((key2.Flags & XslFlags.Stop) == 0 && (key2.Flags & flag) != 0)
					{
						DepthFirstSearch(key2, flag);
					}
				}
			}

			private void DepthFirstSearch(V v, XslFlags flag)
			{
				v.Flags |= flag | XslFlags.Stop;
				foreach (V adj in GetAdjList(v))
				{
					if ((adj.Flags & XslFlags.Stop) == 0)
					{
						DepthFirstSearch(adj, flag);
					}
				}
			}
		}

		internal struct ModeName
		{
			public QilName Mode;

			public QilName Name;

			public ModeName(QilName mode, QilName name)
			{
				Mode = mode;
				Name = name;
			}

			public override int GetHashCode()
			{
				return Mode.GetHashCode() ^ Name.GetHashCode();
			}
		}

		[StructLayout(LayoutKind.Sequential, Size = 1)]
		internal struct NullErrorHelper : IErrorHelper
		{
			public void ReportError(string res, params string[] args)
			{
			}

			public void ReportWarning(string res, params string[] args)
			{
			}
		}

		internal class XPathAnalyzer : IXPathBuilder<XslFlags>
		{
			private XPathParser<XslFlags> xpathParser = new XPathParser<XslFlags>();

			private CompilerScopeManager<VarPar> scope;

			private Compiler compiler;

			private bool xsltCurrentNeeded;

			private VarPar typeDonor;

			private static XslFlags[] OperatorType = new XslFlags[16]
			{
				XslFlags.TypeFilter,
				XslFlags.Boolean,
				XslFlags.Boolean,
				XslFlags.Boolean,
				XslFlags.Boolean,
				XslFlags.Boolean,
				XslFlags.Boolean,
				XslFlags.Boolean,
				XslFlags.Boolean,
				XslFlags.Number,
				XslFlags.Number,
				XslFlags.Number,
				XslFlags.Number,
				XslFlags.Number,
				XslFlags.Number,
				XslFlags.Nodeset
			};

			private static XslFlags[] XPathFunctionFlags = new XslFlags[27]
			{
				XslFlags.Number | XslFlags.Last,
				XslFlags.Number | XslFlags.Position,
				XslFlags.Number,
				XslFlags.String,
				XslFlags.String,
				XslFlags.String,
				XslFlags.String,
				XslFlags.Number,
				XslFlags.Boolean,
				XslFlags.Boolean,
				XslFlags.Boolean,
				XslFlags.Boolean,
				XslFlags.Nodeset | XslFlags.Current,
				XslFlags.String,
				XslFlags.Boolean,
				XslFlags.Boolean,
				XslFlags.String,
				XslFlags.String,
				XslFlags.String,
				XslFlags.Number,
				XslFlags.String,
				XslFlags.String,
				XslFlags.Boolean | XslFlags.Current,
				XslFlags.Number,
				XslFlags.Number,
				XslFlags.Number,
				XslFlags.Number
			};

			private static XslFlags[] XsltFunctionFlags = new XslFlags[9]
			{
				XslFlags.Node,
				XslFlags.Nodeset,
				XslFlags.Nodeset | XslFlags.Current,
				XslFlags.String,
				XslFlags.String,
				XslFlags.String,
				XslFlags.String | XslFlags.Number,
				XslFlags.Boolean,
				XslFlags.Boolean
			};

			public VarPar TypeDonor => typeDonor;

			public XPathAnalyzer(Compiler compiler, CompilerScopeManager<VarPar> scope)
			{
				this.compiler = compiler;
				this.scope = scope;
			}

			public XslFlags Analyze(string xpathExpr)
			{
				typeDonor = null;
				if (xpathExpr == null)
				{
					return XslFlags.None;
				}
				try
				{
					xsltCurrentNeeded = false;
					System.Xml.Xsl.XPath.XPathScanner scanner = new System.Xml.Xsl.XPath.XPathScanner(xpathExpr);
					XslFlags xslFlags = xpathParser.Parse(scanner, this, LexKind.Eof);
					if (xsltCurrentNeeded)
					{
						xslFlags |= XslFlags.Current;
					}
					return xslFlags;
				}
				catch (XslLoadException)
				{
					return XslFlags.TypeFilter | XslFlags.FocusFilter;
				}
			}

			public XslFlags AnalyzeAvt(string source)
			{
				typeDonor = null;
				if (source == null)
				{
					return XslFlags.None;
				}
				try
				{
					xsltCurrentNeeded = false;
					XslFlags xslFlags = XslFlags.None;
					int num = 0;
					while (num < source.Length)
					{
						num = source.IndexOf('{', num);
						if (num == -1)
						{
							break;
						}
						num++;
						if (num < source.Length && source[num] == '{')
						{
							num++;
						}
						else if (num < source.Length)
						{
							System.Xml.Xsl.XPath.XPathScanner xPathScanner = new System.Xml.Xsl.XPath.XPathScanner(source, num);
							xslFlags |= xpathParser.Parse(xPathScanner, this, LexKind.RBrace);
							num = xPathScanner.LexStart + 1;
						}
					}
					if (xsltCurrentNeeded)
					{
						xslFlags |= XslFlags.Current;
					}
					return xslFlags & ~XslFlags.TypeFilter;
				}
				catch (XslLoadException)
				{
					return XslFlags.FocusFilter;
				}
			}

			private VarPar ResolveVariable(string prefix, string name)
			{
				string text = ResolvePrefix(prefix);
				if (text == null)
				{
					return null;
				}
				return scope.LookupVariable(name, text);
			}

			private string ResolvePrefix(string prefix)
			{
				if (prefix.Length == 0)
				{
					return string.Empty;
				}
				return scope.LookupNamespace(prefix);
			}

			public virtual void StartBuild()
			{
			}

			public virtual XslFlags EndBuild(XslFlags result)
			{
				return result;
			}

			public virtual XslFlags String(string value)
			{
				typeDonor = null;
				return XslFlags.String;
			}

			public virtual XslFlags Number(double value)
			{
				typeDonor = null;
				return XslFlags.Number;
			}

			public virtual XslFlags Operator(XPathOperator op, XslFlags left, XslFlags right)
			{
				typeDonor = null;
				XslFlags xslFlags = (left | right) & ~XslFlags.TypeFilter;
				return xslFlags | OperatorType[(int)op];
			}

			public virtual XslFlags Axis(XPathAxis xpathAxis, XPathNodeType nodeType, string prefix, string name)
			{
				typeDonor = null;
				if (xpathAxis == XPathAxis.Self && nodeType == XPathNodeType.All && prefix == null && name == null)
				{
					return XslFlags.Node | XslFlags.Current;
				}
				return XslFlags.Nodeset | XslFlags.Current;
			}

			public virtual XslFlags JoinStep(XslFlags left, XslFlags right)
			{
				typeDonor = null;
				return (left & ~XslFlags.TypeFilter) | XslFlags.Nodeset;
			}

			public virtual XslFlags Predicate(XslFlags nodeset, XslFlags predicate, bool isReverseStep)
			{
				typeDonor = null;
				return (nodeset & ~XslFlags.TypeFilter) | XslFlags.Nodeset | (predicate & XslFlags.SideEffects);
			}

			public virtual XslFlags Variable(string prefix, string name)
			{
				typeDonor = ResolveVariable(prefix, name);
				if (typeDonor == null)
				{
					return XslFlags.TypeFilter;
				}
				return XslFlags.None;
			}

			public virtual XslFlags Function(string prefix, string name, IList<XslFlags> args)
			{
				typeDonor = null;
				XslFlags xslFlags = XslFlags.None;
				foreach (XslFlags arg in args)
				{
					xslFlags |= arg;
				}
				XslFlags xslFlags2 = XslFlags.None;
				if (prefix.Length == 0)
				{
					XPathBuilder.FunctionInfo<QilGenerator.FuncId> value2;
					if (XPathBuilder.FunctionTable.TryGetValue(name, out var value))
					{
						XPathBuilder.FuncId id = value.id;
						xslFlags2 = XPathFunctionFlags[(int)id];
						if (args.Count == 0 && (id == XPathBuilder.FuncId.LocalName || id == XPathBuilder.FuncId.NamespaceUri || id == XPathBuilder.FuncId.Name || id == XPathBuilder.FuncId.String || id == XPathBuilder.FuncId.Number || id == XPathBuilder.FuncId.StringLength || id == XPathBuilder.FuncId.Normalize))
						{
							xslFlags2 |= XslFlags.Current;
						}
					}
					else if (QilGenerator.FunctionTable.TryGetValue(name, out value2))
					{
						QilGenerator.FuncId id2 = value2.id;
						xslFlags2 = XsltFunctionFlags[(int)id2];
						switch (id2)
						{
						case QilGenerator.FuncId.Current:
							xsltCurrentNeeded = true;
							break;
						case QilGenerator.FuncId.GenerateId:
							if (args.Count == 0)
							{
								xslFlags2 |= XslFlags.Current;
							}
							break;
						}
					}
				}
				else
				{
					string text = ResolvePrefix(prefix);
					if (text == "urn:schemas-microsoft-com:xslt")
					{
						switch (name)
						{
						case "node-set":
							xslFlags2 = XslFlags.Nodeset;
							break;
						case "string-compare":
							xslFlags2 = XslFlags.Number;
							break;
						case "utc":
							xslFlags2 = XslFlags.String;
							break;
						case "format-date":
							xslFlags2 = XslFlags.String;
							break;
						case "format-time":
							xslFlags2 = XslFlags.String;
							break;
						case "local-name":
							xslFlags2 = XslFlags.String;
							break;
						case "namespace-uri":
							xslFlags2 = XslFlags.String;
							break;
						case "number":
							xslFlags2 = XslFlags.Number;
							break;
						}
					}
					else if (text == "http://exslt.org/common")
					{
						switch (name)
						{
						case "node-set":
							xslFlags2 = XslFlags.Nodeset;
							break;
						case "object-type":
							xslFlags2 = XslFlags.String;
							break;
						}
					}
					if (xslFlags2 == XslFlags.None)
					{
						xslFlags2 = XslFlags.TypeFilter;
						if (compiler.Settings.EnableScript && text != null)
						{
							XmlExtensionFunction xmlExtensionFunction = compiler.Scripts.ResolveFunction(name, text, args.Count, default(NullErrorHelper));
							if (xmlExtensionFunction != null)
							{
								XmlQueryType xmlReturnType = xmlExtensionFunction.XmlReturnType;
								if (xmlReturnType == XmlQueryTypeFactory.StringX)
								{
									xslFlags2 = XslFlags.String;
								}
								else if (xmlReturnType == XmlQueryTypeFactory.DoubleX)
								{
									xslFlags2 = XslFlags.Number;
								}
								else if (xmlReturnType == XmlQueryTypeFactory.BooleanX)
								{
									xslFlags2 = XslFlags.Boolean;
								}
								else if (xmlReturnType == XmlQueryTypeFactory.NodeNotRtf)
								{
									xslFlags2 = XslFlags.Node;
								}
								else if (xmlReturnType == XmlQueryTypeFactory.NodeDodS)
								{
									xslFlags2 = XslFlags.Nodeset;
								}
								else if (xmlReturnType == XmlQueryTypeFactory.ItemS)
								{
									xslFlags2 = XslFlags.TypeFilter;
								}
								else if (xmlReturnType == XmlQueryTypeFactory.Empty)
								{
									xslFlags2 = XslFlags.Nodeset;
								}
							}
						}
						xslFlags2 |= XslFlags.SideEffects;
					}
				}
				return (xslFlags & ~XslFlags.TypeFilter) | xslFlags2;
			}
		}

		private CompilerScopeManager<VarPar> scope;

		private Compiler compiler;

		private int forEachDepth;

		private XPathAnalyzer xpathAnalyzer;

		private ProtoTemplate currentTemplate;

		private VarPar typeDonor;

		private Graph<ProtoTemplate> focusDonors = new Graph<ProtoTemplate>();

		private Dictionary<Template, Stylesheet> dependsOnApplyImports = new Dictionary<Template, Stylesheet>();

		private Graph<ProtoTemplate> sideEffectDonors = new Graph<ProtoTemplate>();

		private Dictionary<QilName, List<ProtoTemplate>> dependsOnMode = new Dictionary<QilName, List<ProtoTemplate>>();

		private Graph<VarPar> dataFlow = new Graph<VarPar>();

		private Dictionary<ModeName, VarPar> applyTemplatesParams = new Dictionary<ModeName, VarPar>();

		public XslFlags Analyze(Compiler compiler)
		{
			this.compiler = compiler;
			scope = new CompilerScopeManager<VarPar>();
			xpathAnalyzer = new XPathAnalyzer(compiler, scope);
			foreach (VarPar externalPar in compiler.ExternalPars)
			{
				scope.AddVariable(externalPar.Name, externalPar);
			}
			foreach (VarPar globalVar in compiler.GlobalVars)
			{
				scope.AddVariable(globalVar.Name, globalVar);
			}
			foreach (VarPar externalPar2 in compiler.ExternalPars)
			{
				Visit(externalPar2);
				externalPar2.Flags |= XslFlags.TypeFilter;
			}
			foreach (VarPar globalVar2 in compiler.GlobalVars)
			{
				Visit(globalVar2);
			}
			XslFlags xslFlags = XslFlags.None;
			foreach (ProtoTemplate allTemplate in compiler.AllTemplates)
			{
				xslFlags |= Visit(currentTemplate = allTemplate);
			}
			foreach (ProtoTemplate allTemplate2 in compiler.AllTemplates)
			{
				foreach (XslNode item in allTemplate2.Content)
				{
					if (item.NodeType != XslNodeType.Text)
					{
						if (item.NodeType != XslNodeType.Param)
						{
							break;
						}
						VarPar varPar = (VarPar)item;
						if ((varPar.Flags & XslFlags.MayBeDefault) != 0)
						{
							varPar.Flags |= varPar.DefValueFlags;
						}
					}
				}
			}
			for (int num = 32; num != 0; num >>= 1)
			{
				dataFlow.PropagateFlag((XslFlags)num);
			}
			dataFlow = null;
			using (Dictionary<Template, Stylesheet>.Enumerator enumerator8 = dependsOnApplyImports.GetEnumerator())
			{
				while (enumerator8.MoveNext())
				{
					AddImportDependencies(focusDonor: enumerator8.Current.Key, sheet: compiler.PrincipalStylesheet);
				}
			}
			dependsOnApplyImports = null;
			if ((xslFlags & XslFlags.Current) != 0)
			{
				focusDonors.PropagateFlag(XslFlags.Current);
			}
			if ((xslFlags & XslFlags.Position) != 0)
			{
				focusDonors.PropagateFlag(XslFlags.Position);
			}
			if ((xslFlags & XslFlags.Last) != 0)
			{
				focusDonors.PropagateFlag(XslFlags.Last);
			}
			if ((xslFlags & XslFlags.SideEffects) != 0)
			{
				PropagateSideEffectsFlag();
			}
			focusDonors = null;
			sideEffectDonors = null;
			dependsOnMode = null;
			FillModeFlags(compiler.PrincipalStylesheet);
			TraceResults();
			return xslFlags;
		}

		private void AddImportDependencies(Stylesheet sheet, Template focusDonor)
		{
			foreach (Template template in sheet.Templates)
			{
				if (template.Mode.Equals(focusDonor.Mode))
				{
					focusDonors.AddEdge(template, focusDonor);
				}
			}
			Stylesheet[] imports = sheet.Imports;
			foreach (Stylesheet sheet2 in imports)
			{
				AddImportDependencies(sheet2, focusDonor);
			}
		}

		private void FillModeFlags(Stylesheet sheet)
		{
			foreach (Template template in sheet.Templates)
			{
				XslFlags xslFlags = template.Flags & XslFlags.FocusFilter;
				if (xslFlags != 0)
				{
					if (!compiler.ModeFlags.TryGetValue(template.Mode, out var value))
					{
						value = XslFlags.None;
					}
					compiler.ModeFlags[template.Mode] = value | xslFlags;
				}
			}
			Stylesheet[] imports = sheet.Imports;
			foreach (Stylesheet sheet2 in imports)
			{
				FillModeFlags(sheet2);
			}
		}

		private void TraceResults()
		{
		}

		protected override XslFlags Visit(XslNode node)
		{
			scope.PushScope();
			for (NsDecl nsDecl = node.Namespaces; nsDecl != null; nsDecl = nsDecl.Prev)
			{
				scope.AddNamespace(nsDecl.Prefix, nsDecl.NsUri);
			}
			XslFlags result = base.Visit(node);
			scope.PopScope();
			if (currentTemplate != null && (node.NodeType == XslNodeType.Variable || node.NodeType == XslNodeType.Param))
			{
				scope.AddVariable(node.Name, (VarPar)node);
			}
			return result;
		}

		protected override XslFlags VisitChildren(XslNode node)
		{
			XslFlags xslFlags = XslFlags.None;
			foreach (XslNode item in node.Content)
			{
				xslFlags |= Visit(item);
			}
			return xslFlags;
		}

		protected override XslFlags VisitAttributeSet(AttributeSet node)
		{
			node.Flags = VisitChildren(node);
			return node.Flags;
		}

		protected override XslFlags VisitTemplate(Template node)
		{
			node.Flags = VisitChildren(node);
			return node.Flags;
		}

		protected override XslFlags VisitApplyImports(XslNode node)
		{
			dependsOnApplyImports[(Template)currentTemplate] = (Stylesheet)node.Arg;
			return XslFlags.Rtf | XslFlags.Current | XslFlags.HasCalls;
		}

		protected override XslFlags VisitApplyTemplates(XslNode node)
		{
			XslFlags xslFlags = ProcessExpr(node.Select);
			foreach (XslNode item in node.Content)
			{
				xslFlags |= Visit(item);
				if (item.NodeType == XslNodeType.WithParam)
				{
					ModeName key = new ModeName(node.Name, item.Name);
					if (!applyTemplatesParams.TryGetValue(key, out var value))
					{
						VarPar varPar2 = (applyTemplatesParams[key] = AstFactory.WithParam(item.Name));
						value = varPar2;
					}
					if (typeDonor != null)
					{
						dataFlow.AddEdge(typeDonor, value);
					}
					else
					{
						value.Flags |= item.Flags & XslFlags.TypeFilter;
					}
				}
			}
			if (currentTemplate != null)
			{
				AddApplyTemplatesEdge(node.Name, currentTemplate);
			}
			return XslFlags.Rtf | XslFlags.HasCalls | xslFlags;
		}

		protected override XslFlags VisitAttribute(NodeCtor node)
		{
			return XslFlags.Rtf | ProcessAvt(node.NameAvt) | ProcessAvt(node.NsAvt) | VisitChildren(node);
		}

		protected override XslFlags VisitCallTemplate(XslNode node)
		{
			XslFlags xslFlags = XslFlags.None;
			if (compiler.NamedTemplates.TryGetValue(node.Name, out var value) && currentTemplate != null)
			{
				if (forEachDepth == 0)
				{
					focusDonors.AddEdge(value, currentTemplate);
				}
				else
				{
					sideEffectDonors.AddEdge(value, currentTemplate);
				}
			}
			VarPar[] array = new VarPar[node.Content.Count];
			int num = 0;
			foreach (XslNode item in node.Content)
			{
				xslFlags |= Visit(item);
				array[num++] = typeDonor;
			}
			if (value != null)
			{
				foreach (XslNode item2 in value.Content)
				{
					if (item2.NodeType == XslNodeType.Text)
					{
						continue;
					}
					if (item2.NodeType != XslNodeType.Param)
					{
						break;
					}
					VarPar varPar = (VarPar)item2;
					VarPar varPar2 = null;
					num = 0;
					foreach (XslNode item3 in node.Content)
					{
						if (item3.Name.Equals(varPar.Name))
						{
							varPar2 = (VarPar)item3;
							typeDonor = array[num];
							break;
						}
						num++;
					}
					if (varPar2 != null)
					{
						if (typeDonor != null)
						{
							dataFlow.AddEdge(typeDonor, varPar);
						}
						else
						{
							varPar.Flags |= varPar2.Flags & XslFlags.TypeFilter;
						}
					}
					else
					{
						varPar.Flags |= XslFlags.MayBeDefault;
					}
				}
			}
			return XslFlags.Rtf | XslFlags.HasCalls | xslFlags;
		}

		protected override XslFlags VisitComment(XslNode node)
		{
			return XslFlags.Rtf | VisitChildren(node);
		}

		protected override XslFlags VisitCopy(XslNode node)
		{
			return XslFlags.Rtf | XslFlags.Current | VisitChildren(node);
		}

		protected override XslFlags VisitCopyOf(XslNode node)
		{
			return XslFlags.Rtf | ProcessExpr(node.Select);
		}

		protected override XslFlags VisitElement(NodeCtor node)
		{
			return XslFlags.Rtf | ProcessAvt(node.NameAvt) | ProcessAvt(node.NsAvt) | VisitChildren(node);
		}

		protected override XslFlags VisitError(XslNode node)
		{
			return (VisitChildren(node) & ~XslFlags.TypeFilter) | XslFlags.SideEffects;
		}

		protected override XslFlags VisitForEach(XslNode node)
		{
			XslFlags xslFlags = ProcessExpr(node.Select);
			forEachDepth++;
			foreach (XslNode item in node.Content)
			{
				xslFlags = ((item.NodeType != XslNodeType.Sort) ? (xslFlags | (Visit(item) & ~XslFlags.FocusFilter)) : (xslFlags | Visit(item)));
			}
			forEachDepth--;
			return xslFlags;
		}

		protected override XslFlags VisitIf(XslNode node)
		{
			return ProcessExpr(node.Select) | VisitChildren(node);
		}

		protected override XslFlags VisitLiteralAttribute(XslNode node)
		{
			return XslFlags.Rtf | ProcessAvt(node.Select) | VisitChildren(node);
		}

		protected override XslFlags VisitLiteralElement(XslNode node)
		{
			return XslFlags.Rtf | VisitChildren(node);
		}

		protected override XslFlags VisitMessage(XslNode node)
		{
			return (VisitChildren(node) & ~XslFlags.TypeFilter) | XslFlags.SideEffects;
		}

		protected override XslFlags VisitNumber(Number node)
		{
			return XslFlags.Rtf | ProcessPattern(node.Count) | ProcessPattern(node.From) | ((node.Value != null) ? ProcessExpr(node.Value) : XslFlags.Current) | ProcessAvt(node.Format) | ProcessAvt(node.Lang) | ProcessAvt(node.LetterValue) | ProcessAvt(node.GroupingSeparator) | ProcessAvt(node.GroupingSize);
		}

		protected override XslFlags VisitPI(XslNode node)
		{
			return XslFlags.Rtf | ProcessAvt(node.Select) | VisitChildren(node);
		}

		protected override XslFlags VisitSort(Sort node)
		{
			return (ProcessExpr(node.Select) & ~XslFlags.FocusFilter) | ProcessAvt(node.Lang) | ProcessAvt(node.DataType) | ProcessAvt(node.Order) | ProcessAvt(node.CaseOrder);
		}

		protected override XslFlags VisitText(Text node)
		{
			return XslFlags.Rtf | VisitChildren(node);
		}

		protected override XslFlags VisitUseAttributeSet(XslNode node)
		{
			if (compiler.AttributeSets.TryGetValue(node.Name, out var value) && currentTemplate != null)
			{
				if (forEachDepth == 0)
				{
					focusDonors.AddEdge(value, currentTemplate);
				}
				else
				{
					sideEffectDonors.AddEdge(value, currentTemplate);
				}
			}
			return XslFlags.Rtf | XslFlags.HasCalls;
		}

		protected override XslFlags VisitValueOf(XslNode node)
		{
			return XslFlags.Rtf | ProcessExpr(node.Select);
		}

		protected override XslFlags VisitValueOfDoe(XslNode node)
		{
			return XslFlags.Rtf | ProcessExpr(node.Select);
		}

		protected override XslFlags VisitParam(VarPar node)
		{
			if (currentTemplate is Template template && template.Match != null)
			{
				node.Flags |= XslFlags.MayBeDefault;
				ModeName key = new ModeName(template.Mode, node.Name);
				if (!applyTemplatesParams.TryGetValue(key, out var value))
				{
					VarPar varPar2 = (applyTemplatesParams[key] = AstFactory.WithParam(node.Name));
					value = varPar2;
				}
				dataFlow.AddEdge(value, node);
			}
			node.DefValueFlags = ProcessVarPar(node);
			return node.DefValueFlags & ~XslFlags.TypeFilter;
		}

		protected override XslFlags VisitVariable(VarPar node)
		{
			node.Flags = ProcessVarPar(node);
			return node.Flags & ~XslFlags.TypeFilter;
		}

		protected override XslFlags VisitWithParam(VarPar node)
		{
			node.Flags = ProcessVarPar(node);
			return node.Flags & ~XslFlags.TypeFilter;
		}

		private XslFlags ProcessVarPar(VarPar node)
		{
			XslFlags result;
			if (node.Select != null)
			{
				if (node.Content.Count != 0)
				{
					result = xpathAnalyzer.Analyze(node.Select) | VisitChildren(node) | XslFlags.TypeFilter;
					typeDonor = null;
				}
				else
				{
					result = xpathAnalyzer.Analyze(node.Select);
					typeDonor = xpathAnalyzer.TypeDonor;
					if (typeDonor != null && node.NodeType != XslNodeType.WithParam)
					{
						dataFlow.AddEdge(typeDonor, node);
					}
				}
			}
			else if (node.Content.Count != 0)
			{
				result = XslFlags.Rtf | VisitChildren(node);
				typeDonor = null;
			}
			else
			{
				result = XslFlags.String;
				typeDonor = null;
			}
			return result;
		}

		private XslFlags ProcessExpr(string expr)
		{
			return xpathAnalyzer.Analyze(expr) & ~XslFlags.TypeFilter;
		}

		private XslFlags ProcessAvt(string avt)
		{
			return xpathAnalyzer.AnalyzeAvt(avt) & ~XslFlags.TypeFilter;
		}

		private XslFlags ProcessPattern(string pattern)
		{
			return xpathAnalyzer.Analyze(pattern) & ~XslFlags.TypeFilter & ~XslFlags.FocusFilter;
		}

		private void AddApplyTemplatesEdge(QilName mode, ProtoTemplate dependentTemplate)
		{
			if (!dependsOnMode.TryGetValue(mode, out var value))
			{
				value = new List<ProtoTemplate>();
				dependsOnMode.Add(mode, value);
			}
			else if (value[value.Count - 1] == dependentTemplate)
			{
				return;
			}
			value.Add(dependentTemplate);
		}

		private void PropagateSideEffectsFlag()
		{
			foreach (ProtoTemplate key in focusDonors.Keys)
			{
				key.Flags &= ~XslFlags.Stop;
			}
			foreach (ProtoTemplate key2 in sideEffectDonors.Keys)
			{
				key2.Flags &= ~XslFlags.Stop;
			}
			foreach (ProtoTemplate key3 in focusDonors.Keys)
			{
				if ((key3.Flags & XslFlags.Stop) == 0 && (key3.Flags & XslFlags.SideEffects) != 0)
				{
					DepthFirstSearch(key3);
				}
			}
			foreach (ProtoTemplate key4 in sideEffectDonors.Keys)
			{
				if ((key4.Flags & XslFlags.Stop) == 0 && (key4.Flags & XslFlags.SideEffects) != 0)
				{
					DepthFirstSearch(key4);
				}
			}
		}

		private void DepthFirstSearch(ProtoTemplate t)
		{
			t.Flags |= XslFlags.SideEffects | XslFlags.Stop;
			foreach (ProtoTemplate adj in focusDonors.GetAdjList(t))
			{
				if ((adj.Flags & XslFlags.Stop) == 0)
				{
					DepthFirstSearch(adj);
				}
			}
			foreach (ProtoTemplate adj2 in sideEffectDonors.GetAdjList(t))
			{
				if ((adj2.Flags & XslFlags.Stop) == 0)
				{
					DepthFirstSearch(adj2);
				}
			}
			if (!(t is Template template) || !dependsOnMode.TryGetValue(template.Mode, out var value))
			{
				return;
			}
			dependsOnMode.Remove(template.Mode);
			foreach (ProtoTemplate item in value)
			{
				if ((item.Flags & XslFlags.Stop) == 0)
				{
					DepthFirstSearch(item);
				}
			}
		}
	}
}
namespace System.Xml.Xsl
{
	[Flags]
	internal enum XslFlags
	{
		None = 0,
		String = 1,
		Number = 2,
		Boolean = 4,
		Node = 8,
		Nodeset = 0x10,
		Rtf = 0x20,
		TypeFilter = 0x3F,
		AnyType = 0x3F,
		Current = 0x100,
		Position = 0x200,
		Last = 0x400,
		FocusFilter = 0x700,
		FullFocus = 0x700,
		HasCalls = 0x1000,
		MayBeDefault = 0x2000,
		SideEffects = 0x4000,
		Stop = 0x8000
	}
}
namespace System.Xml.Xsl.Xslt
{
	internal class XsltInput : IErrorHelper
	{
		private enum Moves
		{
			Next,
			Child,
			Parent
		}

		private class InputScopeManager
		{
			private enum ScopeFlags
			{
				ForwardCompatibility = 1,
				CanHaveApplyImports = 2,
				NsExtension = 4,
				InheritedFlags = 3
			}

			private struct ScopeRecord
			{
				public int scopeCount;

				public ScopeFlags scopeFlags;

				public string nsUri;
			}

			private XmlNameTable nameTable;

			private ScopeRecord[] records = new ScopeRecord[32];

			private int lastRecord;

			private int lastScopes;

			public bool ForwardCompatibility
			{
				get
				{
					return (records[lastRecord].scopeFlags & ScopeFlags.ForwardCompatibility) != 0;
				}
				set
				{
					SetFlag(value, ScopeFlags.ForwardCompatibility);
				}
			}

			public bool CanHaveApplyImports
			{
				get
				{
					return (records[lastRecord].scopeFlags & ScopeFlags.CanHaveApplyImports) != 0;
				}
				set
				{
					SetFlag(value, ScopeFlags.CanHaveApplyImports);
				}
			}

			public InputScopeManager(XmlNameTable nameTable)
			{
				this.nameTable = nameTable;
				records[0].scopeFlags = (ScopeFlags)0;
			}

			public void PushScope()
			{
				lastScopes++;
			}

			public void PopScope()
			{
				if (0 < lastScopes)
				{
					lastScopes--;
					return;
				}
				do
				{
					lastRecord--;
				}
				while (records[lastRecord].scopeCount == 0);
				lastScopes = records[lastRecord].scopeCount;
				lastScopes--;
			}

			private void AddRecord()
			{
				records[lastRecord].scopeCount = lastScopes;
				lastRecord++;
				if (lastRecord == records.Length)
				{
					ScopeRecord[] destinationArray = new ScopeRecord[lastRecord * 2];
					Array.Copy(records, 0, destinationArray, 0, lastRecord);
					records = destinationArray;
				}
				lastScopes = 0;
			}

			private void SetFlag(bool value, ScopeFlags flag)
			{
				ScopeFlags scopeFlags = records[lastRecord].scopeFlags;
				if ((scopeFlags & flag) != 0 != value)
				{
					if (lastScopes != 0)
					{
						AddRecord();
						scopeFlags &= ScopeFlags.InheritedFlags;
					}
					records[lastRecord].scopeFlags = scopeFlags ^ flag;
				}
			}

			public void AddExtensionNamespace(string uri)
			{
				uri = nameTable.Add(uri);
				ScopeFlags scopeFlags = records[lastRecord].scopeFlags;
				if (lastScopes != 0 || (scopeFlags & ScopeFlags.NsExtension) != 0)
				{
					AddRecord();
					scopeFlags &= ScopeFlags.InheritedFlags;
				}
				records[lastRecord].nsUri = uri;
				records[lastRecord].scopeFlags = scopeFlags | ScopeFlags.NsExtension;
			}

			public bool IsExtensionNamespace(string nsUri)
			{
				int num = lastRecord;
				while (0 <= num)
				{
					if ((records[num].scopeFlags & ScopeFlags.NsExtension) != 0 && records[num].nsUri == nsUri)
					{
						return true;
					}
					num--;
				}
				return false;
			}

			[Conditional("DEBUG")]
			public void CheckEmpty()
			{
				PopScope();
			}
		}

		internal class ContextInfo
		{
			internal class EmptyElementEndTag : ISourceLineInfo
			{
				private ISourceLineInfo elementTagLi;

				public string Uri => elementTagLi.Uri;

				public int StartLine => elementTagLi.EndLine;

				public int StartPos => elementTagLi.EndPos - 2;

				public int EndLine => elementTagLi.EndLine;

				public int EndPos => elementTagLi.EndPos;

				public bool IsNoSource => elementTagLi.IsNoSource;

				public EmptyElementEndTag(ISourceLineInfo elementTagLi)
				{
					this.elementTagLi = elementTagLi;
				}
			}

			public NsDecl nsList;

			public ISourceLineInfo lineInfo;

			public ISourceLineInfo elemNameLi;

			public ISourceLineInfo endTagLi;

			private int elemNameLength;

			public ContextInfo(XsltInput input)
			{
				lineInfo = input.BuildLineInfo();
				elemNameLength = input.QualifiedName.Length;
			}

			public void AddAttribute(XsltInput input)
			{
			}

			public void AddNamespace(XsltInput input)
			{
				if (!Ref.Equal(input.LocalName, input.Atoms.Xml))
				{
					nsList = new NsDecl(nsList, input.LocalName, input.NameTable.Add(input.Value));
				}
			}

			public void Finish(XsltInput input)
			{
			}

			public void SaveExtendedLineInfo(XsltInput input)
			{
				elemNameLi = new SourceLineInfo(lineInfo.Uri, lineInfo.StartLine, lineInfo.StartPos + 1, lineInfo.StartLine, lineInfo.StartPos + 1 + elemNameLength);
				if (!input.IsEmptyElement)
				{
					endTagLi = input.BuildLineInfo();
				}
				else
				{
					endTagLi = new EmptyElementEndTag(lineInfo);
				}
			}
		}

		private XmlReader reader;

		private IXmlLineInfo readerLineInfo;

		private bool topLevelReader;

		private InputScopeManager scopeManager;

		private KeywordsTable atoms;

		private Compiler compiler;

		private string text;

		private bool textIsWhite;

		private XPathNodeType nodeType;

		private string localName;

		private string namespaceName;

		private string value;

		private Moves lastMove = Moves.Child;

		private bool lastResult = true;

		private static XPathNodeType[] XmlNodeType2XPathNodeType = new XPathNodeType[18]
		{
			(XPathNodeType)(-1),
			XPathNodeType.Element,
			XPathNodeType.Attribute,
			XPathNodeType.Text,
			XPathNodeType.Text,
			(XPathNodeType)(-1),
			(XPathNodeType)(-1),
			XPathNodeType.ProcessingInstruction,
			XPathNodeType.Comment,
			(XPathNodeType)(-1),
			(XPathNodeType)(-1),
			(XPathNodeType)(-1),
			(XPathNodeType)(-1),
			XPathNodeType.Whitespace,
			XPathNodeType.SignificantWhitespace,
			XPathNodeType.Element,
			(XPathNodeType)(-1),
			(XPathNodeType)(-1)
		};

		private string[] names = new string[10];

		private string[] values = new string[10];

		private SourceLineInfo lastLineInfo;

		private bool textPreserveWS;

		private int textStartLine;

		private int textStartPos;

		public KeywordsTable Atoms => atoms;

		public XPathNodeType NodeType => nodeType;

		public string Value => value;

		public string LocalName => localName;

		public string NamespaceUri => namespaceName;

		public string Prefix => reader.Prefix;

		public string BaseUri => reader.BaseURI;

		public string QualifiedName => reader.Name;

		public bool IsEmptyElement => reader.IsEmptyElement;

		public XmlNameTable NameTable => reader.NameTable;

		public bool CanHaveApplyImports
		{
			get
			{
				return scopeManager.CanHaveApplyImports;
			}
			set
			{
				scopeManager.CanHaveApplyImports = value;
			}
		}

		public bool ForwardCompatibility => scopeManager.ForwardCompatibility;

		public XslVersion XslVersion
		{
			get
			{
				if (!scopeManager.ForwardCompatibility)
				{
					return XslVersion.Version10;
				}
				return XslVersion.ForwardsCompatible;
			}
		}

		public string Uri => reader.BaseURI;

		public int StartLine
		{
			get
			{
				if (readerLineInfo == null)
				{
					return 0;
				}
				if (OnTextNode)
				{
					return textStartLine;
				}
				return readerLineInfo.LineNumber;
			}
		}

		public int StartPos
		{
			get
			{
				if (readerLineInfo == null)
				{
					return 0;
				}
				if (OnTextNode)
				{
					return textStartPos;
				}
				return readerLineInfo.LinePosition - PositionAdjustment(reader.NodeType);
			}
		}

		public int EndLine
		{
			get
			{
				if (readerLineInfo == null)
				{
					return 0;
				}
				return readerLineInfo.LineNumber;
			}
		}

		public int EndPos
		{
			get
			{
				if (readerLineInfo == null)
				{
					return 0;
				}
				int linePosition = readerLineInfo.LinePosition;
				if (OnTextNode)
				{
					return linePosition - PositionAdjustment(reader.NodeType);
				}
				return linePosition + 1;
			}
		}

		private bool OnTextNode => text != null;

		public XsltInput(XmlReader reader, Compiler compiler)
		{
			EnsureExpandEntities(reader);
			IXmlLineInfo xmlLineInfo = reader as IXmlLineInfo;
			this.reader = reader;
			readerLineInfo = ((xmlLineInfo != null && xmlLineInfo.HasLineInfo()) ? xmlLineInfo : null);
			topLevelReader = reader.ReadState == ReadState.Initial;
			scopeManager = new InputScopeManager(reader.NameTable);
			atoms = new KeywordsTable(reader.NameTable);
			this.compiler = compiler;
			textIsWhite = true;
			nodeType = XPathNodeType.Root;
		}

		private static void EnsureExpandEntities(XmlReader reader)
		{
			if (reader is XmlTextReader xmlTextReader && xmlTextReader.EntityHandling != EntityHandling.ExpandEntities)
			{
				xmlTextReader.EntityHandling = EntityHandling.ExpandEntities;
			}
		}

		public bool Start()
		{
			if (topLevelReader)
			{
				return MoveToNextSibling();
			}
			if (reader.ReadState != ReadState.Interactive)
			{
				return false;
			}
			StepOnNodeRdr();
			if (nodeType == XPathNodeType.Comment || nodeType == XPathNodeType.ProcessingInstruction)
			{
				return MoveToNextSibling();
			}
			return nodeType == XPathNodeType.Element;
		}

		public void Finish()
		{
			reader.Read();
			FixLastLineInfo();
			if (topLevelReader)
			{
				while (reader.ReadState == ReadState.Interactive)
				{
					reader.Skip();
				}
			}
		}

		private void SetCachedProperties()
		{
			nodeType = ConvertNodeType(reader.NodeType);
			localName = reader.LocalName;
			namespaceName = reader.NamespaceURI;
			value = reader.Value;
			if (nodeType == XPathNodeType.Attribute && IsNamespace(reader))
			{
				nodeType = XPathNodeType.Namespace;
				namespaceName = string.Empty;
				if (localName == "xmlns")
				{
					localName = string.Empty;
				}
			}
		}

		public string LookupXmlNamespace(string prefix)
		{
			string text = reader.LookupNamespace(prefix);
			if (text != null)
			{
				return NameTable.Add(text);
			}
			if (prefix.Length == 0)
			{
				return string.Empty;
			}
			ReportError("Xslt_InvalidPrefix", prefix);
			return null;
		}

		public bool MoveToNextAttOrNs()
		{
			if (NodeType == XPathNodeType.Element)
			{
				if (!reader.MoveToFirstAttribute())
				{
					reader.MoveToElement();
					return false;
				}
			}
			else if (!reader.MoveToNextAttribute())
			{
				reader.MoveToElement();
				nodeType = XPathNodeType.Element;
				return false;
			}
			SetCachedProperties();
			return true;
		}

		[Conditional("DEBUG")]
		private void SetLastMove(Moves lastMove, bool lastResult)
		{
			this.lastMove = lastMove;
			this.lastResult = lastResult;
		}

		private void StepOnNodeRdr()
		{
			if (text == null)
			{
				SetCachedProperties();
			}
			else
			{
				value = text;
				localName = string.Empty;
				namespaceName = string.Empty;
				nodeType = ((!textIsWhite) ? XPathNodeType.Text : (textPreserveWS ? XPathNodeType.SignificantWhitespace : XPathNodeType.Whitespace));
			}
			if (NodeType == XPathNodeType.Element)
			{
				scopeManager.PushScope();
			}
		}

		private void StepOffNode()
		{
			if (NodeType == XPathNodeType.Element)
			{
				scopeManager.PopScope();
			}
		}

		private bool MoveToFirstChildAny()
		{
			if (!reader.IsEmptyElement)
			{
				return ReadNextSibling();
			}
			nodeType = XPathNodeType.Element;
			return false;
		}

		public bool MoveToFirstChild()
		{
			bool flag = MoveToFirstChildAny();
			if (flag && (NodeType == XPathNodeType.Comment || NodeType == XPathNodeType.ProcessingInstruction))
			{
				flag = MoveToNextSibling();
				if (!flag)
				{
					MoveToParent();
				}
			}
			return flag;
		}

		public bool MoveToNextSibling()
		{
			bool flag;
			do
			{
				StepOffNode();
				flag = ReadNextSibling();
			}
			while (flag && (NodeType == XPathNodeType.Comment || NodeType == XPathNodeType.ProcessingInstruction));
			return flag;
		}

		public bool MoveToParent()
		{
			return true;
		}

		public void SkipNode()
		{
			if (NodeType == XPathNodeType.Element && MoveToFirstChild())
			{
				do
				{
					SkipNode();
				}
				while (MoveToNextSibling());
				MoveToParent();
			}
		}

		private bool ReadNextSiblingHelper()
		{
			if (text != null)
			{
				text = null;
				textIsWhite = true;
				return reader.NodeType != XmlNodeType.EndElement;
			}
			while (reader.Read())
			{
				switch (reader.NodeType)
				{
				case XmlNodeType.Text:
				case XmlNodeType.CDATA:
					if (textIsWhite && !IsWhitespace(reader.Value))
					{
						textIsWhite = false;
					}
					goto case XmlNodeType.Whitespace;
				case XmlNodeType.Whitespace:
				case XmlNodeType.SignificantWhitespace:
					if (reader.Depth != 0 || text != null || !textIsWhite)
					{
						if (text == null)
						{
							SaveTextInfo();
						}
						text += reader.Value;
					}
					break;
				default:
					if (text != null)
					{
						return true;
					}
					return reader.NodeType != XmlNodeType.EndElement;
				case XmlNodeType.EntityReference:
				case XmlNodeType.DocumentType:
				case XmlNodeType.XmlDeclaration:
					break;
				}
			}
			return text != null;
		}

		private bool ReadNextSibling()
		{
			bool flag = ReadNextSiblingHelper();
			FixLastLineInfo();
			if (flag)
			{
				StepOnNodeRdr();
				return true;
			}
			nodeType = XPathNodeType.Element;
			return false;
		}

		private static bool IsNamespace(XmlReader reader)
		{
			if (!(reader.Prefix == "xmlns"))
			{
				if (reader.Prefix.Length == 0)
				{
					return reader.LocalName == "xmlns";
				}
				return false;
			}
			return true;
		}

		private static bool IsWhitespace(string text)
		{
			return XmlCharType.Instance.IsOnlyWhitespace(text);
		}

		private static XPathNodeType ConvertNodeType(XmlNodeType xmlNodeType)
		{
			XPathNodeType xPathNodeType = XmlNodeType2XPathNodeType[(int)xmlNodeType];
			if (xPathNodeType == (XPathNodeType)(-1))
			{
				return XPathNodeType.All;
			}
			return xPathNodeType;
		}

		public bool IsNs(string ns)
		{
			return Ref.Equal(ns, NamespaceUri);
		}

		public bool IsKeyword(string kwd)
		{
			return Ref.Equal(kwd, LocalName);
		}

		public bool IsXsltNamespace()
		{
			return IsNs(atoms.UriXsl);
		}

		public bool IsNullNamespace()
		{
			return IsNs(string.Empty);
		}

		public bool IsXsltAttribute(string kwd)
		{
			if (IsKeyword(kwd))
			{
				return IsNullNamespace();
			}
			return false;
		}

		public void AddExtensionNamespace(string uri)
		{
			scopeManager.AddExtensionNamespace(uri);
		}

		public bool IsExtensionNamespace(string uri)
		{
			return scopeManager.IsExtensionNamespace(uri);
		}

		public void SetVersion(string version, string attName)
		{
			double num = XPathConvert.StringToDouble(version);
			if (double.IsNaN(num))
			{
				ReportError("Xslt_InvalidAttrValue", attName, version);
				num = 1.0;
			}
			scopeManager.ForwardCompatibility = num != 1.0;
		}

		public ContextInfo GetAttributes()
		{
			return GetAttributes(0, 0, names, values);
		}

		public ContextInfo GetAttributes(int required, string name, out string value)
		{
			names[0] = name;
			ContextInfo attributes = GetAttributes(required, 1, names, values);
			value = values[0];
			return attributes;
		}

		public ContextInfo GetAttributes(int required, string name0, out string value0, string name1, out string value1)
		{
			names[0] = name0;
			names[1] = name1;
			ContextInfo attributes = GetAttributes(required, 2, names, values);
			value0 = values[0];
			value1 = values[1];
			return attributes;
		}

		public ContextInfo GetAttributes(int required, string name0, out string value0, string name1, out string value1, string name2, out string value2)
		{
			names[0] = name0;
			names[1] = name1;
			names[2] = name2;
			ContextInfo attributes = GetAttributes(required, 3, names, values);
			value0 = values[0];
			value1 = values[1];
			value2 = values[2];
			return attributes;
		}

		public ContextInfo GetAttributes(int required, string name0, out string value0, string name1, out string value1, string name2, out string value2, string name3, out string value3)
		{
			names[0] = name0;
			names[1] = name1;
			names[2] = name2;
			names[3] = name3;
			ContextInfo attributes = GetAttributes(required, 4, names, values);
			value0 = values[0];
			value1 = values[1];
			value2 = values[2];
			value3 = values[3];
			return attributes;
		}

		public ContextInfo GetAttributes(int required, string name0, out string value0, string name1, out string value1, string name2, out string value2, string name3, out string value3, string name4, out string value4)
		{
			names[0] = name0;
			names[1] = name1;
			names[2] = name2;
			names[3] = name3;
			names[4] = name4;
			ContextInfo attributes = GetAttributes(required, 5, names, values);
			value0 = values[0];
			value1 = values[1];
			value2 = values[2];
			value3 = values[3];
			value4 = values[4];
			return attributes;
		}

		public ContextInfo GetAttributes(int required, string name0, out string value0, string name1, out string value1, string name2, out string value2, string name3, out string value3, string name4, out string value4, string name5, out string value5, string name6, out string value6, string name7, out string value7, string name8, out string value8)
		{
			names[0] = name0;
			names[1] = name1;
			names[2] = name2;
			names[3] = name3;
			names[4] = name4;
			names[5] = name5;
			names[6] = name6;
			names[7] = name7;
			names[8] = name8;
			ContextInfo attributes = GetAttributes(required, 9, names, values);
			value0 = values[0];
			value1 = values[1];
			value2 = values[2];
			value3 = values[3];
			value4 = values[4];
			value5 = values[5];
			value6 = values[6];
			value7 = values[7];
			value8 = values[8];
			return attributes;
		}

		public ContextInfo GetAttributes(int required, string name0, out string value0, string name1, out string value1, string name2, out string value2, string name3, out string value3, string name4, out string value4, string name5, out string value5, string name6, out string value6, string name7, out string value7, string name8, out string value8, string name9, out string value9)
		{
			names[0] = name0;
			names[1] = name1;
			names[2] = name2;
			names[3] = name3;
			names[4] = name4;
			names[5] = name5;
			names[6] = name6;
			names[7] = name7;
			names[8] = name8;
			names[9] = name9;
			ContextInfo attributes = GetAttributes(required, 10, names, values);
			value0 = values[0];
			value1 = values[1];
			value2 = values[2];
			value3 = values[3];
			value4 = values[4];
			value5 = values[5];
			value6 = values[6];
			value7 = values[7];
			value8 = values[8];
			value9 = values[9];
			return attributes;
		}

		public ContextInfo GetAttributes(int required, int number, string[] names, string[] values)
		{
			for (int i = 0; i < number; i++)
			{
				values[i] = null;
			}
			string qualifiedName = QualifiedName;
			ContextInfo contextInfo = new ContextInfo(this);
			compiler.EnterForwardsCompatible();
			while (MoveToNextAttOrNs())
			{
				if (nodeType == XPathNodeType.Namespace)
				{
					contextInfo.AddNamespace(this);
					continue;
				}
				contextInfo.AddAttribute(this);
				bool flag = false;
				for (int j = 0; j < number; j++)
				{
					if (IsXsltAttribute(names[j]))
					{
						flag = true;
						values[j] = Value;
						if (Ref.Equal(names[j], Atoms.Version) && j < required)
						{
							SetVersion(Value, Atoms.Version);
						}
						break;
					}
				}
				if (!flag && (IsNullNamespace() || IsXsltNamespace()))
				{
					ReportError("Xslt_InvalidAttribute", QualifiedName, qualifiedName);
				}
			}
			compiler.ExitForwardsCompatible(ForwardCompatibility);
			for (int k = 0; k < required; k++)
			{
				if (values[k] == null)
				{
					ReportError("Xslt_MissingAttribute", names[k]);
				}
			}
			contextInfo.Finish(this);
			return contextInfo;
		}

		private static int PositionAdjustment(XmlNodeType nt)
		{
			return nt switch
			{
				XmlNodeType.Element => 1, 
				XmlNodeType.CDATA => 9, 
				XmlNodeType.ProcessingInstruction => 2, 
				XmlNodeType.Comment => 4, 
				XmlNodeType.EndElement => 2, 
				_ => 0, 
			};
		}

		private void SaveTextInfo()
		{
			textPreserveWS = reader.XmlSpace == XmlSpace.Preserve;
			textStartLine = StartLine;
			textStartPos = StartPos;
		}

		public ISourceLineInfo BuildLineInfo()
		{
			bool flag = nodeType == XPathNodeType.Attribute;
			if (lastLineInfo != null && !flag)
			{
				return lastLineInfo;
			}
			SourceLineInfo result = new SourceLineInfo(Uri, StartLine, StartPos, EndLine, EndPos);
			if (!OnTextNode && !flag)
			{
				lastLineInfo = result;
			}
			return result;
		}

		public void FixLastLineInfo()
		{
			if (lastLineInfo != null)
			{
				lastLineInfo.SetEndLinePos(StartLine, StartPos);
				lastLineInfo = null;
			}
		}

		public void ReportError(string res, params string[] args)
		{
			compiler.ReportError(BuildLineInfo(), res, args);
		}

		public void ReportWarning(string res, params string[] args)
		{
			compiler.ReportWarning(BuildLineInfo(), res, args);
		}
	}
	internal class XsltLoader : IErrorHelper
	{
		private enum InstructionFlags
		{
			NoParamNoSort,
			AllowParam,
			AllowSort
		}

		private const int MAX_LOADINSTRUCTIONS_DEPTH = 1024;

		private Compiler compiler;

		private XmlResolver xmlResolver;

		private QueryReaderSettings readerSettings;

		private XsltInput input;

		private Stylesheet curStylesheet;

		private Template curTemplate;

		private static QilName nullMode = AstFactory.QName(string.Empty);

		private HybridDictionary documentUriInUse = new HybridDictionary();

		private int loadInstructionsDepth;

		public void Load(Compiler compiler, object stylesheet, XmlResolver xmlResolver)
		{
			this.compiler = compiler;
			this.xmlResolver = xmlResolver ?? XmlNullResolver.Singleton;
			if (stylesheet is XmlReader reader)
			{
				readerSettings = new QueryReaderSettings(reader);
				LoadStylesheet(reader, include: false);
			}
			else if (stylesheet is string text)
			{
				XmlResolver xmlResolver2 = xmlResolver;
				if (xmlResolver == null || xmlResolver == XmlNullResolver.Singleton)
				{
					xmlResolver2 = new XmlUrlResolver();
				}
				Uri uri = xmlResolver2.ResolveUri(null, text);
				if (uri == null)
				{
					throw new XslLoadException("Xslt_CantResolve", text);
				}
				readerSettings = new QueryReaderSettings(new NameTable());
				XmlReader reader2;
				using (reader2 = CreateReader(uri, xmlResolver2))
				{
					LoadStylesheet(reader2, include: false);
				}
			}
			else if (stylesheet is IXPathNavigable iXPathNavigable)
			{
				XmlReader reader2 = XPathNavigatorReader.Create(iXPathNavigable.CreateNavigator());
				readerSettings = new QueryReaderSettings(reader2.NameTable);
				LoadStylesheet(reader2, include: false);
			}
			Process();
		}

		private void Process()
		{
			compiler.StartApplyTemplates = AstFactory.ApplyTemplates(nullMode);
			ProcessOutputSettings();
			ProcessAttributeSets();
		}

		private Uri ResolveUri(string relativeUri, string baseUri)
		{
			Uri baseUri2 = ((baseUri.Length != 0) ? xmlResolver.ResolveUri(null, baseUri) : null);
			Uri uri = xmlResolver.ResolveUri(baseUri2, relativeUri);
			if (uri == null)
			{
				throw new XslLoadException("Xslt_CantResolve", relativeUri);
			}
			return uri;
		}

		private XmlReader CreateReader(Uri uri, XmlResolver xmlResolver)
		{
			object entity = xmlResolver.GetEntity(uri, null, null);
			if (entity is Stream stream)
			{
				return readerSettings.CreateReader(stream, uri.ToString());
			}
			if (entity is XmlReader result)
			{
				return result;
			}
			if (entity is IXPathNavigable iXPathNavigable)
			{
				return XPathNavigatorReader.Create(iXPathNavigable.CreateNavigator());
			}
			throw new XslLoadException("Xslt_CannotLoadStylesheet", uri.ToString(), (entity == null) ? "null" : entity.GetType().ToString());
		}

		private Stylesheet LoadStylesheet(Uri uri, bool include)
		{
			using XmlReader reader = CreateReader(uri, xmlResolver);
			return LoadStylesheet(reader, include);
		}

		private Stylesheet LoadStylesheet(XmlReader reader, bool include)
		{
			string baseURI = reader.BaseURI;
			documentUriInUse.Add(baseURI, null);
			Stylesheet stylesheet = curStylesheet;
			XsltInput xsltInput = input;
			Stylesheet result = (include ? curStylesheet : compiler.CreateStylesheet());
			input = new XsltInput(reader, compiler);
			curStylesheet = result;
			try
			{
				LoadDocument();
				if (!include)
				{
					compiler.MergeWithStylesheet(curStylesheet);
					List<Uri> importHrefs = curStylesheet.ImportHrefs;
					curStylesheet.Imports = new Stylesheet[importHrefs.Count];
					int num = importHrefs.Count - 1;
					while (0 <= num)
					{
						curStylesheet.Imports[num] = LoadStylesheet(importHrefs[num], include: false);
						num--;
					}
					return result;
				}
				return result;
			}
			catch (XslLoadException)
			{
				throw;
			}
			catch (Exception ex2)
			{
				if (!XmlException.IsCatchableException(ex2))
				{
					throw;
				}
				if (ex2 is XmlException ex3)
				{
					SourceLineInfo lineInfo = new SourceLineInfo(input.Uri, ex3.LineNumber, ex3.LinePosition, ex3.LineNumber, ex3.LinePosition);
					throw new XslLoadException(ex3, lineInfo);
				}
				input.FixLastLineInfo();
				throw new XslLoadException(ex2, input.BuildLineInfo());
			}
			finally
			{
				documentUriInUse.Remove(baseURI);
				input = xsltInput;
				curStylesheet = stylesheet;
			}
		}

		private void LoadDocument()
		{
			if (!input.Start())
			{
				ReportError("Xslt_WrongStylesheetElement");
				return;
			}
			if (input.IsXsltNamespace())
			{
				if (input.IsKeyword(input.Atoms.Stylesheet) || input.IsKeyword(input.Atoms.Transform))
				{
					LoadRealStylesheet();
				}
				else
				{
					ReportError("Xslt_WrongStylesheetElement");
					input.SkipNode();
				}
			}
			else
			{
				LoadSimplifiedStylesheet();
			}
			input.Finish();
		}

		private void LoadSimplifiedStylesheet()
		{
			curTemplate = AstFactory.Template(null, "/", nullMode, double.NaN, input.XslVersion);
			input.CanHaveApplyImports = true;
			XslNode xslNode = LoadLiteralResultElement(asStylesheet: true);
			if (xslNode != null)
			{
				SetLineInfo(curTemplate, xslNode.SourceLine);
				List<XslNode> list = new List<XslNode>();
				list.Add(xslNode);
				SetContent(curTemplate, list);
				curStylesheet.AddTemplate(curTemplate);
			}
			curTemplate = null;
		}

		private void InsertExNamespaces(string value, ref NsDecl nsList, bool extensions)
		{
			if (value == null || value.Length == 0)
			{
				return;
			}
			compiler.EnterForwardsCompatible();
			string[] array = XmlConvert.SplitString(value);
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = input.LookupXmlNamespace((array[i] == "#default") ? string.Empty : array[i]);
			}
			if (!compiler.ExitForwardsCompatible(input.ForwardCompatibility))
			{
				return;
			}
			for (int j = 0; j < array.Length; j++)
			{
				if (array[j] != null)
				{
					nsList = new NsDecl(nsList, null, array[j]);
					if (extensions)
					{
						input.AddExtensionNamespace(array[j]);
					}
				}
			}
		}

		private void LoadRealStylesheet()
		{
			string value;
			string value2;
			string value3;
			string value4;
			XsltInput.ContextInfo attributes = input.GetAttributes(1, input.Atoms.Version, out value, input.Atoms.ExtensionElementPrefixes, out value2, input.Atoms.ExcludeResultPrefixes, out value3, input.Atoms.Id, out value4);
			if (value == null)
			{
				input.SetVersion("1.0", input.Atoms.Version);
			}
			InsertExNamespaces(value2, ref attributes.nsList, extensions: true);
			InsertExNamespaces(value3, ref attributes.nsList, extensions: false);
			string qualifiedName = input.QualifiedName;
			if (!input.MoveToFirstChild())
			{
				return;
			}
			bool flag = true;
			do
			{
				bool flag2 = false;
				switch (input.NodeType)
				{
				case XPathNodeType.Element:
					if (input.IsXsltNamespace())
					{
						if (input.IsKeyword(input.Atoms.Import))
						{
							if (!flag)
							{
								ReportError("Xslt_NotAtTop", input.QualifiedName, qualifiedName);
								input.SkipNode();
							}
							else
							{
								flag2 = true;
								LoadImport();
							}
						}
						else if (input.IsKeyword(input.Atoms.Include))
						{
							LoadInclude();
						}
						else if (input.IsKeyword(input.Atoms.StripSpace))
						{
							LoadStripSpace(attributes.nsList);
						}
						else if (input.IsKeyword(input.Atoms.PreserveSpace))
						{
							LoadPreserveSpace(attributes.nsList);
						}
						else if (input.IsKeyword(input.Atoms.Output))
						{
							LoadOutput();
						}
						else if (input.IsKeyword(input.Atoms.Key))
						{
							LoadKey(attributes.nsList);
						}
						else if (input.IsKeyword(input.Atoms.DecimalFormat))
						{
							LoadDecimalFormat(attributes.nsList);
						}
						else if (input.IsKeyword(input.Atoms.NamespaceAlias))
						{
							LoadNamespaceAlias(attributes.nsList);
						}
						else if (input.IsKeyword(input.Atoms.AttributeSet))
						{
							LoadAttributeSet(attributes.nsList);
						}
						else if (input.IsKeyword(input.Atoms.Variable))
						{
							LoadGlobalVariableOrParameter(attributes.nsList, XslNodeType.Variable);
						}
						else if (input.IsKeyword(input.Atoms.Param))
						{
							LoadGlobalVariableOrParameter(attributes.nsList, XslNodeType.Param);
						}
						else if (input.IsKeyword(input.Atoms.Template))
						{
							LoadTemplate(attributes.nsList);
						}
						else
						{
							if (!input.ForwardCompatibility)
							{
								ReportError("Xslt_UnexpectedElementQ", input.QualifiedName, qualifiedName);
							}
							input.SkipNode();
						}
					}
					else if (input.IsNs(input.Atoms.UrnMsxsl) && input.IsKeyword(input.Atoms.Script))
					{
						LoadScript(attributes.nsList);
					}
					else if (input.IsNullNamespace())
					{
						ReportError("Xslt_NullNsAtTopLevel", input.LocalName);
						input.SkipNode();
					}
					else
					{
						input.SkipNode();
					}
					flag = flag2;
					break;
				default:
					ReportError("Xslt_TextNodesNotAllowed", input.Atoms.Stylesheet);
					break;
				case XPathNodeType.SignificantWhitespace:
				case XPathNodeType.Whitespace:
					break;
				}
			}
			while (input.MoveToNextSibling());
			input.MoveToParent();
		}

		private void LoadImport()
		{
			input.GetAttributes(1, input.Atoms.Href, out var value);
			CheckNoContent();
			if (value != null)
			{
				Uri uri = ResolveUri(value, input.BaseUri);
				if (documentUriInUse.Contains(uri.ToString()))
				{
					ReportError("Xslt_CircularInclude", value);
				}
				else
				{
					curStylesheet.ImportHrefs.Add(uri);
				}
			}
		}

		private void LoadInclude()
		{
			input.GetAttributes(1, input.Atoms.Href, out var value);
			CheckNoContent();
			if (value != null)
			{
				Uri uri = ResolveUri(value, input.BaseUri);
				if (documentUriInUse.Contains(uri.ToString()))
				{
					ReportError("Xslt_CircularInclude", value);
				}
				else
				{
					LoadStylesheet(uri, include: true);
				}
			}
		}

		private void LoadStripSpace(NsDecl stylesheetNsList)
		{
			string value;
			XsltInput.ContextInfo attributes = input.GetAttributes(1, input.Atoms.Elements, out value);
			attributes.nsList = MergeNamespaces(attributes.nsList, stylesheetNsList);
			ParseWhitespaceRules(value, preserveSpace: false);
			CheckNoContent();
		}

		private void LoadPreserveSpace(NsDecl stylesheetNsList)
		{
			string value;
			XsltInput.ContextInfo attributes = input.GetAttributes(1, input.Atoms.Elements, out value);
			attributes.nsList = MergeNamespaces(attributes.nsList, stylesheetNsList);
			ParseWhitespaceRules(value, preserveSpace: true);
			CheckNoContent();
		}

		private void LoadOutput()
		{
			input.GetAttributes(0, input.Atoms.Method, out var value, input.Atoms.Version, out var value2, input.Atoms.Encoding, out var value3, input.Atoms.OmitXmlDeclaration, out var value4, input.Atoms.Standalone, out var value5, input.Atoms.DocTypePublic, out var value6, input.Atoms.DocTypeSystem, out var value7, input.Atoms.CDataSectionElements, out var value8, input.Atoms.Indent, out var value9, input.Atoms.MediaType, out var value10);
			Output output = compiler.Output;
			XmlWriterSettings settings = output.Settings;
			int currentPrecedence = compiler.CurrentPrecedence;
			if (value != null && currentPrecedence >= output.MethodPrec)
			{
				compiler.EnterForwardsCompatible();
				XmlOutputMethod method;
				XmlQualifiedName xmlQualifiedName = ParseOutputMethod(value, out method);
				if (compiler.ExitForwardsCompatible(input.ForwardCompatibility) && xmlQualifiedName != null)
				{
					if (currentPrecedence == output.MethodPrec && !output.Method.Equals(xmlQualifiedName))
					{
						ReportWarning("Xslt_AttributeRedefinition", input.Atoms.Method);
					}
					settings.OutputMethod = method;
					output.Method = xmlQualifiedName;
					output.MethodPrec = currentPrecedence;
				}
			}
			if (value2 != null && currentPrecedence >= output.VersionPrec)
			{
				if (currentPrecedence == output.VersionPrec && output.Version != value2)
				{
					ReportWarning("Xslt_AttributeRedefinition", input.Atoms.Version);
				}
				output.Version = value2;
				output.VersionPrec = currentPrecedence;
			}
			if (value3 != null && currentPrecedence >= output.EncodingPrec)
			{
				try
				{
					Encoding encoding = Encoding.GetEncoding(value3);
					if (currentPrecedence == output.EncodingPrec && output.Encoding != value3)
					{
						ReportWarning("Xslt_AttributeRedefinition", input.Atoms.Encoding);
					}
					settings.Encoding = encoding;
					output.Encoding = value3;
					output.EncodingPrec = currentPrecedence;
				}
				catch (ArgumentException)
				{
					if (!input.ForwardCompatibility)
					{
						ReportWarning("Xslt_InvalidEncoding", value3);
					}
				}
			}
			if (value4 != null && currentPrecedence >= output.OmitXmlDeclarationPrec)
			{
				TriState triState = ParseYesNo(value4, input.Atoms.OmitXmlDeclaration);
				if (triState != TriState.Unknown)
				{
					bool flag = triState == TriState.True;
					if (currentPrecedence == output.OmitXmlDeclarationPrec && settings.OmitXmlDeclaration != flag)
					{
						ReportWarning("Xslt_AttributeRedefinition", input.Atoms.OmitXmlDeclaration);
					}
					settings.OmitXmlDeclaration = flag;
					output.OmitXmlDeclarationPrec = currentPrecedence;
				}
			}
			if (value5 != null && currentPrecedence >= output.StandalonePrec)
			{
				TriState triState = ParseYesNo(value5, input.Atoms.Standalone);
				if (triState != TriState.Unknown)
				{
					XmlStandalone xmlStandalone = ((triState == TriState.True) ? XmlStandalone.Yes : XmlStandalone.No);
					if (currentPrecedence == output.StandalonePrec && settings.Standalone != xmlStandalone)
					{
						ReportWarning("Xslt_AttributeRedefinition", input.Atoms.Standalone);
					}
					settings.Standalone = xmlStandalone;
					output.StandalonePrec = currentPrecedence;
				}
			}
			if (value6 != null && currentPrecedence >= output.DocTypePublicPrec)
			{
				if (currentPrecedence == output.DocTypePublicPrec && settings.DocTypePublic != value6)
				{
					ReportWarning("Xslt_AttributeRedefinition", input.Atoms.DocTypePublic);
				}
				settings.DocTypePublic = value6;
				output.DocTypePublicPrec = currentPrecedence;
			}
			if (value7 != null && currentPrecedence >= output.DocTypeSystemPrec)
			{
				if (currentPrecedence == output.DocTypeSystemPrec && settings.DocTypeSystem != value7)
				{
					ReportWarning("Xslt_AttributeRedefinition", input.Atoms.DocTypeSystem);
				}
				settings.DocTypeSystem = value7;
				output.DocTypeSystemPrec = currentPrecedence;
			}
			if (value8 != null && value8.Length != 0)
			{
				compiler.EnterForwardsCompatible();
				string[] array = XmlConvert.SplitString(value8);
				List<XmlQualifiedName> list = new List<XmlQualifiedName>();
				for (int i = 0; i < array.Length; i++)
				{
					list.Add(ResolveQName(ignoreDefaultNs: false, array[i]));
				}
				if (compiler.ExitForwardsCompatible(input.ForwardCompatibility))
				{
					settings.CDataSectionElements.AddRange(list);
				}
			}
			if (value9 != null && currentPrecedence >= output.IndentPrec)
			{
				TriState triState = ParseYesNo(value9, input.Atoms.Indent);
				if (triState != TriState.Unknown)
				{
					bool flag2 = triState == TriState.True;
					if (currentPrecedence == output.IndentPrec && settings.Indent != flag2)
					{
						ReportWarning("Xslt_AttributeRedefinition", input.Atoms.Indent);
					}
					settings.Indent = flag2;
					output.IndentPrec = currentPrecedence;
				}
			}
			if (value10 != null && currentPrecedence >= output.MediaTypePrec)
			{
				if (currentPrecedence == output.MediaTypePrec && settings.MediaType != value10)
				{
					ReportWarning("Xslt_AttributeRedefinition", input.Atoms.MediaType);
				}
				settings.MediaType = value10;
				output.MediaTypePrec = currentPrecedence;
			}
			CheckNoContent();
		}

		private void ProcessOutputSettings()
		{
			Output output = compiler.Output;
			XmlWriterSettings settings = output.Settings;
			if (settings.OutputMethod == XmlOutputMethod.Html && output.IndentPrec == int.MinValue)
			{
				settings.Indent = true;
			}
			if (output.MediaTypePrec == int.MinValue)
			{
				settings.MediaType = ((settings.OutputMethod == XmlOutputMethod.Xml) ? "text/xml" : ((settings.OutputMethod == XmlOutputMethod.Html) ? "text/html" : ((settings.OutputMethod == XmlOutputMethod.Text) ? "text/plain" : null)));
			}
		}

		private void AttributeSetsDfs(AttributeSet attSet)
		{
			switch (attSet.CycleCheck)
			{
			case CycleCheck.NotStarted:
				attSet.CycleCheck = CycleCheck.Processing;
				foreach (QilName usedAttributeSet in attSet.UsedAttributeSets)
				{
					if (compiler.AttributeSets.TryGetValue(usedAttributeSet, out var value))
					{
						AttributeSetsDfs(value);
					}
				}
				attSet.CycleCheck = CycleCheck.Completed;
				break;
			default:
				compiler.ReportError(attSet.Content[0].SourceLine, "Xslt_CircularAttributeSet", attSet.Name.QualifiedName);
				break;
			case CycleCheck.Completed:
				break;
			}
		}

		private void ProcessAttributeSets()
		{
			foreach (AttributeSet value in compiler.AttributeSets.Values)
			{
				AttributeSetsDfs(value);
			}
		}

		private void LoadKey(NsDecl stylesheetNsList)
		{
			string value;
			string value2;
			string value3;
			XsltInput.ContextInfo attributes = input.GetAttributes(3, input.Atoms.Name, out value, input.Atoms.Match, out value2, input.Atoms.Use, out value3);
			attributes.nsList = MergeNamespaces(attributes.nsList, stylesheetNsList);
			CheckNoContent();
			QilName qilName = CreateXPathQName(value);
			Key item = (Key)SetInfo(AstFactory.Key(qilName, value2, value3, input.XslVersion), null, attributes);
			if (compiler.Keys.Contains(qilName))
			{
				compiler.Keys[qilName].Add(item);
				return;
			}
			List<Key> list = new List<Key>();
			list.Add(item);
			compiler.Keys.Add(list);
		}

		private void LoadDecimalFormat(NsDecl stylesheetNsList)
		{
			string[] array = new string[11];
			string[] array2 = new string[11]
			{
				input.Atoms.DecimalSeparator,
				input.Atoms.GroupingSeparator,
				input.Atoms.Percent,
				input.Atoms.PerMille,
				input.Atoms.ZeroDigit,
				input.Atoms.Digit,
				input.Atoms.PatternSeparator,
				input.Atoms.MinusSign,
				input.Atoms.Infinity,
				input.Atoms.NaN,
				input.Atoms.Name
			};
			XsltInput.ContextInfo attributes = input.GetAttributes(0, 11, array2, array);
			attributes.nsList = MergeNamespaces(attributes.nsList, stylesheetNsList);
			char[] characters = DecimalFormatDecl.Default.Characters;
			char[] array3 = new char[8];
			int i;
			for (i = 0; i < 8; i++)
			{
				array3[i] = ParseCharAttribute(array[i], characters[i], array2[i]);
			}
			string text = array[i++];
			string text2 = array[i++];
			string text3 = array[i++];
			if (text == null)
			{
				text = DecimalFormatDecl.Default.InfinitySymbol;
			}
			if (text2 == null)
			{
				text2 = DecimalFormatDecl.Default.NanSymbol;
			}
			for (int j = 0; j < 7; j++)
			{
				for (int k = j + 1; k < 7; k++)
				{
					if (array3[j] == array3[k])
					{
						ReportError("Xslt_DecimalFormatSignsNotDistinct", array2[j], array2[k]);
						break;
					}
				}
			}
			XmlQualifiedName xmlQualifiedName;
			if (text3 == null)
			{
				xmlQualifiedName = new XmlQualifiedName();
			}
			else
			{
				compiler.EnterForwardsCompatible();
				xmlQualifiedName = ResolveQName(ignoreDefaultNs: true, text3);
				if (!compiler.ExitForwardsCompatible(input.ForwardCompatibility))
				{
					xmlQualifiedName = new XmlQualifiedName();
				}
			}
			if (compiler.DecimalFormats.Contains(xmlQualifiedName))
			{
				DecimalFormatDecl decimalFormatDecl = compiler.DecimalFormats[xmlQualifiedName];
				for (i = 0; i < 8; i++)
				{
					if (array3[i] != decimalFormatDecl.Characters[i])
					{
						ReportError("Xslt_DecimalFormatRedefined", array2[i], char.ToString(array3[i]));
					}
				}
				if (text != decimalFormatDecl.InfinitySymbol)
				{
					ReportError("Xslt_DecimalFormatRedefined", array2[i], text);
				}
				i++;
				if (text2 != decimalFormatDecl.NanSymbol)
				{
					ReportError("Xslt_DecimalFormatRedefined", array2[i], text2);
				}
				i++;
				i++;
			}
			else
			{
				DecimalFormatDecl item = new DecimalFormatDecl(xmlQualifiedName, text, text2, new string(array3));
				compiler.DecimalFormats.Add(item);
			}
			CheckNoContent();
		}

		private void LoadNamespaceAlias(NsDecl stylesheetNsList)
		{
			string value;
			string value2;
			XsltInput.ContextInfo attributes = input.GetAttributes(2, input.Atoms.StylesheetPrefix, out value, input.Atoms.ResultPrefix, out value2);
			attributes.nsList = MergeNamespaces(attributes.nsList, stylesheetNsList);
			CheckNoContent();
			string text = null;
			string text2 = null;
			if (value != null)
			{
				if (value.Length == 0)
				{
					ReportError("Xslt_EmptyNsAlias", input.Atoms.StylesheetPrefix);
				}
				else
				{
					if (value == "#default")
					{
						value = string.Empty;
					}
					text = input.LookupXmlNamespace(value);
				}
			}
			if (value2 != null)
			{
				if (value2.Length == 0)
				{
					ReportError("Xslt_EmptyNsAlias", input.Atoms.ResultPrefix);
				}
				else
				{
					if (value2 == "#default")
					{
						value2 = string.Empty;
					}
					text2 = input.LookupXmlNamespace(value2);
				}
			}
			if (text != null && text2 != null && compiler.SetNsAlias(text, text2, value2, curStylesheet.ImportPrecedence))
			{
				ReportWarning("Xslt_DupNsAlias", text);
			}
		}

		private void LoadAttributeSet(NsDecl stylesheetNsList)
		{
			string value;
			string value2;
			XsltInput.ContextInfo attributes = input.GetAttributes(1, input.Atoms.Name, out value, input.Atoms.UseAttributeSets, out value2);
			attributes.nsList = MergeNamespaces(attributes.nsList, stylesheetNsList);
			QilName qilName = CreateXPathQName(value);
			if (!curStylesheet.AttributeSets.TryGetValue(qilName, out var value3))
			{
				value3 = (curStylesheet.AttributeSets[qilName] = AstFactory.AttributeSet(qilName));
				if (!compiler.AttributeSets.ContainsKey(qilName))
				{
					compiler.AllTemplates.Add(value3);
				}
			}
			List<XslNode> list = ParseUseAttributeSets(value2, attributes.lineInfo);
			foreach (XslNode item in list)
			{
				value3.UsedAttributeSets.Add(item.Name);
			}
			if (input.MoveToFirstChild())
			{
				do
				{
					switch (input.NodeType)
					{
					case XPathNodeType.Element:
						if (input.IsXsltNamespace() && input.IsKeyword(input.Atoms.Attribute))
						{
							AddInstruction(list, XslAttribute());
							break;
						}
						ReportError("Xslt_UnexpectedElement", input.QualifiedName, input.Atoms.AttributeSet);
						input.SkipNode();
						break;
					default:
						ReportError("Xslt_TextNodesNotAllowed", input.Atoms.AttributeSet);
						break;
					case XPathNodeType.SignificantWhitespace:
					case XPathNodeType.Whitespace:
						break;
					}
				}
				while (input.MoveToNextSibling());
				input.MoveToParent();
			}
			value3.AddContent(SetInfo(AstFactory.List(), LoadEndTag(list), attributes));
		}

		private void LoadGlobalVariableOrParameter(NsDecl stylesheetNsList, XslNodeType nodeType)
		{
			VarPar varPar = XslVarPar(nodeType);
			varPar.Namespaces = MergeNamespaces(varPar.Namespaces, stylesheetNsList);
			if (!curStylesheet.AddVarPar(varPar))
			{
				ReportError("Xslt_DupGlobalVariable", varPar.Name.QualifiedName);
			}
		}

		private void LoadTemplate(NsDecl stylesheetNsList)
		{
			string value;
			string value2;
			string value3;
			string value4;
			XsltInput.ContextInfo attributes = input.GetAttributes(0, input.Atoms.Match, out value, input.Atoms.Name, out value2, input.Atoms.Priority, out value3, input.Atoms.Mode, out value4);
			attributes.nsList = MergeNamespaces(attributes.nsList, stylesheetNsList);
			if (value == null)
			{
				if (value2 == null)
				{
					ReportError("Xslt_BothMatchNameAbsent");
				}
				if (value4 != null)
				{
					ReportError("Xslt_ModeWithoutMatch");
					value4 = null;
				}
				if (value3 != null)
				{
					ReportWarning("Xslt_PriorityWithoutMatch");
				}
			}
			QilName name = null;
			if (value2 != null)
			{
				compiler.EnterForwardsCompatible();
				name = CreateXPathQName(value2);
				if (!compiler.ExitForwardsCompatible(input.ForwardCompatibility))
				{
					name = null;
				}
			}
			double num = double.NaN;
			if (value3 != null)
			{
				num = XPathConvert.StringToDouble(value3);
				if (double.IsNaN(num) && !input.ForwardCompatibility)
				{
					ReportError("Xslt_InvalidAttrValue", input.Atoms.Priority, value3);
				}
			}
			curTemplate = AstFactory.Template(name, value, ParseMode(value4), num, input.XslVersion);
			input.CanHaveApplyImports = value != null;
			SetInfo(curTemplate, LoadEndTag(LoadInstructions(InstructionFlags.AllowParam)), attributes);
			if (!curStylesheet.AddTemplate(curTemplate))
			{
				ReportError("Xslt_DupTemplateName", curTemplate.Name.QualifiedName);
			}
			curTemplate = null;
		}

		private void LoadScript(NsDecl stylesheetNsList)
		{
			string value;
			string value2;
			XsltInput.ContextInfo attributes = input.GetAttributes(1, input.Atoms.ImplementsPrefix, out value, input.Atoms.Language, out value2);
			attributes.nsList = MergeNamespaces(attributes.nsList, stylesheetNsList);
			string text = null;
			if (value != null)
			{
				if (value.Length == 0)
				{
					ReportError("Xslt_EmptyAttrValue", input.Atoms.ImplementsPrefix, value);
				}
				else
				{
					text = input.LookupXmlNamespace(value);
					if (text == "http://www.w3.org/1999/XSL/Transform")
					{
						ReportError("Xslt_ScriptXsltNamespace");
						text = null;
					}
				}
			}
			if (text == null)
			{
				text = compiler.CreatePhantomNamespace();
			}
			if (value2 == null)
			{
				value2 = "jscript";
			}
			if (!compiler.Settings.EnableScript)
			{
				compiler.Scripts.ScriptClasses[text] = null;
				input.SkipNode();
				return;
			}
			StringBuilder stringBuilder = new StringBuilder();
			string uri = input.Uri;
			int lineNumber = 0;
			int num = 0;
			ScriptClass scriptClass = compiler.Scripts.GetScriptClass(text, value2, this);
			if (scriptClass == null)
			{
				input.SkipNode();
				return;
			}
			if (input.MoveToFirstChild())
			{
				do
				{
					XPathNodeType nodeType = input.NodeType;
					if (nodeType != XPathNodeType.Element)
					{
						if (nodeType == XPathNodeType.Text || stringBuilder.Length != 0)
						{
							int startLine = input.StartLine;
							int endLine = input.EndLine;
							if (stringBuilder.Length == 0)
							{
								lineNumber = startLine;
							}
							else if (num < startLine)
							{
								stringBuilder.Append('\n', startLine - num);
							}
							stringBuilder.Append(input.Value);
							num = endLine;
						}
					}
					else if (input.IsNs(input.Atoms.UrnMsxsl) && (input.IsKeyword(input.Atoms.Assembly) || input.IsKeyword(input.Atoms.Using)))
					{
						if (stringBuilder.Length != 0)
						{
							ReportError("Xslt_ScriptNotAtTop", input.QualifiedName);
							input.SkipNode();
						}
						if (input.IsKeyword(input.Atoms.Assembly))
						{
							LoadMsAssembly(scriptClass);
						}
						else if (input.IsKeyword(input.Atoms.Using))
						{
							LoadMsUsing(scriptClass);
						}
					}
					else
					{
						ReportError("Xslt_UnexpectedElementQ", input.QualifiedName, "msxsl:script");
						input.SkipNode();
					}
				}
				while (input.MoveToNextSibling());
				input.MoveToParent();
			}
			if (stringBuilder.Length == 0)
			{
				lineNumber = input.StartLine;
			}
			scriptClass.AddScriptBlock(stringBuilder.ToString(), uri, lineNumber, input.StartLine, input.StartPos);
		}

		private void LoadMsAssembly(ScriptClass scriptClass)
		{
			input.GetAttributes(0, input.Atoms.Name, out var value, input.Atoms.Href, out var value2);
			string text = null;
			if (value != null)
			{
				if (value2 != null)
				{
					ReportError("Xslt_AssemblyBothNameHrefPresent");
				}
				else
				{
					try
					{
						text = Assembly.Load(value).Location;
					}
					catch
					{
						AssemblyName assemblyName = new AssemblyName(value);
						byte[] publicKeyToken = assemblyName.GetPublicKeyToken();
						if ((publicKeyToken != null && publicKeyToken.Length != 0) || !(assemblyName.Version == null))
						{
							throw;
						}
						text = assemblyName.Name + ".dll";
					}
				}
			}
			else if (value2 != null)
			{
				text = Assembly.LoadFrom(ResolveUri(value2, input.BaseUri).ToString()).Location;
				scriptClass.refAssembliesByHref = true;
			}
			else
			{
				ReportError("Xslt_AssemblyBothNameHrefAbsent");
			}
			if (text != null)
			{
				scriptClass.refAssemblies.Add(text);
			}
			CheckNoContent();
		}

		private void LoadMsUsing(ScriptClass scriptClass)
		{
			input.GetAttributes(1, input.Atoms.Namespace, out var value);
			if (value != null)
			{
				scriptClass.nsImports.Add(value);
			}
			CheckNoContent();
		}

		private List<XslNode> LoadInstructions()
		{
			return LoadInstructions(new List<XslNode>(), InstructionFlags.NoParamNoSort);
		}

		private List<XslNode> LoadInstructions(InstructionFlags flags)
		{
			return LoadInstructions(new List<XslNode>(), flags);
		}

		private List<XslNode> LoadInstructions(List<XslNode> content)
		{
			return LoadInstructions(content, InstructionFlags.NoParamNoSort);
		}

		private List<XslNode> LoadInstructions(List<XslNode> content, InstructionFlags flags)
		{
			if (++loadInstructionsDepth > 1024 && XsltConfigSection.LimitXPathComplexity)
			{
				throw XsltException.Create("Xslt_CompileError2");
			}
			string qualifiedName = input.QualifiedName;
			if (input.MoveToFirstChild())
			{
				bool flag = true;
				do
				{
					XslNode instruction;
					switch (input.NodeType)
					{
					case XPathNodeType.Element:
					{
						string namespaceUri = input.NamespaceUri;
						string localName = input.LocalName;
						if (namespaceUri == input.Atoms.UriXsl)
						{
							bool flag2 = false;
							if (Ref.Equal(localName, input.Atoms.Param))
							{
								if ((flags & InstructionFlags.AllowParam) == 0)
								{
									ReportError("Xslt_UnexpectedElementQ", input.QualifiedName, qualifiedName);
									flag2 = true;
								}
								else if (!flag)
								{
									ReportError("Xslt_NotAtTop", input.QualifiedName, qualifiedName);
									flag2 = true;
								}
							}
							else if (Ref.Equal(localName, input.Atoms.Sort))
							{
								if ((flags & InstructionFlags.AllowSort) == 0)
								{
									ReportError("Xslt_UnexpectedElementQ", input.QualifiedName, qualifiedName);
									flag2 = true;
								}
								else if (!flag)
								{
									ReportError("Xslt_NotAtTop", input.QualifiedName, qualifiedName);
									flag2 = true;
								}
							}
							else
							{
								flag = false;
							}
							if (flag2)
							{
								flag = false;
								input.SkipNode();
								continue;
							}
							instruction = (Ref.Equal(localName, input.Atoms.ApplyImports) ? XslApplyImports() : (Ref.Equal(localName, input.Atoms.ApplyTemplates) ? XslApplyTemplates() : (Ref.Equal(localName, input.Atoms.CallTemplate) ? XslCallTemplate() : (Ref.Equal(localName, input.Atoms.Copy) ? XslCopy() : (Ref.Equal(localName, input.Atoms.CopyOf) ? XslCopyOf() : (Ref.Equal(localName, input.Atoms.Fallback) ? XslFallback() : (Ref.Equal(localName, input.Atoms.If) ? XslIf() : (Ref.Equal(localName, input.Atoms.Choose) ? XslChoose() : (Ref.Equal(localName, input.Atoms.ForEach) ? XslForEach() : (Ref.Equal(localName, input.Atoms.Message) ? XslMessage() : (Ref.Equal(localName, input.Atoms.Number) ? XslNumber() : (Ref.Equal(localName, input.Atoms.ValueOf) ? XslValueOf() : (Ref.Equal(localName, input.Atoms.Comment) ? XslComment() : (Ref.Equal(localName, input.Atoms.ProcessingInstruction) ? XslProcessingInstruction() : (Ref.Equal(localName, input.Atoms.Text) ? XslText() : (Ref.Equal(localName, input.Atoms.Element) ? XslElement() : (Ref.Equal(localName, input.Atoms.Attribute) ? XslAttribute() : (Ref.Equal(localName, input.Atoms.Variable) ? XslVarPar(XslNodeType.Variable) : (Ref.Equal(localName, input.Atoms.Param) ? XslVarPar(XslNodeType.Param) : (Ref.Equal(localName, input.Atoms.Sort) ? XslSort() : LoadUnknownXsltInstruction(qualifiedName)))))))))))))))))))));
							break;
						}
						flag = false;
						instruction = LoadLiteralResultElement(asStylesheet: false);
						break;
					}
					case XPathNodeType.SignificantWhitespace:
						instruction = SetLineInfo(AstFactory.Text(input.Value), input.BuildLineInfo());
						break;
					default:
						flag = false;
						goto case XPathNodeType.SignificantWhitespace;
					case XPathNodeType.Whitespace:
						continue;
					}
					AddInstruction(content, instruction);
				}
				while (input.MoveToNextSibling());
				input.MoveToParent();
			}
			loadInstructionsDepth--;
			return content;
		}

		private XslNode XslApplyImports()
		{
			XsltInput.ContextInfo attributes = input.GetAttributes();
			if (!input.CanHaveApplyImports)
			{
				ReportError("Xslt_InvalidApplyImports");
				input.SkipNode();
				return null;
			}
			CheckNoContent();
			return SetInfo(AstFactory.ApplyImports(curTemplate.Mode, curStylesheet, input.XslVersion), null, attributes);
		}

		private XslNode XslApplyTemplates()
		{
			string value;
			string value2;
			XsltInput.ContextInfo attributes = input.GetAttributes(0, input.Atoms.Select, out value, input.Atoms.Mode, out value2);
			if (value == null)
			{
				value = "node()";
			}
			QilName mode = ParseMode(value2);
			List<XslNode> content = new List<XslNode>();
			if (input.MoveToFirstChild())
			{
				do
				{
					switch (input.NodeType)
					{
					case XPathNodeType.Element:
						if (input.IsXsltNamespace())
						{
							if (input.IsKeyword(input.Atoms.WithParam))
							{
								XslNode xslNode = XslVarPar(XslNodeType.WithParam);
								CheckWithParam(content, xslNode);
								AddInstruction(content, xslNode);
								break;
							}
							if (input.IsKeyword(input.Atoms.Sort))
							{
								AddInstruction(content, XslSort());
								break;
							}
						}
						ReportError("Xslt_UnexpectedElement", input.QualifiedName, input.Atoms.ApplyTemplates);
						input.SkipNode();
						break;
					default:
						ReportError("Xslt_TextNodesNotAllowed", input.Atoms.ApplyTemplates);
						break;
					case XPathNodeType.SignificantWhitespace:
					case XPathNodeType.Whitespace:
						break;
					}
				}
				while (input.MoveToNextSibling());
				input.MoveToParent();
			}
			attributes.SaveExtendedLineInfo(input);
			return SetInfo(AstFactory.ApplyTemplates(mode, value, attributes, input.XslVersion), content, attributes);
		}

		private XslNode XslCallTemplate()
		{
			string value;
			XsltInput.ContextInfo attributes = input.GetAttributes(1, input.Atoms.Name, out value);
			List<XslNode> content = new List<XslNode>();
			if (input.MoveToFirstChild())
			{
				do
				{
					switch (input.NodeType)
					{
					case XPathNodeType.Element:
						if (input.IsXsltNamespace() && input.IsKeyword(input.Atoms.WithParam))
						{
							XslNode xslNode = XslVarPar(XslNodeType.WithParam);
							CheckWithParam(content, xslNode);
							AddInstruction(content, xslNode);
						}
						else
						{
							ReportError("Xslt_UnexpectedElement", input.QualifiedName, input.Atoms.CallTemplate);
							input.SkipNode();
						}
						break;
					default:
						ReportError("Xslt_TextNodesNotAllowed", input.Atoms.CallTemplate);
						break;
					case XPathNodeType.SignificantWhitespace:
					case XPathNodeType.Whitespace:
						break;
					}
				}
				while (input.MoveToNextSibling());
				input.MoveToParent();
			}
			attributes.SaveExtendedLineInfo(input);
			return SetInfo(AstFactory.CallTemplate(CreateXPathQName(value), attributes), content, attributes);
		}

		private XslNode XslCopy()
		{
			string value;
			XsltInput.ContextInfo attributes = input.GetAttributes(0, input.Atoms.UseAttributeSets, out value);
			List<XslNode> content = ParseUseAttributeSets(value, attributes.lineInfo);
			return SetInfo(AstFactory.Copy(), LoadEndTag(LoadInstructions(content)), attributes);
		}

		private XslNode XslCopyOf()
		{
			string value;
			XsltInput.ContextInfo attributes = input.GetAttributes(1, input.Atoms.Select, out value);
			CheckNoContent();
			return SetInfo(AstFactory.CopyOf(value, input.XslVersion), null, attributes);
		}

		private XslNode XslFallback()
		{
			input.GetAttributes();
			input.SkipNode();
			return null;
		}

		private XslNode XslIf()
		{
			string value;
			XsltInput.ContextInfo attributes = input.GetAttributes(1, input.Atoms.Test, out value);
			return SetInfo(AstFactory.If(value, input.XslVersion), LoadInstructions(), attributes);
		}

		private XslNode XslChoose()
		{
			XsltInput.ContextInfo attributes = input.GetAttributes();
			List<XslNode> content = new List<XslNode>();
			bool flag = false;
			bool flag2 = false;
			if (input.MoveToFirstChild())
			{
				do
				{
					switch (input.NodeType)
					{
					case XPathNodeType.Element:
					{
						XslNode xslNode = null;
						if (Ref.Equal(input.NamespaceUri, input.Atoms.UriXsl))
						{
							if (Ref.Equal(input.LocalName, input.Atoms.When))
							{
								if (flag)
								{
									ReportError("Xslt_WhenAfterOtherwise");
									input.SkipNode();
									break;
								}
								flag2 = true;
								xslNode = XslIf();
							}
							else if (Ref.Equal(input.LocalName, input.Atoms.Otherwise))
							{
								if (flag)
								{
									ReportError("Xslt_DupOtherwise");
									input.SkipNode();
									break;
								}
								flag = true;
								xslNode = XslOtherwise();
							}
						}
						if (xslNode == null)
						{
							ReportError("Xslt_UnexpectedElement", input.QualifiedName, input.Atoms.Choose);
							input.SkipNode();
						}
						else
						{
							AddInstruction(content, xslNode);
						}
						break;
					}
					default:
						ReportError("Xslt_TextNodesNotAllowed", input.Atoms.Choose);
						break;
					case XPathNodeType.SignificantWhitespace:
					case XPathNodeType.Whitespace:
						break;
					}
				}
				while (input.MoveToNextSibling());
				input.MoveToParent();
			}
			if (!flag2)
			{
				ReportError("Xslt_NoWhen");
			}
			return SetInfo(AstFactory.Choose(), content, attributes);
		}

		private XslNode XslOtherwise()
		{
			XsltInput.ContextInfo attributes = input.GetAttributes();
			return SetInfo(AstFactory.Otherwise(), LoadInstructions(), attributes);
		}

		private XslNode XslForEach()
		{
			string value;
			XsltInput.ContextInfo attributes = input.GetAttributes(1, input.Atoms.Select, out value);
			input.CanHaveApplyImports = false;
			List<XslNode> content = LoadInstructions(InstructionFlags.AllowSort);
			attributes.SaveExtendedLineInfo(input);
			return SetInfo(AstFactory.ForEach(value, attributes, input.XslVersion), content, attributes);
		}

		private XslNode XslMessage()
		{
			string value;
			XsltInput.ContextInfo attributes = input.GetAttributes(0, input.Atoms.Terminate, out value);
			bool term = ParseYesNo(value, input.Atoms.Terminate) == TriState.True;
			return SetInfo(AstFactory.Message(term), LoadEndTag(LoadInstructions()), attributes);
		}

		private XslNode XslNumber()
		{
			string value;
			string value2;
			string value3;
			string value4;
			string value5;
			string value6;
			string value7;
			string value8;
			string value9;
			XsltInput.ContextInfo attributes = input.GetAttributes(0, input.Atoms.Level, out value, input.Atoms.Count, out value2, input.Atoms.From, out value3, input.Atoms.Value, out value4, input.Atoms.Format, out value5, input.Atoms.Lang, out value6, input.Atoms.LetterValue, out value7, input.Atoms.GroupingSeparator, out value8, input.Atoms.GroupingSize, out value9);
			NumberLevel level;
			switch (value)
			{
			case "single":
				level = NumberLevel.Single;
				break;
			case "multiple":
				level = NumberLevel.Multiple;
				break;
			case "any":
				level = NumberLevel.Any;
				break;
			default:
				if (value != null && !input.ForwardCompatibility)
				{
					ReportError("Xslt_InvalidAttrValue", input.Atoms.Level, value);
				}
				goto case "single";
			}
			if (value5 == null)
			{
				value5 = "1";
			}
			CheckNoContent();
			return SetInfo(AstFactory.Number(level, value2, value3, value4, value5, value6, value7, value8, value9, input.XslVersion), null, attributes);
		}

		private XslNode XslValueOf()
		{
			string value;
			string value2;
			XsltInput.ContextInfo attributes = input.GetAttributes(1, input.Atoms.Select, out value, input.Atoms.DisableOutputEscaping, out value2);
			bool flag = ParseYesNo(value2, input.Atoms.DisableOutputEscaping) == TriState.True;
			CheckNoContent();
			return SetInfo(AstFactory.XslNode(flag ? XslNodeType.ValueOfDoe : XslNodeType.ValueOf, null, value, input.XslVersion), null, attributes);
		}

		private VarPar XslVarPar(XslNodeType nodeType)
		{
			string value;
			string value2;
			XsltInput.ContextInfo attributes = input.GetAttributes(1, input.Atoms.Name, out value, input.Atoms.Select, out value2);
			List<XslNode> list = LoadInstructions();
			if (list.Count != 0)
			{
				list = LoadEndTag(list);
			}
			if (value2 != null && list.Count != 0)
			{
				ReportError("Xslt_VariableCntSel2", value);
			}
			VarPar varPar = AstFactory.VarPar(nodeType, CreateXPathQName(value), value2, input.XslVersion);
			SetInfo(varPar, list, attributes);
			return varPar;
		}

		private XslNode XslComment()
		{
			XsltInput.ContextInfo attributes = input.GetAttributes();
			return SetInfo(AstFactory.Comment(), LoadEndTag(LoadInstructions()), attributes);
		}

		private XslNode XslProcessingInstruction()
		{
			string value;
			XsltInput.ContextInfo attributes = input.GetAttributes(1, input.Atoms.Name, out value);
			if (value == null)
			{
				value = compiler.PhantomNCName;
			}
			return SetInfo(AstFactory.PI(value, input.XslVersion), LoadEndTag(LoadInstructions()), attributes);
		}

		private XslNode XslText()
		{
			string value;
			XsltInput.ContextInfo attributes = input.GetAttributes(0, input.Atoms.DisableOutputEscaping, out value);
			SerializationHints hints = ((ParseYesNo(value, input.Atoms.DisableOutputEscaping) == TriState.True) ? SerializationHints.DisableOutputEscaping : SerializationHints.None);
			List<XslNode> list = new List<XslNode>();
			if (input.MoveToFirstChild())
			{
				do
				{
					switch (input.NodeType)
					{
					case XPathNodeType.Text:
					case XPathNodeType.SignificantWhitespace:
					case XPathNodeType.Whitespace:
						list.Add(AstFactory.Text(input.Value, hints));
						continue;
					}
					ReportError("Xslt_UnexpectedElement", input.QualifiedName, input.Atoms.Text);
					input.SkipNode();
				}
				while (input.MoveToNextSibling());
				input.MoveToParent();
			}
			return SetInfo(AstFactory.List(), list, attributes);
		}

		private XslNode XslElement()
		{
			string value;
			string value2;
			string value3;
			XsltInput.ContextInfo attributes = input.GetAttributes(1, input.Atoms.Name, out value, input.Atoms.Namespace, out value2, input.Atoms.UseAttributeSets, out value3);
			if (value == null)
			{
				value = compiler.PhantomNCName;
			}
			if (value2 == "http://www.w3.org/2000/xmlns/")
			{
				ReportError("Xslt_ReservedNS", value2);
			}
			List<XslNode> content = ParseUseAttributeSets(value3, attributes.lineInfo);
			return SetInfo(AstFactory.Element(value, value2, input.XslVersion), LoadEndTag(LoadInstructions(content)), attributes);
		}

		private XslNode XslAttribute()
		{
			string value;
			string value2;
			XsltInput.ContextInfo attributes = input.GetAttributes(1, input.Atoms.Name, out value, input.Atoms.Namespace, out value2);
			if (value == null)
			{
				value = compiler.PhantomNCName;
			}
			if (value2 == "http://www.w3.org/2000/xmlns/")
			{
				ReportError("Xslt_ReservedNS", value2);
			}
			return SetInfo(AstFactory.Attribute(value, value2, input.XslVersion), LoadEndTag(LoadInstructions()), attributes);
		}

		private XslNode XslSort()
		{
			string value;
			string value2;
			string value3;
			string value4;
			string value5;
			XsltInput.ContextInfo attributes = input.GetAttributes(0, input.Atoms.Select, out value, input.Atoms.Lang, out value2, input.Atoms.DataType, out value3, input.Atoms.Order, out value4, input.Atoms.CaseOrder, out value5);
			if (value == null)
			{
				value = ".";
			}
			CheckNoContent();
			return SetInfo(AstFactory.Sort(value, value2, value3, value4, value5, input.XslVersion), null, attributes);
		}

		private XslNode LoadLiteralResultElement(bool asStylesheet)
		{
			string prefix = input.Prefix;
			string localName = input.LocalName;
			string namespaceUri = input.NamespaceUri;
			string text = null;
			string value = null;
			string value2 = null;
			string useAttributeSets = null;
			string attName = null;
			List<XslNode> list = new List<XslNode>();
			XsltInput.ContextInfo contextInfo = new XsltInput.ContextInfo(input);
			while (input.MoveToNextAttOrNs())
			{
				if (input.NodeType == XPathNodeType.Namespace)
				{
					contextInfo.AddNamespace(input);
					continue;
				}
				contextInfo.AddAttribute(input);
				if (input.IsXsltNamespace())
				{
					if (input.LocalName == input.Atoms.Version)
					{
						text = input.Value;
						attName = input.QualifiedName;
					}
					else if (input.LocalName == input.Atoms.ExtensionElementPrefixes)
					{
						value = input.Value;
					}
					else if (input.LocalName == input.Atoms.ExcludeResultPrefixes)
					{
						value2 = input.Value;
					}
					else if (input.LocalName == input.Atoms.UseAttributeSets)
					{
						useAttributeSets = input.Value;
					}
				}
				else
				{
					XslNode node = AstFactory.LiteralAttribute(AstFactory.QName(input.LocalName, input.NamespaceUri, input.Prefix), input.Value, input.XslVersion);
					AddInstruction(list, SetLineInfo(node, contextInfo.lineInfo));
				}
			}
			contextInfo.Finish(input);
			if (text != null)
			{
				input.SetVersion(text, attName);
			}
			else if (asStylesheet)
			{
				if (Ref.Equal(namespaceUri, input.Atoms.UriWdXsl) && Ref.Equal(localName, input.Atoms.Stylesheet))
				{
					ReportError("Xslt_WdXslNamespace");
				}
				else
				{
					ReportError("Xslt_WrongStylesheetElement");
				}
				input.SkipNode();
				return null;
			}
			InsertExNamespaces(value, ref contextInfo.nsList, extensions: true);
			XslNode to;
			if (input.IsExtensionNamespace(namespaceUri))
			{
				list = LoadFallbacks(localName);
				to = AstFactory.List();
			}
			else
			{
				InsertExNamespaces(value2, ref contextInfo.nsList, extensions: false);
				list.InsertRange(0, ParseUseAttributeSets(useAttributeSets, contextInfo.lineInfo));
				list = LoadEndTag(LoadInstructions(list));
				to = AstFactory.LiteralElement(AstFactory.QName(localName, namespaceUri, prefix));
			}
			return SetInfo(to, list, contextInfo);
		}

		private void CheckWithParam(List<XslNode> content, XslNode withParam)
		{
			foreach (XslNode item in content)
			{
				if (item.NodeType == XslNodeType.WithParam && item.Name.Equals(withParam.Name))
				{
					ReportError("Xslt_DuplicateWithParam", withParam.Name.QualifiedName);
					break;
				}
			}
		}

		private static void AddInstruction(List<XslNode> content, XslNode instruction)
		{
			if (instruction != null)
			{
				content.Add(instruction);
			}
		}

		private List<XslNode> LoadEndTag(List<XslNode> content)
		{
			if (compiler.IsDebug && !input.IsEmptyElement)
			{
				AddInstruction(content, SetLineInfo(AstFactory.Nop(), input.BuildLineInfo()));
			}
			return content;
		}

		private XslNode LoadUnknownXsltInstruction(string parentName)
		{
			if (!input.ForwardCompatibility)
			{
				ReportError("Xslt_UnexpectedElementQ", input.QualifiedName, parentName);
				input.SkipNode();
				return null;
			}
			XsltInput.ContextInfo attributes = input.GetAttributes();
			List<XslNode> content = LoadFallbacks(input.LocalName);
			return SetInfo(AstFactory.List(), content, attributes);
		}

		private List<XslNode> LoadFallbacks(string instrName)
		{
			List<XslNode> list = new List<XslNode>();
			if (input.MoveToFirstChild())
			{
				do
				{
					if (Ref.Equal(input.NamespaceUri, input.Atoms.UriXsl) && Ref.Equal(input.LocalName, input.Atoms.Fallback))
					{
						XsltInput.ContextInfo attributes = input.GetAttributes();
						list.Add(SetInfo(AstFactory.List(), LoadInstructions(), attributes));
					}
					else
					{
						input.SkipNode();
					}
				}
				while (input.MoveToNextSibling());
				input.MoveToParent();
			}
			if (list.Count == 0)
			{
				list.Add(AstFactory.Error(XslLoadException.CreateMessage(input.BuildLineInfo(), "Xslt_UnknownExtensionElement", instrName)));
			}
			return list;
		}

		private QilName ParseMode(string qname)
		{
			if (qname == null)
			{
				return nullMode;
			}
			compiler.EnterForwardsCompatible();
			QilName result = CreateXPathQName(qname);
			if (!compiler.ExitForwardsCompatible(input.ForwardCompatibility))
			{
				result = nullMode;
			}
			return result;
		}

		private void ResolveQName(bool ignoreDefaultNs, string qname, out string localName, out string namespaceName, out string prefix)
		{
			if (qname == null)
			{
				prefix = compiler.PhantomNCName;
				localName = compiler.PhantomNCName;
				namespaceName = compiler.CreatePhantomNamespace();
				return;
			}
			if (!compiler.ParseQName(qname, out prefix, out localName, this))
			{
				namespaceName = compiler.CreatePhantomNamespace();
				return;
			}
			if (ignoreDefaultNs && prefix.Length == 0)
			{
				namespaceName = string.Empty;
				return;
			}
			namespaceName = input.LookupXmlNamespace(prefix);
			if (namespaceName == null)
			{
				namespaceName = compiler.CreatePhantomNamespace();
			}
		}

		private QilName CreateXPathQName(string qname)
		{
			ResolveQName(ignoreDefaultNs: true, qname, out var localName, out var namespaceName, out var prefix);
			return AstFactory.QName(localName, namespaceName, prefix);
		}

		private XmlQualifiedName ResolveQName(bool ignoreDefaultNs, string qname)
		{
			ResolveQName(ignoreDefaultNs, qname, out var localName, out var namespaceName, out var _);
			return new XmlQualifiedName(localName, namespaceName);
		}

		private void ParseWhitespaceRules(string elements, bool preserveSpace)
		{
			if (elements == null || elements.Length == 0)
			{
				return;
			}
			string[] array = XmlConvert.SplitString(elements);
			for (int i = 0; i < array.Length; i++)
			{
				string text;
				if (!compiler.ParseNameTest(array[i], out var prefix, out var localName, this))
				{
					text = compiler.CreatePhantomNamespace();
				}
				else if (prefix == null || prefix.Length == 0)
				{
					text = prefix;
				}
				else
				{
					text = input.LookupXmlNamespace(prefix);
					if (text == null)
					{
						text = compiler.CreatePhantomNamespace();
					}
				}
				int index = ((localName == null) ? 1 : 0) + ((text == null) ? 1 : 0);
				curStylesheet.AddWhitespaceRule(index, new WhitespaceRule(localName, text, preserveSpace));
			}
		}

		private XmlQualifiedName ParseOutputMethod(string attValue, out XmlOutputMethod method)
		{
			ResolveQName(ignoreDefaultNs: true, attValue, out var localName, out var namespaceName, out var prefix);
			method = XmlOutputMethod.AutoDetect;
			if (compiler.IsPhantomNamespace(namespaceName))
			{
				return null;
			}
			if (prefix.Length == 0)
			{
				switch (localName)
				{
				case "xml":
					method = XmlOutputMethod.Xml;
					break;
				case "html":
					method = XmlOutputMethod.Html;
					break;
				case "text":
					method = XmlOutputMethod.Text;
					break;
				default:
					ReportError("Xslt_InvalidAttrValue", input.Atoms.Method, attValue);
					return null;
				}
			}
			else if (!input.ForwardCompatibility)
			{
				ReportWarning("Xslt_InvalidMethod", attValue);
			}
			return new XmlQualifiedName(localName, namespaceName);
		}

		private List<XslNode> ParseUseAttributeSets(string useAttributeSets, ISourceLineInfo lineInfo)
		{
			List<XslNode> list = new List<XslNode>();
			if (useAttributeSets != null && useAttributeSets.Length != 0)
			{
				compiler.EnterForwardsCompatible();
				string[] array = XmlConvert.SplitString(useAttributeSets);
				for (int i = 0; i < array.Length; i++)
				{
					AddInstruction(list, SetLineInfo(AstFactory.UseAttributeSet(CreateXPathQName(array[i])), lineInfo));
				}
				if (!compiler.ExitForwardsCompatible(input.ForwardCompatibility))
				{
					list = new List<XslNode>();
				}
			}
			return list;
		}

		private TriState ParseYesNo(string val, string attName)
		{
			switch (val)
			{
			case null:
				return TriState.Unknown;
			case "yes":
				return TriState.True;
			case "no":
				return TriState.False;
			default:
				if (!input.ForwardCompatibility)
				{
					ReportError("Xslt_BistateAttribute", attName, "yes", "no");
				}
				return TriState.Unknown;
			}
		}

		private char ParseCharAttribute(string attValue, char defaultValue, string attName)
		{
			if (attValue == null)
			{
				return defaultValue;
			}
			if (attValue.Length != 1)
			{
				if (!input.ForwardCompatibility)
				{
					ReportError("Xslt_CharAttribute", attName);
				}
				return defaultValue;
			}
			return attValue[0];
		}

		private void CheckNoContent()
		{
			string qualifiedName = input.QualifiedName;
			bool flag = false;
			if (!input.MoveToFirstChild())
			{
				return;
			}
			do
			{
				if (input.NodeType != XPathNodeType.Whitespace)
				{
					if (!flag)
					{
						ReportError("Xslt_NotEmptyContents", qualifiedName);
						flag = true;
					}
					input.SkipNode();
				}
			}
			while (input.MoveToNextSibling());
			input.MoveToParent();
		}

		private static XslNode SetLineInfo(XslNode node, ISourceLineInfo lineInfo)
		{
			node.SourceLine = lineInfo;
			return node;
		}

		private static void SetContent(XslNode node, List<XslNode> content)
		{
			if (content != null && content.Count == 0)
			{
				content = null;
			}
			node.SetContent(content);
		}

		private static XslNode SetInfo(XslNode to, List<XslNode> content, XsltInput.ContextInfo info)
		{
			to.Namespaces = info.nsList;
			SetContent(to, content);
			SetLineInfo(to, info.lineInfo);
			return to;
		}

		private static NsDecl MergeNamespaces(NsDecl thisList, NsDecl parentList)
		{
			if (parentList == null)
			{
				return thisList;
			}
			if (thisList == null)
			{
				return parentList;
			}
			while (parentList != null)
			{
				bool flag = false;
				for (NsDecl nsDecl = thisList; nsDecl != null; nsDecl = nsDecl.Prev)
				{
					if (Ref.Equal(nsDecl.Prefix, parentList.Prefix) && (nsDecl.Prefix != null || nsDecl.NsUri == parentList.NsUri))
					{
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					thisList = new NsDecl(thisList, parentList.Prefix, parentList.NsUri);
				}
				parentList = parentList.Prev;
			}
			return thisList;
		}

		public void ReportError(string res, params string[] args)
		{
			compiler.ReportError(input.BuildLineInfo(), res, args);
		}

		public void ReportWarning(string res, params string[] args)
		{
			compiler.ReportWarning(input.BuildLineInfo(), res, args);
		}
	}
	internal class XsltQilFactory : XPathQilFactory
	{
		public XsltQilFactory(QilFactory f, bool debug)
			: base(f, debug)
		{
		}

		[Conditional("DEBUG")]
		public void CheckXsltType(QilNode n)
		{
			XmlQueryType xmlType = n.XmlType;
			switch (xmlType.TypeCode)
			{
			}
		}

		[Conditional("DEBUG")]
		public void CheckQName(QilNode n)
		{
		}

		public QilNode DefaultValueMarker()
		{
			return QName("default-value", "urn:schemas-microsoft-com:xslt-debug");
		}

		public QilNode IsDefaultValueMarker(QilNode n)
		{
			return IsType(n, XmlQueryTypeFactory.QNameX);
		}

		public QilNode InvokeIsSameNodeSort(QilNode n1, QilNode n2)
		{
			return XsltInvokeEarlyBound(QName("is-same-node-sort"), XsltMethods.IsSameNodeSort, XmlQueryTypeFactory.BooleanX, new QilNode[2] { n1, n2 });
		}

		public QilNode InvokeSystemProperty(QilNode n)
		{
			return XsltInvokeEarlyBound(QName("system-property"), XsltMethods.SystemProperty, XmlQueryTypeFactory.Choice(XmlQueryTypeFactory.DoubleX, XmlQueryTypeFactory.StringX), new QilNode[1] { n });
		}

		public QilNode InvokeElementAvailable(QilNode n)
		{
			return XsltInvokeEarlyBound(QName("element-available"), XsltMethods.ElementAvailable, XmlQueryTypeFactory.BooleanX, new QilNode[1] { n });
		}

		public QilNode InvokeCheckScriptNamespace(string nsUri)
		{
			return XsltInvokeEarlyBound(QName("register-script-namespace"), XsltMethods.CheckScriptNamespace, XmlQueryTypeFactory.IntX, new QilNode[1] { String(nsUri) });
		}

		public QilNode InvokeFunctionAvailable(QilNode n)
		{
			return XsltInvokeEarlyBound(QName("function-available"), XsltMethods.FunctionAvailable, XmlQueryTypeFactory.BooleanX, new QilNode[1] { n });
		}

		public QilNode InvokeBaseUri(QilNode n)
		{
			return XsltInvokeEarlyBound(QName("base-uri"), XsltMethods.BaseUri, XmlQueryTypeFactory.StringX, new QilNode[1] { n });
		}

		public QilNode InvokeOnCurrentNodeChanged(QilNode n)
		{
			return XsltInvokeEarlyBound(QName("on-current-node-changed"), XsltMethods.OnCurrentNodeChanged, XmlQueryTypeFactory.IntX, new QilNode[1] { n });
		}

		public QilNode InvokeLangToLcid(QilNode n, bool fwdCompat)
		{
			return XsltInvokeEarlyBound(QName("lang-to-lcid"), XsltMethods.LangToLcid, XmlQueryTypeFactory.IntX, new QilNode[2]
			{
				n,
				Boolean(fwdCompat)
			});
		}

		public QilNode InvokeNumberFormat(QilNode value, QilNode format, QilNode lang, QilNode letterValue, QilNode groupingSeparator, QilNode groupingSize)
		{
			return XsltInvokeEarlyBound(QName("number-format"), XsltMethods.NumberFormat, XmlQueryTypeFactory.StringX, new QilNode[6] { value, format, lang, letterValue, groupingSeparator, groupingSize });
		}

		public QilNode InvokeRegisterDecimalFormat(DecimalFormatDecl format)
		{
			return XsltInvokeEarlyBound(QName("register-decimal-format"), XsltMethods.RegisterDecimalFormat, XmlQueryTypeFactory.IntX, new QilNode[4]
			{
				QName(format.Name.Name, format.Name.Namespace),
				String(format.InfinitySymbol),
				String(format.NanSymbol),
				String(new string(format.Characters))
			});
		}

		public QilNode InvokeRegisterDecimalFormatter(QilNode formatPicture, DecimalFormatDecl format)
		{
			return XsltInvokeEarlyBound(QName("register-decimal-formatter"), XsltMethods.RegisterDecimalFormatter, XmlQueryTypeFactory.DoubleX, new QilNode[4]
			{
				formatPicture,
				String(format.InfinitySymbol),
				String(format.NanSymbol),
				String(new string(format.Characters))
			});
		}

		public QilNode InvokeFormatNumberStatic(QilNode value, QilNode decimalFormatIndex)
		{
			return XsltInvokeEarlyBound(QName("format-number-static"), XsltMethods.FormatNumberStatic, XmlQueryTypeFactory.StringX, new QilNode[2] { value, decimalFormatIndex });
		}

		public QilNode InvokeFormatNumberDynamic(QilNode value, QilNode formatPicture, QilNode decimalFormatName, QilNode errorMessageName)
		{
			return XsltInvokeEarlyBound(QName("format-number-dynamic"), XsltMethods.FormatNumberDynamic, XmlQueryTypeFactory.StringX, new QilNode[4] { value, formatPicture, decimalFormatName, errorMessageName });
		}

		public QilNode InvokeOuterXml(QilNode n)
		{
			return XsltInvokeEarlyBound(QName("outer-xml"), XsltMethods.OuterXml, XmlQueryTypeFactory.StringX, new QilNode[1] { n });
		}

		public QilNode InvokeMsFormatDateTime(QilNode datetime, QilNode format, QilNode lang, QilNode isDate)
		{
			return XsltInvokeEarlyBound(QName("ms:format-date-time"), XsltMethods.MSFormatDateTime, XmlQueryTypeFactory.StringX, new QilNode[4] { datetime, format, lang, isDate });
		}

		public QilNode InvokeMsStringCompare(QilNode x, QilNode y, QilNode lang, QilNode options)
		{
			return XsltInvokeEarlyBound(QName("ms:string-compare"), XsltMethods.MSStringCompare, XmlQueryTypeFactory.DoubleX, new QilNode[4] { x, y, lang, options });
		}

		public QilNode InvokeMsUtc(QilNode n)
		{
			return XsltInvokeEarlyBound(QName("ms:utc"), XsltMethods.MSUtc, XmlQueryTypeFactory.StringX, new QilNode[1] { n });
		}

		public QilNode InvokeMsNumber(QilNode n)
		{
			return XsltInvokeEarlyBound(QName("ms:number"), XsltMethods.MSNumber, XmlQueryTypeFactory.DoubleX, new QilNode[1] { n });
		}

		public QilNode InvokeMsLocalName(QilNode n)
		{
			return XsltInvokeEarlyBound(QName("ms:local-name"), XsltMethods.MSLocalName, XmlQueryTypeFactory.StringX, new QilNode[1] { n });
		}

		public QilNode InvokeMsNamespaceUri(QilNode n, QilNode currentNode)
		{
			return XsltInvokeEarlyBound(QName("ms:namespace-uri"), XsltMethods.MSNamespaceUri, XmlQueryTypeFactory.StringX, new QilNode[2] { n, currentNode });
		}

		public QilNode InvokeEXslObjectType(QilNode n)
		{
			return XsltInvokeEarlyBound(QName("exsl:object-type"), XsltMethods.EXslObjectType, XmlQueryTypeFactory.StringX, new QilNode[1] { n });
		}
	}
}
namespace System.Xml.Xsl.XsltOld
{
	internal abstract class Action
	{
		internal const int Initialized = 0;

		internal const int Finished = -1;

		internal abstract void Execute(Processor processor, ActionFrame frame);

		internal virtual void ReplaceNamespaceAlias(Compiler compiler)
		{
		}

		internal virtual DbgData GetDbgData(ActionFrame frame)
		{
			return DbgData.Empty;
		}
	}
}
namespace System.Xml.Xsl.XsltOld.Debugger
{
	internal interface IStackFrame
	{
		XPathNavigator Instruction { get; }

		XPathNodeIterator NodeSet { get; }

		int GetVariablesCount();

		XPathNavigator GetVariable(int varIndex);

		object GetVariableValue(int varIndex);
	}
}
namespace System.Xml.Xsl.XsltOld
{
	internal class ActionFrame : IStackFrame
	{
		private class XPathSortArrayIterator : XPathArrayIterator
		{
			public override XPathNavigator Current => ((MS.Internal.Xml.XPath.SortKey)list[index - 1]).Node;

			public XPathSortArrayIterator(List<MS.Internal.Xml.XPath.SortKey> list)
				: base(list)
			{
			}

			public XPathSortArrayIterator(XPathSortArrayIterator it)
				: base(it)
			{
			}

			public override XPathNodeIterator Clone()
			{
				return new XPathSortArrayIterator(this);
			}
		}

		private int state;

		private int counter;

		private object[] variables;

		private Hashtable withParams;

		private Action action;

		private ActionFrame container;

		private int currentAction;

		private XPathNodeIterator nodeSet;

		private XPathNodeIterator newNodeSet;

		private PrefixQName calulatedName;

		private string storedOutput;

		internal PrefixQName CalulatedName
		{
			get
			{
				return calulatedName;
			}
			set
			{
				calulatedName = value;
			}
		}

		internal string StoredOutput
		{
			get
			{
				return storedOutput;
			}
			set
			{
				storedOutput = value;
			}
		}

		internal int State
		{
			get
			{
				return state;
			}
			set
			{
				state = value;
			}
		}

		internal int Counter
		{
			get
			{
				return counter;
			}
			set
			{
				counter = value;
			}
		}

		internal ActionFrame Container => container;

		internal XPathNavigator Node
		{
			get
			{
				if (nodeSet != null)
				{
					return nodeSet.Current;
				}
				return null;
			}
		}

		internal XPathNodeIterator NodeSet => nodeSet;

		internal XPathNodeIterator NewNodeSet => newNodeSet;

		XPathNavigator IStackFrame.Instruction
		{
			get
			{
				if (action == null)
				{
					return null;
				}
				return action.GetDbgData(this).StyleSheet;
			}
		}

		XPathNodeIterator IStackFrame.NodeSet => nodeSet.Clone();

		internal int IncrementCounter()
		{
			return ++counter;
		}

		internal void AllocateVariables(int count)
		{
			if (0 < count)
			{
				variables = new object[count];
			}
			else
			{
				variables = null;
			}
		}

		internal object GetVariable(int index)
		{
			return variables[index];
		}

		internal void SetVariable(int index, object value)
		{
			variables[index] = value;
		}

		internal void SetParameter(XmlQualifiedName name, object value)
		{
			if (withParams == null)
			{
				withParams = new Hashtable();
			}
			withParams[name] = value;
		}

		internal void ResetParams()
		{
			if (withParams != null)
			{
				withParams.Clear();
			}
		}

		internal object GetParameter(XmlQualifiedName name)
		{
			if (withParams != null)
			{
				return withParams[name];
			}
			return null;
		}

		internal void InitNodeSet(XPathNodeIterator nodeSet)
		{
			this.nodeSet = nodeSet;
		}

		internal void InitNewNodeSet(XPathNodeIterator nodeSet)
		{
			newNodeSet = nodeSet;
		}

		internal void SortNewNodeSet(Processor proc, ArrayList sortarray)
		{
			int count = sortarray.Count;
			XPathSortComparer xPathSortComparer = new XPathSortComparer(count);
			for (int i = 0; i < count; i++)
			{
				Sort sort = (Sort)sortarray[i];
				Query compiledQuery = proc.GetCompiledQuery(sort.select);
				xPathSortComparer.AddSort(compiledQuery, new XPathComparerHelper(sort.order, sort.caseOrder, sort.lang, sort.dataType));
			}
			List<MS.Internal.Xml.XPath.SortKey> list = new List<MS.Internal.Xml.XPath.SortKey>();
			while (NewNextNode(proc))
			{
				XPathNodeIterator xPathNodeIterator = nodeSet;
				nodeSet = newNodeSet;
				MS.Internal.Xml.XPath.SortKey sortKey = new MS.Internal.Xml.XPath.SortKey(count, list.Count, newNodeSet.Current.Clone());
				for (int j = 0; j < count; j++)
				{
					sortKey[j] = xPathSortComparer.Expression(j).Evaluate(newNodeSet);
				}
				list.Add(sortKey);
				nodeSet = xPathNodeIterator;
			}
			list.Sort(xPathSortComparer);
			newNodeSet = new XPathSortArrayIterator(list);
		}

		internal void Finished()
		{
			State = -1;
		}

		internal void Inherit(ActionFrame parent)
		{
			variables = parent.variables;
		}

		private void Init(Action action, ActionFrame container, XPathNodeIterator nodeSet)
		{
			state = 0;
			this.action = action;
			this.container = container;
			currentAction = 0;
			this.nodeSet = nodeSet;
			newNodeSet = null;
		}

		internal void Init(Action action, XPathNodeIterator nodeSet)
		{
			Init(action, null, nodeSet);
		}

		internal void Init(ActionFrame containerFrame, XPathNodeIterator nodeSet)
		{
			Init(containerFrame.GetAction(0), containerFrame, nodeSet);
		}

		internal void SetAction(Action action)
		{
			SetAction(action, 0);
		}

		internal void SetAction(Action action, int state)
		{
			this.action = action;
			this.state = state;
		}

		private Action GetAction(int actionIndex)
		{
			return ((ContainerAction)action).GetAction(actionIndex);
		}

		internal void Exit()
		{
			Finished();
			container = null;
		}

		internal bool Execute(Processor processor)
		{
			if (action == null)
			{
				return true;
			}
			action.Execute(processor, this);
			if (State == -1)
			{
				if (container != null)
				{
					currentAction++;
					action = container.GetAction(currentAction);
					State = 0;
				}
				else
				{
					action = null;
				}
				return action == null;
			}
			return false;
		}

		internal bool NextNode(Processor proc)
		{
			bool flag = nodeSet.MoveNext();
			if (flag && proc.Stylesheet.Whitespace)
			{
				XPathNodeType nodeType = nodeSet.Current.NodeType;
				if (nodeType == XPathNodeType.Whitespace)
				{
					XPathNavigator xPathNavigator = nodeSet.Current.Clone();
					bool flag2;
					do
					{
						xPathNavigator.MoveTo(nodeSet.Current);
						xPathNavigator.MoveToParent();
						flag2 = !proc.Stylesheet.PreserveWhiteSpace(proc, xPathNavigator) && (flag = nodeSet.MoveNext());
						nodeType = nodeSet.Current.NodeType;
					}
					while (flag2 && nodeType == XPathNodeType.Whitespace);
				}
			}
			return flag;
		}

		internal bool NewNextNode(Processor proc)
		{
			bool flag = newNodeSet.MoveNext();
			if (flag && proc.Stylesheet.Whitespace)
			{
				XPathNodeType nodeType = newNodeSet.Current.NodeType;
				if (nodeType == XPathNodeType.Whitespace)
				{
					XPathNavigator xPathNavigator = newNodeSet.Current.Clone();
					bool flag2;
					do
					{
						xPathNavigator.MoveTo(newNodeSet.Current);
						xPathNavigator.MoveToParent();
						flag2 = !proc.Stylesheet.PreserveWhiteSpace(proc, xPathNavigator) && (flag = newNodeSet.MoveNext());
						nodeType = newNodeSet.Current.NodeType;
					}
					while (flag2 && nodeType == XPathNodeType.Whitespace);
				}
			}
			return flag;
		}

		int IStackFrame.GetVariablesCount()
		{
			if (action == null)
			{
				return 0;
			}
			return action.GetDbgData(this).Variables.Length;
		}

		XPathNavigator IStackFrame.GetVariable(int varIndex)
		{
			return action.GetDbgData(this).Variables[varIndex].GetDbgData(null).StyleSheet;
		}

		object IStackFrame.GetVariableValue(int varIndex)
		{
			return GetVariable(action.GetDbgData(this).Variables[varIndex].VarKey);
		}
	}
	internal abstract class CompiledAction : Action
	{
		internal abstract void Compile(Compiler compiler);

		internal virtual bool CompileAttribute(Compiler compiler)
		{
			return false;
		}

		public void CompileAttributes(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			string localName = input.LocalName;
			if (!input.MoveToFirstAttribute())
			{
				return;
			}
			do
			{
				if (!Keywords.Equals(input.NamespaceURI, input.Atoms.Empty))
				{
					continue;
				}
				try
				{
					if (!CompileAttribute(compiler))
					{
						throw XsltException.Create("Xslt_InvalidAttribute", input.LocalName, localName);
					}
				}
				catch
				{
					if (!compiler.ForwardCompatibility)
					{
						throw;
					}
				}
			}
			while (input.MoveToNextAttribute());
			input.ToParent();
		}

		internal static string PrecalculateAvt(ref Avt avt)
		{
			string result = null;
			if (avt != null && avt.IsConstant)
			{
				result = avt.Evaluate(null, null);
				avt = null;
			}
			return result;
		}

		public void CheckEmpty(Compiler compiler)
		{
			string name = compiler.Input.Name;
			if (!compiler.Recurse())
			{
				return;
			}
			do
			{
				XPathNodeType nodeType = compiler.Input.NodeType;
				if (nodeType != XPathNodeType.Whitespace && nodeType != XPathNodeType.Comment && nodeType != XPathNodeType.ProcessingInstruction)
				{
					throw XsltException.Create("Xslt_NotEmptyContents", name);
				}
			}
			while (compiler.Advance());
			compiler.ToParent();
		}

		public void CheckRequiredAttribute(Compiler compiler, object attrValue, string attrName)
		{
			CheckRequiredAttribute(compiler, attrValue != null, attrName);
		}

		public void CheckRequiredAttribute(Compiler compiler, bool attr, string attrName)
		{
			if (!attr)
			{
				throw XsltException.Create("Xslt_MissingAttribute", attrName);
			}
		}
	}
	internal class ApplyImportsAction : CompiledAction
	{
		private const int TemplateProcessed = 2;

		private XmlQualifiedName mode;

		private Stylesheet stylesheet;

		internal override void Compile(Compiler compiler)
		{
			CheckEmpty(compiler);
			if (!compiler.CanHaveApplyImports)
			{
				throw XsltException.Create("Xslt_ApplyImports");
			}
			mode = compiler.CurrentMode;
			stylesheet = compiler.CompiledStylesheet;
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			case 0:
				processor.PushTemplateLookup(frame.NodeSet, mode, stylesheet);
				frame.State = 2;
				break;
			case 2:
				frame.Finished();
				break;
			case 1:
				break;
			}
		}
	}
	internal class ContainerAction : CompiledAction
	{
		protected const int ProcessingChildren = 1;

		internal ArrayList containedActions;

		internal CopyCodeAction lastCopyCodeAction;

		private int maxid;

		internal override void Compile(Compiler compiler)
		{
			throw new NotImplementedException();
		}

		internal void CompileStylesheetAttributes(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			string localName = input.LocalName;
			string text = null;
			string text2 = null;
			if (input.MoveToFirstAttribute())
			{
				do
				{
					string namespaceURI = input.NamespaceURI;
					string localName2 = input.LocalName;
					if (!Keywords.Equals(namespaceURI, input.Atoms.Empty))
					{
						continue;
					}
					if (Keywords.Equals(localName2, input.Atoms.Version))
					{
						text2 = input.Value;
						if (1.0 <= XmlConvert.ToXPathDouble(text2))
						{
							compiler.ForwardCompatibility = text2 != "1.0";
						}
						else if (!compiler.ForwardCompatibility)
						{
							throw XsltException.Create("Xslt_InvalidAttrValue", "version", text2);
						}
					}
					else if (Keywords.Equals(localName2, input.Atoms.ExtensionElementPrefixes))
					{
						compiler.InsertExtensionNamespace(input.Value);
					}
					else if (Keywords.Equals(localName2, input.Atoms.ExcludeResultPrefixes))
					{
						compiler.InsertExcludedNamespace(input.Value);
					}
					else if (!Keywords.Equals(localName2, input.Atoms.Id))
					{
						text = localName2;
					}
				}
				while (input.MoveToNextAttribute());
				input.ToParent();
			}
			if (text2 == null)
			{
				throw XsltException.Create("Xslt_MissingAttribute", "version");
			}
			if (text != null && !compiler.ForwardCompatibility)
			{
				throw XsltException.Create("Xslt_InvalidAttribute", text, localName);
			}
		}

		internal void CompileSingleTemplate(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			string text = null;
			if (input.MoveToFirstAttribute())
			{
				do
				{
					string namespaceURI = input.NamespaceURI;
					string localName = input.LocalName;
					if (Keywords.Equals(namespaceURI, input.Atoms.XsltNamespace) && Keywords.Equals(localName, input.Atoms.Version))
					{
						text = input.Value;
					}
				}
				while (input.MoveToNextAttribute());
				input.ToParent();
			}
			if (text == null)
			{
				if (Keywords.Equals(input.LocalName, input.Atoms.Stylesheet) && input.NamespaceURI == "http://www.w3.org/TR/WD-xsl")
				{
					throw XsltException.Create("Xslt_WdXslNamespace");
				}
				throw XsltException.Create("Xslt_WrongStylesheetElement");
			}
			compiler.AddTemplate(compiler.CreateSingleTemplateAction());
		}

		protected void CompileDocument(Compiler compiler, bool inInclude)
		{
			NavigatorInput input = compiler.Input;
			while (input.NodeType != XPathNodeType.Element)
			{
				if (!compiler.Advance())
				{
					throw XsltException.Create("Xslt_WrongStylesheetElement");
				}
			}
			if (Keywords.Equals(input.NamespaceURI, input.Atoms.XsltNamespace))
			{
				if (!Keywords.Equals(input.LocalName, input.Atoms.Stylesheet) && !Keywords.Equals(input.LocalName, input.Atoms.Transform))
				{
					throw XsltException.Create("Xslt_WrongStylesheetElement");
				}
				compiler.PushNamespaceScope();
				CompileStylesheetAttributes(compiler);
				CompileTopLevelElements(compiler);
				if (!inInclude)
				{
					CompileImports(compiler);
				}
			}
			else
			{
				compiler.PushLiteralScope();
				CompileSingleTemplate(compiler);
			}
			compiler.PopScope();
		}

		internal Stylesheet CompileImport(Compiler compiler, Uri uri, int id)
		{
			NavigatorInput navigatorInput = compiler.ResolveDocument(uri);
			compiler.PushInputDocument(navigatorInput);
			try
			{
				compiler.PushStylesheet(new Stylesheet());
				compiler.Stylesheetid = id;
				CompileDocument(compiler, inInclude: false);
			}
			catch (XsltCompileException)
			{
				throw;
			}
			catch (Exception inner)
			{
				throw new XsltCompileException(inner, navigatorInput.BaseURI, navigatorInput.LineNumber, navigatorInput.LinePosition);
			}
			finally
			{
				compiler.PopInputDocument();
			}
			return compiler.PopStylesheet();
		}

		private void CompileImports(Compiler compiler)
		{
			ArrayList imports = compiler.CompiledStylesheet.Imports;
			int stylesheetid = compiler.Stylesheetid;
			int num = imports.Count - 1;
			while (0 <= num)
			{
				Uri uri = imports[num] as Uri;
				imports[num] = CompileImport(compiler, uri, ++maxid);
				num--;
			}
			compiler.Stylesheetid = stylesheetid;
		}

		private void CompileInclude(Compiler compiler)
		{
			Uri uri = compiler.ResolveUri(compiler.GetSingleAttribute(compiler.Input.Atoms.Href));
			string text = uri.ToString();
			if (compiler.IsCircularReference(text))
			{
				throw XsltException.Create("Xslt_CircularInclude", text);
			}
			NavigatorInput navigatorInput = compiler.ResolveDocument(uri);
			compiler.PushInputDocument(navigatorInput);
			try
			{
				CompileDocument(compiler, inInclude: true);
			}
			catch (XsltCompileException)
			{
				throw;
			}
			catch (Exception inner)
			{
				throw new XsltCompileException(inner, navigatorInput.BaseURI, navigatorInput.LineNumber, navigatorInput.LinePosition);
			}
			finally
			{
				compiler.PopInputDocument();
			}
			CheckEmpty(compiler);
		}

		internal void CompileNamespaceAlias(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			string localName = input.LocalName;
			string text = null;
			string text2 = null;
			string text3 = null;
			string prefix = null;
			if (input.MoveToFirstAttribute())
			{
				do
				{
					string namespaceURI = input.NamespaceURI;
					string localName2 = input.LocalName;
					if (Keywords.Equals(namespaceURI, input.Atoms.Empty))
					{
						if (Keywords.Equals(localName2, input.Atoms.StylesheetPrefix))
						{
							text3 = input.Value;
							text = compiler.GetNsAlias(ref text3);
						}
						else if (Keywords.Equals(localName2, input.Atoms.ResultPrefix))
						{
							prefix = input.Value;
							text2 = compiler.GetNsAlias(ref prefix);
						}
						else if (!compiler.ForwardCompatibility)
						{
							throw XsltException.Create("Xslt_InvalidAttribute", localName2, localName);
						}
					}
				}
				while (input.MoveToNextAttribute());
				input.ToParent();
			}
			CheckRequiredAttribute(compiler, text, "stylesheet-prefix");
			CheckRequiredAttribute(compiler, text2, "result-prefix");
			CheckEmpty(compiler);
			compiler.AddNamespaceAlias(text, new NamespaceInfo(prefix, text2, compiler.Stylesheetid));
		}

		internal void CompileKey(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			string localName = input.LocalName;
			int num = -1;
			int num2 = -1;
			XmlQualifiedName xmlQualifiedName = null;
			if (input.MoveToFirstAttribute())
			{
				do
				{
					string namespaceURI = input.NamespaceURI;
					string localName2 = input.LocalName;
					string value = input.Value;
					if (Keywords.Equals(namespaceURI, input.Atoms.Empty))
					{
						if (Keywords.Equals(localName2, input.Atoms.Name))
						{
							xmlQualifiedName = compiler.CreateXPathQName(value);
						}
						else if (Keywords.Equals(localName2, input.Atoms.Match))
						{
							num = compiler.AddQuery(value, allowVar: false, allowKey: false, isPattern: true);
						}
						else if (Keywords.Equals(localName2, input.Atoms.Use))
						{
							num2 = compiler.AddQuery(value, allowVar: false, allowKey: false, isPattern: false);
						}
						else if (!compiler.ForwardCompatibility)
						{
							throw XsltException.Create("Xslt_InvalidAttribute", localName2, localName);
						}
					}
				}
				while (input.MoveToNextAttribute());
				input.ToParent();
			}
			CheckRequiredAttribute(compiler, num != -1, "match");
			CheckRequiredAttribute(compiler, num2 != -1, "use");
			CheckRequiredAttribute(compiler, xmlQualifiedName != null, "name");
			compiler.InsertKey(xmlQualifiedName, num, num2);
		}

		protected void CompileDecimalFormat(Compiler compiler)
		{
			NumberFormatInfo numberFormatInfo = new NumberFormatInfo();
			DecimalFormat decimalFormat = new DecimalFormat(numberFormatInfo, '#', '0', ';');
			XmlQualifiedName xmlQualifiedName = null;
			NavigatorInput input = compiler.Input;
			if (input.MoveToFirstAttribute())
			{
				do
				{
					if (!Keywords.Equals(input.Prefix, input.Atoms.Empty))
					{
						continue;
					}
					string localName = input.LocalName;
					string value = input.Value;
					if (Keywords.Equals(localName, input.Atoms.Name))
					{
						xmlQualifiedName = compiler.CreateXPathQName(value);
					}
					else if (Keywords.Equals(localName, input.Atoms.DecimalSeparator))
					{
						numberFormatInfo.NumberDecimalSeparator = value;
					}
					else if (Keywords.Equals(localName, input.Atoms.GroupingSeparator))
					{
						numberFormatInfo.NumberGroupSeparator = value;
					}
					else if (Keywords.Equals(localName, input.Atoms.Infinity))
					{
						numberFormatInfo.PositiveInfinitySymbol = value;
					}
					else if (Keywords.Equals(localName, input.Atoms.MinusSign))
					{
						numberFormatInfo.NegativeSign = value;
					}
					else if (Keywords.Equals(localName, input.Atoms.NaN))
					{
						numberFormatInfo.NaNSymbol = value;
					}
					else if (Keywords.Equals(localName, input.Atoms.Percent))
					{
						numberFormatInfo.PercentSymbol = value;
					}
					else if (Keywords.Equals(localName, input.Atoms.PerMille))
					{
						numberFormatInfo.PerMilleSymbol = value;
					}
					else if (Keywords.Equals(localName, input.Atoms.Digit))
					{
						if (CheckAttribute(value.Length == 1, compiler))
						{
							decimalFormat.digit = value[0];
						}
					}
					else if (Keywords.Equals(localName, input.Atoms.ZeroDigit))
					{
						if (CheckAttribute(value.Length == 1, compiler))
						{
							decimalFormat.zeroDigit = value[0];
						}
					}
					else if (Keywords.Equals(localName, input.Atoms.PatternSeparator) && CheckAttribute(value.Length == 1, compiler))
					{
						decimalFormat.patternSeparator = value[0];
					}
				}
				while (input.MoveToNextAttribute());
				input.ToParent();
			}
			numberFormatInfo.NegativeInfinitySymbol = numberFormatInfo.NegativeSign + numberFormatInfo.PositiveInfinitySymbol;
			if (xmlQualifiedName == null)
			{
				xmlQualifiedName = new XmlQualifiedName();
			}
			compiler.AddDecimalFormat(xmlQualifiedName, decimalFormat);
			CheckEmpty(compiler);
		}

		internal bool CheckAttribute(bool valid, Compiler compiler)
		{
			if (!valid)
			{
				if (!compiler.ForwardCompatibility)
				{
					throw XsltException.Create("Xslt_InvalidAttrValue", compiler.Input.LocalName, compiler.Input.Value);
				}
				return false;
			}
			return true;
		}

		protected void CompileSpace(Compiler compiler, bool preserve)
		{
			string singleAttribute = compiler.GetSingleAttribute(compiler.Input.Atoms.Elements);
			string[] array = XmlConvert.SplitString(singleAttribute);
			for (int i = 0; i < array.Length; i++)
			{
				double priority = NameTest(array[i]);
				compiler.CompiledStylesheet.AddSpace(compiler, array[i], priority, preserve);
			}
			CheckEmpty(compiler);
		}

		private double NameTest(string name)
		{
			if (name == "*")
			{
				return -0.5;
			}
			int num = name.Length - 2;
			if (0 <= num && name[num] == ':' && name[num + 1] == '*')
			{
				if (!PrefixQName.ValidatePrefix(name.Substring(0, num)))
				{
					throw XsltException.Create("Xslt_InvalidAttrValue", "elements", name);
				}
				return -0.25;
			}
			PrefixQName.ParseQualifiedName(name, out var _, out var _);
			return 0.0;
		}

		protected void CompileTopLevelElements(Compiler compiler)
		{
			if (!compiler.Recurse())
			{
				return;
			}
			NavigatorInput input = compiler.Input;
			bool flag = false;
			do
			{
				switch (input.NodeType)
				{
				case XPathNodeType.Element:
				{
					string localName = input.LocalName;
					string namespaceURI = input.NamespaceURI;
					if (Keywords.Equals(namespaceURI, input.Atoms.XsltNamespace))
					{
						if (Keywords.Equals(localName, input.Atoms.Import))
						{
							if (flag)
							{
								throw XsltException.Create("Xslt_NotFirstImport");
							}
							Uri uri = compiler.ResolveUri(compiler.GetSingleAttribute(compiler.Input.Atoms.Href));
							string text = uri.ToString();
							if (compiler.IsCircularReference(text))
							{
								throw XsltException.Create("Xslt_CircularInclude", text);
							}
							compiler.CompiledStylesheet.Imports.Add(uri);
							CheckEmpty(compiler);
							break;
						}
						if (Keywords.Equals(localName, input.Atoms.Include))
						{
							flag = true;
							CompileInclude(compiler);
							break;
						}
						flag = true;
						compiler.PushNamespaceScope();
						if (Keywords.Equals(localName, input.Atoms.StripSpace))
						{
							CompileSpace(compiler, preserve: false);
						}
						else if (Keywords.Equals(localName, input.Atoms.PreserveSpace))
						{
							CompileSpace(compiler, preserve: true);
						}
						else if (Keywords.Equals(localName, input.Atoms.Output))
						{
							CompileOutput(compiler);
						}
						else if (Keywords.Equals(localName, input.Atoms.Key))
						{
							CompileKey(compiler);
						}
						else if (Keywords.Equals(localName, input.Atoms.DecimalFormat))
						{
							CompileDecimalFormat(compiler);
						}
						else if (Keywords.Equals(localName, input.Atoms.NamespaceAlias))
						{
							CompileNamespaceAlias(compiler);
						}
						else if (Keywords.Equals(localName, input.Atoms.AttributeSet))
						{
							compiler.AddAttributeSet(compiler.CreateAttributeSetAction());
						}
						else if (Keywords.Equals(localName, input.Atoms.Variable))
						{
							VariableAction variableAction = compiler.CreateVariableAction(VariableType.GlobalVariable);
							if (variableAction != null)
							{
								AddAction(variableAction);
							}
						}
						else if (Keywords.Equals(localName, input.Atoms.Param))
						{
							VariableAction variableAction2 = compiler.CreateVariableAction(VariableType.GlobalParameter);
							if (variableAction2 != null)
							{
								AddAction(variableAction2);
							}
						}
						else if (Keywords.Equals(localName, input.Atoms.Template))
						{
							compiler.AddTemplate(compiler.CreateTemplateAction());
						}
						else if (!compiler.ForwardCompatibility)
						{
							throw compiler.UnexpectedKeyword();
						}
						compiler.PopScope();
					}
					else if (namespaceURI == input.Atoms.MsXsltNamespace && localName == input.Atoms.Script)
					{
						AddScript(compiler);
					}
					else if (Keywords.Equals(namespaceURI, input.Atoms.Empty))
					{
						throw XsltException.Create("Xslt_NullNsAtTopLevel", input.Name);
					}
					break;
				}
				default:
					throw XsltException.Create("Xslt_InvalidContents", "stylesheet");
				case XPathNodeType.SignificantWhitespace:
				case XPathNodeType.Whitespace:
				case XPathNodeType.ProcessingInstruction:
				case XPathNodeType.Comment:
					break;
				}
			}
			while (compiler.Advance());
			compiler.ToParent();
		}

		protected void CompileTemplate(Compiler compiler)
		{
			do
			{
				CompileOnceTemplate(compiler);
			}
			while (compiler.Advance());
		}

		protected void CompileOnceTemplate(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			if (input.NodeType == XPathNodeType.Element)
			{
				string namespaceURI = input.NamespaceURI;
				if (Keywords.Equals(namespaceURI, input.Atoms.XsltNamespace))
				{
					compiler.PushNamespaceScope();
					CompileInstruction(compiler);
					compiler.PopScope();
					return;
				}
				compiler.PushLiteralScope();
				compiler.InsertExtensionNamespace();
				if (compiler.IsExtensionNamespace(namespaceURI))
				{
					AddAction(compiler.CreateNewInstructionAction());
				}
				else
				{
					CompileLiteral(compiler);
				}
				compiler.PopScope();
			}
			else
			{
				CompileLiteral(compiler);
			}
		}

		private void CompileInstruction(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			CompiledAction compiledAction = null;
			string localName = input.LocalName;
			if (Keywords.Equals(localName, input.Atoms.ApplyImports))
			{
				compiledAction = compiler.CreateApplyImportsAction();
			}
			else if (Keywords.Equals(localName, input.Atoms.ApplyTemplates))
			{
				compiledAction = compiler.CreateApplyTemplatesAction();
			}
			else if (Keywords.Equals(localName, input.Atoms.Attribute))
			{
				compiledAction = compiler.CreateAttributeAction();
			}
			else if (Keywords.Equals(localName, input.Atoms.CallTemplate))
			{
				compiledAction = compiler.CreateCallTemplateAction();
			}
			else if (Keywords.Equals(localName, input.Atoms.Choose))
			{
				compiledAction = compiler.CreateChooseAction();
			}
			else if (Keywords.Equals(localName, input.Atoms.Comment))
			{
				compiledAction = compiler.CreateCommentAction();
			}
			else if (Keywords.Equals(localName, input.Atoms.Copy))
			{
				compiledAction = compiler.CreateCopyAction();
			}
			else if (Keywords.Equals(localName, input.Atoms.CopyOf))
			{
				compiledAction = compiler.CreateCopyOfAction();
			}
			else if (Keywords.Equals(localName, input.Atoms.Element))
			{
				compiledAction = compiler.CreateElementAction();
			}
			else
			{
				if (Keywords.Equals(localName, input.Atoms.Fallback))
				{
					return;
				}
				if (Keywords.Equals(localName, input.Atoms.ForEach))
				{
					compiledAction = compiler.CreateForEachAction();
				}
				else if (Keywords.Equals(localName, input.Atoms.If))
				{
					compiledAction = compiler.CreateIfAction(IfAction.ConditionType.ConditionIf);
				}
				else if (Keywords.Equals(localName, input.Atoms.Message))
				{
					compiledAction = compiler.CreateMessageAction();
				}
				else if (Keywords.Equals(localName, input.Atoms.Number))
				{
					compiledAction = compiler.CreateNumberAction();
				}
				else if (Keywords.Equals(localName, input.Atoms.ProcessingInstruction))
				{
					compiledAction = compiler.CreateProcessingInstructionAction();
				}
				else if (Keywords.Equals(localName, input.Atoms.Text))
				{
					compiledAction = compiler.CreateTextAction();
				}
				else if (Keywords.Equals(localName, input.Atoms.ValueOf))
				{
					compiledAction = compiler.CreateValueOfAction();
				}
				else if (Keywords.Equals(localName, input.Atoms.Variable))
				{
					compiledAction = compiler.CreateVariableAction(VariableType.LocalVariable);
				}
				else
				{
					if (!compiler.ForwardCompatibility)
					{
						throw compiler.UnexpectedKeyword();
					}
					compiledAction = compiler.CreateNewInstructionAction();
				}
			}
			AddAction(compiledAction);
		}

		private void CompileLiteral(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			switch (input.NodeType)
			{
			case XPathNodeType.Element:
				AddEvent(compiler.CreateBeginEvent());
				CompileLiteralAttributesAndNamespaces(compiler);
				if (compiler.Recurse())
				{
					CompileTemplate(compiler);
					compiler.ToParent();
				}
				AddEvent(new EndEvent(XPathNodeType.Element));
				break;
			case XPathNodeType.Text:
			case XPathNodeType.SignificantWhitespace:
				AddEvent(compiler.CreateTextEvent());
				break;
			case XPathNodeType.Attribute:
			case XPathNodeType.Namespace:
			case XPathNodeType.Whitespace:
			case XPathNodeType.ProcessingInstruction:
			case XPathNodeType.Comment:
				break;
			}
		}

		private void CompileLiteralAttributesAndNamespaces(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			if (input.Navigator.MoveToAttribute("use-attribute-sets", input.Atoms.XsltNamespace))
			{
				AddAction(compiler.CreateUseAttributeSetsAction());
				input.Navigator.MoveToParent();
			}
			compiler.InsertExcludedNamespace();
			if (input.MoveToFirstNamespace())
			{
				do
				{
					string value = input.Value;
					if (!Keywords.Compare(value, input.Atoms.XsltNamespace) && !compiler.IsExcludedNamespace(value) && !compiler.IsExtensionNamespace(value) && !compiler.IsNamespaceAlias(value))
					{
						AddEvent(new NamespaceEvent(input));
					}
				}
				while (input.MoveToNextNamespace());
				input.ToParent();
			}
			if (!input.MoveToFirstAttribute())
			{
				return;
			}
			do
			{
				if (!Keywords.Equals(input.NamespaceURI, input.Atoms.XsltNamespace))
				{
					AddEvent(compiler.CreateBeginEvent());
					AddEvents(compiler.CompileAvt(input.Value));
					AddEvent(new EndEvent(XPathNodeType.Attribute));
				}
			}
			while (input.MoveToNextAttribute());
			input.ToParent();
		}

		private void CompileOutput(Compiler compiler)
		{
			compiler.RootAction.Output.Compile(compiler);
		}

		internal void AddAction(Action action)
		{
			if (containedActions == null)
			{
				containedActions = new ArrayList();
			}
			containedActions.Add(action);
			lastCopyCodeAction = null;
		}

		private void EnsureCopyCodeAction()
		{
			if (lastCopyCodeAction == null)
			{
				CopyCodeAction action = new CopyCodeAction();
				AddAction(action);
				lastCopyCodeAction = action;
			}
		}

		protected void AddEvent(Event copyEvent)
		{
			EnsureCopyCodeAction();
			lastCopyCodeAction.AddEvent(copyEvent);
		}

		protected void AddEvents(ArrayList copyEvents)
		{
			EnsureCopyCodeAction();
			lastCopyCodeAction.AddEvents(copyEvents);
		}

		private void AddScript(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			ScriptingLanguage lang = ScriptingLanguage.JScript;
			string text = null;
			if (input.MoveToFirstAttribute())
			{
				do
				{
					if (input.LocalName == input.Atoms.Language)
					{
						string value = input.Value;
						if (string.Compare(value, "jscript", StringComparison.OrdinalIgnoreCase) == 0 || string.Compare(value, "javascript", StringComparison.OrdinalIgnoreCase) == 0)
						{
							lang = ScriptingLanguage.JScript;
							continue;
						}
						if (string.Compare(value, "c#", StringComparison.OrdinalIgnoreCase) == 0 || string.Compare(value, "csharp", StringComparison.OrdinalIgnoreCase) == 0)
						{
							lang = ScriptingLanguage.CSharp;
							continue;
						}
						if (string.Compare(value, "vb", StringComparison.OrdinalIgnoreCase) != 0 && string.Compare(value, "visualbasic", StringComparison.OrdinalIgnoreCase) != 0)
						{
							throw XsltException.Create("Xslt_ScriptInvalidLanguage", value);
						}
						lang = ScriptingLanguage.VisualBasic;
					}
					else if (input.LocalName == input.Atoms.ImplementsPrefix)
					{
						if (!PrefixQName.ValidatePrefix(input.Value))
						{
							throw XsltException.Create("Xslt_InvalidAttrValue", input.LocalName, input.Value);
						}
						text = compiler.ResolveXmlNamespace(input.Value);
					}
				}
				while (input.MoveToNextAttribute());
				input.ToParent();
			}
			if (text == null)
			{
				throw XsltException.Create("Xslt_MissingAttribute", input.Atoms.ImplementsPrefix);
			}
			if (!input.Recurse() || input.NodeType != XPathNodeType.Text)
			{
				throw XsltException.Create("Xslt_ScriptEmpty");
			}
			compiler.AddScript(input.Value, lang, text, input.BaseURI, input.LineNumber);
			input.ToParent();
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			case 0:
				if (containedActions != null && containedActions.Count > 0)
				{
					processor.PushActionFrame(frame);
					frame.State = 1;
				}
				else
				{
					frame.Finished();
				}
				break;
			case 1:
				frame.Finished();
				break;
			}
		}

		internal Action GetAction(int actionIndex)
		{
			if (containedActions != null && actionIndex < containedActions.Count)
			{
				return (Action)containedActions[actionIndex];
			}
			return null;
		}

		internal void CheckDuplicateParams(XmlQualifiedName name)
		{
			if (containedActions == null)
			{
				return;
			}
			foreach (CompiledAction containedAction in containedActions)
			{
				if (containedAction is WithParamAction withParamAction && withParamAction.Name == name)
				{
					throw XsltException.Create("Xslt_DuplicateWithParam", name.ToString());
				}
			}
		}

		internal override void ReplaceNamespaceAlias(Compiler compiler)
		{
			if (containedActions != null)
			{
				_ = containedActions.Count;
				for (int i = 0; i < containedActions.Count; i++)
				{
					((Action)containedActions[i]).ReplaceNamespaceAlias(compiler);
				}
			}
		}
	}
	internal class ApplyTemplatesAction : ContainerAction
	{
		private const int ProcessedChildren = 2;

		private const int ProcessNextNode = 3;

		private const int PositionAdvanced = 4;

		private const int TemplateProcessed = 5;

		private int selectKey = -1;

		private XmlQualifiedName mode;

		private static ApplyTemplatesAction s_BuiltInRule = new ApplyTemplatesAction();

		internal static ApplyTemplatesAction BuiltInRule()
		{
			return s_BuiltInRule;
		}

		internal static ApplyTemplatesAction BuiltInRule(XmlQualifiedName mode)
		{
			if (!(mode == null) && !mode.IsEmpty)
			{
				return new ApplyTemplatesAction(mode);
			}
			return BuiltInRule();
		}

		internal ApplyTemplatesAction()
		{
		}

		private ApplyTemplatesAction(XmlQualifiedName mode)
		{
			this.mode = mode;
		}

		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			CompileContent(compiler);
		}

		internal override bool CompileAttribute(Compiler compiler)
		{
			string localName = compiler.Input.LocalName;
			string value = compiler.Input.Value;
			if (Keywords.Equals(localName, compiler.Atoms.Select))
			{
				selectKey = compiler.AddQuery(value);
			}
			else
			{
				if (!Keywords.Equals(localName, compiler.Atoms.Mode))
				{
					return false;
				}
				if (compiler.AllowBuiltInMode && value == "*")
				{
					mode = Compiler.BuiltInMode;
				}
				else
				{
					mode = compiler.CreateXPathQName(value);
				}
			}
			return true;
		}

		private void CompileContent(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			if (!compiler.Recurse())
			{
				return;
			}
			do
			{
				switch (input.NodeType)
				{
				case XPathNodeType.Element:
				{
					compiler.PushNamespaceScope();
					string namespaceURI = input.NamespaceURI;
					string localName = input.LocalName;
					if (Keywords.Equals(namespaceURI, input.Atoms.XsltNamespace))
					{
						if (Keywords.Equals(localName, input.Atoms.Sort))
						{
							AddAction(compiler.CreateSortAction());
						}
						else
						{
							if (!Keywords.Equals(localName, input.Atoms.WithParam))
							{
								throw compiler.UnexpectedKeyword();
							}
							WithParamAction withParamAction = compiler.CreateWithParamAction();
							CheckDuplicateParams(withParamAction.Name);
							AddAction(withParamAction);
						}
						compiler.PopScope();
						break;
					}
					throw compiler.UnexpectedKeyword();
				}
				default:
					throw XsltException.Create("Xslt_InvalidContents", "apply-templates");
				case XPathNodeType.SignificantWhitespace:
				case XPathNodeType.Whitespace:
				case XPathNodeType.ProcessingInstruction:
				case XPathNodeType.Comment:
					break;
				}
			}
			while (compiler.Advance());
			compiler.ToParent();
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			default:
				return;
			case 0:
				processor.ResetParams();
				processor.InitSortArray();
				if (containedActions != null && containedActions.Count > 0)
				{
					processor.PushActionFrame(frame);
					frame.State = 2;
					return;
				}
				goto case 2;
			case 2:
				if (selectKey == -1)
				{
					if (!frame.Node.HasChildren)
					{
						frame.Finished();
						return;
					}
					frame.InitNewNodeSet(frame.Node.SelectChildren(XPathNodeType.All));
				}
				else
				{
					frame.InitNewNodeSet(processor.StartQuery(frame.NodeSet, selectKey));
				}
				if (processor.SortArray.Count != 0)
				{
					frame.SortNewNodeSet(processor, processor.SortArray);
				}
				frame.State = 3;
				goto case 3;
			case 3:
				if (frame.NewNextNode(processor))
				{
					frame.State = 4;
					break;
				}
				frame.Finished();
				return;
			case 4:
				break;
			case 5:
				frame.State = 3;
				goto case 3;
			case 1:
				return;
			}
			processor.PushTemplateLookup(frame.NewNodeSet, mode, null);
			frame.State = 5;
		}
	}
	internal class AttributeAction : ContainerAction
	{
		private const int NameDone = 2;

		private Avt nameAvt;

		private Avt nsAvt;

		private InputScopeManager manager;

		private string name;

		private string nsUri;

		private PrefixQName qname;

		private static PrefixQName CreateAttributeQName(string name, string nsUri, InputScopeManager manager)
		{
			if (name == "xmlns")
			{
				return null;
			}
			if (nsUri == "http://www.w3.org/2000/xmlns/")
			{
				throw XsltException.Create("Xslt_ReservedNS", nsUri);
			}
			PrefixQName prefixQName = new PrefixQName();
			prefixQName.SetQName(name);
			prefixQName.Namespace = ((nsUri != null) ? nsUri : manager.ResolveXPathNamespace(prefixQName.Prefix));
			if (prefixQName.Prefix.StartsWith("xml", StringComparison.Ordinal))
			{
				if (prefixQName.Prefix.Length == 3)
				{
					if (!(prefixQName.Namespace == "http://www.w3.org/XML/1998/namespace") || (!(prefixQName.Name == "lang") && !(prefixQName.Name == "space")))
					{
						prefixQName.ClearPrefix();
					}
				}
				else if (prefixQName.Prefix == "xmlns")
				{
					if (prefixQName.Namespace == "http://www.w3.org/2000/xmlns/")
					{
						throw XsltException.Create("Xslt_InvalidPrefix", prefixQName.Prefix);
					}
					prefixQName.ClearPrefix();
				}
			}
			return prefixQName;
		}

		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			CheckRequiredAttribute(compiler, nameAvt, "name");
			name = CompiledAction.PrecalculateAvt(ref nameAvt);
			nsUri = CompiledAction.PrecalculateAvt(ref nsAvt);
			if (nameAvt == null && nsAvt == null)
			{
				if (name != "xmlns")
				{
					qname = CreateAttributeQName(name, nsUri, compiler.CloneScopeManager());
				}
			}
			else
			{
				manager = compiler.CloneScopeManager();
			}
			if (compiler.Recurse())
			{
				CompileTemplate(compiler);
				compiler.ToParent();
			}
		}

		internal override bool CompileAttribute(Compiler compiler)
		{
			string localName = compiler.Input.LocalName;
			string value = compiler.Input.Value;
			if (Keywords.Equals(localName, compiler.Atoms.Name))
			{
				nameAvt = Avt.CompileAvt(compiler, value);
			}
			else
			{
				if (!Keywords.Equals(localName, compiler.Atoms.Namespace))
				{
					return false;
				}
				nsAvt = Avt.CompileAvt(compiler, value);
			}
			return true;
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			case 0:
				if (qname != null)
				{
					frame.CalulatedName = qname;
				}
				else
				{
					frame.CalulatedName = CreateAttributeQName((nameAvt == null) ? name : nameAvt.Evaluate(processor, frame), (nsAvt == null) ? nsUri : nsAvt.Evaluate(processor, frame), manager);
					if (frame.CalulatedName == null)
					{
						frame.Finished();
						break;
					}
				}
				goto case 2;
			case 2:
			{
				PrefixQName calulatedName = frame.CalulatedName;
				if (!processor.BeginEvent(XPathNodeType.Attribute, calulatedName.Prefix, calulatedName.Name, calulatedName.Namespace, empty: false))
				{
					frame.State = 2;
					break;
				}
				processor.PushActionFrame(frame);
				frame.State = 1;
				break;
			}
			case 1:
				if (!processor.EndEvent(XPathNodeType.Attribute))
				{
					frame.State = 1;
				}
				else
				{
					frame.Finished();
				}
				break;
			}
		}
	}
	internal class AttributeSetAction : ContainerAction
	{
		internal XmlQualifiedName name;

		internal XmlQualifiedName Name => name;

		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			CheckRequiredAttribute(compiler, name, "name");
			CompileContent(compiler);
		}

		internal override bool CompileAttribute(Compiler compiler)
		{
			string localName = compiler.Input.LocalName;
			string value = compiler.Input.Value;
			if (Keywords.Equals(localName, compiler.Atoms.Name))
			{
				name = compiler.CreateXPathQName(value);
			}
			else
			{
				if (!Keywords.Equals(localName, compiler.Atoms.UseAttributeSets))
				{
					return false;
				}
				AddAction(compiler.CreateUseAttributeSetsAction());
			}
			return true;
		}

		private void CompileContent(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			if (!compiler.Recurse())
			{
				return;
			}
			do
			{
				switch (input.NodeType)
				{
				case XPathNodeType.Element:
				{
					compiler.PushNamespaceScope();
					string namespaceURI = input.NamespaceURI;
					string localName = input.LocalName;
					if (Keywords.Equals(namespaceURI, input.Atoms.XsltNamespace) && Keywords.Equals(localName, input.Atoms.Attribute))
					{
						AddAction(compiler.CreateAttributeAction());
						compiler.PopScope();
						break;
					}
					throw compiler.UnexpectedKeyword();
				}
				default:
					throw XsltException.Create("Xslt_InvalidContents", "attribute-set");
				case XPathNodeType.SignificantWhitespace:
				case XPathNodeType.Whitespace:
				case XPathNodeType.ProcessingInstruction:
				case XPathNodeType.Comment:
					break;
				}
			}
			while (compiler.Advance());
			compiler.ToParent();
		}

		internal void Merge(AttributeSetAction attributeAction)
		{
			int num = 0;
			Action action;
			while ((action = attributeAction.GetAction(num)) != null)
			{
				AddAction(action);
				num++;
			}
		}
	}
	internal sealed class Avt
	{
		private string constAvt;

		private TextEvent[] events;

		public bool IsConstant => events == null;

		private Avt(string constAvt)
		{
			this.constAvt = constAvt;
		}

		private Avt(ArrayList eventList)
		{
			events = new TextEvent[eventList.Count];
			for (int i = 0; i < eventList.Count; i++)
			{
				events[i] = (TextEvent)eventList[i];
			}
		}

		internal string Evaluate(Processor processor, ActionFrame frame)
		{
			if (IsConstant)
			{
				return constAvt;
			}
			StringBuilder sharedStringBuilder = processor.GetSharedStringBuilder();
			for (int i = 0; i < events.Length; i++)
			{
				sharedStringBuilder.Append(events[i].Evaluate(processor, frame));
			}
			processor.ReleaseSharedStringBuilder();
			return sharedStringBuilder.ToString();
		}

		internal static Avt CompileAvt(Compiler compiler, string avtText)
		{
			bool constant;
			ArrayList eventList = compiler.CompileAvt(avtText, out constant);
			if (!constant)
			{
				return new Avt(eventList);
			}
			return new Avt(avtText);
		}
	}
	internal abstract class Event
	{
		internal virtual DbgData DbgData => DbgData.Empty;

		public virtual void ReplaceNamespaceAlias(Compiler compiler)
		{
		}

		public abstract bool Output(Processor processor, ActionFrame frame);

		internal void OnInstructionExecute(Processor processor)
		{
			processor.OnInstructionExecute();
		}
	}
	internal class TextEvent : Event
	{
		private string text;

		protected TextEvent()
		{
		}

		public TextEvent(string text)
		{
			this.text = text;
		}

		public TextEvent(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			text = input.Value;
		}

		public override bool Output(Processor processor, ActionFrame frame)
		{
			return processor.TextEvent(text);
		}

		public virtual string Evaluate(Processor processor, ActionFrame frame)
		{
			return text;
		}
	}
	internal sealed class AvtEvent : TextEvent
	{
		private int key;

		public AvtEvent(int key)
		{
			this.key = key;
		}

		public override bool Output(Processor processor, ActionFrame frame)
		{
			return processor.TextEvent(processor.EvaluateString(frame, key));
		}

		public override string Evaluate(Processor processor, ActionFrame frame)
		{
			return processor.EvaluateString(frame, key);
		}
	}
	internal class BeginEvent : Event
	{
		private XPathNodeType nodeType;

		private string namespaceUri;

		private string name;

		private string prefix;

		private bool empty;

		private object htmlProps;

		public BeginEvent(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			nodeType = input.NodeType;
			namespaceUri = input.NamespaceURI;
			name = input.LocalName;
			prefix = input.Prefix;
			empty = input.IsEmptyTag;
			if (nodeType == XPathNodeType.Element)
			{
				htmlProps = HtmlElementProps.GetProps(name);
			}
			else if (nodeType == XPathNodeType.Attribute)
			{
				htmlProps = HtmlAttributeProps.GetProps(name);
			}
		}

		public override void ReplaceNamespaceAlias(Compiler compiler)
		{
			if (nodeType == XPathNodeType.Attribute && namespaceUri.Length == 0)
			{
				return;
			}
			NamespaceInfo namespaceInfo = compiler.FindNamespaceAlias(namespaceUri);
			if (namespaceInfo != null)
			{
				namespaceUri = namespaceInfo.nameSpace;
				if (namespaceInfo.prefix != null)
				{
					prefix = namespaceInfo.prefix;
				}
			}
		}

		public override bool Output(Processor processor, ActionFrame frame)
		{
			return processor.BeginEvent(nodeType, prefix, name, namespaceUri, empty, htmlProps, search: false);
		}
	}
	internal class BuilderInfo
	{
		private string name;

		private string localName;

		private string namespaceURI;

		private string prefix;

		private XmlNodeType nodeType;

		private int depth;

		private bool isEmptyTag;

		internal string[] TextInfo = new string[4];

		internal int TextInfoCount;

		internal bool search;

		internal HtmlElementProps htmlProps;

		internal HtmlAttributeProps htmlAttrProps;

		internal string Name
		{
			get
			{
				if (name == null)
				{
					string text = Prefix;
					string text2 = LocalName;
					if (text != null && 0 < text.Length)
					{
						if (text2.Length > 0)
						{
							name = text + ":" + text2;
						}
						else
						{
							name = text;
						}
					}
					else
					{
						name = text2;
					}
				}
				return name;
			}
		}

		internal string LocalName
		{
			get
			{
				return localName;
			}
			set
			{
				localName = value;
			}
		}

		internal string NamespaceURI
		{
			get
			{
				return namespaceURI;
			}
			set
			{
				namespaceURI = value;
			}
		}

		internal string Prefix
		{
			get
			{
				return prefix;
			}
			set
			{
				prefix = value;
			}
		}

		internal string Value
		{
			get
			{
				switch (TextInfoCount)
				{
				case 0:
					return string.Empty;
				case 1:
					return TextInfo[0];
				default:
				{
					int num = 0;
					for (int i = 0; i < TextInfoCount; i++)
					{
						string text = TextInfo[i];
						if (text != null)
						{
							num += text.Length;
						}
					}
					StringBuilder stringBuilder = new StringBuilder(num);
					for (int j = 0; j < TextInfoCount; j++)
					{
						string text2 = TextInfo[j];
						if (text2 != null)
						{
							stringBuilder.Append(text2);
						}
					}
					return stringBuilder.ToString();
				}
				}
			}
			set
			{
				TextInfoCount = 0;
				ValueAppend(value, disableEscaping: false);
			}
		}

		internal XmlNodeType NodeType
		{
			get
			{
				return nodeType;
			}
			set
			{
				nodeType = value;
			}
		}

		internal int Depth
		{
			get
			{
				return depth;
			}
			set
			{
				depth = value;
			}
		}

		internal bool IsEmptyTag
		{
			get
			{
				return isEmptyTag;
			}
			set
			{
				isEmptyTag = value;
			}
		}

		internal BuilderInfo()
		{
			Initialize(string.Empty, string.Empty, string.Empty);
		}

		internal void Initialize(string prefix, string name, string nspace)
		{
			this.prefix = prefix;
			localName = name;
			namespaceURI = nspace;
			this.name = null;
			htmlProps = null;
			htmlAttrProps = null;
			TextInfoCount = 0;
		}

		internal void Initialize(BuilderInfo src)
		{
			prefix = src.Prefix;
			localName = src.LocalName;
			namespaceURI = src.NamespaceURI;
			name = null;
			depth = src.Depth;
			nodeType = src.NodeType;
			htmlProps = src.htmlProps;
			htmlAttrProps = src.htmlAttrProps;
			TextInfoCount = 0;
			EnsureTextInfoSize(src.TextInfoCount);
			src.TextInfo.CopyTo(TextInfo, 0);
			TextInfoCount = src.TextInfoCount;
		}

		private void EnsureTextInfoSize(int newSize)
		{
			if (TextInfo.Length < newSize)
			{
				string[] array = new string[newSize * 2];
				Array.Copy(TextInfo, array, TextInfoCount);
				TextInfo = array;
			}
		}

		internal BuilderInfo Clone()
		{
			BuilderInfo builderInfo = new BuilderInfo();
			builderInfo.Initialize(this);
			return builderInfo;
		}

		internal void ValueAppend(string s, bool disableEscaping)
		{
			if (s != null && s.Length != 0)
			{
				EnsureTextInfoSize(TextInfoCount + ((!disableEscaping) ? 1 : 2));
				if (disableEscaping)
				{
					TextInfo[TextInfoCount++] = null;
				}
				TextInfo[TextInfoCount++] = s;
			}
		}
	}
	internal class CallTemplateAction : ContainerAction
	{
		private const int ProcessedChildren = 2;

		private const int ProcessedTemplate = 3;

		private XmlQualifiedName name;

		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			CheckRequiredAttribute(compiler, name, "name");
			CompileContent(compiler);
		}

		internal override bool CompileAttribute(Compiler compiler)
		{
			string localName = compiler.Input.LocalName;
			string value = compiler.Input.Value;
			if (Keywords.Equals(localName, compiler.Atoms.Name))
			{
				name = compiler.CreateXPathQName(value);
				return true;
			}
			return false;
		}

		private void CompileContent(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			if (!compiler.Recurse())
			{
				return;
			}
			do
			{
				switch (input.NodeType)
				{
				case XPathNodeType.Element:
				{
					compiler.PushNamespaceScope();
					string namespaceURI = input.NamespaceURI;
					string localName = input.LocalName;
					if (Keywords.Equals(namespaceURI, input.Atoms.XsltNamespace) && Keywords.Equals(localName, input.Atoms.WithParam))
					{
						WithParamAction withParamAction = compiler.CreateWithParamAction();
						CheckDuplicateParams(withParamAction.Name);
						AddAction(withParamAction);
						compiler.PopScope();
						break;
					}
					throw compiler.UnexpectedKeyword();
				}
				default:
					throw XsltException.Create("Xslt_InvalidContents", "call-template");
				case XPathNodeType.SignificantWhitespace:
				case XPathNodeType.Whitespace:
				case XPathNodeType.ProcessingInstruction:
				case XPathNodeType.Comment:
					break;
				}
			}
			while (compiler.Advance());
			compiler.ToParent();
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			case 0:
				processor.ResetParams();
				if (containedActions != null && containedActions.Count > 0)
				{
					processor.PushActionFrame(frame);
					frame.State = 2;
					break;
				}
				goto case 2;
			case 2:
			{
				TemplateAction templateAction = processor.Stylesheet.FindTemplate(name);
				if (templateAction != null)
				{
					frame.State = 3;
					processor.PushActionFrame(templateAction, frame.NodeSet);
					break;
				}
				throw XsltException.Create("Xslt_InvalidCallTemplate", name.ToString());
			}
			case 3:
				frame.Finished();
				break;
			case 1:
				break;
			}
		}
	}
	internal class ChooseAction : ContainerAction
	{
		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			if (compiler.Recurse())
			{
				CompileConditions(compiler);
				compiler.ToParent();
			}
		}

		private void CompileConditions(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			bool flag = false;
			bool flag2 = false;
			do
			{
				switch (input.NodeType)
				{
				case XPathNodeType.Element:
				{
					compiler.PushNamespaceScope();
					string namespaceURI = input.NamespaceURI;
					string localName = input.LocalName;
					if (Keywords.Equals(namespaceURI, input.Atoms.XsltNamespace))
					{
						IfAction ifAction = null;
						if (Keywords.Equals(localName, input.Atoms.When))
						{
							if (flag2)
							{
								throw XsltException.Create("Xslt_WhenAfterOtherwise");
							}
							ifAction = compiler.CreateIfAction(IfAction.ConditionType.ConditionWhen);
							flag = true;
						}
						else
						{
							if (!Keywords.Equals(localName, input.Atoms.Otherwise))
							{
								throw compiler.UnexpectedKeyword();
							}
							if (flag2)
							{
								throw XsltException.Create("Xslt_DupOtherwise");
							}
							ifAction = compiler.CreateIfAction(IfAction.ConditionType.ConditionOtherwise);
							flag2 = true;
						}
						AddAction(ifAction);
						compiler.PopScope();
						break;
					}
					throw compiler.UnexpectedKeyword();
				}
				default:
					throw XsltException.Create("Xslt_InvalidContents", "choose");
				case XPathNodeType.SignificantWhitespace:
				case XPathNodeType.Whitespace:
				case XPathNodeType.ProcessingInstruction:
				case XPathNodeType.Comment:
					break;
				}
			}
			while (compiler.Advance());
			if (!flag)
			{
				throw XsltException.Create("Xslt_NoWhen");
			}
		}
	}
	internal class CommentAction : ContainerAction
	{
		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			if (compiler.Recurse())
			{
				CompileTemplate(compiler);
				compiler.ToParent();
			}
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			case 0:
				if (processor.BeginEvent(XPathNodeType.Comment, string.Empty, string.Empty, string.Empty, empty: false))
				{
					processor.PushActionFrame(frame);
					frame.State = 1;
				}
				break;
			case 1:
				if (processor.EndEvent(XPathNodeType.Comment))
				{
					frame.Finished();
				}
				break;
			}
		}
	}
	internal class Sort
	{
		internal int select;

		internal string lang;

		internal XmlDataType dataType;

		internal XmlSortOrder order;

		internal XmlCaseOrder caseOrder;

		public Sort(int sortkey, string xmllang, XmlDataType datatype, XmlSortOrder xmlorder, XmlCaseOrder xmlcaseorder)
		{
			select = sortkey;
			lang = xmllang;
			dataType = datatype;
			order = xmlorder;
			caseOrder = xmlcaseorder;
		}
	}
	internal enum ScriptingLanguage
	{
		JScript,
		VisualBasic,
		CSharp
	}
	internal class Compiler
	{
		internal class ErrorXPathExpression : CompiledXpathExpr
		{
			private string baseUri;

			private int lineNumber;

			private int linePosition;

			public ErrorXPathExpression(string expression, string baseUri, int lineNumber, int linePosition)
				: base(null, expression, needContext: false)
			{
				this.baseUri = baseUri;
				this.lineNumber = lineNumber;
				this.linePosition = linePosition;
			}

			public override XPathExpression Clone()
			{
				return this;
			}

			public override void CheckErrors()
			{
				throw new XsltException("Xslt_InvalidXPath", new string[1] { Expression }, baseUri, linePosition, lineNumber, null);
			}
		}

		internal const int InvalidQueryKey = -1;

		internal const double RootPriority = 0.5;

		internal StringBuilder AvtStringBuilder = new StringBuilder();

		private int stylesheetid;

		private InputScope rootScope;

		private XmlResolver xmlResolver;

		private TemplateBaseAction currentTemplate;

		private XmlQualifiedName currentMode;

		private Hashtable globalNamespaceAliasTable;

		private Stack stylesheets;

		private HybridDictionary documentURIs = new HybridDictionary();

		private NavigatorInput input;

		private Keywords atoms;

		private InputScopeManager scopeManager;

		internal Stylesheet stylesheet;

		internal Stylesheet rootStylesheet;

		private RootAction rootAction;

		private List<TheQuery> queryStore;

		private QueryBuilder queryBuilder = new QueryBuilder();

		private int rtfCount;

		public bool AllowBuiltInMode;

		public static XmlQualifiedName BuiltInMode = new XmlQualifiedName("*", string.Empty);

		private Hashtable[] _typeDeclsByLang = new Hashtable[3]
		{
			new Hashtable(),
			new Hashtable(),
			new Hashtable()
		};

		private ArrayList scriptFiles = new ArrayList();

		private static string[] _defaultNamespaces = new string[7] { "System", "System.Collections", "System.Text", "System.Text.RegularExpressions", "System.Xml", "System.Xml.Xsl", "System.Xml.XPath" };

		private static int scriptClassCounter = 0;

		internal Keywords Atoms => atoms;

		internal int Stylesheetid
		{
			get
			{
				return stylesheetid;
			}
			set
			{
				stylesheetid = value;
			}
		}

		internal NavigatorInput Document => input;

		internal NavigatorInput Input => input;

		internal Stylesheet CompiledStylesheet => stylesheet;

		internal RootAction RootAction
		{
			get
			{
				return rootAction;
			}
			set
			{
				rootAction = value;
				currentTemplate = rootAction;
			}
		}

		internal List<TheQuery> QueryStore => queryStore;

		public virtual IXsltDebugger Debugger => null;

		internal bool ForwardCompatibility
		{
			get
			{
				return scopeManager.CurrentScope.ForwardCompatibility;
			}
			set
			{
				scopeManager.CurrentScope.ForwardCompatibility = value;
			}
		}

		internal bool CanHaveApplyImports
		{
			get
			{
				return scopeManager.CurrentScope.CanHaveApplyImports;
			}
			set
			{
				scopeManager.CurrentScope.CanHaveApplyImports = value;
			}
		}

		protected InputScopeManager ScopeManager => scopeManager;

		internal string DefaultNamespace => scopeManager.DefaultNamespace;

		internal XmlQualifiedName CurrentMode => currentMode;

		internal bool Advance()
		{
			return Document.Advance();
		}

		internal bool Recurse()
		{
			return Document.Recurse();
		}

		internal bool ToParent()
		{
			return Document.ToParent();
		}

		internal string GetUnicRtfId()
		{
			rtfCount++;
			return rtfCount.ToString(CultureInfo.InvariantCulture);
		}

		internal void Compile(NavigatorInput input, XmlResolver xmlResolver, Evidence evidence)
		{
			this.xmlResolver = xmlResolver;
			PushInputDocument(input);
			rootScope = scopeManager.PushScope();
			queryStore = new List<TheQuery>();
			try
			{
				rootStylesheet = new Stylesheet();
				PushStylesheet(rootStylesheet);
				try
				{
					CreateRootAction();
				}
				catch (XsltCompileException)
				{
					throw;
				}
				catch (Exception inner)
				{
					throw new XsltCompileException(inner, Input.BaseURI, Input.LineNumber, Input.LinePosition);
				}
				stylesheet.ProcessTemplates();
				rootAction.PorcessAttributeSets(rootStylesheet);
				stylesheet.SortWhiteSpace();
				CompileScript(evidence);
				if (evidence != null)
				{
					rootAction.permissions = SecurityManager.ResolvePolicy(evidence);
				}
				if (globalNamespaceAliasTable != null)
				{
					stylesheet.ReplaceNamespaceAlias(this);
					rootAction.ReplaceNamespaceAlias(this);
				}
			}
			finally
			{
				PopInputDocument();
			}
		}

		internal void InsertExtensionNamespace(string value)
		{
			string[] array = ResolvePrefixes(value);
			if (array != null)
			{
				scopeManager.InsertExtensionNamespaces(array);
			}
		}

		internal void InsertExcludedNamespace(string value)
		{
			string[] array = ResolvePrefixes(value);
			if (array != null)
			{
				scopeManager.InsertExcludedNamespaces(array);
			}
		}

		internal void InsertExtensionNamespace()
		{
			InsertExtensionNamespace(Input.Navigator.GetAttribute(Input.Atoms.ExtensionElementPrefixes, Input.Atoms.XsltNamespace));
		}

		internal void InsertExcludedNamespace()
		{
			InsertExcludedNamespace(Input.Navigator.GetAttribute(Input.Atoms.ExcludeResultPrefixes, Input.Atoms.XsltNamespace));
		}

		internal bool IsExtensionNamespace(string nspace)
		{
			return scopeManager.IsExtensionNamespace(nspace);
		}

		internal bool IsExcludedNamespace(string nspace)
		{
			return scopeManager.IsExcludedNamespace(nspace);
		}

		internal void PushLiteralScope()
		{
			PushNamespaceScope();
			string attribute = Input.Navigator.GetAttribute(Atoms.Version, Atoms.XsltNamespace);
			if (attribute.Length != 0)
			{
				ForwardCompatibility = attribute != "1.0";
			}
		}

		internal void PushNamespaceScope()
		{
			scopeManager.PushScope();
			NavigatorInput navigatorInput = Input;
			if (navigatorInput.MoveToFirstNamespace())
			{
				do
				{
					scopeManager.PushNamespace(navigatorInput.LocalName, navigatorInput.Value);
				}
				while (navigatorInput.MoveToNextNamespace());
				navigatorInput.ToParent();
			}
		}

		internal virtual void PopScope()
		{
			currentTemplate.ReleaseVariableSlots(scopeManager.CurrentScope.GetVeriablesCount());
			scopeManager.PopScope();
		}

		internal InputScopeManager CloneScopeManager()
		{
			return scopeManager.Clone();
		}

		internal int InsertVariable(VariableAction variable)
		{
			InputScope inputScope = ((!variable.IsGlobal) ? scopeManager.VariableScope : rootScope);
			VariableAction variableAction = inputScope.ResolveVariable(variable.Name);
			if (variableAction != null)
			{
				if (!variableAction.IsGlobal)
				{
					throw XsltException.Create("Xslt_DupVarName", variable.NameStr);
				}
				if (variable.IsGlobal)
				{
					if (variable.Stylesheetid == variableAction.Stylesheetid)
					{
						throw XsltException.Create("Xslt_DupVarName", variable.NameStr);
					}
					if (variable.Stylesheetid < variableAction.Stylesheetid)
					{
						inputScope.InsertVariable(variable);
						return variableAction.VarKey;
					}
					return -1;
				}
			}
			inputScope.InsertVariable(variable);
			return currentTemplate.AllocateVariableSlot();
		}

		internal void AddNamespaceAlias(string StylesheetURI, NamespaceInfo AliasInfo)
		{
			if (globalNamespaceAliasTable == null)
			{
				globalNamespaceAliasTable = new Hashtable();
			}
			if (!(globalNamespaceAliasTable[StylesheetURI] is NamespaceInfo namespaceInfo) || AliasInfo.stylesheetId <= namespaceInfo.stylesheetId)
			{
				globalNamespaceAliasTable[StylesheetURI] = AliasInfo;
			}
		}

		internal bool IsNamespaceAlias(string StylesheetURI)
		{
			if (globalNamespaceAliasTable == null)
			{
				return false;
			}
			return globalNamespaceAliasTable.Contains(StylesheetURI);
		}

		internal NamespaceInfo FindNamespaceAlias(string StylesheetURI)
		{
			if (globalNamespaceAliasTable != null)
			{
				return (NamespaceInfo)globalNamespaceAliasTable[StylesheetURI];
			}
			return null;
		}

		internal string ResolveXmlNamespace(string prefix)
		{
			return scopeManager.ResolveXmlNamespace(prefix);
		}

		internal string ResolveXPathNamespace(string prefix)
		{
			return scopeManager.ResolveXPathNamespace(prefix);
		}

		internal void InsertKey(XmlQualifiedName name, int MatchKey, int UseKey)
		{
			rootAction.InsertKey(name, MatchKey, UseKey);
		}

		internal void AddDecimalFormat(XmlQualifiedName name, DecimalFormat formatinfo)
		{
			rootAction.AddDecimalFormat(name, formatinfo);
		}

		private string[] ResolvePrefixes(string tokens)
		{
			if (tokens == null || tokens.Length == 0)
			{
				return null;
			}
			string[] array = XmlConvert.SplitString(tokens);
			try
			{
				for (int i = 0; i < array.Length; i++)
				{
					string text = array[i];
					array[i] = scopeManager.ResolveXmlNamespace((text == "#default") ? string.Empty : text);
				}
				return array;
			}
			catch (XsltException)
			{
				if (!ForwardCompatibility)
				{
					throw;
				}
				return null;
			}
		}

		internal bool GetYesNo(string value)
		{
			if (value.Equals(Atoms.Yes))
			{
				return true;
			}
			if (value.Equals(Atoms.No))
			{
				return false;
			}
			throw XsltException.Create("Xslt_InvalidAttrValue", Input.LocalName, value);
		}

		internal string GetSingleAttribute(string attributeAtom)
		{
			NavigatorInput navigatorInput = Input;
			string localName = navigatorInput.LocalName;
			string text = null;
			if (navigatorInput.MoveToFirstAttribute())
			{
				do
				{
					string namespaceURI = navigatorInput.NamespaceURI;
					string localName2 = navigatorInput.LocalName;
					if (Keywords.Equals(namespaceURI, Atoms.Empty))
					{
						if (Keywords.Equals(localName2, attributeAtom))
						{
							text = navigatorInput.Value;
						}
						else if (!ForwardCompatibility)
						{
							throw XsltException.Create("Xslt_InvalidAttribute", localName2, localName);
						}
					}
				}
				while (navigatorInput.MoveToNextAttribute());
				navigatorInput.ToParent();
			}
			if (text == null)
			{
				throw XsltException.Create("Xslt_MissingAttribute", attributeAtom);
			}
			return text;
		}

		internal XmlQualifiedName CreateXPathQName(string qname)
		{
			PrefixQName.ParseQualifiedName(qname, out var prefix, out var local);
			return new XmlQualifiedName(local, scopeManager.ResolveXPathNamespace(prefix));
		}

		internal XmlQualifiedName CreateXmlQName(string qname)
		{
			PrefixQName.ParseQualifiedName(qname, out var prefix, out var local);
			return new XmlQualifiedName(local, scopeManager.ResolveXmlNamespace(prefix));
		}

		internal static XPathDocument LoadDocument(XmlTextReaderImpl reader)
		{
			reader.EntityHandling = EntityHandling.ExpandEntities;
			reader.XmlValidatingReaderCompatibilityMode = true;
			try
			{
				return new XPathDocument(reader, XmlSpace.Preserve);
			}
			finally
			{
				reader.Close();
			}
		}

		private void AddDocumentURI(string href)
		{
			documentURIs.Add(href, null);
		}

		private void RemoveDocumentURI(string href)
		{
			documentURIs.Remove(href);
		}

		internal bool IsCircularReference(string href)
		{
			return documentURIs.Contains(href);
		}

		internal Uri ResolveUri(string relativeUri)
		{
			string baseURI = Input.BaseURI;
			Uri uri = xmlResolver.ResolveUri((baseURI.Length != 0) ? xmlResolver.ResolveUri(null, baseURI) : null, relativeUri);
			if (uri == null)
			{
				throw XsltException.Create("Xslt_CantResolve", relativeUri);
			}
			return uri;
		}

		internal NavigatorInput ResolveDocument(Uri absoluteUri)
		{
			object entity = xmlResolver.GetEntity(absoluteUri, null, null);
			string text = absoluteUri.ToString();
			if (entity is Stream)
			{
				XmlTextReaderImpl xmlTextReaderImpl = new XmlTextReaderImpl(text, (Stream)entity);
				xmlTextReaderImpl.XmlResolver = xmlResolver;
				return new NavigatorInput(LoadDocument(xmlTextReaderImpl).CreateNavigator(), text, rootScope);
			}
			if (entity is XPathNavigator)
			{
				return new NavigatorInput((XPathNavigator)entity, text, rootScope);
			}
			throw XsltException.Create("Xslt_CantResolve", text);
		}

		internal void PushInputDocument(NavigatorInput newInput)
		{
			string href = newInput.Href;
			AddDocumentURI(href);
			newInput.Next = input;
			input = newInput;
			atoms = input.Atoms;
			scopeManager = input.InputScopeManager;
		}

		internal void PopInputDocument()
		{
			NavigatorInput navigatorInput = input;
			input = navigatorInput.Next;
			navigatorInput.Next = null;
			if (input != null)
			{
				atoms = input.Atoms;
				scopeManager = input.InputScopeManager;
			}
			else
			{
				atoms = null;
				scopeManager = null;
			}
			RemoveDocumentURI(navigatorInput.Href);
			navigatorInput.Close();
		}

		internal void PushStylesheet(Stylesheet stylesheet)
		{
			if (stylesheets == null)
			{
				stylesheets = new Stack();
			}
			stylesheets.Push(stylesheet);
			this.stylesheet = stylesheet;
		}

		internal Stylesheet PopStylesheet()
		{
			Stylesheet result = (Stylesheet)stylesheets.Pop();
			stylesheet = (Stylesheet)stylesheets.Peek();
			return result;
		}

		internal void AddAttributeSet(AttributeSetAction attributeSet)
		{
			stylesheet.AddAttributeSet(attributeSet);
		}

		internal void AddTemplate(TemplateAction template)
		{
			stylesheet.AddTemplate(template);
		}

		internal void BeginTemplate(TemplateAction template)
		{
			currentTemplate = template;
			currentMode = template.Mode;
			CanHaveApplyImports = template.MatchKey != -1;
		}

		internal void EndTemplate()
		{
			currentTemplate = rootAction;
		}

		internal int AddQuery(string xpathQuery)
		{
			return AddQuery(xpathQuery, allowVar: true, allowKey: true, isPattern: false);
		}

		internal int AddQuery(string xpathQuery, bool allowVar, bool allowKey, bool isPattern)
		{
			CompiledXpathExpr compiledQuery;
			try
			{
				compiledQuery = new CompiledXpathExpr(isPattern ? queryBuilder.BuildPatternQuery(xpathQuery, allowVar, allowKey) : queryBuilder.Build(xpathQuery, allowVar, allowKey), xpathQuery, needContext: false);
			}
			catch (XPathException inner)
			{
				if (!ForwardCompatibility)
				{
					throw XsltException.Create("Xslt_InvalidXPath", new string[1] { xpathQuery }, inner);
				}
				compiledQuery = new ErrorXPathExpression(xpathQuery, Input.BaseURI, Input.LineNumber, Input.LinePosition);
			}
			queryStore.Add(new TheQuery(compiledQuery, scopeManager));
			return queryStore.Count - 1;
		}

		internal int AddStringQuery(string xpathQuery)
		{
			string xpathQuery2 = (XmlCharType.Instance.IsOnlyWhitespace(xpathQuery) ? xpathQuery : ("string(" + xpathQuery + ")"));
			return AddQuery(xpathQuery2);
		}

		internal int AddBooleanQuery(string xpathQuery)
		{
			string xpathQuery2 = (XmlCharType.Instance.IsOnlyWhitespace(xpathQuery) ? xpathQuery : ("boolean(" + xpathQuery + ")"));
			return AddQuery(xpathQuery2);
		}

		private static string GenerateUniqueClassName()
		{
			return "ScriptClass_" + ++scriptClassCounter;
		}

		internal void AddScript(string source, ScriptingLanguage lang, string ns, string fileName, int lineNumber)
		{
			ValidateExtensionNamespace(ns);
			for (ScriptingLanguage scriptingLanguage = ScriptingLanguage.JScript; scriptingLanguage <= ScriptingLanguage.CSharp; scriptingLanguage++)
			{
				Hashtable hashtable = _typeDeclsByLang[(int)scriptingLanguage];
				if (lang == scriptingLanguage)
				{
					CodeTypeDeclaration codeTypeDeclaration = (CodeTypeDeclaration)hashtable[ns];
					if (codeTypeDeclaration == null)
					{
						codeTypeDeclaration = new CodeTypeDeclaration(GenerateUniqueClassName());
						codeTypeDeclaration.TypeAttributes = TypeAttributes.Public;
						hashtable.Add(ns, codeTypeDeclaration);
					}
					CodeSnippetTypeMember codeSnippetTypeMember = new CodeSnippetTypeMember(source);
					if (lineNumber > 0)
					{
						codeSnippetTypeMember.LinePragma = new CodeLinePragma(fileName, lineNumber);
						scriptFiles.Add(fileName);
					}
					codeTypeDeclaration.Members.Add(codeSnippetTypeMember);
				}
				else if (hashtable.Contains(ns))
				{
					throw XsltException.Create("Xslt_ScriptMixedLanguages", ns);
				}
			}
		}

		private static void ValidateExtensionNamespace(string nsUri)
		{
			if (nsUri.Length == 0 || nsUri == "http://www.w3.org/1999/XSL/Transform")
			{
				throw XsltException.Create("Xslt_InvalidExtensionNamespace");
			}
			XmlConvert.ToUri(nsUri);
		}

		private void FixCompilerError(CompilerError e)
		{
			foreach (string scriptFile in scriptFiles)
			{
				if (e.FileName == scriptFile)
				{
					return;
				}
			}
			e.FileName = string.Empty;
		}

		private CodeDomProvider ChooseCodeDomProvider(ScriptingLanguage lang)
		{
			return lang switch
			{
				ScriptingLanguage.VisualBasic => new VBCodeProvider(), 
				ScriptingLanguage.JScript => (CodeDomProvider)Activator.CreateInstance(Type.GetType("Microsoft.JScript.JScriptCodeProvider, Microsoft.JScript, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"), BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance, null, null, null), 
				_ => new CSharpCodeProvider(), 
			};
		}

		private void CompileScript(Evidence evidence)
		{
			for (ScriptingLanguage scriptingLanguage = ScriptingLanguage.JScript; scriptingLanguage <= ScriptingLanguage.CSharp; scriptingLanguage++)
			{
				int num = (int)scriptingLanguage;
				if (_typeDeclsByLang[num].Count > 0)
				{
					CompileAssembly(scriptingLanguage, _typeDeclsByLang[num], scriptingLanguage.ToString(), evidence);
				}
			}
		}

		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		private void CompileAssembly(ScriptingLanguage lang, Hashtable typeDecls, string nsName, Evidence evidence)
		{
			nsName = "Microsoft.Xslt.CompiledScripts." + nsName;
			CodeNamespace codeNamespace = new CodeNamespace(nsName);
			string[] defaultNamespaces = _defaultNamespaces;
			foreach (string nameSpace in defaultNamespaces)
			{
				codeNamespace.Imports.Add(new CodeNamespaceImport(nameSpace));
			}
			if (lang == ScriptingLanguage.VisualBasic)
			{
				codeNamespace.Imports.Add(new CodeNamespaceImport("Microsoft.VisualBasic"));
			}
			foreach (CodeTypeDeclaration value in typeDecls.Values)
			{
				codeNamespace.Types.Add(value);
			}
			CodeCompileUnit codeCompileUnit = new CodeCompileUnit();
			codeCompileUnit.Namespaces.Add(codeNamespace);
			codeCompileUnit.UserData["AllowLateBound"] = true;
			codeCompileUnit.UserData["RequireVariableDeclaration"] = false;
			CompilerParameters compilerParameters = new CompilerParameters();
			try
			{
				new SecurityPermission(SecurityPermissionFlag.ControlEvidence).Assert();
				try
				{
					compilerParameters.GenerateInMemory = true;
					compilerParameters.Evidence = evidence;
					compilerParameters.ReferencedAssemblies.Add(typeof(XPathNavigator).Module.FullyQualifiedName);
					compilerParameters.ReferencedAssemblies.Add("system.dll");
					if (lang == ScriptingLanguage.VisualBasic)
					{
						compilerParameters.ReferencedAssemblies.Add("microsoft.visualbasic.dll");
					}
				}
				finally
				{
					CodeAccessPermission.RevertAssert();
				}
			}
			catch
			{
				throw;
			}
			CompilerResults compilerResults = ChooseCodeDomProvider(lang).CompileAssemblyFromDom(compilerParameters, codeCompileUnit);
			if (compilerResults.Errors.HasErrors)
			{
				StringWriter stringWriter = new StringWriter(CultureInfo.InvariantCulture);
				foreach (CompilerError error in compilerResults.Errors)
				{
					FixCompilerError(error);
					stringWriter.WriteLine(error.ToString());
				}
				throw XsltException.Create("Xslt_ScriptCompileErrors", stringWriter.ToString());
			}
			Assembly compiledAssembly = compilerResults.CompiledAssembly;
			foreach (DictionaryEntry typeDecl in typeDecls)
			{
				string key = (string)typeDecl.Key;
				CodeTypeDeclaration codeTypeDeclaration = (CodeTypeDeclaration)typeDecl.Value;
				stylesheet.ScriptObjectTypes.Add(key, compiledAssembly.GetType(nsName + "." + codeTypeDeclaration.Name));
			}
		}

		public string GetNsAlias(ref string prefix)
		{
			if (Keywords.Compare(input.Atoms.HashDefault, prefix))
			{
				prefix = string.Empty;
				return DefaultNamespace;
			}
			if (!PrefixQName.ValidatePrefix(prefix))
			{
				throw XsltException.Create("Xslt_InvalidAttrValue", input.LocalName, prefix);
			}
			return ResolveXPathNamespace(prefix);
		}

		private static void getTextLex(string avt, ref int start, StringBuilder lex)
		{
			int length = avt.Length;
			int i;
			char c;
			for (i = start; i < length; lex.Append(c), i++)
			{
				c = avt[i];
				switch (c)
				{
				case '{':
					if (i + 1 < length && avt[i + 1] == '{')
					{
						i++;
						continue;
					}
					break;
				case '}':
					if (i + 1 < length && avt[i + 1] == '}')
					{
						i++;
						continue;
					}
					throw XsltException.Create("Xslt_SingleRightAvt", avt);
				default:
					continue;
				}
				break;
			}
			start = i;
		}

		private static void getXPathLex(string avt, ref int start, StringBuilder lex)
		{
			int length = avt.Length;
			int num = 0;
			for (int i = start + 1; i < length; i++)
			{
				char c = avt[i];
				switch (num)
				{
				case 0:
					switch (c)
					{
					case '{':
						throw XsltException.Create("Xslt_NestedAvt", avt);
					case '}':
						i++;
						if (i == start + 2)
						{
							throw XsltException.Create("Xslt_EmptyAvtExpr", avt);
						}
						lex.Append(avt, start + 1, i - start - 2);
						start = i;
						return;
					case '\'':
						num = 1;
						break;
					case '"':
						num = 2;
						break;
					}
					break;
				case 1:
					if (c == '\'')
					{
						num = 0;
					}
					break;
				case 2:
					if (c == '"')
					{
						num = 0;
					}
					break;
				}
			}
			throw XsltException.Create((num == 0) ? "Xslt_OpenBracesAvt" : "Xslt_OpenLiteralAvt", avt);
		}

		private static bool GetNextAvtLex(string avt, ref int start, StringBuilder lex, out bool isAvt)
		{
			isAvt = false;
			if (start == avt.Length)
			{
				return false;
			}
			lex.Length = 0;
			getTextLex(avt, ref start, lex);
			if (lex.Length == 0)
			{
				isAvt = true;
				getXPathLex(avt, ref start, lex);
			}
			return true;
		}

		internal ArrayList CompileAvt(string avtText, out bool constant)
		{
			ArrayList arrayList = new ArrayList();
			constant = true;
			int start = 0;
			bool isAvt;
			while (GetNextAvtLex(avtText, ref start, AvtStringBuilder, out isAvt))
			{
				string text = AvtStringBuilder.ToString();
				if (isAvt)
				{
					arrayList.Add(new AvtEvent(AddStringQuery(text)));
					constant = false;
				}
				else
				{
					arrayList.Add(new TextEvent(text));
				}
			}
			return arrayList;
		}

		internal ArrayList CompileAvt(string avtText)
		{
			bool constant;
			return CompileAvt(avtText, out constant);
		}

		public virtual ApplyImportsAction CreateApplyImportsAction()
		{
			ApplyImportsAction applyImportsAction = new ApplyImportsAction();
			applyImportsAction.Compile(this);
			return applyImportsAction;
		}

		public virtual ApplyTemplatesAction CreateApplyTemplatesAction()
		{
			ApplyTemplatesAction applyTemplatesAction = new ApplyTemplatesAction();
			applyTemplatesAction.Compile(this);
			return applyTemplatesAction;
		}

		public virtual AttributeAction CreateAttributeAction()
		{
			AttributeAction attributeAction = new AttributeAction();
			attributeAction.Compile(this);
			return attributeAction;
		}

		public virtual AttributeSetAction CreateAttributeSetAction()
		{
			AttributeSetAction attributeSetAction = new AttributeSetAction();
			attributeSetAction.Compile(this);
			return attributeSetAction;
		}

		public virtual CallTemplateAction CreateCallTemplateAction()
		{
			CallTemplateAction callTemplateAction = new CallTemplateAction();
			callTemplateAction.Compile(this);
			return callTemplateAction;
		}

		public virtual ChooseAction CreateChooseAction()
		{
			ChooseAction chooseAction = new ChooseAction();
			chooseAction.Compile(this);
			return chooseAction;
		}

		public virtual CommentAction CreateCommentAction()
		{
			CommentAction commentAction = new CommentAction();
			commentAction.Compile(this);
			return commentAction;
		}

		public virtual CopyAction CreateCopyAction()
		{
			CopyAction copyAction = new CopyAction();
			copyAction.Compile(this);
			return copyAction;
		}

		public virtual CopyOfAction CreateCopyOfAction()
		{
			CopyOfAction copyOfAction = new CopyOfAction();
			copyOfAction.Compile(this);
			return copyOfAction;
		}

		public virtual ElementAction CreateElementAction()
		{
			ElementAction elementAction = new ElementAction();
			elementAction.Compile(this);
			return elementAction;
		}

		public virtual ForEachAction CreateForEachAction()
		{
			ForEachAction forEachAction = new ForEachAction();
			forEachAction.Compile(this);
			return forEachAction;
		}

		public virtual IfAction CreateIfAction(IfAction.ConditionType type)
		{
			IfAction ifAction = new IfAction(type);
			ifAction.Compile(this);
			return ifAction;
		}

		public virtual MessageAction CreateMessageAction()
		{
			MessageAction messageAction = new MessageAction();
			messageAction.Compile(this);
			return messageAction;
		}

		public virtual NewInstructionAction CreateNewInstructionAction()
		{
			NewInstructionAction newInstructionAction = new NewInstructionAction();
			newInstructionAction.Compile(this);
			return newInstructionAction;
		}

		public virtual NumberAction CreateNumberAction()
		{
			NumberAction numberAction = new NumberAction();
			numberAction.Compile(this);
			return numberAction;
		}

		public virtual ProcessingInstructionAction CreateProcessingInstructionAction()
		{
			ProcessingInstructionAction processingInstructionAction = new ProcessingInstructionAction();
			processingInstructionAction.Compile(this);
			return processingInstructionAction;
		}

		public virtual void CreateRootAction()
		{
			RootAction = new RootAction();
			RootAction.Compile(this);
		}

		public virtual SortAction CreateSortAction()
		{
			SortAction sortAction = new SortAction();
			sortAction.Compile(this);
			return sortAction;
		}

		public virtual TemplateAction CreateTemplateAction()
		{
			TemplateAction templateAction = new TemplateAction();
			templateAction.Compile(this);
			return templateAction;
		}

		public virtual TemplateAction CreateSingleTemplateAction()
		{
			TemplateAction templateAction = new TemplateAction();
			templateAction.CompileSingle(this);
			return templateAction;
		}

		public virtual TextAction CreateTextAction()
		{
			TextAction textAction = new TextAction();
			textAction.Compile(this);
			return textAction;
		}

		public virtual UseAttributeSetsAction CreateUseAttributeSetsAction()
		{
			UseAttributeSetsAction useAttributeSetsAction = new UseAttributeSetsAction();
			useAttributeSetsAction.Compile(this);
			return useAttributeSetsAction;
		}

		public virtual ValueOfAction CreateValueOfAction()
		{
			ValueOfAction valueOfAction = new ValueOfAction();
			valueOfAction.Compile(this);
			return valueOfAction;
		}

		public virtual VariableAction CreateVariableAction(VariableType type)
		{
			VariableAction variableAction = new VariableAction(type);
			variableAction.Compile(this);
			if (variableAction.VarKey != -1)
			{
				return variableAction;
			}
			return null;
		}

		public virtual WithParamAction CreateWithParamAction()
		{
			WithParamAction withParamAction = new WithParamAction();
			withParamAction.Compile(this);
			return withParamAction;
		}

		public virtual BeginEvent CreateBeginEvent()
		{
			return new BeginEvent(this);
		}

		public virtual TextEvent CreateTextEvent()
		{
			return new TextEvent(this);
		}

		public XsltException UnexpectedKeyword()
		{
			XPathNavigator xPathNavigator = Input.Navigator.Clone();
			string name = xPathNavigator.Name;
			xPathNavigator.MoveToParent();
			string name2 = xPathNavigator.Name;
			return XsltException.Create("Xslt_UnexpectedKeyword", name, name2);
		}
	}
	internal class NamespaceInfo
	{
		internal string prefix;

		internal string nameSpace;

		internal int stylesheetId;

		internal NamespaceInfo(string prefix, string nameSpace, int stylesheetId)
		{
			this.prefix = prefix;
			this.nameSpace = nameSpace;
			this.stylesheetId = stylesheetId;
		}
	}
	internal class CopyAction : ContainerAction
	{
		private const int CopyText = 4;

		private const int NamespaceCopy = 5;

		private const int ContentsCopy = 6;

		private const int ProcessChildren = 7;

		private const int ChildrenOnly = 8;

		private string useAttributeSets;

		private bool empty;

		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			if (compiler.Recurse())
			{
				CompileTemplate(compiler);
				compiler.ToParent();
			}
			if (containedActions == null)
			{
				empty = true;
			}
		}

		internal override bool CompileAttribute(Compiler compiler)
		{
			string localName = compiler.Input.LocalName;
			string value = compiler.Input.Value;
			if (Keywords.Equals(localName, compiler.Atoms.UseAttributeSets))
			{
				useAttributeSets = value;
				AddAction(compiler.CreateUseAttributeSetsAction());
				return true;
			}
			return false;
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			while (processor.CanContinue)
			{
				switch (frame.State)
				{
				default:
					return;
				case 0:
					if (Processor.IsRoot(frame.Node))
					{
						processor.PushActionFrame(frame);
						frame.State = 8;
						return;
					}
					if (!processor.CopyBeginEvent(frame.Node, empty))
					{
						return;
					}
					frame.State = 5;
					break;
				case 5:
					frame.State = 6;
					if (frame.Node.NodeType == XPathNodeType.Element)
					{
						processor.PushActionFrame(CopyNamespacesAction.GetAction(), frame.NodeSet);
						return;
					}
					break;
				case 6:
					if (frame.Node.NodeType == XPathNodeType.Element && !empty)
					{
						processor.PushActionFrame(frame);
						frame.State = 7;
						return;
					}
					if (processor.CopyTextEvent(frame.Node))
					{
						frame.State = 7;
						break;
					}
					return;
				case 7:
					if (processor.CopyEndEvent(frame.Node))
					{
						frame.Finished();
					}
					return;
				case 8:
					frame.Finished();
					return;
				case 1:
				case 2:
				case 3:
				case 4:
					return;
				}
			}
		}
	}
	internal sealed class CopyAttributesAction : Action
	{
		private const int BeginEvent = 2;

		private const int TextEvent = 3;

		private const int EndEvent = 4;

		private const int Advance = 5;

		private static CopyAttributesAction s_Action = new CopyAttributesAction();

		internal static CopyAttributesAction GetAction()
		{
			return s_Action;
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			while (processor.CanContinue)
			{
				switch (frame.State)
				{
				default:
					return;
				case 0:
					if (!frame.Node.HasAttributes || !frame.Node.MoveToFirstAttribute())
					{
						frame.Finished();
						return;
					}
					frame.State = 2;
					goto case 2;
				case 2:
					if (!SendBeginEvent(processor, frame.Node))
					{
						return;
					}
					frame.State = 3;
					break;
				case 3:
					if (!SendTextEvent(processor, frame.Node))
					{
						return;
					}
					frame.State = 4;
					break;
				case 4:
					if (!SendEndEvent(processor, frame.Node))
					{
						return;
					}
					frame.State = 5;
					break;
				case 5:
					if (frame.Node.MoveToNextAttribute())
					{
						frame.State = 2;
						break;
					}
					frame.Node.MoveToParent();
					frame.Finished();
					return;
				case 1:
					return;
				}
			}
		}

		private static bool SendBeginEvent(Processor processor, XPathNavigator node)
		{
			return processor.BeginEvent(XPathNodeType.Attribute, node.Prefix, node.LocalName, node.NamespaceURI, empty: false);
		}

		private static bool SendTextEvent(Processor processor, XPathNavigator node)
		{
			return processor.TextEvent(node.Value);
		}

		private static bool SendEndEvent(Processor processor, XPathNavigator node)
		{
			return processor.EndEvent(XPathNodeType.Attribute);
		}
	}
	internal class CopyCodeAction : Action
	{
		private const int Outputting = 2;

		private ArrayList copyEvents;

		internal CopyCodeAction()
		{
			copyEvents = new ArrayList();
		}

		internal void AddEvent(Event copyEvent)
		{
			copyEvents.Add(copyEvent);
		}

		internal void AddEvents(ArrayList copyEvents)
		{
			this.copyEvents.AddRange(copyEvents);
		}

		internal override void ReplaceNamespaceAlias(Compiler compiler)
		{
			int count = copyEvents.Count;
			for (int i = 0; i < count; i++)
			{
				((Event)copyEvents[i]).ReplaceNamespaceAlias(compiler);
			}
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			default:
				return;
			case 0:
				frame.Counter = 0;
				frame.State = 2;
				break;
			case 2:
				break;
			case 1:
				return;
			}
			while (processor.CanContinue)
			{
				Event @event = (Event)copyEvents[frame.Counter];
				if (!@event.Output(processor, frame))
				{
					break;
				}
				if (frame.IncrementCounter() >= copyEvents.Count)
				{
					frame.Finished();
					break;
				}
			}
		}

		internal override DbgData GetDbgData(ActionFrame frame)
		{
			return ((Event)copyEvents[frame.Counter]).DbgData;
		}
	}
	internal sealed class CopyNamespacesAction : Action
	{
		private const int BeginEvent = 2;

		private const int TextEvent = 3;

		private const int EndEvent = 4;

		private const int Advance = 5;

		private static CopyNamespacesAction s_Action = new CopyNamespacesAction();

		internal static CopyNamespacesAction GetAction()
		{
			return s_Action;
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			while (processor.CanContinue)
			{
				switch (frame.State)
				{
				default:
					return;
				case 0:
					if (!frame.Node.MoveToFirstNamespace(XPathNamespaceScope.ExcludeXml))
					{
						frame.Finished();
						return;
					}
					frame.State = 2;
					goto case 2;
				case 2:
					if (!processor.BeginEvent(XPathNodeType.Namespace, null, frame.Node.LocalName, frame.Node.Value, empty: false))
					{
						return;
					}
					frame.State = 4;
					break;
				case 4:
					if (!processor.EndEvent(XPathNodeType.Namespace))
					{
						return;
					}
					frame.State = 5;
					break;
				case 5:
					if (frame.Node.MoveToNextNamespace(XPathNamespaceScope.ExcludeXml))
					{
						frame.State = 2;
						break;
					}
					frame.Node.MoveToParent();
					frame.Finished();
					return;
				case 1:
				case 3:
					return;
				}
			}
		}
	}
	internal sealed class CopyNodeSetAction : Action
	{
		private const int BeginEvent = 2;

		private const int Contents = 3;

		private const int Namespaces = 4;

		private const int Attributes = 5;

		private const int Subtree = 6;

		private const int EndEvent = 7;

		private static CopyNodeSetAction s_Action = new CopyNodeSetAction();

		internal static CopyNodeSetAction GetAction()
		{
			return s_Action;
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			while (processor.CanContinue)
			{
				switch (frame.State)
				{
				default:
					return;
				case 0:
					if (frame.NextNode(processor))
					{
						frame.State = 2;
						goto case 2;
					}
					frame.Finished();
					return;
				case 2:
					if (!SendBeginEvent(processor, frame.Node))
					{
						return;
					}
					frame.State = 3;
					continue;
				case 3:
				{
					XPathNodeType nodeType = frame.Node.NodeType;
					if (nodeType == XPathNodeType.Element || nodeType == XPathNodeType.Root)
					{
						processor.PushActionFrame(CopyNamespacesAction.GetAction(), frame.NodeSet);
						frame.State = 4;
					}
					else if (SendTextEvent(processor, frame.Node))
					{
						frame.State = 7;
						continue;
					}
					return;
				}
				case 4:
					processor.PushActionFrame(CopyAttributesAction.GetAction(), frame.NodeSet);
					frame.State = 5;
					return;
				case 5:
					if (frame.Node.HasChildren)
					{
						processor.PushActionFrame(GetAction(), frame.Node.SelectChildren(XPathNodeType.All));
						frame.State = 6;
						return;
					}
					frame.State = 7;
					break;
				case 6:
					frame.State = 7;
					continue;
				case 7:
					break;
				case 1:
					return;
				}
				if (!SendEndEvent(processor, frame.Node))
				{
					break;
				}
				frame.State = 0;
			}
		}

		private static bool SendBeginEvent(Processor processor, XPathNavigator node)
		{
			return processor.CopyBeginEvent(node, node.IsEmptyElement);
		}

		private static bool SendTextEvent(Processor processor, XPathNavigator node)
		{
			return processor.CopyTextEvent(node);
		}

		private static bool SendEndEvent(Processor processor, XPathNavigator node)
		{
			return processor.CopyEndEvent(node);
		}
	}
	internal class CopyOfAction : CompiledAction
	{
		private const int ResultStored = 2;

		private const int NodeSetCopied = 3;

		private int selectKey = -1;

		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			CheckRequiredAttribute(compiler, selectKey != -1, "select");
			CheckEmpty(compiler);
		}

		internal override bool CompileAttribute(Compiler compiler)
		{
			string localName = compiler.Input.LocalName;
			string value = compiler.Input.Value;
			if (Keywords.Equals(localName, compiler.Atoms.Select))
			{
				selectKey = compiler.AddQuery(value);
				return true;
			}
			return false;
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			case 0:
			{
				Query valueQuery = processor.GetValueQuery(selectKey);
				object obj = valueQuery.Evaluate(frame.NodeSet);
				if (obj is XPathNodeIterator)
				{
					processor.PushActionFrame(CopyNodeSetAction.GetAction(), new XPathArrayIterator(valueQuery));
					frame.State = 3;
					break;
				}
				if (obj is XPathNavigator nav)
				{
					processor.PushActionFrame(CopyNodeSetAction.GetAction(), new XPathSingletonIterator(nav));
					frame.State = 3;
					break;
				}
				string text = XmlConvert.ToXPathString(obj);
				if (processor.TextEvent(text))
				{
					frame.Finished();
					break;
				}
				frame.StoredOutput = text;
				frame.State = 2;
				break;
			}
			case 2:
				processor.TextEvent(frame.StoredOutput);
				frame.Finished();
				break;
			case 3:
				frame.Finished();
				break;
			case 1:
				break;
			}
		}
	}
	internal class DbgData
	{
		private XPathNavigator styleSheet;

		private VariableAction[] variables;

		private static DbgData s_nullDbgData = new DbgData();

		public XPathNavigator StyleSheet => styleSheet;

		public VariableAction[] Variables => variables;

		public static DbgData Empty => s_nullDbgData;

		public DbgData(Compiler compiler)
		{
			DbgCompiler dbgCompiler = (DbgCompiler)compiler;
			styleSheet = dbgCompiler.Input.Navigator.Clone();
			variables = dbgCompiler.LocalVariables;
			dbgCompiler.Debugger.OnInstructionCompile(StyleSheet);
		}

		internal void ReplaceVariables(VariableAction[] vars)
		{
			variables = vars;
		}

		private DbgData()
		{
			styleSheet = null;
			variables = new VariableAction[0];
		}
	}
	internal class DbgCompiler : Compiler
	{
		private class ApplyImportsActionDbg : ApplyImportsAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class ApplyTemplatesActionDbg : ApplyTemplatesAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class AttributeActionDbg : AttributeAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class AttributeSetActionDbg : AttributeSetAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class CallTemplateActionDbg : CallTemplateAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class CommentActionDbg : CommentAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class CopyActionDbg : CopyAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class CopyOfActionDbg : CopyOfAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class ElementActionDbg : ElementAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class ForEachActionDbg : ForEachAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.PushDebuggerStack();
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
				if (frame.State == -1)
				{
					processor.PopDebuggerStack();
				}
			}
		}

		private class IfActionDbg : IfAction
		{
			private DbgData dbgData;

			internal IfActionDbg(ConditionType type)
				: base(type)
			{
			}

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class MessageActionDbg : MessageAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class NewInstructionActionDbg : NewInstructionAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class NumberActionDbg : NumberAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class ProcessingInstructionActionDbg : ProcessingInstructionAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class RootActionDbg : RootAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
				string builtInTemplatesUri = compiler.Debugger.GetBuiltInTemplatesUri();
				if (builtInTemplatesUri != null && builtInTemplatesUri.Length != 0)
				{
					compiler.AllowBuiltInMode = true;
					builtInSheet = compiler.RootAction.CompileImport(compiler, compiler.ResolveUri(builtInTemplatesUri), int.MaxValue);
					compiler.AllowBuiltInMode = false;
				}
				dbgData.ReplaceVariables(((DbgCompiler)compiler).GlobalVariables);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.PushDebuggerStack();
					processor.OnInstructionExecute();
					processor.PushDebuggerStack();
				}
				base.Execute(processor, frame);
				if (frame.State == -1)
				{
					processor.PopDebuggerStack();
					processor.PopDebuggerStack();
				}
			}
		}

		private class SortActionDbg : SortAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class TemplateActionDbg : TemplateAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.PushDebuggerStack();
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
				if (frame.State == -1)
				{
					processor.PopDebuggerStack();
				}
			}
		}

		private class TextActionDbg : TextAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class UseAttributeSetsActionDbg : UseAttributeSetsAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class ValueOfActionDbg : ValueOfAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class VariableActionDbg : VariableAction
		{
			private DbgData dbgData;

			internal VariableActionDbg(VariableType type)
				: base(type)
			{
			}

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
				((DbgCompiler)compiler).DefineVariable(this);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class WithParamActionDbg : WithParamAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class BeginEventDbg : BeginEvent
		{
			private DbgData dbgData;

			internal override DbgData DbgData => dbgData;

			public BeginEventDbg(Compiler compiler)
				: base(compiler)
			{
				dbgData = new DbgData(compiler);
			}

			public override bool Output(Processor processor, ActionFrame frame)
			{
				OnInstructionExecute(processor);
				return base.Output(processor, frame);
			}
		}

		private class TextEventDbg : TextEvent
		{
			private DbgData dbgData;

			internal override DbgData DbgData => dbgData;

			public TextEventDbg(Compiler compiler)
				: base(compiler)
			{
				dbgData = new DbgData(compiler);
			}

			public override bool Output(Processor processor, ActionFrame frame)
			{
				OnInstructionExecute(processor);
				return base.Output(processor, frame);
			}
		}

		private IXsltDebugger debugger;

		private ArrayList globalVars = new ArrayList();

		private ArrayList localVars = new ArrayList();

		private VariableAction[] globalVarsCache;

		private VariableAction[] localVarsCache;

		public override IXsltDebugger Debugger => debugger;

		public virtual VariableAction[] GlobalVariables
		{
			get
			{
				if (globalVarsCache == null)
				{
					globalVarsCache = (VariableAction[])globalVars.ToArray(typeof(VariableAction));
				}
				return globalVarsCache;
			}
		}

		public virtual VariableAction[] LocalVariables
		{
			get
			{
				if (localVarsCache == null)
				{
					localVarsCache = (VariableAction[])localVars.ToArray(typeof(VariableAction));
				}
				return localVarsCache;
			}
		}

		public DbgCompiler(IXsltDebugger debugger)
		{
			this.debugger = debugger;
		}

		private void DefineVariable(VariableAction variable)
		{
			if (variable.IsGlobal)
			{
				for (int i = 0; i < globalVars.Count; i++)
				{
					VariableAction variableAction = (VariableAction)globalVars[i];
					if (variableAction.Name == variable.Name)
					{
						if (variable.Stylesheetid < variableAction.Stylesheetid)
						{
							globalVars[i] = variable;
							globalVarsCache = null;
						}
						return;
					}
				}
				globalVars.Add(variable);
				globalVarsCache = null;
			}
			else
			{
				localVars.Add(variable);
				localVarsCache = null;
			}
		}

		private void UnDefineVariables(int count)
		{
			if (count != 0)
			{
				localVars.RemoveRange(localVars.Count - count, count);
				localVarsCache = null;
			}
		}

		internal override void PopScope()
		{
			UnDefineVariables(base.ScopeManager.CurrentScope.GetVeriablesCount());
			base.PopScope();
		}

		public override ApplyImportsAction CreateApplyImportsAction()
		{
			ApplyImportsAction applyImportsAction = new ApplyImportsActionDbg();
			applyImportsAction.Compile(this);
			return applyImportsAction;
		}

		public override ApplyTemplatesAction CreateApplyTemplatesAction()
		{
			ApplyTemplatesAction applyTemplatesAction = new ApplyTemplatesActionDbg();
			applyTemplatesAction.Compile(this);
			return applyTemplatesAction;
		}

		public override AttributeAction CreateAttributeAction()
		{
			AttributeAction attributeAction = new AttributeActionDbg();
			attributeAction.Compile(this);
			return attributeAction;
		}

		public override AttributeSetAction CreateAttributeSetAction()
		{
			AttributeSetAction attributeSetAction = new AttributeSetActionDbg();
			attributeSetAction.Compile(this);
			return attributeSetAction;
		}

		public override CallTemplateAction CreateCallTemplateAction()
		{
			CallTemplateAction callTemplateAction = new CallTemplateActionDbg();
			callTemplateAction.Compile(this);
			return callTemplateAction;
		}

		public override ChooseAction CreateChooseAction()
		{
			ChooseAction chooseAction = new ChooseAction();
			chooseAction.Compile(this);
			return chooseAction;
		}

		public override CommentAction CreateCommentAction()
		{
			CommentAction commentAction = new CommentActionDbg();
			commentAction.Compile(this);
			return commentAction;
		}

		public override CopyAction CreateCopyAction()
		{
			CopyAction copyAction = new CopyActionDbg();
			copyAction.Compile(this);
			return copyAction;
		}

		public override CopyOfAction CreateCopyOfAction()
		{
			CopyOfAction copyOfAction = new CopyOfActionDbg();
			copyOfAction.Compile(this);
			return copyOfAction;
		}

		public override ElementAction CreateElementAction()
		{
			ElementAction elementAction = new ElementActionDbg();
			elementAction.Compile(this);
			return elementAction;
		}

		public override ForEachAction CreateForEachAction()
		{
			ForEachAction forEachAction = new ForEachActionDbg();
			forEachAction.Compile(this);
			return forEachAction;
		}

		public override IfAction CreateIfAction(IfAction.ConditionType type)
		{
			IfAction ifAction = new IfActionDbg(type);
			ifAction.Compile(this);
			return ifAction;
		}

		public override MessageAction CreateMessageAction()
		{
			MessageAction messageAction = new MessageActionDbg();
			messageAction.Compile(this);
			return messageAction;
		}

		public override NewInstructionAction CreateNewInstructionAction()
		{
			NewInstructionAction newInstructionAction = new NewInstructionActionDbg();
			newInstructionAction.Compile(this);
			return newInstructionAction;
		}

		public override NumberAction CreateNumberAction()
		{
			NumberAction numberAction = new NumberActionDbg();
			numberAction.Compile(this);
			return numberAction;
		}

		public override ProcessingInstructionAction CreateProcessingInstructionAction()
		{
			ProcessingInstructionAction processingInstructionAction = new ProcessingInstructionActionDbg();
			processingInstructionAction.Compile(this);
			return processingInstructionAction;
		}

		public override void CreateRootAction()
		{
			base.RootAction = new RootActionDbg();
			base.RootAction.Compile(this);
		}

		public override SortAction CreateSortAction()
		{
			SortAction sortAction = new SortActionDbg();
			sortAction.Compile(this);
			return sortAction;
		}

		public override TemplateAction CreateTemplateAction()
		{
			TemplateAction templateAction = new TemplateActionDbg();
			templateAction.Compile(this);
			return templateAction;
		}

		public override TemplateAction CreateSingleTemplateAction()
		{
			TemplateAction templateAction = new TemplateActionDbg();
			templateAction.CompileSingle(this);
			return templateAction;
		}

		public override TextAction CreateTextAction()
		{
			TextAction textAction = new TextActionDbg();
			textAction.Compile(this);
			return textAction;
		}

		public override UseAttributeSetsAction CreateUseAttributeSetsAction()
		{
			UseAttributeSetsAction useAttributeSetsAction = new UseAttributeSetsActionDbg();
			useAttributeSetsAction.Compile(this);
			return useAttributeSetsAction;
		}

		public override ValueOfAction CreateValueOfAction()
		{
			ValueOfAction valueOfAction = new ValueOfActionDbg();
			valueOfAction.Compile(this);
			return valueOfAction;
		}

		public override VariableAction CreateVariableAction(VariableType type)
		{
			VariableAction variableAction = new VariableActionDbg(type);
			variableAction.Compile(this);
			return variableAction;
		}

		public override WithParamAction CreateWithParamAction()
		{
			WithParamAction withParamAction = new WithParamActionDbg();
			withParamAction.Compile(this);
			return withParamAction;
		}

		public override BeginEvent CreateBeginEvent()
		{
			return new BeginEventDbg(this);
		}

		public override TextEvent CreateTextEvent()
		{
			return new TextEventDbg(this);
		}
	}
	internal class ElementAction : ContainerAction
	{
		private const int NameDone = 2;

		private Avt nameAvt;

		private Avt nsAvt;

		private bool empty;

		private InputScopeManager manager;

		private string name;

		private string nsUri;

		private PrefixQName qname;

		internal ElementAction()
		{
		}

		private static PrefixQName CreateElementQName(string name, string nsUri, InputScopeManager manager)
		{
			if (nsUri == "http://www.w3.org/2000/xmlns/")
			{
				throw XsltException.Create("Xslt_ReservedNS", nsUri);
			}
			PrefixQName prefixQName = new PrefixQName();
			prefixQName.SetQName(name);
			if (nsUri == null)
			{
				prefixQName.Namespace = manager.ResolveXmlNamespace(prefixQName.Prefix);
			}
			else
			{
				prefixQName.Namespace = nsUri;
			}
			return prefixQName;
		}

		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			CheckRequiredAttribute(compiler, nameAvt, "name");
			name = CompiledAction.PrecalculateAvt(ref nameAvt);
			nsUri = CompiledAction.PrecalculateAvt(ref nsAvt);
			if (nameAvt == null && nsAvt == null)
			{
				if (name != "xmlns")
				{
					qname = CreateElementQName(name, nsUri, compiler.CloneScopeManager());
				}
			}
			else
			{
				manager = compiler.CloneScopeManager();
			}
			if (compiler.Recurse())
			{
				CompileTemplate(compiler);
				compiler.ToParent();
			}
			empty = containedActions == null;
		}

		internal override bool CompileAttribute(Compiler compiler)
		{
			string localName = compiler.Input.LocalName;
			string value = compiler.Input.Value;
			if (Keywords.Equals(localName, compiler.Atoms.Name))
			{
				nameAvt = Avt.CompileAvt(compiler, value);
			}
			else if (Keywords.Equals(localName, compiler.Atoms.Namespace))
			{
				nsAvt = Avt.CompileAvt(compiler, value);
			}
			else
			{
				if (!Keywords.Equals(localName, compiler.Atoms.UseAttributeSets))
				{
					return false;
				}
				AddAction(compiler.CreateUseAttributeSetsAction());
			}
			return true;
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			default:
				return;
			case 0:
				if (qname != null)
				{
					frame.CalulatedName = qname;
				}
				else
				{
					frame.CalulatedName = CreateElementQName((nameAvt == null) ? name : nameAvt.Evaluate(processor, frame), (nsAvt == null) ? nsUri : nsAvt.Evaluate(processor, frame), manager);
				}
				goto case 2;
			case 2:
			{
				PrefixQName calulatedName = frame.CalulatedName;
				if (!processor.BeginEvent(XPathNodeType.Element, calulatedName.Prefix, calulatedName.Name, calulatedName.Namespace, empty))
				{
					frame.State = 2;
					return;
				}
				if (!empty)
				{
					processor.PushActionFrame(frame);
					frame.State = 1;
					return;
				}
				break;
			}
			case 1:
				break;
			}
			if (!processor.EndEvent(XPathNodeType.Element))
			{
				frame.State = 1;
			}
			else
			{
				frame.Finished();
			}
		}
	}
	internal class ForEachAction : ContainerAction
	{
		private const int ProcessedSort = 2;

		private const int ProcessNextNode = 3;

		private const int PositionAdvanced = 4;

		private const int ContentsProcessed = 5;

		private int selectKey = -1;

		private ContainerAction sortContainer;

		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			CheckRequiredAttribute(compiler, selectKey != -1, "select");
			compiler.CanHaveApplyImports = false;
			if (compiler.Recurse())
			{
				CompileSortElements(compiler);
				CompileTemplate(compiler);
				compiler.ToParent();
			}
		}

		internal override bool CompileAttribute(Compiler compiler)
		{
			string localName = compiler.Input.LocalName;
			string value = compiler.Input.Value;
			if (Keywords.Equals(localName, compiler.Atoms.Select))
			{
				selectKey = compiler.AddQuery(value);
				return true;
			}
			return false;
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			default:
				return;
			case 0:
				if (sortContainer != null)
				{
					processor.InitSortArray();
					processor.PushActionFrame(sortContainer, frame.NodeSet);
					frame.State = 2;
					return;
				}
				goto case 2;
			case 2:
				frame.InitNewNodeSet(processor.StartQuery(frame.NodeSet, selectKey));
				if (sortContainer != null)
				{
					frame.SortNewNodeSet(processor, processor.SortArray);
				}
				frame.State = 3;
				goto case 3;
			case 3:
				if (frame.NewNextNode(processor))
				{
					frame.State = 4;
					break;
				}
				frame.Finished();
				return;
			case 4:
				break;
			case 5:
				frame.State = 3;
				goto case 3;
			case 1:
				return;
			}
			processor.PushActionFrame(frame, frame.NewNodeSet);
			frame.State = 5;
		}

		protected void CompileSortElements(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			do
			{
				switch (input.NodeType)
				{
				case XPathNodeType.Element:
					if (Keywords.Equals(input.NamespaceURI, input.Atoms.XsltNamespace) && Keywords.Equals(input.LocalName, input.Atoms.Sort))
					{
						if (sortContainer == null)
						{
							sortContainer = new ContainerAction();
						}
						sortContainer.AddAction(compiler.CreateSortAction());
						break;
					}
					return;
				case XPathNodeType.Text:
					return;
				case XPathNodeType.SignificantWhitespace:
					AddEvent(compiler.CreateTextEvent());
					break;
				}
			}
			while (input.Advance());
		}
	}
	internal class IfAction : ContainerAction
	{
		internal enum ConditionType
		{
			ConditionIf,
			ConditionWhen,
			ConditionOtherwise
		}

		private ConditionType type;

		private int testKey = -1;

		internal IfAction(ConditionType type)
		{
			this.type = type;
		}

		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			if (type != ConditionType.ConditionOtherwise)
			{
				CheckRequiredAttribute(compiler, testKey != -1, "test");
			}
			if (compiler.Recurse())
			{
				CompileTemplate(compiler);
				compiler.ToParent();
			}
		}

		internal override bool CompileAttribute(Compiler compiler)
		{
			string localName = compiler.Input.LocalName;
			string value = compiler.Input.Value;
			if (Keywords.Equals(localName, compiler.Atoms.Test))
			{
				if (type == ConditionType.ConditionOtherwise)
				{
					return false;
				}
				testKey = compiler.AddBooleanQuery(value);
				return true;
			}
			return false;
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			case 0:
				if ((type == ConditionType.ConditionIf || type == ConditionType.ConditionWhen) && !processor.EvaluateBoolean(frame, testKey))
				{
					frame.Finished();
					break;
				}
				processor.PushActionFrame(frame);
				frame.State = 1;
				break;
			case 1:
				if (type == ConditionType.ConditionWhen || type == ConditionType.ConditionOtherwise)
				{
					frame.Exit();
				}
				frame.Finished();
				break;
			}
		}
	}
	internal class MessageAction : ContainerAction
	{
		private bool _Terminate;

		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			if (compiler.Recurse())
			{
				CompileTemplate(compiler);
				compiler.ToParent();
			}
		}

		internal override bool CompileAttribute(Compiler compiler)
		{
			string localName = compiler.Input.LocalName;
			string value = compiler.Input.Value;
			if (Keywords.Equals(localName, compiler.Atoms.Terminate))
			{
				_Terminate = compiler.GetYesNo(value);
				return true;
			}
			return false;
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			case 0:
			{
				TextOnlyOutput output = new TextOnlyOutput(processor, new StringWriter(CultureInfo.InvariantCulture));
				processor.PushOutput(output);
				processor.PushActionFrame(frame);
				frame.State = 1;
				break;
			}
			case 1:
			{
				TextOnlyOutput textOnlyOutput = processor.PopOutput() as TextOnlyOutput;
				Console.WriteLine(textOnlyOutput.Writer.ToString());
				if (_Terminate)
				{
					throw XsltException.Create("Xslt_Terminate", textOnlyOutput.Writer.ToString());
				}
				frame.Finished();
				break;
			}
			}
		}
	}
	internal class NewInstructionAction : ContainerAction
	{
		private string name;

		private string parent;

		private bool fallback;

		internal override void Compile(Compiler compiler)
		{
			XPathNavigator xPathNavigator = compiler.Input.Navigator.Clone();
			name = xPathNavigator.Name;
			xPathNavigator.MoveToParent();
			parent = xPathNavigator.Name;
			if (compiler.Recurse())
			{
				CompileSelectiveTemplate(compiler);
				compiler.ToParent();
			}
		}

		internal void CompileSelectiveTemplate(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			do
			{
				if (Keywords.Equals(input.NamespaceURI, input.Atoms.XsltNamespace) && Keywords.Equals(input.LocalName, input.Atoms.Fallback))
				{
					fallback = true;
					if (compiler.Recurse())
					{
						CompileTemplate(compiler);
						compiler.ToParent();
					}
				}
			}
			while (compiler.Advance());
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			default:
				return;
			case 0:
				if (!fallback)
				{
					throw XsltException.Create("Xslt_UnknownExtensionElement", name);
				}
				if (containedActions != null && containedActions.Count > 0)
				{
					processor.PushActionFrame(frame);
					frame.State = 1;
					return;
				}
				break;
			case 1:
				break;
			}
			frame.Finished();
		}
	}
	internal class NumberAction : ContainerAction
	{
		internal class FormatInfo
		{
			public bool isSeparator;

			public NumberingSequence numSequence;

			public int length;

			public string formatString;

			public FormatInfo(bool isSeparator, string formatString)
			{
				this.isSeparator = isSeparator;
				this.formatString = formatString;
			}

			public FormatInfo()
			{
			}
		}

		private class NumberingFormat : NumberFormatterBase
		{
			private NumberingSequence seq;

			private int cMinLen;

			private string separator;

			private int sizeGroup;

			internal NumberingFormat()
			{
			}

			internal void setNumberingType(NumberingSequence seq)
			{
				this.seq = seq;
			}

			internal void setMinLen(int cMinLen)
			{
				this.cMinLen = cMinLen;
			}

			internal void setGroupingSeparator(string separator)
			{
				this.separator = separator;
			}

			internal void setGroupingSize(int sizeGroup)
			{
				if (0 <= sizeGroup && sizeGroup <= 9)
				{
					this.sizeGroup = sizeGroup;
				}
			}

			internal string FormatItem(object value)
			{
				double num;
				if (value is int)
				{
					num = (int)value;
				}
				else
				{
					num = XmlConvert.ToXPathDouble(value);
					if (!(0.5 <= num) || double.IsPositiveInfinity(num))
					{
						return XmlConvert.ToXPathString(value);
					}
					num = XmlConvert.XPathRound(num);
				}
				switch (seq)
				{
				case NumberingSequence.FirstAlpha:
				case NumberingSequence.LCLetter:
					if (num <= 2147483647.0)
					{
						StringBuilder stringBuilder2 = new StringBuilder();
						NumberFormatterBase.ConvertToAlphabetic(stringBuilder2, num, (seq == NumberingSequence.FirstAlpha) ? 'A' : 'a', 26);
						return stringBuilder2.ToString();
					}
					break;
				case NumberingSequence.FirstSpecial:
				case NumberingSequence.LCRoman:
					if (num <= 32767.0)
					{
						StringBuilder stringBuilder = new StringBuilder();
						NumberFormatterBase.ConvertToRoman(stringBuilder, num, seq == NumberingSequence.FirstSpecial);
						return stringBuilder.ToString();
					}
					break;
				}
				return ConvertToArabic(num, cMinLen, sizeGroup, separator);
			}

			private static string ConvertToArabic(double val, int minLength, int groupSize, string groupSeparator)
			{
				string text;
				if (groupSize != 0 && groupSeparator != null)
				{
					NumberFormatInfo numberFormatInfo = new NumberFormatInfo();
					numberFormatInfo.NumberGroupSizes = new int[1] { groupSize };
					numberFormatInfo.NumberGroupSeparator = groupSeparator;
					if (Math.Floor(val) == val)
					{
						numberFormatInfo.NumberDecimalDigits = 0;
					}
					text = val.ToString("N", numberFormatInfo);
				}
				else
				{
					text = Convert.ToString(val, CultureInfo.InvariantCulture);
				}
				if (text.Length >= minLength)
				{
					return text;
				}
				StringBuilder stringBuilder = new StringBuilder(minLength);
				stringBuilder.Append('0', minLength - text.Length);
				stringBuilder.Append(text);
				return stringBuilder.ToString();
			}
		}

		private const long msofnfcNil = 0L;

		private const long msofnfcTraditional = 1L;

		private const long msofnfcAlwaysFormat = 2L;

		private const int cchMaxFormat = 63;

		private const int cchMaxFormatDecimal = 11;

		private const int OutputNumber = 2;

		private static FormatInfo DefaultFormat = new FormatInfo(isSeparator: false, "0");

		private static FormatInfo DefaultSeparator = new FormatInfo(isSeparator: true, ".");

		private string level;

		private string countPattern;

		private int countKey = -1;

		private string from;

		private int fromKey = -1;

		private string value;

		private int valueKey = -1;

		private Avt formatAvt;

		private Avt langAvt;

		private Avt letterAvt;

		private Avt groupingSepAvt;

		private Avt groupingSizeAvt;

		private List<FormatInfo> formatTokens;

		private string lang;

		private string letter;

		private string groupingSep;

		private string groupingSize;

		private bool forwardCompatibility;

		internal override bool CompileAttribute(Compiler compiler)
		{
			string localName = compiler.Input.LocalName;
			string text = compiler.Input.Value;
			if (Keywords.Equals(localName, compiler.Atoms.Level))
			{
				if (text != "any" && text != "multiple" && text != "single")
				{
					throw XsltException.Create("Xslt_InvalidAttrValue", "level", text);
				}
				level = text;
			}
			else if (Keywords.Equals(localName, compiler.Atoms.Count))
			{
				countPattern = text;
				countKey = compiler.AddQuery(text, allowVar: true, allowKey: true, isPattern: true);
			}
			else if (Keywords.Equals(localName, compiler.Atoms.From))
			{
				from = text;
				fromKey = compiler.AddQuery(text, allowVar: true, allowKey: true, isPattern: true);
			}
			else if (Keywords.Equals(localName, compiler.Atoms.Value))
			{
				value = text;
				valueKey = compiler.AddQuery(text);
			}
			else if (Keywords.Equals(localName, compiler.Atoms.Format))
			{
				formatAvt = Avt.CompileAvt(compiler, text);
			}
			else if (Keywords.Equals(localName, compiler.Atoms.Lang))
			{
				langAvt = Avt.CompileAvt(compiler, text);
			}
			else if (Keywords.Equals(localName, compiler.Atoms.LetterValue))
			{
				letterAvt = Avt.CompileAvt(compiler, text);
			}
			else if (Keywords.Equals(localName, compiler.Atoms.GroupingSeparator))
			{
				groupingSepAvt = Avt.CompileAvt(compiler, text);
			}
			else
			{
				if (!Keywords.Equals(localName, compiler.Atoms.GroupingSize))
				{
					return false;
				}
				groupingSizeAvt = Avt.CompileAvt(compiler, text);
			}
			return true;
		}

		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			CheckEmpty(compiler);
			forwardCompatibility = compiler.ForwardCompatibility;
			formatTokens = ParseFormat(CompiledAction.PrecalculateAvt(ref formatAvt));
			letter = ParseLetter(CompiledAction.PrecalculateAvt(ref letterAvt));
			lang = CompiledAction.PrecalculateAvt(ref langAvt);
			groupingSep = CompiledAction.PrecalculateAvt(ref groupingSepAvt);
			if (groupingSep != null && groupingSep.Length > 1)
			{
				throw XsltException.Create("Xslt_CharAttribute", "grouping-separator");
			}
			groupingSize = CompiledAction.PrecalculateAvt(ref groupingSizeAvt);
		}

		private int numberAny(Processor processor, ActionFrame frame)
		{
			int num = 0;
			XPathNavigator xPathNavigator = frame.Node;
			if (xPathNavigator.NodeType == XPathNodeType.Attribute || xPathNavigator.NodeType == XPathNodeType.Namespace)
			{
				xPathNavigator = xPathNavigator.Clone();
				xPathNavigator.MoveToParent();
			}
			XPathNavigator xPathNavigator2 = xPathNavigator.Clone();
			if (fromKey != -1)
			{
				bool flag = false;
				do
				{
					if (processor.Matches(xPathNavigator2, fromKey))
					{
						flag = true;
						break;
					}
				}
				while (xPathNavigator2.MoveToParent());
				XPathNodeIterator xPathNodeIterator = xPathNavigator2.SelectDescendants(XPathNodeType.All, matchSelf: true);
				while (xPathNodeIterator.MoveNext())
				{
					if (processor.Matches(xPathNodeIterator.Current, fromKey))
					{
						flag = true;
						num = 0;
					}
					else if (MatchCountKey(processor, frame.Node, xPathNodeIterator.Current))
					{
						num++;
					}
					if (xPathNodeIterator.Current.IsSamePosition(xPathNavigator))
					{
						break;
					}
				}
				if (!flag)
				{
					num = 0;
				}
			}
			else
			{
				xPathNavigator2.MoveToRoot();
				XPathNodeIterator xPathNodeIterator2 = xPathNavigator2.SelectDescendants(XPathNodeType.All, matchSelf: true);
				while (xPathNodeIterator2.MoveNext())
				{
					if (MatchCountKey(processor, frame.Node, xPathNodeIterator2.Current))
					{
						num++;
					}
					if (xPathNodeIterator2.Current.IsSamePosition(xPathNavigator))
					{
						break;
					}
				}
			}
			return num;
		}

		private bool checkFrom(Processor processor, XPathNavigator nav)
		{
			if (fromKey == -1)
			{
				return true;
			}
			do
			{
				if (processor.Matches(nav, fromKey))
				{
					return true;
				}
			}
			while (nav.MoveToParent());
			return false;
		}

		private bool moveToCount(XPathNavigator nav, Processor processor, XPathNavigator contextNode)
		{
			do
			{
				if (fromKey != -1 && processor.Matches(nav, fromKey))
				{
					return false;
				}
				if (MatchCountKey(processor, contextNode, nav))
				{
					return true;
				}
			}
			while (nav.MoveToParent());
			return false;
		}

		private int numberCount(XPathNavigator nav, Processor processor, XPathNavigator contextNode)
		{
			XPathNavigator xPathNavigator = nav.Clone();
			int num = 1;
			if (xPathNavigator.MoveToParent())
			{
				xPathNavigator.MoveToFirstChild();
				while (!xPathNavigator.IsSamePosition(nav))
				{
					if (MatchCountKey(processor, contextNode, xPathNavigator))
					{
						num++;
					}
					if (!xPathNavigator.MoveToNext())
					{
						break;
					}
				}
			}
			return num;
		}

		private static object SimplifyValue(object value)
		{
			if (Type.GetTypeCode(value.GetType()) == TypeCode.Object)
			{
				if (value is XPathNodeIterator xPathNodeIterator)
				{
					if (xPathNodeIterator.MoveNext())
					{
						return xPathNodeIterator.Current.Value;
					}
					return string.Empty;
				}
				if (value is XPathNavigator xPathNavigator)
				{
					return xPathNavigator.Value;
				}
			}
			return value;
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			ArrayList numberList = processor.NumberList;
			switch (frame.State)
			{
			default:
				return;
			case 0:
				numberList.Clear();
				if (valueKey != -1)
				{
					numberList.Add(SimplifyValue(processor.Evaluate(frame, valueKey)));
				}
				else if (level == "any")
				{
					int num = numberAny(processor, frame);
					if (num != 0)
					{
						numberList.Add(num);
					}
				}
				else
				{
					bool flag = level == "multiple";
					XPathNavigator node = frame.Node;
					XPathNavigator xPathNavigator = frame.Node.Clone();
					if (xPathNavigator.NodeType == XPathNodeType.Attribute || xPathNavigator.NodeType == XPathNodeType.Namespace)
					{
						xPathNavigator.MoveToParent();
					}
					while (moveToCount(xPathNavigator, processor, node))
					{
						numberList.Insert(0, numberCount(xPathNavigator, processor, node));
						if (!flag || !xPathNavigator.MoveToParent())
						{
							break;
						}
					}
					if (!checkFrom(processor, xPathNavigator))
					{
						numberList.Clear();
					}
				}
				frame.StoredOutput = Format(numberList, (formatAvt == null) ? formatTokens : ParseFormat(formatAvt.Evaluate(processor, frame)), (langAvt == null) ? lang : langAvt.Evaluate(processor, frame), (letterAvt == null) ? letter : ParseLetter(letterAvt.Evaluate(processor, frame)), (groupingSepAvt == null) ? groupingSep : groupingSepAvt.Evaluate(processor, frame), (groupingSizeAvt == null) ? groupingSize : groupingSizeAvt.Evaluate(processor, frame));
				break;
			case 2:
				break;
			case 1:
				return;
			}
			if (!processor.TextEvent(frame.StoredOutput))
			{
				frame.State = 2;
			}
			else
			{
				frame.Finished();
			}
		}

		private bool MatchCountKey(Processor processor, XPathNavigator contextNode, XPathNavigator nav)
		{
			if (countKey != -1)
			{
				return processor.Matches(nav, countKey);
			}
			if (contextNode.Name == nav.Name && BasicNodeType(contextNode.NodeType) == BasicNodeType(nav.NodeType))
			{
				return true;
			}
			return false;
		}

		private XPathNodeType BasicNodeType(XPathNodeType type)
		{
			if (type == XPathNodeType.SignificantWhitespace || type == XPathNodeType.Whitespace)
			{
				return XPathNodeType.Text;
			}
			return type;
		}

		private static string Format(ArrayList numberlist, List<FormatInfo> tokens, string lang, string letter, string groupingSep, string groupingSize)
		{
			StringBuilder stringBuilder = new StringBuilder();
			int num = 0;
			if (tokens != null)
			{
				num = tokens.Count;
			}
			NumberingFormat numberingFormat = new NumberingFormat();
			if (groupingSize != null)
			{
				try
				{
					numberingFormat.setGroupingSize(Convert.ToInt32(groupingSize, CultureInfo.InvariantCulture));
				}
				catch (FormatException)
				{
				}
				catch (OverflowException)
				{
				}
			}
			if (groupingSep != null)
			{
				_ = groupingSep.Length;
				_ = 1;
				numberingFormat.setGroupingSeparator(groupingSep);
			}
			if (0 < num)
			{
				FormatInfo formatInfo = tokens[0];
				FormatInfo formatInfo2 = null;
				if (num % 2 == 1)
				{
					formatInfo2 = tokens[num - 1];
					num--;
				}
				FormatInfo formatInfo3 = ((2 < num) ? tokens[num - 2] : DefaultSeparator);
				FormatInfo formatInfo4 = ((0 < num) ? tokens[num - 1] : DefaultFormat);
				if (formatInfo != null)
				{
					stringBuilder.Append(formatInfo.formatString);
				}
				int count = numberlist.Count;
				for (int i = 0; i < count; i++)
				{
					int num2 = i * 2;
					bool flag = num2 < num;
					if (0 < i)
					{
						FormatInfo formatInfo5 = (flag ? tokens[num2] : formatInfo3);
						stringBuilder.Append(formatInfo5.formatString);
					}
					FormatInfo formatInfo6 = (flag ? tokens[num2 + 1] : formatInfo4);
					numberingFormat.setNumberingType(formatInfo6.numSequence);
					numberingFormat.setMinLen(formatInfo6.length);
					stringBuilder.Append(numberingFormat.FormatItem(numberlist[i]));
				}
				if (formatInfo2 != null)
				{
					stringBuilder.Append(formatInfo2.formatString);
				}
			}
			else
			{
				numberingFormat.setNumberingType(NumberingSequence.FirstDecimal);
				for (int j = 0; j < numberlist.Count; j++)
				{
					if (j != 0)
					{
						stringBuilder.Append(".");
					}
					stringBuilder.Append(numberingFormat.FormatItem(numberlist[j]));
				}
			}
			return stringBuilder.ToString();
		}

		private static void mapFormatToken(string wsToken, int startLen, int tokLen, out NumberingSequence seq, out int pminlen)
		{
			char c = wsToken[startLen];
			bool flag = false;
			pminlen = 1;
			seq = NumberingSequence.Nil;
			int num = c;
			if (num <= 2406)
			{
				if (num == 48 || num == 2406)
				{
					goto IL_0042;
				}
			}
			else if (num == 3664 || num == 51067 || num == 65296)
			{
				goto IL_0042;
			}
			goto IL_0070;
			IL_0042:
			do
			{
				pminlen++;
			}
			while (--tokLen > 0 && c == wsToken[++startLen]);
			if (wsToken[startLen] != (ushort)(c + 1))
			{
				flag = true;
			}
			goto IL_0070;
			IL_0070:
			if (!flag)
			{
				switch (wsToken[startLen])
				{
				case '1':
					seq = NumberingSequence.FirstDecimal;
					break;
				case 'A':
					seq = NumberingSequence.FirstAlpha;
					break;
				case 'I':
					seq = NumberingSequence.FirstSpecial;
					break;
				case 'a':
					seq = NumberingSequence.LCLetter;
					break;
				case 'i':
					seq = NumberingSequence.LCRoman;
					break;
				case 'А':
					seq = NumberingSequence.UCRus;
					break;
				case 'а':
					seq = NumberingSequence.LCRus;
					break;
				case 'א':
					seq = NumberingSequence.Hebrew;
					break;
				case 'أ':
					seq = NumberingSequence.ArabicScript;
					break;
				case 'अ':
					seq = NumberingSequence.Hindi2;
					break;
				case 'क':
					seq = NumberingSequence.Hindi1;
					break;
				case '१':
					seq = NumberingSequence.Hindi3;
					break;
				case 'ก':
					seq = NumberingSequence.Thai1;
					break;
				case '๑':
					seq = NumberingSequence.Thai2;
					break;
				case 'ア':
					seq = NumberingSequence.DAiueo;
					break;
				case 'イ':
					seq = NumberingSequence.DIroha;
					break;
				case 'ㄱ':
					seq = NumberingSequence.DChosung;
					break;
				case '一':
					seq = NumberingSequence.FEDecimal;
					break;
				case '壱':
					seq = NumberingSequence.DbNum3;
					break;
				case '壹':
					seq = NumberingSequence.ChnCmplx;
					break;
				case '子':
					seq = NumberingSequence.Zodiac2;
					break;
				case '가':
					seq = NumberingSequence.Ganada;
					break;
				case '일':
					seq = NumberingSequence.KorDbNum1;
					break;
				case '하':
					seq = NumberingSequence.KorDbNum3;
					break;
				case '１':
					seq = NumberingSequence.DArabic;
					break;
				case 'ｱ':
					seq = NumberingSequence.Aiueo;
					break;
				case 'ｲ':
					seq = NumberingSequence.Iroha;
					break;
				case '甲':
					if (tokLen > 1 && wsToken[startLen + 1] == '子')
					{
						seq = NumberingSequence.Zodiac3;
						tokLen--;
						startLen++;
					}
					else
					{
						seq = NumberingSequence.Zodiac1;
					}
					break;
				default:
					seq = NumberingSequence.FirstDecimal;
					break;
				}
			}
			if (flag)
			{
				seq = NumberingSequence.FirstDecimal;
				pminlen = 0;
			}
		}

		private static List<FormatInfo> ParseFormat(string formatString)
		{
			if (formatString == null || formatString.Length == 0)
			{
				return null;
			}
			int num = 0;
			bool flag = CharUtil.IsAlphaNumeric(formatString[num]);
			List<FormatInfo> list = new List<FormatInfo>();
			int num2 = 0;
			if (flag)
			{
				list.Add(null);
			}
			while (num <= formatString.Length)
			{
				bool flag2 = ((num < formatString.Length) ? CharUtil.IsAlphaNumeric(formatString[num]) : (!flag));
				if (flag != flag2)
				{
					FormatInfo formatInfo = new FormatInfo();
					if (flag)
					{
						mapFormatToken(formatString, num2, num - num2, out formatInfo.numSequence, out formatInfo.length);
					}
					else
					{
						formatInfo.isSeparator = true;
						formatInfo.formatString = formatString.Substring(num2, num - num2);
					}
					num2 = num;
					num++;
					list.Add(formatInfo);
					flag = flag2;
				}
				else
				{
					num++;
				}
			}
			return list;
		}

		private string ParseLetter(string letter)
		{
			switch (letter)
			{
			case null:
			case "traditional":
			case "alphabetic":
				return letter;
			default:
				if (!forwardCompatibility)
				{
					throw XsltException.Create("Xslt_InvalidAttrValue", "letter-value", letter);
				}
				return null;
			}
		}
	}
	internal class ProcessingInstructionAction : ContainerAction
	{
		private const int NameEvaluated = 2;

		private const int NameReady = 3;

		private const char CharX = 'X';

		private const char Charx = 'x';

		private const char CharM = 'M';

		private const char Charm = 'm';

		private const char CharL = 'L';

		private const char Charl = 'l';

		private Avt nameAvt;

		private string name;

		internal ProcessingInstructionAction()
		{
		}

		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			CheckRequiredAttribute(compiler, nameAvt, "name");
			if (nameAvt.IsConstant)
			{
				name = nameAvt.Evaluate(null, null);
				nameAvt = null;
				if (!IsProcessingInstructionName(name))
				{
					name = null;
				}
			}
			if (compiler.Recurse())
			{
				CompileTemplate(compiler);
				compiler.ToParent();
			}
		}

		internal override bool CompileAttribute(Compiler compiler)
		{
			string localName = compiler.Input.LocalName;
			string value = compiler.Input.Value;
			if (Keywords.Equals(localName, compiler.Atoms.Name))
			{
				nameAvt = Avt.CompileAvt(compiler, value);
				return true;
			}
			return false;
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			case 0:
				if (nameAvt == null)
				{
					frame.StoredOutput = name;
					if (name == null)
					{
						frame.Finished();
						break;
					}
				}
				else
				{
					frame.StoredOutput = nameAvt.Evaluate(processor, frame);
					if (!IsProcessingInstructionName(frame.StoredOutput))
					{
						frame.Finished();
						break;
					}
				}
				goto case 3;
			case 3:
				if (!processor.BeginEvent(XPathNodeType.ProcessingInstruction, string.Empty, frame.StoredOutput, string.Empty, empty: false))
				{
					frame.State = 3;
					break;
				}
				processor.PushActionFrame(frame);
				frame.State = 1;
				break;
			case 1:
				if (!processor.EndEvent(XPathNodeType.ProcessingInstruction))
				{
					frame.State = 1;
				}
				else
				{
					frame.Finished();
				}
				break;
			default:
				frame.Finished();
				break;
			}
		}

		internal static bool IsProcessingInstructionName(string name)
		{
			if (name == null)
			{
				return false;
			}
			int length = name.Length;
			int i = 0;
			XmlCharType instance;
			for (instance = XmlCharType.Instance; i < length && instance.IsWhiteSpace(name[i]); i++)
			{
			}
			if (i >= length)
			{
				return false;
			}
			if (i < length && !instance.IsStartNCNameChar(name[i]))
			{
				return false;
			}
			for (; i < length && instance.IsNCNameChar(name[i]); i++)
			{
			}
			for (; i < length && instance.IsWhiteSpace(name[i]); i++)
			{
			}
			if (i < length)
			{
				return false;
			}
			if (length == 3 && (name[0] == 'X' || name[0] == 'x') && (name[1] == 'M' || name[1] == 'm') && (name[2] == 'L' || name[2] == 'l'))
			{
				return false;
			}
			return true;
		}
	}
	internal abstract class TemplateBaseAction : ContainerAction
	{
		protected int variableCount;

		private int variableFreeSlot;

		public int AllocateVariableSlot()
		{
			int result = variableFreeSlot;
			variableFreeSlot++;
			if (variableCount < variableFreeSlot)
			{
				variableCount = variableFreeSlot;
			}
			return result;
		}

		public void ReleaseVariableSlots(int n)
		{
		}
	}
	internal class RootAction : TemplateBaseAction
	{
		private const int QueryInitialized = 2;

		private const int RootProcessed = 3;

		private Hashtable attributeSetTable = new Hashtable();

		private Hashtable decimalFormatTable = new Hashtable();

		private List<Key> keyList;

		private XsltOutput output;

		public Stylesheet builtInSheet;

		public PermissionSet permissions;

		internal XsltOutput Output
		{
			get
			{
				if (output == null)
				{
					output = new XsltOutput();
				}
				return output;
			}
		}

		internal List<Key> KeyList => keyList;

		internal override void Compile(Compiler compiler)
		{
			CompileDocument(compiler, inInclude: false);
		}

		internal void InsertKey(XmlQualifiedName name, int MatchKey, int UseKey)
		{
			if (keyList == null)
			{
				keyList = new List<Key>();
			}
			keyList.Add(new Key(name, MatchKey, UseKey));
		}

		internal AttributeSetAction GetAttributeSet(XmlQualifiedName name)
		{
			AttributeSetAction attributeSetAction = (AttributeSetAction)attributeSetTable[name];
			if (attributeSetAction == null)
			{
				throw XsltException.Create("Xslt_NoAttributeSet", name.ToString());
			}
			return attributeSetAction;
		}

		public void PorcessAttributeSets(Stylesheet rootStylesheet)
		{
			MirgeAttributeSets(rootStylesheet);
			foreach (AttributeSetAction value in attributeSetTable.Values)
			{
				if (value.containedActions != null)
				{
					value.containedActions.Reverse();
				}
			}
			CheckAttributeSets_RecurceInList(new Hashtable(), attributeSetTable.Keys);
		}

		private void MirgeAttributeSets(Stylesheet stylesheet)
		{
			if (stylesheet.AttributeSetTable != null)
			{
				foreach (AttributeSetAction value in stylesheet.AttributeSetTable.Values)
				{
					ArrayList arrayList = value.containedActions;
					AttributeSetAction attributeSetAction2 = (AttributeSetAction)attributeSetTable[value.Name];
					if (attributeSetAction2 == null)
					{
						attributeSetAction2 = new AttributeSetAction();
						attributeSetAction2.name = value.Name;
						attributeSetAction2.containedActions = new ArrayList();
						attributeSetTable[value.Name] = attributeSetAction2;
					}
					ArrayList arrayList2 = attributeSetAction2.containedActions;
					if (arrayList != null)
					{
						int num = arrayList.Count - 1;
						while (0 <= num)
						{
							arrayList2.Add(arrayList[num]);
							num--;
						}
					}
				}
			}
			foreach (Stylesheet import in stylesheet.Imports)
			{
				MirgeAttributeSets(import);
			}
		}

		private void CheckAttributeSets_RecurceInList(Hashtable markTable, ICollection setQNames)
		{
			foreach (XmlQualifiedName setQName in setQNames)
			{
				object obj = markTable[setQName];
				if (obj == "P")
				{
					throw XsltException.Create("Xslt_CircularAttributeSet", setQName.ToString());
				}
				if (obj != "D")
				{
					markTable[setQName] = "P";
					CheckAttributeSets_RecurceInContainer(markTable, GetAttributeSet(setQName));
					markTable[setQName] = "D";
				}
			}
		}

		private void CheckAttributeSets_RecurceInContainer(Hashtable markTable, ContainerAction container)
		{
			if (container.containedActions == null)
			{
				return;
			}
			foreach (Action containedAction in container.containedActions)
			{
				if (containedAction is UseAttributeSetsAction)
				{
					CheckAttributeSets_RecurceInList(markTable, ((UseAttributeSetsAction)containedAction).UsedSets);
				}
				else if (containedAction is ContainerAction)
				{
					CheckAttributeSets_RecurceInContainer(markTable, (ContainerAction)containedAction);
				}
			}
		}

		internal void AddDecimalFormat(XmlQualifiedName name, DecimalFormat formatinfo)
		{
			DecimalFormat decimalFormat = (DecimalFormat)decimalFormatTable[name];
			if (decimalFormat != null)
			{
				NumberFormatInfo info = decimalFormat.info;
				NumberFormatInfo info2 = formatinfo.info;
				if (info.NumberDecimalSeparator != info2.NumberDecimalSeparator || info.NumberGroupSeparator != info2.NumberGroupSeparator || info.PositiveInfinitySymbol != info2.PositiveInfinitySymbol || info.NegativeSign != info2.NegativeSign || info.NaNSymbol != info2.NaNSymbol || info.PercentSymbol != info2.PercentSymbol || info.PerMilleSymbol != info2.PerMilleSymbol || decimalFormat.zeroDigit != formatinfo.zeroDigit || decimalFormat.digit != formatinfo.digit || decimalFormat.patternSeparator != formatinfo.patternSeparator)
				{
					throw XsltException.Create("Xslt_DupDecimalFormat", name.ToString());
				}
			}
			decimalFormatTable[name] = formatinfo;
		}

		internal DecimalFormat GetDecimalFormat(XmlQualifiedName name)
		{
			return decimalFormatTable[name] as DecimalFormat;
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			case 0:
			{
				frame.AllocateVariables(variableCount);
				XPathNavigator xPathNavigator = processor.Document.Clone();
				xPathNavigator.MoveToRoot();
				frame.InitNodeSet(new XPathSingletonIterator(xPathNavigator));
				if (containedActions != null && containedActions.Count > 0)
				{
					processor.PushActionFrame(frame);
				}
				frame.State = 2;
				break;
			}
			case 2:
				frame.NextNode(processor);
				if (processor.Debugger != null)
				{
					processor.PopDebuggerStack();
				}
				processor.PushTemplateLookup(frame.NodeSet, null, null);
				frame.State = 3;
				break;
			case 3:
				frame.Finished();
				break;
			case 1:
				break;
			}
		}
	}
	internal class SortAction : CompiledAction
	{
		private int selectKey = -1;

		private Avt langAvt;

		private Avt dataTypeAvt;

		private Avt orderAvt;

		private Avt caseOrderAvt;

		private string lang;

		private XmlDataType dataType = XmlDataType.Text;

		private XmlSortOrder order = XmlSortOrder.Ascending;

		private XmlCaseOrder caseOrder;

		private Sort sort;

		private bool forwardCompatibility;

		private InputScopeManager manager;

		private string ParseLang(string value)
		{
			if (value == null)
			{
				return null;
			}
			if (!XmlComplianceUtil.IsValidLanguageID(value.ToCharArray(), 0, value.Length) && (value.Length == 0 || CultureInfo.GetCultureInfo(value) == null))
			{
				if (forwardCompatibility)
				{
					return null;
				}
				throw XsltException.Create("Xslt_InvalidAttrValue", "lang", value);
			}
			return value;
		}

		private XmlDataType ParseDataType(string value, InputScopeManager manager)
		{
			if (value == null)
			{
				return XmlDataType.Text;
			}
			if (value == "text")
			{
				return XmlDataType.Text;
			}
			if (value == "number")
			{
				return XmlDataType.Number;
			}
			PrefixQName.ParseQualifiedName(value, out var prefix, out var _);
			manager.ResolveXmlNamespace(prefix);
			if (prefix.Length == 0 && !forwardCompatibility)
			{
				throw XsltException.Create("Xslt_InvalidAttrValue", "data-type", value);
			}
			return XmlDataType.Text;
		}

		private XmlSortOrder ParseOrder(string value)
		{
			if (value == null)
			{
				return XmlSortOrder.Ascending;
			}
			if (value == "ascending")
			{
				return XmlSortOrder.Ascending;
			}
			if (value == "descending")
			{
				return XmlSortOrder.Descending;
			}
			if (forwardCompatibility)
			{
				return XmlSortOrder.Ascending;
			}
			throw XsltException.Create("Xslt_InvalidAttrValue", "order", value);
		}

		private XmlCaseOrder ParseCaseOrder(string value)
		{
			if (value == null)
			{
				return XmlCaseOrder.None;
			}
			if (value == "upper-first")
			{
				return XmlCaseOrder.UpperFirst;
			}
			if (value == "lower-first")
			{
				return XmlCaseOrder.LowerFirst;
			}
			if (forwardCompatibility)
			{
				return XmlCaseOrder.None;
			}
			throw XsltException.Create("Xslt_InvalidAttrValue", "case-order", value);
		}

		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			CheckEmpty(compiler);
			if (selectKey == -1)
			{
				selectKey = compiler.AddQuery(".");
			}
			forwardCompatibility = compiler.ForwardCompatibility;
			manager = compiler.CloneScopeManager();
			lang = ParseLang(CompiledAction.PrecalculateAvt(ref langAvt));
			dataType = ParseDataType(CompiledAction.PrecalculateAvt(ref dataTypeAvt), manager);
			order = ParseOrder(CompiledAction.PrecalculateAvt(ref orderAvt));
			caseOrder = ParseCaseOrder(CompiledAction.PrecalculateAvt(ref caseOrderAvt));
			if (langAvt == null && dataTypeAvt == null && orderAvt == null && caseOrderAvt == null)
			{
				sort = new Sort(selectKey, lang, dataType, order, caseOrder);
			}
		}

		internal override bool CompileAttribute(Compiler compiler)
		{
			string localName = compiler.Input.LocalName;
			string value = compiler.Input.Value;
			if (Keywords.Equals(localName, compiler.Atoms.Select))
			{
				selectKey = compiler.AddQuery(value);
			}
			else if (Keywords.Equals(localName, compiler.Atoms.Lang))
			{
				langAvt = Avt.CompileAvt(compiler, value);
			}
			else if (Keywords.Equals(localName, compiler.Atoms.DataType))
			{
				dataTypeAvt = Avt.CompileAvt(compiler, value);
			}
			else if (Keywords.Equals(localName, compiler.Atoms.Order))
			{
				orderAvt = Avt.CompileAvt(compiler, value);
			}
			else
			{
				if (!Keywords.Equals(localName, compiler.Atoms.CaseOrder))
				{
					return false;
				}
				caseOrderAvt = Avt.CompileAvt(compiler, value);
			}
			return true;
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			processor.AddSort((sort != null) ? sort : new Sort(selectKey, (langAvt == null) ? lang : ParseLang(langAvt.Evaluate(processor, frame)), (dataTypeAvt == null) ? dataType : ParseDataType(dataTypeAvt.Evaluate(processor, frame), manager), (orderAvt == null) ? order : ParseOrder(orderAvt.Evaluate(processor, frame)), (caseOrderAvt == null) ? caseOrder : ParseCaseOrder(caseOrderAvt.Evaluate(processor, frame))));
			frame.Finished();
		}
	}
	internal class TemplateAction : TemplateBaseAction
	{
		private int matchKey = -1;

		private XmlQualifiedName name;

		private double priority = double.NaN;

		private XmlQualifiedName mode;

		private int templateId;

		private bool replaceNSAliasesDone;

		internal int MatchKey => matchKey;

		internal XmlQualifiedName Name => name;

		internal double Priority => priority;

		internal XmlQualifiedName Mode => mode;

		internal int TemplateId
		{
			get
			{
				return templateId;
			}
			set
			{
				templateId = value;
			}
		}

		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			if (matchKey == -1)
			{
				if (name == null)
				{
					throw XsltException.Create("Xslt_TemplateNoAttrib");
				}
				if (mode != null)
				{
					throw XsltException.Create("Xslt_InvalidModeAttribute");
				}
			}
			compiler.BeginTemplate(this);
			if (compiler.Recurse())
			{
				CompileParameters(compiler);
				CompileTemplate(compiler);
				compiler.ToParent();
			}
			compiler.EndTemplate();
			AnalyzePriority(compiler);
		}

		internal virtual void CompileSingle(Compiler compiler)
		{
			matchKey = compiler.AddQuery("/", allowVar: false, allowKey: true, isPattern: true);
			priority = 0.5;
			CompileOnceTemplate(compiler);
		}

		internal override bool CompileAttribute(Compiler compiler)
		{
			string localName = compiler.Input.LocalName;
			string value = compiler.Input.Value;
			if (Keywords.Equals(localName, compiler.Atoms.Match))
			{
				matchKey = compiler.AddQuery(value, allowVar: false, allowKey: true, isPattern: true);
			}
			else if (Keywords.Equals(localName, compiler.Atoms.Name))
			{
				name = compiler.CreateXPathQName(value);
			}
			else if (Keywords.Equals(localName, compiler.Atoms.Priority))
			{
				priority = XmlConvert.ToXPathDouble(value);
				if (double.IsNaN(priority) && !compiler.ForwardCompatibility)
				{
					throw XsltException.Create("Xslt_InvalidAttrValue", "priority", value);
				}
			}
			else
			{
				if (!Keywords.Equals(localName, compiler.Atoms.Mode))
				{
					return false;
				}
				if (compiler.AllowBuiltInMode && value == "*")
				{
					mode = Compiler.BuiltInMode;
				}
				else
				{
					mode = compiler.CreateXPathQName(value);
				}
			}
			return true;
		}

		private void AnalyzePriority(Compiler compiler)
		{
			_ = compiler.Input;
			if (double.IsNaN(priority) && matchKey != -1)
			{
				TheQuery theQuery = compiler.QueryStore[MatchKey];
				CompiledXpathExpr compiledQuery = theQuery.CompiledQuery;
				Query query;
				for (query = compiledQuery.QueryTree; query is UnionExpr unionExpr; query = unionExpr.qy1)
				{
					TemplateAction templateAction = CloneWithoutName();
					compiler.QueryStore.Add(new TheQuery(new CompiledXpathExpr(unionExpr.qy2, compiledQuery.Expression, needContext: false), theQuery._ScopeManager));
					templateAction.matchKey = compiler.QueryStore.Count - 1;
					templateAction.priority = unionExpr.qy2.XsltDefaultPriority;
					compiler.AddTemplate(templateAction);
				}
				if (compiledQuery.QueryTree != query)
				{
					compiler.QueryStore[MatchKey] = new TheQuery(new CompiledXpathExpr(query, compiledQuery.Expression, needContext: false), theQuery._ScopeManager);
				}
				priority = query.XsltDefaultPriority;
			}
		}

		protected void CompileParameters(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			do
			{
				switch (input.NodeType)
				{
				case XPathNodeType.Element:
					if (Keywords.Equals(input.NamespaceURI, input.Atoms.XsltNamespace) && Keywords.Equals(input.LocalName, input.Atoms.Param))
					{
						compiler.PushNamespaceScope();
						AddAction(compiler.CreateVariableAction(VariableType.LocalParameter));
						compiler.PopScope();
						break;
					}
					return;
				case XPathNodeType.Text:
					return;
				case XPathNodeType.SignificantWhitespace:
					AddEvent(compiler.CreateTextEvent());
					break;
				}
			}
			while (input.Advance());
		}

		private TemplateAction CloneWithoutName()
		{
			TemplateAction templateAction = new TemplateAction();
			templateAction.containedActions = containedActions;
			templateAction.mode = mode;
			templateAction.variableCount = variableCount;
			templateAction.replaceNSAliasesDone = true;
			return templateAction;
		}

		internal override void ReplaceNamespaceAlias(Compiler compiler)
		{
			if (!replaceNSAliasesDone)
			{
				base.ReplaceNamespaceAlias(compiler);
				replaceNSAliasesDone = true;
			}
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			case 0:
				if (variableCount > 0)
				{
					frame.AllocateVariables(variableCount);
				}
				if (containedActions != null && containedActions.Count > 0)
				{
					processor.PushActionFrame(frame);
					frame.State = 1;
				}
				else
				{
					frame.Finished();
				}
				break;
			case 1:
				frame.Finished();
				break;
			}
		}
	}
	internal class TextAction : CompiledAction
	{
		private bool disableOutputEscaping;

		private string text;

		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			CompileContent(compiler);
		}

		internal override bool CompileAttribute(Compiler compiler)
		{
			string localName = compiler.Input.LocalName;
			string value = compiler.Input.Value;
			if (Keywords.Equals(localName, compiler.Atoms.DisableOutputEscaping))
			{
				disableOutputEscaping = compiler.GetYesNo(value);
				return true;
			}
			return false;
		}

		private void CompileContent(Compiler compiler)
		{
			if (!compiler.Recurse())
			{
				return;
			}
			NavigatorInput input = compiler.Input;
			text = string.Empty;
			do
			{
				switch (input.NodeType)
				{
				case XPathNodeType.Text:
				case XPathNodeType.SignificantWhitespace:
				case XPathNodeType.Whitespace:
					text += input.Value;
					break;
				default:
					throw compiler.UnexpectedKeyword();
				case XPathNodeType.ProcessingInstruction:
				case XPathNodeType.Comment:
					break;
				}
			}
			while (compiler.Advance());
			compiler.ToParent();
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			if (frame.State == 0 && processor.TextEvent(text, disableOutputEscaping))
			{
				frame.Finished();
			}
		}
	}
	internal class UseAttributeSetsAction : CompiledAction
	{
		private const int ProcessingSets = 2;

		private XmlQualifiedName[] useAttributeSets;

		private string useString;

		internal XmlQualifiedName[] UsedSets => useAttributeSets;

		internal override void Compile(Compiler compiler)
		{
			useString = compiler.Input.Value;
			if (useString.Length == 0)
			{
				useAttributeSets = new XmlQualifiedName[0];
				return;
			}
			string[] array = XmlConvert.SplitString(useString);
			try
			{
				useAttributeSets = new XmlQualifiedName[array.Length];
				for (int i = 0; i < array.Length; i++)
				{
					useAttributeSets[i] = compiler.CreateXPathQName(array[i]);
				}
			}
			catch (XsltException)
			{
				if (!compiler.ForwardCompatibility)
				{
					throw;
				}
				useAttributeSets = new XmlQualifiedName[0];
			}
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			default:
				return;
			case 0:
				frame.Counter = 0;
				frame.State = 2;
				break;
			case 2:
				break;
			case 1:
				return;
			}
			if (frame.Counter < useAttributeSets.Length)
			{
				AttributeSetAction attributeSet = processor.RootAction.GetAttributeSet(useAttributeSets[frame.Counter]);
				frame.IncrementCounter();
				processor.PushActionFrame(attributeSet, frame.NodeSet);
			}
			else
			{
				frame.Finished();
			}
		}
	}
	internal class ValueOfAction : CompiledAction
	{
		private const int ResultStored = 2;

		private int selectKey = -1;

		private bool disableOutputEscaping;

		private static Action s_BuiltInRule = new BuiltInRuleTextAction();

		internal static Action BuiltInRule()
		{
			return s_BuiltInRule;
		}

		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			CheckRequiredAttribute(compiler, selectKey != -1, "select");
			CheckEmpty(compiler);
		}

		internal override bool CompileAttribute(Compiler compiler)
		{
			string localName = compiler.Input.LocalName;
			string value = compiler.Input.Value;
			if (Keywords.Equals(localName, compiler.Atoms.Select))
			{
				selectKey = compiler.AddQuery(value);
			}
			else
			{
				if (!Keywords.Equals(localName, compiler.Atoms.DisableOutputEscaping))
				{
					return false;
				}
				disableOutputEscaping = compiler.GetYesNo(value);
			}
			return true;
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			case 0:
			{
				string text = processor.ValueOf(frame, selectKey);
				if (processor.TextEvent(text, disableOutputEscaping))
				{
					frame.Finished();
					break;
				}
				frame.StoredOutput = text;
				frame.State = 2;
				break;
			}
			case 2:
				processor.TextEvent(frame.StoredOutput);
				frame.Finished();
				break;
			case 1:
				break;
			}
		}
	}
	internal class VariableAction : ContainerAction, IXsltContextVariable
	{
		private const int ValueCalculated = 2;

		public static object BeingComputedMark = new object();

		protected XmlQualifiedName name;

		protected string nameStr;

		protected string baseUri;

		protected int selectKey = -1;

		protected int stylesheetid;

		protected VariableType varType;

		private int varKey;

		internal int Stylesheetid => stylesheetid;

		internal XmlQualifiedName Name => name;

		internal string NameStr => nameStr;

		internal VariableType VarType => varType;

		internal int VarKey => varKey;

		internal bool IsGlobal
		{
			get
			{
				if (varType != 0)
				{
					return varType == VariableType.GlobalParameter;
				}
				return true;
			}
		}

		XPathResultType IXsltContextVariable.VariableType => XPathResultType.Any;

		bool IXsltContextVariable.IsLocal
		{
			get
			{
				if (varType != VariableType.LocalVariable)
				{
					return varType == VariableType.LocalParameter;
				}
				return true;
			}
		}

		bool IXsltContextVariable.IsParam
		{
			get
			{
				if (varType != VariableType.LocalParameter)
				{
					return varType == VariableType.GlobalParameter;
				}
				return true;
			}
		}

		internal VariableAction(VariableType type)
		{
			varType = type;
		}

		internal override void Compile(Compiler compiler)
		{
			stylesheetid = compiler.Stylesheetid;
			baseUri = compiler.Input.BaseURI;
			CompileAttributes(compiler);
			CheckRequiredAttribute(compiler, name, "name");
			if (compiler.Recurse())
			{
				CompileTemplate(compiler);
				compiler.ToParent();
				if (selectKey != -1 && containedActions != null)
				{
					throw XsltException.Create("Xslt_VariableCntSel2", nameStr);
				}
			}
			if (containedActions != null)
			{
				baseUri = baseUri + '#' + compiler.GetUnicRtfId();
			}
			else
			{
				baseUri = null;
			}
			varKey = compiler.InsertVariable(this);
		}

		internal override bool CompileAttribute(Compiler compiler)
		{
			string localName = compiler.Input.LocalName;
			string value = compiler.Input.Value;
			if (Keywords.Equals(localName, compiler.Atoms.Name))
			{
				nameStr = value;
				name = compiler.CreateXPathQName(nameStr);
			}
			else
			{
				if (!Keywords.Equals(localName, compiler.Atoms.Select))
				{
					return false;
				}
				selectKey = compiler.AddQuery(value);
			}
			return true;
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			object obj = null;
			switch (frame.State)
			{
			default:
				return;
			case 0:
			{
				if (IsGlobal)
				{
					if (frame.GetVariable(varKey) != null)
					{
						frame.Finished();
						return;
					}
					frame.SetVariable(varKey, BeingComputedMark);
				}
				if (varType == VariableType.GlobalParameter)
				{
					obj = processor.GetGlobalParameter(name);
				}
				else if (varType == VariableType.LocalParameter)
				{
					obj = processor.GetParameter(name);
				}
				if (obj != null)
				{
					break;
				}
				if (selectKey != -1)
				{
					obj = processor.RunQuery(frame, selectKey);
					break;
				}
				if (containedActions == null)
				{
					obj = string.Empty;
					break;
				}
				NavigatorOutput output = new NavigatorOutput(baseUri);
				processor.PushOutput(output);
				processor.PushActionFrame(frame);
				frame.State = 1;
				return;
			}
			case 1:
			{
				RecordOutput recordOutput = processor.PopOutput();
				obj = ((NavigatorOutput)recordOutput).Navigator;
				break;
			}
			case 2:
				break;
			}
			frame.SetVariable(varKey, obj);
			frame.Finished();
		}

		object IXsltContextVariable.Evaluate(XsltContext xsltContext)
		{
			return ((XsltCompileContext)xsltContext).EvaluateVariable(this);
		}
	}
	internal class WithParamAction : VariableAction
	{
		internal WithParamAction()
			: base(VariableType.WithParameter)
		{
		}

		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			CheckRequiredAttribute(compiler, name, "name");
			if (compiler.Recurse())
			{
				CompileTemplate(compiler);
				compiler.ToParent();
				if (selectKey != -1 && containedActions != null)
				{
					throw XsltException.Create("Xslt_VariableCntSel2", nameStr);
				}
			}
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			case 0:
				if (selectKey != -1)
				{
					object value = processor.RunQuery(frame, selectKey);
					processor.SetParameter(name, value);
					frame.Finished();
				}
				else if (containedActions == null)
				{
					processor.SetParameter(name, string.Empty);
					frame.Finished();
				}
				else
				{
					NavigatorOutput output = new NavigatorOutput(baseUri);
					processor.PushOutput(output);
					processor.PushActionFrame(frame);
					frame.State = 1;
				}
				break;
			case 1:
			{
				RecordOutput recordOutput = processor.PopOutput();
				processor.SetParameter(name, ((NavigatorOutput)recordOutput).Navigator);
				frame.Finished();
				break;
			}
			}
		}
	}
	internal class DocumentScope
	{
		protected NamespaceDecl scopes;

		internal NamespaceDecl Scopes => scopes;

		internal NamespaceDecl AddNamespace(string prefix, string uri, string prevDefaultNsUri)
		{
			scopes = new NamespaceDecl(prefix, uri, prevDefaultNsUri, scopes);
			return scopes;
		}

		internal string ResolveAtom(string prefix)
		{
			for (NamespaceDecl next = scopes; next != null; next = next.Next)
			{
				if (Keywords.Equals(next.Prefix, prefix))
				{
					return next.Uri;
				}
			}
			return null;
		}

		internal string ResolveNonAtom(string prefix)
		{
			for (NamespaceDecl next = scopes; next != null; next = next.Next)
			{
				if (Keywords.Compare(next.Prefix, prefix))
				{
					return next.Uri;
				}
			}
			return null;
		}
	}
	internal class EndEvent : Event
	{
		private XPathNodeType nodeType;

		internal EndEvent(XPathNodeType nodeType)
		{
			this.nodeType = nodeType;
		}

		public override bool Output(Processor processor, ActionFrame frame)
		{
			return processor.EndEvent(nodeType);
		}
	}
	internal class HtmlElementProps
	{
		private bool empty;

		private bool abrParent;

		private bool uriParent;

		private bool noEntities;

		private bool blockWS;

		private bool head;

		private bool nameParent;

		private static Hashtable s_table = CreatePropsTable();

		public bool Empty => empty;

		public bool AbrParent => abrParent;

		public bool UriParent => uriParent;

		public bool NoEntities => noEntities;

		public bool BlockWS => blockWS;

		public bool Head => head;

		public bool NameParent => nameParent;

		public static HtmlElementProps Create(bool empty, bool abrParent, bool uriParent, bool noEntities, bool blockWS, bool head, bool nameParent)
		{
			HtmlElementProps htmlElementProps = new HtmlElementProps();
			htmlElementProps.empty = empty;
			htmlElementProps.abrParent = abrParent;
			htmlElementProps.uriParent = uriParent;
			htmlElementProps.noEntities = noEntities;
			htmlElementProps.blockWS = blockWS;
			htmlElementProps.head = head;
			htmlElementProps.nameParent = nameParent;
			return htmlElementProps;
		}

		public static HtmlElementProps GetProps(string name)
		{
			return (HtmlElementProps)s_table[name];
		}

		private static Hashtable CreatePropsTable()
		{
			bool flag = false;
			bool flag2 = true;
			Hashtable hashtable = new Hashtable(71, StringComparer.OrdinalIgnoreCase);
			hashtable.Add("a", Create(flag, flag, flag2, flag, flag, flag, flag2));
			hashtable.Add("address", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("applet", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("area", Create(flag2, flag2, flag2, flag, flag2, flag, flag));
			hashtable.Add("base", Create(flag2, flag, flag2, flag, flag2, flag, flag));
			hashtable.Add("basefont", Create(flag2, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("blockquote", Create(flag, flag, flag2, flag, flag2, flag, flag));
			hashtable.Add("body", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("br", Create(flag2, flag, flag, flag, flag, flag, flag));
			hashtable.Add("button", Create(flag, flag2, flag, flag, flag, flag, flag));
			hashtable.Add("caption", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("center", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("col", Create(flag2, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("colgroup", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("dd", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("del", Create(flag, flag, flag2, flag, flag2, flag, flag));
			hashtable.Add("dir", Create(flag, flag2, flag, flag, flag2, flag, flag));
			hashtable.Add("div", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("dl", Create(flag, flag2, flag, flag, flag2, flag, flag));
			hashtable.Add("dt", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("fieldset", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("font", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("form", Create(flag, flag, flag2, flag, flag2, flag, flag));
			hashtable.Add("frame", Create(flag2, flag2, flag, flag, flag2, flag, flag));
			hashtable.Add("frameset", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("h1", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("h2", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("h3", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("h4", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("h5", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("h6", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("head", Create(flag, flag, flag2, flag, flag2, flag2, flag));
			hashtable.Add("hr", Create(flag2, flag2, flag, flag, flag2, flag, flag));
			hashtable.Add("html", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("iframe", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("img", Create(flag2, flag2, flag2, flag, flag, flag, flag));
			hashtable.Add("input", Create(flag2, flag2, flag2, flag, flag, flag, flag));
			hashtable.Add("ins", Create(flag, flag, flag2, flag, flag2, flag, flag));
			hashtable.Add("isindex", Create(flag2, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("legend", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("li", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("link", Create(flag2, flag, flag2, flag, flag2, flag, flag));
			hashtable.Add("map", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("menu", Create(flag, flag2, flag, flag, flag2, flag, flag));
			hashtable.Add("meta", Create(flag2, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("noframes", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("noscript", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("object", Create(flag, flag2, flag2, flag, flag, flag, flag));
			hashtable.Add("ol", Create(flag, flag2, flag, flag, flag2, flag, flag));
			hashtable.Add("optgroup", Create(flag, flag2, flag, flag, flag2, flag, flag));
			hashtable.Add("option", Create(flag, flag2, flag, flag, flag2, flag, flag));
			hashtable.Add("p", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("param", Create(flag2, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("pre", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("q", Create(flag, flag, flag2, flag, flag, flag, flag));
			hashtable.Add("s", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("script", Create(flag, flag2, flag2, flag2, flag, flag, flag));
			hashtable.Add("select", Create(flag, flag2, flag, flag, flag, flag, flag));
			hashtable.Add("strike", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("style", Create(flag, flag, flag, flag2, flag2, flag, flag));
			hashtable.Add("table", Create(flag, flag, flag2, flag, flag2, flag, flag));
			hashtable.Add("tbody", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("td", Create(flag, flag2, flag, flag, flag2, flag, flag));
			hashtable.Add("textarea", Create(flag, flag2, flag, flag, flag, flag, flag));
			hashtable.Add("tfoot", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("th", Create(flag, flag2, flag, flag, flag2, flag, flag));
			hashtable.Add("thead", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("title", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("tr", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("ul", Create(flag, flag2, flag, flag, flag2, flag, flag));
			hashtable.Add("xmp", Create(flag, flag, flag, flag, flag, flag, flag));
			return hashtable;
		}
	}
	internal class HtmlAttributeProps
	{
		private bool abr;

		private bool uri;

		private bool name;

		private static Hashtable s_table = CreatePropsTable();

		public bool Abr => abr;

		public bool Uri => uri;

		public bool Name => name;

		public static HtmlAttributeProps Create(bool abr, bool uri, bool name)
		{
			HtmlAttributeProps htmlAttributeProps = new HtmlAttributeProps();
			htmlAttributeProps.abr = abr;
			htmlAttributeProps.uri = uri;
			htmlAttributeProps.name = name;
			return htmlAttributeProps;
		}

		public static HtmlAttributeProps GetProps(string name)
		{
			return (HtmlAttributeProps)s_table[name];
		}

		private static Hashtable CreatePropsTable()
		{
			bool flag = false;
			bool flag2 = true;
			Hashtable hashtable = new Hashtable(26, StringComparer.OrdinalIgnoreCase);
			hashtable.Add("action", Create(flag, flag2, flag));
			hashtable.Add("checked", Create(flag2, flag, flag));
			hashtable.Add("cite", Create(flag, flag2, flag));
			hashtable.Add("classid", Create(flag, flag2, flag));
			hashtable.Add("codebase", Create(flag, flag2, flag));
			hashtable.Add("compact", Create(flag2, flag, flag));
			hashtable.Add("data", Create(flag, flag2, flag));
			hashtable.Add("datasrc", Create(flag, flag2, flag));
			hashtable.Add("declare", Create(flag2, flag, flag));
			hashtable.Add("defer", Create(flag2, flag, flag));
			hashtable.Add("disabled", Create(flag2, flag, flag));
			hashtable.Add("for", Create(flag, flag2, flag));
			hashtable.Add("href", Create(flag, flag2, flag));
			hashtable.Add("ismap", Create(flag2, flag, flag));
			hashtable.Add("longdesc", Create(flag, flag2, flag));
			hashtable.Add("multiple", Create(flag2, flag, flag));
			hashtable.Add("name", Create(flag, flag, flag2));
			hashtable.Add("nohref", Create(flag2, flag, flag));
			hashtable.Add("noresize", Create(flag2, flag, flag));
			hashtable.Add("noshade", Create(flag2, flag, flag));
			hashtable.Add("nowrap", Create(flag2, flag, flag));
			hashtable.Add("profile", Create(flag, flag2, flag));
			hashtable.Add("readonly", Create(flag2, flag, flag));
			hashtable.Add("selected", Create(flag2, flag, flag));
			hashtable.Add("src", Create(flag, flag2, flag));
			hashtable.Add("usemap", Create(flag, flag2, flag));
			return hashtable;
		}
	}
	internal class InputScope : DocumentScope
	{
		private InputScope parent;

		private bool forwardCompatibility;

		private bool canHaveApplyImports;

		private Hashtable variables;

		private Hashtable extensionNamespaces;

		private Hashtable excludedNamespaces;

		internal InputScope Parent => parent;

		internal Hashtable Variables => variables;

		internal bool ForwardCompatibility
		{
			get
			{
				return forwardCompatibility;
			}
			set
			{
				forwardCompatibility = value;
			}
		}

		internal bool CanHaveApplyImports
		{
			get
			{
				return canHaveApplyImports;
			}
			set
			{
				canHaveApplyImports = value;
			}
		}

		internal InputScope(InputScope parent)
		{
			Init(parent);
		}

		internal void Init(InputScope parent)
		{
			scopes = null;
			this.parent = parent;
			if (this.parent != null)
			{
				forwardCompatibility = this.parent.forwardCompatibility;
				canHaveApplyImports = this.parent.canHaveApplyImports;
			}
		}

		internal void InsertExtensionNamespace(string nspace)
		{
			if (extensionNamespaces == null)
			{
				extensionNamespaces = new Hashtable();
			}
			extensionNamespaces[nspace] = null;
		}

		internal bool IsExtensionNamespace(string nspace)
		{
			if (extensionNamespaces == null)
			{
				return false;
			}
			return extensionNamespaces.Contains(nspace);
		}

		internal void InsertExcludedNamespace(string nspace)
		{
			if (excludedNamespaces == null)
			{
				excludedNamespaces = new Hashtable();
			}
			excludedNamespaces[nspace] = null;
		}

		internal bool IsExcludedNamespace(string nspace)
		{
			if (excludedNamespaces == null)
			{
				return false;
			}
			return excludedNamespaces.Contains(nspace);
		}

		internal void InsertVariable(VariableAction variable)
		{
			if (variables == null)
			{
				variables = new Hashtable();
			}
			variables[variable.Name] = variable;
		}

		internal int GetVeriablesCount()
		{
			if (variables == null)
			{
				return 0;
			}
			return variables.Count;
		}

		public VariableAction ResolveVariable(XmlQualifiedName qname)
		{
			for (InputScope inputScope = this; inputScope != null; inputScope = inputScope.Parent)
			{
				if (inputScope.Variables != null)
				{
					VariableAction variableAction = (VariableAction)inputScope.Variables[qname];
					if (variableAction != null)
					{
						return variableAction;
					}
				}
			}
			return null;
		}

		public VariableAction ResolveGlobalVariable(XmlQualifiedName qname)
		{
			InputScope inputScope = null;
			for (InputScope inputScope2 = this; inputScope2 != null; inputScope2 = inputScope2.Parent)
			{
				inputScope = inputScope2;
			}
			return inputScope.ResolveVariable(qname);
		}
	}
	internal class InputScopeManager
	{
		private InputScope scopeStack;

		private string defaultNS = string.Empty;

		private XPathNavigator navigator;

		internal InputScope CurrentScope => scopeStack;

		internal InputScope VariableScope => scopeStack.Parent;

		public XPathNavigator Navigator => navigator;

		public string DefaultNamespace => defaultNS;

		public InputScopeManager(XPathNavigator navigator, InputScope rootScope)
		{
			this.navigator = navigator;
			scopeStack = rootScope;
		}

		internal InputScopeManager Clone()
		{
			InputScopeManager inputScopeManager = new InputScopeManager(navigator, null);
			inputScopeManager.scopeStack = scopeStack;
			inputScopeManager.defaultNS = defaultNS;
			return inputScopeManager;
		}

		internal InputScope PushScope()
		{
			scopeStack = new InputScope(scopeStack);
			return scopeStack;
		}

		internal void PopScope()
		{
			if (scopeStack != null)
			{
				for (NamespaceDecl namespaceDecl = scopeStack.Scopes; namespaceDecl != null; namespaceDecl = namespaceDecl.Next)
				{
					defaultNS = namespaceDecl.PrevDefaultNsUri;
				}
				scopeStack = scopeStack.Parent;
			}
		}

		internal void PushNamespace(string prefix, string nspace)
		{
			scopeStack.AddNamespace(prefix, nspace, defaultNS);
			if (prefix == null || prefix.Length == 0)
			{
				defaultNS = nspace;
			}
		}

		private string ResolveNonEmptyPrefix(string prefix)
		{
			if (prefix == "xml")
			{
				return "http://www.w3.org/XML/1998/namespace";
			}
			if (prefix == "xmlns")
			{
				return "http://www.w3.org/2000/xmlns/";
			}
			for (InputScope parent = scopeStack; parent != null; parent = parent.Parent)
			{
				string text = parent.ResolveNonAtom(prefix);
				if (text != null)
				{
					return text;
				}
			}
			throw XsltException.Create("Xslt_InvalidPrefix", prefix);
		}

		public string ResolveXmlNamespace(string prefix)
		{
			if (prefix.Length == 0)
			{
				return defaultNS;
			}
			return ResolveNonEmptyPrefix(prefix);
		}

		public string ResolveXPathNamespace(string prefix)
		{
			if (prefix.Length == 0)
			{
				return string.Empty;
			}
			return ResolveNonEmptyPrefix(prefix);
		}

		internal void InsertExtensionNamespaces(string[] nsList)
		{
			for (int i = 0; i < nsList.Length; i++)
			{
				scopeStack.InsertExtensionNamespace(nsList[i]);
			}
		}

		internal bool IsExtensionNamespace(string nspace)
		{
			for (InputScope parent = scopeStack; parent != null; parent = parent.Parent)
			{
				if (parent.IsExtensionNamespace(nspace))
				{
					return true;
				}
			}
			return false;
		}

		internal void InsertExcludedNamespaces(string[] nsList)
		{
			for (int i = 0; i < nsList.Length; i++)
			{
				scopeStack.InsertExcludedNamespace(nsList[i]);
			}
		}

		internal bool IsExcludedNamespace(string nspace)
		{
			for (InputScope parent = scopeStack; parent != null; parent = parent.Parent)
			{
				if (parent.IsExcludedNamespace(nspace))
				{
					return true;
				}
			}
			return false;
		}
	}
	internal class Keywords
	{
		internal const string s_Xmlns = "xmlns";

		internal const string s_XsltNamespace = "http://www.w3.org/1999/XSL/Transform";

		internal const string s_XmlNamespace = "http://www.w3.org/XML/1998/namespace";

		internal const string s_XmlnsNamespace = "http://www.w3.org/2000/xmlns/";

		internal const string s_WdXslNamespace = "http://www.w3.org/TR/WD-xsl";

		internal const string s_Version10 = "1.0";

		internal const string s_ApplyImports = "apply-imports";

		internal const string s_ApplyTemplates = "apply-templates";

		internal const string s_Attribute = "attribute";

		internal const string s_AttributeSet = "attribute-set";

		internal const string s_CallTemplate = "call-template";

		internal const string s_Choose = "choose";

		internal const string s_Comment = "comment";

		internal const string s_Copy = "copy";

		internal const string s_CopyOf = "copy-of";

		internal const string s_DecimalFormat = "decimal-format";

		internal const string s_Element = "element";

		internal const string s_Fallback = "fallback";

		internal const string s_ForEach = "for-each";

		internal const string s_If = "if";

		internal const string s_Import = "import";

		internal const string s_Include = "include";

		internal const string s_Key = "key";

		internal const string s_Message = "message";

		internal const string s_NamespaceAlias = "namespace-alias";

		internal const string s_Number = "number";

		internal const string s_Otherwise = "otherwise";

		internal const string s_Output = "output";

		internal const string s_Param = "param";

		internal const string s_PreserveSpace = "preserve-space";

		internal const string s_ProcessingInstruction = "processing-instruction";

		internal const string s_Sort = "sort";

		internal const string s_StripSpace = "strip-space";

		internal const string s_Stylesheet = "stylesheet";

		internal const string s_Template = "template";

		internal const string s_Text = "text";

		internal const string s_Transform = "transform";

		internal const string s_ValueOf = "value-of";

		internal const string s_Variable = "variable";

		internal const string s_When = "when";

		internal const string s_WithParam = "with-param";

		internal const string s_CaseOrder = "case-order";

		internal const string s_CdataSectionElements = "cdata-section-elements";

		internal const string s_Count = "count";

		internal const string s_DataType = "data-type";

		internal const string s_DecimalSeparator = "decimal-separator";

		internal const string s_Digit = "digit";

		internal const string s_DisableOutputEscaping = "disable-output-escaping";

		internal const string s_DoctypePublic = "doctype-public";

		internal const string s_DoctypeSystem = "doctype-system";

		internal const string s_Elements = "elements";

		internal const string s_Encoding = "encoding";

		internal const string s_ExcludeResultPrefixes = "exclude-result-prefixes";

		internal const string s_ExtensionElementPrefixes = "extension-element-prefixes";

		internal const string s_Format = "format";

		internal const string s_From = "from";

		internal const string s_GroupingSeparator = "grouping-separator";

		internal const string s_GroupingSize = "grouping-size";

		internal const string s_Href = "href";

		internal const string s_Id = "id";

		internal const string s_Indent = "indent";

		internal const string s_Infinity = "infinity";

		internal const string s_Lang = "lang";

		internal const string s_LetterValue = "letter-value";

		internal const string s_Level = "level";

		internal const string s_Match = "match";

		internal const string s_MediaType = "media-type";

		internal const string s_Method = "method";

		internal const string s_MinusSign = "minus-sign";

		internal const string s_Mode = "mode";

		internal const string s_Name = "name";

		internal const string s_Namespace = "namespace";

		internal const string s_NaN = "NaN";

		internal const string s_OmitXmlDeclaration = "omit-xml-declaration";

		internal const string s_Order = "order";

		internal const string s_PatternSeparator = "pattern-separator";

		internal const string s_Percent = "percent";

		internal const string s_PerMille = "per-mille";

		internal const string s_Priority = "priority";

		internal const string s_ResultPrefix = "result-prefix";

		internal const string s_Select = "select";

		internal const string s_Space = "space";

		internal const string s_Standalone = "standalone";

		internal const string s_StylesheetPrefix = "stylesheet-prefix";

		internal const string s_Terminate = "terminate";

		internal const string s_Test = "test";

		internal const string s_Use = "use";

		internal const string s_UseAttributeSets = "use-attribute-sets";

		internal const string s_Value = "value";

		internal const string s_Version = "version";

		internal const string s_ZeroDigit = "zero-digit";

		internal const string s_Alphabetic = "alphabetic";

		internal const string s_Any = "any";

		internal const string s_Ascending = "ascending";

		internal const string s_Descending = "descending";

		internal const string s_HashDefault = "#default";

		internal const string s_Html = "html";

		internal const string s_LowerFirst = "lower-first";

		internal const string s_Multiple = "multiple";

		internal const string s_No = "no";

		internal const string s_Single = "single";

		internal const string s_Traditional = "traditional";

		internal const string s_UpperFirst = "upper-first";

		internal const string s_Xml = "xml";

		internal const string s_Yes = "yes";

		internal const string s_Vendor = "vendor";

		internal const string s_VendorUrl = "vendor-url";

		internal const string s_MsXsltNamespace = "urn:schemas-microsoft-com:xslt";

		internal const string s_Script = "script";

		internal const string s_Language = "language";

		internal const string s_ImplementsPrefix = "implements-prefix";

		private XmlNameTable _NameTable;

		private string _AtomEmpty;

		private string _AtomXsltNamespace;

		private string _AtomApplyImports;

		private string _AtomApplyTemplates;

		private string _AtomAttribute;

		private string _AtomAttributeSet;

		private string _AtomCallTemplate;

		private string _AtomChoose;

		private string _AtomComment;

		private string _AtomCopy;

		private string _AtomCopyOf;

		private string _AtomDecimalFormat;

		private string _AtomElement;

		private string _AtomFallback;

		private string _AtomForEach;

		private string _AtomIf;

		private string _AtomImport;

		private string _AtomInclude;

		private string _AtomKey;

		private string _AtomMessage;

		private string _AtomNamespaceAlias;

		private string _AtomNumber;

		private string _AtomOtherwise;

		private string _AtomOutput;

		private string _AtomParam;

		private string _AtomPreserveSpace;

		private string _AtomProcessingInstruction;

		private string _AtomSort;

		private string _AtomStripSpace;

		private string _AtomStylesheet;

		private string _AtomTemplate;

		private string _AtomText;

		private string _AtomTransform;

		private string _AtomValueOf;

		private string _AtomVariable;

		private string _AtomWhen;

		private string _AtomWithParam;

		private string _AtomCaseOrder;

		private string _AtomCdataSectionElements;

		private string _AtomCount;

		private string _AtomDataType;

		private string _AtomDecimalSeparator;

		private string _AtomDigit;

		private string _AtomDisableOutputEscaping;

		private string _AtomDoctypePublic;

		private string _AtomDoctypeSystem;

		private string _AtomElements;

		private string _AtomEncoding;

		private string _AtomExcludeResultPrefixes;

		private string _AtomExtensionElementPrefixes;

		private string _AtomFormat;

		private string _AtomFrom;

		private string _AtomGroupingSeparator;

		private string _AtomGroupingSize;

		private string _AtomHref;

		private string _AtomId;

		private string _AtomIndent;

		private string _AtomInfinity;

		private string _AtomLang;

		private string _AtomLetterValue;

		private string _AtomLevel;

		private string _AtomMatch;

		private string _AtomMediaType;

		private string _AtomMethod;

		private string _AtomMinusSign;

		private string _AtomMode;

		private string _AtomName;

		private string _AtomNamespace;

		private string _AtomNaN;

		private string _AtomOmitXmlDeclaration;

		private string _AtomOrder;

		private string _AtomPatternSeparator;

		private string _AtomPercent;

		private string _AtomPerMille;

		private string _AtomPriority;

		private string _AtomResultPrefix;

		private string _AtomSelect;

		private string _AtomStandalone;

		private string _AtomStylesheetPrefix;

		private string _AtomTerminate;

		private string _AtomTest;

		private string _AtomUse;

		private string _AtomUseAttributeSets;

		private string _AtomValue;

		private string _AtomVersion;

		private string _AtomZeroDigit;

		private string _AtomHashDefault;

		private string _AtomNo;

		private string _AtomYes;

		private string _AtomMsXsltNamespace;

		private string _AtomScript;

		private string _AtomLanguage;

		private string _AtomImplementsPrefix;

		internal string Empty => _AtomEmpty;

		internal string XsltNamespace => _AtomXsltNamespace;

		internal string ApplyImports
		{
			get
			{
				if (_AtomApplyImports == null)
				{
					_AtomApplyImports = _NameTable.Add("apply-imports");
				}
				return _AtomApplyImports;
			}
		}

		internal string ApplyTemplates => _AtomApplyTemplates;

		internal string Attribute
		{
			get
			{
				if (_AtomAttribute == null)
				{
					_AtomAttribute = _NameTable.Add("attribute");
				}
				return _AtomAttribute;
			}
		}

		internal string AttributeSet
		{
			get
			{
				if (_AtomAttributeSet == null)
				{
					_AtomAttributeSet = _NameTable.Add("attribute-set");
				}
				return _AtomAttributeSet;
			}
		}

		internal string CallTemplate
		{
			get
			{
				if (_AtomCallTemplate == null)
				{
					_AtomCallTemplate = _NameTable.Add("call-template");
				}
				return _AtomCallTemplate;
			}
		}

		internal string Choose => _AtomChoose;

		internal string Comment
		{
			get
			{
				if (_AtomComment == null)
				{
					_AtomComment = _NameTable.Add("comment");
				}
				return _AtomComment;
			}
		}

		internal string Copy
		{
			get
			{
				if (_AtomCopy == null)
				{
					_AtomCopy = _NameTable.Add("copy");
				}
				return _AtomCopy;
			}
		}

		internal string CopyOf
		{
			get
			{
				if (_AtomCopyOf == null)
				{
					_AtomCopyOf = _NameTable.Add("copy-of");
				}
				return _AtomCopyOf;
			}
		}

		internal string DecimalFormat
		{
			get
			{
				if (_AtomDecimalFormat == null)
				{
					_AtomDecimalFormat = _NameTable.Add("decimal-format");
				}
				return _AtomDecimalFormat;
			}
		}

		internal string Element
		{
			get
			{
				if (_AtomElement == null)
				{
					_AtomElement = _NameTable.Add("element");
				}
				return _AtomElement;
			}
		}

		internal string Fallback
		{
			get
			{
				if (_AtomFallback == null)
				{
					_AtomFallback = _NameTable.Add("fallback");
				}
				return _AtomFallback;
			}
		}

		internal string ForEach => _AtomForEach;

		internal string If => _AtomIf;

		internal string Import
		{
			get
			{
				if (_AtomImport == null)
				{
					_AtomImport = _NameTable.Add("import");
				}
				return _AtomImport;
			}
		}

		internal string Include
		{
			get
			{
				if (_AtomInclude == null)
				{
					_AtomInclude = _NameTable.Add("include");
				}
				return _AtomInclude;
			}
		}

		internal string Key
		{
			get
			{
				if (_AtomKey == null)
				{
					_AtomKey = _NameTable.Add("key");
				}
				return _AtomKey;
			}
		}

		internal string Message
		{
			get
			{
				if (_AtomMessage == null)
				{
					_AtomMessage = _NameTable.Add("message");
				}
				return _AtomMessage;
			}
		}

		internal string NamespaceAlias
		{
			get
			{
				if (_AtomNamespaceAlias == null)
				{
					_AtomNamespaceAlias = _NameTable.Add("namespace-alias");
				}
				return _AtomNamespaceAlias;
			}
		}

		internal string Number
		{
			get
			{
				if (_AtomNumber == null)
				{
					_AtomNumber = _NameTable.Add("number");
				}
				return _AtomNumber;
			}
		}

		internal string Otherwise => _AtomOtherwise;

		internal string Output
		{
			get
			{
				if (_AtomOutput == null)
				{
					_AtomOutput = _NameTable.Add("output");
				}
				return _AtomOutput;
			}
		}

		internal string Param
		{
			get
			{
				if (_AtomParam == null)
				{
					_AtomParam = _NameTable.Add("param");
				}
				return _AtomParam;
			}
		}

		internal string PreserveSpace
		{
			get
			{
				if (_AtomPreserveSpace == null)
				{
					_AtomPreserveSpace = _NameTable.Add("preserve-space");
				}
				return _AtomPreserveSpace;
			}
		}

		internal string ProcessingInstruction
		{
			get
			{
				if (_AtomProcessingInstruction == null)
				{
					_AtomProcessingInstruction = _NameTable.Add("processing-instruction");
				}
				return _AtomProcessingInstruction;
			}
		}

		internal string Sort
		{
			get
			{
				if (_AtomSort == null)
				{
					_AtomSort = _NameTable.Add("sort");
				}
				return _AtomSort;
			}
		}

		internal string StripSpace
		{
			get
			{
				if (_AtomStripSpace == null)
				{
					_AtomStripSpace = _NameTable.Add("strip-space");
				}
				return _AtomStripSpace;
			}
		}

		internal string Stylesheet => _AtomStylesheet;

		internal string Template => _AtomTemplate;

		internal string Text
		{
			get
			{
				if (_AtomText == null)
				{
					_AtomText = _NameTable.Add("text");
				}
				return _AtomText;
			}
		}

		internal string Transform => _AtomTransform;

		internal string ValueOf => _AtomValueOf;

		internal string Variable
		{
			get
			{
				if (_AtomVariable == null)
				{
					_AtomVariable = _NameTable.Add("variable");
				}
				return _AtomVariable;
			}
		}

		internal string When => _AtomWhen;

		internal string WithParam
		{
			get
			{
				if (_AtomWithParam == null)
				{
					_AtomWithParam = _NameTable.Add("with-param");
				}
				return _AtomWithParam;
			}
		}

		internal string CaseOrder
		{
			get
			{
				if (_AtomCaseOrder == null)
				{
					_AtomCaseOrder = _NameTable.Add("case-order");
				}
				return _AtomCaseOrder;
			}
		}

		internal string CdataSectionElements
		{
			get
			{
				if (_AtomCdataSectionElements == null)
				{
					_AtomCdataSectionElements = _NameTable.Add("cdata-section-elements");
				}
				return _AtomCdataSectionElements;
			}
		}

		internal string Count
		{
			get
			{
				if (_AtomCount == null)
				{
					_AtomCount = _NameTable.Add("count");
				}
				return _AtomCount;
			}
		}

		internal string DataType
		{
			get
			{
				if (_AtomDataType == null)
				{
					_AtomDataType = _NameTable.Add("data-type");
				}
				return _AtomDataType;
			}
		}

		internal string DecimalSeparator
		{
			get
			{
				if (_AtomDecimalSeparator == null)
				{
					_AtomDecimalSeparator = _NameTable.Add("decimal-separator");
				}
				return _AtomDecimalSeparator;
			}
		}

		internal string Digit
		{
			get
			{
				if (_AtomDigit == null)
				{
					_AtomDigit = _NameTable.Add("digit");
				}
				return _AtomDigit;
			}
		}

		internal string DisableOutputEscaping
		{
			get
			{
				if (_AtomDisableOutputEscaping == null)
				{
					_AtomDisableOutputEscaping = _NameTable.Add("disable-output-escaping");
				}
				return _AtomDisableOutputEscaping;
			}
		}

		internal string DoctypePublic
		{
			get
			{
				if (_AtomDoctypePublic == null)
				{
					_AtomDoctypePublic = _NameTable.Add("doctype-public");
				}
				return _AtomDoctypePublic;
			}
		}

		internal string DoctypeSystem
		{
			get
			{
				if (_AtomDoctypeSystem == null)
				{
					_AtomDoctypeSystem = _NameTable.Add("doctype-system");
				}
				return _AtomDoctypeSystem;
			}
		}

		internal string Elements
		{
			get
			{
				if (_AtomElements == null)
				{
					_AtomElements = _NameTable.Add("elements");
				}
				return _AtomElements;
			}
		}

		internal string Encoding
		{
			get
			{
				if (_AtomEncoding == null)
				{
					_AtomEncoding = _NameTable.Add("encoding");
				}
				return _AtomEncoding;
			}
		}

		internal string ExcludeResultPrefixes
		{
			get
			{
				if (_AtomExcludeResultPrefixes == null)
				{
					_AtomExcludeResultPrefixes = _NameTable.Add("exclude-result-prefixes");
				}
				return _AtomExcludeResultPrefixes;
			}
		}

		internal string ExtensionElementPrefixes
		{
			get
			{
				if (_AtomExtensionElementPrefixes == null)
				{
					_AtomExtensionElementPrefixes = _NameTable.Add("extension-element-prefixes");
				}
				return _AtomExtensionElementPrefixes;
			}
		}

		internal string Format
		{
			get
			{
				if (_AtomFormat == null)
				{
					_AtomFormat = _NameTable.Add("format");
				}
				return _AtomFormat;
			}
		}

		internal string From
		{
			get
			{
				if (_AtomFrom == null)
				{
					_AtomFrom = _NameTable.Add("from");
				}
				return _AtomFrom;
			}
		}

		internal string GroupingSeparator
		{
			get
			{
				if (_AtomGroupingSeparator == null)
				{
					_AtomGroupingSeparator = _NameTable.Add("grouping-separator");
				}
				return _AtomGroupingSeparator;
			}
		}

		internal string GroupingSize
		{
			get
			{
				if (_AtomGroupingSize == null)
				{
					_AtomGroupingSize = _NameTable.Add("grouping-size");
				}
				return _AtomGroupingSize;
			}
		}

		internal string Href
		{
			get
			{
				if (_AtomHref == null)
				{
					_AtomHref = _NameTable.Add("href");
				}
				return _AtomHref;
			}
		}

		internal string Id
		{
			get
			{
				if (_AtomId == null)
				{
					_AtomId = _NameTable.Add("id");
				}
				return _AtomId;
			}
		}

		internal string Indent
		{
			get
			{
				if (_AtomIndent == null)
				{
					_AtomIndent = _NameTable.Add("indent");
				}
				return _AtomIndent;
			}
		}

		internal string Infinity
		{
			get
			{
				if (_AtomInfinity == null)
				{
					_AtomInfinity = _NameTable.Add("infinity");
				}
				return _AtomInfinity;
			}
		}

		internal string Lang
		{
			get
			{
				if (_AtomLang == null)
				{
					_AtomLang = _NameTable.Add("lang");
				}
				return _AtomLang;
			}
		}

		internal string LetterValue
		{
			get
			{
				if (_AtomLetterValue == null)
				{
					_AtomLetterValue = _NameTable.Add("letter-value");
				}
				return _AtomLetterValue;
			}
		}

		internal string Level
		{
			get
			{
				if (_AtomLevel == null)
				{
					_AtomLevel = _NameTable.Add("level");
				}
				return _AtomLevel;
			}
		}

		internal string Match => _AtomMatch;

		internal string MediaType
		{
			get
			{
				if (_AtomMediaType == null)
				{
					_AtomMediaType = _NameTable.Add("media-type");
				}
				return _AtomMediaType;
			}
		}

		internal string Method
		{
			get
			{
				if (_AtomMethod == null)
				{
					_AtomMethod = _NameTable.Add("method");
				}
				return _AtomMethod;
			}
		}

		internal string MinusSign
		{
			get
			{
				if (_AtomMinusSign == null)
				{
					_AtomMinusSign = _NameTable.Add("minus-sign");
				}
				return _AtomMinusSign;
			}
		}

		internal string Mode
		{
			get
			{
				if (_AtomMode == null)
				{
					_AtomMode = _NameTable.Add("mode");
				}
				return _AtomMode;
			}
		}

		internal string Name => _AtomName;

		internal string Namespace
		{
			get
			{
				if (_AtomNamespace == null)
				{
					_AtomNamespace = _NameTable.Add("namespace");
				}
				return _AtomNamespace;
			}
		}

		internal string NaN
		{
			get
			{
				if (_AtomNaN == null)
				{
					_AtomNaN = _NameTable.Add("NaN");
				}
				return _AtomNaN;
			}
		}

		internal string OmitXmlDeclaration
		{
			get
			{
				if (_AtomOmitXmlDeclaration == null)
				{
					_AtomOmitXmlDeclaration = _NameTable.Add("omit-xml-declaration");
				}
				return _AtomOmitXmlDeclaration;
			}
		}

		internal string Order
		{
			get
			{
				if (_AtomOrder == null)
				{
					_AtomOrder = _NameTable.Add("order");
				}
				return _AtomOrder;
			}
		}

		internal string PatternSeparator
		{
			get
			{
				if (_AtomPatternSeparator == null)
				{
					_AtomPatternSeparator = _NameTable.Add("pattern-separator");
				}
				return _AtomPatternSeparator;
			}
		}

		internal string Percent
		{
			get
			{
				if (_AtomPercent == null)
				{
					_AtomPercent = _NameTable.Add("percent");
				}
				return _AtomPercent;
			}
		}

		internal string PerMille
		{
			get
			{
				if (_AtomPerMille == null)
				{
					_AtomPerMille = _NameTable.Add("per-mille");
				}
				return _AtomPerMille;
			}
		}

		internal string Priority
		{
			get
			{
				if (_AtomPriority == null)
				{
					_AtomPriority = _NameTable.Add("priority");
				}
				return _AtomPriority;
			}
		}

		internal string ResultPrefix
		{
			get
			{
				if (_AtomResultPrefix == null)
				{
					_AtomResultPrefix = _NameTable.Add("result-prefix");
				}
				return _AtomResultPrefix;
			}
		}

		internal string Select => _AtomSelect;

		internal string Standalone
		{
			get
			{
				if (_AtomStandalone == null)
				{
					_AtomStandalone = _NameTable.Add("standalone");
				}
				return _AtomStandalone;
			}
		}

		internal string StylesheetPrefix
		{
			get
			{
				if (_AtomStylesheetPrefix == null)
				{
					_AtomStylesheetPrefix = _NameTable.Add("stylesheet-prefix");
				}
				return _AtomStylesheetPrefix;
			}
		}

		internal string Terminate
		{
			get
			{
				if (_AtomTerminate == null)
				{
					_AtomTerminate = _NameTable.Add("terminate");
				}
				return _AtomTerminate;
			}
		}

		internal string Test => _AtomTest;

		internal string Use
		{
			get
			{
				if (_AtomUse == null)
				{
					_AtomUse = _NameTable.Add("use");
				}
				return _AtomUse;
			}
		}

		internal string UseAttributeSets
		{
			get
			{
				if (_AtomUseAttributeSets == null)
				{
					_AtomUseAttributeSets = _NameTable.Add("use-attribute-sets");
				}
				return _AtomUseAttributeSets;
			}
		}

		internal string Value
		{
			get
			{
				if (_AtomValue == null)
				{
					_AtomValue = _NameTable.Add("value");
				}
				return _AtomValue;
			}
		}

		internal string Version
		{
			get
			{
				if (_AtomVersion == null)
				{
					_AtomVersion = _NameTable.Add("version");
				}
				return _AtomVersion;
			}
		}

		internal string ZeroDigit
		{
			get
			{
				if (_AtomZeroDigit == null)
				{
					_AtomZeroDigit = _NameTable.Add("zero-digit");
				}
				return _AtomZeroDigit;
			}
		}

		internal string HashDefault
		{
			get
			{
				if (_AtomHashDefault == null)
				{
					_AtomHashDefault = _NameTable.Add("#default");
				}
				return _AtomHashDefault;
			}
		}

		internal string No
		{
			get
			{
				if (_AtomNo == null)
				{
					_AtomNo = _NameTable.Add("no");
				}
				return _AtomNo;
			}
		}

		internal string Yes
		{
			get
			{
				if (_AtomYes == null)
				{
					_AtomYes = _NameTable.Add("yes");
				}
				return _AtomYes;
			}
		}

		internal string MsXsltNamespace => _AtomMsXsltNamespace;

		internal string Script => _AtomScript;

		internal string Language
		{
			get
			{
				if (_AtomLanguage == null)
				{
					_AtomLanguage = _NameTable.Add("language");
				}
				return _AtomLanguage;
			}
		}

		internal string ImplementsPrefix
		{
			get
			{
				if (_AtomImplementsPrefix == null)
				{
					_AtomImplementsPrefix = _NameTable.Add("implements-prefix");
				}
				return _AtomImplementsPrefix;
			}
		}

		internal Keywords(XmlNameTable nameTable)
		{
			_NameTable = nameTable;
		}

		internal void LookupKeywords()
		{
			_AtomEmpty = _NameTable.Add(string.Empty);
			_AtomXsltNamespace = _NameTable.Add("http://www.w3.org/1999/XSL/Transform");
			_AtomApplyTemplates = _NameTable.Add("apply-templates");
			_AtomChoose = _NameTable.Add("choose");
			_AtomForEach = _NameTable.Add("for-each");
			_AtomIf = _NameTable.Add("if");
			_AtomOtherwise = _NameTable.Add("otherwise");
			_AtomStylesheet = _NameTable.Add("stylesheet");
			_AtomTemplate = _NameTable.Add("template");
			_AtomTransform = _NameTable.Add("transform");
			_AtomValueOf = _NameTable.Add("value-of");
			_AtomWhen = _NameTable.Add("when");
			_AtomMatch = _NameTable.Add("match");
			_AtomName = _NameTable.Add("name");
			_AtomSelect = _NameTable.Add("select");
			_AtomTest = _NameTable.Add("test");
			_AtomMsXsltNamespace = _NameTable.Add("urn:schemas-microsoft-com:xslt");
			_AtomScript = _NameTable.Add("script");
		}

		internal static bool Equals(string strA, string strB)
		{
			return (object)strA == strB;
		}

		internal static bool Compare(string strA, string strB)
		{
			return string.Equals(strA, strB);
		}

		[Conditional("DEBUG")]
		private void CheckKeyword(string keyword)
		{
		}
	}
	internal class NamespaceDecl
	{
		private string prefix;

		private string nsUri;

		private string prevDefaultNsUri;

		private NamespaceDecl next;

		internal string Prefix => prefix;

		internal string Uri => nsUri;

		internal string PrevDefaultNsUri => prevDefaultNsUri;

		internal NamespaceDecl Next => next;

		internal NamespaceDecl(string prefix, string nsUri, string prevDefaultNsUri, NamespaceDecl next)
		{
			Init(prefix, nsUri, prevDefaultNsUri, next);
		}

		internal void Init(string prefix, string nsUri, string prevDefaultNsUri, NamespaceDecl next)
		{
			this.prefix = prefix;
			this.nsUri = nsUri;
			this.prevDefaultNsUri = prevDefaultNsUri;
			this.next = next;
		}
	}
	internal class NamespaceEvent : Event
	{
		private string namespaceUri;

		private string name;

		public NamespaceEvent(NavigatorInput input)
		{
			namespaceUri = input.Value;
			name = input.LocalName;
		}

		public override void ReplaceNamespaceAlias(Compiler compiler)
		{
			if (namespaceUri.Length == 0)
			{
				return;
			}
			NamespaceInfo namespaceInfo = compiler.FindNamespaceAlias(namespaceUri);
			if (namespaceInfo != null)
			{
				namespaceUri = namespaceInfo.nameSpace;
				if (namespaceInfo.prefix != null)
				{
					name = namespaceInfo.prefix;
				}
			}
		}

		public override bool Output(Processor processor, ActionFrame frame)
		{
			processor.BeginEvent(XPathNodeType.Namespace, null, name, namespaceUri, empty: false);
			processor.EndEvent(XPathNodeType.Namespace);
			return true;
		}
	}
	internal class NavigatorInput
	{
		private XPathNavigator _Navigator;

		private PositionInfo _PositionInfo;

		private InputScopeManager _Manager;

		private NavigatorInput _Next;

		private string _Href;

		private Keywords _Atoms;

		internal NavigatorInput Next
		{
			get
			{
				return _Next;
			}
			set
			{
				_Next = value;
			}
		}

		internal string Href => _Href;

		internal Keywords Atoms => _Atoms;

		internal XPathNavigator Navigator => _Navigator;

		internal InputScopeManager InputScopeManager => _Manager;

		internal int LineNumber => _PositionInfo.LineNumber;

		internal int LinePosition => _PositionInfo.LinePosition;

		internal XPathNodeType NodeType => _Navigator.NodeType;

		internal string Name => _Navigator.Name;

		internal string LocalName => _Navigator.LocalName;

		internal string NamespaceURI => _Navigator.NamespaceURI;

		internal string Prefix => _Navigator.Prefix;

		internal string Value => _Navigator.Value;

		internal bool IsEmptyTag => _Navigator.IsEmptyElement;

		internal string BaseURI => _Navigator.BaseURI;

		internal bool Advance()
		{
			return _Navigator.MoveToNext();
		}

		internal bool Recurse()
		{
			return _Navigator.MoveToFirstChild();
		}

		internal bool ToParent()
		{
			return _Navigator.MoveToParent();
		}

		internal void Close()
		{
			_Navigator = null;
			_PositionInfo = null;
		}

		internal bool MoveToFirstAttribute()
		{
			return _Navigator.MoveToFirstAttribute();
		}

		internal bool MoveToNextAttribute()
		{
			return _Navigator.MoveToNextAttribute();
		}

		internal bool MoveToFirstNamespace()
		{
			return _Navigator.MoveToFirstNamespace(XPathNamespaceScope.ExcludeXml);
		}

		internal bool MoveToNextNamespace()
		{
			return _Navigator.MoveToNextNamespace(XPathNamespaceScope.ExcludeXml);
		}

		internal NavigatorInput(XPathNavigator navigator, string baseUri, InputScope rootScope)
		{
			if (navigator == null)
			{
				throw new ArgumentNullException("navigator");
			}
			if (baseUri == null)
			{
				throw new ArgumentNullException("baseUri");
			}
			_Next = null;
			_Href = baseUri;
			_Atoms = new Keywords(navigator.NameTable);
			_Atoms.LookupKeywords();
			_Navigator = navigator;
			_Manager = new InputScopeManager(_Navigator, rootScope);
			_PositionInfo = PositionInfo.GetPositionInfo(_Navigator);
			if (NodeType == XPathNodeType.Root)
			{
				_Navigator.MoveToFirstChild();
			}
		}

		internal NavigatorInput(XPathNavigator navigator)
			: this(navigator, navigator.BaseURI, null)
		{
		}

		[Conditional("DEBUG")]
		internal void AssertInput()
		{
		}
	}
	internal interface RecordOutput
	{
		Processor.OutputResult RecordDone(RecordBuilder record);

		void TheEnd();
	}
	internal class NavigatorOutput : RecordOutput
	{
		private XPathDocument doc;

		private int documentIndex;

		private XmlRawWriter wr;

		internal XPathNavigator Navigator => ((IXPathNavigable)doc).CreateNavigator();

		internal NavigatorOutput(string baseUri)
		{
			doc = new XPathDocument();
			wr = doc.LoadFromWriter(XPathDocument.LoadFlags.AtomizeNames, baseUri);
		}

		public Processor.OutputResult RecordDone(RecordBuilder record)
		{
			BuilderInfo mainNode = record.MainNode;
			documentIndex++;
			switch (mainNode.NodeType)
			{
			case XmlNodeType.Element:
			{
				wr.WriteStartElement(mainNode.Prefix, mainNode.LocalName, mainNode.NamespaceURI);
				for (int i = 0; i < record.AttributeCount; i++)
				{
					documentIndex++;
					BuilderInfo builderInfo = (BuilderInfo)record.AttributeList[i];
					if (builderInfo.NamespaceURI == "http://www.w3.org/2000/xmlns/")
					{
						if (builderInfo.Prefix.Length == 0)
						{
							wr.WriteNamespaceDeclaration(string.Empty, builderInfo.Value);
						}
						else
						{
							wr.WriteNamespaceDeclaration(builderInfo.LocalName, builderInfo.Value);
						}
					}
					else
					{
						wr.WriteAttributeString(builderInfo.Prefix, builderInfo.LocalName, builderInfo.NamespaceURI, builderInfo.Value);
					}
				}
				wr.StartElementContent();
				if (mainNode.IsEmptyTag)
				{
					wr.WriteEndElement(mainNode.Prefix, mainNode.LocalName, mainNode.NamespaceURI);
				}
				break;
			}
			case XmlNodeType.Text:
				wr.WriteString(mainNode.Value);
				break;
			case XmlNodeType.SignificantWhitespace:
				wr.WriteString(mainNode.Value);
				break;
			case XmlNodeType.ProcessingInstruction:
				wr.WriteProcessingInstruction(mainNode.LocalName, mainNode.Value);
				break;
			case XmlNodeType.Comment:
				wr.WriteComment(mainNode.Value);
				break;
			case XmlNodeType.EndElement:
				wr.WriteEndElement(mainNode.Prefix, mainNode.LocalName, mainNode.NamespaceURI);
				break;
			}
			record.Reset();
			return Processor.OutputResult.Continue;
		}

		public void TheEnd()
		{
			wr.Close();
		}
	}
	internal class OutKeywords
	{
		private string _AtomEmpty;

		private string _AtomLang;

		private string _AtomSpace;

		private string _AtomXmlns;

		private string _AtomXml;

		private string _AtomXmlNamespace;

		private string _AtomXmlnsNamespace;

		internal string Empty => _AtomEmpty;

		internal string Lang => _AtomLang;

		internal string Space => _AtomSpace;

		internal string Xmlns => _AtomXmlns;

		internal string Xml => _AtomXml;

		internal string XmlNamespace => _AtomXmlNamespace;

		internal string XmlnsNamespace => _AtomXmlnsNamespace;

		internal OutKeywords(XmlNameTable nameTable)
		{
			_AtomEmpty = nameTable.Add(string.Empty);
			_AtomLang = nameTable.Add("lang");
			_AtomSpace = nameTable.Add("space");
			_AtomXmlns = nameTable.Add("xmlns");
			_AtomXml = nameTable.Add("xml");
			_AtomXmlNamespace = nameTable.Add("http://www.w3.org/XML/1998/namespace");
			_AtomXmlnsNamespace = nameTable.Add("http://www.w3.org/2000/xmlns/");
		}

		[Conditional("DEBUG")]
		private void CheckKeyword(string keyword)
		{
		}
	}
	internal class OutputScope : DocumentScope
	{
		private string name;

		private string nsUri;

		private string prefix;

		private XmlSpace space;

		private string lang;

		private bool mixed;

		private bool toCData;

		private HtmlElementProps htmlElementProps;

		internal string Name => name;

		internal string Namespace => nsUri;

		internal string Prefix
		{
			get
			{
				return prefix;
			}
			set
			{
				prefix = value;
			}
		}

		internal XmlSpace Space
		{
			get
			{
				return space;
			}
			set
			{
				space = value;
			}
		}

		internal string Lang
		{
			get
			{
				return lang;
			}
			set
			{
				lang = value;
			}
		}

		internal bool Mixed
		{
			get
			{
				return mixed;
			}
			set
			{
				mixed = value;
			}
		}

		internal bool ToCData
		{
			get
			{
				return toCData;
			}
			set
			{
				toCData = value;
			}
		}

		internal HtmlElementProps HtmlElementProps
		{
			get
			{
				return htmlElementProps;
			}
			set
			{
				htmlElementProps = value;
			}
		}

		internal OutputScope()
		{
			Init(string.Empty, string.Empty, string.Empty, XmlSpace.None, string.Empty, mixed: false);
		}

		internal void Init(string name, string nspace, string prefix, XmlSpace space, string lang, bool mixed)
		{
			scopes = null;
			this.name = name;
			nsUri = nspace;
			this.prefix = prefix;
			this.space = space;
			this.lang = lang;
			this.mixed = mixed;
			toCData = false;
			htmlElementProps = null;
		}

		internal bool FindPrefix(string urn, out string prefix)
		{
			for (NamespaceDecl next = scopes; next != null; next = next.Next)
			{
				if (Keywords.Equals(next.Uri, urn) && next.Prefix != null && next.Prefix.Length > 0)
				{
					prefix = next.Prefix;
					return true;
				}
			}
			prefix = string.Empty;
			return false;
		}
	}
	internal class OutputScopeManager
	{
		private const int STACK_INCREMENT = 10;

		private HWStack elementScopesStack;

		private string defaultNS;

		private OutKeywords atoms;

		private XmlNameTable nameTable;

		private int prefixIndex;

		internal string DefaultNamespace => defaultNS;

		internal OutputScope CurrentElementScope => (OutputScope)elementScopesStack.Peek();

		internal XmlSpace XmlSpace => CurrentElementScope.Space;

		internal string XmlLang => CurrentElementScope.Lang;

		internal OutputScopeManager(XmlNameTable nameTable, OutKeywords atoms)
		{
			elementScopesStack = new HWStack(10);
			this.nameTable = nameTable;
			this.atoms = atoms;
			defaultNS = this.atoms.Empty;
			OutputScope outputScope = (OutputScope)elementScopesStack.Push();
			if (outputScope == null)
			{
				outputScope = new OutputScope();
				elementScopesStack.AddToTop(outputScope);
			}
			outputScope.Init(string.Empty, string.Empty, string.Empty, XmlSpace.None, string.Empty, mixed: false);
		}

		internal void PushNamespace(string prefix, string nspace)
		{
			CurrentElementScope.AddNamespace(prefix, nspace, defaultNS);
			if (prefix == null || prefix.Length == 0)
			{
				defaultNS = nspace;
			}
		}

		internal void PushScope(string name, string nspace, string prefix)
		{
			OutputScope currentElementScope = CurrentElementScope;
			OutputScope outputScope = (OutputScope)elementScopesStack.Push();
			if (outputScope == null)
			{
				outputScope = new OutputScope();
				elementScopesStack.AddToTop(outputScope);
			}
			outputScope.Init(name, nspace, prefix, currentElementScope.Space, currentElementScope.Lang, currentElementScope.Mixed);
		}

		internal void PopScope()
		{
			OutputScope outputScope = (OutputScope)elementScopesStack.Pop();
			for (NamespaceDecl namespaceDecl = outputScope.Scopes; namespaceDecl != null; namespaceDecl = namespaceDecl.Next)
			{
				defaultNS = namespaceDecl.PrevDefaultNsUri;
			}
		}

		internal string ResolveNamespace(string prefix)
		{
			bool thisScope;
			return ResolveNamespace(prefix, out thisScope);
		}

		internal string ResolveNamespace(string prefix, out bool thisScope)
		{
			thisScope = true;
			if (prefix == null || prefix.Length == 0)
			{
				return defaultNS;
			}
			if (Keywords.Equals(prefix, atoms.Xml))
			{
				return atoms.XmlNamespace;
			}
			if (Keywords.Equals(prefix, atoms.Xmlns))
			{
				return atoms.XmlnsNamespace;
			}
			for (int num = elementScopesStack.Length - 1; num >= 0; num--)
			{
				OutputScope outputScope = (OutputScope)elementScopesStack[num];
				string text = outputScope.ResolveAtom(prefix);
				if (text != null)
				{
					thisScope = num == elementScopesStack.Length - 1;
					return text;
				}
			}
			return null;
		}

		internal bool FindPrefix(string nspace, out string prefix)
		{
			int num = elementScopesStack.Length - 1;
			while (0 <= num)
			{
				OutputScope outputScope = (OutputScope)elementScopesStack[num];
				string prefix2 = null;
				if (outputScope.FindPrefix(nspace, out prefix2))
				{
					string text = ResolveNamespace(prefix2);
					if (text == null || !Keywords.Equals(text, nspace))
					{
						break;
					}
					prefix = prefix2;
					return true;
				}
				num--;
			}
			prefix = null;
			return false;
		}

		internal string GeneratePrefix(string format)
		{
			string array;
			do
			{
				array = string.Format(CultureInfo.InvariantCulture, format, prefixIndex++);
			}
			while (nameTable.Get(array) != null);
			return nameTable.Add(array);
		}
	}
	internal sealed class PrefixQName
	{
		public string Prefix;

		public string Name;

		public string Namespace;

		internal void ClearPrefix()
		{
			Prefix = string.Empty;
		}

		internal void SetQName(string qname)
		{
			ParseQualifiedName(qname, out Prefix, out Name);
		}

		private static string ParseNCName(string qname, ref int position)
		{
			int length = qname.Length;
			int num = position;
			XmlCharType instance = XmlCharType.Instance;
			if (length == position || !instance.IsStartNCNameChar(qname[position]))
			{
				throw XsltException.Create("Xslt_InvalidQName", qname);
			}
			position++;
			while (position < length && instance.IsNCNameChar(qname[position]))
			{
				position++;
			}
			return qname.Substring(num, position - num);
		}

		public static void ParseQualifiedName(string qname, out string prefix, out string local)
		{
			prefix = string.Empty;
			local = string.Empty;
			int position = 0;
			local = ParseNCName(qname, ref position);
			if (position < qname.Length)
			{
				if (qname[position] == ':')
				{
					position++;
					prefix = local;
					local = ParseNCName(qname, ref position);
				}
				if (position < qname.Length)
				{
					throw XsltException.Create("Xslt_InvalidQName", qname);
				}
			}
		}

		public static bool ValidatePrefix(string prefix)
		{
			if (prefix.Length == 0)
			{
				return false;
			}
			XmlCharType instance = XmlCharType.Instance;
			if (!instance.IsStartNCNameChar(prefix[0]))
			{
				return false;
			}
			for (int i = 1; i < prefix.Length; i++)
			{
				if (!instance.IsNCNameChar(prefix[i]))
				{
					return false;
				}
			}
			return true;
		}
	}
}
namespace System.Xml.Xsl.XsltOld.Debugger
{
	internal interface IXsltProcessor
	{
		int StackDepth { get; }

		IStackFrame GetStackFrame(int depth);
	}
}
namespace System.Xml.Xsl.XsltOld
{
	internal sealed class Processor : IXsltProcessor
	{
		internal enum ExecResult
		{
			Continue,
			Interrupt,
			Done
		}

		internal enum OutputResult
		{
			Continue,
			Interrupt,
			Overflow,
			Error,
			Ignore
		}

		internal class DebuggerFrame
		{
			internal ActionFrame actionFrame;

			internal XmlQualifiedName currentMode;
		}

		private const int StackIncrement = 10;

		private ExecResult execResult;

		private Stylesheet stylesheet;

		private RootAction rootAction;

		private Key[] keyList;

		private List<TheQuery> queryStore;

		public PermissionSet permissions;

		private XPathNavigator document;

		private HWStack actionStack;

		private HWStack debuggerStack;

		private StringBuilder sharedStringBuilder;

		private int ignoreLevel;

		private StateMachine xsm;

		private RecordBuilder builder;

		private XsltOutput output;

		private XmlNameTable nameTable = new NameTable();

		private XmlResolver resolver;

		private XsltArgumentList args;

		private Hashtable scriptExtensions;

		private ArrayList numberList;

		private TemplateLookupAction templateLookup = new TemplateLookupAction();

		private IXsltDebugger debugger;

		private Query[] queryList;

		private ArrayList sortArray;

		private Hashtable documentCache;

		private XsltCompileContext valueOfContext;

		private XsltCompileContext matchesContext;

		internal XPathNavigator Current => ((ActionFrame)actionStack.Peek())?.Node;

		internal ExecResult ExecutionResult
		{
			get
			{
				return execResult;
			}
			set
			{
				execResult = value;
			}
		}

		internal Stylesheet Stylesheet => stylesheet;

		internal XmlResolver Resolver => resolver;

		internal ArrayList SortArray => sortArray;

		internal Key[] KeyList => keyList;

		internal RootAction RootAction => rootAction;

		internal XPathNavigator Document => document;

		internal ArrayList NumberList
		{
			get
			{
				if (numberList == null)
				{
					numberList = new ArrayList();
				}
				return numberList;
			}
		}

		internal IXsltDebugger Debugger => debugger;

		internal HWStack ActionStack => actionStack;

		internal RecordBuilder Builder => builder;

		internal XsltOutput Output => output;

		internal XmlNameTable NameTable => nameTable;

		internal bool CanContinue => execResult == ExecResult.Continue;

		internal bool ExecutionDone => execResult == ExecResult.Done;

		int IXsltProcessor.StackDepth => debuggerStack.Length;

		internal XPathNavigator GetNavigator(Uri ruri)
		{
			XPathNavigator xPathNavigator = null;
			if (documentCache != null)
			{
				if (documentCache[ruri] is XPathNavigator xPathNavigator2)
				{
					return xPathNavigator2.Clone();
				}
			}
			else
			{
				documentCache = new Hashtable();
			}
			object entity = resolver.GetEntity(ruri, null, null);
			if (entity is Stream)
			{
				XmlTextReaderImpl xmlTextReaderImpl = new XmlTextReaderImpl(ruri.ToString(), (Stream)entity);
				xmlTextReaderImpl.XmlResolver = resolver;
				xPathNavigator = ((IXPathNavigable)Compiler.LoadDocument(xmlTextReaderImpl)).CreateNavigator();
			}
			else
			{
				if (!(entity is XPathNavigator))
				{
					throw XsltException.Create("Xslt_CantResolve", ruri.ToString());
				}
				xPathNavigator = (XPathNavigator)entity;
			}
			documentCache[ruri] = xPathNavigator.Clone();
			return xPathNavigator;
		}

		internal void AddSort(Sort sortinfo)
		{
			sortArray.Add(sortinfo);
		}

		internal void InitSortArray()
		{
			if (sortArray == null)
			{
				sortArray = new ArrayList();
			}
			else
			{
				sortArray.Clear();
			}
		}

		internal object GetGlobalParameter(XmlQualifiedName qname)
		{
			object obj = args.GetParam(qname.Name, qname.Namespace);
			if (obj == null)
			{
				return null;
			}
			if (!(obj is XPathNodeIterator) && !(obj is XPathNavigator) && !(obj is bool) && !(obj is double) && !(obj is string))
			{
				obj = ((!(obj is short) && !(obj is ushort) && !(obj is int) && !(obj is uint) && !(obj is long) && !(obj is ulong) && !(obj is float) && !(obj is decimal)) ? obj.ToString() : ((object)XmlConvert.ToXPathDouble(obj)));
			}
			return obj;
		}

		internal object GetExtensionObject(string nsUri)
		{
			return args.GetExtensionObject(nsUri);
		}

		internal object GetScriptObject(string nsUri)
		{
			return scriptExtensions[nsUri];
		}

		internal StringBuilder GetSharedStringBuilder()
		{
			if (sharedStringBuilder == null)
			{
				sharedStringBuilder = new StringBuilder();
			}
			else
			{
				sharedStringBuilder.Length = 0;
			}
			return sharedStringBuilder;
		}

		internal void ReleaseSharedStringBuilder()
		{
		}

		public Processor(XPathNavigator doc, XsltArgumentList args, XmlResolver resolver, Stylesheet stylesheet, List<TheQuery> queryStore, RootAction rootAction, IXsltDebugger debugger)
		{
			this.stylesheet = stylesheet;
			this.queryStore = queryStore;
			this.rootAction = rootAction;
			queryList = new Query[queryStore.Count];
			for (int i = 0; i < queryStore.Count; i++)
			{
				queryList[i] = Query.Clone(queryStore[i].CompiledQuery.QueryTree);
			}
			xsm = new StateMachine();
			document = doc;
			builder = null;
			actionStack = new HWStack(10);
			output = this.rootAction.Output;
			permissions = this.rootAction.permissions;
			this.resolver = ((resolver != null) ? resolver : new XmlNullResolver());
			this.args = ((args != null) ? args : new XsltArgumentList());
			this.debugger = debugger;
			if (this.debugger != null)
			{
				debuggerStack = new HWStack(10, 1000);
				templateLookup = new TemplateLookupActionDbg();
			}
			if (this.rootAction.KeyList != null)
			{
				keyList = new Key[this.rootAction.KeyList.Count];
				for (int j = 0; j < keyList.Length; j++)
				{
					keyList[j] = this.rootAction.KeyList[j].Clone();
				}
			}
			scriptExtensions = new Hashtable(this.stylesheet.ScriptObjectTypes.Count);
			foreach (DictionaryEntry scriptObjectType in this.stylesheet.ScriptObjectTypes)
			{
				string text = (string)scriptObjectType.Key;
				if (GetExtensionObject(text) != null)
				{
					throw XsltException.Create("Xslt_ScriptDub", text);
				}
				scriptExtensions.Add(text, Activator.CreateInstance((Type)scriptObjectType.Value, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance, null, null, null));
			}
			PushActionFrame(this.rootAction, null);
		}

		public ReaderOutput StartReader()
		{
			ReaderOutput result = new ReaderOutput(this);
			builder = new RecordBuilder(result, nameTable);
			return result;
		}

		public void Execute(Stream stream)
		{
			RecordOutput recordOutput = null;
			switch (output.Method)
			{
			case XsltOutput.OutputMethod.Text:
				recordOutput = new TextOnlyOutput(this, stream);
				break;
			case XsltOutput.OutputMethod.Xml:
			case XsltOutput.OutputMethod.Html:
			case XsltOutput.OutputMethod.Other:
			case XsltOutput.OutputMethod.Unknown:
				recordOutput = new TextOutput(this, stream);
				break;
			}
			builder = new RecordBuilder(recordOutput, nameTable);
			Execute();
		}

		public void Execute(TextWriter writer)
		{
			RecordOutput recordOutput = null;
			switch (output.Method)
			{
			case XsltOutput.OutputMethod.Text:
				recordOutput = new TextOnlyOutput(this, writer);
				break;
			case XsltOutput.OutputMethod.Xml:
			case XsltOutput.OutputMethod.Html:
			case XsltOutput.OutputMethod.Other:
			case XsltOutput.OutputMethod.Unknown:
				recordOutput = new TextOutput(this, writer);
				break;
			}
			builder = new RecordBuilder(recordOutput, nameTable);
			Execute();
		}

		public void Execute(XmlWriter writer)
		{
			builder = new RecordBuilder(new WriterOutput(this, writer), nameTable);
			Execute();
		}

		internal void Execute()
		{
			while (execResult == ExecResult.Continue)
			{
				ActionFrame actionFrame = (ActionFrame)actionStack.Peek();
				if (actionFrame == null)
				{
					builder.TheEnd();
					ExecutionResult = ExecResult.Done;
					break;
				}
				if (actionFrame.Execute(this))
				{
					actionStack.Pop();
				}
			}
			if (execResult == ExecResult.Interrupt)
			{
				execResult = ExecResult.Continue;
			}
		}

		internal ActionFrame PushNewFrame()
		{
			ActionFrame actionFrame = (ActionFrame)actionStack.Peek();
			ActionFrame actionFrame2 = (ActionFrame)actionStack.Push();
			if (actionFrame2 == null)
			{
				actionFrame2 = new ActionFrame();
				actionStack.AddToTop(actionFrame2);
			}
			if (actionFrame != null)
			{
				actionFrame2.Inherit(actionFrame);
			}
			return actionFrame2;
		}

		internal void PushActionFrame(Action action, XPathNodeIterator nodeSet)
		{
			ActionFrame actionFrame = PushNewFrame();
			actionFrame.Init(action, nodeSet);
		}

		internal void PushActionFrame(ActionFrame container)
		{
			PushActionFrame(container, container.NodeSet);
		}

		internal void PushActionFrame(ActionFrame container, XPathNodeIterator nodeSet)
		{
			ActionFrame actionFrame = PushNewFrame();
			actionFrame.Init(container, nodeSet);
		}

		internal void PushTemplateLookup(XPathNodeIterator nodeSet, XmlQualifiedName mode, Stylesheet importsOf)
		{
			templateLookup.Initialize(mode, importsOf);
			PushActionFrame(templateLookup, nodeSet);
		}

		internal string GetQueryExpression(int key)
		{
			return queryStore[key].CompiledQuery.Expression;
		}

		internal Query GetCompiledQuery(int key)
		{
			TheQuery theQuery = queryStore[key];
			theQuery.CompiledQuery.CheckErrors();
			Query query = Query.Clone(queryList[key]);
			query.SetXsltContext(new XsltCompileContext(theQuery._ScopeManager, this));
			return query;
		}

		internal Query GetValueQuery(int key)
		{
			return GetValueQuery(key, null);
		}

		internal Query GetValueQuery(int key, XsltCompileContext context)
		{
			TheQuery theQuery = queryStore[key];
			theQuery.CompiledQuery.CheckErrors();
			Query query = queryList[key];
			if (context == null)
			{
				context = new XsltCompileContext(theQuery._ScopeManager, this);
			}
			else
			{
				context.Reinitialize(theQuery._ScopeManager, this);
			}
			query.SetXsltContext(context);
			return query;
		}

		private XsltCompileContext GetValueOfContext()
		{
			if (valueOfContext == null)
			{
				valueOfContext = new XsltCompileContext();
			}
			return valueOfContext;
		}

		[Conditional("DEBUG")]
		private void RecycleValueOfContext()
		{
			if (valueOfContext != null)
			{
				valueOfContext.Recycle();
			}
		}

		private XsltCompileContext GetMatchesContext()
		{
			if (matchesContext == null)
			{
				matchesContext = new XsltCompileContext();
			}
			return matchesContext;
		}

		[Conditional("DEBUG")]
		private void RecycleMatchesContext()
		{
			if (matchesContext != null)
			{
				matchesContext.Recycle();
			}
		}

		internal string ValueOf(ActionFrame context, int key)
		{
			Query valueQuery = GetValueQuery(key, GetValueOfContext());
			object obj = valueQuery.Evaluate(context.NodeSet);
			if (obj is XPathNodeIterator)
			{
				XPathNavigator xPathNavigator = valueQuery.Advance();
				return (xPathNavigator != null) ? ValueOf(xPathNavigator) : string.Empty;
			}
			return XmlConvert.ToXPathString(obj);
		}

		internal string ValueOf(XPathNavigator n)
		{
			if (stylesheet.Whitespace && n.NodeType == XPathNodeType.Element)
			{
				StringBuilder stringBuilder = GetSharedStringBuilder();
				ElementValueWithoutWS(n, stringBuilder);
				ReleaseSharedStringBuilder();
				return stringBuilder.ToString();
			}
			return n.Value;
		}

		private void ElementValueWithoutWS(XPathNavigator nav, StringBuilder builder)
		{
			bool flag = Stylesheet.PreserveWhiteSpace(this, nav);
			if (!nav.MoveToFirstChild())
			{
				return;
			}
			do
			{
				switch (nav.NodeType)
				{
				case XPathNodeType.Text:
				case XPathNodeType.SignificantWhitespace:
					builder.Append(nav.Value);
					break;
				case XPathNodeType.Whitespace:
					if (flag)
					{
						builder.Append(nav.Value);
					}
					break;
				case XPathNodeType.Element:
					ElementValueWithoutWS(nav, builder);
					break;
				}
			}
			while (nav.MoveToNext());
			nav.MoveToParent();
		}

		internal XPathNodeIterator StartQuery(XPathNodeIterator context, int key)
		{
			Query compiledQuery = GetCompiledQuery(key);
			object obj = compiledQuery.Evaluate(context);
			if (obj is XPathNodeIterator)
			{
				return new XPathSelectionIterator(context.Current, compiledQuery);
			}
			throw XsltException.Create("XPath_NodeSetExpected");
		}

		internal object Evaluate(ActionFrame context, int key)
		{
			return GetValueQuery(key).Evaluate(context.NodeSet);
		}

		internal object RunQuery(ActionFrame context, int key)
		{
			Query compiledQuery = GetCompiledQuery(key);
			object obj = compiledQuery.Evaluate(context.NodeSet);
			if (obj is XPathNodeIterator nodeIterator)
			{
				return new XPathArrayIterator(nodeIterator);
			}
			return obj;
		}

		internal string EvaluateString(ActionFrame context, int key)
		{
			object obj = Evaluate(context, key);
			string text = null;
			if (obj != null)
			{
				text = XmlConvert.ToXPathString(obj);
			}
			if (text == null)
			{
				text = string.Empty;
			}
			return text;
		}

		internal bool EvaluateBoolean(ActionFrame context, int key)
		{
			object obj = Evaluate(context, key);
			if (obj != null)
			{
				if (!(obj is XPathNavigator xPathNavigator))
				{
					return Convert.ToBoolean(obj, CultureInfo.InvariantCulture);
				}
				return Convert.ToBoolean(xPathNavigator.Value, CultureInfo.InvariantCulture);
			}
			return false;
		}

		internal bool Matches(XPathNavigator context, int key)
		{
			Query valueQuery = GetValueQuery(key, GetMatchesContext());
			try
			{
				return valueQuery.MatchNode(context) != null;
			}
			catch (XPathException)
			{
				throw XsltException.Create("Xslt_InvalidPattern", GetQueryExpression(key));
			}
		}

		internal void ResetOutput()
		{
			builder.Reset();
		}

		internal bool BeginEvent(XPathNodeType nodeType, string prefix, string name, string nspace, bool empty)
		{
			return BeginEvent(nodeType, prefix, name, nspace, empty, null, search: true);
		}

		internal bool BeginEvent(XPathNodeType nodeType, string prefix, string name, string nspace, bool empty, object htmlProps, bool search)
		{
			int num = xsm.BeginOutlook(nodeType);
			if (ignoreLevel > 0 || num == 16)
			{
				ignoreLevel++;
				return true;
			}
			switch (builder.BeginEvent(num, nodeType, prefix, name, nspace, empty, htmlProps, search))
			{
			case OutputResult.Continue:
				xsm.Begin(nodeType);
				return true;
			case OutputResult.Interrupt:
				xsm.Begin(nodeType);
				ExecutionResult = ExecResult.Interrupt;
				return true;
			case OutputResult.Overflow:
				ExecutionResult = ExecResult.Interrupt;
				return false;
			case OutputResult.Error:
				ignoreLevel++;
				return true;
			case OutputResult.Ignore:
				return true;
			default:
				return true;
			}
		}

		internal bool TextEvent(string text)
		{
			return TextEvent(text, disableOutputEscaping: false);
		}

		internal bool TextEvent(string text, bool disableOutputEscaping)
		{
			if (ignoreLevel > 0)
			{
				return true;
			}
			int state = xsm.BeginOutlook(XPathNodeType.Text);
			switch (builder.TextEvent(state, text, disableOutputEscaping))
			{
			case OutputResult.Continue:
				xsm.Begin(XPathNodeType.Text);
				return true;
			case OutputResult.Interrupt:
				xsm.Begin(XPathNodeType.Text);
				ExecutionResult = ExecResult.Interrupt;
				return true;
			case OutputResult.Overflow:
				ExecutionResult = ExecResult.Interrupt;
				return false;
			case OutputResult.Error:
			case OutputResult.Ignore:
				return true;
			default:
				return true;
			}
		}

		internal bool EndEvent(XPathNodeType nodeType)
		{
			if (ignoreLevel > 0)
			{
				ignoreLevel--;
				return true;
			}
			int state = xsm.EndOutlook(nodeType);
			switch (builder.EndEvent(state, nodeType))
			{
			case OutputResult.Continue:
				xsm.End(nodeType);
				return true;
			case OutputResult.Interrupt:
				xsm.End(nodeType);
				ExecutionResult = ExecResult.Interrupt;
				return true;
			case OutputResult.Overflow:
				ExecutionResult = ExecResult.Interrupt;
				return false;
			default:
				return true;
			}
		}

		internal bool CopyBeginEvent(XPathNavigator node, bool emptyflag)
		{
			switch (node.NodeType)
			{
			case XPathNodeType.Element:
			case XPathNodeType.Attribute:
			case XPathNodeType.ProcessingInstruction:
			case XPathNodeType.Comment:
				return BeginEvent(node.NodeType, node.Prefix, node.LocalName, node.NamespaceURI, emptyflag);
			case XPathNodeType.Namespace:
				return BeginEvent(XPathNodeType.Namespace, null, node.LocalName, node.Value, empty: false);
			default:
				return true;
			}
		}

		internal bool CopyTextEvent(XPathNavigator node)
		{
			switch (node.NodeType)
			{
			case XPathNodeType.Attribute:
			case XPathNodeType.Text:
			case XPathNodeType.SignificantWhitespace:
			case XPathNodeType.Whitespace:
			case XPathNodeType.ProcessingInstruction:
			case XPathNodeType.Comment:
			{
				string value = node.Value;
				return TextEvent(value);
			}
			default:
				return true;
			}
		}

		internal bool CopyEndEvent(XPathNavigator node)
		{
			switch (node.NodeType)
			{
			case XPathNodeType.Element:
			case XPathNodeType.Attribute:
			case XPathNodeType.Namespace:
			case XPathNodeType.ProcessingInstruction:
			case XPathNodeType.Comment:
				return EndEvent(node.NodeType);
			default:
				return true;
			}
		}

		internal static bool IsRoot(XPathNavigator navigator)
		{
			if (navigator.NodeType == XPathNodeType.Root)
			{
				return true;
			}
			if (navigator.NodeType == XPathNodeType.Element)
			{
				XPathNavigator xPathNavigator = navigator.Clone();
				xPathNavigator.MoveToRoot();
				return xPathNavigator.IsSamePosition(navigator);
			}
			return false;
		}

		internal void PushOutput(RecordOutput output)
		{
			builder.OutputState = xsm.State;
			RecordBuilder next = builder;
			builder = new RecordBuilder(output, nameTable);
			builder.Next = next;
			xsm.Reset();
		}

		internal RecordOutput PopOutput()
		{
			RecordBuilder recordBuilder = builder;
			builder = recordBuilder.Next;
			xsm.State = builder.OutputState;
			recordBuilder.TheEnd();
			return recordBuilder.Output;
		}

		internal bool SetDefaultOutput(XsltOutput.OutputMethod method)
		{
			if (Output.Method != method)
			{
				output = output.CreateDerivedOutput(method);
				return true;
			}
			return false;
		}

		internal object GetVariableValue(VariableAction variable)
		{
			int varKey = variable.VarKey;
			if (variable.IsGlobal)
			{
				ActionFrame actionFrame = (ActionFrame)actionStack[0];
				object variable2 = actionFrame.GetVariable(varKey);
				if (variable2 == VariableAction.BeingComputedMark)
				{
					throw XsltException.Create("Xslt_CircularReference", variable.NameStr);
				}
				if (variable2 != null)
				{
					return variable2;
				}
				int length = actionStack.Length;
				ActionFrame actionFrame2 = PushNewFrame();
				actionFrame2.Inherit(actionFrame);
				actionFrame2.Init(variable, actionFrame.NodeSet);
				do
				{
					if (((ActionFrame)actionStack.Peek()).Execute(this))
					{
						actionStack.Pop();
					}
				}
				while (length < actionStack.Length);
				return actionFrame.GetVariable(varKey);
			}
			return ((ActionFrame)actionStack.Peek()).GetVariable(varKey);
		}

		internal void SetParameter(XmlQualifiedName name, object value)
		{
			ActionFrame actionFrame = (ActionFrame)actionStack[actionStack.Length - 2];
			actionFrame.SetParameter(name, value);
		}

		internal void ResetParams()
		{
			ActionFrame actionFrame = (ActionFrame)actionStack[actionStack.Length - 1];
			actionFrame.ResetParams();
		}

		internal object GetParameter(XmlQualifiedName name)
		{
			ActionFrame actionFrame = (ActionFrame)actionStack[actionStack.Length - 3];
			return actionFrame.GetParameter(name);
		}

		internal void PushDebuggerStack()
		{
			DebuggerFrame debuggerFrame = (DebuggerFrame)debuggerStack.Push();
			if (debuggerFrame == null)
			{
				debuggerFrame = new DebuggerFrame();
				debuggerStack.AddToTop(debuggerFrame);
			}
			debuggerFrame.actionFrame = (ActionFrame)actionStack.Peek();
		}

		internal void PopDebuggerStack()
		{
			debuggerStack.Pop();
		}

		internal void OnInstructionExecute()
		{
			DebuggerFrame debuggerFrame = (DebuggerFrame)debuggerStack.Peek();
			debuggerFrame.actionFrame = (ActionFrame)actionStack.Peek();
			Debugger.OnInstructionExecute(this);
		}

		internal XmlQualifiedName GetPrevioseMode()
		{
			return ((DebuggerFrame)debuggerStack[debuggerStack.Length - 2]).currentMode;
		}

		internal void SetCurrentMode(XmlQualifiedName mode)
		{
			((DebuggerFrame)debuggerStack[debuggerStack.Length - 1]).currentMode = mode;
		}

		IStackFrame IXsltProcessor.GetStackFrame(int depth)
		{
			return ((DebuggerFrame)debuggerStack[depth]).actionFrame;
		}
	}
	internal class ReaderOutput : XmlReader, RecordOutput
	{
		private class XmlEncoder
		{
			private StringBuilder buffer;

			private XmlTextEncoder encoder;

			public char QuoteChar => '"';

			private void Init()
			{
				buffer = new StringBuilder();
				encoder = new XmlTextEncoder(new StringWriter(buffer, CultureInfo.InvariantCulture));
			}

			public string AtributeInnerXml(string value)
			{
				if (encoder == null)
				{
					Init();
				}
				buffer.Length = 0;
				encoder.StartAttribute(cacheAttrValue: false);
				encoder.Write(value);
				encoder.EndAttribute();
				return buffer.ToString();
			}

			public string AtributeOuterXml(string name, string value)
			{
				if (encoder == null)
				{
					Init();
				}
				buffer.Length = 0;
				buffer.Append(name);
				buffer.Append('=');
				buffer.Append(QuoteChar);
				encoder.StartAttribute(cacheAttrValue: false);
				encoder.Write(value);
				encoder.EndAttribute();
				buffer.Append(QuoteChar);
				return buffer.ToString();
			}
		}

		private Processor processor;

		private XmlNameTable nameTable;

		private RecordBuilder builder;

		private BuilderInfo mainNode;

		private ArrayList attributeList;

		private int attributeCount;

		private BuilderInfo attributeValue;

		private OutputScopeManager manager;

		private int currentIndex;

		private BuilderInfo currentInfo;

		private ReadState state;

		private bool haveRecord;

		private static BuilderInfo s_DefaultInfo = new BuilderInfo();

		private XmlEncoder encoder = new XmlEncoder();

		private XmlCharType xmlCharType = XmlCharType.Instance;

		public override XmlNodeType NodeType => currentInfo.NodeType;

		public override string Name
		{
			get
			{
				string prefix = Prefix;
				string localName = LocalName;
				if (prefix != null && prefix.Length > 0)
				{
					if (localName.Length > 0)
					{
						return prefix + ":" + localName;
					}
					return prefix;
				}
				return localName;
			}
		}

		public override string LocalName => currentInfo.LocalName;

		public override string NamespaceURI => currentInfo.NamespaceURI;

		public override string Prefix => currentInfo.Prefix;

		public override bool HasValue => XmlReader.HasValueInternal(NodeType);

		public override string Value => currentInfo.Value;

		public override int Depth => currentInfo.Depth;

		public override string BaseURI => string.Empty;

		public override bool IsEmptyElement => currentInfo.IsEmptyTag;

		public override char QuoteChar => encoder.QuoteChar;

		public override bool IsDefault => false;

		public override XmlSpace XmlSpace
		{
			get
			{
				if (manager == null)
				{
					return XmlSpace.None;
				}
				return manager.XmlSpace;
			}
		}

		public override string XmlLang
		{
			get
			{
				if (manager == null)
				{
					return string.Empty;
				}
				return manager.XmlLang;
			}
		}

		public override int AttributeCount => attributeCount;

		public override string this[int i] => GetAttribute(i);

		public override string this[string name] => GetAttribute(name);

		public override string this[string name, string namespaceURI] => GetAttribute(name, namespaceURI);

		public override bool EOF => state == ReadState.EndOfFile;

		public override ReadState ReadState => state;

		public override XmlNameTable NameTable => nameTable;

		internal ReaderOutput(Processor processor)
		{
			this.processor = processor;
			nameTable = processor.NameTable;
			Reset();
		}

		public override string GetAttribute(string name)
		{
			if (FindAttribute(name, out var attrIndex))
			{
				return ((BuilderInfo)attributeList[attrIndex]).Value;
			}
			return null;
		}

		public override string GetAttribute(string localName, string namespaceURI)
		{
			if (FindAttribute(localName, namespaceURI, out var attrIndex))
			{
				return ((BuilderInfo)attributeList[attrIndex]).Value;
			}
			return null;
		}

		public override string GetAttribute(int i)
		{
			BuilderInfo builderInfo = GetBuilderInfo(i);
			return builderInfo.Value;
		}

		public override bool MoveToAttribute(string name)
		{
			if (FindAttribute(name, out var attrIndex))
			{
				SetAttribute(attrIndex);
				return true;
			}
			return false;
		}

		public override bool MoveToAttribute(string localName, string namespaceURI)
		{
			if (FindAttribute(localName, namespaceURI, out var attrIndex))
			{
				SetAttribute(attrIndex);
				return true;
			}
			return false;
		}

		public override void MoveToAttribute(int i)
		{
			if (i < 0 || attributeCount <= i)
			{
				throw new ArgumentOutOfRangeException("i");
			}
			SetAttribute(i);
		}

		public override bool MoveToFirstAttribute()
		{
			if (attributeCount <= 0)
			{
				return false;
			}
			SetAttribute(0);
			return true;
		}

		public override bool MoveToNextAttribute()
		{
			if (currentIndex + 1 < attributeCount)
			{
				SetAttribute(currentIndex + 1);
				return true;
			}
			return false;
		}

		public override bool MoveToElement()
		{
			if (NodeType == XmlNodeType.Attribute || currentInfo == attributeValue)
			{
				SetMainNode();
				return true;
			}
			return false;
		}

		public override bool Read()
		{
			if (state != ReadState.Interactive)
			{
				if (state != 0)
				{
					return false;
				}
				state = ReadState.Interactive;
			}
			while (true)
			{
				if (haveRecord)
				{
					processor.ResetOutput();
					haveRecord = false;
				}
				processor.Execute();
				if (haveRecord)
				{
					switch (NodeType)
					{
					case XmlNodeType.Text:
						if (!xmlCharType.IsOnlyWhitespace(Value))
						{
							break;
						}
						currentInfo.NodeType = XmlNodeType.Whitespace;
						goto IL_007b;
					case XmlNodeType.Whitespace:
						goto IL_007b;
					}
				}
				else
				{
					state = ReadState.EndOfFile;
					Reset();
				}
				break;
				IL_007b:
				if (Value.Length != 0)
				{
					if (XmlSpace == XmlSpace.Preserve)
					{
						currentInfo.NodeType = XmlNodeType.SignificantWhitespace;
					}
					break;
				}
			}
			return haveRecord;
		}

		public override void Close()
		{
			processor = null;
			state = ReadState.Closed;
			Reset();
		}

		public override string ReadString()
		{
			string text = string.Empty;
			if (NodeType == XmlNodeType.Element || NodeType == XmlNodeType.Attribute || currentInfo == attributeValue)
			{
				if (mainNode.IsEmptyTag)
				{
					return text;
				}
				if (!Read())
				{
					throw new InvalidOperationException(System.Xml.Utils.Res.GetString("Xml_InvalidOperation"));
				}
			}
			StringBuilder stringBuilder = null;
			bool flag = true;
			do
			{
				switch (NodeType)
				{
				case XmlNodeType.Text:
				case XmlNodeType.Whitespace:
				case XmlNodeType.SignificantWhitespace:
					if (flag)
					{
						text = Value;
						flag = false;
						break;
					}
					if (stringBuilder == null)
					{
						stringBuilder = new StringBuilder(text);
					}
					stringBuilder.Append(Value);
					break;
				default:
					if (stringBuilder != null)
					{
						return stringBuilder.ToString();
					}
					return text;
				}
			}
			while (Read());
			throw new InvalidOperationException(System.Xml.Utils.Res.GetString("Xml_InvalidOperation"));
		}

		public override string ReadInnerXml()
		{
			if (ReadState == ReadState.Interactive)
			{
				if (NodeType == XmlNodeType.Element && !IsEmptyElement)
				{
					StringOutput stringOutput = new StringOutput(processor);
					stringOutput.OmitXmlDecl();
					int depth = Depth;
					Read();
					while (depth < Depth)
					{
						stringOutput.RecordDone(builder);
						Read();
					}
					Read();
					stringOutput.TheEnd();
					return stringOutput.Result;
				}
				if (NodeType == XmlNodeType.Attribute)
				{
					return encoder.AtributeInnerXml(Value);
				}
				Read();
			}
			return string.Empty;
		}

		public override string ReadOuterXml()
		{
			if (ReadState == ReadState.Interactive)
			{
				if (NodeType == XmlNodeType.Element)
				{
					StringOutput stringOutput = new StringOutput(processor);
					stringOutput.OmitXmlDecl();
					bool isEmptyElement = IsEmptyElement;
					int depth = Depth;
					stringOutput.RecordDone(builder);
					Read();
					while (depth < Depth)
					{
						stringOutput.RecordDone(builder);
						Read();
					}
					if (!isEmptyElement)
					{
						stringOutput.RecordDone(builder);
						Read();
					}
					stringOutput.TheEnd();
					return stringOutput.Result;
				}
				if (NodeType == XmlNodeType.Attribute)
				{
					return encoder.AtributeOuterXml(Name, Value);
				}
				Read();
			}
			return string.Empty;
		}

		public override string LookupNamespace(string prefix)
		{
			prefix = nameTable.Get(prefix);
			if (manager != null && prefix != null)
			{
				return manager.ResolveNamespace(prefix);
			}
			return null;
		}

		public override void ResolveEntity()
		{
			if (NodeType != XmlNodeType.EntityReference)
			{
				throw new InvalidOperationException(System.Xml.Utils.Res.GetString("Xml_InvalidOperation"));
			}
		}

		public override bool ReadAttributeValue()
		{
			if (ReadState != ReadState.Interactive || NodeType != XmlNodeType.Attribute)
			{
				return false;
			}
			if (attributeValue == null)
			{
				attributeValue = new BuilderInfo();
				attributeValue.NodeType = XmlNodeType.Text;
			}
			if (currentInfo == attributeValue)
			{
				return false;
			}
			attributeValue.Value = currentInfo.Value;
			attributeValue.Depth = currentInfo.Depth + 1;
			currentInfo = attributeValue;
			return true;
		}

		public Processor.OutputResult RecordDone(RecordBuilder record)
		{
			builder = record;
			mainNode = record.MainNode;
			attributeList = record.AttributeList;
			attributeCount = record.AttributeCount;
			manager = record.Manager;
			haveRecord = true;
			SetMainNode();
			return Processor.OutputResult.Interrupt;
		}

		public void TheEnd()
		{
		}

		private void SetMainNode()
		{
			currentIndex = -1;
			currentInfo = mainNode;
		}

		private void SetAttribute(int attrib)
		{
			currentIndex = attrib;
			currentInfo = (BuilderInfo)attributeList[attrib];
		}

		private BuilderInfo GetBuilderInfo(int attrib)
		{
			if (attrib < 0 || attributeCount <= attrib)
			{
				throw new ArgumentOutOfRangeException("attrib");
			}
			return (BuilderInfo)attributeList[attrib];
		}

		private bool FindAttribute(string localName, string namespaceURI, out int attrIndex)
		{
			if (namespaceURI == null)
			{
				namespaceURI = string.Empty;
			}
			if (localName == null)
			{
				localName = string.Empty;
			}
			for (int i = 0; i < attributeCount; i++)
			{
				BuilderInfo builderInfo = (BuilderInfo)attributeList[i];
				if (builderInfo.NamespaceURI == namespaceURI && builderInfo.LocalName == localName)
				{
					attrIndex = i;
					return true;
				}
			}
			attrIndex = -1;
			return false;
		}

		private bool FindAttribute(string name, out int attrIndex)
		{
			if (name == null)
			{
				name = string.Empty;
			}
			for (int i = 0; i < attributeCount; i++)
			{
				BuilderInfo builderInfo = (BuilderInfo)attributeList[i];
				if (builderInfo.Name == name)
				{
					attrIndex = i;
					return true;
				}
			}
			attrIndex = -1;
			return false;
		}

		private void Reset()
		{
			currentIndex = -1;
			currentInfo = s_DefaultInfo;
			mainNode = s_DefaultInfo;
			manager = null;
		}

		[Conditional("DEBUG")]
		private void CheckCurrentInfo()
		{
		}
	}
	internal sealed class RecordBuilder
	{
		private const int NoRecord = 0;

		private const int SomeRecord = 1;

		private const int HaveRecord = 2;

		private const char s_Minus = '-';

		private const string s_Space = " ";

		private const string s_SpaceMinus = " -";

		private const char s_Question = '?';

		private const char s_Greater = '>';

		private const string s_SpaceGreater = " >";

		private const string PrefixFormat = "xp_{0}";

		private const string s_SpaceDefault = "default";

		private const string s_SpacePreserve = "preserve";

		private int outputState;

		private RecordBuilder next;

		private RecordOutput output;

		private XmlNameTable nameTable;

		private OutKeywords atoms;

		private OutputScopeManager scopeManager;

		private BuilderInfo mainNode = new BuilderInfo();

		private ArrayList attributeList = new ArrayList();

		private int attributeCount;

		private ArrayList namespaceList = new ArrayList();

		private int namespaceCount;

		private BuilderInfo dummy = new BuilderInfo();

		private BuilderInfo currentInfo;

		private bool popScope;

		private int recordState;

		private int recordDepth;

		internal int OutputState
		{
			get
			{
				return outputState;
			}
			set
			{
				outputState = value;
			}
		}

		internal RecordBuilder Next
		{
			get
			{
				return next;
			}
			set
			{
				next = value;
			}
		}

		internal RecordOutput Output => output;

		internal BuilderInfo MainNode => mainNode;

		internal ArrayList AttributeList => attributeList;

		internal int AttributeCount => attributeCount;

		internal OutputScopeManager Manager => scopeManager;

		internal RecordBuilder(RecordOutput output, XmlNameTable nameTable)
		{
			this.output = output;
			this.nameTable = ((nameTable != null) ? nameTable : new NameTable());
			atoms = new OutKeywords(this.nameTable);
			scopeManager = new OutputScopeManager(this.nameTable, atoms);
		}

		private void ValueAppend(string s, bool disableOutputEscaping)
		{
			currentInfo.ValueAppend(s, disableOutputEscaping);
		}

		private bool CanOutput(int state)
		{
			if (recordState == 0 || (state & 0x2000) == 0)
			{
				return true;
			}
			recordState = 2;
			FinalizeRecord();
			SetEmptyFlag(state);
			return output.RecordDone(this) == Processor.OutputResult.Continue;
		}

		internal Processor.OutputResult BeginEvent(int state, XPathNodeType nodeType, string prefix, string name, string nspace, bool empty, object htmlProps, bool search)
		{
			if (!CanOutput(state))
			{
				return Processor.OutputResult.Overflow;
			}
			AdjustDepth(state);
			ResetRecord(state);
			PopElementScope();
			prefix = ((prefix != null) ? nameTable.Add(prefix) : atoms.Empty);
			name = ((name != null) ? nameTable.Add(name) : atoms.Empty);
			nspace = ((nspace != null) ? nameTable.Add(nspace) : atoms.Empty);
			switch (nodeType)
			{
			case XPathNodeType.Element:
				mainNode.htmlProps = htmlProps as HtmlElementProps;
				mainNode.search = search;
				BeginElement(prefix, name, nspace, empty);
				break;
			case XPathNodeType.Attribute:
				BeginAttribute(prefix, name, nspace, htmlProps, search);
				break;
			case XPathNodeType.Namespace:
				BeginNamespace(name, nspace);
				break;
			case XPathNodeType.ProcessingInstruction:
				if (!BeginProcessingInstruction(prefix, name, nspace))
				{
					return Processor.OutputResult.Error;
				}
				break;
			case XPathNodeType.Comment:
				BeginComment();
				break;
			}
			return CheckRecordBegin(state);
		}

		internal Processor.OutputResult TextEvent(int state, string text, bool disableOutputEscaping)
		{
			if (!CanOutput(state))
			{
				return Processor.OutputResult.Overflow;
			}
			AdjustDepth(state);
			ResetRecord(state);
			PopElementScope();
			if (((uint)state & 0x2000u) != 0)
			{
				currentInfo.Depth = recordDepth;
				currentInfo.NodeType = XmlNodeType.Text;
			}
			ValueAppend(text, disableOutputEscaping);
			return CheckRecordBegin(state);
		}

		internal Processor.OutputResult EndEvent(int state, XPathNodeType nodeType)
		{
			if (!CanOutput(state))
			{
				return Processor.OutputResult.Overflow;
			}
			AdjustDepth(state);
			PopElementScope();
			popScope = (state & 0x10000) != 0;
			if (((uint)state & 0x1000u) != 0 && mainNode.IsEmptyTag)
			{
				return Processor.OutputResult.Continue;
			}
			ResetRecord(state);
			if (((uint)state & 0x2000u) != 0 && nodeType == XPathNodeType.Element)
			{
				EndElement();
			}
			return CheckRecordEnd(state);
		}

		internal void Reset()
		{
			if (recordState == 2)
			{
				recordState = 0;
			}
		}

		internal void TheEnd()
		{
			if (recordState == 1)
			{
				recordState = 2;
				FinalizeRecord();
				output.RecordDone(this);
			}
			output.TheEnd();
		}

		private int FindAttribute(string name, string nspace, ref string prefix)
		{
			for (int i = 0; i < attributeCount; i++)
			{
				BuilderInfo builderInfo = (BuilderInfo)attributeList[i];
				if (Keywords.Equals(builderInfo.LocalName, name))
				{
					if (Keywords.Equals(builderInfo.NamespaceURI, nspace))
					{
						return i;
					}
					if (Keywords.Equals(builderInfo.Prefix, prefix))
					{
						prefix = string.Empty;
					}
				}
			}
			return -1;
		}

		private void BeginElement(string prefix, string name, string nspace, bool empty)
		{
			currentInfo.NodeType = XmlNodeType.Element;
			currentInfo.Prefix = prefix;
			currentInfo.LocalName = name;
			currentInfo.NamespaceURI = nspace;
			currentInfo.Depth = recordDepth;
			currentInfo.IsEmptyTag = empty;
			scopeManager.PushScope(name, nspace, prefix);
		}

		private void EndElement()
		{
			OutputScope currentElementScope = scopeManager.CurrentElementScope;
			currentInfo.NodeType = XmlNodeType.EndElement;
			currentInfo.Prefix = currentElementScope.Prefix;
			currentInfo.LocalName = currentElementScope.Name;
			currentInfo.NamespaceURI = currentElementScope.Namespace;
			currentInfo.Depth = recordDepth;
		}

		private int NewAttribute()
		{
			if (attributeCount >= attributeList.Count)
			{
				attributeList.Add(new BuilderInfo());
			}
			return attributeCount++;
		}

		private void BeginAttribute(string prefix, string name, string nspace, object htmlAttrProps, bool search)
		{
			int num = FindAttribute(name, nspace, ref prefix);
			if (num == -1)
			{
				num = NewAttribute();
			}
			BuilderInfo builderInfo = (BuilderInfo)attributeList[num];
			builderInfo.Initialize(prefix, name, nspace);
			builderInfo.Depth = recordDepth;
			builderInfo.NodeType = XmlNodeType.Attribute;
			builderInfo.htmlAttrProps = htmlAttrProps as HtmlAttributeProps;
			builderInfo.search = search;
			currentInfo = builderInfo;
		}

		private void BeginNamespace(string name, string nspace)
		{
			bool thisScope = false;
			if (Keywords.Equals(name, atoms.Empty))
			{
				if (!Keywords.Equals(nspace, scopeManager.DefaultNamespace) && !Keywords.Equals(mainNode.NamespaceURI, atoms.Empty))
				{
					DeclareNamespace(nspace, name);
				}
			}
			else
			{
				string text = scopeManager.ResolveNamespace(name, out thisScope);
				if (text != null)
				{
					if (!Keywords.Equals(nspace, text) && !thisScope)
					{
						DeclareNamespace(nspace, name);
					}
				}
				else
				{
					DeclareNamespace(nspace, name);
				}
			}
			currentInfo = dummy;
			currentInfo.NodeType = XmlNodeType.Attribute;
		}

		private bool BeginProcessingInstruction(string prefix, string name, string nspace)
		{
			currentInfo.NodeType = XmlNodeType.ProcessingInstruction;
			currentInfo.Prefix = prefix;
			currentInfo.LocalName = name;
			currentInfo.NamespaceURI = nspace;
			currentInfo.Depth = recordDepth;
			return true;
		}

		private void BeginComment()
		{
			currentInfo.NodeType = XmlNodeType.Comment;
			currentInfo.Depth = recordDepth;
		}

		private void AdjustDepth(int state)
		{
			switch (state & 0x300)
			{
			case 256:
				recordDepth++;
				break;
			case 512:
				recordDepth--;
				break;
			}
		}

		private void ResetRecord(int state)
		{
			if (((uint)state & 0x2000u) != 0)
			{
				attributeCount = 0;
				namespaceCount = 0;
				currentInfo = mainNode;
				currentInfo.Initialize(atoms.Empty, atoms.Empty, atoms.Empty);
				currentInfo.NodeType = XmlNodeType.None;
				currentInfo.IsEmptyTag = false;
				currentInfo.htmlProps = null;
				currentInfo.htmlAttrProps = null;
			}
		}

		private void PopElementScope()
		{
			if (popScope)
			{
				scopeManager.PopScope();
				popScope = false;
			}
		}

		private Processor.OutputResult CheckRecordBegin(int state)
		{
			if (((uint)state & 0x4000u) != 0)
			{
				recordState = 2;
				FinalizeRecord();
				SetEmptyFlag(state);
				return output.RecordDone(this);
			}
			recordState = 1;
			return Processor.OutputResult.Continue;
		}

		private Processor.OutputResult CheckRecordEnd(int state)
		{
			if (((uint)state & 0x4000u) != 0)
			{
				recordState = 2;
				FinalizeRecord();
				SetEmptyFlag(state);
				return output.RecordDone(this);
			}
			return Processor.OutputResult.Continue;
		}

		private void SetEmptyFlag(int state)
		{
			if (((uint)state & 0x400u) != 0)
			{
				mainNode.IsEmptyTag = false;
			}
		}

		private void AnalyzeSpaceLang()
		{
			for (int i = 0; i < attributeCount; i++)
			{
				BuilderInfo builderInfo = (BuilderInfo)attributeList[i];
				if (Keywords.Equals(builderInfo.Prefix, atoms.Xml))
				{
					OutputScope currentElementScope = scopeManager.CurrentElementScope;
					if (Keywords.Equals(builderInfo.LocalName, atoms.Lang))
					{
						currentElementScope.Lang = builderInfo.Value;
					}
					else if (Keywords.Equals(builderInfo.LocalName, atoms.Space))
					{
						currentElementScope.Space = TranslateXmlSpace(builderInfo.Value);
					}
				}
			}
		}

		private void FixupElement()
		{
			if (Keywords.Equals(mainNode.NamespaceURI, atoms.Empty))
			{
				mainNode.Prefix = atoms.Empty;
			}
			if (Keywords.Equals(mainNode.Prefix, atoms.Empty))
			{
				if (!Keywords.Equals(mainNode.NamespaceURI, scopeManager.DefaultNamespace))
				{
					DeclareNamespace(mainNode.NamespaceURI, mainNode.Prefix);
				}
			}
			else
			{
				bool thisScope = false;
				string text = scopeManager.ResolveNamespace(mainNode.Prefix, out thisScope);
				if (text != null)
				{
					if (!Keywords.Equals(mainNode.NamespaceURI, text))
					{
						if (thisScope)
						{
							mainNode.Prefix = GetPrefixForNamespace(mainNode.NamespaceURI);
						}
						else
						{
							DeclareNamespace(mainNode.NamespaceURI, mainNode.Prefix);
						}
					}
				}
				else
				{
					DeclareNamespace(mainNode.NamespaceURI, mainNode.Prefix);
				}
			}
			OutputScope currentElementScope = scopeManager.CurrentElementScope;
			currentElementScope.Prefix = mainNode.Prefix;
		}

		private void FixupAttributes(int attributeCount)
		{
			for (int i = 0; i < attributeCount; i++)
			{
				BuilderInfo builderInfo = (BuilderInfo)attributeList[i];
				if (Keywords.Equals(builderInfo.NamespaceURI, atoms.Empty))
				{
					builderInfo.Prefix = atoms.Empty;
					continue;
				}
				if (Keywords.Equals(builderInfo.Prefix, atoms.Empty))
				{
					builderInfo.Prefix = GetPrefixForNamespace(builderInfo.NamespaceURI);
					continue;
				}
				bool thisScope = false;
				string text = scopeManager.ResolveNamespace(builderInfo.Prefix, out thisScope);
				if (text != null)
				{
					if (!Keywords.Equals(builderInfo.NamespaceURI, text))
					{
						if (thisScope)
						{
							builderInfo.Prefix = GetPrefixForNamespace(builderInfo.NamespaceURI);
						}
						else
						{
							DeclareNamespace(builderInfo.NamespaceURI, builderInfo.Prefix);
						}
					}
				}
				else
				{
					DeclareNamespace(builderInfo.NamespaceURI, builderInfo.Prefix);
				}
			}
		}

		private void AppendNamespaces()
		{
			for (int num = namespaceCount - 1; num >= 0; num--)
			{
				BuilderInfo builderInfo = (BuilderInfo)attributeList[NewAttribute()];
				builderInfo.Initialize((BuilderInfo)namespaceList[num]);
			}
		}

		private void AnalyzeComment()
		{
			StringBuilder stringBuilder = null;
			string value = mainNode.Value;
			bool flag = false;
			int i = 0;
			int num = 0;
			for (; i < value.Length; i++)
			{
				char c = value[i];
				if (c == '-')
				{
					if (flag)
					{
						if (stringBuilder == null)
						{
							stringBuilder = new StringBuilder(value, num, i, 2 * value.Length);
						}
						else
						{
							stringBuilder.Append(value, num, i - num);
						}
						stringBuilder.Append(" -");
						num = i + 1;
					}
					flag = true;
				}
				else
				{
					flag = false;
				}
			}
			if (stringBuilder != null)
			{
				if (num < value.Length)
				{
					stringBuilder.Append(value, num, value.Length - num);
				}
				if (flag)
				{
					stringBuilder.Append(" ");
				}
				mainNode.Value = stringBuilder.ToString();
			}
			else if (flag)
			{
				mainNode.ValueAppend(" ", disableEscaping: false);
			}
		}

		private void AnalyzeProcessingInstruction()
		{
			StringBuilder stringBuilder = null;
			string value = mainNode.Value;
			bool flag = false;
			int i = 0;
			int num = 0;
			for (; i < value.Length; i++)
			{
				switch (value[i])
				{
				case '?':
					flag = true;
					break;
				case '>':
					if (flag)
					{
						if (stringBuilder == null)
						{
							stringBuilder = new StringBuilder(value, num, i, 2 * value.Length);
						}
						else
						{
							stringBuilder.Append(value, num, i - num);
						}
						stringBuilder.Append(" >");
						num = i + 1;
					}
					flag = false;
					break;
				default:
					flag = false;
					break;
				}
			}
			if (stringBuilder != null)
			{
				if (num < value.Length)
				{
					stringBuilder.Append(value, num, value.Length - num);
				}
				mainNode.Value = stringBuilder.ToString();
			}
		}

		private void FinalizeRecord()
		{
			switch (mainNode.NodeType)
			{
			case XmlNodeType.Element:
			{
				int num = attributeCount;
				FixupElement();
				FixupAttributes(num);
				AnalyzeSpaceLang();
				AppendNamespaces();
				break;
			}
			case XmlNodeType.Comment:
				AnalyzeComment();
				break;
			case XmlNodeType.ProcessingInstruction:
				AnalyzeProcessingInstruction();
				break;
			}
		}

		private int NewNamespace()
		{
			if (namespaceCount >= namespaceList.Count)
			{
				namespaceList.Add(new BuilderInfo());
			}
			return namespaceCount++;
		}

		private void DeclareNamespace(string nspace, string prefix)
		{
			int index = NewNamespace();
			BuilderInfo builderInfo = (BuilderInfo)namespaceList[index];
			if (prefix == atoms.Empty)
			{
				builderInfo.Initialize(atoms.Empty, atoms.Xmlns, atoms.XmlnsNamespace);
			}
			else
			{
				builderInfo.Initialize(atoms.Xmlns, prefix, atoms.XmlnsNamespace);
			}
			builderInfo.Depth = recordDepth;
			builderInfo.NodeType = XmlNodeType.Attribute;
			builderInfo.Value = nspace;
			scopeManager.PushNamespace(prefix, nspace);
		}

		private string DeclareNewNamespace(string nspace)
		{
			string text = scopeManager.GeneratePrefix("xp_{0}");
			DeclareNamespace(nspace, text);
			return text;
		}

		internal string GetPrefixForNamespace(string nspace)
		{
			string prefix = null;
			if (scopeManager.FindPrefix(nspace, out prefix))
			{
				return prefix;
			}
			return DeclareNewNamespace(nspace);
		}

		private static XmlSpace TranslateXmlSpace(string space)
		{
			if (Keywords.Compare(space, "default"))
			{
				return XmlSpace.Default;
			}
			if (Keywords.Compare(space, "preserve"))
			{
				return XmlSpace.Preserve;
			}
			return XmlSpace.None;
		}
	}
	internal class Key
	{
		private XmlQualifiedName name;

		private int matchKey;

		private int useKey;

		private ArrayList keyNodes;

		public XmlQualifiedName Name => name;

		public int MatchKey => matchKey;

		public int UseKey => useKey;

		public Key(XmlQualifiedName name, int matchkey, int usekey)
		{
			this.name = name;
			matchKey = matchkey;
			useKey = usekey;
			keyNodes = null;
		}

		public void AddKey(XPathNavigator root, Hashtable table)
		{
			if (keyNodes == null)
			{
				keyNodes = new ArrayList();
			}
			keyNodes.Add(new DocumentKeyList(root, table));
		}

		public Hashtable GetKeys(XPathNavigator root)
		{
			if (keyNodes != null)
			{
				for (int i = 0; i < keyNodes.Count; i++)
				{
					if (((DocumentKeyList)keyNodes[i]).RootNav.IsSamePosition(root))
					{
						return ((DocumentKeyList)keyNodes[i]).KeyTable;
					}
				}
			}
			return null;
		}

		public Key Clone()
		{
			return new Key(name, matchKey, useKey);
		}
	}
	internal struct DocumentKeyList
	{
		private XPathNavigator rootNav;

		private Hashtable keyTable;

		public XPathNavigator RootNav => rootNav;

		public Hashtable KeyTable => keyTable;

		public DocumentKeyList(XPathNavigator rootNav, Hashtable keyTable)
		{
			this.rootNav = rootNav;
			this.keyTable = keyTable;
		}
	}
	internal abstract class SequentialOutput : RecordOutput
	{
		private const char s_Colon = ':';

		private const char s_GreaterThan = '>';

		private const char s_LessThan = '<';

		private const char s_Space = ' ';

		private const char s_Quote = '"';

		private const char s_Semicolon = ';';

		private const char s_NewLine = '\n';

		private const char s_Return = '\r';

		private const char s_Ampersand = '&';

		private const string s_LessThanQuestion = "<?";

		private const string s_QuestionGreaterThan = "?>";

		private const string s_LessThanSlash = "</";

		private const string s_SlashGreaterThan = " />";

		private const string s_EqualQuote = "=\"";

		private const string s_DocType = "<!DOCTYPE ";

		private const string s_CommentBegin = "<!--";

		private const string s_CommentEnd = "-->";

		private const string s_CDataBegin = "<![CDATA[";

		private const string s_CDataEnd = "]]>";

		private const string s_VersionAll = " version=\"1.0\"";

		private const string s_Standalone = " standalone=\"";

		private const string s_EncodingStart = " encoding=\"";

		private const string s_Public = "PUBLIC ";

		private const string s_System = "SYSTEM ";

		private const string s_Html = "html";

		private const string s_QuoteSpace = "\" ";

		private const string s_CDataSplit = "]]]]><![CDATA[>";

		private const string s_EnLessThan = "&lt;";

		private const string s_EnGreaterThan = "&gt;";

		private const string s_EnAmpersand = "&amp;";

		private const string s_EnQuote = "&quot;";

		private const string s_EnNewLine = "&#xA;";

		private const string s_EnReturn = "&#xD;";

		private const string s_EndOfLine = "\r\n";

		private static char[] s_TextValueFind = new char[3] { '&', '>', '<' };

		private static string[] s_TextValueReplace = new string[3] { "&amp;", "&gt;", "&lt;" };

		private static char[] s_XmlAttributeValueFind = new char[6] { '&', '>', '<', '"', '\n', '\r' };

		private static string[] s_XmlAttributeValueReplace = new string[6] { "&amp;", "&gt;", "&lt;", "&quot;", "&#xA;", "&#xD;" };

		private Processor processor;

		protected Encoding encoding;

		private ArrayList outputCache;

		private bool firstLine = true;

		private bool secondRoot;

		private XsltOutput output;

		private bool isHtmlOutput;

		private bool isXmlOutput;

		private Hashtable cdataElements;

		private bool indentOutput;

		private bool outputDoctype;

		private bool outputXmlDecl;

		private bool omitXmlDeclCalled;

		private byte[] byteBuffer;

		private Encoding utf8Encoding;

		private XmlCharType xmlCharType = XmlCharType.Instance;

		private void CacheOuptutProps(XsltOutput output)
		{
			this.output = output;
			isXmlOutput = this.output.Method == XsltOutput.OutputMethod.Xml;
			isHtmlOutput = this.output.Method == XsltOutput.OutputMethod.Html;
			cdataElements = this.output.CDataElements;
			indentOutput = this.output.Indent;
			outputDoctype = this.output.DoctypeSystem != null || (isHtmlOutput && this.output.DoctypePublic != null);
			outputXmlDecl = isXmlOutput && !this.output.OmitXmlDeclaration && !omitXmlDeclCalled;
		}

		internal SequentialOutput(Processor processor)
		{
			this.processor = processor;
			CacheOuptutProps(processor.Output);
		}

		public void OmitXmlDecl()
		{
			omitXmlDeclCalled = true;
			outputXmlDecl = false;
		}

		private void WriteStartElement(RecordBuilder record)
		{
			BuilderInfo mainNode = record.MainNode;
			HtmlElementProps htmlElementProps = null;
			if (isHtmlOutput)
			{
				if (mainNode.Prefix.Length == 0)
				{
					htmlElementProps = mainNode.htmlProps;
					if (htmlElementProps == null && mainNode.search)
					{
						htmlElementProps = HtmlElementProps.GetProps(mainNode.LocalName);
					}
					record.Manager.CurrentElementScope.HtmlElementProps = htmlElementProps;
					mainNode.IsEmptyTag = false;
				}
			}
			else if (isXmlOutput && mainNode.Depth == 0)
			{
				if (secondRoot && (output.DoctypeSystem != null || output.Standalone))
				{
					throw XsltException.Create("Xslt_MultipleRoots");
				}
				secondRoot = true;
			}
			if (outputDoctype)
			{
				WriteDoctype(mainNode);
				outputDoctype = false;
			}
			if (cdataElements != null && cdataElements.Contains(new XmlQualifiedName(mainNode.LocalName, mainNode.NamespaceURI)) && isXmlOutput)
			{
				record.Manager.CurrentElementScope.ToCData = true;
			}
			Indent(record);
			Write('<');
			WriteName(mainNode.Prefix, mainNode.LocalName);
			WriteAttributes(record.AttributeList, record.AttributeCount, htmlElementProps);
			if (mainNode.IsEmptyTag)
			{
				Write(" />");
			}
			else
			{
				Write('>');
			}
			if (htmlElementProps != null && htmlElementProps.Head)
			{
				mainNode.Depth++;
				Indent(record);
				mainNode.Depth--;
				Write("<META http-equiv=\"Content-Type\" content=\"");
				Write(output.MediaType);
				Write("; charset=");
				Write(encoding.WebName);
				Write("\">");
			}
		}

		private void WriteTextNode(RecordBuilder record)
		{
			BuilderInfo mainNode = record.MainNode;
			OutputScope currentElementScope = record.Manager.CurrentElementScope;
			currentElementScope.Mixed = true;
			if (currentElementScope.HtmlElementProps != null && currentElementScope.HtmlElementProps.NoEntities)
			{
				Write(mainNode.Value);
			}
			else if (currentElementScope.ToCData)
			{
				WriteCDataSection(mainNode.Value);
			}
			else
			{
				WriteTextNode(mainNode);
			}
		}

		private void WriteTextNode(BuilderInfo node)
		{
			for (int i = 0; i < node.TextInfoCount; i++)
			{
				string text = node.TextInfo[i];
				if (text == null)
				{
					i++;
					Write(node.TextInfo[i]);
				}
				else
				{
					WriteWithReplace(text, s_TextValueFind, s_TextValueReplace);
				}
			}
		}

		private void WriteCDataSection(string value)
		{
			Write("<![CDATA[");
			WriteCData(value);
			Write("]]>");
		}

		private void WriteDoctype(BuilderInfo mainNode)
		{
			Indent(0);
			Write("<!DOCTYPE ");
			if (isXmlOutput)
			{
				WriteName(mainNode.Prefix, mainNode.LocalName);
			}
			else
			{
				WriteName(string.Empty, "html");
			}
			Write(' ');
			if (output.DoctypePublic != null)
			{
				Write("PUBLIC ");
				Write('"');
				Write(output.DoctypePublic);
				Write("\" ");
			}
			else
			{
				Write("SYSTEM ");
			}
			if (output.DoctypeSystem != null)
			{
				Write('"');
				Write(output.DoctypeSystem);
				Write('"');
			}
			Write('>');
		}

		private void WriteXmlDeclaration()
		{
			outputXmlDecl = false;
			Indent(0);
			Write("<?");
			WriteName(string.Empty, "xml");
			Write(" version=\"1.0\"");
			if (encoding != null)
			{
				Write(" encoding=\"");
				Write(encoding.WebName);
				Write('"');
			}
			if (output.HasStandalone)
			{
				Write(" standalone=\"");
				Write(output.Standalone ? "yes" : "no");
				Write('"');
			}
			Write("?>");
		}

		private void WriteProcessingInstruction(RecordBuilder record)
		{
			Indent(record);
			WriteProcessingInstruction(record.MainNode);
		}

		private void WriteProcessingInstruction(BuilderInfo node)
		{
			Write("<?");
			WriteName(node.Prefix, node.LocalName);
			Write(' ');
			Write(node.Value);
			if (isHtmlOutput)
			{
				Write('>');
			}
			else
			{
				Write("?>");
			}
		}

		private void WriteEndElement(RecordBuilder record)
		{
			_ = record.MainNode;
			HtmlElementProps htmlElementProps = record.Manager.CurrentElementScope.HtmlElementProps;
			if (htmlElementProps == null || !htmlElementProps.Empty)
			{
				Indent(record);
				Write("</");
				WriteName(record.MainNode.Prefix, record.MainNode.LocalName);
				Write('>');
			}
		}

		public Processor.OutputResult RecordDone(RecordBuilder record)
		{
			if (output.Method == XsltOutput.OutputMethod.Unknown)
			{
				if (!DecideDefaultOutput(record.MainNode))
				{
					CacheRecord(record);
				}
				else
				{
					OutputCachedRecords();
					OutputRecord(record);
				}
			}
			else
			{
				OutputRecord(record);
			}
			record.Reset();
			return Processor.OutputResult.Continue;
		}

		public void TheEnd()
		{
			OutputCachedRecords();
			Close();
		}

		private bool DecideDefaultOutput(BuilderInfo node)
		{
			XsltOutput.OutputMethod defaultOutput = XsltOutput.OutputMethod.Xml;
			switch (node.NodeType)
			{
			case XmlNodeType.Element:
				if (node.NamespaceURI.Length == 0 && string.Compare("html", node.LocalName, StringComparison.OrdinalIgnoreCase) == 0)
				{
					defaultOutput = XsltOutput.OutputMethod.Html;
				}
				break;
			case XmlNodeType.Text:
			case XmlNodeType.Whitespace:
			case XmlNodeType.SignificantWhitespace:
				if (xmlCharType.IsOnlyWhitespace(node.Value))
				{
					return false;
				}
				defaultOutput = XsltOutput.OutputMethod.Xml;
				break;
			default:
				return false;
			}
			if (processor.SetDefaultOutput(defaultOutput))
			{
				CacheOuptutProps(processor.Output);
			}
			return true;
		}

		private void CacheRecord(RecordBuilder record)
		{
			if (outputCache == null)
			{
				outputCache = new ArrayList();
			}
			outputCache.Add(record.MainNode.Clone());
		}

		private void OutputCachedRecords()
		{
			if (outputCache != null)
			{
				for (int i = 0; i < outputCache.Count; i++)
				{
					BuilderInfo node = (BuilderInfo)outputCache[i];
					OutputRecord(node);
				}
				outputCache = null;
			}
		}

		private void OutputRecord(RecordBuilder record)
		{
			BuilderInfo mainNode = record.MainNode;
			if (outputXmlDecl)
			{
				WriteXmlDeclaration();
			}
			switch (mainNode.NodeType)
			{
			case XmlNodeType.Element:
				WriteStartElement(record);
				break;
			case XmlNodeType.Text:
			case XmlNodeType.Whitespace:
			case XmlNodeType.SignificantWhitespace:
				WriteTextNode(record);
				break;
			case XmlNodeType.EntityReference:
				Write('&');
				WriteName(mainNode.Prefix, mainNode.LocalName);
				Write(';');
				break;
			case XmlNodeType.ProcessingInstruction:
				WriteProcessingInstruction(record);
				break;
			case XmlNodeType.Comment:
				Indent(record);
				Write("<!--");
				Write(mainNode.Value);
				Write("-->");
				break;
			case XmlNodeType.DocumentType:
				Write(mainNode.Value);
				break;
			case XmlNodeType.EndElement:
				WriteEndElement(record);
				break;
			case XmlNodeType.Attribute:
			case XmlNodeType.CDATA:
			case XmlNodeType.Entity:
			case XmlNodeType.Document:
			case XmlNodeType.DocumentFragment:
			case XmlNodeType.Notation:
				break;
			}
		}

		private void OutputRecord(BuilderInfo node)
		{
			if (outputXmlDecl)
			{
				WriteXmlDeclaration();
			}
			Indent(0);
			switch (node.NodeType)
			{
			case XmlNodeType.Text:
			case XmlNodeType.Whitespace:
			case XmlNodeType.SignificantWhitespace:
				WriteTextNode(node);
				break;
			case XmlNodeType.EntityReference:
				Write('&');
				WriteName(node.Prefix, node.LocalName);
				Write(';');
				break;
			case XmlNodeType.ProcessingInstruction:
				WriteProcessingInstruction(node);
				break;
			case XmlNodeType.Comment:
				Write("<!--");
				Write(node.Value);
				Write("-->");
				break;
			case XmlNodeType.DocumentType:
				Write(node.Value);
				break;
			case XmlNodeType.Element:
			case XmlNodeType.Attribute:
			case XmlNodeType.CDATA:
			case XmlNodeType.Entity:
			case XmlNodeType.Document:
			case XmlNodeType.DocumentFragment:
			case XmlNodeType.Notation:
			case XmlNodeType.EndElement:
				break;
			}
		}

		private void WriteName(string prefix, string name)
		{
			if (prefix != null && prefix.Length > 0)
			{
				Write(prefix);
				if (name == null || name.Length <= 0)
				{
					return;
				}
				Write(':');
			}
			Write(name);
		}

		private void WriteXmlAttributeValue(string value)
		{
			WriteWithReplace(value, s_XmlAttributeValueFind, s_XmlAttributeValueReplace);
		}

		private void WriteHtmlAttributeValue(string value)
		{
			int length = value.Length;
			int num = 0;
			while (num < length)
			{
				char c = value[num];
				num++;
				switch (c)
				{
				case '&':
					if (num != length && value[num] == '{')
					{
						Write(c);
					}
					else
					{
						Write("&amp;");
					}
					break;
				case '"':
					Write("&quot;");
					break;
				default:
					Write(c);
					break;
				}
			}
		}

		private void WriteHtmlUri(string value)
		{
			int length = value.Length;
			int num = 0;
			while (num < length)
			{
				char c = value[num];
				num++;
				switch (c)
				{
				case '&':
					if (num != length && value[num] == '{')
					{
						Write(c);
					}
					else
					{
						Write("&amp;");
					}
					continue;
				case '"':
					Write("&quot;");
					continue;
				case '\n':
					Write("&#xA;");
					continue;
				case '\r':
					Write("&#xD;");
					continue;
				}
				if ('\u007f' < c)
				{
					if (utf8Encoding == null)
					{
						utf8Encoding = Encoding.UTF8;
						byteBuffer = new byte[utf8Encoding.GetMaxByteCount(1)];
					}
					int bytes = utf8Encoding.GetBytes(value, num - 1, 1, byteBuffer, 0);
					for (int i = 0; i < bytes; i++)
					{
						Write("%");
						uint num2 = byteBuffer[i];
						Write(num2.ToString("X2", CultureInfo.InvariantCulture));
					}
				}
				else
				{
					Write(c);
				}
			}
		}

		private void WriteWithReplace(string value, char[] find, string[] replace)
		{
			int length = value.Length;
			int i;
			for (i = 0; i < length; i++)
			{
				int num = value.IndexOfAny(find, i);
				if (num == -1)
				{
					break;
				}
				for (; i < num; i++)
				{
					Write(value[i]);
				}
				char c = value[i];
				int num2 = find.Length - 1;
				while (0 <= num2)
				{
					if (find[num2] == c)
					{
						Write(replace[num2]);
						break;
					}
					num2--;
				}
			}
			if (i == 0)
			{
				Write(value);
				return;
			}
			for (; i < length; i++)
			{
				Write(value[i]);
			}
		}

		private void WriteCData(string value)
		{
			Write(value.Replace("]]>", "]]]]><![CDATA[>"));
		}

		private void WriteAttributes(ArrayList list, int count, HtmlElementProps htmlElementsProps)
		{
			for (int i = 0; i < count; i++)
			{
				BuilderInfo builderInfo = (BuilderInfo)list[i];
				string value = builderInfo.Value;
				bool flag = false;
				bool flag2 = false;
				if (htmlElementsProps != null && builderInfo.Prefix.Length == 0)
				{
					HtmlAttributeProps htmlAttributeProps = builderInfo.htmlAttrProps;
					if (htmlAttributeProps == null && builderInfo.search)
					{
						htmlAttributeProps = HtmlAttributeProps.GetProps(builderInfo.LocalName);
					}
					if (htmlAttributeProps != null)
					{
						flag = htmlElementsProps.AbrParent && htmlAttributeProps.Abr;
						flag2 = htmlElementsProps.UriParent && (htmlAttributeProps.Uri || (htmlElementsProps.NameParent && htmlAttributeProps.Name));
					}
				}
				Write(' ');
				WriteName(builderInfo.Prefix, builderInfo.LocalName);
				if (!flag || string.Compare(builderInfo.LocalName, value, StringComparison.OrdinalIgnoreCase) != 0)
				{
					Write("=\"");
					if (flag2)
					{
						WriteHtmlUri(value);
					}
					else if (isHtmlOutput)
					{
						WriteHtmlAttributeValue(value);
					}
					else
					{
						WriteXmlAttributeValue(value);
					}
					Write('"');
				}
			}
		}

		private void Indent(RecordBuilder record)
		{
			if (!record.Manager.CurrentElementScope.Mixed)
			{
				Indent(record.MainNode.Depth);
			}
		}

		private void Indent(int depth)
		{
			if (firstLine)
			{
				if (indentOutput)
				{
					firstLine = false;
				}
				return;
			}
			Write("\r\n");
			int num = 2 * depth;
			while (0 < num)
			{
				Write(" ");
				num--;
			}
		}

		internal abstract void Write(char outputChar);

		internal abstract void Write(string outputText);

		internal abstract void Close();
	}
	internal class StateMachine
	{
		private const int Init = 0;

		private const int Elem = 1;

		private const int NsN = 2;

		private const int NsV = 3;

		private const int Ns = 4;

		private const int AttrN = 5;

		private const int AttrV = 6;

		private const int Attr = 7;

		private const int InElm = 8;

		private const int EndEm = 9;

		private const int InCmt = 10;

		private const int InPI = 11;

		private const int StateMask = 15;

		internal const int Error = 16;

		private const int Ignor = 32;

		private const int Assrt = 48;

		private const int U = 256;

		private const int D = 512;

		internal const int DepthMask = 768;

		internal const int DepthUp = 256;

		internal const int DepthDown = 512;

		private const int C = 1024;

		private const int H = 2048;

		private const int M = 4096;

		internal const int BeginChild = 1024;

		internal const int HadChild = 2048;

		internal const int EmptyTag = 4096;

		private const int B = 8192;

		private const int E = 16384;

		internal const int BeginRecord = 8192;

		internal const int EndRecord = 16384;

		private const int S = 32768;

		private const int P = 65536;

		internal const int PushScope = 32768;

		internal const int PopScope = 65536;

		private int _State;

		private static readonly int[][] s_BeginTransitions = new int[10][]
		{
			new int[12]
			{
				16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
				16, 16
			},
			new int[12]
			{
				40961, 42241, 16, 16, 41985, 16, 16, 41985, 40961, 106497,
				16, 16
			},
			new int[12]
			{
				16, 261, 16, 16, 5, 16, 16, 5, 16, 16,
				16, 16
			},
			new int[12]
			{
				16, 258, 16, 16, 2, 16, 16, 16, 16, 16,
				16, 16
			},
			new int[12]
			{
				8200, 9480, 259, 3, 9224, 262, 6, 9224, 8, 73736,
				10, 11
			},
			new int[12]
			{
				8200, 9480, 259, 3, 9224, 262, 6, 9224, 8, 73736,
				10, 11
			},
			new int[12]
			{
				8200, 9480, 259, 3, 9224, 262, 6, 9224, 8, 73736,
				10, 11
			},
			new int[12]
			{
				8203, 9483, 16, 16, 9227, 16, 16, 9227, 8203, 73739,
				16, 16
			},
			new int[12]
			{
				8202, 9482, 16, 16, 9226, 16, 16, 9226, 8202, 73738,
				16, 16
			},
			new int[12]
			{
				16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
				16, 16
			}
		};

		private static readonly int[][] s_EndTransitions = new int[10][]
		{
			new int[12]
			{
				48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
				48, 48
			},
			new int[12]
			{
				48, 94217, 48, 48, 94729, 48, 48, 94729, 92681, 92681,
				48, 48
			},
			new int[12]
			{
				48, 48, 48, 48, 48, 7, 519, 48, 48, 48,
				48, 48
			},
			new int[12]
			{
				48, 48, 4, 516, 48, 48, 48, 48, 48, 48,
				48, 48
			},
			new int[12]
			{
				48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
				48, 48
			},
			new int[12]
			{
				48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
				48, 48
			},
			new int[12]
			{
				48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
				48, 48
			},
			new int[12]
			{
				48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
				48, 16393
			},
			new int[12]
			{
				48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
				16393, 48
			},
			new int[12]
			{
				48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
				48, 48
			}
		};

		internal int State
		{
			get
			{
				return _State;
			}
			set
			{
				_State = value;
			}
		}

		internal StateMachine()
		{
			_State = 0;
		}

		internal void Reset()
		{
			_State = 0;
		}

		internal static int StateOnly(int state)
		{
			return state & 0xF;
		}

		internal int BeginOutlook(XPathNodeType nodeType)
		{
			return s_BeginTransitions[(int)nodeType][_State];
		}

		internal int Begin(XPathNodeType nodeType)
		{
			int num = s_BeginTransitions[(int)nodeType][_State];
			if (num != 16 && num != 32)
			{
				_State = num & 0xF;
			}
			return num;
		}

		internal int EndOutlook(XPathNodeType nodeType)
		{
			return s_EndTransitions[(int)nodeType][_State];
		}

		internal int End(XPathNodeType nodeType)
		{
			int num = s_EndTransitions[(int)nodeType][_State];
			if (num != 16 && num != 32)
			{
				_State = num & 0xF;
			}
			return num;
		}
	}
	internal class StringOutput : SequentialOutput
	{
		private StringBuilder builder;

		private string result;

		internal string Result => result;

		internal StringOutput(Processor processor)
			: base(processor)
		{
			builder = new StringBuilder();
		}

		internal override void Write(char outputChar)
		{
			builder.Append(outputChar);
		}

		internal override void Write(string outputText)
		{
			builder.Append(outputText);
		}

		internal override void Close()
		{
			result = builder.ToString();
		}
	}
	internal class Stylesheet
	{
		private class WhitespaceElement
		{
			private int key;

			private double priority;

			private bool preserveSpace;

			internal double Priority => priority;

			internal int Key => key;

			internal bool PreserveSpace => preserveSpace;

			internal WhitespaceElement(int Key, double priority, bool PreserveSpace)
			{
				key = Key;
				this.priority = priority;
				preserveSpace = PreserveSpace;
			}

			internal void ReplaceValue(bool PreserveSpace)
			{
				preserveSpace = PreserveSpace;
			}
		}

		private ArrayList imports = new ArrayList();

		private Hashtable modeManagers;

		private Hashtable templateNameTable = new Hashtable();

		private Hashtable attributeSetTable;

		private int templateCount;

		private Hashtable queryKeyTable;

		private ArrayList whitespaceList;

		private bool whitespace;

		private Hashtable scriptObjectTypes = new Hashtable();

		private TemplateManager templates;

		internal bool Whitespace => whitespace;

		internal ArrayList Imports => imports;

		internal Hashtable AttributeSetTable => attributeSetTable;

		internal Hashtable ScriptObjectTypes => scriptObjectTypes;

		internal void AddSpace(Compiler compiler, string query, double Priority, bool PreserveSpace)
		{
			WhitespaceElement whitespaceElement;
			if (queryKeyTable != null)
			{
				if (queryKeyTable.Contains(query))
				{
					whitespaceElement = (WhitespaceElement)queryKeyTable[query];
					whitespaceElement.ReplaceValue(PreserveSpace);
					return;
				}
			}
			else
			{
				queryKeyTable = new Hashtable();
				whitespaceList = new ArrayList();
			}
			int key = compiler.AddQuery(query);
			whitespaceElement = new WhitespaceElement(key, Priority, PreserveSpace);
			queryKeyTable[query] = whitespaceElement;
			whitespaceList.Add(whitespaceElement);
		}

		internal void SortWhiteSpace()
		{
			if (queryKeyTable != null)
			{
				for (int i = 0; i < whitespaceList.Count; i++)
				{
					for (int num = whitespaceList.Count - 1; num > i; num--)
					{
						WhitespaceElement whitespaceElement = (WhitespaceElement)whitespaceList[num - 1];
						WhitespaceElement whitespaceElement2 = (WhitespaceElement)whitespaceList[num];
						if (whitespaceElement2.Priority < whitespaceElement.Priority)
						{
							whitespaceList[num - 1] = whitespaceElement2;
							whitespaceList[num] = whitespaceElement;
						}
					}
				}
				whitespace = true;
			}
			if (imports == null)
			{
				return;
			}
			for (int num2 = imports.Count - 1; num2 >= 0; num2--)
			{
				Stylesheet stylesheet = (Stylesheet)imports[num2];
				if (stylesheet.Whitespace)
				{
					stylesheet.SortWhiteSpace();
					whitespace = true;
				}
			}
		}

		internal bool PreserveWhiteSpace(Processor proc, XPathNavigator node)
		{
			if (whitespaceList != null)
			{
				int num = whitespaceList.Count - 1;
				while (0 <= num)
				{
					WhitespaceElement whitespaceElement = (WhitespaceElement)whitespaceList[num];
					if (proc.Matches(node, whitespaceElement.Key))
					{
						return whitespaceElement.PreserveSpace;
					}
					num--;
				}
			}
			if (imports != null)
			{
				for (int num2 = imports.Count - 1; num2 >= 0; num2--)
				{
					Stylesheet stylesheet = (Stylesheet)imports[num2];
					if (!stylesheet.PreserveWhiteSpace(proc, node))
					{
						return false;
					}
				}
			}
			return true;
		}

		internal void AddAttributeSet(AttributeSetAction attributeSet)
		{
			if (attributeSetTable == null)
			{
				attributeSetTable = new Hashtable();
			}
			if (!attributeSetTable.ContainsKey(attributeSet.Name))
			{
				attributeSetTable[attributeSet.Name] = attributeSet;
			}
			else
			{
				((AttributeSetAction)attributeSetTable[attributeSet.Name]).Merge(attributeSet);
			}
		}

		internal void AddTemplate(TemplateAction template)
		{
			XmlQualifiedName xmlQualifiedName = template.Mode;
			if (template.Name != null)
			{
				if (templateNameTable.ContainsKey(template.Name))
				{
					throw XsltException.Create("Xslt_DupTemplateName", template.Name.ToString());
				}
				templateNameTable[template.Name] = template;
			}
			if (template.MatchKey == -1)
			{
				return;
			}
			if (modeManagers == null)
			{
				modeManagers = new Hashtable();
			}
			if (xmlQualifiedName == null)
			{
				xmlQualifiedName = XmlQualifiedName.Empty;
			}
			TemplateManager templateManager = (TemplateManager)modeManagers[xmlQualifiedName];
			if (templateManager == null)
			{
				templateManager = new TemplateManager(this, xmlQualifiedName);
				modeManagers[xmlQualifiedName] = templateManager;
				if (xmlQualifiedName.IsEmpty)
				{
					templates = templateManager;
				}
			}
			template.TemplateId = ++templateCount;
			templateManager.AddTemplate(template);
		}

		internal void ProcessTemplates()
		{
			if (modeManagers != null)
			{
				IDictionaryEnumerator enumerator = modeManagers.GetEnumerator();
				while (enumerator.MoveNext())
				{
					TemplateManager templateManager = (TemplateManager)enumerator.Value;
					templateManager.ProcessTemplates();
				}
			}
			if (imports != null)
			{
				for (int num = imports.Count - 1; num >= 0; num--)
				{
					Stylesheet stylesheet = (Stylesheet)imports[num];
					stylesheet.ProcessTemplates();
				}
			}
		}

		internal void ReplaceNamespaceAlias(Compiler compiler)
		{
			if (modeManagers != null)
			{
				IDictionaryEnumerator enumerator = modeManagers.GetEnumerator();
				while (enumerator.MoveNext())
				{
					TemplateManager templateManager = (TemplateManager)enumerator.Value;
					if (templateManager.templates != null)
					{
						for (int i = 0; i < templateManager.templates.Count; i++)
						{
							TemplateAction templateAction = (TemplateAction)templateManager.templates[i];
							templateAction.ReplaceNamespaceAlias(compiler);
						}
					}
				}
			}
			if (templateNameTable != null)
			{
				IDictionaryEnumerator enumerator2 = templateNameTable.GetEnumerator();
				while (enumerator2.MoveNext())
				{
					TemplateAction templateAction2 = (TemplateAction)enumerator2.Value;
					templateAction2.ReplaceNamespaceAlias(compiler);
				}
			}
			if (imports != null)
			{
				for (int num = imports.Count - 1; num >= 0; num--)
				{
					Stylesheet stylesheet = (Stylesheet)imports[num];
					stylesheet.ReplaceNamespaceAlias(compiler);
				}
			}
		}

		internal TemplateAction FindTemplate(Processor processor, XPathNavigator navigator, XmlQualifiedName mode)
		{
			TemplateAction templateAction = null;
			if (modeManagers != null)
			{
				TemplateManager templateManager = (TemplateManager)modeManagers[mode];
				if (templateManager != null)
				{
					templateAction = templateManager.FindTemplate(processor, navigator);
				}
			}
			if (templateAction == null)
			{
				templateAction = FindTemplateImports(processor, navigator, mode);
			}
			return templateAction;
		}

		internal TemplateAction FindTemplateImports(Processor processor, XPathNavigator navigator, XmlQualifiedName mode)
		{
			TemplateAction templateAction = null;
			if (imports != null)
			{
				for (int num = imports.Count - 1; num >= 0; num--)
				{
					Stylesheet stylesheet = (Stylesheet)imports[num];
					templateAction = stylesheet.FindTemplate(processor, navigator, mode);
					if (templateAction != null)
					{
						return templateAction;
					}
				}
			}
			return templateAction;
		}

		internal TemplateAction FindTemplate(Processor processor, XPathNavigator navigator)
		{
			TemplateAction templateAction = null;
			if (templates != null)
			{
				templateAction = templates.FindTemplate(processor, navigator);
			}
			if (templateAction == null)
			{
				templateAction = FindTemplateImports(processor, navigator);
			}
			return templateAction;
		}

		internal TemplateAction FindTemplate(XmlQualifiedName name)
		{
			TemplateAction templateAction = null;
			if (templateNameTable != null)
			{
				templateAction = (TemplateAction)templateNameTable[name];
			}
			if (templateAction == null && imports != null)
			{
				for (int num = imports.Count - 1; num >= 0; num--)
				{
					Stylesheet stylesheet = (Stylesheet)imports[num];
					templateAction = stylesheet.FindTemplate(name);
					if (templateAction != null)
					{
						return templateAction;
					}
				}
			}
			return templateAction;
		}

		internal TemplateAction FindTemplateImports(Processor processor, XPathNavigator navigator)
		{
			TemplateAction templateAction = null;
			if (imports != null)
			{
				for (int num = imports.Count - 1; num >= 0; num--)
				{
					Stylesheet stylesheet = (Stylesheet)imports[num];
					templateAction = stylesheet.FindTemplate(processor, navigator);
					if (templateAction != null)
					{
						return templateAction;
					}
				}
			}
			return templateAction;
		}
	}
	internal class TemplateLookupAction : Action
	{
		protected XmlQualifiedName mode;

		protected Stylesheet importsOf;

		internal void Initialize(XmlQualifiedName mode, Stylesheet importsOf)
		{
			this.mode = mode;
			this.importsOf = importsOf;
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			Action action = null;
			action = ((!(mode != null)) ? ((importsOf == null) ? processor.Stylesheet.FindTemplate(processor, frame.Node) : importsOf.FindTemplateImports(processor, frame.Node)) : ((importsOf == null) ? processor.Stylesheet.FindTemplate(processor, frame.Node, mode) : importsOf.FindTemplateImports(processor, frame.Node, mode)));
			if (action == null)
			{
				action = BuiltInTemplate(frame.Node);
			}
			if (action != null)
			{
				frame.SetAction(action);
			}
			else
			{
				frame.Finished();
			}
		}

		internal Action BuiltInTemplate(XPathNavigator node)
		{
			Action result = null;
			switch (node.NodeType)
			{
			case XPathNodeType.Root:
			case XPathNodeType.Element:
				result = ApplyTemplatesAction.BuiltInRule(mode);
				break;
			case XPathNodeType.Attribute:
			case XPathNodeType.Text:
			case XPathNodeType.SignificantWhitespace:
			case XPathNodeType.Whitespace:
				result = ValueOfAction.BuiltInRule();
				break;
			}
			return result;
		}
	}
	internal class TemplateLookupActionDbg : TemplateLookupAction
	{
		internal override void Execute(Processor processor, ActionFrame frame)
		{
			Action action = null;
			if (mode == Compiler.BuiltInMode)
			{
				mode = processor.GetPrevioseMode();
			}
			processor.SetCurrentMode(mode);
			action = ((!(mode != null)) ? ((importsOf == null) ? processor.Stylesheet.FindTemplate(processor, frame.Node) : importsOf.FindTemplateImports(processor, frame.Node)) : ((importsOf == null) ? processor.Stylesheet.FindTemplate(processor, frame.Node, mode) : importsOf.FindTemplateImports(processor, frame.Node, mode)));
			if (action == null && processor.RootAction.builtInSheet != null)
			{
				action = processor.RootAction.builtInSheet.FindTemplate(processor, frame.Node, Compiler.BuiltInMode);
			}
			if (action == null)
			{
				action = BuiltInTemplate(frame.Node);
			}
			if (action != null)
			{
				frame.SetAction(action);
			}
			else
			{
				frame.Finished();
			}
		}
	}
	internal class TemplateManager
	{
		private class TemplateComparer : IComparer
		{
			public int Compare(object x, object y)
			{
				TemplateAction templateAction = (TemplateAction)x;
				TemplateAction templateAction2 = (TemplateAction)y;
				if (templateAction.Priority == templateAction2.Priority)
				{
					return templateAction.TemplateId - templateAction2.TemplateId;
				}
				if (!(templateAction.Priority > templateAction2.Priority))
				{
					return -1;
				}
				return 1;
			}
		}

		private XmlQualifiedName mode;

		internal ArrayList templates;

		private Stylesheet stylesheet;

		private static TemplateComparer s_TemplateComparer = new TemplateComparer();

		internal XmlQualifiedName Mode => mode;

		internal TemplateManager(Stylesheet stylesheet, XmlQualifiedName mode)
		{
			this.mode = mode;
			this.stylesheet = stylesheet;
		}

		internal void AddTemplate(TemplateAction template)
		{
			if (templates == null)
			{
				templates = new ArrayList();
			}
			templates.Add(template);
		}

		internal void ProcessTemplates()
		{
			if (templates != null)
			{
				templates.Sort(s_TemplateComparer);
			}
		}

		internal TemplateAction FindTemplate(Processor processor, XPathNavigator navigator)
		{
			if (templates == null)
			{
				return null;
			}
			for (int num = templates.Count - 1; num >= 0; num--)
			{
				TemplateAction templateAction = (TemplateAction)templates[num];
				int matchKey = templateAction.MatchKey;
				if (matchKey != -1 && processor.Matches(navigator, matchKey))
				{
					return templateAction;
				}
			}
			return null;
		}
	}
	internal class TextOnlyOutput : RecordOutput
	{
		private Processor processor;

		private TextWriter writer;

		internal XsltOutput Output => processor.Output;

		public TextWriter Writer => writer;

		internal TextOnlyOutput(Processor processor, Stream stream)
		{
			if (stream == null)
			{
				throw new ArgumentNullException("stream");
			}
			this.processor = processor;
			writer = new StreamWriter(stream, Output.Encoding);
		}

		internal TextOnlyOutput(Processor processor, TextWriter writer)
		{
			if (writer == null)
			{
				throw new ArgumentNullException("writer");
			}
			this.processor = processor;
			this.writer = writer;
		}

		public Processor.OutputResult RecordDone(RecordBuilder record)
		{
			BuilderInfo mainNode = record.MainNode;
			switch (mainNode.NodeType)
			{
			case XmlNodeType.Text:
			case XmlNodeType.Whitespace:
			case XmlNodeType.SignificantWhitespace:
				writer.Write(mainNode.Value);
				break;
			}
			record.Reset();
			return Processor.OutputResult.Continue;
		}

		public void TheEnd()
		{
			writer.Flush();
		}
	}
	internal class TextOutput : SequentialOutput
	{
		private TextWriter writer;

		internal TextOutput(Processor processor, Stream stream)
			: base(processor)
		{
			if (stream == null)
			{
				throw new ArgumentNullException("stream");
			}
			encoding = processor.Output.Encoding;
			writer = new StreamWriter(stream, encoding);
		}

		internal TextOutput(Processor processor, TextWriter writer)
			: base(processor)
		{
			if (writer == null)
			{
				throw new ArgumentNullException("writer");
			}
			encoding = writer.Encoding;
			this.writer = writer;
		}

		internal override void Write(char outputChar)
		{
			writer.Write(outputChar);
		}

		internal override void Write(string outputText)
		{
			writer.Write(outputText);
		}

		internal override void Close()
		{
			writer.Flush();
			writer = null;
		}
	}
	internal sealed class TheQuery
	{
		internal InputScopeManager _ScopeManager;

		private CompiledXpathExpr _CompiledQuery;

		internal CompiledXpathExpr CompiledQuery => _CompiledQuery;

		internal TheQuery(CompiledXpathExpr compiledQuery, InputScopeManager manager)
		{
			_CompiledQuery = compiledQuery;
			_ScopeManager = manager.Clone();
		}
	}
	internal class BuiltInRuleTextAction : Action
	{
		private const int ResultStored = 2;

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			case 0:
			{
				string text = processor.ValueOf(frame.NodeSet.Current);
				if (processor.TextEvent(text, disableOutputEscaping: false))
				{
					frame.Finished();
					break;
				}
				frame.StoredOutput = text;
				frame.State = 2;
				break;
			}
			case 2:
				processor.TextEvent(frame.StoredOutput);
				frame.Finished();
				break;
			case 1:
				break;
			}
		}
	}
	internal enum VariableType
	{
		GlobalVariable,
		GlobalParameter,
		LocalVariable,
		LocalParameter,
		WithParameter
	}
	internal class WriterOutput : RecordOutput
	{
		private XmlWriter writer;

		private Processor processor;

		internal WriterOutput(Processor processor, XmlWriter writer)
		{
			if (writer == null)
			{
				throw new ArgumentNullException("writer");
			}
			this.writer = writer;
			this.processor = processor;
		}

		public Processor.OutputResult RecordDone(RecordBuilder record)
		{
			BuilderInfo mainNode = record.MainNode;
			switch (mainNode.NodeType)
			{
			case XmlNodeType.Element:
				writer.WriteStartElement(mainNode.Prefix, mainNode.LocalName, mainNode.NamespaceURI);
				WriteAttributes(record.AttributeList, record.AttributeCount);
				if (mainNode.IsEmptyTag)
				{
					writer.WriteEndElement();
				}
				break;
			case XmlNodeType.Text:
			case XmlNodeType.Whitespace:
			case XmlNodeType.SignificantWhitespace:
				writer.WriteString(mainNode.Value);
				break;
			case XmlNodeType.CDATA:
				writer.WriteCData(mainNode.Value);
				break;
			case XmlNodeType.EntityReference:
				writer.WriteEntityRef(mainNode.LocalName);
				break;
			case XmlNodeType.ProcessingInstruction:
				writer.WriteProcessingInstruction(mainNode.LocalName, mainNode.Value);
				break;
			case XmlNodeType.Comment:
				writer.WriteComment(mainNode.Value);
				break;
			case XmlNodeType.DocumentType:
				writer.WriteRaw(mainNode.Value);
				break;
			case XmlNodeType.EndElement:
				writer.WriteFullEndElement();
				break;
			}
			record.Reset();
			return Processor.OutputResult.Continue;
		}

		public void TheEnd()
		{
			writer.Flush();
			writer = null;
		}

		private void WriteAttributes(ArrayList list, int count)
		{
			for (int i = 0; i < count; i++)
			{
				BuilderInfo builderInfo = (BuilderInfo)list[i];
				writer.WriteAttributeString(builderInfo.Prefix, builderInfo.LocalName, builderInfo.NamespaceURI, builderInfo.Value);
			}
		}
	}
	internal class XsltCompileContext : XsltContext
	{
		private abstract class XsltFunctionImpl : IXsltContextFunction
		{
			private int minargs;

			private int maxargs;

			private XPathResultType returnType;

			private XPathResultType[] argTypes;

			public int Minargs => minargs;

			public int Maxargs => maxargs;

			public XPathResultType ReturnType => returnType;

			public XPathResultType[] ArgTypes => argTypes;

			public XsltFunctionImpl()
			{
			}

			public XsltFunctionImpl(int minArgs, int maxArgs, XPathResultType returnType, XPathResultType[] argTypes)
			{
				Init(minArgs, maxArgs, returnType, argTypes);
			}

			protected void Init(int minArgs, int maxArgs, XPathResultType returnType, XPathResultType[] argTypes)
			{
				minargs = minArgs;
				maxargs = maxArgs;
				this.returnType = returnType;
				this.argTypes = argTypes;
			}

			public abstract object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext);

			public static XPathNodeIterator ToIterator(object argument)
			{
				if (!(argument is XPathNodeIterator result))
				{
					throw XsltException.Create("Xslt_NoNodeSetConversion");
				}
				return result;
			}

			public static XPathNavigator ToNavigator(object argument)
			{
				if (!(argument is XPathNavigator result))
				{
					throw XsltException.Create("Xslt_NoNavigatorConversion");
				}
				return result;
			}

			private static string IteratorToString(XPathNodeIterator it)
			{
				if (it.MoveNext())
				{
					return it.Current.Value;
				}
				return string.Empty;
			}

			public static string ToString(object argument)
			{
				if (argument is XPathNodeIterator it)
				{
					return IteratorToString(it);
				}
				return XmlConvert.ToXPathString(argument);
			}

			public static bool ToBoolean(object argument)
			{
				if (argument is XPathNodeIterator it)
				{
					return Convert.ToBoolean(IteratorToString(it), CultureInfo.InvariantCulture);
				}
				if (argument is XPathNavigator xPathNavigator)
				{
					return Convert.ToBoolean(xPathNavigator.ToString(), CultureInfo.InvariantCulture);
				}
				return Convert.ToBoolean(argument, CultureInfo.InvariantCulture);
			}

			public static double ToNumber(object argument)
			{
				if (argument is XPathNodeIterator it)
				{
					return XmlConvert.ToXPathDouble(IteratorToString(it));
				}
				if (argument is XPathNavigator xPathNavigator)
				{
					return XmlConvert.ToXPathDouble(xPathNavigator.ToString());
				}
				return XmlConvert.ToXPathDouble(argument);
			}

			private static object ToNumeric(object argument, TypeCode typeCode)
			{
				return Convert.ChangeType(ToNumber(argument), typeCode, CultureInfo.InvariantCulture);
			}

			public static object ConvertToXPathType(object val, XPathResultType xt, TypeCode typeCode)
			{
				switch (xt)
				{
				case XPathResultType.String:
					if (typeCode == TypeCode.String)
					{
						return ToString(val);
					}
					return ToNavigator(val);
				case XPathResultType.Number:
					return ToNumeric(val, typeCode);
				case XPathResultType.Boolean:
					return ToBoolean(val);
				case XPathResultType.NodeSet:
					return ToIterator(val);
				case XPathResultType.Any:
				case XPathResultType.Error:
					return val;
				default:
					return val;
				}
			}
		}

		private class FuncCurrent : XsltFunctionImpl
		{
			public FuncCurrent()
				: base(0, 0, XPathResultType.NodeSet, new XPathResultType[0])
			{
			}

			public override object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext)
			{
				return ((XsltCompileContext)xsltContext).Current();
			}
		}

		private class FuncUnEntityUri : XsltFunctionImpl
		{
			public FuncUnEntityUri()
				: base(1, 1, XPathResultType.String, new XPathResultType[1] { XPathResultType.String })
			{
			}

			public override object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext)
			{
				throw XsltException.Create("Xslt_UnsuppFunction", "unparsed-entity-uri");
			}
		}

		private class FuncGenerateId : XsltFunctionImpl
		{
			public FuncGenerateId()
				: base(0, 1, XPathResultType.String, new XPathResultType[1] { XPathResultType.NodeSet })
			{
			}

			public override object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext)
			{
				if (args.Length > 0)
				{
					XPathNodeIterator xPathNodeIterator = XsltFunctionImpl.ToIterator(args[0]);
					if (xPathNodeIterator.MoveNext())
					{
						return xPathNodeIterator.Current.UniqueId;
					}
					return string.Empty;
				}
				return docContext.UniqueId;
			}
		}

		private class FuncSystemProp : XsltFunctionImpl
		{
			public FuncSystemProp()
				: base(1, 1, XPathResultType.String, new XPathResultType[1] { XPathResultType.String })
			{
			}

			public override object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext)
			{
				return ((XsltCompileContext)xsltContext).SystemProperty(XsltFunctionImpl.ToString(args[0]));
			}
		}

		private class FuncElementAvailable : XsltFunctionImpl
		{
			public FuncElementAvailable()
				: base(1, 1, XPathResultType.Boolean, new XPathResultType[1] { XPathResultType.String })
			{
			}

			public override object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext)
			{
				return ((XsltCompileContext)xsltContext).ElementAvailable(XsltFunctionImpl.ToString(args[0]));
			}
		}

		private class FuncFunctionAvailable : XsltFunctionImpl
		{
			public FuncFunctionAvailable()
				: base(1, 1, XPathResultType.Boolean, new XPathResultType[1] { XPathResultType.String })
			{
			}

			public override object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext)
			{
				return ((XsltCompileContext)xsltContext).FunctionAvailable(XsltFunctionImpl.ToString(args[0]));
			}
		}

		private class FuncDocument : XsltFunctionImpl
		{
			public FuncDocument()
				: base(1, 2, XPathResultType.NodeSet, new XPathResultType[2]
				{
					XPathResultType.Any,
					XPathResultType.NodeSet
				})
			{
			}

			public override object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext)
			{
				string baseUri = null;
				if (args.Length == 2)
				{
					XPathNodeIterator xPathNodeIterator = XsltFunctionImpl.ToIterator(args[1]);
					baseUri = ((!xPathNodeIterator.MoveNext()) ? string.Empty : xPathNodeIterator.Current.BaseURI);
				}
				try
				{
					return ((XsltCompileContext)xsltContext).Document(args[0], baseUri);
				}
				catch (Exception e)
				{
					if (!XmlException.IsCatchableException(e))
					{
						throw;
					}
					return XPathEmptyIterator.Instance;
				}
			}
		}

		private class FuncKey : XsltFunctionImpl
		{
			public FuncKey()
				: base(2, 2, XPathResultType.NodeSet, new XPathResultType[2]
				{
					XPathResultType.String,
					XPathResultType.Any
				})
			{
			}

			public override object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext)
			{
				XsltCompileContext xsltCompileContext = (XsltCompileContext)xsltContext;
				PrefixQName.ParseQualifiedName(XsltFunctionImpl.ToString(args[0]), out var prefix, out var local);
				string ns = xsltContext.LookupNamespace(prefix);
				XmlQualifiedName xmlQualifiedName = new XmlQualifiedName(local, ns);
				XPathNavigator xPathNavigator = docContext.Clone();
				xPathNavigator.MoveToRoot();
				ArrayList arrayList = null;
				Key[] keyList = xsltCompileContext.processor.KeyList;
				foreach (Key key in keyList)
				{
					if (!(key.Name == xmlQualifiedName))
					{
						continue;
					}
					Hashtable hashtable = key.GetKeys(xPathNavigator);
					if (hashtable == null)
					{
						hashtable = xsltCompileContext.BuildKeyTable(key, xPathNavigator);
						key.AddKey(xPathNavigator, hashtable);
					}
					if (args[1] is XPathNodeIterator xPathNodeIterator)
					{
						XPathNodeIterator xPathNodeIterator2 = xPathNodeIterator.Clone();
						while (xPathNodeIterator2.MoveNext())
						{
							arrayList = AddToList(arrayList, (ArrayList)hashtable[xPathNodeIterator2.Current.Value]);
						}
					}
					else
					{
						arrayList = AddToList(arrayList, (ArrayList)hashtable[XsltFunctionImpl.ToString(args[1])]);
					}
				}
				if (arrayList == null)
				{
					return XPathEmptyIterator.Instance;
				}
				if (arrayList[0] is XPathNavigator)
				{
					return new XPathArrayIterator(arrayList);
				}
				return new XPathMultyIterator(arrayList);
			}

			private static ArrayList AddToList(ArrayList resultCollection, ArrayList newList)
			{
				if (newList == null)
				{
					return resultCollection;
				}
				if (resultCollection == null)
				{
					return newList;
				}
				if (!(resultCollection[0] is ArrayList))
				{
					ArrayList value = resultCollection;
					resultCollection = new ArrayList();
					resultCollection.Add(value);
				}
				resultCollection.Add(newList);
				return resultCollection;
			}
		}

		private class FuncFormatNumber : XsltFunctionImpl
		{
			public FuncFormatNumber()
				: base(2, 3, XPathResultType.String, new XPathResultType[3]
				{
					XPathResultType.Number,
					XPathResultType.String,
					XPathResultType.String
				})
			{
			}

			public override object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext)
			{
				DecimalFormat decimalFormat = ((XsltCompileContext)xsltContext).ResolveFormatName((args.Length == 3) ? XsltFunctionImpl.ToString(args[2]) : null);
				return DecimalFormatter.Format(XsltFunctionImpl.ToNumber(args[0]), XsltFunctionImpl.ToString(args[1]), decimalFormat);
			}
		}

		private class FuncNodeSet : XsltFunctionImpl
		{
			public FuncNodeSet()
				: base(1, 1, XPathResultType.NodeSet, new XPathResultType[1] { XPathResultType.String })
			{
			}

			public override object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext)
			{
				return new XPathSingletonIterator(XsltFunctionImpl.ToNavigator(args[0]));
			}
		}

		private class FuncExtension : XsltFunctionImpl
		{
			private object extension;

			private MethodInfo method;

			private TypeCode[] typeCodes;

			private PermissionSet permissions;

			public FuncExtension(object extension, MethodInfo method, PermissionSet permissions)
			{
				this.extension = extension;
				this.method = method;
				this.permissions = permissions;
				XPathResultType xPathType = GetXPathType(method.ReturnType);
				ParameterInfo[] parameters = method.GetParameters();
				int num = parameters.Length;
				int maxArgs = parameters.Length;
				typeCodes = new TypeCode[parameters.Length];
				XPathResultType[] array = new XPathResultType[parameters.Length];
				bool flag = true;
				int num2 = parameters.Length - 1;
				while (0 <= num2)
				{
					typeCodes[num2] = Type.GetTypeCode(parameters[num2].ParameterType);
					array[num2] = GetXPathType(parameters[num2].ParameterType);
					if (flag)
					{
						if (parameters[num2].IsOptional)
						{
							num--;
						}
						else
						{
							flag = false;
						}
					}
					num2--;
				}
				Init(num, maxArgs, xPathType, array);
			}

			public override object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext)
			{
				int num = args.Length - 1;
				while (0 <= num)
				{
					args[num] = XsltFunctionImpl.ConvertToXPathType(args[num], base.ArgTypes[num], typeCodes[num]);
					num--;
				}
				if (permissions != null)
				{
					permissions.PermitOnly();
				}
				return method.Invoke(extension, args);
			}
		}

		private const string f_NodeSet = "node-set";

		private const BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic;

		private InputScopeManager manager;

		private Processor processor;

		private static Hashtable s_FunctionTable = CreateFunctionTable();

		private static IXsltContextFunction s_FuncNodeSet = new FuncNodeSet();

		public override string DefaultNamespace => string.Empty;

		public override bool Whitespace => processor.Stylesheet.Whitespace;

		internal XsltCompileContext(InputScopeManager manager, Processor processor)
			: base(dummy: false)
		{
			this.manager = manager;
			this.processor = processor;
		}

		internal XsltCompileContext()
			: base(dummy: false)
		{
		}

		internal void Recycle()
		{
			manager = null;
			processor = null;
		}

		internal void Reinitialize(InputScopeManager manager, Processor processor)
		{
			this.manager = manager;
			this.processor = processor;
		}

		public override int CompareDocument(string baseUri, string nextbaseUri)
		{
			return string.Compare(baseUri, nextbaseUri, StringComparison.Ordinal);
		}

		public override string LookupNamespace(string prefix)
		{
			return manager.ResolveXPathNamespace(prefix);
		}

		public override IXsltContextVariable ResolveVariable(string prefix, string name)
		{
			string ns = LookupNamespace(prefix);
			XmlQualifiedName xmlQualifiedName = new XmlQualifiedName(name, ns);
			IXsltContextVariable xsltContextVariable = manager.VariableScope.ResolveVariable(xmlQualifiedName);
			if (xsltContextVariable == null)
			{
				throw XsltException.Create("Xslt_InvalidVariable", xmlQualifiedName.ToString());
			}
			return xsltContextVariable;
		}

		internal object EvaluateVariable(VariableAction variable)
		{
			object variableValue = processor.GetVariableValue(variable);
			if (variableValue == null && !variable.IsGlobal)
			{
				VariableAction variableAction = manager.VariableScope.ResolveGlobalVariable(variable.Name);
				if (variableAction != null)
				{
					variableValue = processor.GetVariableValue(variableAction);
				}
			}
			if (variableValue == null)
			{
				throw XsltException.Create("Xslt_InvalidVariable", variable.Name.ToString());
			}
			return variableValue;
		}

		public override bool PreserveWhitespace(XPathNavigator node)
		{
			node = node.Clone();
			node.MoveToParent();
			return processor.Stylesheet.PreserveWhiteSpace(processor, node);
		}

		private MethodInfo FindBestMethod(MethodInfo[] methods, bool ignoreCase, bool publicOnly, string name, XPathResultType[] argTypes)
		{
			int num = methods.Length;
			int num2 = 0;
			for (int i = 0; i < num; i++)
			{
				if (string.Compare(name, methods[i].Name, ignoreCase ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal) == 0 && (!publicOnly || methods[i].GetBaseDefinition().IsPublic))
				{
					methods[num2++] = methods[i];
				}
			}
			num = num2;
			if (num == 0)
			{
				return null;
			}
			if (argTypes == null)
			{
				return methods[0];
			}
			num2 = 0;
			for (int j = 0; j < num; j++)
			{
				if (methods[j].GetParameters().Length == argTypes.Length)
				{
					methods[num2++] = methods[j];
				}
			}
			num = num2;
			if (num <= 1)
			{
				return methods[0];
			}
			num2 = 0;
			for (int k = 0; k < num; k++)
			{
				bool flag = true;
				ParameterInfo[] parameters = methods[k].GetParameters();
				for (int l = 0; l < parameters.Length; l++)
				{
					XPathResultType xPathResultType = argTypes[l];
					if (xPathResultType != XPathResultType.Any)
					{
						XPathResultType xPathType = GetXPathType(parameters[l].ParameterType);
						if (xPathType != xPathResultType && xPathType != XPathResultType.Any)
						{
							flag = false;
							break;
						}
					}
				}
				if (flag)
				{
					methods[num2++] = methods[k];
				}
			}
			num = num2;
			return methods[0];
		}

		private IXsltContextFunction GetExtentionMethod(string ns, string name, XPathResultType[] argTypes, out object extension)
		{
			FuncExtension result = null;
			extension = processor.GetScriptObject(ns);
			if (extension != null)
			{
				MethodInfo methodInfo = FindBestMethod(extension.GetType().GetMethods(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic), ignoreCase: true, publicOnly: false, name, argTypes);
				if (methodInfo != null)
				{
					result = new FuncExtension(extension, methodInfo, null);
				}
				return result;
			}
			extension = processor.GetExtensionObject(ns);
			if (extension != null)
			{
				MethodInfo methodInfo2 = FindBestMethod(extension.GetType().GetMethods(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic), ignoreCase: false, publicOnly: true, name, argTypes);
				if (methodInfo2 != null)
				{
					result = new FuncExtension(extension, methodInfo2, processor.permissions);
				}
				return result;
			}
			return null;
		}

		public override IXsltContextFunction ResolveFunction(string prefix, string name, XPathResultType[] argTypes)
		{
			IXsltContextFunction xsltContextFunction = null;
			if (prefix.Length == 0)
			{
				xsltContextFunction = s_FunctionTable[name] as IXsltContextFunction;
			}
			else
			{
				string text = LookupNamespace(prefix);
				if (text == "urn:schemas-microsoft-com:xslt" && name == "node-set")
				{
					xsltContextFunction = s_FuncNodeSet;
				}
				else
				{
					xsltContextFunction = GetExtentionMethod(text, name, argTypes, out var extension);
					if (extension == null)
					{
						throw XsltException.Create("Xslt_ScriptInvalidPrefix", prefix);
					}
				}
			}
			if (xsltContextFunction == null)
			{
				throw XsltException.Create("Xslt_UnknownXsltFunction", name);
			}
			if (argTypes.Length < xsltContextFunction.Minargs || xsltContextFunction.Maxargs < argTypes.Length)
			{
				throw XsltException.Create("Xslt_WrongNumberArgs", name, argTypes.Length.ToString(CultureInfo.InvariantCulture));
			}
			return xsltContextFunction;
		}

		private Uri ComposeUri(string thisUri, string baseUri)
		{
			XmlResolver resolver = processor.Resolver;
			Uri baseUri2 = null;
			if (baseUri.Length != 0)
			{
				baseUri2 = resolver.ResolveUri(null, baseUri);
			}
			return resolver.ResolveUri(baseUri2, thisUri);
		}

		private XPathNodeIterator Document(object arg0, string baseUri)
		{
			if (processor.permissions != null)
			{
				processor.permissions.PermitOnly();
			}
			if (arg0 is XPathNodeIterator xPathNodeIterator)
			{
				ArrayList arrayList = new ArrayList();
				Hashtable hashtable = new Hashtable();
				while (xPathNodeIterator.MoveNext())
				{
					Uri uri = ComposeUri(xPathNodeIterator.Current.Value, baseUri ?? xPathNodeIterator.Current.BaseURI);
					if (!hashtable.ContainsKey(uri))
					{
						hashtable.Add(uri, null);
						arrayList.Add(processor.GetNavigator(uri));
					}
				}
				return new XPathArrayIterator(arrayList);
			}
			return new XPathSingletonIterator(processor.GetNavigator(ComposeUri(XmlConvert.ToXPathString(arg0), baseUri ?? manager.Navigator.BaseURI)));
		}

		private Hashtable BuildKeyTable(Key key, XPathNavigator root)
		{
			Hashtable hashtable = new Hashtable();
			string queryExpression = processor.GetQueryExpression(key.MatchKey);
			Query compiledQuery = processor.GetCompiledQuery(key.MatchKey);
			Query compiledQuery2 = processor.GetCompiledQuery(key.UseKey);
			XPathNodeIterator xPathNodeIterator = root.SelectDescendants(XPathNodeType.All, matchSelf: false);
			while (xPathNodeIterator.MoveNext())
			{
				XPathNavigator current = xPathNodeIterator.Current;
				EvaluateKey(current, compiledQuery, queryExpression, compiledQuery2, hashtable);
				if (current.MoveToFirstAttribute())
				{
					do
					{
						EvaluateKey(current, compiledQuery, queryExpression, compiledQuery2, hashtable);
					}
					while (current.MoveToNextAttribute());
					current.MoveToParent();
				}
			}
			return hashtable;
		}

		private static void AddKeyValue(Hashtable keyTable, string key, XPathNavigator value, bool checkDuplicates)
		{
			ArrayList arrayList = (ArrayList)keyTable[key];
			if (arrayList == null)
			{
				arrayList = new ArrayList();
				keyTable.Add(key, arrayList);
			}
			else if (checkDuplicates && value.ComparePosition((XPathNavigator)arrayList[arrayList.Count - 1]) == XmlNodeOrder.Same)
			{
				return;
			}
			arrayList.Add(value.Clone());
		}

		private static void EvaluateKey(XPathNavigator node, Query matchExpr, string matchStr, Query useExpr, Hashtable keyTable)
		{
			try
			{
				if (matchExpr.MatchNode(node) == null)
				{
					return;
				}
			}
			catch (XPathException)
			{
				throw XsltException.Create("Xslt_InvalidPattern", matchStr);
			}
			object obj = useExpr.Evaluate(new XPathSingletonIterator(node, moved: true));
			if (obj is XPathNodeIterator xPathNodeIterator)
			{
				bool checkDuplicates = false;
				while (xPathNodeIterator.MoveNext())
				{
					AddKeyValue(keyTable, xPathNodeIterator.Current.Value, node, checkDuplicates);
					checkDuplicates = true;
				}
			}
			else
			{
				string key = XmlConvert.ToXPathString(obj);
				AddKeyValue(keyTable, key, node, checkDuplicates: false);
			}
		}

		private DecimalFormat ResolveFormatName(string formatName)
		{
			string ns = string.Empty;
			string local = string.Empty;
			if (formatName != null)
			{
				PrefixQName.ParseQualifiedName(formatName, out var prefix, out local);
				ns = LookupNamespace(prefix);
			}
			DecimalFormat decimalFormat = processor.RootAction.GetDecimalFormat(new XmlQualifiedName(local, ns));
			if (decimalFormat == null)
			{
				if (formatName != null)
				{
					throw XsltException.Create("Xslt_NoDecimalFormat", formatName);
				}
				decimalFormat = new DecimalFormat(new NumberFormatInfo(), '#', '0', ';');
			}
			return decimalFormat;
		}

		private bool ElementAvailable(string qname)
		{
			PrefixQName.ParseQualifiedName(qname, out var prefix, out var local);
			string text = manager.ResolveXmlNamespace(prefix);
			if (text == "http://www.w3.org/1999/XSL/Transform")
			{
				switch (local)
				{
				default:
					return local == "variable";
				case "apply-imports":
				case "apply-templates":
				case "attribute":
				case "call-template":
				case "choose":
				case "comment":
				case "copy":
				case "copy-of":
				case "element":
				case "fallback":
				case "for-each":
				case "if":
				case "message":
				case "number":
				case "processing-instruction":
				case "text":
				case "value-of":
					return true;
				}
			}
			return false;
		}

		private bool FunctionAvailable(string qname)
		{
			PrefixQName.ParseQualifiedName(qname, out var prefix, out var local);
			string text = LookupNamespace(prefix);
			if (text == "urn:schemas-microsoft-com:xslt")
			{
				return local == "node-set";
			}
			if (text.Length == 0)
			{
				switch (local)
				{
				default:
					if (s_FunctionTable[local] != null)
					{
						return local != "unparsed-entity-uri";
					}
					return false;
				case "last":
				case "position":
				case "name":
				case "namespace-uri":
				case "local-name":
				case "count":
				case "id":
				case "string":
				case "concat":
				case "starts-with":
				case "contains":
				case "substring-before":
				case "substring-after":
				case "substring":
				case "string-length":
				case "normalize-space":
				case "translate":
				case "boolean":
				case "not":
				case "true":
				case "false":
				case "lang":
				case "number":
				case "sum":
				case "floor":
				case "ceiling":
				case "round":
					return true;
				}
			}
			object extension;
			return GetExtentionMethod(text, local, null, out extension) != null;
		}

		private XPathNodeIterator Current()
		{
			XPathNavigator current = processor.Current;
			if (current != null)
			{
				return new XPathSingletonIterator(current.Clone());
			}
			return XPathEmptyIterator.Instance;
		}

		private string SystemProperty(string qname)
		{
			string result = string.Empty;
			PrefixQName.ParseQualifiedName(qname, out var prefix, out var local);
			string text = LookupNamespace(prefix);
			if (text == "http://www.w3.org/1999/XSL/Transform")
			{
				switch (local)
				{
				case "version":
					result = "1";
					break;
				case "vendor":
					result = "Microsoft";
					break;
				case "vendor-url":
					result = "http://www.microsoft.com";
					break;
				}
				return result;
			}
			if (text == null && prefix != null)
			{
				throw XsltException.Create("Xslt_InvalidPrefix", prefix);
			}
			return string.Empty;
		}

		public static XPathResultType GetXPathType(Type type)
		{
			switch (Type.GetTypeCode(type))
			{
			case TypeCode.String:
				return XPathResultType.String;
			case TypeCode.Boolean:
				return XPathResultType.Boolean;
			case TypeCode.Object:
				if (typeof(XPathNavigator).IsAssignableFrom(type) || typeof(IXPathNavigable).IsAssignableFrom(type))
				{
					return XPathResultType.String;
				}
				if (typeof(XPathNodeIterator).IsAssignableFrom(type))
				{
					return XPathResultType.NodeSet;
				}
				return XPathResultType.Any;
			case TypeCode.DateTime:
				return XPathResultType.Error;
			default:
				return XPathResultType.Number;
			}
		}

		private static Hashtable CreateFunctionTable()
		{
			Hashtable hashtable = new Hashtable(10);
			hashtable["current"] = new FuncCurrent();
			hashtable["unparsed-entity-uri"] = new FuncUnEntityUri();
			hashtable["generate-id"] = new FuncGenerateId();
			hashtable["system-property"] = new FuncSystemProp();
			hashtable["element-available"] = new FuncElementAvailable();
			hashtable["function-available"] = new FuncFunctionAvailable();
			hashtable["document"] = new FuncDocument();
			hashtable["key"] = new FuncKey();
			hashtable["format-number"] = new FuncFormatNumber();
			return hashtable;
		}
	}
}
namespace System.Xml.Xsl.XsltOld.Debugger
{
	internal interface IXsltDebugger
	{
		string GetBuiltInTemplatesUri();

		void OnInstructionCompile(XPathNavigator styleSheetNavigator);

		void OnInstructionExecute(IXsltProcessor xsltProcessor);
	}
}
namespace System.Xml.Xsl.XsltOld
{
	internal class XsltOutput : CompiledAction
	{
		internal enum OutputMethod
		{
			Xml,
			Html,
			Text,
			Other,
			Unknown
		}

		private OutputMethod method = OutputMethod.Unknown;

		private int methodSId = int.MaxValue;

		private Encoding encoding = Encoding.UTF8;

		private int encodingSId = int.MaxValue;

		private string version;

		private int versionSId = int.MaxValue;

		private bool omitXmlDecl;

		private int omitXmlDeclSId = int.MaxValue;

		private bool standalone;

		private int standaloneSId = int.MaxValue;

		private string doctypePublic;

		private int doctypePublicSId = int.MaxValue;

		private string doctypeSystem;

		private int doctypeSystemSId = int.MaxValue;

		private bool indent;

		private int indentSId = int.MaxValue;

		private string mediaType = "text/html";

		private int mediaTypeSId = int.MaxValue;

		private Hashtable cdataElements;

		internal OutputMethod Method => method;

		internal bool OmitXmlDeclaration => omitXmlDecl;

		internal bool HasStandalone => standaloneSId != int.MaxValue;

		internal bool Standalone => standalone;

		internal string DoctypePublic => doctypePublic;

		internal string DoctypeSystem => doctypeSystem;

		internal Hashtable CDataElements => cdataElements;

		internal bool Indent => indent;

		internal Encoding Encoding => encoding;

		internal string MediaType => mediaType;

		internal XsltOutput CreateDerivedOutput(OutputMethod method)
		{
			XsltOutput xsltOutput = (XsltOutput)MemberwiseClone();
			xsltOutput.method = method;
			if (method == OutputMethod.Html && indentSId == int.MaxValue)
			{
				xsltOutput.indent = true;
			}
			return xsltOutput;
		}

		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			CheckEmpty(compiler);
		}

		internal override bool CompileAttribute(Compiler compiler)
		{
			string localName = compiler.Input.LocalName;
			string value = compiler.Input.Value;
			if (Keywords.Equals(localName, compiler.Atoms.Method))
			{
				if (compiler.Stylesheetid <= methodSId)
				{
					method = ParseOutputMethod(value, compiler);
					methodSId = compiler.Stylesheetid;
					if (indentSId == int.MaxValue)
					{
						indent = method == OutputMethod.Html;
					}
				}
			}
			else if (Keywords.Equals(localName, compiler.Atoms.Version))
			{
				if (compiler.Stylesheetid <= versionSId)
				{
					version = value;
					versionSId = compiler.Stylesheetid;
				}
			}
			else if (Keywords.Equals(localName, compiler.Atoms.Encoding))
			{
				if (compiler.Stylesheetid <= encodingSId)
				{
					try
					{
						encoding = Encoding.GetEncoding(value);
						encodingSId = compiler.Stylesheetid;
					}
					catch (NotSupportedException)
					{
					}
					catch (ArgumentException)
					{
					}
				}
			}
			else if (Keywords.Equals(localName, compiler.Atoms.OmitXmlDeclaration))
			{
				if (compiler.Stylesheetid <= omitXmlDeclSId)
				{
					omitXmlDecl = compiler.GetYesNo(value);
					omitXmlDeclSId = compiler.Stylesheetid;
				}
			}
			else if (Keywords.Equals(localName, compiler.Atoms.Standalone))
			{
				if (compiler.Stylesheetid <= standaloneSId)
				{
					standalone = compiler.GetYesNo(value);
					standaloneSId = compiler.Stylesheetid;
				}
			}
			else if (Keywords.Equals(localName, compiler.Atoms.DoctypePublic))
			{
				if (compiler.Stylesheetid <= doctypePublicSId)
				{
					doctypePublic = value;
					doctypePublicSId = compiler.Stylesheetid;
				}
			}
			else if (Keywords.Equals(localName, compiler.Atoms.DoctypeSystem))
			{
				if (compiler.Stylesheetid <= doctypeSystemSId)
				{
					doctypeSystem = value;
					doctypeSystemSId = compiler.Stylesheetid;
				}
			}
			else if (Keywords.Equals(localName, compiler.Atoms.Indent))
			{
				if (compiler.Stylesheetid <= indentSId)
				{
					indent = compiler.GetYesNo(value);
					indentSId = compiler.Stylesheetid;
				}
			}
			else if (Keywords.Equals(localName, compiler.Atoms.MediaType))
			{
				if (compiler.Stylesheetid <= mediaTypeSId)
				{
					mediaType = value;
					mediaTypeSId = compiler.Stylesheetid;
				}
			}
			else
			{
				if (!Keywords.Equals(localName, compiler.Atoms.CdataSectionElements))
				{
					return false;
				}
				string[] array = XmlConvert.SplitString(value);
				if (cdataElements == null)
				{
					cdataElements = new Hashtable(array.Length);
				}
				for (int i = 0; i < array.Length; i++)
				{
					XmlQualifiedName xmlQualifiedName = compiler.CreateXmlQName(array[i]);
					cdataElements[xmlQualifiedName] = xmlQualifiedName;
				}
			}
			return true;
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
		}

		private static OutputMethod ParseOutputMethod(string value, Compiler compiler)
		{
			XmlQualifiedName xmlQualifiedName = compiler.CreateXPathQName(value);
			if (xmlQualifiedName.Namespace.Length != 0)
			{
				return OutputMethod.Other;
			}
			switch (xmlQualifiedName.Name)
			{
			case "xml":
				return OutputMethod.Xml;
			case "html":
				return OutputMethod.Html;
			case "text":
				return OutputMethod.Text;
			default:
				if (compiler.ForwardCompatibility)
				{
					return OutputMethod.Unknown;
				}
				throw XsltException.Create("Xslt_InvalidAttrValue", "method", value);
			}
		}
	}
}
