
// C:\WINDOWS\assembly\GAC_MSIL\System.Drawing\2.0.0.0__b03f5f7f11d50a3a\System.Drawing.dll
// System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
// Global type: <Module>
// Architecture: AnyCPU (64-bit preferred)
// Runtime: v2.0.50727
// This assembly is signed with a strong name key.
// Hash algorithm: SHA1
// Public key: 002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.ComponentModel.Design.Serialization;
using System.Diagnostics;
using System.Drawing.Design;
using System.Drawing.Drawing2D;
using System.Drawing.Imaging;
using System.Drawing.Internal;
using System.Drawing.Printing;
using System.Drawing.Text;
using System.Globalization;
using System.Internal;
using System.IO;
using System.Reflection;
using System.Resources;
using System.Runtime.CompilerServices;
using System.Runtime.ConstrainedExecution;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Runtime.Versioning;
using System.Security;
using System.Security.Permissions;
using System.Text;
using System.Threading;
using Microsoft.Win32;

[assembly: CLSCompliant(true)]
[assembly: AllowPartiallyTrustedCallers]
[assembly: ComVisible(false)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: CompilationRelaxations(8)]
[assembly: Dependency("System,", LoadHint.Always)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: ComCompatibleVersion(1, 0, 3300, 0)]
[assembly: AssemblyKeyFile("f:\\dd\\Tools\\devdiv\\FinalPublicKey.snk")]
[assembly: AssemblyDelaySign(true)]
[assembly: NeutralResourcesLanguage("en-US")]
[assembly: SatelliteContractVersion("2.0.0.0")]
[assembly: AssemblyInformationalVersion("2.0.50727.9149")]
[assembly: AssemblyFileVersion("2.0.50727.9149")]
[assembly: AssemblyCopyright("© Microsoft Corporation.  All rights reserved.")]
[assembly: AssemblyProduct("Microsoft® .NET Framework")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyDefaultAlias("System.Drawing.dll")]
[assembly: AssemblyDescription("System.Drawing.dll")]
[assembly: AssemblyTitle("System.Drawing.dll")]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
[assembly: AssemblyVersion("2.0.0.0")]
[module: UnverifiableCode]
internal static class FXAssembly
{
	internal const string Version = "2.0.0.0";
}
internal static class ThisAssembly
{
	internal const string Title = "System.Drawing.dll";

	internal const string Description = "System.Drawing.dll";

	internal const string DefaultAlias = "System.Drawing.dll";

	internal const string Copyright = "© Microsoft Corporation.  All rights reserved.";

	internal const string Version = "2.0.0.0";

	internal const string InformationalVersion = "2.0.50727.9149";

	internal const int DailyBuildNumber = 50727;
}
internal static class AssemblyRef
{
	internal const string EcmaPublicKey = "b77a5c561934e089";

	internal const string EcmaPublicKeyToken = "b77a5c561934e089";

	internal const string EcmaPublicKeyFull = "00000000000000000400000000000000";

	internal const string Mscorlib = "mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemData = "System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemDataOracleClient = "System.Data.OracleClient, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string System = "System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemRuntimeRemoting = "System.Runtime.Remoting, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemWindowsForms = "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemXml = "System.Xml, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string MicrosoftPublicKey = "b03f5f7f11d50a3a";

	internal const string MicrosoftPublicKeyToken = "b03f5f7f11d50a3a";

	internal const string MicrosoftPublicKeyFull = "002400000480000094000000060200000024000052534131000400000100010007D1FA57C4AED9F0A32E84AA0FAEFD0DE9E8FD6AEC8F87FB03766C834C99921EB23BE79AD9D5DCC1DD9AD236132102900B723CF980957FC4E177108FC607774F29E8320E92EA05ECE4E821C0A5EFE8F1645C4C0C93C1AB99285D622CAA652C1DFAD63D745D6F2DE5F17E5EAF0FC4963D261C8A12436518206DC093344D5AD293";

	internal const string SystemConfiguration = "System.Configuration, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemConfigurationInstall = "System.Configuration.Install, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemDeployment = "System.Deployment, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemDesign = "System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemDirectoryServices = "System.DirectoryServices, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemDrawingDesign = "System.Drawing.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemDrawing = "System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemEnterpriseServices = "System.EnterpriseServices, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemManagement = "System.Management, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemMessaging = "System.Messaging, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemRuntimeSerializationFormattersSoap = "System.Runtime.Serialization.Formatters.Soap, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemSecurity = "System.Security, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemServiceProcess = "System.ServiceProcess, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemWeb = "System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemWebMobile = "System.Web.Mobile, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemWebRegularExpressions = "System.Web.RegularExpressions, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemWebServices = "System.Web.Services, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string MicrosoftVisualStudio = "Microsoft.VisualStudio, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string MicrosoftVisualStudioWindowsForms = "Microsoft.VisualStudio.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string VJSharpCodeProvider = "VJSharpCodeProvider, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string ASPBrowserCapsPublicKey = "b7bd7678b977bd8f";

	internal const string ASPBrowserCapsFactory = "ASP.BrowserCapsFactory, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b7bd7678b977bd8f";

	internal const string MicrosoftVSDesigner = "Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string MicrosoftVisualStudioWeb = "Microsoft.VisualStudio.Web, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string MicrosoftVSDesignerMobile = "Microsoft.VSDesigner.Mobile, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string MicrosoftJScript = "Microsoft.JScript, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";
}
namespace System.Drawing
{
	[AttributeUsage(AttributeTargets.All)]
	internal sealed class SRDescriptionAttribute : DescriptionAttribute
	{
		private bool replaced;

		public override string Description
		{
			get
			{
				if (!replaced)
				{
					replaced = true;
					base.DescriptionValue = SR.GetString(base.Description);
				}
				return base.Description;
			}
		}

		public SRDescriptionAttribute(string description)
			: base(description)
		{
		}
	}
	[AttributeUsage(AttributeTargets.All)]
	internal sealed class SRCategoryAttribute : CategoryAttribute
	{
		public SRCategoryAttribute(string category)
			: base(category)
		{
		}

		protected override string GetLocalizedString(string value)
		{
			return SR.GetString(value);
		}
	}
	internal sealed class SR
	{
		internal const string CantTellPrinterName = "CantTellPrinterName";

		internal const string CantChangeImmutableObjects = "CantChangeImmutableObjects";

		internal const string CantMakeIconTransparent = "CantMakeIconTransparent";

		internal const string ColorNotSystemColor = "ColorNotSystemColor";

		internal const string DotNET_ComponentType = "DotNET_ComponentType";

		internal const string GdiplusAborted = "GdiplusAborted";

		internal const string GdiplusAccessDenied = "GdiplusAccessDenied";

		internal const string GdiplusCannotCreateGraphicsFromIndexedPixelFormat = "GdiplusCannotCreateGraphicsFromIndexedPixelFormat";

		internal const string GdiplusCannotSetPixelFromIndexedPixelFormat = "GdiplusCannotSetPixelFromIndexedPixelFormat";

		internal const string GdiplusDestPointsInvalidParallelogram = "GdiplusDestPointsInvalidParallelogram";

		internal const string GdiplusDestPointsInvalidLength = "GdiplusDestPointsInvalidLength";

		internal const string GdiplusFileNotFound = "GdiplusFileNotFound";

		internal const string GdiplusFontFamilyNotFound = "GdiplusFontFamilyNotFound";

		internal const string GdiplusFontStyleNotFound = "GdiplusFontStyleNotFound";

		internal const string GdiplusGenericError = "GdiplusGenericError";

		internal const string GdiplusInsufficientBuffer = "GdiplusInsufficientBuffer";

		internal const string GdiplusInvalidParameter = "GdiplusInvalidParameter";

		internal const string GdiplusInvalidRectangle = "GdiplusInvalidRectangle";

		internal const string GdiplusInvalidSize = "GdiplusInvalidSize";

		internal const string GdiplusOutOfMemory = "GdiplusOutOfMemory";

		internal const string GdiplusNotImplemented = "GdiplusNotImplemented";

		internal const string GdiplusNotInitialized = "GdiplusNotInitialized";

		internal const string GdiplusNotTrueTypeFont = "GdiplusNotTrueTypeFont";

		internal const string GdiplusNotTrueTypeFont_NoName = "GdiplusNotTrueTypeFont_NoName";

		internal const string GdiplusObjectBusy = "GdiplusObjectBusy";

		internal const string GdiplusOverflow = "GdiplusOverflow";

		internal const string GdiplusPropertyNotFoundError = "GdiplusPropertyNotFoundError";

		internal const string GdiplusPropertyNotSupportedError = "GdiplusPropertyNotSupportedError";

		internal const string GdiplusUnknown = "GdiplusUnknown";

		internal const string GdiplusUnknownImageFormat = "GdiplusUnknownImageFormat";

		internal const string GdiplusUnsupportedGdiplusVersion = "GdiplusUnsupportedGdiplusVersion";

		internal const string GdiplusWrongState = "GdiplusWrongState";

		internal const string GlobalAssemblyCache = "GlobalAssemblyCache";

		internal const string GraphicsBufferCurrentlyBusy = "GraphicsBufferCurrentlyBusy";

		internal const string GraphicsBufferQueryFail = "GraphicsBufferQueryFail";

		internal const string ToolboxItemLocked = "ToolboxItemLocked";

		internal const string ToolboxItemInvalidPropertyType = "ToolboxItemInvalidPropertyType";

		internal const string ToolboxItemValueNotSerializable = "ToolboxItemValueNotSerializable";

		internal const string ToolboxItemInvalidKey = "ToolboxItemInvalidKey";

		internal const string IllegalState = "IllegalState";

		internal const string InterpolationColorsColorBlendNotSet = "InterpolationColorsColorBlendNotSet";

		internal const string InterpolationColorsCommon = "InterpolationColorsCommon";

		internal const string InterpolationColorsInvalidColorBlendObject = "InterpolationColorsInvalidColorBlendObject";

		internal const string InterpolationColorsInvalidStartPosition = "InterpolationColorsInvalidStartPosition";

		internal const string InterpolationColorsInvalidEndPosition = "InterpolationColorsInvalidEndPosition";

		internal const string InterpolationColorsLength = "InterpolationColorsLength";

		internal const string InterpolationColorsLengthsDiffer = "InterpolationColorsLengthsDiffer";

		internal const string InvalidArgument = "InvalidArgument";

		internal const string InvalidBoundArgument = "InvalidBoundArgument";

		internal const string InvalidClassName = "InvalidClassName";

		internal const string InvalidColor = "InvalidColor";

		internal const string InvalidDashPattern = "InvalidDashPattern";

		internal const string InvalidEx2BoundArgument = "InvalidEx2BoundArgument";

		internal const string InvalidFrame = "InvalidFrame";

		internal const string InvalidGDIHandle = "InvalidGDIHandle";

		internal const string InvalidImage = "InvalidImage";

		internal const string InvalidLowBoundArgumentEx = "InvalidLowBoundArgumentEx";

		internal const string InvalidPermissionLevel = "InvalidPermissionLevel";

		internal const string InvalidPermissionState = "InvalidPermissionState";

		internal const string InvalidPictureType = "InvalidPictureType";

		internal const string InvalidPrinterException_InvalidPrinter = "InvalidPrinterException_InvalidPrinter";

		internal const string InvalidPrinterException_NoDefaultPrinter = "InvalidPrinterException_NoDefaultPrinter";

		internal const string InvalidPrinterHandle = "InvalidPrinterHandle";

		internal const string ValidRangeX = "ValidRangeX";

		internal const string ValidRangeY = "ValidRangeY";

		internal const string NativeHandle0 = "NativeHandle0";

		internal const string NoDefaultPrinter = "NoDefaultPrinter";

		internal const string NotImplemented = "NotImplemented";

		internal const string PDOCbeginPrintDescr = "PDOCbeginPrintDescr";

		internal const string PDOCdocumentNameDescr = "PDOCdocumentNameDescr";

		internal const string PDOCdocumentPageSettingsDescr = "PDOCdocumentPageSettingsDescr";

		internal const string PDOCendPrintDescr = "PDOCendPrintDescr";

		internal const string PDOCoriginAtMarginsDescr = "PDOCoriginAtMarginsDescr";

		internal const string PDOCprintControllerDescr = "PDOCprintControllerDescr";

		internal const string PDOCprintPageDescr = "PDOCprintPageDescr";

		internal const string PDOCprinterSettingsDescr = "PDOCprinterSettingsDescr";

		internal const string PDOCqueryPageSettingsDescr = "PDOCqueryPageSettingsDescr";

		internal const string PrintDocumentDesc = "PrintDocumentDesc";

		internal const string PrintingPermissionBadXml = "PrintingPermissionBadXml";

		internal const string PrintingPermissionAttributeInvalidPermissionLevel = "PrintingPermissionAttributeInvalidPermissionLevel";

		internal const string PropertyValueInvalidEntry = "PropertyValueInvalidEntry";

		internal const string PSizeNotCustom = "PSizeNotCustom";

		internal const string ResourceNotFound = "ResourceNotFound";

		internal const string TargetNotPrintingPermission = "TargetNotPrintingPermission";

		internal const string TextParseFailedFormat = "TextParseFailedFormat";

		internal const string TriStateCompareError = "TriStateCompareError";

		internal const string toStringIcon = "toStringIcon";

		internal const string toStringNone = "toStringNone";

		internal const string DCTypeInvalid = "DCTypeInvalid";

		private static SR loader;

		private ResourceManager resources;

		private static object s_InternalSyncObject;

		private static object InternalSyncObject
		{
			get
			{
				if (s_InternalSyncObject == null)
				{
					object value = new object();
					Interlocked.CompareExchange(ref s_InternalSyncObject, value, null);
				}
				return s_InternalSyncObject;
			}
		}

		private static CultureInfo Culture => null;

		public static ResourceManager Resources => GetLoader().resources;

		internal SR()
		{
			resources = new ResourceManager("System.Drawing.Res", GetType().Assembly);
		}

		private static SR GetLoader()
		{
			if (loader == null)
			{
				lock (InternalSyncObject)
				{
					if (loader == null)
					{
						loader = new SR();
					}
				}
			}
			return loader;
		}

		public static string GetString(string name, params object[] args)
		{
			SR sR = GetLoader();
			if (sR == null)
			{
				return null;
			}
			string @string = sR.resources.GetString(name, Culture);
			if (args != null && args.Length > 0)
			{
				for (int i = 0; i < args.Length; i++)
				{
					if (args[i] is string text && text.Length > 1024)
					{
						args[i] = text.Substring(0, 1021) + "...";
					}
				}
				return string.Format(CultureInfo.CurrentCulture, @string, args);
			}
			return @string;
		}

		public static string GetString(string name)
		{
			return GetLoader()?.resources.GetString(name, Culture);
		}

		public static object GetObject(string name)
		{
			return GetLoader()?.resources.GetObject(name, Culture);
		}
	}
}
namespace System
{
	internal static class ExternDll
	{
		public const string Activeds = "activeds.dll";

		public const string Advapi32 = "advapi32.dll";

		public const string Comctl32 = "comctl32.dll";

		public const string Comdlg32 = "comdlg32.dll";

		public const string Gdi32 = "gdi32.dll";

		public const string Gdiplus = "gdiplus.dll";

		public const string Hhctrl = "hhctrl.ocx";

		public const string Imm32 = "imm32.dll";

		public const string Kernel32 = "kernel32.dll";

		public const string Loadperf = "Loadperf.dll";

		public const string Mscoree = "mscoree.dll";

		public const string Mscorwks = "mscorwks.dll";

		public const string Msi = "msi.dll";

		public const string Mqrt = "mqrt.dll";

		public const string Ntdll = "ntdll.dll";

		public const string Ole32 = "ole32.dll";

		public const string Oleacc = "oleacc.dll";

		public const string Oleaut32 = "oleaut32.dll";

		public const string Olepro32 = "olepro32.dll";

		public const string PerfCounter = "perfcounter.dll";

		public const string Powrprof = "Powrprof.dll";

		public const string Psapi = "psapi.dll";

		public const string Shell32 = "shell32.dll";

		public const string Shfolder = "shfolder.dll";

		public const string User32 = "user32.dll";

		public const string Uxtheme = "uxtheme.dll";

		public const string WinMM = "winmm.dll";

		public const string Winspool = "winspool.drv";

		public const string Wtsapi32 = "wtsapi32.dll";

		public const string Version = "version.dll";

		public const string Vsassert = "vsassert.dll";

		public const string Shlwapi = "shlwapi.dll";

		public const string Crypt32 = "crypt32.dll";

		internal const string Odbc32 = "odbc32.dll";

		internal const string SNI = "System.Data.dll";

		internal const string OciDll = "oci.dll";

		internal const string OraMtsDll = "oramts.dll";
	}
}
namespace System.Internal
{
	internal sealed class HandleCollector
	{
		private class HandleType
		{
			internal readonly string name;

			private int initialThreshHold;

			private int threshHold;

			private int handleCount;

			private readonly int deltaPercent;

			internal HandleType(string name, int expense, int initialThreshHold)
			{
				this.name = name;
				this.initialThreshHold = initialThreshHold;
				threshHold = initialThreshHold;
				deltaPercent = 100 - expense;
			}

			internal void Add(IntPtr handle)
			{
				if (handle == IntPtr.Zero)
				{
					return;
				}
				bool flag = false;
				int currentHandleCount = 0;
				lock (this)
				{
					handleCount++;
					flag = NeedCollection();
					currentHandleCount = handleCount;
				}
				lock (internalSyncObject)
				{
					if (HandleCollector.HandleAdded != null)
					{
						HandleCollector.HandleAdded(name, handle, currentHandleCount);
					}
				}
				if (flag && flag)
				{
					GC.Collect();
					int millisecondsTimeout = (100 - deltaPercent) / 4;
					Thread.Sleep(millisecondsTimeout);
				}
			}

			internal int GetHandleCount()
			{
				lock (this)
				{
					return handleCount;
				}
			}

			internal bool NeedCollection()
			{
				if (suspendCount > 0)
				{
					return false;
				}
				if (handleCount > threshHold)
				{
					threshHold = handleCount + handleCount * deltaPercent / 100;
					return true;
				}
				int num = 100 * threshHold / (100 + deltaPercent);
				if (num >= initialThreshHold && handleCount < (int)((float)num * 0.9f))
				{
					threshHold = num;
				}
				return false;
			}

			internal IntPtr Remove(IntPtr handle)
			{
				if (handle == IntPtr.Zero)
				{
					return handle;
				}
				int currentHandleCount = 0;
				lock (this)
				{
					handleCount--;
					if (handleCount < 0)
					{
						handleCount = 0;
					}
					currentHandleCount = handleCount;
				}
				lock (internalSyncObject)
				{
					if (HandleCollector.HandleRemoved != null)
					{
						HandleCollector.HandleRemoved(name, handle, currentHandleCount);
						return handle;
					}
					return handle;
				}
			}
		}

		private static HandleType[] handleTypes;

		private static int handleTypeCount;

		private static int suspendCount;

		private static object internalSyncObject = new object();

		internal static event HandleChangeEventHandler HandleAdded;

		internal static event HandleChangeEventHandler HandleRemoved;

		internal static IntPtr Add(IntPtr handle, int type)
		{
			handleTypes[type - 1].Add(handle);
			return handle;
		}

		internal static void SuspendCollect()
		{
			lock (internalSyncObject)
			{
				suspendCount++;
			}
		}

		internal static void ResumeCollect()
		{
			bool flag = false;
			lock (internalSyncObject)
			{
				if (suspendCount > 0)
				{
					suspendCount--;
				}
				if (suspendCount == 0)
				{
					for (int i = 0; i < handleTypeCount; i++)
					{
						lock (handleTypes[i])
						{
							if (handleTypes[i].NeedCollection())
							{
								flag = true;
							}
						}
					}
				}
			}
			if (flag)
			{
				GC.Collect();
			}
		}

		internal static int RegisterType(string typeName, int expense, int initialThreshold)
		{
			lock (internalSyncObject)
			{
				if (handleTypeCount == 0 || handleTypeCount == handleTypes.Length)
				{
					HandleType[] destinationArray = new HandleType[handleTypeCount + 10];
					if (handleTypes != null)
					{
						Array.Copy(handleTypes, 0, destinationArray, 0, handleTypeCount);
					}
					handleTypes = destinationArray;
				}
				handleTypes[handleTypeCount++] = new HandleType(typeName, expense, initialThreshold);
				return handleTypeCount;
			}
		}

		internal static IntPtr Remove(IntPtr handle, int type)
		{
			return handleTypes[type - 1].Remove(handle);
		}
	}
	internal delegate void HandleChangeEventHandler(string handleType, IntPtr handleValue, int currentHandleCount);
	internal class DebugHandleTracker
	{
		private class HandleType
		{
			private class HandleEntry
			{
				private class StackParser
				{
					internal string releventStack;

					internal int startIndex;

					internal int endIndex;

					internal int length;

					public StackParser(string callStack)
					{
						releventStack = callStack;
						length = releventStack.Length;
					}

					private static bool ContainsString(string str, string token)
					{
						int num = str.Length;
						int num2 = token.Length;
						for (int i = 0; i < num; i++)
						{
							int j;
							for (j = 0; j < num2 && str[i + j] == token[j]; j++)
							{
							}
							if (j == num2)
							{
								return true;
							}
						}
						return false;
					}

					public void DiscardNext()
					{
						GetLine();
					}

					public void DiscardTo(string discardText)
					{
						while (startIndex < length)
						{
							string line = GetLine();
							if (line == null || ContainsString(line, discardText))
							{
								break;
							}
						}
					}

					private string GetLine()
					{
						endIndex = releventStack.IndexOf('\r', startIndex);
						if (endIndex < 0)
						{
							endIndex = length - 1;
						}
						string text = releventStack.Substring(startIndex, endIndex - startIndex);
						char c;
						while (endIndex < length && ((c = releventStack[endIndex]) == '\r' || c == '\n'))
						{
							endIndex++;
						}
						if (startIndex == endIndex)
						{
							return null;
						}
						startIndex = endIndex;
						return text.Replace('\t', ' ');
					}

					public override string ToString()
					{
						return releventStack.Substring(startIndex);
					}

					public void Truncate(int lines)
					{
						string text = "";
						while (lines-- > 0 && startIndex < length)
						{
							text = ((text != null) ? (text + ": " + GetLine()) : GetLine());
							text += Environment.NewLine;
						}
						releventStack = text;
						startIndex = 0;
						endIndex = 0;
						length = releventStack.Length;
					}
				}

				public readonly IntPtr handle;

				public HandleEntry next;

				public readonly string callStack;

				public bool ignorableAsLeak;

				public HandleEntry(HandleEntry next, IntPtr handle)
				{
					this.handle = handle;
					this.next = next;
					if (System.ComponentModel.CompModSwitches.HandleLeak.Level > TraceLevel.Off)
					{
						callStack = Environment.StackTrace;
					}
					else
					{
						callStack = null;
					}
				}

				public string ToString(HandleType type)
				{
					StackParser stackParser = new StackParser(callStack);
					stackParser.DiscardTo("HandleCollector.Add");
					stackParser.DiscardNext();
					stackParser.Truncate(40);
					string text = "";
					return Convert.ToString((int)handle, 16) + text + ": " + stackParser.ToString();
				}
			}

			private const int BUCKETS = 10;

			public readonly string name;

			private int handleCount;

			private HandleEntry[] buckets;

			public HandleType(string name)
			{
				this.name = name;
				buckets = new HandleEntry[10];
			}

			public void Add(IntPtr handle)
			{
				lock (this)
				{
					int num = ComputeHash(handle);
					if (System.ComponentModel.CompModSwitches.HandleLeak.Level >= TraceLevel.Info)
					{
						_ = System.ComponentModel.CompModSwitches.HandleLeak.Level;
						_ = 4;
					}
					for (HandleEntry handleEntry = buckets[num]; handleEntry != null; handleEntry = handleEntry.next)
					{
					}
					buckets[num] = new HandleEntry(buckets[num], handle);
					handleCount++;
				}
			}

			public void CheckLeaks()
			{
				lock (this)
				{
					bool flag = false;
					if (handleCount <= 0)
					{
						return;
					}
					for (int i = 0; i < 10; i++)
					{
						for (HandleEntry handleEntry = buckets[i]; handleEntry != null; handleEntry = handleEntry.next)
						{
							if (!handleEntry.ignorableAsLeak && !flag)
							{
								flag = true;
							}
						}
					}
				}
			}

			public void IgnoreCurrentHandlesAsLeaks()
			{
				lock (this)
				{
					if (handleCount <= 0)
					{
						return;
					}
					for (int i = 0; i < 10; i++)
					{
						for (HandleEntry handleEntry = buckets[i]; handleEntry != null; handleEntry = handleEntry.next)
						{
							handleEntry.ignorableAsLeak = true;
						}
					}
				}
			}

			private int ComputeHash(IntPtr handle)
			{
				return ((int)handle & 0xFFFF) % 10;
			}

			public bool Remove(IntPtr handle)
			{
				lock (this)
				{
					int num = ComputeHash(handle);
					if (System.ComponentModel.CompModSwitches.HandleLeak.Level >= TraceLevel.Info)
					{
						_ = System.ComponentModel.CompModSwitches.HandleLeak.Level;
						_ = 4;
					}
					HandleEntry handleEntry = buckets[num];
					HandleEntry handleEntry2 = null;
					while (handleEntry != null && handleEntry.handle != handle)
					{
						handleEntry2 = handleEntry;
						handleEntry = handleEntry.next;
					}
					if (handleEntry != null)
					{
						if (handleEntry2 == null)
						{
							buckets[num] = handleEntry.next;
						}
						else
						{
							handleEntry2.next = handleEntry.next;
						}
						handleCount--;
						return true;
					}
					return false;
				}
			}
		}

		private static Hashtable handleTypes;

		private static DebugHandleTracker tracker;

		private static object internalSyncObject;

		static DebugHandleTracker()
		{
			handleTypes = new Hashtable();
			internalSyncObject = new object();
			tracker = new DebugHandleTracker();
			if (System.ComponentModel.CompModSwitches.HandleLeak.Level > TraceLevel.Off || System.ComponentModel.CompModSwitches.TraceCollect.Enabled)
			{
				HandleCollector.HandleAdded += tracker.OnHandleAdd;
				HandleCollector.HandleRemoved += tracker.OnHandleRemove;
			}
		}

		private DebugHandleTracker()
		{
		}

		public static void IgnoreCurrentHandlesAsLeaks()
		{
			lock (internalSyncObject)
			{
				if (System.ComponentModel.CompModSwitches.HandleLeak.Level < TraceLevel.Warning)
				{
					return;
				}
				HandleType[] array = new HandleType[handleTypes.Values.Count];
				handleTypes.Values.CopyTo(array, 0);
				for (int i = 0; i < array.Length; i++)
				{
					if (array[i] != null)
					{
						array[i].IgnoreCurrentHandlesAsLeaks();
					}
				}
			}
		}

		public static void CheckLeaks()
		{
			lock (internalSyncObject)
			{
				if (System.ComponentModel.CompModSwitches.HandleLeak.Level < TraceLevel.Warning)
				{
					return;
				}
				GC.Collect();
				GC.WaitForPendingFinalizers();
				HandleType[] array = new HandleType[handleTypes.Values.Count];
				handleTypes.Values.CopyTo(array, 0);
				for (int i = 0; i < array.Length; i++)
				{
					if (array[i] != null)
					{
						array[i].CheckLeaks();
					}
				}
			}
		}

		public static void Initialize()
		{
		}

		private void OnHandleAdd(string handleName, IntPtr handle, int handleCount)
		{
			HandleType handleType = (HandleType)handleTypes[handleName];
			if (handleType == null)
			{
				handleType = new HandleType(handleName);
				handleTypes[handleName] = handleType;
			}
			handleType.Add(handle);
		}

		private void OnHandleRemove(string handleName, IntPtr handle, int HandleCount)
		{
			HandleType handleType = (HandleType)handleTypes[handleName];
			bool flag = false;
			if (handleType != null)
			{
				flag = handleType.Remove(handle);
			}
			if (!flag)
			{
				_ = System.ComponentModel.CompModSwitches.HandleLeak.Level;
				_ = 1;
			}
		}
	}
}
namespace System.ComponentModel
{
	internal static class CompModSwitches
	{
		private static TraceSwitch handleLeak;

		private static BooleanSwitch traceCollect;

		public static TraceSwitch HandleLeak
		{
			get
			{
				if (handleLeak == null)
				{
					handleLeak = new TraceSwitch("HANDLELEAK", "HandleCollector: Track Win32 Handle Leaks");
				}
				return handleLeak;
			}
		}

		public static BooleanSwitch TraceCollect
		{
			get
			{
				if (traceCollect == null)
				{
					traceCollect = new BooleanSwitch("TRACECOLLECT", "HandleCollector: Trace HandleCollector operations");
				}
				return traceCollect;
			}
		}
	}
	internal static class CoreSwitches
	{
		private static BooleanSwitch perfTrack;

		public static BooleanSwitch PerfTrack
		{
			get
			{
				if (perfTrack == null)
				{
					perfTrack = new BooleanSwitch("PERFTRACK", "Debug performance critical sections.");
				}
				return perfTrack;
			}
		}
	}
}
namespace System
{
	[Serializable]
	internal class InvariantComparer : IComparer
	{
		private CompareInfo m_compareInfo;

		internal static readonly InvariantComparer Default = new InvariantComparer();

		internal InvariantComparer()
		{
			m_compareInfo = CultureInfo.InvariantCulture.CompareInfo;
		}

		public int Compare(object a, object b)
		{
			string text = a as string;
			string text2 = b as string;
			if (text != null && text2 != null)
			{
				return m_compareInfo.Compare(text, text2);
			}
			return Comparer.Default.Compare(a, b);
		}
	}
}
namespace System.Drawing
{
	internal static class ClientUtils
	{
		internal class WeakRefCollection : IList, ICollection, IEnumerable
		{
			internal class WeakRefObject
			{
				private int hash;

				private WeakReference weakHolder;

				internal bool IsAlive => weakHolder.IsAlive;

				internal object Target => weakHolder.Target;

				internal WeakRefObject(object obj)
				{
					weakHolder = new WeakReference(obj);
					hash = obj.GetHashCode();
				}

				public override int GetHashCode()
				{
					return hash;
				}

				public override bool Equals(object obj)
				{
					WeakRefObject weakRefObject = obj as WeakRefObject;
					if (weakRefObject == this)
					{
						return true;
					}
					if (weakRefObject == null)
					{
						return false;
					}
					if (weakRefObject.Target != Target && (Target == null || !Target.Equals(weakRefObject.Target)))
					{
						return false;
					}
					return true;
				}
			}

			private int refCheckThreshold = int.MaxValue;

			private ArrayList _innerList;

			internal ArrayList InnerList => _innerList;

			public int RefCheckThreshold
			{
				get
				{
					return refCheckThreshold;
				}
				set
				{
					refCheckThreshold = value;
				}
			}

			public object this[int index]
			{
				get
				{
					if (InnerList[index] is WeakRefObject weakRefObject && weakRefObject.IsAlive)
					{
						return weakRefObject.Target;
					}
					return null;
				}
				set
				{
					InnerList[index] = CreateWeakRefObject(value);
				}
			}

			public bool IsFixedSize => InnerList.IsFixedSize;

			public int Count => InnerList.Count;

			object ICollection.SyncRoot => InnerList.SyncRoot;

			public bool IsReadOnly => InnerList.IsReadOnly;

			bool ICollection.IsSynchronized => InnerList.IsSynchronized;

			internal WeakRefCollection()
			{
				_innerList = new ArrayList(4);
			}

			internal WeakRefCollection(int size)
			{
				_innerList = new ArrayList(size);
			}

			public void ScavengeReferences()
			{
				int num = 0;
				int count = Count;
				for (int i = 0; i < count; i++)
				{
					object obj = this[num];
					if (obj == null)
					{
						InnerList.RemoveAt(num);
					}
					else
					{
						num++;
					}
				}
			}

			public override bool Equals(object obj)
			{
				WeakRefCollection weakRefCollection = obj as WeakRefCollection;
				if (weakRefCollection == this)
				{
					return true;
				}
				if (weakRefCollection == null || Count != weakRefCollection.Count)
				{
					return false;
				}
				for (int i = 0; i < Count; i++)
				{
					if (InnerList[i] != weakRefCollection.InnerList[i] && (InnerList[i] == null || !InnerList[i].Equals(weakRefCollection.InnerList[i])))
					{
						return false;
					}
				}
				return true;
			}

			public override int GetHashCode()
			{
				return base.GetHashCode();
			}

			private WeakRefObject CreateWeakRefObject(object value)
			{
				if (value == null)
				{
					return null;
				}
				return new WeakRefObject(value);
			}

			private static void Copy(WeakRefCollection sourceList, int sourceIndex, WeakRefCollection destinationList, int destinationIndex, int length)
			{
				if (sourceIndex < destinationIndex)
				{
					sourceIndex += length;
					destinationIndex += length;
					while (length > 0)
					{
						destinationList.InnerList[--destinationIndex] = sourceList.InnerList[--sourceIndex];
						length--;
					}
				}
				else
				{
					while (length > 0)
					{
						destinationList.InnerList[destinationIndex++] = sourceList.InnerList[sourceIndex++];
						length--;
					}
				}
			}

			public void RemoveByHashCode(object value)
			{
				if (value == null)
				{
					return;
				}
				int hashCode = value.GetHashCode();
				for (int i = 0; i < InnerList.Count; i++)
				{
					if (InnerList[i] != null && InnerList[i].GetHashCode() == hashCode)
					{
						RemoveAt(i);
						break;
					}
				}
			}

			public void Clear()
			{
				InnerList.Clear();
			}

			public bool Contains(object value)
			{
				return InnerList.Contains(CreateWeakRefObject(value));
			}

			public void RemoveAt(int index)
			{
				InnerList.RemoveAt(index);
			}

			public void Remove(object value)
			{
				InnerList.Remove(CreateWeakRefObject(value));
			}

			public int IndexOf(object value)
			{
				return InnerList.IndexOf(CreateWeakRefObject(value));
			}

			public void Insert(int index, object value)
			{
				InnerList.Insert(index, CreateWeakRefObject(value));
			}

			public int Add(object value)
			{
				if (Count > RefCheckThreshold)
				{
					ScavengeReferences();
				}
				return InnerList.Add(CreateWeakRefObject(value));
			}

			public void CopyTo(Array array, int index)
			{
				InnerList.CopyTo(array, index);
			}

			public IEnumerator GetEnumerator()
			{
				return InnerList.GetEnumerator();
			}
		}

		public static bool IsCriticalException(Exception ex)
		{
			if (!(ex is NullReferenceException) && !(ex is StackOverflowException) && !(ex is OutOfMemoryException) && !(ex is ThreadAbortException) && !(ex is ExecutionEngineException) && !(ex is IndexOutOfRangeException))
			{
				return ex is AccessViolationException;
			}
			return true;
		}

		public static bool IsSecurityOrCriticalException(Exception ex)
		{
			if (!(ex is SecurityException))
			{
				return IsCriticalException(ex);
			}
			return true;
		}

		public static int GetBitCount(uint x)
		{
			int num = 0;
			while (x != 0)
			{
				x &= x - 1;
				num++;
			}
			return num;
		}

		public static bool IsEnumValid(Enum enumValue, int value, int minValue, int maxValue)
		{
			return value >= minValue && value <= maxValue;
		}

		public static bool IsEnumValid(Enum enumValue, int value, int minValue, int maxValue, int maxNumberOfBitsOn)
		{
			return value >= minValue && value <= maxValue && GetBitCount((uint)value) <= maxNumberOfBitsOn;
		}

		public static bool IsEnumValid_Masked(Enum enumValue, int value, uint mask)
		{
			return (value & mask) == value;
		}

		public static bool IsEnumValid_NotSequential(Enum enumValue, int value, params int[] enumValues)
		{
			for (int i = 0; i < enumValues.Length; i++)
			{
				if (enumValues[i] == value)
				{
					return true;
				}
			}
			return false;
		}
	}
	internal static class SecurityUtils
	{
		private static bool HasReflectionPermission
		{
			get
			{
				try
				{
					new ReflectionPermission(PermissionState.Unrestricted).Demand();
					return true;
				}
				catch (SecurityException)
				{
				}
				return false;
			}
		}

		internal static object SecureCreateInstance(Type type)
		{
			return SecureCreateInstance(type, null);
		}

		internal static object SecureCreateInstance(Type type, object[] args)
		{
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			if (type.Assembly == typeof(SecurityUtils).Assembly && !type.IsPublic && !type.IsNestedPublic)
			{
				new ReflectionPermission(PermissionState.Unrestricted).Demand();
			}
			return Activator.CreateInstance(type, args);
		}

		internal static object SecureCreateInstance(Type type, object[] args, bool allowNonPublic)
		{
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.CreateInstance;
			if (type.Assembly == typeof(SecurityUtils).Assembly)
			{
				if (!type.IsPublic && !type.IsNestedPublic)
				{
					new ReflectionPermission(PermissionState.Unrestricted).Demand();
				}
				else if (allowNonPublic && !HasReflectionPermission)
				{
					allowNonPublic = false;
				}
			}
			if (allowNonPublic)
			{
				bindingFlags |= BindingFlags.NonPublic;
			}
			return Activator.CreateInstance(type, bindingFlags, null, args, null);
		}

		internal static object SecureConstructorInvoke(Type type, Type[] argTypes, object[] args, bool allowNonPublic)
		{
			return SecureConstructorInvoke(type, argTypes, args, allowNonPublic, BindingFlags.Default);
		}

		internal static object SecureConstructorInvoke(Type type, Type[] argTypes, object[] args, bool allowNonPublic, BindingFlags extraFlags)
		{
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public | extraFlags;
			if (type.Assembly == typeof(SecurityUtils).Assembly)
			{
				if (!type.IsPublic && !type.IsNestedPublic)
				{
					new ReflectionPermission(PermissionState.Unrestricted).Demand();
				}
				else if (allowNonPublic && !HasReflectionPermission)
				{
					allowNonPublic = false;
				}
			}
			if (allowNonPublic)
			{
				bindingFlags |= BindingFlags.NonPublic;
			}
			return type.GetConstructor(bindingFlags, null, argTypes, null)?.Invoke(args);
		}
	}
}
namespace System.Drawing.Internal
{
	[UIPermission(SecurityAction.Assert, Unrestricted = true)]
	[SecurityPermission(SecurityAction.Assert, Flags = SecurityPermissionFlag.UnmanagedCode)]
	[FileIOPermission(SecurityAction.Assert, Unrestricted = true)]
	[EnvironmentPermission(SecurityAction.Assert, Unrestricted = true)]
	[ReflectionPermission(SecurityAction.Assert, TypeInformation = true, MemberAccess = true)]
	internal sealed class DbgUtil
	{
		public const int FORMAT_MESSAGE_ALLOCATE_BUFFER = 256;

		public const int FORMAT_MESSAGE_IGNORE_INSERTS = 512;

		public const int FORMAT_MESSAGE_FROM_SYSTEM = 4096;

		public const int FORMAT_MESSAGE_DEFAULT = 4608;

		public static int gdipInitMaxFrameCount = 8;

		public static int gdiUseMaxFrameCount = 8;

		public static int finalizeMaxFrameCount = 5;

		public static string StackTrace => Environment.StackTrace;

		[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern int GetUserDefaultLCID();

		[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern int FormatMessage(int dwFlags, HandleRef lpSource, int dwMessageId, int dwLanguageId, StringBuilder lpBuffer, int nSize, HandleRef arguments);

		[Conditional("DEBUG")]
		public static void AssertFinalization(object obj, bool disposing)
		{
		}

		[Conditional("DEBUG")]
		public static void AssertWin32(bool expression, string message)
		{
		}

		[Conditional("DEBUG")]
		public static void AssertWin32(bool expression, string format, object arg1)
		{
		}

		[Conditional("DEBUG")]
		public static void AssertWin32(bool expression, string format, object arg1, object arg2)
		{
		}

		[Conditional("DEBUG")]
		public static void AssertWin32(bool expression, string format, object arg1, object arg2, object arg3)
		{
		}

		[Conditional("DEBUG")]
		public static void AssertWin32(bool expression, string format, object arg1, object arg2, object arg3, object arg4)
		{
		}

		[Conditional("DEBUG")]
		public static void AssertWin32(bool expression, string format, object arg1, object arg2, object arg3, object arg4, object arg5)
		{
		}

		[Conditional("DEBUG")]
		private static void AssertWin32Impl(bool expression, string format, object[] args)
		{
		}

		public static string GetLastErrorStr()
		{
			int num = 255;
			StringBuilder stringBuilder = new StringBuilder(num);
			string empty = string.Empty;
			int num2 = 0;
			try
			{
				num2 = Marshal.GetLastWin32Error();
				empty = ((FormatMessage(4608, new HandleRef(null, IntPtr.Zero), num2, GetUserDefaultLCID(), stringBuilder, num, new HandleRef(null, IntPtr.Zero)) != 0) ? stringBuilder.ToString() : "<error returned>");
			}
			catch (Exception ex)
			{
				if (IsCriticalException(ex))
				{
					throw;
				}
				empty = ex.ToString();
			}
			return string.Format(CultureInfo.CurrentCulture, "0x{0:x8} - {1}", num2, empty);
		}

		private static bool IsCriticalException(Exception ex)
		{
			if (!(ex is StackOverflowException) && !(ex is OutOfMemoryException))
			{
				return ex is ThreadAbortException;
			}
			return true;
		}

		public static string StackFramesToStr(int maxFrameCount)
		{
			string text = string.Empty;
			try
			{
				StackTrace stackTrace = new StackTrace(fNeedFileInfo: true);
				int i;
				for (i = 0; i < stackTrace.FrameCount; i++)
				{
					StackFrame frame = stackTrace.GetFrame(i);
					if (frame == null || frame.GetMethod().DeclaringType != typeof(DbgUtil))
					{
						break;
					}
				}
				maxFrameCount += i;
				if (maxFrameCount > stackTrace.FrameCount)
				{
					maxFrameCount = stackTrace.FrameCount;
				}
				for (int j = i; j < maxFrameCount; j++)
				{
					StackFrame frame2 = stackTrace.GetFrame(j);
					if (frame2 == null)
					{
						continue;
					}
					MethodBase method = frame2.GetMethod();
					if (method != null)
					{
						string text2 = string.Empty;
						string text3 = frame2.GetFileName();
						int num = text3?.LastIndexOf('\\') ?? (-1);
						if (num != -1)
						{
							text3 = text3.Substring(num + 1, text3.Length - num - 1);
						}
						ParameterInfo[] parameters = method.GetParameters();
						foreach (ParameterInfo parameterInfo in parameters)
						{
							text2 = text2 + parameterInfo.ParameterType.Name + ", ";
						}
						if (text2.Length > 0)
						{
							text2 = text2.Substring(0, text2.Length - 2);
						}
						text += string.Format(CultureInfo.CurrentCulture, "at {0}:{1} {2}.{3}({4})\r\n", text3, frame2.GetFileLineNumber(), method.DeclaringType, method.Name, text2);
					}
				}
			}
			catch (Exception ex)
			{
				if (IsCriticalException(ex))
				{
					throw;
				}
				text += ex.ToString();
			}
			return text.ToString();
		}

		public static string StackFramesToStr()
		{
			return StackFramesToStr(gdipInitMaxFrameCount);
		}

		public static string StackTraceToStr(string message, int frameCount)
		{
			return string.Format(CultureInfo.CurrentCulture, "{0}\r\nTop Stack Trace:\r\n{1}", message, StackFramesToStr(frameCount));
		}

		public static string StackTraceToStr(string message)
		{
			return StackTraceToStr(message, gdipInitMaxFrameCount);
		}
	}
	[Flags]
	internal enum ApplyGraphicsProperties
	{
		None = 0,
		Clipping = 1,
		TranslateTransform = 2,
		All = 3
	}
}
namespace System.Drawing
{
	public interface IDeviceContext : IDisposable
	{
		[SecurityPermission(SecurityAction.InheritanceDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
		IntPtr GetHdc();

		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
		[SecurityPermission(SecurityAction.InheritanceDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
		void ReleaseHdc();
	}
}
namespace System.Drawing.Internal
{
	internal sealed class DeviceContext : MarshalByRefObject, IDeviceContext, IDisposable
	{
		internal class GraphicsState
		{
			internal IntPtr hBrush;

			internal IntPtr hFont;

			internal IntPtr hPen;

			internal IntPtr hBitmap;
		}

		private IntPtr hDC;

		private DeviceContextType dcType;

		private bool disposed;

		private IntPtr hWnd = (IntPtr)(-1);

		private IntPtr hInitialPen;

		private IntPtr hInitialBrush;

		private IntPtr hInitialBmp;

		private IntPtr hInitialFont;

		private IntPtr hCurrentPen;

		private IntPtr hCurrentBrush;

		private IntPtr hCurrentBmp;

		private IntPtr hCurrentFont;

		private Stack contextStack;

		public DeviceContextType DeviceContextType => dcType;

		public IntPtr Hdc
		{
			get
			{
				if (hDC == IntPtr.Zero && dcType == DeviceContextType.Display)
				{
					hDC = ((IDeviceContext)this).GetHdc();
					CacheInitialState();
				}
				return hDC;
			}
		}

		public DeviceContextGraphicsMode GraphicsMode => (DeviceContextGraphicsMode)IntUnsafeNativeMethods.GetGraphicsMode(new HandleRef(this, Hdc));

		public event EventHandler Disposing;

		private void CacheInitialState()
		{
			hCurrentPen = (hInitialPen = IntUnsafeNativeMethods.GetCurrentObject(new HandleRef(this, hDC), 1));
			hCurrentBrush = (hInitialBrush = IntUnsafeNativeMethods.GetCurrentObject(new HandleRef(this, hDC), 2));
			hCurrentBmp = (hInitialBmp = IntUnsafeNativeMethods.GetCurrentObject(new HandleRef(this, hDC), 7));
			hCurrentFont = (hInitialFont = IntUnsafeNativeMethods.GetCurrentObject(new HandleRef(this, hDC), 6));
		}

		public void DeleteObject(IntPtr handle, GdiObjectType type)
		{
			IntPtr handle2 = IntPtr.Zero;
			switch (type)
			{
			case GdiObjectType.Pen:
				if (handle == hCurrentPen)
				{
					IntUnsafeNativeMethods.SelectObject(new HandleRef(this, Hdc), new HandleRef(this, hInitialPen));
					hCurrentPen = IntPtr.Zero;
				}
				handle2 = handle;
				break;
			case GdiObjectType.Brush:
				if (handle == hCurrentBrush)
				{
					IntUnsafeNativeMethods.SelectObject(new HandleRef(this, Hdc), new HandleRef(this, hInitialBrush));
					hCurrentBrush = IntPtr.Zero;
				}
				handle2 = handle;
				break;
			case GdiObjectType.Bitmap:
				if (handle == hCurrentBmp)
				{
					IntUnsafeNativeMethods.SelectObject(new HandleRef(this, Hdc), new HandleRef(this, hInitialBmp));
					hCurrentBmp = IntPtr.Zero;
				}
				handle2 = handle;
				break;
			}
			IntUnsafeNativeMethods.DeleteObject(new HandleRef(this, handle2));
		}

		private DeviceContext(IntPtr hWnd)
		{
			this.hWnd = hWnd;
			dcType = DeviceContextType.Display;
			DeviceContexts.AddDeviceContext(this);
		}

		private DeviceContext(IntPtr hDC, DeviceContextType dcType)
		{
			this.hDC = hDC;
			this.dcType = dcType;
			CacheInitialState();
			DeviceContexts.AddDeviceContext(this);
			if (dcType == DeviceContextType.Display)
			{
				hWnd = IntUnsafeNativeMethods.WindowFromDC(new HandleRef(this, this.hDC));
			}
		}

		public static DeviceContext CreateDC(string driverName, string deviceName, string fileName, HandleRef devMode)
		{
			IntPtr intPtr = IntUnsafeNativeMethods.CreateDC(driverName, deviceName, fileName, devMode);
			return new DeviceContext(intPtr, DeviceContextType.NamedDevice);
		}

		public static DeviceContext CreateIC(string driverName, string deviceName, string fileName, HandleRef devMode)
		{
			IntPtr intPtr = IntUnsafeNativeMethods.CreateIC(driverName, deviceName, fileName, devMode);
			return new DeviceContext(intPtr, DeviceContextType.Information);
		}

		public static DeviceContext FromCompatibleDC(IntPtr hdc)
		{
			IntPtr intPtr = IntUnsafeNativeMethods.CreateCompatibleDC(new HandleRef(null, hdc));
			return new DeviceContext(intPtr, DeviceContextType.Memory);
		}

		public static DeviceContext FromHdc(IntPtr hdc)
		{
			return new DeviceContext(hdc, DeviceContextType.Unknown);
		}

		public static DeviceContext FromHwnd(IntPtr hwnd)
		{
			return new DeviceContext(hwnd);
		}

		~DeviceContext()
		{
			Dispose(disposing: false);
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		internal void Dispose(bool disposing)
		{
			if (!disposed)
			{
				if (this.Disposing != null)
				{
					this.Disposing(this, EventArgs.Empty);
				}
				disposed = true;
				switch (dcType)
				{
				case DeviceContextType.Display:
					((IDeviceContext)this).ReleaseHdc();
					break;
				case DeviceContextType.NamedDevice:
				case DeviceContextType.Information:
					IntUnsafeNativeMethods.DeleteHDC(new HandleRef(this, hDC));
					hDC = IntPtr.Zero;
					break;
				case DeviceContextType.Memory:
					IntUnsafeNativeMethods.DeleteDC(new HandleRef(this, hDC));
					hDC = IntPtr.Zero;
					break;
				case DeviceContextType.Unknown:
				case DeviceContextType.NCWindow:
					break;
				}
			}
		}

		IntPtr IDeviceContext.GetHdc()
		{
			if (hDC == IntPtr.Zero)
			{
				hDC = IntUnsafeNativeMethods.GetDC(new HandleRef(this, hWnd));
			}
			return hDC;
		}

		void IDeviceContext.ReleaseHdc()
		{
			if (hDC != IntPtr.Zero && dcType == DeviceContextType.Display)
			{
				IntUnsafeNativeMethods.ReleaseDC(new HandleRef(this, hWnd), new HandleRef(this, hDC));
				hDC = IntPtr.Zero;
			}
		}

		public DeviceContextGraphicsMode SetGraphicsMode(DeviceContextGraphicsMode newMode)
		{
			return (DeviceContextGraphicsMode)IntUnsafeNativeMethods.SetGraphicsMode(new HandleRef(this, Hdc), (int)newMode);
		}

		public void RestoreHdc()
		{
			IntUnsafeNativeMethods.RestoreDC(new HandleRef(this, hDC), -1);
			if (contextStack != null)
			{
				GraphicsState graphicsState = (GraphicsState)contextStack.Pop();
				hCurrentBmp = graphicsState.hBitmap;
				hCurrentBrush = graphicsState.hBrush;
				hCurrentPen = graphicsState.hPen;
				hCurrentFont = graphicsState.hFont;
			}
		}

		public int SaveHdc()
		{
			HandleRef handleRef = new HandleRef(this, Hdc);
			int result = IntUnsafeNativeMethods.SaveDC(handleRef);
			if (contextStack == null)
			{
				contextStack = new Stack();
			}
			GraphicsState graphicsState = new GraphicsState();
			graphicsState.hBitmap = hCurrentBmp;
			graphicsState.hBrush = hCurrentBrush;
			graphicsState.hPen = hCurrentPen;
			graphicsState.hFont = hCurrentFont;
			contextStack.Push(graphicsState);
			return result;
		}

		public void SetClip(WindowsRegion region)
		{
			HandleRef handleRef = new HandleRef(this, Hdc);
			HandleRef hRgn = new HandleRef(region, region.HRegion);
			IntUnsafeNativeMethods.SelectClipRgn(handleRef, hRgn);
		}

		public void IntersectClip(WindowsRegion wr)
		{
			if (wr.HRegion == IntPtr.Zero)
			{
				return;
			}
			WindowsRegion windowsRegion = new WindowsRegion(0, 0, 0, 0);
			try
			{
				int clipRgn = IntUnsafeNativeMethods.GetClipRgn(new HandleRef(this, Hdc), new HandleRef(windowsRegion, windowsRegion.HRegion));
				if (clipRgn == 1)
				{
					wr.CombineRegion(windowsRegion, wr, RegionCombineMode.AND);
				}
				SetClip(wr);
			}
			finally
			{
				windowsRegion.Dispose();
			}
		}

		public void TranslateTransform(int dx, int dy)
		{
			IntNativeMethods.POINT point = new IntNativeMethods.POINT();
			IntUnsafeNativeMethods.OffsetViewportOrgEx(new HandleRef(this, Hdc), dx, dy, point);
		}

		public override bool Equals(object obj)
		{
			DeviceContext deviceContext = obj as DeviceContext;
			if (deviceContext == this)
			{
				return true;
			}
			if (deviceContext == null)
			{
				return false;
			}
			return deviceContext.Hdc == Hdc;
		}

		public override int GetHashCode()
		{
			return Hdc.GetHashCode();
		}
	}
	internal static class DeviceContexts
	{
		[ThreadStatic]
		private static ClientUtils.WeakRefCollection activeDeviceContexts;

		internal static void AddDeviceContext(DeviceContext dc)
		{
			if (activeDeviceContexts == null)
			{
				activeDeviceContexts = new ClientUtils.WeakRefCollection();
				activeDeviceContexts.RefCheckThreshold = 20;
			}
			if (!activeDeviceContexts.Contains(dc))
			{
				dc.Disposing += OnDcDisposing;
				activeDeviceContexts.Add(dc);
			}
		}

		private static void OnDcDisposing(object sender, EventArgs e)
		{
			if (sender is DeviceContext deviceContext)
			{
				deviceContext.Disposing -= OnDcDisposing;
				RemoveDeviceContext(deviceContext);
			}
		}

		internal static void RemoveDeviceContext(DeviceContext dc)
		{
			if (activeDeviceContexts != null)
			{
				activeDeviceContexts.RemoveByHashCode(dc);
			}
		}
	}
	internal enum DeviceContextGraphicsMode
	{
		Compatible = 1,
		Advanced = 2,
		ModifyWorldIdentity = 1
	}
	internal enum DeviceContextType
	{
		Unknown,
		Display,
		NCWindow,
		NamedDevice,
		Information,
		Memory,
		Metafile
	}
	internal enum GdiObjectType
	{
		Pen = 1,
		Brush,
		DisplayDC,
		MetafileDC,
		Palette,
		Font,
		Bitmap,
		Region,
		Metafile,
		MemoryDC,
		ExtendedPen,
		EnhancedMetafileDC,
		EnhMetafile,
		ColorSpace
	}
	internal sealed class WindowsRegion : MarshalByRefObject, ICloneable, IDisposable
	{
		private IntPtr nativeHandle;

		private bool ownHandle;

		public IntPtr HRegion => nativeHandle;

		public bool IsInfinite => nativeHandle == IntPtr.Zero;

		private WindowsRegion()
		{
		}

		public WindowsRegion(Rectangle rect)
		{
			CreateRegion(rect);
		}

		public WindowsRegion(int x, int y, int width, int height)
		{
			CreateRegion(new Rectangle(x, y, width, height));
		}

		public static WindowsRegion FromHregion(IntPtr hRegion, bool takeOwnership)
		{
			WindowsRegion windowsRegion = new WindowsRegion();
			if (hRegion != IntPtr.Zero)
			{
				windowsRegion.nativeHandle = hRegion;
				if (takeOwnership)
				{
					windowsRegion.ownHandle = true;
					System.Internal.HandleCollector.Add(hRegion, IntSafeNativeMethods.CommonHandles.GDI);
				}
			}
			return windowsRegion;
		}

		public static WindowsRegion FromRegion(Region region, Graphics g)
		{
			if (region.IsInfinite(g))
			{
				return new WindowsRegion();
			}
			return FromHregion(region.GetHrgn(g), takeOwnership: true);
		}

		public object Clone()
		{
			if (!IsInfinite)
			{
				return new WindowsRegion(ToRectangle());
			}
			return new WindowsRegion();
		}

		public IntNativeMethods.RegionFlags CombineRegion(WindowsRegion region1, WindowsRegion region2, RegionCombineMode mode)
		{
			return IntUnsafeNativeMethods.CombineRgn(new HandleRef(this, HRegion), new HandleRef(region1, region1.HRegion), new HandleRef(region2, region2.HRegion), mode);
		}

		private void CreateRegion(Rectangle rect)
		{
			nativeHandle = IntSafeNativeMethods.CreateRectRgn(rect.X, rect.Y, rect.X + rect.Width, rect.Y + rect.Height);
			ownHandle = true;
		}

		public void Dispose()
		{
			Dispose(disposing: true);
		}

		public void Dispose(bool disposing)
		{
			if (nativeHandle != IntPtr.Zero)
			{
				if (ownHandle)
				{
					IntUnsafeNativeMethods.DeleteObject(new HandleRef(this, nativeHandle));
				}
				nativeHandle = IntPtr.Zero;
				if (disposing)
				{
					GC.SuppressFinalize(this);
				}
			}
		}

		~WindowsRegion()
		{
			Dispose(disposing: false);
		}

		public Rectangle ToRectangle()
		{
			if (IsInfinite)
			{
				return new Rectangle(-2147483647, -2147483647, int.MaxValue, int.MaxValue);
			}
			IntNativeMethods.RECT clipRect = default(IntNativeMethods.RECT);
			IntUnsafeNativeMethods.GetRgnBox(new HandleRef(this, nativeHandle), ref clipRect);
			return new Rectangle(new Point(clipRect.left, clipRect.top), clipRect.Size);
		}
	}
	internal enum RegionCombineMode
	{
		AND = 1,
		OR = 2,
		XOR = 3,
		DIFF = 4,
		COPY = 5,
		MIN = 1,
		MAX = 5
	}
	internal sealed class WindowsGraphics : MarshalByRefObject, IDeviceContext, IDisposable
	{
		private DeviceContext dc;

		private bool disposeDc;

		private Graphics graphics;

		public DeviceContext DeviceContext => dc;

		public WindowsGraphics(DeviceContext dc)
		{
			this.dc = dc;
			this.dc.SaveHdc();
		}

		public static WindowsGraphics CreateMeasurementWindowsGraphics()
		{
			DeviceContext deviceContext = DeviceContext.FromCompatibleDC(IntPtr.Zero);
			WindowsGraphics windowsGraphics = new WindowsGraphics(deviceContext);
			windowsGraphics.disposeDc = true;
			return windowsGraphics;
		}

		public static WindowsGraphics FromHwnd(IntPtr hWnd)
		{
			DeviceContext deviceContext = DeviceContext.FromHwnd(hWnd);
			WindowsGraphics windowsGraphics = new WindowsGraphics(deviceContext);
			windowsGraphics.disposeDc = true;
			return windowsGraphics;
		}

		public static WindowsGraphics FromHdc(IntPtr hDc)
		{
			DeviceContext deviceContext = DeviceContext.FromHdc(hDc);
			WindowsGraphics windowsGraphics = new WindowsGraphics(deviceContext);
			windowsGraphics.disposeDc = true;
			return windowsGraphics;
		}

		public static WindowsGraphics FromGraphics(Graphics g)
		{
			ApplyGraphicsProperties properties = ApplyGraphicsProperties.All;
			return FromGraphics(g, properties);
		}

		public static WindowsGraphics FromGraphics(Graphics g, ApplyGraphicsProperties properties)
		{
			WindowsRegion windowsRegion = null;
			float[] array = null;
			Region region = null;
			Matrix matrix = null;
			if ((properties & ApplyGraphicsProperties.TranslateTransform) != 0 || (properties & ApplyGraphicsProperties.Clipping) != 0)
			{
				if (g.GetContextInfo() is object[] array2 && array2.Length == 2)
				{
					region = array2[0] as Region;
					matrix = array2[1] as Matrix;
				}
				if (matrix != null)
				{
					if ((properties & ApplyGraphicsProperties.TranslateTransform) != 0)
					{
						array = matrix.Elements;
					}
					matrix.Dispose();
				}
				if (region != null)
				{
					if ((properties & ApplyGraphicsProperties.Clipping) != 0 && !region.IsInfinite(g))
					{
						windowsRegion = WindowsRegion.FromRegion(region, g);
					}
					region.Dispose();
				}
			}
			WindowsGraphics windowsGraphics = FromHdc(g.GetHdc());
			windowsGraphics.graphics = g;
			if (windowsRegion != null)
			{
				using (windowsRegion)
				{
					windowsGraphics.DeviceContext.IntersectClip(windowsRegion);
				}
			}
			if (array != null)
			{
				windowsGraphics.DeviceContext.TranslateTransform((int)array[4], (int)array[5]);
			}
			return windowsGraphics;
		}

		~WindowsGraphics()
		{
			Dispose(disposing: false);
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		internal void Dispose(bool disposing)
		{
			if (dc == null)
			{
				return;
			}
			try
			{
				dc.RestoreHdc();
				if (disposeDc)
				{
					dc.Dispose(disposing);
				}
				if (graphics != null)
				{
					graphics.ReleaseHdcInternal(dc.Hdc);
					graphics = null;
				}
			}
			catch (Exception ex)
			{
				if (ClientUtils.IsSecurityOrCriticalException(ex))
				{
					throw;
				}
			}
			finally
			{
				dc = null;
			}
		}

		public IntPtr GetHdc()
		{
			return dc.Hdc;
		}

		public void ReleaseHdc()
		{
			dc.Dispose();
		}
	}
	internal class IntNativeMethods
	{
		public enum RegionFlags
		{
			ERROR,
			NULLREGION,
			SIMPLEREGION,
			COMPLEXREGION
		}

		public struct RECT
		{
			public int left;

			public int top;

			public int right;

			public int bottom;

			public Size Size => new Size(right - left, bottom - top);

			public RECT(int left, int top, int right, int bottom)
			{
				this.left = left;
				this.top = top;
				this.right = right;
				this.bottom = bottom;
			}

			public RECT(Rectangle r)
			{
				left = r.Left;
				top = r.Top;
				right = r.Right;
				bottom = r.Bottom;
			}

			public static RECT FromXYWH(int x, int y, int width, int height)
			{
				return new RECT(x, y, x + width, y + height);
			}

			public Rectangle ToRectangle()
			{
				return new Rectangle(left, top, right - left, bottom - top);
			}
		}

		[StructLayout(LayoutKind.Sequential)]
		public class POINT
		{
			public int x;

			public int y;

			public POINT()
			{
			}

			public POINT(int x, int y)
			{
				this.x = x;
				this.y = y;
			}

			public Point ToPoint()
			{
				return new Point(x, y);
			}
		}

		[StructLayout(LayoutKind.Sequential)]
		public class DRAWTEXTPARAMS
		{
			private int cbSize = Marshal.SizeOf(typeof(DRAWTEXTPARAMS));

			public int iTabLength;

			public int iLeftMargin;

			public int iRightMargin;

			public int uiLengthDrawn;

			public DRAWTEXTPARAMS()
			{
			}

			public DRAWTEXTPARAMS(DRAWTEXTPARAMS original)
			{
				iLeftMargin = original.iLeftMargin;
				iRightMargin = original.iRightMargin;
				iTabLength = original.iTabLength;
			}

			public DRAWTEXTPARAMS(int leftMargin, int rightMargin)
			{
				iLeftMargin = leftMargin;
				iRightMargin = rightMargin;
			}
		}

		[StructLayout(LayoutKind.Sequential)]
		public class LOGBRUSH
		{
			public int lbStyle;

			public int lbColor;

			public int lbHatch;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
		public class LOGFONT
		{
			public int lfHeight;

			public int lfWidth;

			public int lfEscapement;

			public int lfOrientation;

			public int lfWeight;

			public byte lfItalic;

			public byte lfUnderline;

			public byte lfStrikeOut;

			public byte lfCharSet;

			public byte lfOutPrecision;

			public byte lfClipPrecision;

			public byte lfQuality;

			public byte lfPitchAndFamily;

			[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]
			public string lfFaceName;

			public LOGFONT()
			{
			}

			public LOGFONT(LOGFONT lf)
			{
				lfHeight = lf.lfHeight;
				lfWidth = lf.lfWidth;
				lfEscapement = lf.lfEscapement;
				lfOrientation = lf.lfOrientation;
				lfWeight = lf.lfWeight;
				lfItalic = lf.lfItalic;
				lfUnderline = lf.lfUnderline;
				lfStrikeOut = lf.lfStrikeOut;
				lfCharSet = lf.lfCharSet;
				lfOutPrecision = lf.lfOutPrecision;
				lfClipPrecision = lf.lfClipPrecision;
				lfQuality = lf.lfQuality;
				lfPitchAndFamily = lf.lfPitchAndFamily;
				lfFaceName = lf.lfFaceName;
			}
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		public struct TEXTMETRIC
		{
			public int tmHeight;

			public int tmAscent;

			public int tmDescent;

			public int tmInternalLeading;

			public int tmExternalLeading;

			public int tmAveCharWidth;

			public int tmMaxCharWidth;

			public int tmWeight;

			public int tmOverhang;

			public int tmDigitizedAspectX;

			public int tmDigitizedAspectY;

			public char tmFirstChar;

			public char tmLastChar;

			public char tmDefaultChar;

			public char tmBreakChar;

			public byte tmItalic;

			public byte tmUnderlined;

			public byte tmStruckOut;

			public byte tmPitchAndFamily;

			public byte tmCharSet;
		}

		public struct TEXTMETRICA
		{
			public int tmHeight;

			public int tmAscent;

			public int tmDescent;

			public int tmInternalLeading;

			public int tmExternalLeading;

			public int tmAveCharWidth;

			public int tmMaxCharWidth;

			public int tmWeight;

			public int tmOverhang;

			public int tmDigitizedAspectX;

			public int tmDigitizedAspectY;

			public byte tmFirstChar;

			public byte tmLastChar;

			public byte tmDefaultChar;

			public byte tmBreakChar;

			public byte tmItalic;

			public byte tmUnderlined;

			public byte tmStruckOut;

			public byte tmPitchAndFamily;

			public byte tmCharSet;
		}

		[StructLayout(LayoutKind.Sequential)]
		public class SIZE
		{
			public int cx;

			public int cy;

			public SIZE()
			{
			}

			public SIZE(int cx, int cy)
			{
				this.cx = cx;
				this.cy = cy;
			}

			public Size ToSize()
			{
				return new Size(cx, cy);
			}
		}

		public const int MaxTextLengthInWin9x = 8192;

		public const int DT_TOP = 0;

		public const int DT_LEFT = 0;

		public const int DT_CENTER = 1;

		public const int DT_RIGHT = 2;

		public const int DT_VCENTER = 4;

		public const int DT_BOTTOM = 8;

		public const int DT_WORDBREAK = 16;

		public const int DT_SINGLELINE = 32;

		public const int DT_EXPANDTABS = 64;

		public const int DT_TABSTOP = 128;

		public const int DT_NOCLIP = 256;

		public const int DT_EXTERNALLEADING = 512;

		public const int DT_CALCRECT = 1024;

		public const int DT_NOPREFIX = 2048;

		public const int DT_INTERNAL = 4096;

		public const int DT_EDITCONTROL = 8192;

		public const int DT_PATH_ELLIPSIS = 16384;

		public const int DT_END_ELLIPSIS = 32768;

		public const int DT_MODIFYSTRING = 65536;

		public const int DT_RTLREADING = 131072;

		public const int DT_WORD_ELLIPSIS = 262144;

		public const int DT_NOFULLWIDTHCHARBREAK = 524288;

		public const int DT_HIDEPREFIX = 1048576;

		public const int DT_PREFIXONLY = 2097152;

		public const int DIB_RGB_COLORS = 0;

		public const int BI_BITFIELDS = 3;

		public const int BI_RGB = 0;

		public const int BITMAPINFO_MAX_COLORSIZE = 256;

		public const int SPI_GETICONTITLELOGFONT = 31;

		public const int SPI_GETNONCLIENTMETRICS = 41;

		public const int DEFAULT_GUI_FONT = 17;

		public const int HOLLOW_BRUSH = 5;

		public const int BITSPIXEL = 12;

		public const int ALTERNATE = 1;

		public const int WINDING = 2;

		public const int SRCCOPY = 13369376;

		public const int SRCPAINT = 15597702;

		public const int SRCAND = 8913094;

		public const int SRCINVERT = 6684742;

		public const int SRCERASE = 4457256;

		public const int NOTSRCCOPY = 3342344;

		public const int NOTSRCERASE = 1114278;

		public const int MERGECOPY = 12583114;

		public const int MERGEPAINT = 12255782;

		public const int PATCOPY = 15728673;

		public const int PATPAINT = 16452105;

		public const int PATINVERT = 5898313;

		public const int DSTINVERT = 5570569;

		public const int BLACKNESS = 66;

		public const int WHITENESS = 16711778;

		public const int CAPTUREBLT = 1073741824;

		public const int FW_DONTCARE = 0;

		public const int FW_NORMAL = 400;

		public const int FW_BOLD = 700;

		public const int ANSI_CHARSET = 0;

		public const int DEFAULT_CHARSET = 1;

		public const int OUT_DEFAULT_PRECIS = 0;

		public const int OUT_TT_PRECIS = 4;

		public const int OUT_TT_ONLY_PRECIS = 7;

		public const int CLIP_DEFAULT_PRECIS = 0;

		public const int DEFAULT_QUALITY = 0;

		public const int DRAFT_QUALITY = 1;

		public const int PROOF_QUALITY = 2;

		public const int NONANTIALIASED_QUALITY = 3;

		public const int ANTIALIASED_QUALITY = 4;

		public const int CLEARTYPE_QUALITY = 5;

		public const int CLEARTYPE_NATURAL_QUALITY = 6;

		public const int OBJ_PEN = 1;

		public const int OBJ_BRUSH = 2;

		public const int OBJ_DC = 3;

		public const int OBJ_METADC = 4;

		public const int OBJ_FONT = 6;

		public const int OBJ_BITMAP = 7;

		public const int OBJ_MEMDC = 10;

		public const int OBJ_EXTPEN = 11;

		public const int OBJ_ENHMETADC = 12;

		public const int BS_SOLID = 0;

		public const int BS_HATCHED = 2;

		public const int CP_ACP = 0;

		public const int FORMAT_MESSAGE_ALLOCATE_BUFFER = 256;

		public const int FORMAT_MESSAGE_IGNORE_INSERTS = 512;

		public const int FORMAT_MESSAGE_FROM_SYSTEM = 4096;

		public const int FORMAT_MESSAGE_DEFAULT = 4608;
	}
	[SuppressUnmanagedCodeSecurity]
	internal static class IntSafeNativeMethods
	{
		public sealed class CommonHandles
		{
			public static readonly int EMF;

			public static readonly int GDI;

			public static readonly int HDC;

			static CommonHandles()
			{
				EMF = System.Internal.HandleCollector.RegisterType("EnhancedMetaFile", 20, 500);
				GDI = System.Internal.HandleCollector.RegisterType("GDI", 90, 50);
				HDC = System.Internal.HandleCollector.RegisterType("HDC", 100, 2);
			}
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "CreateSolidBrush", ExactSpelling = true, SetLastError = true)]
		private static extern IntPtr IntCreateSolidBrush(int crColor);

		public static IntPtr CreateSolidBrush(int crColor)
		{
			return System.Internal.HandleCollector.Add(IntCreateSolidBrush(crColor), CommonHandles.GDI);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "CreatePen", ExactSpelling = true, SetLastError = true)]
		private static extern IntPtr IntCreatePen(int fnStyle, int nWidth, int crColor);

		public static IntPtr CreatePen(int fnStyle, int nWidth, int crColor)
		{
			return System.Internal.HandleCollector.Add(IntCreatePen(fnStyle, nWidth, crColor), CommonHandles.GDI);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "ExtCreatePen", ExactSpelling = true, SetLastError = true)]
		private static extern IntPtr IntExtCreatePen(int fnStyle, int dwWidth, IntNativeMethods.LOGBRUSH lplb, int dwStyleCount, [MarshalAs(UnmanagedType.LPArray)] int[] lpStyle);

		public static IntPtr ExtCreatePen(int fnStyle, int dwWidth, IntNativeMethods.LOGBRUSH lplb, int dwStyleCount, int[] lpStyle)
		{
			return System.Internal.HandleCollector.Add(IntExtCreatePen(fnStyle, dwWidth, lplb, dwStyleCount, lpStyle), CommonHandles.GDI);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "CreateRectRgn", ExactSpelling = true, SetLastError = true)]
		public static extern IntPtr IntCreateRectRgn(int x1, int y1, int x2, int y2);

		public static IntPtr CreateRectRgn(int x1, int y1, int x2, int y2)
		{
			return System.Internal.HandleCollector.Add(IntCreateRectRgn(x1, y1, x2, y2), CommonHandles.GDI);
		}

		[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern int GetUserDefaultLCID();

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern bool GdiFlush();
	}
	[SuppressUnmanagedCodeSecurity]
	internal static class IntUnsafeNativeMethods
	{
		[DllImport("user32.dll", CharSet = CharSet.Auto, EntryPoint = "GetDC", ExactSpelling = true, SetLastError = true)]
		public static extern IntPtr IntGetDC(HandleRef hWnd);

		public static IntPtr GetDC(HandleRef hWnd)
		{
			return System.Internal.HandleCollector.Add(IntGetDC(hWnd), IntSafeNativeMethods.CommonHandles.HDC);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "DeleteDC", ExactSpelling = true, SetLastError = true)]
		public static extern bool IntDeleteDC(HandleRef hDC);

		public static bool DeleteDC(HandleRef hDC)
		{
			System.Internal.HandleCollector.Remove((IntPtr)hDC, IntSafeNativeMethods.CommonHandles.GDI);
			return IntDeleteDC(hDC);
		}

		public static bool DeleteHDC(HandleRef hDC)
		{
			System.Internal.HandleCollector.Remove((IntPtr)hDC, IntSafeNativeMethods.CommonHandles.HDC);
			return IntDeleteDC(hDC);
		}

		[DllImport("user32.dll", CharSet = CharSet.Auto, EntryPoint = "ReleaseDC", ExactSpelling = true, SetLastError = true)]
		public static extern int IntReleaseDC(HandleRef hWnd, HandleRef hDC);

		public static int ReleaseDC(HandleRef hWnd, HandleRef hDC)
		{
			System.Internal.HandleCollector.Remove((IntPtr)hDC, IntSafeNativeMethods.CommonHandles.HDC);
			return IntReleaseDC(hWnd, hDC);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "CreateDC", SetLastError = true)]
		public static extern IntPtr IntCreateDC(string lpszDriverName, string lpszDeviceName, string lpszOutput, HandleRef lpInitData);

		public static IntPtr CreateDC(string lpszDriverName, string lpszDeviceName, string lpszOutput, HandleRef lpInitData)
		{
			return System.Internal.HandleCollector.Add(IntCreateDC(lpszDriverName, lpszDeviceName, lpszOutput, lpInitData), IntSafeNativeMethods.CommonHandles.HDC);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "CreateIC", SetLastError = true)]
		public static extern IntPtr IntCreateIC(string lpszDriverName, string lpszDeviceName, string lpszOutput, HandleRef lpInitData);

		public static IntPtr CreateIC(string lpszDriverName, string lpszDeviceName, string lpszOutput, HandleRef lpInitData)
		{
			return System.Internal.HandleCollector.Add(IntCreateIC(lpszDriverName, lpszDeviceName, lpszOutput, lpInitData), IntSafeNativeMethods.CommonHandles.HDC);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "CreateCompatibleDC", ExactSpelling = true, SetLastError = true)]
		public static extern IntPtr IntCreateCompatibleDC(HandleRef hDC);

		public static IntPtr CreateCompatibleDC(HandleRef hDC)
		{
			return System.Internal.HandleCollector.Add(IntCreateCompatibleDC(hDC), IntSafeNativeMethods.CommonHandles.GDI);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "SaveDC", ExactSpelling = true, SetLastError = true)]
		public static extern int IntSaveDC(HandleRef hDC);

		public static int SaveDC(HandleRef hDC)
		{
			return IntSaveDC(hDC);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "RestoreDC", ExactSpelling = true, SetLastError = true)]
		public static extern bool IntRestoreDC(HandleRef hDC, int nSavedDC);

		public static bool RestoreDC(HandleRef hDC, int nSavedDC)
		{
			return IntRestoreDC(hDC, nSavedDC);
		}

		[DllImport("user32.dll", ExactSpelling = true, SetLastError = true)]
		public static extern IntPtr WindowFromDC(HandleRef hDC);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int GetDeviceCaps(HandleRef hDC, int nIndex);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "OffsetViewportOrgEx", ExactSpelling = true, SetLastError = true)]
		public static extern bool IntOffsetViewportOrgEx(HandleRef hDC, int nXOffset, int nYOffset, [In][Out] IntNativeMethods.POINT point);

		public static bool OffsetViewportOrgEx(HandleRef hDC, int nXOffset, int nYOffset, [In][Out] IntNativeMethods.POINT point)
		{
			return IntOffsetViewportOrgEx(hDC, nXOffset, nYOffset, point);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "SetGraphicsMode", ExactSpelling = true, SetLastError = true)]
		public static extern int IntSetGraphicsMode(HandleRef hDC, int iMode);

		public static int SetGraphicsMode(HandleRef hDC, int iMode)
		{
			iMode = IntSetGraphicsMode(hDC, iMode);
			return iMode;
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int GetGraphicsMode(HandleRef hDC);

		[DllImport("gdi32.dll", ExactSpelling = true, SetLastError = true)]
		public static extern int GetROP2(HandleRef hdc);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int SetROP2(HandleRef hDC, int nDrawMode);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "CombineRgn", ExactSpelling = true, SetLastError = true)]
		public static extern IntNativeMethods.RegionFlags IntCombineRgn(HandleRef hRgnDest, HandleRef hRgnSrc1, HandleRef hRgnSrc2, RegionCombineMode combineMode);

		public static IntNativeMethods.RegionFlags CombineRgn(HandleRef hRgnDest, HandleRef hRgnSrc1, HandleRef hRgnSrc2, RegionCombineMode combineMode)
		{
			if (hRgnDest.Wrapper == null || hRgnSrc1.Wrapper == null || hRgnSrc2.Wrapper == null)
			{
				return IntNativeMethods.RegionFlags.ERROR;
			}
			return IntCombineRgn(hRgnDest, hRgnSrc1, hRgnSrc2, combineMode);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "GetClipRgn", ExactSpelling = true, SetLastError = true)]
		public static extern int IntGetClipRgn(HandleRef hDC, HandleRef hRgn);

		public static int GetClipRgn(HandleRef hDC, HandleRef hRgn)
		{
			return IntGetClipRgn(hDC, hRgn);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "SelectClipRgn", ExactSpelling = true, SetLastError = true)]
		public static extern IntNativeMethods.RegionFlags IntSelectClipRgn(HandleRef hDC, HandleRef hRgn);

		public static IntNativeMethods.RegionFlags SelectClipRgn(HandleRef hDC, HandleRef hRgn)
		{
			return IntSelectClipRgn(hDC, hRgn);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "GetRgnBox", ExactSpelling = true, SetLastError = true)]
		public static extern IntNativeMethods.RegionFlags IntGetRgnBox(HandleRef hRgn, [In][Out] ref IntNativeMethods.RECT clipRect);

		public static IntNativeMethods.RegionFlags GetRgnBox(HandleRef hRgn, [In][Out] ref IntNativeMethods.RECT clipRect)
		{
			return IntGetRgnBox(hRgn, ref clipRect);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "CreateFontIndirect", SetLastError = true)]
		public static extern IntPtr IntCreateFontIndirect([In][Out][MarshalAs(UnmanagedType.AsAny)] object lf);

		public static IntPtr CreateFontIndirect(object lf)
		{
			return System.Internal.HandleCollector.Add(IntCreateFontIndirect(lf), IntSafeNativeMethods.CommonHandles.GDI);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "DeleteObject", ExactSpelling = true, SetLastError = true)]
		public static extern bool IntDeleteObject(HandleRef hObject);

		public static bool DeleteObject(HandleRef hObject)
		{
			System.Internal.HandleCollector.Remove((IntPtr)hObject, IntSafeNativeMethods.CommonHandles.GDI);
			return IntDeleteObject(hObject);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "GetObject", SetLastError = true)]
		public static extern int IntGetObject(HandleRef hBrush, int nSize, [In][Out] IntNativeMethods.LOGBRUSH lb);

		public static int GetObject(HandleRef hBrush, IntNativeMethods.LOGBRUSH lb)
		{
			return IntGetObject(hBrush, Marshal.SizeOf(typeof(IntNativeMethods.LOGBRUSH)), lb);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "GetObject", SetLastError = true)]
		public static extern int IntGetObject(HandleRef hFont, int nSize, [In][Out] IntNativeMethods.LOGFONT lf);

		public static int GetObject(HandleRef hFont, IntNativeMethods.LOGFONT lp)
		{
			return IntGetObject(hFont, Marshal.SizeOf(typeof(IntNativeMethods.LOGFONT)), lp);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "SelectObject", ExactSpelling = true, SetLastError = true)]
		public static extern IntPtr IntSelectObject(HandleRef hdc, HandleRef obj);

		public static IntPtr SelectObject(HandleRef hdc, HandleRef obj)
		{
			return IntSelectObject(hdc, obj);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "GetCurrentObject", ExactSpelling = true, SetLastError = true)]
		public static extern IntPtr IntGetCurrentObject(HandleRef hDC, int uObjectType);

		public static IntPtr GetCurrentObject(HandleRef hDC, int uObjectType)
		{
			return IntGetCurrentObject(hDC, uObjectType);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "GetStockObject", ExactSpelling = true, SetLastError = true)]
		public static extern IntPtr IntGetStockObject(int nIndex);

		public static IntPtr GetStockObject(int nIndex)
		{
			return IntGetStockObject(nIndex);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int GetNearestColor(HandleRef hDC, int color);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int SetTextColor(HandleRef hDC, int crColor);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int GetTextAlign(HandleRef hdc);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int GetTextColor(HandleRef hDC);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int SetBkColor(HandleRef hDC, int clr);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "SetBkMode", ExactSpelling = true, SetLastError = true)]
		public static extern int IntSetBkMode(HandleRef hDC, int nBkMode);

		public static int SetBkMode(HandleRef hDC, int nBkMode)
		{
			return IntSetBkMode(hDC, nBkMode);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "GetBkMode", ExactSpelling = true, SetLastError = true)]
		public static extern int IntGetBkMode(HandleRef hDC);

		public static int GetBkMode(HandleRef hDC)
		{
			return IntGetBkMode(hDC);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int GetBkColor(HandleRef hDC);

		[DllImport("user32.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
		public static extern int DrawTextW(HandleRef hDC, string lpszString, int nCount, ref IntNativeMethods.RECT lpRect, int nFormat);

		[DllImport("user32.dll", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)]
		public static extern int DrawTextA(HandleRef hDC, byte[] lpszString, int byteCount, ref IntNativeMethods.RECT lpRect, int nFormat);

		public static int DrawText(HandleRef hDC, string text, ref IntNativeMethods.RECT lpRect, int nFormat)
		{
			if (Marshal.SystemDefaultCharSize == 1)
			{
				lpRect.top = Math.Min(32767, lpRect.top);
				lpRect.left = Math.Min(32767, lpRect.left);
				lpRect.right = Math.Min(32767, lpRect.right);
				lpRect.bottom = Math.Min(32767, lpRect.bottom);
				int num = WideCharToMultiByte(0, 0, text, text.Length, null, 0, IntPtr.Zero, IntPtr.Zero);
				byte[] array = new byte[num];
				WideCharToMultiByte(0, 0, text, text.Length, array, array.Length, IntPtr.Zero, IntPtr.Zero);
				num = Math.Min(num, 8192);
				return DrawTextA(hDC, array, num, ref lpRect, nFormat);
			}
			return DrawTextW(hDC, text, text.Length, ref lpRect, nFormat);
		}

		[DllImport("user32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
		public static extern int DrawTextExW(HandleRef hDC, string lpszString, int nCount, ref IntNativeMethods.RECT lpRect, int nFormat, [In][Out] IntNativeMethods.DRAWTEXTPARAMS lpDTParams);

		[DllImport("user32.dll", CharSet = CharSet.Ansi, SetLastError = true)]
		public static extern int DrawTextExA(HandleRef hDC, byte[] lpszString, int byteCount, ref IntNativeMethods.RECT lpRect, int nFormat, [In][Out] IntNativeMethods.DRAWTEXTPARAMS lpDTParams);

		public static int DrawTextEx(HandleRef hDC, string text, ref IntNativeMethods.RECT lpRect, int nFormat, [In][Out] IntNativeMethods.DRAWTEXTPARAMS lpDTParams)
		{
			if (Marshal.SystemDefaultCharSize == 1)
			{
				lpRect.top = Math.Min(32767, lpRect.top);
				lpRect.left = Math.Min(32767, lpRect.left);
				lpRect.right = Math.Min(32767, lpRect.right);
				lpRect.bottom = Math.Min(32767, lpRect.bottom);
				int num = WideCharToMultiByte(0, 0, text, text.Length, null, 0, IntPtr.Zero, IntPtr.Zero);
				byte[] array = new byte[num];
				WideCharToMultiByte(0, 0, text, text.Length, array, array.Length, IntPtr.Zero, IntPtr.Zero);
				num = Math.Min(num, 8192);
				return DrawTextExA(hDC, array, num, ref lpRect, nFormat, lpDTParams);
			}
			return DrawTextExW(hDC, text, text.Length, ref lpRect, nFormat, lpDTParams);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
		public static extern int GetTextExtentPoint32W(HandleRef hDC, string text, int len, [In][Out] IntNativeMethods.SIZE size);

		[DllImport("gdi32.dll", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)]
		public static extern int GetTextExtentPoint32A(HandleRef hDC, byte[] lpszString, int byteCount, [In][Out] IntNativeMethods.SIZE size);

		public static int GetTextExtentPoint32(HandleRef hDC, string text, [In][Out] IntNativeMethods.SIZE size)
		{
			int length = text.Length;
			if (Marshal.SystemDefaultCharSize == 1)
			{
				length = WideCharToMultiByte(0, 0, text, text.Length, null, 0, IntPtr.Zero, IntPtr.Zero);
				byte[] array = new byte[length];
				WideCharToMultiByte(0, 0, text, text.Length, array, array.Length, IntPtr.Zero, IntPtr.Zero);
				length = Math.Min(text.Length, 8192);
				return GetTextExtentPoint32A(hDC, array, length, size);
			}
			return GetTextExtentPoint32W(hDC, text, text.Length, size);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		internal static extern bool ExtTextOut(HandleRef hdc, int x, int y, int options, ref IntNativeMethods.RECT rect, string str, int length, int[] spacing);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "LineTo", ExactSpelling = true, SetLastError = true)]
		public static extern bool IntLineTo(HandleRef hdc, int x, int y);

		public static bool LineTo(HandleRef hdc, int x, int y)
		{
			return IntLineTo(hdc, x, y);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "MoveToEx", ExactSpelling = true, SetLastError = true)]
		public static extern bool IntMoveToEx(HandleRef hdc, int x, int y, IntNativeMethods.POINT pt);

		public static bool MoveToEx(HandleRef hdc, int x, int y, IntNativeMethods.POINT pt)
		{
			return IntMoveToEx(hdc, x, y, pt);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "Rectangle", ExactSpelling = true, SetLastError = true)]
		public static extern bool IntRectangle(HandleRef hdc, int left, int top, int right, int bottom);

		public static bool Rectangle(HandleRef hdc, int left, int top, int right, int bottom)
		{
			return IntRectangle(hdc, left, top, right, bottom);
		}

		[DllImport("user32.dll", CharSet = CharSet.Auto, EntryPoint = "FillRect", ExactSpelling = true, SetLastError = true)]
		public static extern bool IntFillRect(HandleRef hdc, [In] ref IntNativeMethods.RECT rect, HandleRef hbrush);

		public static bool FillRect(HandleRef hDC, [In] ref IntNativeMethods.RECT rect, HandleRef hbrush)
		{
			return IntFillRect(hDC, ref rect, hbrush);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "SetMapMode", ExactSpelling = true, SetLastError = true)]
		public static extern int IntSetMapMode(HandleRef hDC, int nMapMode);

		public static int SetMapMode(HandleRef hDC, int nMapMode)
		{
			return IntSetMapMode(hDC, nMapMode);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "GetMapMode", ExactSpelling = true, SetLastError = true)]
		public static extern int IntGetMapMode(HandleRef hDC);

		public static int GetMapMode(HandleRef hDC)
		{
			return IntGetMapMode(hDC);
		}

		[DllImport("gdi32.dll", EntryPoint = "GetViewportExtEx", ExactSpelling = true, SetLastError = true)]
		public static extern bool IntGetViewportExtEx(HandleRef hdc, [In][Out] IntNativeMethods.SIZE lpSize);

		public static bool GetViewportExtEx(HandleRef hdc, [In][Out] IntNativeMethods.SIZE lpSize)
		{
			return IntGetViewportExtEx(hdc, lpSize);
		}

		[DllImport("gdi32.dll", EntryPoint = "GetViewportOrgEx", ExactSpelling = true, SetLastError = true)]
		public static extern bool IntGetViewportOrgEx(HandleRef hdc, [In][Out] IntNativeMethods.POINT lpPoint);

		public static bool GetViewportOrgEx(HandleRef hdc, [In][Out] IntNativeMethods.POINT lpPoint)
		{
			return IntGetViewportOrgEx(hdc, lpPoint);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "SetViewportExtEx", ExactSpelling = true, SetLastError = true)]
		public static extern bool IntSetViewportExtEx(HandleRef hDC, int x, int y, [In][Out] IntNativeMethods.SIZE size);

		public static bool SetViewportExtEx(HandleRef hDC, int x, int y, [In][Out] IntNativeMethods.SIZE size)
		{
			return IntSetViewportExtEx(hDC, x, y, size);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "SetViewportOrgEx", ExactSpelling = true, SetLastError = true)]
		public static extern bool IntSetViewportOrgEx(HandleRef hDC, int x, int y, [In][Out] IntNativeMethods.POINT point);

		public static bool SetViewportOrgEx(HandleRef hDC, int x, int y, [In][Out] IntNativeMethods.POINT point)
		{
			return IntSetViewportOrgEx(hDC, x, y, point);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
		public static extern int GetTextMetricsW(HandleRef hDC, [In][Out] ref IntNativeMethods.TEXTMETRIC lptm);

		[DllImport("gdi32.dll", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)]
		public static extern int GetTextMetricsA(HandleRef hDC, [In][Out] ref IntNativeMethods.TEXTMETRICA lptm);

		public static int GetTextMetrics(HandleRef hDC, ref IntNativeMethods.TEXTMETRIC lptm)
		{
			int result;
			if (Marshal.SystemDefaultCharSize == 1)
			{
				IntNativeMethods.TEXTMETRICA lptm2 = default(IntNativeMethods.TEXTMETRICA);
				result = GetTextMetricsA(hDC, ref lptm2);
				lptm.tmHeight = lptm2.tmHeight;
				lptm.tmAscent = lptm2.tmAscent;
				lptm.tmDescent = lptm2.tmDescent;
				lptm.tmInternalLeading = lptm2.tmInternalLeading;
				lptm.tmExternalLeading = lptm2.tmExternalLeading;
				lptm.tmAveCharWidth = lptm2.tmAveCharWidth;
				lptm.tmMaxCharWidth = lptm2.tmMaxCharWidth;
				lptm.tmWeight = lptm2.tmWeight;
				lptm.tmOverhang = lptm2.tmOverhang;
				lptm.tmDigitizedAspectX = lptm2.tmDigitizedAspectX;
				lptm.tmDigitizedAspectY = lptm2.tmDigitizedAspectY;
				lptm.tmFirstChar = (char)lptm2.tmFirstChar;
				lptm.tmLastChar = (char)lptm2.tmLastChar;
				lptm.tmDefaultChar = (char)lptm2.tmDefaultChar;
				lptm.tmBreakChar = (char)lptm2.tmBreakChar;
				lptm.tmItalic = lptm2.tmItalic;
				lptm.tmUnderlined = lptm2.tmUnderlined;
				lptm.tmStruckOut = lptm2.tmStruckOut;
				lptm.tmPitchAndFamily = lptm2.tmPitchAndFamily;
				lptm.tmCharSet = lptm2.tmCharSet;
			}
			else
			{
				result = GetTextMetricsW(hDC, ref lptm);
			}
			return result;
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "BeginPath", ExactSpelling = true, SetLastError = true)]
		public static extern bool IntBeginPath(HandleRef hDC);

		public static bool BeginPath(HandleRef hDC)
		{
			return IntBeginPath(hDC);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "EndPath", ExactSpelling = true, SetLastError = true)]
		public static extern bool IntEndPath(HandleRef hDC);

		public static bool EndPath(HandleRef hDC)
		{
			return IntEndPath(hDC);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "StrokePath", ExactSpelling = true, SetLastError = true)]
		public static extern bool IntStrokePath(HandleRef hDC);

		public static bool StrokePath(HandleRef hDC)
		{
			return IntStrokePath(hDC);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "AngleArc", ExactSpelling = true, SetLastError = true)]
		public static extern bool IntAngleArc(HandleRef hDC, int x, int y, int radius, float startAngle, float endAngle);

		public static bool AngleArc(HandleRef hDC, int x, int y, int radius, float startAngle, float endAngle)
		{
			return IntAngleArc(hDC, x, y, radius, startAngle, endAngle);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "Arc", ExactSpelling = true, SetLastError = true)]
		public static extern bool IntArc(HandleRef hDC, int nLeftRect, int nTopRect, int nRightRect, int nBottomRect, int nXStartArc, int nYStartArc, int nXEndArc, int nYEndArc);

		public static bool Arc(HandleRef hDC, int nLeftRect, int nTopRect, int nRightRect, int nBottomRect, int nXStartArc, int nYStartArc, int nXEndArc, int nYEndArc)
		{
			return IntArc(hDC, nLeftRect, nTopRect, nRightRect, nBottomRect, nXStartArc, nYStartArc, nXEndArc, nYEndArc);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int SetTextAlign(HandleRef hDC, int nMode);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "Ellipse", ExactSpelling = true, SetLastError = true)]
		public static extern bool IntEllipse(HandleRef hDc, int x1, int y1, int x2, int y2);

		public static bool Ellipse(HandleRef hDc, int x1, int y1, int x2, int y2)
		{
			return IntEllipse(hDc, x1, y1, x2, y2);
		}

		[DllImport("kernel32.dll", CharSet = CharSet.Unicode, ExactSpelling = true)]
		public static extern int WideCharToMultiByte(int codePage, int flags, [MarshalAs(UnmanagedType.LPWStr)] string wideStr, int chars, [In][Out] byte[] pOutBytes, int bufferBytes, IntPtr defaultChar, IntPtr pDefaultUsed);
	}
}
namespace System.Drawing
{
	[Serializable]
	[Editor("System.Drawing.Design.ImageEditor, System.Drawing.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(UITypeEditor))]
	[ComVisible(true)]
	[TypeConverter(typeof(ImageConverter))]
	[ImmutableObject(true)]
	public abstract class Image : MarshalByRefObject, ISerializable, ICloneable, IDisposable
	{
		public delegate bool GetThumbnailImageAbort();

		private enum ImageTypeEnum
		{
			Bitmap = 1,
			Metafile
		}

		internal IntPtr nativeImage;

		private byte[] rawData;

		private object userData;

		[DefaultValue(null)]
		[TypeConverter(typeof(StringConverter))]
		[Localizable(false)]
		[Bindable(true)]
		public object Tag
		{
			get
			{
				return userData;
			}
			set
			{
				userData = value;
			}
		}

		public SizeF PhysicalDimension => _GetPhysicalDimension();

		public Size Size => new Size(Width, Height);

		[Browsable(false)]
		[DefaultValue(false)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public int Width
		{
			get
			{
				int width;
				int num = SafeNativeMethods.Gdip.GdipGetImageWidth(new HandleRef(this, nativeImage), out width);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return width;
			}
		}

		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[DefaultValue(false)]
		[Browsable(false)]
		public int Height
		{
			get
			{
				int height;
				int num = SafeNativeMethods.Gdip.GdipGetImageHeight(new HandleRef(this, nativeImage), out height);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return height;
			}
		}

		public float HorizontalResolution
		{
			get
			{
				float horzRes;
				int num = SafeNativeMethods.Gdip.GdipGetImageHorizontalResolution(new HandleRef(this, nativeImage), out horzRes);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return horzRes;
			}
		}

		public float VerticalResolution
		{
			get
			{
				float vertRes;
				int num = SafeNativeMethods.Gdip.GdipGetImageVerticalResolution(new HandleRef(this, nativeImage), out vertRes);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return vertRes;
			}
		}

		[Browsable(false)]
		public int Flags
		{
			get
			{
				int flags;
				int num = SafeNativeMethods.Gdip.GdipGetImageFlags(new HandleRef(this, nativeImage), out flags);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return flags;
			}
		}

		public ImageFormat RawFormat
		{
			get
			{
				Guid format = default(Guid);
				int num = SafeNativeMethods.Gdip.GdipGetImageRawFormat(new HandleRef(this, nativeImage), ref format);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return new ImageFormat(format);
			}
		}

		public PixelFormat PixelFormat
		{
			get
			{
				if (SafeNativeMethods.Gdip.GdipGetImagePixelFormat(new HandleRef(this, nativeImage), out var format) != 0)
				{
					return PixelFormat.Undefined;
				}
				return (PixelFormat)format;
			}
		}

		[Browsable(false)]
		public ColorPalette Palette
		{
			get
			{
				return _GetColorPalette();
			}
			set
			{
				_SetColorPalette(value);
			}
		}

		[Browsable(false)]
		public Guid[] FrameDimensionsList
		{
			get
			{
				int num = SafeNativeMethods.Gdip.GdipImageGetFrameDimensionsCount(new HandleRef(this, nativeImage), out var count);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				if (count <= 0)
				{
					return new Guid[0];
				}
				int num2 = Marshal.SizeOf(typeof(Guid));
				IntPtr intPtr = Marshal.AllocHGlobal(checked(num2 * count));
				if (intPtr == IntPtr.Zero)
				{
					throw SafeNativeMethods.Gdip.StatusException(3);
				}
				num = SafeNativeMethods.Gdip.GdipImageGetFrameDimensionsList(new HandleRef(this, nativeImage), intPtr, count);
				if (num != 0)
				{
					Marshal.FreeHGlobal(intPtr);
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				Guid[] array = new Guid[count];
				try
				{
					for (int i = 0; i < count; i++)
					{
						ref Guid reference = ref array[i];
						reference = (Guid)UnsafeNativeMethods.PtrToStructure((IntPtr)((long)intPtr + num2 * i), typeof(Guid));
					}
					return array;
				}
				finally
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
		}

		[Browsable(false)]
		public int[] PropertyIdList
		{
			get
			{
				int num = SafeNativeMethods.Gdip.GdipGetPropertyCount(new HandleRef(this, nativeImage), out var count);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				int[] array = new int[count];
				if (count == 0)
				{
					return array;
				}
				num = SafeNativeMethods.Gdip.GdipGetPropertyIdList(new HandleRef(this, nativeImage), count, array);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return array;
			}
		}

		[Browsable(false)]
		public PropertyItem[] PropertyItems
		{
			get
			{
				int num = SafeNativeMethods.Gdip.GdipGetPropertyCount(new HandleRef(this, nativeImage), out var count);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				num = SafeNativeMethods.Gdip.GdipGetPropertySize(new HandleRef(this, nativeImage), out var totalSize, ref count);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				if (totalSize == 0 || count == 0)
				{
					return new PropertyItem[0];
				}
				IntPtr intPtr = Marshal.AllocHGlobal(totalSize);
				num = SafeNativeMethods.Gdip.GdipGetAllPropertyItems(new HandleRef(this, nativeImage), totalSize, count, intPtr);
				PropertyItem[] array = null;
				try
				{
					if (num != 0)
					{
						throw SafeNativeMethods.Gdip.StatusException(num);
					}
					return PropertyItemInternal.ConvertFromMemory(intPtr, count);
				}
				finally
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
		}

		internal Image()
		{
		}

		internal Image(SerializationInfo info, StreamingContext context)
		{
			SerializationInfoEnumerator enumerator = info.GetEnumerator();
			if (enumerator == null)
			{
				return;
			}
			while (enumerator.MoveNext())
			{
				if (!string.Equals(enumerator.Name, "Data", StringComparison.OrdinalIgnoreCase))
				{
					continue;
				}
				try
				{
					byte[] array = (byte[])enumerator.Value;
					if (array != null)
					{
						InitializeFromStream(new MemoryStream(array));
					}
				}
				catch (ExternalException)
				{
				}
				catch (ArgumentException)
				{
				}
				catch (OutOfMemoryException)
				{
				}
				catch (InvalidOperationException)
				{
				}
				catch (NotImplementedException)
				{
				}
				catch (FileNotFoundException)
				{
				}
			}
		}

		public static Image FromFile(string filename)
		{
			return FromFile(filename, useEmbeddedColorManagement: false);
		}

		public static Image FromFile(string filename, bool useEmbeddedColorManagement)
		{
			if (!File.Exists(filename))
			{
				IntSecurity.DemandReadFileIO(filename);
				throw new FileNotFoundException(filename);
			}
			filename = Path.GetFullPath(filename);
			IntPtr image = IntPtr.Zero;
			int num = ((!useEmbeddedColorManagement) ? SafeNativeMethods.Gdip.GdipLoadImageFromFile(filename, out image) : SafeNativeMethods.Gdip.GdipLoadImageFromFileICM(filename, out image));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			num = SafeNativeMethods.Gdip.GdipImageForceValidation(new HandleRef(null, image));
			if (num != 0)
			{
				SafeNativeMethods.Gdip.GdipDisposeImage(new HandleRef(null, image));
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			Image image2 = CreateImageObject(image);
			EnsureSave(image2, filename, null);
			return image2;
		}

		public static Image FromStream(Stream stream)
		{
			return FromStream(stream, useEmbeddedColorManagement: false);
		}

		public static Image FromStream(Stream stream, bool useEmbeddedColorManagement)
		{
			return FromStream(stream, useEmbeddedColorManagement, validateImageData: true);
		}

		public static Image FromStream(Stream stream, bool useEmbeddedColorManagement, bool validateImageData)
		{
			if (!validateImageData)
			{
				IntSecurity.UnmanagedCode.Demand();
			}
			if (stream == null)
			{
				throw new ArgumentException(SR.GetString("InvalidArgument", "stream", "null"));
			}
			IntPtr image = IntPtr.Zero;
			int num = ((!useEmbeddedColorManagement) ? SafeNativeMethods.Gdip.GdipLoadImageFromStream(new GPStream(stream), out image) : SafeNativeMethods.Gdip.GdipLoadImageFromStreamICM(new GPStream(stream), out image));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			if (validateImageData)
			{
				num = SafeNativeMethods.Gdip.GdipImageForceValidation(new HandleRef(null, image));
				if (num != 0)
				{
					SafeNativeMethods.Gdip.GdipDisposeImage(new HandleRef(null, image));
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			Image image2 = CreateImageObject(image);
			EnsureSave(image2, null, stream);
			return image2;
		}

		private void InitializeFromStream(Stream stream)
		{
			IntPtr image = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipLoadImageFromStream(new GPStream(stream), out image);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			num = SafeNativeMethods.Gdip.GdipImageForceValidation(new HandleRef(null, image));
			if (num != 0)
			{
				SafeNativeMethods.Gdip.GdipDisposeImage(new HandleRef(null, image));
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			nativeImage = image;
			int type = -1;
			num = SafeNativeMethods.Gdip.GdipGetImageType(new HandleRef(this, nativeImage), out type);
			EnsureSave(this, null, stream);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		internal Image(IntPtr nativeImage)
		{
			SetNativeImage(nativeImage);
		}

		public object Clone()
		{
			IntPtr cloneimage = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCloneImage(new HandleRef(this, nativeImage), out cloneimage);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			num = SafeNativeMethods.Gdip.GdipImageForceValidation(new HandleRef(null, cloneimage));
			if (num != 0)
			{
				SafeNativeMethods.Gdip.GdipDisposeImage(new HandleRef(null, cloneimage));
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return CreateImageObject(cloneimage);
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		protected virtual void Dispose(bool disposing)
		{
			if (!(nativeImage != IntPtr.Zero))
			{
				return;
			}
			try
			{
				SafeNativeMethods.Gdip.GdipDisposeImage(new HandleRef(this, nativeImage));
			}
			catch (Exception ex)
			{
				if (ClientUtils.IsSecurityOrCriticalException(ex))
				{
					throw;
				}
			}
			finally
			{
				nativeImage = IntPtr.Zero;
			}
		}

		~Image()
		{
			Dispose(disposing: false);
		}

		internal static void EnsureSave(Image image, string filename, Stream dataStream)
		{
			if (!image.RawFormat.Equals(ImageFormat.Gif))
			{
				return;
			}
			bool flag = false;
			Guid[] frameDimensionsList = image.FrameDimensionsList;
			Guid[] array = frameDimensionsList;
			foreach (Guid guid in array)
			{
				FrameDimension frameDimension = new FrameDimension(guid);
				if (frameDimension.Equals(FrameDimension.Time))
				{
					flag = image.GetFrameCount(FrameDimension.Time) > 1;
					break;
				}
			}
			if (!flag)
			{
				return;
			}
			try
			{
				Stream stream = null;
				long position = 0L;
				if (dataStream != null)
				{
					position = dataStream.Position;
					dataStream.Position = 0L;
				}
				try
				{
					if (dataStream == null)
					{
						stream = (dataStream = File.OpenRead(filename));
					}
					image.rawData = new byte[(int)dataStream.Length];
					dataStream.Read(image.rawData, 0, (int)dataStream.Length);
				}
				finally
				{
					if (stream != null)
					{
						stream.Close();
					}
					else
					{
						dataStream.Position = position;
					}
				}
			}
			catch (UnauthorizedAccessException)
			{
			}
			catch (DirectoryNotFoundException)
			{
			}
			catch (IOException)
			{
			}
			catch (NotSupportedException)
			{
			}
			catch (ObjectDisposedException)
			{
			}
			catch (ArgumentException)
			{
			}
		}

		internal static Image CreateImageObject(IntPtr nativeImage)
		{
			int type = -1;
			int num = SafeNativeMethods.Gdip.GdipGetImageType(new HandleRef(null, nativeImage), out type);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return type switch
			{
				1 => Bitmap.FromGDIplus(nativeImage), 
				2 => Metafile.FromGDIplus(nativeImage), 
				_ => throw new ArgumentException(SR.GetString("InvalidImage")), 
			};
		}

		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
		void ISerializable.GetObjectData(SerializationInfo si, StreamingContext context)
		{
			using MemoryStream memoryStream = new MemoryStream();
			Save(memoryStream);
			si.AddValue("Data", memoryStream.ToArray(), typeof(byte[]));
		}

		public EncoderParameters GetEncoderParameterList(Guid encoder)
		{
			int num = SafeNativeMethods.Gdip.GdipGetEncoderParameterListSize(new HandleRef(this, nativeImage), ref encoder, out var size);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			if (size <= 0)
			{
				return null;
			}
			IntPtr intPtr = Marshal.AllocHGlobal(size);
			num = SafeNativeMethods.Gdip.GdipGetEncoderParameterList(new HandleRef(this, nativeImage), ref encoder, size, intPtr);
			try
			{
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return EncoderParameters.ConvertFromMemory(intPtr);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		public void Save(string filename)
		{
			Save(filename, RawFormat);
		}

		public void Save(string filename, ImageFormat format)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			ImageCodecInfo imageCodecInfo = format.FindEncoder();
			if (imageCodecInfo == null)
			{
				imageCodecInfo = ImageFormat.Png.FindEncoder();
			}
			Save(filename, imageCodecInfo, null);
		}

		public void Save(string filename, ImageCodecInfo encoder, EncoderParameters encoderParams)
		{
			if (filename == null)
			{
				throw new ArgumentNullException("filename");
			}
			if (encoder == null)
			{
				throw new ArgumentNullException("encoder");
			}
			IntSecurity.DemandWriteFileIO(filename);
			IntPtr intPtr = IntPtr.Zero;
			if (encoderParams != null)
			{
				rawData = null;
				intPtr = encoderParams.ConvertToMemory();
			}
			int num = 0;
			try
			{
				Guid classId = encoder.Clsid;
				bool flag = false;
				if (rawData != null)
				{
					ImageCodecInfo imageCodecInfo = RawFormat.FindEncoder();
					if (imageCodecInfo != null && imageCodecInfo.Clsid == classId)
					{
						using FileStream fileStream = File.OpenWrite(filename);
						fileStream.Write(rawData, 0, rawData.Length);
						flag = true;
					}
				}
				if (!flag)
				{
					num = SafeNativeMethods.Gdip.GdipSaveImageToFile(new HandleRef(this, nativeImage), filename, ref classId, new HandleRef(encoderParams, intPtr));
				}
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		internal void Save(MemoryStream stream)
		{
			ImageFormat imageFormat = RawFormat;
			if (imageFormat == ImageFormat.Jpeg)
			{
				imageFormat = ImageFormat.Png;
			}
			ImageCodecInfo imageCodecInfo = imageFormat.FindEncoder();
			if (imageCodecInfo == null)
			{
				imageCodecInfo = ImageFormat.Png.FindEncoder();
			}
			Save(stream, imageCodecInfo, null);
		}

		public void Save(Stream stream, ImageFormat format)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			ImageCodecInfo encoder = format.FindEncoder();
			Save(stream, encoder, null);
		}

		public void Save(Stream stream, ImageCodecInfo encoder, EncoderParameters encoderParams)
		{
			if (stream == null)
			{
				throw new ArgumentNullException("stream");
			}
			if (encoder == null)
			{
				throw new ArgumentNullException("encoder");
			}
			IntPtr intPtr = IntPtr.Zero;
			if (encoderParams != null)
			{
				rawData = null;
				intPtr = encoderParams.ConvertToMemory();
			}
			int num = 0;
			try
			{
				Guid classId = encoder.Clsid;
				bool flag = false;
				if (rawData != null)
				{
					ImageCodecInfo imageCodecInfo = RawFormat.FindEncoder();
					if (imageCodecInfo != null && imageCodecInfo.Clsid == classId)
					{
						stream.Write(rawData, 0, rawData.Length);
						flag = true;
					}
				}
				if (!flag)
				{
					num = SafeNativeMethods.Gdip.GdipSaveImageToStream(new HandleRef(this, nativeImage), new UnsafeNativeMethods.ComStreamFromDataStream(stream), ref classId, new HandleRef(encoderParams, intPtr));
				}
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void SaveAdd(EncoderParameters encoderParams)
		{
			IntPtr intPtr = IntPtr.Zero;
			if (encoderParams != null)
			{
				intPtr = encoderParams.ConvertToMemory();
			}
			rawData = null;
			int num = SafeNativeMethods.Gdip.GdipSaveAdd(new HandleRef(this, nativeImage), new HandleRef(encoderParams, intPtr));
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void SaveAdd(Image image, EncoderParameters encoderParams)
		{
			IntPtr intPtr = IntPtr.Zero;
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			if (encoderParams != null)
			{
				intPtr = encoderParams.ConvertToMemory();
			}
			rawData = null;
			int num = SafeNativeMethods.Gdip.GdipSaveAddImage(new HandleRef(this, nativeImage), new HandleRef(image, image.nativeImage), new HandleRef(encoderParams, intPtr));
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private SizeF _GetPhysicalDimension()
		{
			float width;
			float height;
			int num = SafeNativeMethods.Gdip.GdipGetImageDimension(new HandleRef(this, nativeImage), out width, out height);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new SizeF(width, height);
		}

		public RectangleF GetBounds(ref GraphicsUnit pageUnit)
		{
			GPRECTF gprectf = default(GPRECTF);
			int num = SafeNativeMethods.Gdip.GdipGetImageBounds(new HandleRef(this, nativeImage), ref gprectf, out pageUnit);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return gprectf.ToRectangleF();
		}

		private ColorPalette _GetColorPalette()
		{
			int size = -1;
			int num = SafeNativeMethods.Gdip.GdipGetImagePaletteSize(new HandleRef(this, nativeImage), out size);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			ColorPalette colorPalette = new ColorPalette(size);
			IntPtr intPtr = Marshal.AllocHGlobal(size);
			num = SafeNativeMethods.Gdip.GdipGetImagePalette(new HandleRef(this, nativeImage), intPtr, size);
			try
			{
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				colorPalette.ConvertFromMemory(intPtr);
				return colorPalette;
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		private void _SetColorPalette(ColorPalette palette)
		{
			IntPtr intPtr = palette.ConvertToMemory();
			int num = SafeNativeMethods.Gdip.GdipSetImagePalette(new HandleRef(this, nativeImage), intPtr);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public Image GetThumbnailImage(int thumbWidth, int thumbHeight, GetThumbnailImageAbort callback, IntPtr callbackData)
		{
			IntPtr thumbImage = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipGetImageThumbnail(new HandleRef(this, nativeImage), thumbWidth, thumbHeight, out thumbImage, callback, callbackData);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return CreateImageObject(thumbImage);
		}

		public int GetFrameCount(FrameDimension dimension)
		{
			int[] array = new int[1];
			int[] array2 = array;
			Guid dimensionID = dimension.Guid;
			int num = SafeNativeMethods.Gdip.GdipImageGetFrameCount(new HandleRef(this, nativeImage), ref dimensionID, array2);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return array2[0];
		}

		public int SelectActiveFrame(FrameDimension dimension, int frameIndex)
		{
			int[] array = new int[1];
			int[] array2 = array;
			Guid dimensionID = dimension.Guid;
			int num = SafeNativeMethods.Gdip.GdipImageSelectActiveFrame(new HandleRef(this, nativeImage), ref dimensionID, frameIndex);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return array2[0];
		}

		public void RotateFlip(RotateFlipType rotateFlipType)
		{
			int num = SafeNativeMethods.Gdip.GdipImageRotateFlip(new HandleRef(this, nativeImage), (int)rotateFlipType);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public PropertyItem GetPropertyItem(int propid)
		{
			int num = SafeNativeMethods.Gdip.GdipGetPropertyItemSize(new HandleRef(this, nativeImage), propid, out var size);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			if (size == 0)
			{
				return null;
			}
			IntPtr intPtr = Marshal.AllocHGlobal(size);
			if (intPtr == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			num = SafeNativeMethods.Gdip.GdipGetPropertyItem(new HandleRef(this, nativeImage), propid, size, intPtr);
			try
			{
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return PropertyItemInternal.ConvertFromMemory(intPtr, 1)[0];
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		public void RemovePropertyItem(int propid)
		{
			int num = SafeNativeMethods.Gdip.GdipRemovePropertyItem(new HandleRef(this, nativeImage), propid);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void SetPropertyItem(PropertyItem propitem)
		{
			PropertyItemInternal propertyItemInternal = PropertyItemInternal.ConvertFromPropertyItem(propitem);
			using (propertyItemInternal)
			{
				int num = SafeNativeMethods.Gdip.GdipSetPropertyItem(new HandleRef(this, nativeImage), propertyItemInternal);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		internal void SetNativeImage(IntPtr handle)
		{
			if (handle == IntPtr.Zero)
			{
				throw new ArgumentException(SR.GetString("NativeHandle0"), "handle");
			}
			nativeImage = handle;
		}

		public static Bitmap FromHbitmap(IntPtr hbitmap)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			return FromHbitmap(hbitmap, IntPtr.Zero);
		}

		public static Bitmap FromHbitmap(IntPtr hbitmap, IntPtr hpalette)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			IntPtr bitmap = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateBitmapFromHBITMAP(new HandleRef(null, hbitmap), new HandleRef(null, hpalette), out bitmap);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return Bitmap.FromGDIplus(bitmap);
		}

		public static int GetPixelFormatSize(PixelFormat pixfmt)
		{
			return ((int)pixfmt >> 8) & 0xFF;
		}

		public static bool IsAlphaPixelFormat(PixelFormat pixfmt)
		{
			return (pixfmt & PixelFormat.Alpha) != 0;
		}

		public static bool IsExtendedPixelFormat(PixelFormat pixfmt)
		{
			return (pixfmt & PixelFormat.Extended) != 0;
		}

		public static bool IsCanonicalPixelFormat(PixelFormat pixfmt)
		{
			return (pixfmt & PixelFormat.Canonical) != 0;
		}
	}
	[Serializable]
	[Editor("System.Drawing.Design.BitmapEditor, System.Drawing.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(UITypeEditor))]
	[ComVisible(true)]
	public sealed class Bitmap : Image
	{
		private static Color defaultTransparentColor = Color.LightGray;

		public Bitmap(string filename)
		{
			IntSecurity.DemandReadFileIO(filename);
			filename = Path.GetFullPath(filename);
			IntPtr bitmap = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateBitmapFromFile(filename, out bitmap);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			num = SafeNativeMethods.Gdip.GdipImageForceValidation(new HandleRef(null, bitmap));
			if (num != 0)
			{
				SafeNativeMethods.Gdip.GdipDisposeImage(new HandleRef(null, bitmap));
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(bitmap);
			Image.EnsureSave(this, filename, null);
		}

		public Bitmap(string filename, bool useIcm)
		{
			IntSecurity.DemandReadFileIO(filename);
			filename = Path.GetFullPath(filename);
			IntPtr bitmap = IntPtr.Zero;
			int num = ((!useIcm) ? SafeNativeMethods.Gdip.GdipCreateBitmapFromFile(filename, out bitmap) : SafeNativeMethods.Gdip.GdipCreateBitmapFromFileICM(filename, out bitmap));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			num = SafeNativeMethods.Gdip.GdipImageForceValidation(new HandleRef(null, bitmap));
			if (num != 0)
			{
				SafeNativeMethods.Gdip.GdipDisposeImage(new HandleRef(null, bitmap));
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(bitmap);
			Image.EnsureSave(this, filename, null);
		}

		public Bitmap(Type type, string resource)
		{
			Stream manifestResourceStream = type.Module.Assembly.GetManifestResourceStream(type, resource);
			if (manifestResourceStream == null)
			{
				throw new ArgumentException(SR.GetString("ResourceNotFound", type, resource));
			}
			IntPtr bitmap = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateBitmapFromStream(new GPStream(manifestResourceStream), out bitmap);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			num = SafeNativeMethods.Gdip.GdipImageForceValidation(new HandleRef(null, bitmap));
			if (num != 0)
			{
				SafeNativeMethods.Gdip.GdipDisposeImage(new HandleRef(null, bitmap));
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(bitmap);
			Image.EnsureSave(this, null, manifestResourceStream);
		}

		public Bitmap(Stream stream)
		{
			if (stream == null)
			{
				throw new ArgumentException(SR.GetString("InvalidArgument", "stream", "null"));
			}
			IntPtr bitmap = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateBitmapFromStream(new GPStream(stream), out bitmap);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			num = SafeNativeMethods.Gdip.GdipImageForceValidation(new HandleRef(null, bitmap));
			if (num != 0)
			{
				SafeNativeMethods.Gdip.GdipDisposeImage(new HandleRef(null, bitmap));
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(bitmap);
			Image.EnsureSave(this, null, stream);
		}

		public Bitmap(Stream stream, bool useIcm)
		{
			if (stream == null)
			{
				throw new ArgumentException(SR.GetString("InvalidArgument", "stream", "null"));
			}
			IntPtr bitmap = IntPtr.Zero;
			int num = ((!useIcm) ? SafeNativeMethods.Gdip.GdipCreateBitmapFromStream(new GPStream(stream), out bitmap) : SafeNativeMethods.Gdip.GdipCreateBitmapFromStreamICM(new GPStream(stream), out bitmap));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			num = SafeNativeMethods.Gdip.GdipImageForceValidation(new HandleRef(null, bitmap));
			if (num != 0)
			{
				SafeNativeMethods.Gdip.GdipDisposeImage(new HandleRef(null, bitmap));
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(bitmap);
			Image.EnsureSave(this, null, stream);
		}

		public Bitmap(int width, int height, int stride, PixelFormat format, IntPtr scan0)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			IntPtr bitmap = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateBitmapFromScan0(width, height, stride, (int)format, new HandleRef(null, scan0), out bitmap);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(bitmap);
		}

		public Bitmap(int width, int height, PixelFormat format)
		{
			IntPtr bitmap = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateBitmapFromScan0(width, height, 0, (int)format, NativeMethods.NullHandleRef, out bitmap);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(bitmap);
		}

		public Bitmap(int width, int height)
			: this(width, height, PixelFormat.Format32bppArgb)
		{
		}

		public Bitmap(int width, int height, Graphics g)
		{
			if (g == null)
			{
				throw new ArgumentNullException(SR.GetString("InvalidArgument", "g", "null"));
			}
			IntPtr bitmap = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateBitmapFromGraphics(width, height, new HandleRef(g, g.NativeGraphics), out bitmap);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(bitmap);
		}

		public Bitmap(Image original)
			: this(original, original.Width, original.Height)
		{
		}

		public Bitmap(Image original, int width, int height)
			: this(width, height)
		{
			Graphics graphics = null;
			try
			{
				graphics = Graphics.FromImage(this);
				graphics.Clear(Color.Transparent);
				graphics.DrawImage(original, 0, 0, width, height);
			}
			finally
			{
				graphics?.Dispose();
			}
		}

		private Bitmap(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}

		public static Bitmap FromHicon(IntPtr hicon)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			IntPtr bitmap = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateBitmapFromHICON(new HandleRef(null, hicon), out bitmap);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return FromGDIplus(bitmap);
		}

		public static Bitmap FromResource(IntPtr hinstance, string bitmapName)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			IntPtr intPtr = Marshal.StringToHGlobalUni(bitmapName);
			IntPtr bitmap;
			int num = SafeNativeMethods.Gdip.GdipCreateBitmapFromResource(new HandleRef(null, hinstance), new HandleRef(null, intPtr), out bitmap);
			Marshal.FreeHGlobal(intPtr);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return FromGDIplus(bitmap);
		}

		[EditorBrowsable(EditorBrowsableState.Advanced)]
		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
		public IntPtr GetHbitmap()
		{
			return GetHbitmap(Color.LightGray);
		}

		[EditorBrowsable(EditorBrowsableState.Advanced)]
		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
		public IntPtr GetHbitmap(Color background)
		{
			IntPtr hbitmap = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateHBITMAPFromBitmap(new HandleRef(this, nativeImage), out hbitmap, ColorTranslator.ToWin32(background));
			if (num == 2 && (base.Width >= 32767 || base.Height >= 32767))
			{
				throw new ArgumentException(SR.GetString("GdiplusInvalidSize"));
			}
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return hbitmap;
		}

		[EditorBrowsable(EditorBrowsableState.Advanced)]
		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
		public IntPtr GetHicon()
		{
			IntPtr hicon = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateHICONFromBitmap(new HandleRef(this, nativeImage), out hicon);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return hicon;
		}

		public Bitmap(Image original, Size newSize)
			: this(original, ((object)newSize != null) ? newSize.Width : 0, ((object)newSize != null) ? newSize.Height : 0)
		{
		}

		private Bitmap()
		{
		}

		internal static Bitmap FromGDIplus(IntPtr handle)
		{
			Bitmap bitmap = new Bitmap();
			bitmap.SetNativeImage(handle);
			return bitmap;
		}

		public Bitmap Clone(Rectangle rect, PixelFormat format)
		{
			if (rect.Width == 0 || rect.Height == 0)
			{
				throw new ArgumentException(SR.GetString("GdiplusInvalidRectangle", rect.ToString()));
			}
			IntPtr dstbitmap = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCloneBitmapAreaI(rect.X, rect.Y, rect.Width, rect.Height, (int)format, new HandleRef(this, nativeImage), out dstbitmap);
			if (num != 0 || dstbitmap == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return FromGDIplus(dstbitmap);
		}

		public Bitmap Clone(RectangleF rect, PixelFormat format)
		{
			if (rect.Width == 0f || rect.Height == 0f)
			{
				throw new ArgumentException(SR.GetString("GdiplusInvalidRectangle", rect.ToString()));
			}
			IntPtr dstbitmap = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCloneBitmapArea(rect.X, rect.Y, rect.Width, rect.Height, (int)format, new HandleRef(this, nativeImage), out dstbitmap);
			if (num != 0 || dstbitmap == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return FromGDIplus(dstbitmap);
		}

		public void MakeTransparent()
		{
			Color pixel = defaultTransparentColor;
			if (base.Height > 0 && base.Width > 0)
			{
				pixel = GetPixel(0, base.Size.Height - 1);
			}
			if (pixel.A >= byte.MaxValue)
			{
				MakeTransparent(pixel);
			}
		}

		public void MakeTransparent(Color transparentColor)
		{
			if (base.RawFormat.Guid == ImageFormat.Icon.Guid)
			{
				throw new InvalidOperationException(SR.GetString("CantMakeIconTransparent"));
			}
			Size size = base.Size;
			Bitmap bitmap = null;
			Graphics graphics = null;
			try
			{
				bitmap = new Bitmap(size.Width, size.Height, PixelFormat.Format32bppArgb);
				try
				{
					graphics = Graphics.FromImage(bitmap);
					graphics.Clear(Color.Transparent);
					Rectangle destRect = new Rectangle(0, 0, size.Width, size.Height);
					ImageAttributes imageAttributes = null;
					try
					{
						imageAttributes = new ImageAttributes();
						imageAttributes.SetColorKey(transparentColor, transparentColor);
						graphics.DrawImage(this, destRect, 0, 0, size.Width, size.Height, GraphicsUnit.Pixel, imageAttributes, null, IntPtr.Zero);
					}
					finally
					{
						imageAttributes?.Dispose();
					}
				}
				finally
				{
					graphics?.Dispose();
				}
				IntPtr intPtr = nativeImage;
				nativeImage = bitmap.nativeImage;
				bitmap.nativeImage = intPtr;
			}
			finally
			{
				bitmap?.Dispose();
			}
		}

		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
		public BitmapData LockBits(Rectangle rect, ImageLockMode flags, PixelFormat format)
		{
			BitmapData bitmapData = new BitmapData();
			return LockBits(rect, flags, format, bitmapData);
		}

		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
		public BitmapData LockBits(Rectangle rect, ImageLockMode flags, PixelFormat format, BitmapData bitmapData)
		{
			GPRECT rect2 = new GPRECT(rect);
			int num = SafeNativeMethods.Gdip.GdipBitmapLockBits(new HandleRef(this, nativeImage), ref rect2, flags, format, bitmapData);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return bitmapData;
		}

		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
		public void UnlockBits(BitmapData bitmapdata)
		{
			int num = SafeNativeMethods.Gdip.GdipBitmapUnlockBits(new HandleRef(this, nativeImage), bitmapdata);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public Color GetPixel(int x, int y)
		{
			int argb = 0;
			if (x < 0 || x >= base.Width)
			{
				throw new ArgumentOutOfRangeException("x", SR.GetString("ValidRangeX"));
			}
			if (y < 0 || y >= base.Height)
			{
				throw new ArgumentOutOfRangeException("y", SR.GetString("ValidRangeY"));
			}
			int num = SafeNativeMethods.Gdip.GdipBitmapGetPixel(new HandleRef(this, nativeImage), x, y, out argb);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return Color.FromArgb(argb);
		}

		public void SetPixel(int x, int y, Color color)
		{
			if ((base.PixelFormat & PixelFormat.Indexed) != 0)
			{
				throw new InvalidOperationException(SR.GetString("GdiplusCannotSetPixelFromIndexedPixelFormat"));
			}
			if (x < 0 || x >= base.Width)
			{
				throw new ArgumentOutOfRangeException("x", SR.GetString("ValidRangeX"));
			}
			if (y < 0 || y >= base.Height)
			{
				throw new ArgumentOutOfRangeException("y", SR.GetString("ValidRangeY"));
			}
			int num = SafeNativeMethods.Gdip.GdipBitmapSetPixel(new HandleRef(this, nativeImage), x, y, color.ToArgb());
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void SetResolution(float xDpi, float yDpi)
		{
			int num = SafeNativeMethods.Gdip.GdipBitmapSetResolution(new HandleRef(this, nativeImage), xDpi, yDpi);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}
	}
	public abstract class Brush : MarshalByRefObject, ICloneable, IDisposable
	{
		private IntPtr nativeBrush;

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Browsable(false)]
		internal IntPtr NativeBrush => nativeBrush;

		public abstract object Clone();

		protected internal void SetNativeBrush(IntPtr brush)
		{
			IntSecurity.UnmanagedCode.Demand();
			SetNativeBrushInternal(brush);
		}

		internal void SetNativeBrushInternal(IntPtr brush)
		{
			nativeBrush = brush;
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		protected virtual void Dispose(bool disposing)
		{
			if (!(nativeBrush != IntPtr.Zero))
			{
				return;
			}
			try
			{
				SafeNativeMethods.Gdip.GdipDeleteBrush(new HandleRef(this, nativeBrush));
			}
			catch (Exception ex)
			{
				if (ClientUtils.IsSecurityOrCriticalException(ex))
				{
					throw;
				}
			}
			finally
			{
				nativeBrush = IntPtr.Zero;
			}
		}

		~Brush()
		{
			Dispose(disposing: false);
		}
	}
	public sealed class Brushes
	{
		private static readonly object TransparentKey = new object();

		private static readonly object AliceBlueKey = new object();

		private static readonly object AntiqueWhiteKey = new object();

		private static readonly object AquaKey = new object();

		private static readonly object AquamarineKey = new object();

		private static readonly object AzureKey = new object();

		private static readonly object BeigeKey = new object();

		private static readonly object BisqueKey = new object();

		private static readonly object BlackKey = new object();

		private static readonly object BlanchedAlmondKey = new object();

		private static readonly object BlueKey = new object();

		private static readonly object BlueVioletKey = new object();

		private static readonly object BrownKey = new object();

		private static readonly object BurlyWoodKey = new object();

		private static readonly object CadetBlueKey = new object();

		private static readonly object ChartreuseKey = new object();

		private static readonly object ChocolateKey = new object();

		private static readonly object ChoralKey = new object();

		private static readonly object CornflowerBlueKey = new object();

		private static readonly object CornsilkKey = new object();

		private static readonly object CrimsonKey = new object();

		private static readonly object CyanKey = new object();

		private static readonly object DarkBlueKey = new object();

		private static readonly object DarkCyanKey = new object();

		private static readonly object DarkGoldenrodKey = new object();

		private static readonly object DarkGrayKey = new object();

		private static readonly object DarkGreenKey = new object();

		private static readonly object DarkKhakiKey = new object();

		private static readonly object DarkMagentaKey = new object();

		private static readonly object DarkOliveGreenKey = new object();

		private static readonly object DarkOrangeKey = new object();

		private static readonly object DarkOrchidKey = new object();

		private static readonly object DarkRedKey = new object();

		private static readonly object DarkSalmonKey = new object();

		private static readonly object DarkSeaGreenKey = new object();

		private static readonly object DarkSlateBlueKey = new object();

		private static readonly object DarkSlateGrayKey = new object();

		private static readonly object DarkTurquoiseKey = new object();

		private static readonly object DarkVioletKey = new object();

		private static readonly object DeepPinkKey = new object();

		private static readonly object DeepSkyBlueKey = new object();

		private static readonly object DimGrayKey = new object();

		private static readonly object DodgerBlueKey = new object();

		private static readonly object FirebrickKey = new object();

		private static readonly object FloralWhiteKey = new object();

		private static readonly object ForestGreenKey = new object();

		private static readonly object FuchiaKey = new object();

		private static readonly object GainsboroKey = new object();

		private static readonly object GhostWhiteKey = new object();

		private static readonly object GoldKey = new object();

		private static readonly object GoldenrodKey = new object();

		private static readonly object GrayKey = new object();

		private static readonly object GreenKey = new object();

		private static readonly object GreenYellowKey = new object();

		private static readonly object HoneydewKey = new object();

		private static readonly object HotPinkKey = new object();

		private static readonly object IndianRedKey = new object();

		private static readonly object IndigoKey = new object();

		private static readonly object IvoryKey = new object();

		private static readonly object KhakiKey = new object();

		private static readonly object LavenderKey = new object();

		private static readonly object LavenderBlushKey = new object();

		private static readonly object LawnGreenKey = new object();

		private static readonly object LemonChiffonKey = new object();

		private static readonly object LightBlueKey = new object();

		private static readonly object LightCoralKey = new object();

		private static readonly object LightCyanKey = new object();

		private static readonly object LightGoldenrodYellowKey = new object();

		private static readonly object LightGreenKey = new object();

		private static readonly object LightGrayKey = new object();

		private static readonly object LightPinkKey = new object();

		private static readonly object LightSalmonKey = new object();

		private static readonly object LightSeaGreenKey = new object();

		private static readonly object LightSkyBlueKey = new object();

		private static readonly object LightSlateGrayKey = new object();

		private static readonly object LightSteelBlueKey = new object();

		private static readonly object LightYellowKey = new object();

		private static readonly object LimeKey = new object();

		private static readonly object LimeGreenKey = new object();

		private static readonly object LinenKey = new object();

		private static readonly object MagentaKey = new object();

		private static readonly object MaroonKey = new object();

		private static readonly object MediumAquamarineKey = new object();

		private static readonly object MediumBlueKey = new object();

		private static readonly object MediumOrchidKey = new object();

		private static readonly object MediumPurpleKey = new object();

		private static readonly object MediumSeaGreenKey = new object();

		private static readonly object MediumSlateBlueKey = new object();

		private static readonly object MediumSpringGreenKey = new object();

		private static readonly object MediumTurquoiseKey = new object();

		private static readonly object MediumVioletRedKey = new object();

		private static readonly object MidnightBlueKey = new object();

		private static readonly object MintCreamKey = new object();

		private static readonly object MistyRoseKey = new object();

		private static readonly object MoccasinKey = new object();

		private static readonly object NavajoWhiteKey = new object();

		private static readonly object NavyKey = new object();

		private static readonly object OldLaceKey = new object();

		private static readonly object OliveKey = new object();

		private static readonly object OliveDrabKey = new object();

		private static readonly object OrangeKey = new object();

		private static readonly object OrangeRedKey = new object();

		private static readonly object OrchidKey = new object();

		private static readonly object PaleGoldenrodKey = new object();

		private static readonly object PaleGreenKey = new object();

		private static readonly object PaleTurquoiseKey = new object();

		private static readonly object PaleVioletRedKey = new object();

		private static readonly object PapayaWhipKey = new object();

		private static readonly object PeachPuffKey = new object();

		private static readonly object PeruKey = new object();

		private static readonly object PinkKey = new object();

		private static readonly object PlumKey = new object();

		private static readonly object PowderBlueKey = new object();

		private static readonly object PurpleKey = new object();

		private static readonly object RedKey = new object();

		private static readonly object RosyBrownKey = new object();

		private static readonly object RoyalBlueKey = new object();

		private static readonly object SaddleBrownKey = new object();

		private static readonly object SalmonKey = new object();

		private static readonly object SandyBrownKey = new object();

		private static readonly object SeaGreenKey = new object();

		private static readonly object SeaShellKey = new object();

		private static readonly object SiennaKey = new object();

		private static readonly object SilverKey = new object();

		private static readonly object SkyBlueKey = new object();

		private static readonly object SlateBlueKey = new object();

		private static readonly object SlateGrayKey = new object();

		private static readonly object SnowKey = new object();

		private static readonly object SpringGreenKey = new object();

		private static readonly object SteelBlueKey = new object();

		private static readonly object TanKey = new object();

		private static readonly object TealKey = new object();

		private static readonly object ThistleKey = new object();

		private static readonly object TomatoKey = new object();

		private static readonly object TurquoiseKey = new object();

		private static readonly object VioletKey = new object();

		private static readonly object WheatKey = new object();

		private static readonly object WhiteKey = new object();

		private static readonly object WhiteSmokeKey = new object();

		private static readonly object YellowKey = new object();

		private static readonly object YellowGreenKey = new object();

		public static Brush Transparent
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[TransparentKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Transparent);
					SafeNativeMethods.Gdip.ThreadData[TransparentKey] = brush;
				}
				return brush;
			}
		}

		public static Brush AliceBlue
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[AliceBlueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.AliceBlue);
					SafeNativeMethods.Gdip.ThreadData[AliceBlueKey] = brush;
				}
				return brush;
			}
		}

		public static Brush AntiqueWhite
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[AntiqueWhiteKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.AntiqueWhite);
					SafeNativeMethods.Gdip.ThreadData[AntiqueWhiteKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Aqua
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[AquaKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Aqua);
					SafeNativeMethods.Gdip.ThreadData[AquaKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Aquamarine
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[AquamarineKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Aquamarine);
					SafeNativeMethods.Gdip.ThreadData[AquamarineKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Azure
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[AzureKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Azure);
					SafeNativeMethods.Gdip.ThreadData[AzureKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Beige
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[BeigeKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Beige);
					SafeNativeMethods.Gdip.ThreadData[BeigeKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Bisque
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[BisqueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Bisque);
					SafeNativeMethods.Gdip.ThreadData[BisqueKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Black
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[BlackKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Black);
					SafeNativeMethods.Gdip.ThreadData[BlackKey] = brush;
				}
				return brush;
			}
		}

		public static Brush BlanchedAlmond
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[BlanchedAlmondKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.BlanchedAlmond);
					SafeNativeMethods.Gdip.ThreadData[BlanchedAlmondKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Blue
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[BlueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Blue);
					SafeNativeMethods.Gdip.ThreadData[BlueKey] = brush;
				}
				return brush;
			}
		}

		public static Brush BlueViolet
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[BlueVioletKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.BlueViolet);
					SafeNativeMethods.Gdip.ThreadData[BlueVioletKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Brown
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[BrownKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Brown);
					SafeNativeMethods.Gdip.ThreadData[BrownKey] = brush;
				}
				return brush;
			}
		}

		public static Brush BurlyWood
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[BurlyWoodKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.BurlyWood);
					SafeNativeMethods.Gdip.ThreadData[BurlyWoodKey] = brush;
				}
				return brush;
			}
		}

		public static Brush CadetBlue
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[CadetBlueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.CadetBlue);
					SafeNativeMethods.Gdip.ThreadData[CadetBlueKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Chartreuse
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[ChartreuseKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Chartreuse);
					SafeNativeMethods.Gdip.ThreadData[ChartreuseKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Chocolate
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[ChocolateKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Chocolate);
					SafeNativeMethods.Gdip.ThreadData[ChocolateKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Coral
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[ChoralKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Coral);
					SafeNativeMethods.Gdip.ThreadData[ChoralKey] = brush;
				}
				return brush;
			}
		}

		public static Brush CornflowerBlue
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[CornflowerBlueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.CornflowerBlue);
					SafeNativeMethods.Gdip.ThreadData[CornflowerBlueKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Cornsilk
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[CornsilkKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Cornsilk);
					SafeNativeMethods.Gdip.ThreadData[CornsilkKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Crimson
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[CrimsonKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Crimson);
					SafeNativeMethods.Gdip.ThreadData[CrimsonKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Cyan
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[CyanKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Cyan);
					SafeNativeMethods.Gdip.ThreadData[CyanKey] = brush;
				}
				return brush;
			}
		}

		public static Brush DarkBlue
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DarkBlueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DarkBlue);
					SafeNativeMethods.Gdip.ThreadData[DarkBlueKey] = brush;
				}
				return brush;
			}
		}

		public static Brush DarkCyan
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DarkCyanKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DarkCyan);
					SafeNativeMethods.Gdip.ThreadData[DarkCyanKey] = brush;
				}
				return brush;
			}
		}

		public static Brush DarkGoldenrod
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DarkGoldenrodKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DarkGoldenrod);
					SafeNativeMethods.Gdip.ThreadData[DarkGoldenrodKey] = brush;
				}
				return brush;
			}
		}

		public static Brush DarkGray
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DarkGrayKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DarkGray);
					SafeNativeMethods.Gdip.ThreadData[DarkGrayKey] = brush;
				}
				return brush;
			}
		}

		public static Brush DarkGreen
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DarkGreenKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DarkGreen);
					SafeNativeMethods.Gdip.ThreadData[DarkGreenKey] = brush;
				}
				return brush;
			}
		}

		public static Brush DarkKhaki
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DarkKhakiKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DarkKhaki);
					SafeNativeMethods.Gdip.ThreadData[DarkKhakiKey] = brush;
				}
				return brush;
			}
		}

		public static Brush DarkMagenta
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DarkMagentaKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DarkMagenta);
					SafeNativeMethods.Gdip.ThreadData[DarkMagentaKey] = brush;
				}
				return brush;
			}
		}

		public static Brush DarkOliveGreen
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DarkOliveGreenKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DarkOliveGreen);
					SafeNativeMethods.Gdip.ThreadData[DarkOliveGreenKey] = brush;
				}
				return brush;
			}
		}

		public static Brush DarkOrange
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DarkOrangeKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DarkOrange);
					SafeNativeMethods.Gdip.ThreadData[DarkOrangeKey] = brush;
				}
				return brush;
			}
		}

		public static Brush DarkOrchid
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DarkOrchidKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DarkOrchid);
					SafeNativeMethods.Gdip.ThreadData[DarkOrchidKey] = brush;
				}
				return brush;
			}
		}

		public static Brush DarkRed
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DarkRedKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DarkRed);
					SafeNativeMethods.Gdip.ThreadData[DarkRedKey] = brush;
				}
				return brush;
			}
		}

		public static Brush DarkSalmon
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DarkSalmonKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DarkSalmon);
					SafeNativeMethods.Gdip.ThreadData[DarkSalmonKey] = brush;
				}
				return brush;
			}
		}

		public static Brush DarkSeaGreen
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DarkSeaGreenKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DarkSeaGreen);
					SafeNativeMethods.Gdip.ThreadData[DarkSeaGreenKey] = brush;
				}
				return brush;
			}
		}

		public static Brush DarkSlateBlue
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DarkSlateBlueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DarkSlateBlue);
					SafeNativeMethods.Gdip.ThreadData[DarkSlateBlueKey] = brush;
				}
				return brush;
			}
		}

		public static Brush DarkSlateGray
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DarkSlateGrayKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DarkSlateGray);
					SafeNativeMethods.Gdip.ThreadData[DarkSlateGrayKey] = brush;
				}
				return brush;
			}
		}

		public static Brush DarkTurquoise
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DarkTurquoiseKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DarkTurquoise);
					SafeNativeMethods.Gdip.ThreadData[DarkTurquoiseKey] = brush;
				}
				return brush;
			}
		}

		public static Brush DarkViolet
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DarkVioletKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DarkViolet);
					SafeNativeMethods.Gdip.ThreadData[DarkVioletKey] = brush;
				}
				return brush;
			}
		}

		public static Brush DeepPink
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DeepPinkKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DeepPink);
					SafeNativeMethods.Gdip.ThreadData[DeepPinkKey] = brush;
				}
				return brush;
			}
		}

		public static Brush DeepSkyBlue
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DeepSkyBlueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DeepSkyBlue);
					SafeNativeMethods.Gdip.ThreadData[DeepSkyBlueKey] = brush;
				}
				return brush;
			}
		}

		public static Brush DimGray
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DimGrayKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DimGray);
					SafeNativeMethods.Gdip.ThreadData[DimGrayKey] = brush;
				}
				return brush;
			}
		}

		public static Brush DodgerBlue
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DodgerBlueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DodgerBlue);
					SafeNativeMethods.Gdip.ThreadData[DodgerBlueKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Firebrick
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[FirebrickKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Firebrick);
					SafeNativeMethods.Gdip.ThreadData[FirebrickKey] = brush;
				}
				return brush;
			}
		}

		public static Brush FloralWhite
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[FloralWhiteKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.FloralWhite);
					SafeNativeMethods.Gdip.ThreadData[FloralWhiteKey] = brush;
				}
				return brush;
			}
		}

		public static Brush ForestGreen
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[ForestGreenKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.ForestGreen);
					SafeNativeMethods.Gdip.ThreadData[ForestGreenKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Fuchsia
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[FuchiaKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Fuchsia);
					SafeNativeMethods.Gdip.ThreadData[FuchiaKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Gainsboro
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[GainsboroKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Gainsboro);
					SafeNativeMethods.Gdip.ThreadData[GainsboroKey] = brush;
				}
				return brush;
			}
		}

		public static Brush GhostWhite
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[GhostWhiteKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.GhostWhite);
					SafeNativeMethods.Gdip.ThreadData[GhostWhiteKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Gold
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[GoldKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Gold);
					SafeNativeMethods.Gdip.ThreadData[GoldKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Goldenrod
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[GoldenrodKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Goldenrod);
					SafeNativeMethods.Gdip.ThreadData[GoldenrodKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Gray
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[GrayKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Gray);
					SafeNativeMethods.Gdip.ThreadData[GrayKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Green
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[GreenKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Green);
					SafeNativeMethods.Gdip.ThreadData[GreenKey] = brush;
				}
				return brush;
			}
		}

		public static Brush GreenYellow
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[GreenYellowKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.GreenYellow);
					SafeNativeMethods.Gdip.ThreadData[GreenYellowKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Honeydew
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[HoneydewKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Honeydew);
					SafeNativeMethods.Gdip.ThreadData[HoneydewKey] = brush;
				}
				return brush;
			}
		}

		public static Brush HotPink
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[HotPinkKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.HotPink);
					SafeNativeMethods.Gdip.ThreadData[HotPinkKey] = brush;
				}
				return brush;
			}
		}

		public static Brush IndianRed
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[IndianRedKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.IndianRed);
					SafeNativeMethods.Gdip.ThreadData[IndianRedKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Indigo
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[IndigoKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Indigo);
					SafeNativeMethods.Gdip.ThreadData[IndigoKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Ivory
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[IvoryKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Ivory);
					SafeNativeMethods.Gdip.ThreadData[IvoryKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Khaki
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[KhakiKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Khaki);
					SafeNativeMethods.Gdip.ThreadData[KhakiKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Lavender
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LavenderKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Lavender);
					SafeNativeMethods.Gdip.ThreadData[LavenderKey] = brush;
				}
				return brush;
			}
		}

		public static Brush LavenderBlush
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LavenderBlushKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.LavenderBlush);
					SafeNativeMethods.Gdip.ThreadData[LavenderBlushKey] = brush;
				}
				return brush;
			}
		}

		public static Brush LawnGreen
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LawnGreenKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.LawnGreen);
					SafeNativeMethods.Gdip.ThreadData[LawnGreenKey] = brush;
				}
				return brush;
			}
		}

		public static Brush LemonChiffon
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LemonChiffonKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.LemonChiffon);
					SafeNativeMethods.Gdip.ThreadData[LemonChiffonKey] = brush;
				}
				return brush;
			}
		}

		public static Brush LightBlue
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LightBlueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.LightBlue);
					SafeNativeMethods.Gdip.ThreadData[LightBlueKey] = brush;
				}
				return brush;
			}
		}

		public static Brush LightCoral
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LightCoralKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.LightCoral);
					SafeNativeMethods.Gdip.ThreadData[LightCoralKey] = brush;
				}
				return brush;
			}
		}

		public static Brush LightCyan
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LightCyanKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.LightCyan);
					SafeNativeMethods.Gdip.ThreadData[LightCyanKey] = brush;
				}
				return brush;
			}
		}

		public static Brush LightGoldenrodYellow
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LightGoldenrodYellowKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.LightGoldenrodYellow);
					SafeNativeMethods.Gdip.ThreadData[LightGoldenrodYellowKey] = brush;
				}
				return brush;
			}
		}

		public static Brush LightGreen
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LightGreenKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.LightGreen);
					SafeNativeMethods.Gdip.ThreadData[LightGreenKey] = brush;
				}
				return brush;
			}
		}

		public static Brush LightGray
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LightGrayKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.LightGray);
					SafeNativeMethods.Gdip.ThreadData[LightGrayKey] = brush;
				}
				return brush;
			}
		}

		public static Brush LightPink
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LightPinkKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.LightPink);
					SafeNativeMethods.Gdip.ThreadData[LightPinkKey] = brush;
				}
				return brush;
			}
		}

		public static Brush LightSalmon
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LightSalmonKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.LightSalmon);
					SafeNativeMethods.Gdip.ThreadData[LightSalmonKey] = brush;
				}
				return brush;
			}
		}

		public static Brush LightSeaGreen
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LightSeaGreenKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.LightSeaGreen);
					SafeNativeMethods.Gdip.ThreadData[LightSeaGreenKey] = brush;
				}
				return brush;
			}
		}

		public static Brush LightSkyBlue
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LightSkyBlueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.LightSkyBlue);
					SafeNativeMethods.Gdip.ThreadData[LightSkyBlueKey] = brush;
				}
				return brush;
			}
		}

		public static Brush LightSlateGray
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LightSlateGrayKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.LightSlateGray);
					SafeNativeMethods.Gdip.ThreadData[LightSlateGrayKey] = brush;
				}
				return brush;
			}
		}

		public static Brush LightSteelBlue
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LightSteelBlueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.LightSteelBlue);
					SafeNativeMethods.Gdip.ThreadData[LightSteelBlueKey] = brush;
				}
				return brush;
			}
		}

		public static Brush LightYellow
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LightYellowKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.LightYellow);
					SafeNativeMethods.Gdip.ThreadData[LightYellowKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Lime
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LimeKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Lime);
					SafeNativeMethods.Gdip.ThreadData[LimeKey] = brush;
				}
				return brush;
			}
		}

		public static Brush LimeGreen
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LimeGreenKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.LimeGreen);
					SafeNativeMethods.Gdip.ThreadData[LimeGreenKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Linen
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LinenKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Linen);
					SafeNativeMethods.Gdip.ThreadData[LinenKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Magenta
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[MagentaKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Magenta);
					SafeNativeMethods.Gdip.ThreadData[MagentaKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Maroon
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[MaroonKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Maroon);
					SafeNativeMethods.Gdip.ThreadData[MaroonKey] = brush;
				}
				return brush;
			}
		}

		public static Brush MediumAquamarine
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[MediumAquamarineKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.MediumAquamarine);
					SafeNativeMethods.Gdip.ThreadData[MediumAquamarineKey] = brush;
				}
				return brush;
			}
		}

		public static Brush MediumBlue
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[MediumBlueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.MediumBlue);
					SafeNativeMethods.Gdip.ThreadData[MediumBlueKey] = brush;
				}
				return brush;
			}
		}

		public static Brush MediumOrchid
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[MediumOrchidKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.MediumOrchid);
					SafeNativeMethods.Gdip.ThreadData[MediumOrchidKey] = brush;
				}
				return brush;
			}
		}

		public static Brush MediumPurple
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[MediumPurpleKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.MediumPurple);
					SafeNativeMethods.Gdip.ThreadData[MediumPurpleKey] = brush;
				}
				return brush;
			}
		}

		public static Brush MediumSeaGreen
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[MediumSeaGreenKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.MediumSeaGreen);
					SafeNativeMethods.Gdip.ThreadData[MediumSeaGreenKey] = brush;
				}
				return brush;
			}
		}

		public static Brush MediumSlateBlue
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[MediumSlateBlueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.MediumSlateBlue);
					SafeNativeMethods.Gdip.ThreadData[MediumSlateBlueKey] = brush;
				}
				return brush;
			}
		}

		public static Brush MediumSpringGreen
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[MediumSpringGreenKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.MediumSpringGreen);
					SafeNativeMethods.Gdip.ThreadData[MediumSpringGreenKey] = brush;
				}
				return brush;
			}
		}

		public static Brush MediumTurquoise
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[MediumTurquoiseKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.MediumTurquoise);
					SafeNativeMethods.Gdip.ThreadData[MediumTurquoiseKey] = brush;
				}
				return brush;
			}
		}

		public static Brush MediumVioletRed
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[MediumVioletRedKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.MediumVioletRed);
					SafeNativeMethods.Gdip.ThreadData[MediumVioletRedKey] = brush;
				}
				return brush;
			}
		}

		public static Brush MidnightBlue
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[MidnightBlueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.MidnightBlue);
					SafeNativeMethods.Gdip.ThreadData[MidnightBlueKey] = brush;
				}
				return brush;
			}
		}

		public static Brush MintCream
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[MintCreamKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.MintCream);
					SafeNativeMethods.Gdip.ThreadData[MintCreamKey] = brush;
				}
				return brush;
			}
		}

		public static Brush MistyRose
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[MistyRoseKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.MistyRose);
					SafeNativeMethods.Gdip.ThreadData[MistyRoseKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Moccasin
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[MoccasinKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Moccasin);
					SafeNativeMethods.Gdip.ThreadData[MoccasinKey] = brush;
				}
				return brush;
			}
		}

		public static Brush NavajoWhite
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[NavajoWhiteKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.NavajoWhite);
					SafeNativeMethods.Gdip.ThreadData[NavajoWhiteKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Navy
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[NavyKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Navy);
					SafeNativeMethods.Gdip.ThreadData[NavyKey] = brush;
				}
				return brush;
			}
		}

		public static Brush OldLace
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[OldLaceKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.OldLace);
					SafeNativeMethods.Gdip.ThreadData[OldLaceKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Olive
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[OliveKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Olive);
					SafeNativeMethods.Gdip.ThreadData[OliveKey] = brush;
				}
				return brush;
			}
		}

		public static Brush OliveDrab
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[OliveDrabKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.OliveDrab);
					SafeNativeMethods.Gdip.ThreadData[OliveDrabKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Orange
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[OrangeKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Orange);
					SafeNativeMethods.Gdip.ThreadData[OrangeKey] = brush;
				}
				return brush;
			}
		}

		public static Brush OrangeRed
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[OrangeRedKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.OrangeRed);
					SafeNativeMethods.Gdip.ThreadData[OrangeRedKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Orchid
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[OrchidKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Orchid);
					SafeNativeMethods.Gdip.ThreadData[OrchidKey] = brush;
				}
				return brush;
			}
		}

		public static Brush PaleGoldenrod
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[PaleGoldenrodKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.PaleGoldenrod);
					SafeNativeMethods.Gdip.ThreadData[PaleGoldenrodKey] = brush;
				}
				return brush;
			}
		}

		public static Brush PaleGreen
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[PaleGreenKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.PaleGreen);
					SafeNativeMethods.Gdip.ThreadData[PaleGreenKey] = brush;
				}
				return brush;
			}
		}

		public static Brush PaleTurquoise
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[PaleTurquoiseKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.PaleTurquoise);
					SafeNativeMethods.Gdip.ThreadData[PaleTurquoiseKey] = brush;
				}
				return brush;
			}
		}

		public static Brush PaleVioletRed
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[PaleVioletRedKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.PaleVioletRed);
					SafeNativeMethods.Gdip.ThreadData[PaleVioletRedKey] = brush;
				}
				return brush;
			}
		}

		public static Brush PapayaWhip
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[PapayaWhipKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.PapayaWhip);
					SafeNativeMethods.Gdip.ThreadData[PapayaWhipKey] = brush;
				}
				return brush;
			}
		}

		public static Brush PeachPuff
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[PeachPuffKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.PeachPuff);
					SafeNativeMethods.Gdip.ThreadData[PeachPuffKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Peru
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[PeruKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Peru);
					SafeNativeMethods.Gdip.ThreadData[PeruKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Pink
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[PinkKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Pink);
					SafeNativeMethods.Gdip.ThreadData[PinkKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Plum
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[PlumKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Plum);
					SafeNativeMethods.Gdip.ThreadData[PlumKey] = brush;
				}
				return brush;
			}
		}

		public static Brush PowderBlue
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[PowderBlueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.PowderBlue);
					SafeNativeMethods.Gdip.ThreadData[PowderBlueKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Purple
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[PurpleKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Purple);
					SafeNativeMethods.Gdip.ThreadData[PurpleKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Red
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[RedKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Red);
					SafeNativeMethods.Gdip.ThreadData[RedKey] = brush;
				}
				return brush;
			}
		}

		public static Brush RosyBrown
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[RosyBrownKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.RosyBrown);
					SafeNativeMethods.Gdip.ThreadData[RosyBrownKey] = brush;
				}
				return brush;
			}
		}

		public static Brush RoyalBlue
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[RoyalBlueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.RoyalBlue);
					SafeNativeMethods.Gdip.ThreadData[RoyalBlueKey] = brush;
				}
				return brush;
			}
		}

		public static Brush SaddleBrown
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[SaddleBrownKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.SaddleBrown);
					SafeNativeMethods.Gdip.ThreadData[SaddleBrownKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Salmon
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[SalmonKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Salmon);
					SafeNativeMethods.Gdip.ThreadData[SalmonKey] = brush;
				}
				return brush;
			}
		}

		public static Brush SandyBrown
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[SandyBrownKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.SandyBrown);
					SafeNativeMethods.Gdip.ThreadData[SandyBrownKey] = brush;
				}
				return brush;
			}
		}

		public static Brush SeaGreen
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[SeaGreenKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.SeaGreen);
					SafeNativeMethods.Gdip.ThreadData[SeaGreenKey] = brush;
				}
				return brush;
			}
		}

		public static Brush SeaShell
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[SeaShellKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.SeaShell);
					SafeNativeMethods.Gdip.ThreadData[SeaShellKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Sienna
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[SiennaKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Sienna);
					SafeNativeMethods.Gdip.ThreadData[SiennaKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Silver
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[SilverKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Silver);
					SafeNativeMethods.Gdip.ThreadData[SilverKey] = brush;
				}
				return brush;
			}
		}

		public static Brush SkyBlue
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[SkyBlueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.SkyBlue);
					SafeNativeMethods.Gdip.ThreadData[SkyBlueKey] = brush;
				}
				return brush;
			}
		}

		public static Brush SlateBlue
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[SlateBlueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.SlateBlue);
					SafeNativeMethods.Gdip.ThreadData[SlateBlueKey] = brush;
				}
				return brush;
			}
		}

		public static Brush SlateGray
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[SlateGrayKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.SlateGray);
					SafeNativeMethods.Gdip.ThreadData[SlateGrayKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Snow
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[SnowKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Snow);
					SafeNativeMethods.Gdip.ThreadData[SnowKey] = brush;
				}
				return brush;
			}
		}

		public static Brush SpringGreen
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[SpringGreenKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.SpringGreen);
					SafeNativeMethods.Gdip.ThreadData[SpringGreenKey] = brush;
				}
				return brush;
			}
		}

		public static Brush SteelBlue
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[SteelBlueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.SteelBlue);
					SafeNativeMethods.Gdip.ThreadData[SteelBlueKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Tan
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[TanKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Tan);
					SafeNativeMethods.Gdip.ThreadData[TanKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Teal
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[TealKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Teal);
					SafeNativeMethods.Gdip.ThreadData[TealKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Thistle
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[ThistleKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Thistle);
					SafeNativeMethods.Gdip.ThreadData[ThistleKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Tomato
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[TomatoKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Tomato);
					SafeNativeMethods.Gdip.ThreadData[TomatoKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Turquoise
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[TurquoiseKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Turquoise);
					SafeNativeMethods.Gdip.ThreadData[TurquoiseKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Violet
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[VioletKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Violet);
					SafeNativeMethods.Gdip.ThreadData[VioletKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Wheat
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[WheatKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Wheat);
					SafeNativeMethods.Gdip.ThreadData[WheatKey] = brush;
				}
				return brush;
			}
		}

		public static Brush White
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[WhiteKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.White);
					SafeNativeMethods.Gdip.ThreadData[WhiteKey] = brush;
				}
				return brush;
			}
		}

		public static Brush WhiteSmoke
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[WhiteSmokeKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.WhiteSmoke);
					SafeNativeMethods.Gdip.ThreadData[WhiteSmokeKey] = brush;
				}
				return brush;
			}
		}

		public static Brush Yellow
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[YellowKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Yellow);
					SafeNativeMethods.Gdip.ThreadData[YellowKey] = brush;
				}
				return brush;
			}
		}

		public static Brush YellowGreen
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[YellowGreenKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.YellowGreen);
					SafeNativeMethods.Gdip.ThreadData[YellowGreenKey] = brush;
				}
				return brush;
			}
		}

		private Brushes()
		{
		}
	}
	public sealed class BufferedGraphics : IDisposable
	{
		private Graphics bufferedGraphicsSurface;

		private Graphics targetGraphics;

		private BufferedGraphicsContext context;

		private IntPtr targetDC;

		private Point targetLoc;

		private Size virtualSize;

		private bool disposeContext;

		private static int rop = 13369376;

		internal bool DisposeContext
		{
			get
			{
				return disposeContext;
			}
			set
			{
				disposeContext = value;
			}
		}

		public Graphics Graphics => bufferedGraphicsSurface;

		internal BufferedGraphics(Graphics bufferedGraphicsSurface, BufferedGraphicsContext context, Graphics targetGraphics, IntPtr targetDC, Point targetLoc, Size virtualSize)
		{
			this.context = context;
			this.bufferedGraphicsSurface = bufferedGraphicsSurface;
			this.targetDC = targetDC;
			this.targetGraphics = targetGraphics;
			this.targetLoc = targetLoc;
			this.virtualSize = virtualSize;
		}

		~BufferedGraphics()
		{
			Dispose(disposing: false);
		}

		public void Dispose()
		{
			Dispose(disposing: true);
		}

		private void Dispose(bool disposing)
		{
			if (!disposing)
			{
				return;
			}
			if (context != null)
			{
				context.ReleaseBuffer(this);
				if (DisposeContext)
				{
					context.Dispose();
					context = null;
				}
			}
			if (bufferedGraphicsSurface != null)
			{
				bufferedGraphicsSurface.Dispose();
				bufferedGraphicsSurface = null;
			}
		}

		public void Render()
		{
			if (targetGraphics != null)
			{
				Render(targetGraphics);
			}
			else
			{
				RenderInternal(new HandleRef(Graphics, targetDC), this);
			}
		}

		public void Render(Graphics target)
		{
			if (target != null)
			{
				IntPtr hdc = target.GetHdc();
				try
				{
					RenderInternal(new HandleRef(target, hdc), this);
				}
				finally
				{
					target.ReleaseHdcInternal(hdc);
				}
			}
		}

		public void Render(IntPtr targetDC)
		{
			IntSecurity.UnmanagedCode.Demand();
			RenderInternal(new HandleRef(null, targetDC), this);
		}

		private void RenderInternal(HandleRef refTargetDC, BufferedGraphics buffer)
		{
			IntPtr hdc = buffer.Graphics.GetHdc();
			try
			{
				SafeNativeMethods.BitBlt(refTargetDC, targetLoc.X, targetLoc.Y, virtualSize.Width, virtualSize.Height, new HandleRef(buffer.Graphics, hdc), 0, 0, rop);
			}
			finally
			{
				buffer.Graphics.ReleaseHdcInternal(hdc);
			}
		}
	}
	public sealed class BufferedGraphicsContext : IDisposable
	{
		private const int BUFFER_FREE = 0;

		private const int BUFFER_BUSY_PAINTING = 1;

		private const int BUFFER_BUSY_DISPOSING = 2;

		private Size maximumBuffer;

		private Size bufferSize;

		private Size virtualSize;

		private Point targetLoc;

		private IntPtr compatDC;

		private IntPtr dib;

		private IntPtr oldBitmap;

		private Graphics compatGraphics;

		private BufferedGraphics buffer;

		private int busy;

		private bool invalidateWhenFree;

		private static TraceSwitch doubleBuffering;

		internal static TraceSwitch DoubleBuffering
		{
			get
			{
				if (doubleBuffering == null)
				{
					doubleBuffering = new TraceSwitch("DoubleBuffering", "Output information about double buffering");
				}
				return doubleBuffering;
			}
		}

		public Size MaximumBuffer
		{
			get
			{
				return maximumBuffer;
			}
			[UIPermission(SecurityAction.Demand, Window = UIPermissionWindow.AllWindows)]
			set
			{
				if (value.Width <= 0 || value.Height <= 0)
				{
					throw new ArgumentException(SR.GetString("InvalidArgument", "MaximumBuffer", value));
				}
				if (value.Width * value.Height < maximumBuffer.Width * maximumBuffer.Height)
				{
					Invalidate();
				}
				maximumBuffer = value;
			}
		}

		public BufferedGraphicsContext()
		{
			maximumBuffer.Width = 225;
			maximumBuffer.Height = 96;
			bufferSize = Size.Empty;
		}

		~BufferedGraphicsContext()
		{
			Dispose(disposing: false);
		}

		public BufferedGraphics Allocate(Graphics targetGraphics, Rectangle targetRectangle)
		{
			if (ShouldUseTempManager(targetRectangle))
			{
				return AllocBufferInTempManager(targetGraphics, IntPtr.Zero, targetRectangle);
			}
			return AllocBuffer(targetGraphics, IntPtr.Zero, targetRectangle);
		}

		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
		public BufferedGraphics Allocate(IntPtr targetDC, Rectangle targetRectangle)
		{
			if (ShouldUseTempManager(targetRectangle))
			{
				return AllocBufferInTempManager(null, targetDC, targetRectangle);
			}
			return AllocBuffer(null, targetDC, targetRectangle);
		}

		private BufferedGraphics AllocBuffer(Graphics targetGraphics, IntPtr targetDC, Rectangle targetRectangle)
		{
			if (Interlocked.CompareExchange(ref busy, 1, 0) != 0)
			{
				return AllocBufferInTempManager(targetGraphics, targetDC, targetRectangle);
			}
			targetLoc = new Point(targetRectangle.X, targetRectangle.Y);
			try
			{
				Graphics bufferedGraphicsSurface;
				if (targetGraphics != null)
				{
					IntPtr hdc = targetGraphics.GetHdc();
					try
					{
						bufferedGraphicsSurface = CreateBuffer(hdc, -targetLoc.X, -targetLoc.Y, targetRectangle.Width, targetRectangle.Height);
					}
					finally
					{
						targetGraphics.ReleaseHdcInternal(hdc);
					}
				}
				else
				{
					bufferedGraphicsSurface = CreateBuffer(targetDC, -targetLoc.X, -targetLoc.Y, targetRectangle.Width, targetRectangle.Height);
				}
				buffer = new BufferedGraphics(bufferedGraphicsSurface, this, targetGraphics, targetDC, targetLoc, virtualSize);
			}
			catch
			{
				busy = 0;
				throw;
			}
			return buffer;
		}

		private BufferedGraphics AllocBufferInTempManager(Graphics targetGraphics, IntPtr targetDC, Rectangle targetRectangle)
		{
			BufferedGraphicsContext bufferedGraphicsContext = null;
			BufferedGraphics bufferedGraphics = null;
			try
			{
				bufferedGraphicsContext = new BufferedGraphicsContext();
				if (bufferedGraphicsContext != null)
				{
					bufferedGraphics = bufferedGraphicsContext.AllocBuffer(targetGraphics, targetDC, targetRectangle);
					bufferedGraphics.DisposeContext = true;
				}
			}
			finally
			{
				if (bufferedGraphicsContext != null && (bufferedGraphics == null || (bufferedGraphics != null && !bufferedGraphics.DisposeContext)))
				{
					bufferedGraphicsContext.Dispose();
				}
			}
			return bufferedGraphics;
		}

		private bool bFillBitmapInfo(IntPtr hdc, IntPtr hpal, ref NativeMethods.BITMAPINFO_FLAT pbmi)
		{
			IntPtr intPtr = IntPtr.Zero;
			bool flag = false;
			try
			{
				intPtr = SafeNativeMethods.CreateCompatibleBitmap(new HandleRef(null, hdc), 1, 1);
				if (intPtr == IntPtr.Zero)
				{
					throw new OutOfMemoryException(SR.GetString("GraphicsBufferQueryFail"));
				}
				pbmi.bmiHeader_biSize = Marshal.SizeOf(typeof(NativeMethods.BITMAPINFOHEADER));
				pbmi.bmiColors = new byte[1024];
				SafeNativeMethods.GetDIBits(new HandleRef(null, hdc), new HandleRef(null, intPtr), 0, 0, IntPtr.Zero, ref pbmi, 0);
				if (pbmi.bmiHeader_biBitCount <= 8)
				{
					return bFillColorTable(hdc, hpal, ref pbmi);
				}
				if (pbmi.bmiHeader_biCompression == 3)
				{
					SafeNativeMethods.GetDIBits(new HandleRef(null, hdc), new HandleRef(null, intPtr), 0, pbmi.bmiHeader_biHeight, IntPtr.Zero, ref pbmi, 0);
				}
				return true;
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					SafeNativeMethods.DeleteObject(new HandleRef(null, intPtr));
					intPtr = IntPtr.Zero;
				}
			}
		}

		private unsafe bool bFillColorTable(IntPtr hdc, IntPtr hpal, ref NativeMethods.BITMAPINFO_FLAT pbmi)
		{
			bool result = false;
			byte[] array = new byte[sizeof(NativeMethods.PALETTEENTRY) * 256];
			fixed (byte* ptr = pbmi.bmiColors)
			{
				fixed (byte* ptr3 = array)
				{
					NativeMethods.RGBQUAD* ptr2 = (NativeMethods.RGBQUAD*)ptr;
					NativeMethods.PALETTEENTRY* ptr4 = (NativeMethods.PALETTEENTRY*)ptr3;
					int num = 1 << (int)pbmi.bmiHeader_biBitCount;
					if (num <= 256)
					{
						IntPtr zero = IntPtr.Zero;
						uint paletteEntries;
						if (hpal == IntPtr.Zero)
						{
							zero = Graphics.GetHalftonePalette();
							paletteEntries = SafeNativeMethods.GetPaletteEntries(new HandleRef(null, zero), 0, num, array);
						}
						else
						{
							paletteEntries = SafeNativeMethods.GetPaletteEntries(new HandleRef(null, hpal), 0, num, array);
						}
						if (paletteEntries != 0)
						{
							for (int i = 0; i < num; i++)
							{
								ptr2[i].rgbRed = ptr4[i].peRed;
								ptr2[i].rgbGreen = ptr4[i].peGreen;
								ptr2[i].rgbBlue = ptr4[i].peBlue;
								ptr2[i].rgbReserved = 0;
							}
							result = true;
						}
					}
				}
			}
			return result;
		}

		private Graphics CreateBuffer(IntPtr src, int offsetX, int offsetY, int width, int height)
		{
			busy = 2;
			DisposeDC();
			busy = 1;
			compatDC = UnsafeNativeMethods.CreateCompatibleDC(new HandleRef(null, src));
			if (width > bufferSize.Width || height > bufferSize.Height)
			{
				int num = Math.Max(width, bufferSize.Width);
				int num2 = Math.Max(height, bufferSize.Height);
				busy = 2;
				DisposeBitmap();
				busy = 1;
				IntPtr ppvBits = IntPtr.Zero;
				dib = CreateCompatibleDIB(src, IntPtr.Zero, num, num2, ref ppvBits);
				bufferSize = new Size(num, num2);
			}
			oldBitmap = SafeNativeMethods.SelectObject(new HandleRef(this, compatDC), new HandleRef(this, dib));
			compatGraphics = Graphics.FromHdcInternal(compatDC);
			compatGraphics.TranslateTransform(-targetLoc.X, -targetLoc.Y);
			virtualSize = new Size(width, height);
			return compatGraphics;
		}

		private IntPtr CreateCompatibleDIB(IntPtr hdc, IntPtr hpal, int ulWidth, int ulHeight, ref IntPtr ppvBits)
		{
			if (hdc == IntPtr.Zero)
			{
				throw new ArgumentNullException("hdc");
			}
			IntPtr intPtr = IntPtr.Zero;
			NativeMethods.BITMAPINFO_FLAT pbmi = default(NativeMethods.BITMAPINFO_FLAT);
			switch (UnsafeNativeMethods.GetObjectType(new HandleRef(null, hdc)))
			{
			default:
				throw new ArgumentException(SR.GetString("DCTypeInvalid"));
			case 3:
			case 4:
			case 10:
			case 12:
				if (bFillBitmapInfo(hdc, hpal, ref pbmi))
				{
					pbmi.bmiHeader_biWidth = ulWidth;
					pbmi.bmiHeader_biHeight = ulHeight;
					if (pbmi.bmiHeader_biCompression == 0)
					{
						pbmi.bmiHeader_biSizeImage = 0;
					}
					else if (pbmi.bmiHeader_biBitCount == 16)
					{
						pbmi.bmiHeader_biSizeImage = ulWidth * ulHeight * 2;
					}
					else if (pbmi.bmiHeader_biBitCount == 32)
					{
						pbmi.bmiHeader_biSizeImage = ulWidth * ulHeight * 4;
					}
					else
					{
						pbmi.bmiHeader_biSizeImage = 0;
					}
					pbmi.bmiHeader_biClrUsed = 0;
					pbmi.bmiHeader_biClrImportant = 0;
					intPtr = SafeNativeMethods.CreateDIBSection(new HandleRef(null, hdc), ref pbmi, 0, ref ppvBits, IntPtr.Zero, 0);
					Win32Exception ex = null;
					if (intPtr == IntPtr.Zero)
					{
						ex = new Win32Exception(Marshal.GetLastWin32Error());
					}
					if (ex != null)
					{
						throw ex;
					}
				}
				return intPtr;
			}
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		private void DisposeDC()
		{
			if (oldBitmap != IntPtr.Zero && compatDC != IntPtr.Zero)
			{
				SafeNativeMethods.SelectObject(new HandleRef(this, compatDC), new HandleRef(this, oldBitmap));
				oldBitmap = IntPtr.Zero;
			}
			if (compatDC != IntPtr.Zero)
			{
				UnsafeNativeMethods.DeleteDC(new HandleRef(this, compatDC));
				compatDC = IntPtr.Zero;
			}
		}

		private void DisposeBitmap()
		{
			if (dib != IntPtr.Zero)
			{
				SafeNativeMethods.DeleteObject(new HandleRef(this, dib));
				dib = IntPtr.Zero;
			}
		}

		private void Dispose(bool disposing)
		{
			int num = Interlocked.CompareExchange(ref busy, 2, 0);
			if (disposing)
			{
				if (num == 1)
				{
					throw new InvalidOperationException(SR.GetString("GraphicsBufferCurrentlyBusy"));
				}
				if (compatGraphics != null)
				{
					compatGraphics.Dispose();
					compatGraphics = null;
				}
			}
			DisposeDC();
			DisposeBitmap();
			if (buffer != null)
			{
				buffer.Dispose();
				buffer = null;
			}
			bufferSize = Size.Empty;
			virtualSize = Size.Empty;
			busy = 0;
		}

		public void Invalidate()
		{
			if (Interlocked.CompareExchange(ref busy, 2, 0) == 0)
			{
				Dispose();
				busy = 0;
			}
			else
			{
				invalidateWhenFree = true;
			}
		}

		internal void ReleaseBuffer(BufferedGraphics buffer)
		{
			this.buffer = null;
			if (invalidateWhenFree)
			{
				busy = 2;
				Dispose();
			}
			else
			{
				busy = 2;
				DisposeDC();
			}
			busy = 0;
		}

		private bool ShouldUseTempManager(Rectangle targetBounds)
		{
			return targetBounds.Width * targetBounds.Height > MaximumBuffer.Width * MaximumBuffer.Height;
		}
	}
	public sealed class BufferedGraphicsManager
	{
		private static BufferedGraphicsContext bufferedGraphicsContext;

		public static BufferedGraphicsContext Current => bufferedGraphicsContext;

		private BufferedGraphicsManager()
		{
		}

		static BufferedGraphicsManager()
		{
			AppDomain.CurrentDomain.ProcessExit += OnShutdown;
			AppDomain.CurrentDomain.DomainUnload += OnShutdown;
			bufferedGraphicsContext = new BufferedGraphicsContext();
		}

		[PrePrepareMethod]
		private static void OnShutdown(object sender, EventArgs e)
		{
			Current.Invalidate();
		}
	}
	[Serializable]
	[TypeConverter(typeof(ColorConverter))]
	[DebuggerDisplay("{NameAndARGBValue}")]
	[Editor("System.Drawing.Design.ColorEditor, System.Drawing.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(UITypeEditor))]
	public struct Color
	{
		private const int ARGBAlphaShift = 24;

		private const int ARGBRedShift = 16;

		private const int ARGBGreenShift = 8;

		private const int ARGBBlueShift = 0;

		public static readonly Color Empty = default(Color);

		private static short StateKnownColorValid = 1;

		private static short StateARGBValueValid = 2;

		private static short StateValueMask = StateARGBValueValid;

		private static short StateNameValid = 8;

		private static long NotDefinedValue = 0L;

		private readonly string name;

		private readonly long value;

		private readonly short knownColor;

		private readonly short state;

		public static Color Transparent => new Color(KnownColor.Transparent);

		public static Color AliceBlue => new Color(KnownColor.AliceBlue);

		public static Color AntiqueWhite => new Color(KnownColor.AntiqueWhite);

		public static Color Aqua => new Color(KnownColor.Aqua);

		public static Color Aquamarine => new Color(KnownColor.Aquamarine);

		public static Color Azure => new Color(KnownColor.Azure);

		public static Color Beige => new Color(KnownColor.Beige);

		public static Color Bisque => new Color(KnownColor.Bisque);

		public static Color Black => new Color(KnownColor.Black);

		public static Color BlanchedAlmond => new Color(KnownColor.BlanchedAlmond);

		public static Color Blue => new Color(KnownColor.Blue);

		public static Color BlueViolet => new Color(KnownColor.BlueViolet);

		public static Color Brown => new Color(KnownColor.Brown);

		public static Color BurlyWood => new Color(KnownColor.BurlyWood);

		public static Color CadetBlue => new Color(KnownColor.CadetBlue);

		public static Color Chartreuse => new Color(KnownColor.Chartreuse);

		public static Color Chocolate => new Color(KnownColor.Chocolate);

		public static Color Coral => new Color(KnownColor.Coral);

		public static Color CornflowerBlue => new Color(KnownColor.CornflowerBlue);

		public static Color Cornsilk => new Color(KnownColor.Cornsilk);

		public static Color Crimson => new Color(KnownColor.Crimson);

		public static Color Cyan => new Color(KnownColor.Cyan);

		public static Color DarkBlue => new Color(KnownColor.DarkBlue);

		public static Color DarkCyan => new Color(KnownColor.DarkCyan);

		public static Color DarkGoldenrod => new Color(KnownColor.DarkGoldenrod);

		public static Color DarkGray => new Color(KnownColor.DarkGray);

		public static Color DarkGreen => new Color(KnownColor.DarkGreen);

		public static Color DarkKhaki => new Color(KnownColor.DarkKhaki);

		public static Color DarkMagenta => new Color(KnownColor.DarkMagenta);

		public static Color DarkOliveGreen => new Color(KnownColor.DarkOliveGreen);

		public static Color DarkOrange => new Color(KnownColor.DarkOrange);

		public static Color DarkOrchid => new Color(KnownColor.DarkOrchid);

		public static Color DarkRed => new Color(KnownColor.DarkRed);

		public static Color DarkSalmon => new Color(KnownColor.DarkSalmon);

		public static Color DarkSeaGreen => new Color(KnownColor.DarkSeaGreen);

		public static Color DarkSlateBlue => new Color(KnownColor.DarkSlateBlue);

		public static Color DarkSlateGray => new Color(KnownColor.DarkSlateGray);

		public static Color DarkTurquoise => new Color(KnownColor.DarkTurquoise);

		public static Color DarkViolet => new Color(KnownColor.DarkViolet);

		public static Color DeepPink => new Color(KnownColor.DeepPink);

		public static Color DeepSkyBlue => new Color(KnownColor.DeepSkyBlue);

		public static Color DimGray => new Color(KnownColor.DimGray);

		public static Color DodgerBlue => new Color(KnownColor.DodgerBlue);

		public static Color Firebrick => new Color(KnownColor.Firebrick);

		public static Color FloralWhite => new Color(KnownColor.FloralWhite);

		public static Color ForestGreen => new Color(KnownColor.ForestGreen);

		public static Color Fuchsia => new Color(KnownColor.Fuchsia);

		public static Color Gainsboro => new Color(KnownColor.Gainsboro);

		public static Color GhostWhite => new Color(KnownColor.GhostWhite);

		public static Color Gold => new Color(KnownColor.Gold);

		public static Color Goldenrod => new Color(KnownColor.Goldenrod);

		public static Color Gray => new Color(KnownColor.Gray);

		public static Color Green => new Color(KnownColor.Green);

		public static Color GreenYellow => new Color(KnownColor.GreenYellow);

		public static Color Honeydew => new Color(KnownColor.Honeydew);

		public static Color HotPink => new Color(KnownColor.HotPink);

		public static Color IndianRed => new Color(KnownColor.IndianRed);

		public static Color Indigo => new Color(KnownColor.Indigo);

		public static Color Ivory => new Color(KnownColor.Ivory);

		public static Color Khaki => new Color(KnownColor.Khaki);

		public static Color Lavender => new Color(KnownColor.Lavender);

		public static Color LavenderBlush => new Color(KnownColor.LavenderBlush);

		public static Color LawnGreen => new Color(KnownColor.LawnGreen);

		public static Color LemonChiffon => new Color(KnownColor.LemonChiffon);

		public static Color LightBlue => new Color(KnownColor.LightBlue);

		public static Color LightCoral => new Color(KnownColor.LightCoral);

		public static Color LightCyan => new Color(KnownColor.LightCyan);

		public static Color LightGoldenrodYellow => new Color(KnownColor.LightGoldenrodYellow);

		public static Color LightGreen => new Color(KnownColor.LightGreen);

		public static Color LightGray => new Color(KnownColor.LightGray);

		public static Color LightPink => new Color(KnownColor.LightPink);

		public static Color LightSalmon => new Color(KnownColor.LightSalmon);

		public static Color LightSeaGreen => new Color(KnownColor.LightSeaGreen);

		public static Color LightSkyBlue => new Color(KnownColor.LightSkyBlue);

		public static Color LightSlateGray => new Color(KnownColor.LightSlateGray);

		public static Color LightSteelBlue => new Color(KnownColor.LightSteelBlue);

		public static Color LightYellow => new Color(KnownColor.LightYellow);

		public static Color Lime => new Color(KnownColor.Lime);

		public static Color LimeGreen => new Color(KnownColor.LimeGreen);

		public static Color Linen => new Color(KnownColor.Linen);

		public static Color Magenta => new Color(KnownColor.Magenta);

		public static Color Maroon => new Color(KnownColor.Maroon);

		public static Color MediumAquamarine => new Color(KnownColor.MediumAquamarine);

		public static Color MediumBlue => new Color(KnownColor.MediumBlue);

		public static Color MediumOrchid => new Color(KnownColor.MediumOrchid);

		public static Color MediumPurple => new Color(KnownColor.MediumPurple);

		public static Color MediumSeaGreen => new Color(KnownColor.MediumSeaGreen);

		public static Color MediumSlateBlue => new Color(KnownColor.MediumSlateBlue);

		public static Color MediumSpringGreen => new Color(KnownColor.MediumSpringGreen);

		public static Color MediumTurquoise => new Color(KnownColor.MediumTurquoise);

		public static Color MediumVioletRed => new Color(KnownColor.MediumVioletRed);

		public static Color MidnightBlue => new Color(KnownColor.MidnightBlue);

		public static Color MintCream => new Color(KnownColor.MintCream);

		public static Color MistyRose => new Color(KnownColor.MistyRose);

		public static Color Moccasin => new Color(KnownColor.Moccasin);

		public static Color NavajoWhite => new Color(KnownColor.NavajoWhite);

		public static Color Navy => new Color(KnownColor.Navy);

		public static Color OldLace => new Color(KnownColor.OldLace);

		public static Color Olive => new Color(KnownColor.Olive);

		public static Color OliveDrab => new Color(KnownColor.OliveDrab);

		public static Color Orange => new Color(KnownColor.Orange);

		public static Color OrangeRed => new Color(KnownColor.OrangeRed);

		public static Color Orchid => new Color(KnownColor.Orchid);

		public static Color PaleGoldenrod => new Color(KnownColor.PaleGoldenrod);

		public static Color PaleGreen => new Color(KnownColor.PaleGreen);

		public static Color PaleTurquoise => new Color(KnownColor.PaleTurquoise);

		public static Color PaleVioletRed => new Color(KnownColor.PaleVioletRed);

		public static Color PapayaWhip => new Color(KnownColor.PapayaWhip);

		public static Color PeachPuff => new Color(KnownColor.PeachPuff);

		public static Color Peru => new Color(KnownColor.Peru);

		public static Color Pink => new Color(KnownColor.Pink);

		public static Color Plum => new Color(KnownColor.Plum);

		public static Color PowderBlue => new Color(KnownColor.PowderBlue);

		public static Color Purple => new Color(KnownColor.Purple);

		public static Color Red => new Color(KnownColor.Red);

		public static Color RosyBrown => new Color(KnownColor.RosyBrown);

		public static Color RoyalBlue => new Color(KnownColor.RoyalBlue);

		public static Color SaddleBrown => new Color(KnownColor.SaddleBrown);

		public static Color Salmon => new Color(KnownColor.Salmon);

		public static Color SandyBrown => new Color(KnownColor.SandyBrown);

		public static Color SeaGreen => new Color(KnownColor.SeaGreen);

		public static Color SeaShell => new Color(KnownColor.SeaShell);

		public static Color Sienna => new Color(KnownColor.Sienna);

		public static Color Silver => new Color(KnownColor.Silver);

		public static Color SkyBlue => new Color(KnownColor.SkyBlue);

		public static Color SlateBlue => new Color(KnownColor.SlateBlue);

		public static Color SlateGray => new Color(KnownColor.SlateGray);

		public static Color Snow => new Color(KnownColor.Snow);

		public static Color SpringGreen => new Color(KnownColor.SpringGreen);

		public static Color SteelBlue => new Color(KnownColor.SteelBlue);

		public static Color Tan => new Color(KnownColor.Tan);

		public static Color Teal => new Color(KnownColor.Teal);

		public static Color Thistle => new Color(KnownColor.Thistle);

		public static Color Tomato => new Color(KnownColor.Tomato);

		public static Color Turquoise => new Color(KnownColor.Turquoise);

		public static Color Violet => new Color(KnownColor.Violet);

		public static Color Wheat => new Color(KnownColor.Wheat);

		public static Color White => new Color(KnownColor.White);

		public static Color WhiteSmoke => new Color(KnownColor.WhiteSmoke);

		public static Color Yellow => new Color(KnownColor.Yellow);

		public static Color YellowGreen => new Color(KnownColor.YellowGreen);

		public byte R => (byte)((Value >> 16) & 0xFF);

		public byte G => (byte)((Value >> 8) & 0xFF);

		public byte B => (byte)(Value & 0xFF);

		public byte A => (byte)((Value >> 24) & 0xFF);

		public bool IsKnownColor => (state & StateKnownColorValid) != 0;

		public bool IsEmpty => state == 0;

		public bool IsNamedColor
		{
			get
			{
				if ((state & StateNameValid) == 0)
				{
					return IsKnownColor;
				}
				return true;
			}
		}

		public bool IsSystemColor
		{
			get
			{
				if (IsKnownColor)
				{
					if (knownColor > 26)
					{
						return knownColor > 167;
					}
					return true;
				}
				return false;
			}
		}

		private string NameAndARGBValue => string.Format(CultureInfo.CurrentCulture, "{{Name={0}, ARGB=({1}, {2}, {3}, {4})}}", Name, A, R, G, B);

		public string Name
		{
			get
			{
				if ((state & StateNameValid) != 0)
				{
					return name;
				}
				if (IsKnownColor)
				{
					string text = KnownColorTable.KnownColorToName((KnownColor)knownColor);
					if (text != null)
					{
						return text;
					}
					return ((KnownColor)knownColor).ToString();
				}
				return Convert.ToString(value, 16);
			}
		}

		private long Value
		{
			get
			{
				if ((state & StateValueMask) != 0)
				{
					return value;
				}
				if (IsKnownColor)
				{
					return KnownColorTable.KnownColorToArgb((KnownColor)knownColor);
				}
				return NotDefinedValue;
			}
		}

		internal Color(KnownColor knownColor)
		{
			value = 0L;
			state = StateKnownColorValid;
			name = null;
			this.knownColor = (short)knownColor;
		}

		private Color(long value, short state, string name, KnownColor knownColor)
		{
			this.value = value;
			this.state = state;
			this.name = name;
			this.knownColor = (short)knownColor;
		}

		private static void CheckByte(int value, string name)
		{
			if (value < 0 || value > 255)
			{
				throw new ArgumentException(SR.GetString("InvalidEx2BoundArgument", name, value, 0, 255));
			}
		}

		private static long MakeArgb(byte alpha, byte red, byte green, byte blue)
		{
			return (long)(uint)((red << 16) | (green << 8) | blue | (alpha << 24)) & 0xFFFFFFFFL;
		}

		public static Color FromArgb(int argb)
		{
			return new Color(argb & 0xFFFFFFFFu, StateARGBValueValid, null, (KnownColor)0);
		}

		public static Color FromArgb(int alpha, int red, int green, int blue)
		{
			CheckByte(alpha, "alpha");
			CheckByte(red, "red");
			CheckByte(green, "green");
			CheckByte(blue, "blue");
			return new Color(MakeArgb((byte)alpha, (byte)red, (byte)green, (byte)blue), StateARGBValueValid, null, (KnownColor)0);
		}

		public static Color FromArgb(int alpha, Color baseColor)
		{
			CheckByte(alpha, "alpha");
			return new Color(MakeArgb((byte)alpha, baseColor.R, baseColor.G, baseColor.B), StateARGBValueValid, null, (KnownColor)0);
		}

		public static Color FromArgb(int red, int green, int blue)
		{
			return FromArgb(255, red, green, blue);
		}

		public static Color FromKnownColor(KnownColor color)
		{
			if (!ClientUtils.IsEnumValid(color, (int)color, 1, 174))
			{
				return FromName(color.ToString());
			}
			return new Color(color);
		}

		public static Color FromName(string name)
		{
			object namedColor = ColorConverter.GetNamedColor(name);
			if (namedColor != null)
			{
				return (Color)namedColor;
			}
			return new Color(NotDefinedValue, StateNameValid, name, (KnownColor)0);
		}

		public float GetBrightness()
		{
			float num = (float)(int)R / 255f;
			float num2 = (float)(int)G / 255f;
			float num3 = (float)(int)B / 255f;
			float num4 = num;
			float num5 = num;
			if (num2 > num4)
			{
				num4 = num2;
			}
			if (num3 > num4)
			{
				num4 = num3;
			}
			if (num2 < num5)
			{
				num5 = num2;
			}
			if (num3 < num5)
			{
				num5 = num3;
			}
			return (num4 + num5) / 2f;
		}

		public float GetHue()
		{
			if (R == G && G == B)
			{
				return 0f;
			}
			float num = (float)(int)R / 255f;
			float num2 = (float)(int)G / 255f;
			float num3 = (float)(int)B / 255f;
			float num4 = 0f;
			float num5 = num;
			float num6 = num;
			if (num2 > num5)
			{
				num5 = num2;
			}
			if (num3 > num5)
			{
				num5 = num3;
			}
			if (num2 < num6)
			{
				num6 = num2;
			}
			if (num3 < num6)
			{
				num6 = num3;
			}
			float num7 = num5 - num6;
			if (num == num5)
			{
				num4 = (num2 - num3) / num7;
			}
			else if (num2 == num5)
			{
				num4 = 2f + (num3 - num) / num7;
			}
			else if (num3 == num5)
			{
				num4 = 4f + (num - num2) / num7;
			}
			num4 *= 60f;
			if (num4 < 0f)
			{
				num4 += 360f;
			}
			return num4;
		}

		public float GetSaturation()
		{
			float num = (float)(int)R / 255f;
			float num2 = (float)(int)G / 255f;
			float num3 = (float)(int)B / 255f;
			float result = 0f;
			float num4 = num;
			float num5 = num;
			if (num2 > num4)
			{
				num4 = num2;
			}
			if (num3 > num4)
			{
				num4 = num3;
			}
			if (num2 < num5)
			{
				num5 = num2;
			}
			if (num3 < num5)
			{
				num5 = num3;
			}
			if (num4 != num5)
			{
				float num6 = (num4 + num5) / 2f;
				result = ((!((double)num6 <= 0.5)) ? ((num4 - num5) / (2f - num4 - num5)) : ((num4 - num5) / (num4 + num5)));
			}
			return result;
		}

		public int ToArgb()
		{
			return (int)Value;
		}

		public KnownColor ToKnownColor()
		{
			return (KnownColor)knownColor;
		}

		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder(32);
			stringBuilder.Append(GetType().Name);
			stringBuilder.Append(" [");
			if ((state & StateNameValid) != 0)
			{
				stringBuilder.Append(Name);
			}
			else if ((state & StateKnownColorValid) != 0)
			{
				stringBuilder.Append(Name);
			}
			else if ((state & StateValueMask) != 0)
			{
				stringBuilder.Append("A=");
				stringBuilder.Append(A);
				stringBuilder.Append(", R=");
				stringBuilder.Append(R);
				stringBuilder.Append(", G=");
				stringBuilder.Append(G);
				stringBuilder.Append(", B=");
				stringBuilder.Append(B);
			}
			else
			{
				stringBuilder.Append("Empty");
			}
			stringBuilder.Append("]");
			return stringBuilder.ToString();
		}

		public static bool operator ==(Color left, Color right)
		{
			if (left.value == right.value && left.state == right.state && left.knownColor == right.knownColor)
			{
				if (left.name == right.name)
				{
					return true;
				}
				if (left.name == null || right.name == null)
				{
					return false;
				}
				return left.name.Equals(right.name);
			}
			return false;
		}

		public static bool operator !=(Color left, Color right)
		{
			return !(left == right);
		}

		public override bool Equals(object obj)
		{
			if (obj is Color color && value == color.value && state == color.state && knownColor == color.knownColor)
			{
				if (name == color.name)
				{
					return true;
				}
				if (name == null || color.name == null)
				{
					return false;
				}
				return name.Equals(name);
			}
			return false;
		}

		public override int GetHashCode()
		{
			return value.GetHashCode() ^ state.GetHashCode() ^ knownColor.GetHashCode();
		}
	}
	public class ColorConverter : TypeConverter
	{
		private class ColorComparer : IComparer
		{
			public int Compare(object left, object right)
			{
				Color color = (Color)left;
				return string.Compare(strB: ((Color)right).Name, strA: color.Name, ignoreCase: false, culture: CultureInfo.InvariantCulture);
			}
		}

		private static string ColorConstantsLock = "colorConstants";

		private static Hashtable colorConstants;

		private static string SystemColorConstantsLock = "systemColorConstants";

		private static Hashtable systemColorConstants;

		private static string ValuesLock = "values";

		private static StandardValuesCollection values;

		private static Hashtable Colors
		{
			get
			{
				if (colorConstants == null)
				{
					lock (ColorConstantsLock)
					{
						if (colorConstants == null)
						{
							Hashtable hash = new Hashtable(StringComparer.OrdinalIgnoreCase);
							FillConstants(hash, typeof(Color));
							colorConstants = hash;
						}
					}
				}
				return colorConstants;
			}
		}

		private static Hashtable SystemColors
		{
			get
			{
				if (systemColorConstants == null)
				{
					lock (SystemColorConstantsLock)
					{
						if (systemColorConstants == null)
						{
							Hashtable hash = new Hashtable(StringComparer.OrdinalIgnoreCase);
							FillConstants(hash, typeof(SystemColors));
							systemColorConstants = hash;
						}
					}
				}
				return systemColorConstants;
			}
		}

		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
		{
			if (sourceType == typeof(string))
			{
				return true;
			}
			return base.CanConvertFrom(context, sourceType);
		}

		public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
		{
			if (destinationType == typeof(InstanceDescriptor))
			{
				return true;
			}
			return base.CanConvertTo(context, destinationType);
		}

		internal static object GetNamedColor(string name)
		{
			object obj = null;
			obj = Colors[name];
			if (obj != null)
			{
				return obj;
			}
			return SystemColors[name];
		}

		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
		{
			if (value is string text)
			{
				object obj = null;
				string text2 = text.Trim();
				if (text2.Length == 0)
				{
					obj = Color.Empty;
				}
				else
				{
					obj = GetNamedColor(text2);
					if (obj == null)
					{
						if (culture == null)
						{
							culture = CultureInfo.CurrentCulture;
						}
						char c = culture.TextInfo.ListSeparator[0];
						bool flag = true;
						TypeConverter converter = TypeDescriptor.GetConverter(typeof(int));
						if (text2.IndexOf(c) == -1)
						{
							if (text2.Length >= 2 && (text2[0] == '\'' || text2[0] == '"') && text2[0] == text2[text2.Length - 1])
							{
								string name = text2.Substring(1, text2.Length - 2);
								obj = Color.FromName(name);
								flag = false;
							}
							else if ((text2.Length == 7 && text2[0] == '#') || (text2.Length == 8 && (text2.StartsWith("0x") || text2.StartsWith("0X"))) || (text2.Length == 8 && (text2.StartsWith("&h") || text2.StartsWith("&H"))))
							{
								obj = Color.FromArgb(-16777216 | (int)converter.ConvertFromString(context, culture, text2));
							}
						}
						if (obj == null)
						{
							string[] array = text2.Split(c);
							int[] array2 = new int[array.Length];
							for (int i = 0; i < array2.Length; i++)
							{
								array2[i] = (int)converter.ConvertFromString(context, culture, array[i]);
							}
							switch (array2.Length)
							{
							case 1:
								obj = Color.FromArgb(array2[0]);
								break;
							case 3:
								obj = Color.FromArgb(array2[0], array2[1], array2[2]);
								break;
							case 4:
								obj = Color.FromArgb(array2[0], array2[1], array2[2], array2[3]);
								break;
							}
							flag = true;
						}
						if (obj != null && flag)
						{
							int num = ((Color)obj).ToArgb();
							foreach (Color value2 in Colors.Values)
							{
								if (value2.ToArgb() == num)
								{
									obj = value2;
									break;
								}
							}
						}
					}
					if (obj == null)
					{
						throw new ArgumentException(SR.GetString("InvalidColor", text2));
					}
				}
				return obj;
			}
			return base.ConvertFrom(context, culture, value);
		}

		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (value is Color)
			{
				if (destinationType == typeof(string))
				{
					Color color = (Color)value;
					if (color == Color.Empty)
					{
						return string.Empty;
					}
					if (color.IsKnownColor)
					{
						return color.Name;
					}
					if (color.IsNamedColor)
					{
						return "'" + color.Name + "'";
					}
					if (culture == null)
					{
						culture = CultureInfo.CurrentCulture;
					}
					string separator = culture.TextInfo.ListSeparator + " ";
					TypeConverter converter = TypeDescriptor.GetConverter(typeof(int));
					int num = 0;
					string[] array;
					if (color.A < byte.MaxValue)
					{
						array = new string[4];
						array[num++] = converter.ConvertToString(context, culture, color.A);
					}
					else
					{
						array = new string[3];
					}
					array[num++] = converter.ConvertToString(context, culture, color.R);
					array[num++] = converter.ConvertToString(context, culture, color.G);
					array[num++] = converter.ConvertToString(context, culture, color.B);
					return string.Join(separator, array);
				}
				if (destinationType == typeof(InstanceDescriptor))
				{
					MemberInfo memberInfo = null;
					object[] arguments = null;
					Color color2 = (Color)value;
					if (color2.IsEmpty)
					{
						memberInfo = typeof(Color).GetField("Empty");
					}
					else if (color2.IsSystemColor)
					{
						memberInfo = typeof(SystemColors).GetProperty(color2.Name);
					}
					else if (color2.IsKnownColor)
					{
						memberInfo = typeof(Color).GetProperty(color2.Name);
					}
					else if (color2.A != byte.MaxValue)
					{
						memberInfo = typeof(Color).GetMethod("FromArgb", new Type[4]
						{
							typeof(int),
							typeof(int),
							typeof(int),
							typeof(int)
						});
						arguments = new object[4] { color2.A, color2.R, color2.G, color2.B };
					}
					else if (color2.IsNamedColor)
					{
						memberInfo = typeof(Color).GetMethod("FromName", new Type[1] { typeof(string) });
						arguments = new object[1] { color2.Name };
					}
					else
					{
						memberInfo = typeof(Color).GetMethod("FromArgb", new Type[3]
						{
							typeof(int),
							typeof(int),
							typeof(int)
						});
						arguments = new object[3] { color2.R, color2.G, color2.B };
					}
					if (memberInfo != null)
					{
						return new InstanceDescriptor(memberInfo, arguments);
					}
					return null;
				}
			}
			return base.ConvertTo(context, culture, value, destinationType);
		}

		private static void FillConstants(Hashtable hash, Type enumType)
		{
			MethodAttributes methodAttributes = MethodAttributes.Public | MethodAttributes.Static;
			PropertyInfo[] properties = enumType.GetProperties();
			foreach (PropertyInfo propertyInfo in properties)
			{
				if (propertyInfo.PropertyType == typeof(Color))
				{
					MethodInfo getMethod = propertyInfo.GetGetMethod();
					if (getMethod != null && (getMethod.Attributes & methodAttributes) == methodAttributes)
					{
						object[] index = null;
						hash[propertyInfo.Name] = propertyInfo.GetValue(null, index);
					}
				}
			}
		}

		public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
		{
			if (values == null)
			{
				lock (ValuesLock)
				{
					if (values == null)
					{
						ArrayList arrayList = new ArrayList();
						arrayList.AddRange(Colors.Values);
						arrayList.AddRange(SystemColors.Values);
						int num = arrayList.Count;
						for (int i = 0; i < num - 1; i++)
						{
							for (int j = i + 1; j < num; j++)
							{
								if (arrayList[i].Equals(arrayList[j]))
								{
									arrayList.RemoveAt(j);
									num--;
									j--;
								}
							}
						}
						arrayList.Sort(0, arrayList.Count, new ColorComparer());
						values = new StandardValuesCollection(arrayList.ToArray());
					}
				}
			}
			return values;
		}

		public override bool GetStandardValuesSupported(ITypeDescriptorContext context)
		{
			return true;
		}
	}
	[Editor("System.Drawing.Design.ContentAlignmentEditor, System.Drawing.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(UITypeEditor))]
	public enum ContentAlignment
	{
		TopLeft = 1,
		TopCenter = 2,
		TopRight = 4,
		MiddleLeft = 0x10,
		MiddleCenter = 0x20,
		MiddleRight = 0x40,
		BottomLeft = 0x100,
		BottomCenter = 0x200,
		BottomRight = 0x400
	}
	[ComVisible(true)]
	public enum CopyPixelOperation
	{
		Blackness = 66,
		CaptureBlt = 1073741824,
		DestinationInvert = 5570569,
		MergeCopy = 12583114,
		MergePaint = 12255782,
		NoMirrorBitmap = int.MinValue,
		NotSourceCopy = 3342344,
		NotSourceErase = 1114278,
		PatCopy = 15728673,
		PatInvert = 5898313,
		PatPaint = 16452105,
		SourceAnd = 8913094,
		SourceCopy = 13369376,
		SourceErase = 4457256,
		SourceInvert = 6684742,
		SourcePaint = 15597702,
		Whiteness = 16711778
	}
}
namespace System.Drawing.Drawing2D
{
	public enum DashCap
	{
		Flat = 0,
		Round = 2,
		Triangle = 3
	}
}
namespace System.Drawing
{
	public class FontConverter : TypeConverter
	{
		internal class UnitName
		{
			internal string name;

			internal GraphicsUnit unit;

			internal static readonly UnitName[] names = new UnitName[7]
			{
				new UnitName("world", GraphicsUnit.World),
				new UnitName("display", GraphicsUnit.Display),
				new UnitName("px", GraphicsUnit.Pixel),
				new UnitName("pt", GraphicsUnit.Point),
				new UnitName("in", GraphicsUnit.Inch),
				new UnitName("doc", GraphicsUnit.Document),
				new UnitName("mm", GraphicsUnit.Millimeter)
			};

			internal UnitName(string name, GraphicsUnit unit)
			{
				this.name = name;
				this.unit = unit;
			}
		}

		public sealed class FontNameConverter : TypeConverter, IDisposable
		{
			private StandardValuesCollection values;

			public FontNameConverter()
			{
				SystemEvents.InstalledFontsChanged += OnInstalledFontsChanged;
			}

			public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
			{
				if (sourceType == typeof(string))
				{
					return true;
				}
				return base.CanConvertFrom(context, sourceType);
			}

			public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
			{
				if (value is string)
				{
					return MatchFontName((string)value, context);
				}
				return base.ConvertFrom(context, culture, value);
			}

			void IDisposable.Dispose()
			{
				SystemEvents.InstalledFontsChanged -= OnInstalledFontsChanged;
			}

			public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
			{
				if (values == null)
				{
					FontFamily[] families = FontFamily.Families;
					Hashtable hashtable = new Hashtable();
					for (int i = 0; i < families.Length; i++)
					{
						string name = families[i].Name;
						hashtable[name.ToLower(CultureInfo.InvariantCulture)] = name;
					}
					object[] array = new object[hashtable.Values.Count];
					hashtable.Values.CopyTo(array, 0);
					Array.Sort(array, Comparer.Default);
					values = new StandardValuesCollection(array);
				}
				return values;
			}

			public override bool GetStandardValuesExclusive(ITypeDescriptorContext context)
			{
				return false;
			}

			public override bool GetStandardValuesSupported(ITypeDescriptorContext context)
			{
				return true;
			}

			private string MatchFontName(string name, ITypeDescriptorContext context)
			{
				string text = null;
				name = name.ToLower(CultureInfo.InvariantCulture);
				IEnumerator enumerator = GetStandardValues(context).GetEnumerator();
				while (enumerator.MoveNext())
				{
					string text2 = enumerator.Current.ToString().ToLower(CultureInfo.InvariantCulture);
					if (text2.Equals(name))
					{
						return enumerator.Current.ToString();
					}
					if (text2.StartsWith(name) && (text == null || text2.Length <= text.Length))
					{
						text = enumerator.Current.ToString();
					}
				}
				if (text == null)
				{
					text = name;
				}
				return text;
			}

			private void OnInstalledFontsChanged(object sender, EventArgs e)
			{
				values = null;
			}
		}

		public class FontUnitConverter : EnumConverter
		{
			public FontUnitConverter()
				: base(typeof(GraphicsUnit))
			{
			}

			public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
			{
				if (base.Values == null)
				{
					base.GetStandardValues(context);
					ArrayList arrayList = new ArrayList(base.Values);
					arrayList.Remove(GraphicsUnit.Display);
					base.Values = new StandardValuesCollection(arrayList);
				}
				return base.Values;
			}
		}

		private const string styleHdr = "style=";

		private FontNameConverter fontNameConverter;

		~FontConverter()
		{
			if (fontNameConverter != null)
			{
				((IDisposable)fontNameConverter).Dispose();
			}
		}

		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
		{
			if (sourceType == typeof(string))
			{
				return true;
			}
			return base.CanConvertFrom(context, sourceType);
		}

		public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
		{
			if (destinationType == typeof(InstanceDescriptor))
			{
				return true;
			}
			return base.CanConvertTo(context, destinationType);
		}

		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
		{
			if (value is string text)
			{
				string text2 = text.Trim();
				if (text2.Length == 0)
				{
					return null;
				}
				if (culture == null)
				{
					culture = CultureInfo.CurrentCulture;
				}
				char c = culture.TextInfo.ListSeparator[0];
				string value2 = text2;
				string text3 = null;
				string text4 = null;
				float emSize = 8.25f;
				FontStyle fontStyle = FontStyle.Regular;
				GraphicsUnit unit = GraphicsUnit.Point;
				int num = text2.IndexOf(c);
				if (num > 0)
				{
					value2 = text2.Substring(0, num);
					if (num < text2.Length - 1)
					{
						int num2 = text2.IndexOf("style=");
						if (num2 != -1)
						{
							text3 = text2.Substring(num2, text2.Length - num2);
							if (!text3.StartsWith("style="))
							{
								throw GetFormatException(text2, c);
							}
							text4 = text2.Substring(num + 1, num2 - num - 1);
						}
						else
						{
							text4 = text2.Substring(num + 1, text2.Length - num - 1);
						}
						string[] array = ParseSizeTokens(text4, c);
						if (array[0] != null)
						{
							try
							{
								emSize = (float)TypeDescriptor.GetConverter(typeof(float)).ConvertFromString(context, culture, array[0]);
							}
							catch
							{
								throw GetFormatException(text2, c);
							}
						}
						if (array[1] != null)
						{
							unit = ParseGraphicsUnits(array[1]);
						}
						if (text3 != null)
						{
							int num3 = text3.IndexOf("=");
							text3 = text3.Substring(num3 + 1, text3.Length - "style=".Length);
							string[] array2 = text3.Split(c);
							for (int i = 0; i < array2.Length; i++)
							{
								string text5 = array2[i];
								text5 = text5.Trim();
								try
								{
									fontStyle |= (FontStyle)Enum.Parse(typeof(FontStyle), text5, ignoreCase: true);
								}
								catch (Exception ex)
								{
									if (ex is InvalidEnumArgumentException)
									{
										throw;
									}
									throw GetFormatException(text2, c);
								}
								FontStyle fontStyle2 = FontStyle.Bold | FontStyle.Italic | FontStyle.Underline | FontStyle.Strikeout;
								if ((fontStyle | fontStyle2) != fontStyle2)
								{
									throw new InvalidEnumArgumentException("style", (int)fontStyle, typeof(FontStyle));
								}
							}
						}
					}
				}
				if (fontNameConverter == null)
				{
					fontNameConverter = new FontNameConverter();
				}
				value2 = (string)fontNameConverter.ConvertFrom(context, culture, value2);
				return new Font(value2, emSize, fontStyle, unit);
			}
			return base.ConvertFrom(context, culture, value);
		}

		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (destinationType == typeof(string))
			{
				if (!(value is Font font))
				{
					return SR.GetString("toStringNone");
				}
				if (culture == null)
				{
					culture = CultureInfo.CurrentCulture;
				}
				string separator = culture.TextInfo.ListSeparator + " ";
				int num = 2;
				if (font.Style != 0)
				{
					num++;
				}
				string[] array = new string[num];
				int num2 = 0;
				array[num2++] = font.Name;
				array[num2++] = TypeDescriptor.GetConverter(font.Size).ConvertToString(context, culture, font.Size) + GetGraphicsUnitText(font.Unit);
				if (font.Style != 0)
				{
					array[num2++] = "style=" + font.Style.ToString("G");
				}
				return string.Join(separator, array);
			}
			if (destinationType == typeof(InstanceDescriptor) && value is Font)
			{
				Font font2 = (Font)value;
				int num3 = 2;
				if (font2.GdiVerticalFont)
				{
					num3 = 6;
				}
				else if (font2.GdiCharSet != 1)
				{
					num3 = 5;
				}
				else if (font2.Unit != GraphicsUnit.Point)
				{
					num3 = 4;
				}
				else if (font2.Style != 0)
				{
					num3++;
				}
				object[] array2 = new object[num3];
				Type[] array3 = new Type[num3];
				array2[0] = font2.Name;
				array3[0] = typeof(string);
				array2[1] = font2.Size;
				array3[1] = typeof(float);
				if (num3 > 2)
				{
					array2[2] = font2.Style;
					array3[2] = typeof(FontStyle);
				}
				if (num3 > 3)
				{
					array2[3] = font2.Unit;
					array3[3] = typeof(GraphicsUnit);
				}
				if (num3 > 4)
				{
					array2[4] = font2.GdiCharSet;
					array3[4] = typeof(byte);
				}
				if (num3 > 5)
				{
					array2[5] = font2.GdiVerticalFont;
					array3[5] = typeof(bool);
				}
				MemberInfo constructor = typeof(Font).GetConstructor(array3);
				if (constructor != null)
				{
					return new InstanceDescriptor(constructor, array2);
				}
			}
			return base.ConvertTo(context, culture, value, destinationType);
		}

		public override object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues)
		{
			if (propertyValues == null)
			{
				throw new ArgumentNullException("propertyValues");
			}
			object obj = propertyValues["Name"];
			object obj2 = propertyValues["Size"];
			object obj3 = propertyValues["Unit"];
			object obj4 = propertyValues["Bold"];
			object obj5 = propertyValues["Italic"];
			object obj6 = propertyValues["Strikeout"];
			object obj7 = propertyValues["Underline"];
			object obj8 = propertyValues["GdiCharSet"];
			object obj9 = propertyValues["GdiVerticalFont"];
			if (obj == null)
			{
				obj = "Tahoma";
			}
			if (obj2 == null)
			{
				obj2 = 8f;
			}
			if (obj3 == null)
			{
				obj3 = GraphicsUnit.Point;
			}
			if (obj4 == null)
			{
				obj4 = false;
			}
			if (obj5 == null)
			{
				obj5 = false;
			}
			if (obj6 == null)
			{
				obj6 = false;
			}
			if (obj7 == null)
			{
				obj7 = false;
			}
			if (obj8 == null)
			{
				obj8 = (byte)0;
			}
			if (obj9 == null)
			{
				obj9 = false;
			}
			if (!(obj is string) || !(obj2 is float) || !(obj8 is byte) || !(obj3 is GraphicsUnit) || !(obj4 is bool) || !(obj5 is bool) || !(obj6 is bool) || !(obj7 is bool) || !(obj9 is bool))
			{
				throw new ArgumentException(SR.GetString("PropertyValueInvalidEntry"));
			}
			FontStyle fontStyle = FontStyle.Regular;
			if (obj4 != null && (bool)obj4)
			{
				fontStyle |= FontStyle.Bold;
			}
			if (obj5 != null && (bool)obj5)
			{
				fontStyle |= FontStyle.Italic;
			}
			if (obj6 != null && (bool)obj6)
			{
				fontStyle |= FontStyle.Strikeout;
			}
			if (obj7 != null && (bool)obj7)
			{
				fontStyle |= FontStyle.Underline;
			}
			return new Font((string)obj, (float)obj2, fontStyle, (GraphicsUnit)obj3, (byte)obj8, (bool)obj9);
		}

		public override bool GetCreateInstanceSupported(ITypeDescriptorContext context)
		{
			return true;
		}

		private ArgumentException GetFormatException(string text, char separator)
		{
			string text2 = string.Format(CultureInfo.CurrentCulture, "name{0} size[units[{0} style=style1[{0} style2{0} ...]]]", separator);
			return new ArgumentException(SR.GetString("TextParseFailedFormat", text, text2));
		}

		private string GetGraphicsUnitText(GraphicsUnit units)
		{
			string result = "";
			for (int i = 0; i < UnitName.names.Length; i++)
			{
				if (UnitName.names[i].unit == units)
				{
					result = UnitName.names[i].name;
					break;
				}
			}
			return result;
		}

		public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
		{
			PropertyDescriptorCollection properties = TypeDescriptor.GetProperties(typeof(Font), attributes);
			return properties.Sort(new string[4] { "Name", "Size", "Unit", "Weight" });
		}

		public override bool GetPropertiesSupported(ITypeDescriptorContext context)
		{
			return true;
		}

		private string[] ParseSizeTokens(string text, char separator)
		{
			string text2 = null;
			string text3 = null;
			text = text.Trim();
			int length = text.Length;
			if (length > 0)
			{
				int i;
				for (i = 0; i < length && !char.IsLetter(text[i]); i++)
				{
				}
				char[] trimChars = new char[2] { separator, ' ' };
				if (i > 0)
				{
					text2 = text.Substring(0, i);
					text2 = text2.Trim(trimChars);
				}
				if (i < length)
				{
					text3 = text.Substring(i);
					text3 = text3.TrimEnd(trimChars);
				}
			}
			return new string[2] { text2, text3 };
		}

		private GraphicsUnit ParseGraphicsUnits(string units)
		{
			UnitName unitName = null;
			for (int i = 0; i < UnitName.names.Length; i++)
			{
				if (string.Equals(UnitName.names[i].name, units, StringComparison.OrdinalIgnoreCase))
				{
					unitName = UnitName.names[i];
					break;
				}
			}
			if (unitName == null)
			{
				throw new ArgumentException(SR.GetString("InvalidArgument", "units", units));
			}
			return unitName.unit;
		}
	}
	internal class GraphicsContext : IDisposable
	{
		private int contextState;

		private PointF transformOffset;

		private Region clipRegion;

		private GraphicsContext nextContext;

		private GraphicsContext prevContext;

		private bool isCumulative;

		public int State
		{
			get
			{
				return contextState;
			}
			set
			{
				contextState = value;
			}
		}

		public PointF TransformOffset => transformOffset;

		public Region Clip => clipRegion;

		public GraphicsContext Next
		{
			get
			{
				return nextContext;
			}
			set
			{
				nextContext = value;
			}
		}

		public GraphicsContext Previous
		{
			get
			{
				return prevContext;
			}
			set
			{
				prevContext = value;
			}
		}

		public bool IsCumulative
		{
			get
			{
				return isCumulative;
			}
			set
			{
				isCumulative = value;
			}
		}

		private GraphicsContext()
		{
		}

		public GraphicsContext(Graphics g)
		{
			Matrix transform = g.Transform;
			if (!transform.IsIdentity)
			{
				float[] elements = transform.Elements;
				transformOffset.X = elements[4];
				transformOffset.Y = elements[5];
			}
			transform.Dispose();
			Region clip = g.Clip;
			if (clip.IsInfinite(g))
			{
				clip.Dispose();
			}
			else
			{
				clipRegion = clip;
			}
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		public void Dispose(bool disposing)
		{
			if (nextContext != null)
			{
				nextContext.Dispose();
				nextContext = null;
			}
			if (clipRegion != null)
			{
				clipRegion.Dispose();
				clipRegion = null;
			}
		}
	}
	public sealed class Graphics : MarshalByRefObject, IDeviceContext, IDisposable
	{
		public delegate bool DrawImageAbort(IntPtr callbackdata);

		public delegate bool EnumerateMetafileProc(EmfPlusRecordType recordType, int flags, int dataSize, IntPtr data, PlayRecordCallback callbackData);

		private GraphicsContext previousContext;

		private static object syncObject = new object();

		private IntPtr nativeGraphics;

		private IntPtr nativeHdc;

		private object printingHelper;

		private static IntPtr halftonePalette;

		private Image backingImage;

		internal IntPtr NativeGraphics => nativeGraphics;

		public CompositingMode CompositingMode
		{
			get
			{
				int compositeMode = 0;
				int num = SafeNativeMethods.Gdip.GdipGetCompositingMode(new HandleRef(this, NativeGraphics), out compositeMode);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return (CompositingMode)compositeMode;
			}
			set
			{
				if (!ClientUtils.IsEnumValid(value, (int)value, 0, 1))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(CompositingMode));
				}
				int num = SafeNativeMethods.Gdip.GdipSetCompositingMode(new HandleRef(this, NativeGraphics), (int)value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		public Point RenderingOrigin
		{
			get
			{
				int x;
				int y;
				int num = SafeNativeMethods.Gdip.GdipGetRenderingOrigin(new HandleRef(this, NativeGraphics), out x, out y);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return new Point(x, y);
			}
			set
			{
				int num = SafeNativeMethods.Gdip.GdipSetRenderingOrigin(new HandleRef(this, NativeGraphics), value.X, value.Y);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		public CompositingQuality CompositingQuality
		{
			get
			{
				CompositingQuality quality;
				int num = SafeNativeMethods.Gdip.GdipGetCompositingQuality(new HandleRef(this, NativeGraphics), out quality);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return quality;
			}
			set
			{
				if (!ClientUtils.IsEnumValid(value, (int)value, -1, 4))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(CompositingQuality));
				}
				int num = SafeNativeMethods.Gdip.GdipSetCompositingQuality(new HandleRef(this, NativeGraphics), value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		public TextRenderingHint TextRenderingHint
		{
			get
			{
				TextRenderingHint textRenderingHint = TextRenderingHint.SystemDefault;
				int num = SafeNativeMethods.Gdip.GdipGetTextRenderingHint(new HandleRef(this, NativeGraphics), out textRenderingHint);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return textRenderingHint;
			}
			set
			{
				if (!ClientUtils.IsEnumValid(value, (int)value, 0, 5))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(TextRenderingHint));
				}
				int num = SafeNativeMethods.Gdip.GdipSetTextRenderingHint(new HandleRef(this, NativeGraphics), value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		public int TextContrast
		{
			get
			{
				int textContrast = 0;
				int num = SafeNativeMethods.Gdip.GdipGetTextContrast(new HandleRef(this, NativeGraphics), out textContrast);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return textContrast;
			}
			set
			{
				int num = SafeNativeMethods.Gdip.GdipSetTextContrast(new HandleRef(this, NativeGraphics), value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		public SmoothingMode SmoothingMode
		{
			get
			{
				SmoothingMode smoothingMode = SmoothingMode.Default;
				int num = SafeNativeMethods.Gdip.GdipGetSmoothingMode(new HandleRef(this, NativeGraphics), out smoothingMode);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return smoothingMode;
			}
			set
			{
				if (!ClientUtils.IsEnumValid(value, (int)value, -1, 4))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(SmoothingMode));
				}
				int num = SafeNativeMethods.Gdip.GdipSetSmoothingMode(new HandleRef(this, NativeGraphics), value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		public PixelOffsetMode PixelOffsetMode
		{
			get
			{
				PixelOffsetMode pixelOffsetMode = PixelOffsetMode.Default;
				int num = SafeNativeMethods.Gdip.GdipGetPixelOffsetMode(new HandleRef(this, NativeGraphics), out pixelOffsetMode);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return pixelOffsetMode;
			}
			set
			{
				if (!ClientUtils.IsEnumValid(value, (int)value, -1, 4))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(PixelOffsetMode));
				}
				int num = SafeNativeMethods.Gdip.GdipSetPixelOffsetMode(new HandleRef(this, NativeGraphics), value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		internal object PrintingHelper
		{
			get
			{
				return printingHelper;
			}
			set
			{
				printingHelper = value;
			}
		}

		public InterpolationMode InterpolationMode
		{
			get
			{
				int mode = 0;
				int num = SafeNativeMethods.Gdip.GdipGetInterpolationMode(new HandleRef(this, NativeGraphics), out mode);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return (InterpolationMode)mode;
			}
			set
			{
				if (!ClientUtils.IsEnumValid(value, (int)value, -1, 7))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(InterpolationMode));
				}
				int num = SafeNativeMethods.Gdip.GdipSetInterpolationMode(new HandleRef(this, NativeGraphics), (int)value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		public Matrix Transform
		{
			get
			{
				Matrix matrix = new Matrix();
				int num = SafeNativeMethods.Gdip.GdipGetWorldTransform(new HandleRef(this, NativeGraphics), new HandleRef(matrix, matrix.nativeMatrix));
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return matrix;
			}
			set
			{
				int num = SafeNativeMethods.Gdip.GdipSetWorldTransform(new HandleRef(this, NativeGraphics), new HandleRef(value, value.nativeMatrix));
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		public GraphicsUnit PageUnit
		{
			get
			{
				int unit = 0;
				int num = SafeNativeMethods.Gdip.GdipGetPageUnit(new HandleRef(this, NativeGraphics), out unit);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return (GraphicsUnit)unit;
			}
			set
			{
				if (!ClientUtils.IsEnumValid(value, (int)value, 0, 6))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(GraphicsUnit));
				}
				int num = SafeNativeMethods.Gdip.GdipSetPageUnit(new HandleRef(this, NativeGraphics), (int)value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		public float PageScale
		{
			get
			{
				float[] array = new float[1];
				float[] array2 = array;
				int num = SafeNativeMethods.Gdip.GdipGetPageScale(new HandleRef(this, NativeGraphics), array2);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return array2[0];
			}
			set
			{
				int num = SafeNativeMethods.Gdip.GdipSetPageScale(new HandleRef(this, NativeGraphics), value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		public float DpiX
		{
			get
			{
				float[] array = new float[1];
				float[] array2 = array;
				int num = SafeNativeMethods.Gdip.GdipGetDpiX(new HandleRef(this, NativeGraphics), array2);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return array2[0];
			}
		}

		public float DpiY
		{
			get
			{
				float[] array = new float[1];
				float[] array2 = array;
				int num = SafeNativeMethods.Gdip.GdipGetDpiY(new HandleRef(this, NativeGraphics), array2);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return array2[0];
			}
		}

		public Region Clip
		{
			get
			{
				Region region = new Region();
				int num = SafeNativeMethods.Gdip.GdipGetClip(new HandleRef(this, NativeGraphics), new HandleRef(region, region.nativeRegion));
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return region;
			}
			set
			{
				SetClip(value, CombineMode.Replace);
			}
		}

		public RectangleF ClipBounds
		{
			get
			{
				GPRECTF rect = default(GPRECTF);
				int num = SafeNativeMethods.Gdip.GdipGetClipBounds(new HandleRef(this, NativeGraphics), ref rect);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return rect.ToRectangleF();
			}
		}

		public bool IsClipEmpty
		{
			get
			{
				int boolean;
				int num = SafeNativeMethods.Gdip.GdipIsClipEmpty(new HandleRef(this, NativeGraphics), out boolean);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return boolean != 0;
			}
		}

		public RectangleF VisibleClipBounds
		{
			get
			{
				if (PrintingHelper != null && PrintingHelper is PrintPreviewGraphics printPreviewGraphics)
				{
					return printPreviewGraphics.VisibleClipBounds;
				}
				GPRECTF rect = default(GPRECTF);
				int num = SafeNativeMethods.Gdip.GdipGetVisibleClipBounds(new HandleRef(this, NativeGraphics), ref rect);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return rect.ToRectangleF();
			}
		}

		public bool IsVisibleClipEmpty
		{
			get
			{
				int boolean;
				int num = SafeNativeMethods.Gdip.GdipIsVisibleClipEmpty(new HandleRef(this, NativeGraphics), out boolean);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return boolean != 0;
			}
		}

		private Graphics(IntPtr gdipNativeGraphics)
		{
			if (gdipNativeGraphics == IntPtr.Zero)
			{
				throw new ArgumentNullException("gdipNativeGraphics");
			}
			nativeGraphics = gdipNativeGraphics;
		}

		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public static Graphics FromHdc(IntPtr hdc)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			if (hdc == IntPtr.Zero)
			{
				throw new ArgumentNullException("hdc");
			}
			return FromHdcInternal(hdc);
		}

		[EditorBrowsable(EditorBrowsableState.Advanced)]
		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
		public static Graphics FromHdcInternal(IntPtr hdc)
		{
			IntPtr graphics = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateFromHDC(new HandleRef(null, hdc), out graphics);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new Graphics(graphics);
		}

		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public static Graphics FromHdc(IntPtr hdc, IntPtr hdevice)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			IntPtr graphics = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateFromHDC2(new HandleRef(null, hdc), new HandleRef(null, hdevice), out graphics);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new Graphics(graphics);
		}

		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public static Graphics FromHwnd(IntPtr hwnd)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			return FromHwndInternal(hwnd);
		}

		[EditorBrowsable(EditorBrowsableState.Advanced)]
		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
		public static Graphics FromHwndInternal(IntPtr hwnd)
		{
			IntPtr graphics = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateFromHWND(new HandleRef(null, hwnd), out graphics);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new Graphics(graphics);
		}

		public static Graphics FromImage(Image image)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			if ((image.PixelFormat & PixelFormat.Indexed) != 0)
			{
				throw new Exception(SR.GetString("GdiplusCannotCreateGraphicsFromIndexedPixelFormat"));
			}
			IntPtr graphics = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipGetImageGraphicsContext(new HandleRef(image, image.nativeImage), out graphics);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			Graphics graphics2 = new Graphics(graphics);
			graphics2.backingImage = image;
			return graphics2;
		}

		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
		public IntPtr GetHdc()
		{
			IntPtr hdc = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipGetDC(new HandleRef(this, NativeGraphics), out hdc);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			nativeHdc = hdc;
			return nativeHdc;
		}

		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public void ReleaseHdc(IntPtr hdc)
		{
			IntSecurity.Win32HandleManipulation.Demand();
			ReleaseHdcInternal(hdc);
		}

		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
		public void ReleaseHdc()
		{
			ReleaseHdcInternal(nativeHdc);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
		public void ReleaseHdcInternal(IntPtr hdc)
		{
			int num = SafeNativeMethods.Gdip.GdipReleaseDC(new HandleRef(this, NativeGraphics), new HandleRef(null, hdc));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			nativeHdc = IntPtr.Zero;
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		private void Dispose(bool disposing)
		{
			while (previousContext != null)
			{
				GraphicsContext previous = previousContext.Previous;
				previousContext.Dispose();
				previousContext = previous;
			}
			if (!(nativeGraphics != IntPtr.Zero))
			{
				return;
			}
			try
			{
				if (nativeHdc != IntPtr.Zero)
				{
					ReleaseHdc();
				}
				if (PrintingHelper != null && PrintingHelper is DeviceContext deviceContext)
				{
					deviceContext.Dispose();
					printingHelper = null;
				}
				SafeNativeMethods.Gdip.GdipDeleteGraphics(new HandleRef(this, nativeGraphics));
			}
			catch (Exception ex)
			{
				if (ClientUtils.IsSecurityOrCriticalException(ex))
				{
					throw;
				}
			}
			finally
			{
				nativeGraphics = IntPtr.Zero;
			}
		}

		~Graphics()
		{
			Dispose(disposing: false);
		}

		public void Flush()
		{
			Flush(FlushIntention.Flush);
		}

		public void Flush(FlushIntention intention)
		{
			int num = SafeNativeMethods.Gdip.GdipFlush(new HandleRef(this, NativeGraphics), intention);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void CopyFromScreen(Point upperLeftSource, Point upperLeftDestination, Size blockRegionSize)
		{
			CopyFromScreen(upperLeftSource.X, upperLeftSource.Y, upperLeftDestination.X, upperLeftDestination.Y, blockRegionSize);
		}

		public void CopyFromScreen(int sourceX, int sourceY, int destinationX, int destinationY, Size blockRegionSize)
		{
			CopyFromScreen(sourceX, sourceY, destinationX, destinationY, blockRegionSize, CopyPixelOperation.SourceCopy);
		}

		public void CopyFromScreen(Point upperLeftSource, Point upperLeftDestination, Size blockRegionSize, CopyPixelOperation copyPixelOperation)
		{
			CopyFromScreen(upperLeftSource.X, upperLeftSource.Y, upperLeftDestination.X, upperLeftDestination.Y, blockRegionSize, copyPixelOperation);
		}

		public void CopyFromScreen(int sourceX, int sourceY, int destinationX, int destinationY, Size blockRegionSize, CopyPixelOperation copyPixelOperation)
		{
			switch (copyPixelOperation)
			{
			default:
				throw new InvalidEnumArgumentException("value", (int)copyPixelOperation, typeof(CopyPixelOperation));
			case CopyPixelOperation.NoMirrorBitmap:
			case CopyPixelOperation.Blackness:
			case CopyPixelOperation.NotSourceErase:
			case CopyPixelOperation.NotSourceCopy:
			case CopyPixelOperation.SourceErase:
			case CopyPixelOperation.DestinationInvert:
			case CopyPixelOperation.PatInvert:
			case CopyPixelOperation.SourceInvert:
			case CopyPixelOperation.SourceAnd:
			case CopyPixelOperation.MergePaint:
			case CopyPixelOperation.MergeCopy:
			case CopyPixelOperation.SourceCopy:
			case CopyPixelOperation.SourcePaint:
			case CopyPixelOperation.PatCopy:
			case CopyPixelOperation.PatPaint:
			case CopyPixelOperation.Whiteness:
			case CopyPixelOperation.CaptureBlt:
			{
				new UIPermission(UIPermissionWindow.AllWindows).Demand();
				int width = blockRegionSize.Width;
				int height = blockRegionSize.Height;
				using DeviceContext deviceContext = DeviceContext.FromHwnd(IntPtr.Zero);
				HandleRef hSrcDC = new HandleRef(null, deviceContext.Hdc);
				HandleRef hDC = new HandleRef(null, GetHdc());
				try
				{
					if (SafeNativeMethods.BitBlt(hDC, destinationX, destinationY, width, height, hSrcDC, sourceX, sourceY, (int)copyPixelOperation) == 0)
					{
						throw new Win32Exception();
					}
					break;
				}
				finally
				{
					ReleaseHdc();
				}
			}
			}
		}

		public void ResetTransform()
		{
			int num = SafeNativeMethods.Gdip.GdipResetWorldTransform(new HandleRef(this, NativeGraphics));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void MultiplyTransform(Matrix matrix)
		{
			MultiplyTransform(matrix, MatrixOrder.Prepend);
		}

		public void MultiplyTransform(Matrix matrix, MatrixOrder order)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			int num = SafeNativeMethods.Gdip.GdipMultiplyWorldTransform(new HandleRef(this, NativeGraphics), new HandleRef(matrix, matrix.nativeMatrix), order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void TranslateTransform(float dx, float dy)
		{
			TranslateTransform(dx, dy, MatrixOrder.Prepend);
		}

		public void TranslateTransform(float dx, float dy, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipTranslateWorldTransform(new HandleRef(this, NativeGraphics), dx, dy, order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void ScaleTransform(float sx, float sy)
		{
			ScaleTransform(sx, sy, MatrixOrder.Prepend);
		}

		public void ScaleTransform(float sx, float sy, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipScaleWorldTransform(new HandleRef(this, NativeGraphics), sx, sy, order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void RotateTransform(float angle)
		{
			RotateTransform(angle, MatrixOrder.Prepend);
		}

		public void RotateTransform(float angle, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipRotateWorldTransform(new HandleRef(this, NativeGraphics), angle, order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void TransformPoints(CoordinateSpace destSpace, CoordinateSpace srcSpace, PointF[] pts)
		{
			if (pts == null)
			{
				throw new ArgumentNullException("pts");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(pts);
			int num = SafeNativeMethods.Gdip.GdipTransformPoints(new HandleRef(this, NativeGraphics), (int)destSpace, (int)srcSpace, intPtr, pts.Length);
			try
			{
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				PointF[] array = SafeNativeMethods.Gdip.ConvertGPPOINTFArrayF(intPtr, pts.Length);
				for (int i = 0; i < pts.Length; i++)
				{
					ref PointF reference = ref pts[i];
					reference = array[i];
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		public void TransformPoints(CoordinateSpace destSpace, CoordinateSpace srcSpace, Point[] pts)
		{
			if (pts == null)
			{
				throw new ArgumentNullException("pts");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(pts);
			int num = SafeNativeMethods.Gdip.GdipTransformPointsI(new HandleRef(this, NativeGraphics), (int)destSpace, (int)srcSpace, intPtr, pts.Length);
			try
			{
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				Point[] array = SafeNativeMethods.Gdip.ConvertGPPOINTArray(intPtr, pts.Length);
				for (int i = 0; i < pts.Length; i++)
				{
					ref Point reference = ref pts[i];
					reference = array[i];
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		public Color GetNearestColor(Color color)
		{
			int color2 = color.ToArgb();
			int num = SafeNativeMethods.Gdip.GdipGetNearestColor(new HandleRef(this, NativeGraphics), ref color2);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return Color.FromArgb(color2);
		}

		public void DrawLine(Pen pen, float x1, float y1, float x2, float y2)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			int status = SafeNativeMethods.Gdip.GdipDrawLine(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), x1, y1, x2, y2);
			CheckErrorStatus(status);
		}

		public void DrawLine(Pen pen, PointF pt1, PointF pt2)
		{
			DrawLine(pen, pt1.X, pt1.Y, pt2.X, pt2.Y);
		}

		public void DrawLines(Pen pen, PointF[] points)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			int status = SafeNativeMethods.Gdip.GdipDrawLines(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), new HandleRef(this, intPtr), points.Length);
			Marshal.FreeHGlobal(intPtr);
			CheckErrorStatus(status);
		}

		public void DrawLine(Pen pen, int x1, int y1, int x2, int y2)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			int status = SafeNativeMethods.Gdip.GdipDrawLineI(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), x1, y1, x2, y2);
			CheckErrorStatus(status);
		}

		public void DrawLine(Pen pen, Point pt1, Point pt2)
		{
			DrawLine(pen, pt1.X, pt1.Y, pt2.X, pt2.Y);
		}

		public void DrawLines(Pen pen, Point[] points)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			int status = SafeNativeMethods.Gdip.GdipDrawLinesI(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), new HandleRef(this, intPtr), points.Length);
			Marshal.FreeHGlobal(intPtr);
			CheckErrorStatus(status);
		}

		public void DrawArc(Pen pen, float x, float y, float width, float height, float startAngle, float sweepAngle)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			int status = SafeNativeMethods.Gdip.GdipDrawArc(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), x, y, width, height, startAngle, sweepAngle);
			CheckErrorStatus(status);
		}

		public void DrawArc(Pen pen, RectangleF rect, float startAngle, float sweepAngle)
		{
			DrawArc(pen, rect.X, rect.Y, rect.Width, rect.Height, startAngle, sweepAngle);
		}

		public void DrawArc(Pen pen, int x, int y, int width, int height, int startAngle, int sweepAngle)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			int status = SafeNativeMethods.Gdip.GdipDrawArcI(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), x, y, width, height, startAngle, sweepAngle);
			CheckErrorStatus(status);
		}

		public void DrawArc(Pen pen, Rectangle rect, float startAngle, float sweepAngle)
		{
			DrawArc(pen, rect.X, rect.Y, rect.Width, rect.Height, startAngle, sweepAngle);
		}

		public void DrawBezier(Pen pen, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			int status = SafeNativeMethods.Gdip.GdipDrawBezier(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), x1, y1, x2, y2, x3, y3, x4, y4);
			CheckErrorStatus(status);
		}

		public void DrawBezier(Pen pen, PointF pt1, PointF pt2, PointF pt3, PointF pt4)
		{
			DrawBezier(pen, pt1.X, pt1.Y, pt2.X, pt2.Y, pt3.X, pt3.Y, pt4.X, pt4.Y);
		}

		public void DrawBeziers(Pen pen, PointF[] points)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			int status = SafeNativeMethods.Gdip.GdipDrawBeziers(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), new HandleRef(this, intPtr), points.Length);
			Marshal.FreeHGlobal(intPtr);
			CheckErrorStatus(status);
		}

		public void DrawBezier(Pen pen, Point pt1, Point pt2, Point pt3, Point pt4)
		{
			DrawBezier(pen, pt1.X, pt1.Y, pt2.X, pt2.Y, pt3.X, pt3.Y, pt4.X, pt4.Y);
		}

		public void DrawBeziers(Pen pen, Point[] points)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			int status = SafeNativeMethods.Gdip.GdipDrawBeziersI(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), new HandleRef(this, intPtr), points.Length);
			Marshal.FreeHGlobal(intPtr);
			CheckErrorStatus(status);
		}

		public void DrawRectangle(Pen pen, Rectangle rect)
		{
			DrawRectangle(pen, rect.X, rect.Y, rect.Width, rect.Height);
		}

		public void DrawRectangle(Pen pen, float x, float y, float width, float height)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			int status = SafeNativeMethods.Gdip.GdipDrawRectangle(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), x, y, width, height);
			CheckErrorStatus(status);
		}

		public void DrawRectangle(Pen pen, int x, int y, int width, int height)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			int status = SafeNativeMethods.Gdip.GdipDrawRectangleI(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), x, y, width, height);
			CheckErrorStatus(status);
		}

		public void DrawRectangles(Pen pen, RectangleF[] rects)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (rects == null)
			{
				throw new ArgumentNullException("rects");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertRectangleToMemory(rects);
			int status = SafeNativeMethods.Gdip.GdipDrawRectangles(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), new HandleRef(this, intPtr), rects.Length);
			Marshal.FreeHGlobal(intPtr);
			CheckErrorStatus(status);
		}

		public void DrawRectangles(Pen pen, Rectangle[] rects)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (rects == null)
			{
				throw new ArgumentNullException("rects");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertRectangleToMemory(rects);
			int status = SafeNativeMethods.Gdip.GdipDrawRectanglesI(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), new HandleRef(this, intPtr), rects.Length);
			Marshal.FreeHGlobal(intPtr);
			CheckErrorStatus(status);
		}

		public void DrawEllipse(Pen pen, RectangleF rect)
		{
			DrawEllipse(pen, rect.X, rect.Y, rect.Width, rect.Height);
		}

		public void DrawEllipse(Pen pen, float x, float y, float width, float height)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			int status = SafeNativeMethods.Gdip.GdipDrawEllipse(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), x, y, width, height);
			CheckErrorStatus(status);
		}

		public void DrawEllipse(Pen pen, Rectangle rect)
		{
			DrawEllipse(pen, rect.X, rect.Y, rect.Width, rect.Height);
		}

		public void DrawEllipse(Pen pen, int x, int y, int width, int height)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			int status = SafeNativeMethods.Gdip.GdipDrawEllipseI(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), x, y, width, height);
			CheckErrorStatus(status);
		}

		public void DrawPie(Pen pen, RectangleF rect, float startAngle, float sweepAngle)
		{
			DrawPie(pen, rect.X, rect.Y, rect.Width, rect.Height, startAngle, sweepAngle);
		}

		public void DrawPie(Pen pen, float x, float y, float width, float height, float startAngle, float sweepAngle)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			int status = SafeNativeMethods.Gdip.GdipDrawPie(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), x, y, width, height, startAngle, sweepAngle);
			CheckErrorStatus(status);
		}

		public void DrawPie(Pen pen, Rectangle rect, float startAngle, float sweepAngle)
		{
			DrawPie(pen, rect.X, rect.Y, rect.Width, rect.Height, startAngle, sweepAngle);
		}

		public void DrawPie(Pen pen, int x, int y, int width, int height, int startAngle, int sweepAngle)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			int status = SafeNativeMethods.Gdip.GdipDrawPieI(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), x, y, width, height, startAngle, sweepAngle);
			CheckErrorStatus(status);
		}

		public void DrawPolygon(Pen pen, PointF[] points)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			int status = SafeNativeMethods.Gdip.GdipDrawPolygon(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), new HandleRef(this, intPtr), points.Length);
			Marshal.FreeHGlobal(intPtr);
			CheckErrorStatus(status);
		}

		public void DrawPolygon(Pen pen, Point[] points)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			int status = SafeNativeMethods.Gdip.GdipDrawPolygonI(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), new HandleRef(this, intPtr), points.Length);
			Marshal.FreeHGlobal(intPtr);
			CheckErrorStatus(status);
		}

		public void DrawPath(Pen pen, GraphicsPath path)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			int status = SafeNativeMethods.Gdip.GdipDrawPath(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), new HandleRef(path, path.nativePath));
			CheckErrorStatus(status);
		}

		public void DrawCurve(Pen pen, PointF[] points)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			int status = SafeNativeMethods.Gdip.GdipDrawCurve(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), new HandleRef(this, intPtr), points.Length);
			Marshal.FreeHGlobal(intPtr);
			CheckErrorStatus(status);
		}

		public void DrawCurve(Pen pen, PointF[] points, float tension)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			int status = SafeNativeMethods.Gdip.GdipDrawCurve2(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), new HandleRef(this, intPtr), points.Length, tension);
			Marshal.FreeHGlobal(intPtr);
			CheckErrorStatus(status);
		}

		public void DrawCurve(Pen pen, PointF[] points, int offset, int numberOfSegments)
		{
			DrawCurve(pen, points, offset, numberOfSegments, 0.5f);
		}

		public void DrawCurve(Pen pen, PointF[] points, int offset, int numberOfSegments, float tension)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			int status = SafeNativeMethods.Gdip.GdipDrawCurve3(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), new HandleRef(this, intPtr), points.Length, offset, numberOfSegments, tension);
			Marshal.FreeHGlobal(intPtr);
			CheckErrorStatus(status);
		}

		public void DrawCurve(Pen pen, Point[] points)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			int status = SafeNativeMethods.Gdip.GdipDrawCurveI(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), new HandleRef(this, intPtr), points.Length);
			Marshal.FreeHGlobal(intPtr);
			CheckErrorStatus(status);
		}

		public void DrawCurve(Pen pen, Point[] points, float tension)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			int status = SafeNativeMethods.Gdip.GdipDrawCurve2I(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), new HandleRef(this, intPtr), points.Length, tension);
			Marshal.FreeHGlobal(intPtr);
			CheckErrorStatus(status);
		}

		public void DrawCurve(Pen pen, Point[] points, int offset, int numberOfSegments, float tension)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			int status = SafeNativeMethods.Gdip.GdipDrawCurve3I(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), new HandleRef(this, intPtr), points.Length, offset, numberOfSegments, tension);
			Marshal.FreeHGlobal(intPtr);
			CheckErrorStatus(status);
		}

		public void DrawClosedCurve(Pen pen, PointF[] points)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			int status = SafeNativeMethods.Gdip.GdipDrawClosedCurve(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), new HandleRef(this, intPtr), points.Length);
			Marshal.FreeHGlobal(intPtr);
			CheckErrorStatus(status);
		}

		public void DrawClosedCurve(Pen pen, PointF[] points, float tension, FillMode fillmode)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			int status = SafeNativeMethods.Gdip.GdipDrawClosedCurve2(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), new HandleRef(this, intPtr), points.Length, tension);
			Marshal.FreeHGlobal(intPtr);
			CheckErrorStatus(status);
		}

		public void DrawClosedCurve(Pen pen, Point[] points)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			int status = SafeNativeMethods.Gdip.GdipDrawClosedCurveI(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), new HandleRef(this, intPtr), points.Length);
			Marshal.FreeHGlobal(intPtr);
			CheckErrorStatus(status);
		}

		public void DrawClosedCurve(Pen pen, Point[] points, float tension, FillMode fillmode)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			int status = SafeNativeMethods.Gdip.GdipDrawClosedCurve2I(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), new HandleRef(this, intPtr), points.Length, tension);
			Marshal.FreeHGlobal(intPtr);
			CheckErrorStatus(status);
		}

		public void Clear(Color color)
		{
			int num = SafeNativeMethods.Gdip.GdipGraphicsClear(new HandleRef(this, NativeGraphics), color.ToArgb());
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void FillRectangle(Brush brush, RectangleF rect)
		{
			FillRectangle(brush, rect.X, rect.Y, rect.Width, rect.Height);
		}

		public void FillRectangle(Brush brush, float x, float y, float width, float height)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			int status = SafeNativeMethods.Gdip.GdipFillRectangle(new HandleRef(this, NativeGraphics), new HandleRef(brush, brush.NativeBrush), x, y, width, height);
			CheckErrorStatus(status);
		}

		public void FillRectangle(Brush brush, Rectangle rect)
		{
			FillRectangle(brush, rect.X, rect.Y, rect.Width, rect.Height);
		}

		public void FillRectangle(Brush brush, int x, int y, int width, int height)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			int status = SafeNativeMethods.Gdip.GdipFillRectangleI(new HandleRef(this, NativeGraphics), new HandleRef(brush, brush.NativeBrush), x, y, width, height);
			CheckErrorStatus(status);
		}

		public void FillRectangles(Brush brush, RectangleF[] rects)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			if (rects == null)
			{
				throw new ArgumentNullException("rects");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertRectangleToMemory(rects);
			int status = SafeNativeMethods.Gdip.GdipFillRectangles(new HandleRef(this, NativeGraphics), new HandleRef(brush, brush.NativeBrush), new HandleRef(this, intPtr), rects.Length);
			Marshal.FreeHGlobal(intPtr);
			CheckErrorStatus(status);
		}

		public void FillRectangles(Brush brush, Rectangle[] rects)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			if (rects == null)
			{
				throw new ArgumentNullException("rects");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertRectangleToMemory(rects);
			int status = SafeNativeMethods.Gdip.GdipFillRectanglesI(new HandleRef(this, NativeGraphics), new HandleRef(brush, brush.NativeBrush), new HandleRef(this, intPtr), rects.Length);
			Marshal.FreeHGlobal(intPtr);
			CheckErrorStatus(status);
		}

		public void FillPolygon(Brush brush, PointF[] points)
		{
			FillPolygon(brush, points, FillMode.Alternate);
		}

		public void FillPolygon(Brush brush, PointF[] points, FillMode fillMode)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			int status = SafeNativeMethods.Gdip.GdipFillPolygon(new HandleRef(this, NativeGraphics), new HandleRef(brush, brush.NativeBrush), new HandleRef(this, intPtr), points.Length, (int)fillMode);
			Marshal.FreeHGlobal(intPtr);
			CheckErrorStatus(status);
		}

		public void FillPolygon(Brush brush, Point[] points)
		{
			FillPolygon(brush, points, FillMode.Alternate);
		}

		public void FillPolygon(Brush brush, Point[] points, FillMode fillMode)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			int status = SafeNativeMethods.Gdip.GdipFillPolygonI(new HandleRef(this, NativeGraphics), new HandleRef(brush, brush.NativeBrush), new HandleRef(this, intPtr), points.Length, (int)fillMode);
			Marshal.FreeHGlobal(intPtr);
			CheckErrorStatus(status);
		}

		public void FillEllipse(Brush brush, RectangleF rect)
		{
			FillEllipse(brush, rect.X, rect.Y, rect.Width, rect.Height);
		}

		public void FillEllipse(Brush brush, float x, float y, float width, float height)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			int status = SafeNativeMethods.Gdip.GdipFillEllipse(new HandleRef(this, NativeGraphics), new HandleRef(brush, brush.NativeBrush), x, y, width, height);
			CheckErrorStatus(status);
		}

		public void FillEllipse(Brush brush, Rectangle rect)
		{
			FillEllipse(brush, rect.X, rect.Y, rect.Width, rect.Height);
		}

		public void FillEllipse(Brush brush, int x, int y, int width, int height)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			int status = SafeNativeMethods.Gdip.GdipFillEllipseI(new HandleRef(this, NativeGraphics), new HandleRef(brush, brush.NativeBrush), x, y, width, height);
			CheckErrorStatus(status);
		}

		public void FillPie(Brush brush, Rectangle rect, float startAngle, float sweepAngle)
		{
			FillPie(brush, rect.X, rect.Y, rect.Width, rect.Height, startAngle, sweepAngle);
		}

		public void FillPie(Brush brush, float x, float y, float width, float height, float startAngle, float sweepAngle)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			int status = SafeNativeMethods.Gdip.GdipFillPie(new HandleRef(this, NativeGraphics), new HandleRef(brush, brush.NativeBrush), x, y, width, height, startAngle, sweepAngle);
			CheckErrorStatus(status);
		}

		public void FillPie(Brush brush, int x, int y, int width, int height, int startAngle, int sweepAngle)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			int status = SafeNativeMethods.Gdip.GdipFillPieI(new HandleRef(this, NativeGraphics), new HandleRef(brush, brush.NativeBrush), x, y, width, height, startAngle, sweepAngle);
			CheckErrorStatus(status);
		}

		public void FillPath(Brush brush, GraphicsPath path)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			int status = SafeNativeMethods.Gdip.GdipFillPath(new HandleRef(this, NativeGraphics), new HandleRef(brush, brush.NativeBrush), new HandleRef(path, path.nativePath));
			CheckErrorStatus(status);
		}

		public void FillClosedCurve(Brush brush, PointF[] points)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			int status = SafeNativeMethods.Gdip.GdipFillClosedCurve(new HandleRef(this, NativeGraphics), new HandleRef(brush, brush.NativeBrush), new HandleRef(this, intPtr), points.Length);
			Marshal.FreeHGlobal(intPtr);
			CheckErrorStatus(status);
		}

		public void FillClosedCurve(Brush brush, PointF[] points, FillMode fillmode)
		{
			FillClosedCurve(brush, points, fillmode, 0.5f);
		}

		public void FillClosedCurve(Brush brush, PointF[] points, FillMode fillmode, float tension)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			int status = SafeNativeMethods.Gdip.GdipFillClosedCurve2(new HandleRef(this, NativeGraphics), new HandleRef(brush, brush.NativeBrush), new HandleRef(this, intPtr), points.Length, tension, (int)fillmode);
			Marshal.FreeHGlobal(intPtr);
			CheckErrorStatus(status);
		}

		public void FillClosedCurve(Brush brush, Point[] points)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			int status = SafeNativeMethods.Gdip.GdipFillClosedCurveI(new HandleRef(this, NativeGraphics), new HandleRef(brush, brush.NativeBrush), new HandleRef(this, intPtr), points.Length);
			Marshal.FreeHGlobal(intPtr);
			CheckErrorStatus(status);
		}

		public void FillClosedCurve(Brush brush, Point[] points, FillMode fillmode)
		{
			FillClosedCurve(brush, points, fillmode, 0.5f);
		}

		public void FillClosedCurve(Brush brush, Point[] points, FillMode fillmode, float tension)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			int status = SafeNativeMethods.Gdip.GdipFillClosedCurve2I(new HandleRef(this, NativeGraphics), new HandleRef(brush, brush.NativeBrush), new HandleRef(this, intPtr), points.Length, tension, (int)fillmode);
			Marshal.FreeHGlobal(intPtr);
			CheckErrorStatus(status);
		}

		public void FillRegion(Brush brush, Region region)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			if (region == null)
			{
				throw new ArgumentNullException("region");
			}
			int status = SafeNativeMethods.Gdip.GdipFillRegion(new HandleRef(this, NativeGraphics), new HandleRef(brush, brush.NativeBrush), new HandleRef(region, region.nativeRegion));
			CheckErrorStatus(status);
		}

		public void DrawString(string s, Font font, Brush brush, float x, float y)
		{
			DrawString(s, font, brush, new RectangleF(x, y, 0f, 0f), null);
		}

		public void DrawString(string s, Font font, Brush brush, PointF point)
		{
			DrawString(s, font, brush, new RectangleF(point.X, point.Y, 0f, 0f), null);
		}

		public void DrawString(string s, Font font, Brush brush, float x, float y, StringFormat format)
		{
			DrawString(s, font, brush, new RectangleF(x, y, 0f, 0f), format);
		}

		public void DrawString(string s, Font font, Brush brush, PointF point, StringFormat format)
		{
			DrawString(s, font, brush, new RectangleF(point.X, point.Y, 0f, 0f), format);
		}

		public void DrawString(string s, Font font, Brush brush, RectangleF layoutRectangle)
		{
			DrawString(s, font, brush, layoutRectangle, null);
		}

		public void DrawString(string s, Font font, Brush brush, RectangleF layoutRectangle, StringFormat format)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			if (s != null && s.Length != 0)
			{
				if (font == null)
				{
					throw new ArgumentNullException("font");
				}
				GPRECTF layoutRect = new GPRECTF(layoutRectangle);
				IntPtr handle = format?.nativeFormat ?? IntPtr.Zero;
				int status = SafeNativeMethods.Gdip.GdipDrawString(new HandleRef(this, NativeGraphics), s, s.Length, new HandleRef(font, font.NativeFont), ref layoutRect, new HandleRef(format, handle), new HandleRef(brush, brush.NativeBrush));
				CheckErrorStatus(status);
			}
		}

		public SizeF MeasureString(string text, Font font, SizeF layoutArea, StringFormat stringFormat, out int charactersFitted, out int linesFilled)
		{
			if (text == null || text.Length == 0)
			{
				charactersFitted = 0;
				linesFilled = 0;
				return new SizeF(0f, 0f);
			}
			if (font == null)
			{
				throw new ArgumentNullException("font");
			}
			GPRECTF layoutRect = new GPRECTF(0f, 0f, layoutArea.Width, layoutArea.Height);
			GPRECTF boundingBox = default(GPRECTF);
			int num = SafeNativeMethods.Gdip.GdipMeasureString(new HandleRef(this, NativeGraphics), text, text.Length, new HandleRef(font, font.NativeFont), ref layoutRect, new HandleRef(stringFormat, stringFormat?.nativeFormat ?? IntPtr.Zero), ref boundingBox, out charactersFitted, out linesFilled);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return boundingBox.SizeF;
		}

		public SizeF MeasureString(string text, Font font, PointF origin, StringFormat stringFormat)
		{
			if (text == null || text.Length == 0)
			{
				return new SizeF(0f, 0f);
			}
			if (font == null)
			{
				throw new ArgumentNullException("font");
			}
			GPRECTF layoutRect = default(GPRECTF);
			GPRECTF boundingBox = default(GPRECTF);
			layoutRect.X = origin.X;
			layoutRect.Y = origin.Y;
			layoutRect.Width = 0f;
			layoutRect.Height = 0f;
			int codepointsFitted;
			int linesFilled;
			int num = SafeNativeMethods.Gdip.GdipMeasureString(new HandleRef(this, NativeGraphics), text, text.Length, new HandleRef(font, font.NativeFont), ref layoutRect, new HandleRef(stringFormat, stringFormat?.nativeFormat ?? IntPtr.Zero), ref boundingBox, out codepointsFitted, out linesFilled);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return boundingBox.SizeF;
		}

		public SizeF MeasureString(string text, Font font, SizeF layoutArea)
		{
			return MeasureString(text, font, layoutArea, null);
		}

		public SizeF MeasureString(string text, Font font, SizeF layoutArea, StringFormat stringFormat)
		{
			if (text == null || text.Length == 0)
			{
				return new SizeF(0f, 0f);
			}
			if (font == null)
			{
				throw new ArgumentNullException("font");
			}
			GPRECTF layoutRect = new GPRECTF(0f, 0f, layoutArea.Width, layoutArea.Height);
			GPRECTF boundingBox = default(GPRECTF);
			int codepointsFitted;
			int linesFilled;
			int num = SafeNativeMethods.Gdip.GdipMeasureString(new HandleRef(this, NativeGraphics), text, text.Length, new HandleRef(font, font.NativeFont), ref layoutRect, new HandleRef(stringFormat, stringFormat?.nativeFormat ?? IntPtr.Zero), ref boundingBox, out codepointsFitted, out linesFilled);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return boundingBox.SizeF;
		}

		public SizeF MeasureString(string text, Font font)
		{
			return MeasureString(text, font, new SizeF(0f, 0f));
		}

		public SizeF MeasureString(string text, Font font, int width)
		{
			return MeasureString(text, font, new SizeF(width, 999999f));
		}

		public SizeF MeasureString(string text, Font font, int width, StringFormat format)
		{
			return MeasureString(text, font, new SizeF(width, 999999f), format);
		}

		public Region[] MeasureCharacterRanges(string text, Font font, RectangleF layoutRect, StringFormat stringFormat)
		{
			if (text == null || text.Length == 0)
			{
				return new Region[0];
			}
			if (font == null)
			{
				throw new ArgumentNullException("font");
			}
			int num = SafeNativeMethods.Gdip.GdipGetStringFormatMeasurableCharacterRangeCount(new HandleRef(stringFormat, stringFormat?.nativeFormat ?? IntPtr.Zero), out var count);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			IntPtr[] array = new IntPtr[count];
			GPRECTF layoutRect2 = new GPRECTF(layoutRect);
			Region[] array2 = new Region[count];
			for (int i = 0; i < count; i++)
			{
				array2[i] = new Region();
				ref IntPtr reference = ref array[i];
				reference = array2[i].nativeRegion;
			}
			num = SafeNativeMethods.Gdip.GdipMeasureCharacterRanges(new HandleRef(this, NativeGraphics), text, text.Length, new HandleRef(font, font.NativeFont), ref layoutRect2, new HandleRef(stringFormat, stringFormat?.nativeFormat ?? IntPtr.Zero), count, array);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return array2;
		}

		public void DrawIcon(Icon icon, int x, int y)
		{
			if (icon == null)
			{
				throw new ArgumentNullException("icon");
			}
			if (backingImage != null)
			{
				DrawImage(icon.ToBitmap(), x, y);
			}
			else
			{
				icon.Draw(this, x, y);
			}
		}

		public void DrawIcon(Icon icon, Rectangle targetRect)
		{
			if (icon == null)
			{
				throw new ArgumentNullException("icon");
			}
			if (backingImage != null)
			{
				DrawImage(icon.ToBitmap(), targetRect);
			}
			else
			{
				icon.Draw(this, targetRect);
			}
		}

		public void DrawIconUnstretched(Icon icon, Rectangle targetRect)
		{
			if (icon == null)
			{
				throw new ArgumentNullException("icon");
			}
			if (backingImage != null)
			{
				DrawImageUnscaled(icon.ToBitmap(), targetRect);
			}
			else
			{
				icon.DrawUnstretched(this, targetRect);
			}
		}

		public void DrawImage(Image image, PointF point)
		{
			DrawImage(image, point.X, point.Y);
		}

		public void DrawImage(Image image, float x, float y)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			int errorStatus = SafeNativeMethods.Gdip.GdipDrawImage(new HandleRef(this, NativeGraphics), new HandleRef(image, image.nativeImage), x, y);
			IgnoreMetafileErrors(image, ref errorStatus);
			CheckErrorStatus(errorStatus);
		}

		public void DrawImage(Image image, RectangleF rect)
		{
			DrawImage(image, rect.X, rect.Y, rect.Width, rect.Height);
		}

		public void DrawImage(Image image, float x, float y, float width, float height)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			int errorStatus = SafeNativeMethods.Gdip.GdipDrawImageRect(new HandleRef(this, NativeGraphics), new HandleRef(image, image.nativeImage), x, y, width, height);
			IgnoreMetafileErrors(image, ref errorStatus);
			CheckErrorStatus(errorStatus);
		}

		public void DrawImage(Image image, Point point)
		{
			DrawImage(image, point.X, point.Y);
		}

		public void DrawImage(Image image, int x, int y)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			int errorStatus = SafeNativeMethods.Gdip.GdipDrawImageI(new HandleRef(this, NativeGraphics), new HandleRef(image, image.nativeImage), x, y);
			IgnoreMetafileErrors(image, ref errorStatus);
			CheckErrorStatus(errorStatus);
		}

		public void DrawImage(Image image, Rectangle rect)
		{
			DrawImage(image, rect.X, rect.Y, rect.Width, rect.Height);
		}

		public void DrawImage(Image image, int x, int y, int width, int height)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			int errorStatus = SafeNativeMethods.Gdip.GdipDrawImageRectI(new HandleRef(this, NativeGraphics), new HandleRef(image, image.nativeImage), x, y, width, height);
			IgnoreMetafileErrors(image, ref errorStatus);
			CheckErrorStatus(errorStatus);
		}

		public void DrawImageUnscaled(Image image, Point point)
		{
			DrawImage(image, point.X, point.Y);
		}

		public void DrawImageUnscaled(Image image, int x, int y)
		{
			DrawImage(image, x, y);
		}

		public void DrawImageUnscaled(Image image, Rectangle rect)
		{
			DrawImage(image, rect.X, rect.Y);
		}

		public void DrawImageUnscaled(Image image, int x, int y, int width, int height)
		{
			DrawImage(image, x, y);
		}

		public void DrawImageUnscaledAndClipped(Image image, Rectangle rect)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			int srcWidth = Math.Min(rect.Width, image.Width);
			int srcHeight = Math.Min(rect.Height, image.Height);
			DrawImage(image, rect, 0, 0, srcWidth, srcHeight, GraphicsUnit.Pixel);
		}

		public void DrawImage(Image image, PointF[] destPoints)
		{
			if (destPoints == null)
			{
				throw new ArgumentNullException("destPoints");
			}
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			int num = destPoints.Length;
			if (num != 3 && num != 4)
			{
				throw new ArgumentException(SR.GetString("GdiplusDestPointsInvalidLength"));
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(destPoints);
			int errorStatus = SafeNativeMethods.Gdip.GdipDrawImagePoints(new HandleRef(this, NativeGraphics), new HandleRef(image, image.nativeImage), new HandleRef(this, intPtr), num);
			Marshal.FreeHGlobal(intPtr);
			IgnoreMetafileErrors(image, ref errorStatus);
			CheckErrorStatus(errorStatus);
		}

		public void DrawImage(Image image, Point[] destPoints)
		{
			if (destPoints == null)
			{
				throw new ArgumentNullException("destPoints");
			}
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			int num = destPoints.Length;
			if (num != 3 && num != 4)
			{
				throw new ArgumentException(SR.GetString("GdiplusDestPointsInvalidLength"));
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(destPoints);
			int errorStatus = SafeNativeMethods.Gdip.GdipDrawImagePointsI(new HandleRef(this, NativeGraphics), new HandleRef(image, image.nativeImage), new HandleRef(this, intPtr), num);
			Marshal.FreeHGlobal(intPtr);
			IgnoreMetafileErrors(image, ref errorStatus);
			CheckErrorStatus(errorStatus);
		}

		public void DrawImage(Image image, float x, float y, RectangleF srcRect, GraphicsUnit srcUnit)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			int errorStatus = SafeNativeMethods.Gdip.GdipDrawImagePointRect(new HandleRef(this, NativeGraphics), new HandleRef(image, image.nativeImage), x, y, srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, (int)srcUnit);
			IgnoreMetafileErrors(image, ref errorStatus);
			CheckErrorStatus(errorStatus);
		}

		public void DrawImage(Image image, int x, int y, Rectangle srcRect, GraphicsUnit srcUnit)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			int errorStatus = SafeNativeMethods.Gdip.GdipDrawImagePointRectI(new HandleRef(this, NativeGraphics), new HandleRef(image, image.nativeImage), x, y, srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, (int)srcUnit);
			IgnoreMetafileErrors(image, ref errorStatus);
			CheckErrorStatus(errorStatus);
		}

		public void DrawImage(Image image, RectangleF destRect, RectangleF srcRect, GraphicsUnit srcUnit)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			int errorStatus = SafeNativeMethods.Gdip.GdipDrawImageRectRect(new HandleRef(this, NativeGraphics), new HandleRef(image, image.nativeImage), destRect.X, destRect.Y, destRect.Width, destRect.Height, srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, (int)srcUnit, NativeMethods.NullHandleRef, null, NativeMethods.NullHandleRef);
			IgnoreMetafileErrors(image, ref errorStatus);
			CheckErrorStatus(errorStatus);
		}

		public void DrawImage(Image image, Rectangle destRect, Rectangle srcRect, GraphicsUnit srcUnit)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			int errorStatus = SafeNativeMethods.Gdip.GdipDrawImageRectRectI(new HandleRef(this, NativeGraphics), new HandleRef(image, image.nativeImage), destRect.X, destRect.Y, destRect.Width, destRect.Height, srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, (int)srcUnit, NativeMethods.NullHandleRef, null, NativeMethods.NullHandleRef);
			IgnoreMetafileErrors(image, ref errorStatus);
			CheckErrorStatus(errorStatus);
		}

		public void DrawImage(Image image, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit)
		{
			if (destPoints == null)
			{
				throw new ArgumentNullException("destPoints");
			}
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			int num = destPoints.Length;
			if (num != 3 && num != 4)
			{
				throw new ArgumentException(SR.GetString("GdiplusDestPointsInvalidLength"));
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(destPoints);
			int errorStatus = SafeNativeMethods.Gdip.GdipDrawImagePointsRect(new HandleRef(this, NativeGraphics), new HandleRef(image, image.nativeImage), new HandleRef(this, intPtr), destPoints.Length, srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, (int)srcUnit, NativeMethods.NullHandleRef, null, NativeMethods.NullHandleRef);
			Marshal.FreeHGlobal(intPtr);
			IgnoreMetafileErrors(image, ref errorStatus);
			CheckErrorStatus(errorStatus);
		}

		public void DrawImage(Image image, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr)
		{
			DrawImage(image, destPoints, srcRect, srcUnit, imageAttr, null, 0);
		}

		public void DrawImage(Image image, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr, DrawImageAbort callback)
		{
			DrawImage(image, destPoints, srcRect, srcUnit, imageAttr, callback, 0);
		}

		public void DrawImage(Image image, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr, DrawImageAbort callback, int callbackData)
		{
			if (destPoints == null)
			{
				throw new ArgumentNullException("destPoints");
			}
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			int num = destPoints.Length;
			if (num != 3 && num != 4)
			{
				throw new ArgumentException(SR.GetString("GdiplusDestPointsInvalidLength"));
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(destPoints);
			int errorStatus = SafeNativeMethods.Gdip.GdipDrawImagePointsRect(new HandleRef(this, NativeGraphics), new HandleRef(image, image.nativeImage), new HandleRef(this, intPtr), destPoints.Length, srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, (int)srcUnit, new HandleRef(imageAttr, imageAttr?.nativeImageAttributes ?? IntPtr.Zero), callback, new HandleRef(null, (IntPtr)callbackData));
			Marshal.FreeHGlobal(intPtr);
			IgnoreMetafileErrors(image, ref errorStatus);
			CheckErrorStatus(errorStatus);
		}

		public void DrawImage(Image image, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit)
		{
			DrawImage(image, destPoints, srcRect, srcUnit, null, null, 0);
		}

		public void DrawImage(Image image, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr)
		{
			DrawImage(image, destPoints, srcRect, srcUnit, imageAttr, null, 0);
		}

		public void DrawImage(Image image, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr, DrawImageAbort callback)
		{
			DrawImage(image, destPoints, srcRect, srcUnit, imageAttr, callback, 0);
		}

		public void DrawImage(Image image, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr, DrawImageAbort callback, int callbackData)
		{
			if (destPoints == null)
			{
				throw new ArgumentNullException("destPoints");
			}
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			int num = destPoints.Length;
			if (num != 3 && num != 4)
			{
				throw new ArgumentException(SR.GetString("GdiplusDestPointsInvalidLength"));
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(destPoints);
			int errorStatus = SafeNativeMethods.Gdip.GdipDrawImagePointsRectI(new HandleRef(this, NativeGraphics), new HandleRef(image, image.nativeImage), new HandleRef(this, intPtr), destPoints.Length, srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, (int)srcUnit, new HandleRef(imageAttr, imageAttr?.nativeImageAttributes ?? IntPtr.Zero), callback, new HandleRef(null, (IntPtr)callbackData));
			Marshal.FreeHGlobal(intPtr);
			IgnoreMetafileErrors(image, ref errorStatus);
			CheckErrorStatus(errorStatus);
		}

		public void DrawImage(Image image, Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, GraphicsUnit srcUnit)
		{
			DrawImage(image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, null);
		}

		public void DrawImage(Image image, Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttrs)
		{
			DrawImage(image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttrs, null);
		}

		public void DrawImage(Image image, Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttrs, DrawImageAbort callback)
		{
			DrawImage(image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttrs, callback, IntPtr.Zero);
		}

		public void DrawImage(Image image, Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttrs, DrawImageAbort callback, IntPtr callbackData)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			int errorStatus = SafeNativeMethods.Gdip.GdipDrawImageRectRect(new HandleRef(this, NativeGraphics), new HandleRef(image, image.nativeImage), destRect.X, destRect.Y, destRect.Width, destRect.Height, srcX, srcY, srcWidth, srcHeight, (int)srcUnit, new HandleRef(imageAttrs, imageAttrs?.nativeImageAttributes ?? IntPtr.Zero), callback, new HandleRef(null, callbackData));
			IgnoreMetafileErrors(image, ref errorStatus);
			CheckErrorStatus(errorStatus);
		}

		public void DrawImage(Image image, Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, GraphicsUnit srcUnit)
		{
			DrawImage(image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, null);
		}

		public void DrawImage(Image image, Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttr)
		{
			DrawImage(image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttr, null);
		}

		public void DrawImage(Image image, Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttr, DrawImageAbort callback)
		{
			DrawImage(image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttr, callback, IntPtr.Zero);
		}

		public void DrawImage(Image image, Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttrs, DrawImageAbort callback, IntPtr callbackData)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			int errorStatus = SafeNativeMethods.Gdip.GdipDrawImageRectRectI(new HandleRef(this, NativeGraphics), new HandleRef(image, image.nativeImage), destRect.X, destRect.Y, destRect.Width, destRect.Height, srcX, srcY, srcWidth, srcHeight, (int)srcUnit, new HandleRef(imageAttrs, imageAttrs?.nativeImageAttributes ?? IntPtr.Zero), callback, new HandleRef(null, callbackData));
			IgnoreMetafileErrors(image, ref errorStatus);
			CheckErrorStatus(errorStatus);
		}

		public void EnumerateMetafile(Metafile metafile, PointF destPoint, EnumerateMetafileProc callback)
		{
			EnumerateMetafile(metafile, destPoint, callback, IntPtr.Zero);
		}

		public void EnumerateMetafile(Metafile metafile, PointF destPoint, EnumerateMetafileProc callback, IntPtr callbackData)
		{
			EnumerateMetafile(metafile, destPoint, callback, callbackData, null);
		}

		public void EnumerateMetafile(Metafile metafile, PointF destPoint, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr)
		{
			IntPtr handle = metafile?.nativeImage ?? IntPtr.Zero;
			IntPtr handle2 = imageAttr?.nativeImageAttributes ?? IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipEnumerateMetafileDestPoint(new HandleRef(this, NativeGraphics), new HandleRef(metafile, handle), new GPPOINTF(destPoint), callback, new HandleRef(null, callbackData), new HandleRef(imageAttr, handle2));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void EnumerateMetafile(Metafile metafile, Point destPoint, EnumerateMetafileProc callback)
		{
			EnumerateMetafile(metafile, destPoint, callback, IntPtr.Zero);
		}

		public void EnumerateMetafile(Metafile metafile, Point destPoint, EnumerateMetafileProc callback, IntPtr callbackData)
		{
			EnumerateMetafile(metafile, destPoint, callback, callbackData, null);
		}

		public void EnumerateMetafile(Metafile metafile, Point destPoint, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr)
		{
			IntPtr handle = metafile?.nativeImage ?? IntPtr.Zero;
			IntPtr handle2 = imageAttr?.nativeImageAttributes ?? IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipEnumerateMetafileDestPointI(new HandleRef(this, NativeGraphics), new HandleRef(metafile, handle), new GPPOINT(destPoint), callback, new HandleRef(null, callbackData), new HandleRef(imageAttr, handle2));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void EnumerateMetafile(Metafile metafile, RectangleF destRect, EnumerateMetafileProc callback)
		{
			EnumerateMetafile(metafile, destRect, callback, IntPtr.Zero);
		}

		public void EnumerateMetafile(Metafile metafile, RectangleF destRect, EnumerateMetafileProc callback, IntPtr callbackData)
		{
			EnumerateMetafile(metafile, destRect, callback, callbackData, null);
		}

		public void EnumerateMetafile(Metafile metafile, RectangleF destRect, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr)
		{
			IntPtr handle = metafile?.nativeImage ?? IntPtr.Zero;
			IntPtr handle2 = imageAttr?.nativeImageAttributes ?? IntPtr.Zero;
			GPRECTF destRect2 = new GPRECTF(destRect);
			int num = SafeNativeMethods.Gdip.GdipEnumerateMetafileDestRect(new HandleRef(this, NativeGraphics), new HandleRef(metafile, handle), ref destRect2, callback, new HandleRef(null, callbackData), new HandleRef(imageAttr, handle2));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void EnumerateMetafile(Metafile metafile, Rectangle destRect, EnumerateMetafileProc callback)
		{
			EnumerateMetafile(metafile, destRect, callback, IntPtr.Zero);
		}

		public void EnumerateMetafile(Metafile metafile, Rectangle destRect, EnumerateMetafileProc callback, IntPtr callbackData)
		{
			EnumerateMetafile(metafile, destRect, callback, callbackData, null);
		}

		public void EnumerateMetafile(Metafile metafile, Rectangle destRect, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr)
		{
			IntPtr handle = metafile?.nativeImage ?? IntPtr.Zero;
			IntPtr handle2 = imageAttr?.nativeImageAttributes ?? IntPtr.Zero;
			GPRECT destRect2 = new GPRECT(destRect);
			int num = SafeNativeMethods.Gdip.GdipEnumerateMetafileDestRectI(new HandleRef(this, NativeGraphics), new HandleRef(metafile, handle), ref destRect2, callback, new HandleRef(null, callbackData), new HandleRef(imageAttr, handle2));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void EnumerateMetafile(Metafile metafile, PointF[] destPoints, EnumerateMetafileProc callback)
		{
			EnumerateMetafile(metafile, destPoints, callback, IntPtr.Zero);
		}

		public void EnumerateMetafile(Metafile metafile, PointF[] destPoints, EnumerateMetafileProc callback, IntPtr callbackData)
		{
			EnumerateMetafile(metafile, destPoints, callback, IntPtr.Zero, null);
		}

		public void EnumerateMetafile(Metafile metafile, PointF[] destPoints, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr)
		{
			if (destPoints == null)
			{
				throw new ArgumentNullException("destPoints");
			}
			if (destPoints.Length != 3)
			{
				throw new ArgumentException(SR.GetString("GdiplusDestPointsInvalidParallelogram"));
			}
			IntPtr handle = metafile?.nativeImage ?? IntPtr.Zero;
			IntPtr handle2 = imageAttr?.nativeImageAttributes ?? IntPtr.Zero;
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(destPoints);
			int num = SafeNativeMethods.Gdip.GdipEnumerateMetafileDestPoints(new HandleRef(this, NativeGraphics), new HandleRef(metafile, handle), intPtr, destPoints.Length, callback, new HandleRef(null, callbackData), new HandleRef(imageAttr, handle2));
			Marshal.FreeHGlobal(intPtr);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void EnumerateMetafile(Metafile metafile, Point[] destPoints, EnumerateMetafileProc callback)
		{
			EnumerateMetafile(metafile, destPoints, callback, IntPtr.Zero);
		}

		public void EnumerateMetafile(Metafile metafile, Point[] destPoints, EnumerateMetafileProc callback, IntPtr callbackData)
		{
			EnumerateMetafile(metafile, destPoints, callback, callbackData, null);
		}

		public void EnumerateMetafile(Metafile metafile, Point[] destPoints, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr)
		{
			if (destPoints == null)
			{
				throw new ArgumentNullException("destPoints");
			}
			if (destPoints.Length != 3)
			{
				throw new ArgumentException(SR.GetString("GdiplusDestPointsInvalidParallelogram"));
			}
			IntPtr handle = metafile?.nativeImage ?? IntPtr.Zero;
			IntPtr handle2 = imageAttr?.nativeImageAttributes ?? IntPtr.Zero;
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(destPoints);
			int num = SafeNativeMethods.Gdip.GdipEnumerateMetafileDestPointsI(new HandleRef(this, NativeGraphics), new HandleRef(metafile, handle), intPtr, destPoints.Length, callback, new HandleRef(null, callbackData), new HandleRef(imageAttr, handle2));
			Marshal.FreeHGlobal(intPtr);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void EnumerateMetafile(Metafile metafile, PointF destPoint, RectangleF srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback)
		{
			EnumerateMetafile(metafile, destPoint, srcRect, srcUnit, callback, IntPtr.Zero);
		}

		public void EnumerateMetafile(Metafile metafile, PointF destPoint, RectangleF srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback, IntPtr callbackData)
		{
			EnumerateMetafile(metafile, destPoint, srcRect, srcUnit, callback, callbackData, null);
		}

		public void EnumerateMetafile(Metafile metafile, PointF destPoint, RectangleF srcRect, GraphicsUnit unit, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr)
		{
			IntPtr handle = metafile?.nativeImage ?? IntPtr.Zero;
			IntPtr handle2 = imageAttr?.nativeImageAttributes ?? IntPtr.Zero;
			GPRECTF srcRect2 = new GPRECTF(srcRect);
			int num = SafeNativeMethods.Gdip.GdipEnumerateMetafileSrcRectDestPoint(new HandleRef(this, NativeGraphics), new HandleRef(metafile, handle), new GPPOINTF(destPoint), ref srcRect2, (int)unit, callback, new HandleRef(null, callbackData), new HandleRef(imageAttr, handle2));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void EnumerateMetafile(Metafile metafile, Point destPoint, Rectangle srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback)
		{
			EnumerateMetafile(metafile, destPoint, srcRect, srcUnit, callback, IntPtr.Zero);
		}

		public void EnumerateMetafile(Metafile metafile, Point destPoint, Rectangle srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback, IntPtr callbackData)
		{
			EnumerateMetafile(metafile, destPoint, srcRect, srcUnit, callback, callbackData, null);
		}

		public void EnumerateMetafile(Metafile metafile, Point destPoint, Rectangle srcRect, GraphicsUnit unit, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr)
		{
			IntPtr handle = metafile?.nativeImage ?? IntPtr.Zero;
			IntPtr handle2 = imageAttr?.nativeImageAttributes ?? IntPtr.Zero;
			GPPOINT destPoint2 = new GPPOINT(destPoint);
			GPRECT srcRect2 = new GPRECT(srcRect);
			int num = SafeNativeMethods.Gdip.GdipEnumerateMetafileSrcRectDestPointI(new HandleRef(this, NativeGraphics), new HandleRef(metafile, handle), destPoint2, ref srcRect2, (int)unit, callback, new HandleRef(null, callbackData), new HandleRef(imageAttr, handle2));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void EnumerateMetafile(Metafile metafile, RectangleF destRect, RectangleF srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback)
		{
			EnumerateMetafile(metafile, destRect, srcRect, srcUnit, callback, IntPtr.Zero);
		}

		public void EnumerateMetafile(Metafile metafile, RectangleF destRect, RectangleF srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback, IntPtr callbackData)
		{
			EnumerateMetafile(metafile, destRect, srcRect, srcUnit, callback, callbackData, null);
		}

		public void EnumerateMetafile(Metafile metafile, RectangleF destRect, RectangleF srcRect, GraphicsUnit unit, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr)
		{
			IntPtr handle = metafile?.nativeImage ?? IntPtr.Zero;
			IntPtr handle2 = imageAttr?.nativeImageAttributes ?? IntPtr.Zero;
			GPRECTF destRect2 = new GPRECTF(destRect);
			GPRECTF srcRect2 = new GPRECTF(srcRect);
			int num = SafeNativeMethods.Gdip.GdipEnumerateMetafileSrcRectDestRect(new HandleRef(this, NativeGraphics), new HandleRef(metafile, handle), ref destRect2, ref srcRect2, (int)unit, callback, new HandleRef(null, callbackData), new HandleRef(imageAttr, handle2));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void EnumerateMetafile(Metafile metafile, Rectangle destRect, Rectangle srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback)
		{
			EnumerateMetafile(metafile, destRect, srcRect, srcUnit, callback, IntPtr.Zero);
		}

		public void EnumerateMetafile(Metafile metafile, Rectangle destRect, Rectangle srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback, IntPtr callbackData)
		{
			EnumerateMetafile(metafile, destRect, srcRect, srcUnit, callback, callbackData, null);
		}

		public void EnumerateMetafile(Metafile metafile, Rectangle destRect, Rectangle srcRect, GraphicsUnit unit, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr)
		{
			IntPtr handle = metafile?.nativeImage ?? IntPtr.Zero;
			IntPtr handle2 = imageAttr?.nativeImageAttributes ?? IntPtr.Zero;
			GPRECT destRect2 = new GPRECT(destRect);
			GPRECT srcRect2 = new GPRECT(srcRect);
			int num = SafeNativeMethods.Gdip.GdipEnumerateMetafileSrcRectDestRectI(new HandleRef(this, NativeGraphics), new HandleRef(metafile, handle), ref destRect2, ref srcRect2, (int)unit, callback, new HandleRef(null, callbackData), new HandleRef(imageAttr, handle2));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void EnumerateMetafile(Metafile metafile, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback)
		{
			EnumerateMetafile(metafile, destPoints, srcRect, srcUnit, callback, IntPtr.Zero);
		}

		public void EnumerateMetafile(Metafile metafile, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback, IntPtr callbackData)
		{
			EnumerateMetafile(metafile, destPoints, srcRect, srcUnit, callback, callbackData, null);
		}

		public void EnumerateMetafile(Metafile metafile, PointF[] destPoints, RectangleF srcRect, GraphicsUnit unit, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr)
		{
			if (destPoints == null)
			{
				throw new ArgumentNullException("destPoints");
			}
			if (destPoints.Length != 3)
			{
				throw new ArgumentException(SR.GetString("GdiplusDestPointsInvalidParallelogram"));
			}
			IntPtr handle = metafile?.nativeImage ?? IntPtr.Zero;
			IntPtr handle2 = imageAttr?.nativeImageAttributes ?? IntPtr.Zero;
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(destPoints);
			GPRECTF srcRect2 = new GPRECTF(srcRect);
			int num = SafeNativeMethods.Gdip.GdipEnumerateMetafileSrcRectDestPoints(new HandleRef(this, NativeGraphics), new HandleRef(metafile, handle), intPtr, destPoints.Length, ref srcRect2, (int)unit, callback, new HandleRef(null, callbackData), new HandleRef(imageAttr, handle2));
			Marshal.FreeHGlobal(intPtr);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void EnumerateMetafile(Metafile metafile, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback)
		{
			EnumerateMetafile(metafile, destPoints, srcRect, srcUnit, callback, IntPtr.Zero);
		}

		public void EnumerateMetafile(Metafile metafile, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback, IntPtr callbackData)
		{
			EnumerateMetafile(metafile, destPoints, srcRect, srcUnit, callback, callbackData, null);
		}

		public void EnumerateMetafile(Metafile metafile, Point[] destPoints, Rectangle srcRect, GraphicsUnit unit, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr)
		{
			if (destPoints == null)
			{
				throw new ArgumentNullException("destPoints");
			}
			if (destPoints.Length != 3)
			{
				throw new ArgumentException(SR.GetString("GdiplusDestPointsInvalidParallelogram"));
			}
			IntPtr handle = metafile?.nativeImage ?? IntPtr.Zero;
			IntPtr handle2 = imageAttr?.nativeImageAttributes ?? IntPtr.Zero;
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(destPoints);
			GPRECT srcRect2 = new GPRECT(srcRect);
			int num = SafeNativeMethods.Gdip.GdipEnumerateMetafileSrcRectDestPointsI(new HandleRef(this, NativeGraphics), new HandleRef(metafile, handle), intPtr, destPoints.Length, ref srcRect2, (int)unit, callback, new HandleRef(null, callbackData), new HandleRef(imageAttr, handle2));
			Marshal.FreeHGlobal(intPtr);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void SetClip(Graphics g)
		{
			SetClip(g, CombineMode.Replace);
		}

		public void SetClip(Graphics g, CombineMode combineMode)
		{
			if (g == null)
			{
				throw new ArgumentNullException("g");
			}
			int num = SafeNativeMethods.Gdip.GdipSetClipGraphics(new HandleRef(this, NativeGraphics), new HandleRef(g, g.NativeGraphics), combineMode);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void SetClip(Rectangle rect)
		{
			SetClip(rect, CombineMode.Replace);
		}

		public void SetClip(Rectangle rect, CombineMode combineMode)
		{
			int num = SafeNativeMethods.Gdip.GdipSetClipRectI(new HandleRef(this, NativeGraphics), rect.X, rect.Y, rect.Width, rect.Height, combineMode);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void SetClip(RectangleF rect)
		{
			SetClip(rect, CombineMode.Replace);
		}

		public void SetClip(RectangleF rect, CombineMode combineMode)
		{
			int num = SafeNativeMethods.Gdip.GdipSetClipRect(new HandleRef(this, NativeGraphics), rect.X, rect.Y, rect.Width, rect.Height, combineMode);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void SetClip(GraphicsPath path)
		{
			SetClip(path, CombineMode.Replace);
		}

		public void SetClip(GraphicsPath path, CombineMode combineMode)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			int num = SafeNativeMethods.Gdip.GdipSetClipPath(new HandleRef(this, NativeGraphics), new HandleRef(path, path.nativePath), combineMode);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void SetClip(Region region, CombineMode combineMode)
		{
			if (region == null)
			{
				throw new ArgumentNullException("region");
			}
			int num = SafeNativeMethods.Gdip.GdipSetClipRegion(new HandleRef(this, NativeGraphics), new HandleRef(region, region.nativeRegion), combineMode);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void IntersectClip(Rectangle rect)
		{
			int num = SafeNativeMethods.Gdip.GdipSetClipRectI(new HandleRef(this, NativeGraphics), rect.X, rect.Y, rect.Width, rect.Height, CombineMode.Intersect);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void IntersectClip(RectangleF rect)
		{
			int num = SafeNativeMethods.Gdip.GdipSetClipRect(new HandleRef(this, NativeGraphics), rect.X, rect.Y, rect.Width, rect.Height, CombineMode.Intersect);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void IntersectClip(Region region)
		{
			if (region == null)
			{
				throw new ArgumentNullException("region");
			}
			int num = SafeNativeMethods.Gdip.GdipSetClipRegion(new HandleRef(this, NativeGraphics), new HandleRef(region, region.nativeRegion), CombineMode.Intersect);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void ExcludeClip(Rectangle rect)
		{
			int num = SafeNativeMethods.Gdip.GdipSetClipRectI(new HandleRef(this, NativeGraphics), rect.X, rect.Y, rect.Width, rect.Height, CombineMode.Exclude);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void ExcludeClip(Region region)
		{
			if (region == null)
			{
				throw new ArgumentNullException("region");
			}
			int num = SafeNativeMethods.Gdip.GdipSetClipRegion(new HandleRef(this, NativeGraphics), new HandleRef(region, region.nativeRegion), CombineMode.Exclude);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void ResetClip()
		{
			int num = SafeNativeMethods.Gdip.GdipResetClip(new HandleRef(this, NativeGraphics));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void TranslateClip(float dx, float dy)
		{
			int num = SafeNativeMethods.Gdip.GdipTranslateClip(new HandleRef(this, NativeGraphics), dx, dy);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void TranslateClip(int dx, int dy)
		{
			int num = SafeNativeMethods.Gdip.GdipTranslateClip(new HandleRef(this, NativeGraphics), dx, dy);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[StrongNameIdentityPermission(SecurityAction.LinkDemand, Name = "System.Windows.Forms", PublicKey = "0x00000000000000000400000000000000")]
		public object GetContextInfo()
		{
			Region clip = Clip;
			Matrix transform = Transform;
			PointF pointF = PointF.Empty;
			PointF empty = PointF.Empty;
			if (!transform.IsIdentity)
			{
				float[] elements = transform.Elements;
				pointF.X = elements[4];
				pointF.Y = elements[5];
			}
			GraphicsContext previous = previousContext;
			while (previous != null)
			{
				if (!previous.TransformOffset.IsEmpty)
				{
					transform.Translate(previous.TransformOffset.X, previous.TransformOffset.Y);
				}
				if (!pointF.IsEmpty)
				{
					clip.Translate(pointF.X, pointF.Y);
					empty.X += pointF.X;
					empty.Y += pointF.Y;
				}
				if (previous.Clip != null)
				{
					clip.Intersect(previous.Clip);
				}
				pointF = previous.TransformOffset;
				do
				{
					previous = previous.Previous;
				}
				while (previous != null && previous.Next.IsCumulative && previous.IsCumulative);
			}
			if (!empty.IsEmpty)
			{
				clip.Translate(0f - empty.X, 0f - empty.Y);
			}
			return new object[2] { clip, transform };
		}

		public bool IsVisible(int x, int y)
		{
			return IsVisible(new Point(x, y));
		}

		public bool IsVisible(Point point)
		{
			int boolean;
			int num = SafeNativeMethods.Gdip.GdipIsVisiblePointI(new HandleRef(this, NativeGraphics), point.X, point.Y, out boolean);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return boolean != 0;
		}

		public bool IsVisible(float x, float y)
		{
			return IsVisible(new PointF(x, y));
		}

		public bool IsVisible(PointF point)
		{
			int boolean;
			int num = SafeNativeMethods.Gdip.GdipIsVisiblePoint(new HandleRef(this, NativeGraphics), point.X, point.Y, out boolean);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return boolean != 0;
		}

		public bool IsVisible(int x, int y, int width, int height)
		{
			return IsVisible(new Rectangle(x, y, width, height));
		}

		public bool IsVisible(Rectangle rect)
		{
			int boolean;
			int num = SafeNativeMethods.Gdip.GdipIsVisibleRectI(new HandleRef(this, NativeGraphics), rect.X, rect.Y, rect.Width, rect.Height, out boolean);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return boolean != 0;
		}

		public bool IsVisible(float x, float y, float width, float height)
		{
			return IsVisible(new RectangleF(x, y, width, height));
		}

		public bool IsVisible(RectangleF rect)
		{
			int boolean;
			int num = SafeNativeMethods.Gdip.GdipIsVisibleRect(new HandleRef(this, NativeGraphics), rect.X, rect.Y, rect.Width, rect.Height, out boolean);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return boolean != 0;
		}

		private void PushContext(GraphicsContext context)
		{
			if (previousContext != null)
			{
				context.Previous = previousContext;
				previousContext.Next = context;
			}
			previousContext = context;
		}

		private void PopContext(int currentContextState)
		{
			for (GraphicsContext previous = previousContext; previous != null; previous = previous.Previous)
			{
				if (previous.State == currentContextState)
				{
					previousContext = previous.Previous;
					previous.Dispose();
					break;
				}
			}
		}

		public GraphicsState Save()
		{
			GraphicsContext graphicsContext = new GraphicsContext(this);
			int state = 0;
			int num = SafeNativeMethods.Gdip.GdipSaveGraphics(new HandleRef(this, NativeGraphics), out state);
			if (num != 0)
			{
				graphicsContext.Dispose();
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			graphicsContext.State = state;
			graphicsContext.IsCumulative = true;
			PushContext(graphicsContext);
			return new GraphicsState(state);
		}

		public void Restore(GraphicsState gstate)
		{
			int num = SafeNativeMethods.Gdip.GdipRestoreGraphics(new HandleRef(this, NativeGraphics), gstate.nativeState);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			PopContext(gstate.nativeState);
		}

		public GraphicsContainer BeginContainer(RectangleF dstrect, RectangleF srcrect, GraphicsUnit unit)
		{
			GraphicsContext graphicsContext = new GraphicsContext(this);
			int state = 0;
			GPRECTF dstRect = dstrect.ToGPRECTF();
			GPRECTF srcRect = srcrect.ToGPRECTF();
			int num = SafeNativeMethods.Gdip.GdipBeginContainer(new HandleRef(this, NativeGraphics), ref dstRect, ref srcRect, (int)unit, out state);
			if (num != 0)
			{
				graphicsContext.Dispose();
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			graphicsContext.State = state;
			PushContext(graphicsContext);
			return new GraphicsContainer(state);
		}

		public GraphicsContainer BeginContainer()
		{
			GraphicsContext graphicsContext = new GraphicsContext(this);
			int state = 0;
			int num = SafeNativeMethods.Gdip.GdipBeginContainer2(new HandleRef(this, NativeGraphics), out state);
			if (num != 0)
			{
				graphicsContext.Dispose();
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			graphicsContext.State = state;
			PushContext(graphicsContext);
			return new GraphicsContainer(state);
		}

		public void EndContainer(GraphicsContainer container)
		{
			if (container == null)
			{
				throw new ArgumentNullException("container");
			}
			int num = SafeNativeMethods.Gdip.GdipEndContainer(new HandleRef(this, NativeGraphics), container.nativeGraphicsContainer);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			PopContext(container.nativeGraphicsContainer);
		}

		public GraphicsContainer BeginContainer(Rectangle dstrect, Rectangle srcrect, GraphicsUnit unit)
		{
			GraphicsContext graphicsContext = new GraphicsContext(this);
			int state = 0;
			GPRECT dstRect = new GPRECT(dstrect);
			GPRECT srcRect = new GPRECT(srcrect);
			int num = SafeNativeMethods.Gdip.GdipBeginContainerI(new HandleRef(this, NativeGraphics), ref dstRect, ref srcRect, (int)unit, out state);
			if (num != 0)
			{
				graphicsContext.Dispose();
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			graphicsContext.State = state;
			PushContext(graphicsContext);
			return new GraphicsContainer(state);
		}

		public void AddMetafileComment(byte[] data)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			int num = SafeNativeMethods.Gdip.GdipComment(new HandleRef(this, NativeGraphics), data.Length, data);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public static IntPtr GetHalftonePalette()
		{
			if (halftonePalette == IntPtr.Zero)
			{
				lock (syncObject)
				{
					if (halftonePalette == IntPtr.Zero)
					{
						if (Environment.OSVersion.Platform != PlatformID.Win32Windows)
						{
							AppDomain.CurrentDomain.DomainUnload += OnDomainUnload;
						}
						AppDomain.CurrentDomain.ProcessExit += OnDomainUnload;
						halftonePalette = SafeNativeMethods.Gdip.GdipCreateHalftonePalette();
					}
				}
			}
			return halftonePalette;
		}

		[PrePrepareMethod]
		private static void OnDomainUnload(object sender, EventArgs e)
		{
			if (halftonePalette != IntPtr.Zero)
			{
				SafeNativeMethods.IntDeleteObject(new HandleRef(null, halftonePalette));
				halftonePalette = IntPtr.Zero;
			}
		}

		private void CheckErrorStatus(int status)
		{
			switch (status)
			{
			case 1:
			case 7:
			{
				int lastWin32Error = Marshal.GetLastWin32Error();
				if (lastWin32Error == 5 || lastWin32Error == 127 || (((uint)UnsafeNativeMethods.GetSystemMetrics(4096) & (true ? 1u : 0u)) != 0 && lastWin32Error == 0))
				{
					return;
				}
				break;
			}
			case 0:
				return;
			}
			throw SafeNativeMethods.Gdip.StatusException(status);
		}

		private void IgnoreMetafileErrors(Image image, ref int errorStatus)
		{
			if (errorStatus != 0 && image.RawFormat.Equals(ImageFormat.Emf))
			{
				errorStatus = 0;
			}
		}
	}
	[Serializable]
	[TypeConverter(typeof(IconConverter))]
	[Editor("System.Drawing.Design.IconEditor, System.Drawing.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(UITypeEditor))]
	public sealed class Icon : MarshalByRefObject, ISerializable, ICloneable, IDisposable
	{
		private static int bitDepth;

		private byte[] iconData;

		private int bestImageOffset;

		private int bestBitDepth;

		private Size iconSize = Size.Empty;

		private IntPtr handle = IntPtr.Zero;

		private bool ownHandle = true;

		[Browsable(false)]
		public IntPtr Handle
		{
			get
			{
				if (handle == IntPtr.Zero)
				{
					throw new ObjectDisposedException(GetType().Name);
				}
				return handle;
			}
		}

		[Browsable(false)]
		public int Height => Size.Height;

		public Size Size
		{
			get
			{
				if (iconSize.IsEmpty)
				{
					SafeNativeMethods.ICONINFO iCONINFO = new SafeNativeMethods.ICONINFO();
					SafeNativeMethods.GetIconInfo(new HandleRef(this, Handle), iCONINFO);
					SafeNativeMethods.BITMAP bITMAP = new SafeNativeMethods.BITMAP();
					if (iCONINFO.hbmColor != IntPtr.Zero)
					{
						SafeNativeMethods.GetObject(new HandleRef(null, iCONINFO.hbmColor), Marshal.SizeOf(typeof(SafeNativeMethods.BITMAP)), bITMAP);
						SafeNativeMethods.IntDeleteObject(new HandleRef(null, iCONINFO.hbmColor));
						iconSize = new Size(bITMAP.bmWidth, bITMAP.bmHeight);
					}
					else if (iCONINFO.hbmMask != IntPtr.Zero)
					{
						SafeNativeMethods.GetObject(new HandleRef(null, iCONINFO.hbmMask), Marshal.SizeOf(typeof(SafeNativeMethods.BITMAP)), bITMAP);
						iconSize = new Size(bITMAP.bmWidth, bITMAP.bmHeight / 2);
					}
					if (iCONINFO.hbmMask != IntPtr.Zero)
					{
						SafeNativeMethods.IntDeleteObject(new HandleRef(null, iCONINFO.hbmMask));
					}
				}
				return iconSize;
			}
		}

		[Browsable(false)]
		public int Width => Size.Width;

		private Icon()
		{
		}

		internal Icon(IntPtr handle)
			: this(handle, takeOwnership: false)
		{
		}

		internal Icon(IntPtr handle, bool takeOwnership)
		{
			if (handle == IntPtr.Zero)
			{
				throw new ArgumentException(SR.GetString("InvalidGDIHandle", typeof(Icon).Name));
			}
			this.handle = handle;
			ownHandle = takeOwnership;
		}

		public Icon(string fileName)
			: this(fileName, 0, 0)
		{
		}

		public Icon(string fileName, Size size)
			: this(fileName, size.Width, size.Height)
		{
		}

		public Icon(string fileName, int width, int height)
			: this()
		{
			using (FileStream fileStream = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read))
			{
				iconData = new byte[(int)fileStream.Length];
				fileStream.Read(iconData, 0, iconData.Length);
			}
			Initialize(width, height);
		}

		public Icon(Icon original, Size size)
			: this(original, size.Width, size.Height)
		{
		}

		public Icon(Icon original, int width, int height)
			: this()
		{
			if (original == null)
			{
				throw new ArgumentException(SR.GetString("InvalidArgument", "original", "null"));
			}
			iconData = original.iconData;
			if (iconData == null)
			{
				iconSize = original.Size;
				handle = SafeNativeMethods.CopyImage(new HandleRef(original, original.Handle), 1, iconSize.Width, iconSize.Height, 0);
			}
			else
			{
				Initialize(width, height);
			}
		}

		public Icon(Type type, string resource)
			: this()
		{
			Stream manifestResourceStream = type.Module.Assembly.GetManifestResourceStream(type, resource);
			if (manifestResourceStream == null)
			{
				throw new ArgumentException(SR.GetString("ResourceNotFound", type, resource));
			}
			iconData = new byte[(int)manifestResourceStream.Length];
			manifestResourceStream.Read(iconData, 0, iconData.Length);
			Initialize(0, 0);
		}

		public Icon(Stream stream)
			: this(stream, 0, 0)
		{
		}

		public Icon(Stream stream, Size size)
			: this(stream, size.Width, size.Height)
		{
		}

		public Icon(Stream stream, int width, int height)
			: this()
		{
			if (stream == null)
			{
				throw new ArgumentException(SR.GetString("InvalidArgument", "stream", "null"));
			}
			iconData = new byte[(int)stream.Length];
			stream.Read(iconData, 0, iconData.Length);
			Initialize(width, height);
		}

		private Icon(SerializationInfo info, StreamingContext context)
		{
			iconData = (byte[])info.GetValue("IconData", typeof(byte[]));
			iconSize = (Size)info.GetValue("IconSize", typeof(Size));
			if (iconSize.IsEmpty)
			{
				Initialize(0, 0);
			}
			else
			{
				Initialize(iconSize.Width, iconSize.Height);
			}
		}

		public static Icon ExtractAssociatedIcon(string filePath)
		{
			return ExtractAssociatedIcon(filePath, 0);
		}

		private static Icon ExtractAssociatedIcon(string filePath, int index)
		{
			if (filePath == null)
			{
				throw new ArgumentException(SR.GetString("InvalidArgument", "filePath", "null"));
			}
			Uri uri;
			try
			{
				uri = new Uri(filePath);
			}
			catch (UriFormatException)
			{
				filePath = Path.GetFullPath(filePath);
				uri = new Uri(filePath);
			}
			if (uri.IsUnc)
			{
				throw new ArgumentException(SR.GetString("InvalidArgument", "filePath", filePath));
			}
			if (uri.IsFile)
			{
				if (!File.Exists(filePath))
				{
					IntSecurity.DemandReadFileIO(filePath);
					throw new FileNotFoundException(filePath);
				}
				Icon icon = new Icon();
				StringBuilder stringBuilder = new StringBuilder(260);
				stringBuilder.Append(filePath);
				IntPtr intPtr = SafeNativeMethods.ExtractAssociatedIcon(NativeMethods.NullHandleRef, stringBuilder, ref index);
				if (intPtr != IntPtr.Zero)
				{
					IntSecurity.ObjectFromWin32Handle.Demand();
					return new Icon(intPtr, takeOwnership: true);
				}
			}
			return null;
		}

		public object Clone()
		{
			return new Icon(this, Size.Width, Size.Height);
		}

		internal void DestroyHandle()
		{
			if (ownHandle)
			{
				SafeNativeMethods.DestroyIcon(new HandleRef(this, handle));
				handle = IntPtr.Zero;
			}
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		private void Dispose(bool disposing)
		{
			if (handle != IntPtr.Zero)
			{
				DestroyHandle();
			}
		}

		private void DrawIcon(IntPtr dc, Rectangle imageRect, Rectangle targetRect, bool stretch)
		{
			int num = 0;
			int num2 = 0;
			int num3 = 0;
			int num4 = 0;
			int num5 = 0;
			int num6 = 0;
			Size size = Size;
			int width;
			int height;
			if (!imageRect.IsEmpty)
			{
				num = imageRect.X;
				num2 = imageRect.Y;
				width = imageRect.Width;
				height = imageRect.Height;
			}
			else
			{
				width = size.Width;
				height = size.Height;
			}
			if (!targetRect.IsEmpty)
			{
				num3 = targetRect.X;
				num4 = targetRect.Y;
				num5 = targetRect.Width;
				num6 = targetRect.Height;
			}
			else
			{
				num5 = size.Width;
				num6 = size.Height;
			}
			int width2;
			int height2;
			int num7;
			int num8;
			if (stretch)
			{
				width2 = size.Width * num5 / width;
				height2 = size.Height * num6 / height;
				num7 = num5;
				num8 = num6;
			}
			else
			{
				width2 = size.Width;
				height2 = size.Height;
				num7 = ((num5 < width) ? num5 : width);
				num8 = ((num6 < height) ? num6 : height);
			}
			IntPtr hRgn = SafeNativeMethods.SaveClipRgn(dc);
			try
			{
				SafeNativeMethods.IntersectClipRect(new HandleRef(this, dc), num3, num4, num3 + num7, num4 + num8);
				SafeNativeMethods.DrawIconEx(new HandleRef(null, dc), num3 - num, num4 - num2, new HandleRef(this, handle), width2, height2, 0, NativeMethods.NullHandleRef, 3);
			}
			finally
			{
				SafeNativeMethods.RestoreClipRgn(dc, hRgn);
			}
		}

		internal void Draw(Graphics graphics, int x, int y)
		{
			Size size = Size;
			Draw(graphics, new Rectangle(x, y, size.Width, size.Height));
		}

		internal void Draw(Graphics graphics, Rectangle targetRect)
		{
			Rectangle targetRect2 = targetRect;
			targetRect2.X += (int)graphics.Transform.OffsetX;
			targetRect2.Y += (int)graphics.Transform.OffsetY;
			WindowsGraphics windowsGraphics = WindowsGraphics.FromGraphics(graphics, ApplyGraphicsProperties.Clipping);
			IntPtr hdc = windowsGraphics.GetHdc();
			try
			{
				DrawIcon(hdc, Rectangle.Empty, targetRect2, stretch: true);
			}
			finally
			{
				windowsGraphics.Dispose();
			}
		}

		internal void DrawUnstretched(Graphics graphics, Rectangle targetRect)
		{
			Rectangle targetRect2 = targetRect;
			targetRect2.X += (int)graphics.Transform.OffsetX;
			targetRect2.Y += (int)graphics.Transform.OffsetY;
			WindowsGraphics windowsGraphics = WindowsGraphics.FromGraphics(graphics, ApplyGraphicsProperties.Clipping);
			IntPtr hdc = windowsGraphics.GetHdc();
			try
			{
				DrawIcon(hdc, Rectangle.Empty, targetRect2, stretch: false);
			}
			finally
			{
				windowsGraphics.Dispose();
			}
		}

		~Icon()
		{
			Dispose(disposing: false);
		}

		public static Icon FromHandle(IntPtr handle)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			return new Icon(handle);
		}

		private unsafe short GetShort(byte* pb)
		{
			int num = 0;
			if (((uint)(byte)pb & (true ? 1u : 0u)) != 0)
			{
				num = *pb;
				pb++;
				num |= *pb << 8;
			}
			else
			{
				num = *(short*)pb;
			}
			return (short)num;
		}

		private unsafe int GetInt(byte* pb)
		{
			int num = 0;
			if (((byte)pb & 3u) != 0)
			{
				num = *pb;
				pb++;
				num |= *pb << 8;
				pb++;
				num |= *pb << 16;
				pb++;
				return num | (*pb << 24);
			}
			return *(int*)pb;
		}

		private unsafe void Initialize(int width, int height)
		{
			if (iconData == null || handle != IntPtr.Zero)
			{
				throw new InvalidOperationException(SR.GetString("IllegalState", GetType().Name));
			}
			int num = Marshal.SizeOf(typeof(SafeNativeMethods.ICONDIR));
			if (iconData.Length < num)
			{
				throw new ArgumentException(SR.GetString("InvalidPictureType", "picture", "Icon"));
			}
			if (width == 0)
			{
				width = UnsafeNativeMethods.GetSystemMetrics(11);
			}
			if (height == 0)
			{
				height = UnsafeNativeMethods.GetSystemMetrics(12);
			}
			if (bitDepth == 0)
			{
				IntPtr dC = UnsafeNativeMethods.GetDC(NativeMethods.NullHandleRef);
				bitDepth = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(null, dC), 12);
				bitDepth *= UnsafeNativeMethods.GetDeviceCaps(new HandleRef(null, dC), 14);
				UnsafeNativeMethods.ReleaseDC(NativeMethods.NullHandleRef, new HandleRef(null, dC));
				if (bitDepth == 8)
				{
					bitDepth = 4;
				}
			}
			fixed (byte* ptr = iconData)
			{
				short @short = GetShort(ptr);
				short short2 = GetShort(ptr + 2);
				short short3 = GetShort(ptr + 4);
				if (@short != 0 || short2 != 1 || short3 == 0)
				{
					throw new ArgumentException(SR.GetString("InvalidPictureType", "picture", "Icon"));
				}
				byte b = 0;
				byte b2 = 0;
				int num2 = 0;
				byte* ptr2 = ptr + 6;
				int num3 = Marshal.SizeOf(typeof(SafeNativeMethods.ICONDIRENTRY));
				if (num3 * (short3 - 1) + num > iconData.Length)
				{
					throw new ArgumentException(SR.GetString("InvalidPictureType", "picture", "Icon"));
				}
				SafeNativeMethods.ICONDIRENTRY iCONDIRENTRY = default(SafeNativeMethods.ICONDIRENTRY);
				for (int i = 0; i < short3; i++)
				{
					iCONDIRENTRY.bWidth = *ptr2;
					iCONDIRENTRY.bHeight = ptr2[1];
					iCONDIRENTRY.bColorCount = ptr2[2];
					iCONDIRENTRY.bReserved = ptr2[3];
					iCONDIRENTRY.wPlanes = GetShort(ptr2 + 4);
					iCONDIRENTRY.wBitCount = GetShort(ptr2 + 6);
					iCONDIRENTRY.dwBytesInRes = GetInt(ptr2 + 8);
					iCONDIRENTRY.dwImageOffset = GetInt(ptr2 + 12);
					bool flag = false;
					int num4 = 0;
					if (iCONDIRENTRY.bColorCount != 0)
					{
						num4 = 4;
						if (iCONDIRENTRY.bColorCount < 16)
						{
							num4 = 1;
						}
					}
					else
					{
						num4 = iCONDIRENTRY.wBitCount;
					}
					if (num4 == 0)
					{
						num4 = 8;
					}
					if (num2 == 0)
					{
						flag = true;
					}
					else
					{
						int num5 = Math.Abs(b - width) + Math.Abs(b2 - height);
						int num6 = Math.Abs(iCONDIRENTRY.bWidth - width) + Math.Abs(iCONDIRENTRY.bHeight - height);
						if (num6 < num5 || (num6 == num5 && ((num4 <= bitDepth && num4 > bestBitDepth) || (bestBitDepth > bitDepth && num4 < bestBitDepth))))
						{
							flag = true;
						}
					}
					if (flag)
					{
						b = iCONDIRENTRY.bWidth;
						b2 = iCONDIRENTRY.bHeight;
						bestImageOffset = iCONDIRENTRY.dwImageOffset;
						num2 = iCONDIRENTRY.dwBytesInRes;
						bestBitDepth = num4;
					}
					ptr2 += num3;
				}
				if (bestImageOffset < 0)
				{
					throw new ArgumentException(SR.GetString("InvalidPictureType", "picture", "Icon"));
				}
				if (num2 < 0)
				{
					throw new Win32Exception(87);
				}
				int num7;
				try
				{
					num7 = checked(bestImageOffset + num2);
				}
				catch (OverflowException)
				{
					throw new Win32Exception(87);
				}
				if (num7 > iconData.Length)
				{
					throw new ArgumentException(SR.GetString("InvalidPictureType", "picture", "Icon"));
				}
				if (bestImageOffset % IntPtr.Size != 0)
				{
					byte[] array = new byte[num2];
					Array.Copy(iconData, bestImageOffset, array, 0, num2);
					fixed (byte* pbIconBits = array)
					{
						handle = SafeNativeMethods.CreateIconFromResourceEx(pbIconBits, num2, fIcon: true, 196608, 0, 0, 0);
					}
				}
				else
				{
					try
					{
						handle = SafeNativeMethods.CreateIconFromResourceEx((byte*)checked(unchecked((ulong)ptr) + unchecked((ulong)bestImageOffset)), num2, fIcon: true, 196608, 0, 0, 0);
					}
					catch (OverflowException)
					{
						throw new Win32Exception(87);
					}
				}
				if (handle == IntPtr.Zero)
				{
					throw new Win32Exception();
				}
			}
		}

		public void Save(Stream outputStream)
		{
			if (iconData != null)
			{
				outputStream.Write(iconData, 0, iconData.Length);
				return;
			}
			SafeNativeMethods.PICTDESC pictdesc = SafeNativeMethods.PICTDESC.CreateIconPICTDESC(Handle);
			Guid refiid = typeof(SafeNativeMethods.IPicture).GUID;
			SafeNativeMethods.IPicture picture = SafeNativeMethods.OleCreatePictureIndirect(pictdesc, ref refiid, fOwn: false);
			if (picture == null)
			{
				return;
			}
			try
			{
				picture.SaveAsFile(new UnsafeNativeMethods.ComStreamFromDataStream(outputStream), -1, out var _);
			}
			finally
			{
				Marshal.ReleaseComObject(picture);
			}
		}

		private void CopyBitmapData(BitmapData sourceData, BitmapData targetData)
		{
			int num = 0;
			int num2 = 0;
			for (int i = 0; i < Math.Min(sourceData.Height, targetData.Height); i++)
			{
				IntPtr intPtr;
				IntPtr intPtr2;
				if (IntPtr.Size == 4)
				{
					intPtr = new IntPtr(sourceData.Scan0.ToInt32() + num);
					intPtr2 = new IntPtr(targetData.Scan0.ToInt32() + num2);
				}
				else
				{
					intPtr = new IntPtr(sourceData.Scan0.ToInt64() + num);
					intPtr2 = new IntPtr(targetData.Scan0.ToInt64() + num2);
				}
				UnsafeNativeMethods.CopyMemory(new HandleRef(this, intPtr2), new HandleRef(this, intPtr), Math.Abs(targetData.Stride));
				num += sourceData.Stride;
				num2 += targetData.Stride;
			}
		}

		private unsafe static bool BitmapHasAlpha(BitmapData bmpData)
		{
			bool result = false;
			for (int i = 0; i < bmpData.Height; i++)
			{
				int num = 3;
				while (num < Math.Abs(bmpData.Stride))
				{
					byte* ptr = (byte*)bmpData.Scan0.ToPointer() + (long)i * (long)bmpData.Stride + num;
					if (*ptr == 0)
					{
						num += 4;
						continue;
					}
					goto IL_002a;
				}
				continue;
				IL_002a:
				result = true;
				break;
			}
			return result;
		}

		public unsafe Bitmap ToBitmap()
		{
			Bitmap bitmap = null;
			if (iconData != null && bestBitDepth == 32)
			{
				bitmap = new Bitmap(Size.Width, Size.Height, PixelFormat.Format32bppArgb);
				BitmapData bitmapData = bitmap.LockBits(new Rectangle(0, 0, Size.Width, Size.Height), ImageLockMode.WriteOnly, PixelFormat.Format32bppArgb);
				try
				{
					uint* ptr = (uint*)bitmapData.Scan0.ToPointer();
					int num = bestImageOffset + Marshal.SizeOf(typeof(SafeNativeMethods.BITMAPINFOHEADER));
					int length = Size.Width * 4;
					int width = Size.Width;
					for (int num2 = (Size.Height - 1) * 4; num2 >= 0; num2 -= 4)
					{
						Marshal.Copy(iconData, num + num2 * width, (IntPtr)ptr, length);
						ptr += width;
					}
				}
				finally
				{
					bitmap.UnlockBits(bitmapData);
				}
			}
			else if (bestBitDepth == 0 || bestBitDepth == 32)
			{
				SafeNativeMethods.ICONINFO iCONINFO = new SafeNativeMethods.ICONINFO();
				SafeNativeMethods.GetIconInfo(new HandleRef(this, handle), iCONINFO);
				SafeNativeMethods.BITMAP bITMAP = new SafeNativeMethods.BITMAP();
				try
				{
					if (iCONINFO.hbmColor != IntPtr.Zero)
					{
						SafeNativeMethods.GetObject(new HandleRef(null, iCONINFO.hbmColor), Marshal.SizeOf(typeof(SafeNativeMethods.BITMAP)), bITMAP);
						if (bITMAP.bmBitsPixel == 32)
						{
							Bitmap bitmap2 = null;
							BitmapData bitmapData2 = null;
							BitmapData bitmapData3 = null;
							IntSecurity.ObjectFromWin32Handle.Assert();
							try
							{
								bitmap2 = Image.FromHbitmap(iCONINFO.hbmColor);
								bitmapData2 = bitmap2.LockBits(new Rectangle(0, 0, bitmap2.Width, bitmap2.Height), ImageLockMode.ReadOnly, bitmap2.PixelFormat);
								if (BitmapHasAlpha(bitmapData2))
								{
									bitmap = new Bitmap(bitmapData2.Width, bitmapData2.Height, PixelFormat.Format32bppArgb);
									bitmapData3 = bitmap.LockBits(new Rectangle(0, 0, bitmapData2.Width, bitmapData2.Height), ImageLockMode.WriteOnly, PixelFormat.Format32bppArgb);
									CopyBitmapData(bitmapData2, bitmapData3);
								}
							}
							finally
							{
								CodeAccessPermission.RevertAssert();
								if (bitmap2 != null && bitmapData2 != null)
								{
									bitmap2.UnlockBits(bitmapData2);
								}
								if (bitmap != null && bitmapData3 != null)
								{
									bitmap.UnlockBits(bitmapData3);
								}
							}
							bitmap2.Dispose();
						}
					}
				}
				finally
				{
					if (iCONINFO.hbmColor != IntPtr.Zero)
					{
						SafeNativeMethods.IntDeleteObject(new HandleRef(null, iCONINFO.hbmColor));
					}
					if (iCONINFO.hbmMask != IntPtr.Zero)
					{
						SafeNativeMethods.IntDeleteObject(new HandleRef(null, iCONINFO.hbmMask));
					}
				}
			}
			if (bitmap == null)
			{
				Size size = Size;
				bitmap = new Bitmap(size.Width, size.Height);
				Graphics graphics = null;
				try
				{
					graphics = Graphics.FromImage(bitmap);
					IntSecurity.ObjectFromWin32Handle.Assert();
					try
					{
						using Bitmap image = Bitmap.FromHicon(Handle);
						graphics.DrawImage(image, new Rectangle(0, 0, size.Width, size.Height));
					}
					catch (ArgumentException)
					{
						Draw(graphics, new Rectangle(0, 0, size.Width, size.Height));
					}
					finally
					{
						CodeAccessPermission.RevertAssert();
					}
				}
				finally
				{
					graphics?.Dispose();
				}
				Color transparentColor = Color.FromArgb(13, 11, 12);
				bitmap.MakeTransparent(transparentColor);
			}
			return bitmap;
		}

		public override string ToString()
		{
			return SR.GetString("toStringIcon");
		}

		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
		void ISerializable.GetObjectData(SerializationInfo si, StreamingContext context)
		{
			if (iconData != null)
			{
				si.AddValue("IconData", iconData, typeof(byte[]));
			}
			else
			{
				MemoryStream memoryStream = new MemoryStream();
				Save(memoryStream);
				si.AddValue("IconData", memoryStream.ToArray(), typeof(byte[]));
			}
			si.AddValue("IconSize", iconSize, typeof(Size));
		}
	}
	public class IconConverter : ExpandableObjectConverter
	{
		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
		{
			if (sourceType == typeof(byte[]))
			{
				return true;
			}
			if (sourceType == typeof(InstanceDescriptor))
			{
				return false;
			}
			return base.CanConvertFrom(context, sourceType);
		}

		public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
		{
			if (destinationType == typeof(Image) || destinationType == typeof(Bitmap))
			{
				return true;
			}
			if (destinationType == typeof(byte[]))
			{
				return true;
			}
			return base.CanConvertTo(context, destinationType);
		}

		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
		{
			if (value is byte[])
			{
				MemoryStream stream = new MemoryStream((byte[])value);
				return new Icon(stream);
			}
			return base.ConvertFrom(context, culture, value);
		}

		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if ((destinationType == typeof(Image) || destinationType == typeof(Bitmap)) && value is Icon icon)
			{
				return icon.ToBitmap();
			}
			if (destinationType == typeof(string))
			{
				if (value != null)
				{
					return value.ToString();
				}
				return SR.GetString("toStringNone");
			}
			if (destinationType == typeof(byte[]))
			{
				if (value != null)
				{
					MemoryStream memoryStream = null;
					try
					{
						memoryStream = new MemoryStream();
						if (value is Icon icon2)
						{
							icon2.Save(memoryStream);
						}
					}
					finally
					{
						memoryStream?.Close();
					}
					return memoryStream?.ToArray();
				}
				return new byte[0];
			}
			return base.ConvertTo(context, culture, value, destinationType);
		}
	}
	public sealed class ImageAnimator
	{
		private class ImageInfo
		{
			private const int PropertyTagFrameDelay = 20736;

			private Image image;

			private int frame;

			private int frameCount;

			private bool frameDirty;

			private bool animated;

			private EventHandler onFrameChangedHandler;

			private int[] frameDelay;

			private int frameTimer;

			public bool Animated => animated;

			public int Frame
			{
				get
				{
					return frame;
				}
				set
				{
					if (frame != value)
					{
						if (value < 0 || value >= FrameCount)
						{
							throw new ArgumentException(SR.GetString("InvalidFrame"), "value");
						}
						if (Animated)
						{
							frame = value;
							frameDirty = true;
							OnFrameChanged(EventArgs.Empty);
						}
					}
				}
			}

			public bool FrameDirty => frameDirty;

			public EventHandler FrameChangedHandler
			{
				get
				{
					return onFrameChangedHandler;
				}
				set
				{
					onFrameChangedHandler = value;
				}
			}

			public int FrameCount => frameCount;

			internal int FrameTimer
			{
				get
				{
					return frameTimer;
				}
				set
				{
					frameTimer = value;
				}
			}

			internal Image Image => image;

			public ImageInfo(Image image)
			{
				this.image = image;
				animated = CanAnimate(image);
				if (animated)
				{
					frameCount = image.GetFrameCount(FrameDimension.Time);
					PropertyItem propertyItem = image.GetPropertyItem(20736);
					if (propertyItem != null)
					{
						byte[] value = propertyItem.Value;
						frameDelay = new int[FrameCount];
						for (int i = 0; i < FrameCount; i++)
						{
							frameDelay[i] = value[i * 4] + 256 * value[i * 4 + 1] + 65536 * value[i * 4 + 2] + 16777216 * value[i * 4 + 3];
						}
					}
				}
				else
				{
					frameCount = 1;
				}
				if (frameDelay == null)
				{
					frameDelay = new int[FrameCount];
				}
			}

			public int FrameDelay(int frame)
			{
				return frameDelay[frame];
			}

			internal void UpdateFrame()
			{
				if (frameDirty)
				{
					image.SelectActiveFrame(FrameDimension.Time, Frame);
					frameDirty = false;
				}
			}

			protected void OnFrameChanged(EventArgs e)
			{
				if (onFrameChangedHandler != null)
				{
					onFrameChangedHandler(image, e);
				}
			}
		}

		private static List<ImageInfo> imageInfoList;

		private static bool anyFrameDirty;

		private static Thread animationThread;

		private static ReaderWriterLock rwImgListLock = new ReaderWriterLock();

		[ThreadStatic]
		private static int threadWriterLockWaitCount;

		private ImageAnimator()
		{
		}

		public static void UpdateFrames(Image image)
		{
			if (!anyFrameDirty || image == null || imageInfoList == null || threadWriterLockWaitCount > 0)
			{
				return;
			}
			rwImgListLock.AcquireReaderLock(-1);
			try
			{
				bool flag = false;
				bool flag2 = false;
				foreach (ImageInfo imageInfo in imageInfoList)
				{
					if (imageInfo.Image == image)
					{
						if (imageInfo.FrameDirty)
						{
							lock (imageInfo.Image)
							{
								imageInfo.UpdateFrame();
							}
						}
						flag2 = true;
					}
					if (imageInfo.FrameDirty)
					{
						flag = true;
					}
					if (flag && flag2)
					{
						break;
					}
				}
				anyFrameDirty = flag;
			}
			finally
			{
				rwImgListLock.ReleaseReaderLock();
			}
		}

		public static void UpdateFrames()
		{
			if (!anyFrameDirty || imageInfoList == null || threadWriterLockWaitCount > 0)
			{
				return;
			}
			rwImgListLock.AcquireReaderLock(-1);
			try
			{
				foreach (ImageInfo imageInfo in imageInfoList)
				{
					lock (imageInfo.Image)
					{
						imageInfo.UpdateFrame();
					}
				}
				anyFrameDirty = false;
			}
			finally
			{
				rwImgListLock.ReleaseReaderLock();
			}
		}

		public static void Animate(Image image, EventHandler onFrameChangedHandler)
		{
			if (image == null)
			{
				return;
			}
			ImageInfo imageInfo = null;
			lock (image)
			{
				imageInfo = new ImageInfo(image);
			}
			StopAnimate(image, onFrameChangedHandler);
			bool isReaderLockHeld = rwImgListLock.IsReaderLockHeld;
			LockCookie lockCookie = default(LockCookie);
			threadWriterLockWaitCount++;
			try
			{
				if (isReaderLockHeld)
				{
					lockCookie = rwImgListLock.UpgradeToWriterLock(-1);
				}
				else
				{
					rwImgListLock.AcquireWriterLock(-1);
				}
			}
			finally
			{
				threadWriterLockWaitCount--;
			}
			try
			{
				if (imageInfo.Animated)
				{
					if (imageInfoList == null)
					{
						imageInfoList = new List<ImageInfo>();
					}
					imageInfo.FrameChangedHandler = onFrameChangedHandler;
					imageInfoList.Add(imageInfo);
					if (animationThread == null)
					{
						animationThread = new Thread(AnimateImages50ms);
						animationThread.Name = typeof(ImageAnimator).Name;
						animationThread.IsBackground = true;
						animationThread.Start();
					}
				}
			}
			finally
			{
				if (isReaderLockHeld)
				{
					rwImgListLock.DowngradeFromWriterLock(ref lockCookie);
				}
				else
				{
					rwImgListLock.ReleaseWriterLock();
				}
			}
		}

		public static bool CanAnimate(Image image)
		{
			if (image == null)
			{
				return false;
			}
			lock (image)
			{
				Guid[] frameDimensionsList = image.FrameDimensionsList;
				Guid[] array = frameDimensionsList;
				foreach (Guid guid in array)
				{
					FrameDimension frameDimension = new FrameDimension(guid);
					if (frameDimension.Equals(FrameDimension.Time))
					{
						return image.GetFrameCount(FrameDimension.Time) > 1;
					}
				}
			}
			return false;
		}

		public static void StopAnimate(Image image, EventHandler onFrameChangedHandler)
		{
			if (image == null || imageInfoList == null)
			{
				return;
			}
			bool isReaderLockHeld = rwImgListLock.IsReaderLockHeld;
			LockCookie lockCookie = default(LockCookie);
			threadWriterLockWaitCount++;
			try
			{
				if (isReaderLockHeld)
				{
					lockCookie = rwImgListLock.UpgradeToWriterLock(-1);
				}
				else
				{
					rwImgListLock.AcquireWriterLock(-1);
				}
			}
			finally
			{
				threadWriterLockWaitCount--;
			}
			try
			{
				for (int i = 0; i < imageInfoList.Count; i++)
				{
					ImageInfo imageInfo = imageInfoList[i];
					if (image == imageInfo.Image)
					{
						if (onFrameChangedHandler == imageInfo.FrameChangedHandler || (onFrameChangedHandler != null && onFrameChangedHandler.Equals(imageInfo.FrameChangedHandler)))
						{
							imageInfoList.Remove(imageInfo);
						}
						break;
					}
				}
			}
			finally
			{
				if (isReaderLockHeld)
				{
					rwImgListLock.DowngradeFromWriterLock(ref lockCookie);
				}
				else
				{
					rwImgListLock.ReleaseWriterLock();
				}
			}
		}

		private static void AnimateImages50ms()
		{
			while (true)
			{
				rwImgListLock.AcquireReaderLock(-1);
				try
				{
					for (int i = 0; i < imageInfoList.Count; i++)
					{
						ImageInfo imageInfo = imageInfoList[i];
						imageInfo.FrameTimer += 5;
						if (imageInfo.FrameTimer >= imageInfo.FrameDelay(imageInfo.Frame))
						{
							imageInfo.FrameTimer = 0;
							if (imageInfo.Frame + 1 < imageInfo.FrameCount)
							{
								imageInfo.Frame++;
							}
							else
							{
								imageInfo.Frame = 0;
							}
							if (imageInfo.FrameDirty)
							{
								anyFrameDirty = true;
							}
						}
					}
				}
				finally
				{
					rwImgListLock.ReleaseReaderLock();
				}
				Thread.Sleep(50);
			}
		}
	}
	public class ImageConverter : TypeConverter
	{
		private Type iconType = typeof(Icon);

		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
		{
			if (sourceType == iconType)
			{
				return true;
			}
			if (sourceType == typeof(byte[]))
			{
				return true;
			}
			if (sourceType == typeof(InstanceDescriptor))
			{
				return false;
			}
			return base.CanConvertFrom(context, sourceType);
		}

		public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
		{
			if (destinationType == typeof(byte[]))
			{
				return true;
			}
			return base.CanConvertTo(context, destinationType);
		}

		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
		{
			if (value is Icon)
			{
				Icon icon = (Icon)value;
				return icon.ToBitmap();
			}
			if (value is byte[] array)
			{
				Stream stream = null;
				stream = GetBitmapStream(array);
				if (stream == null)
				{
					stream = new MemoryStream(array);
				}
				return Image.FromStream(stream);
			}
			return base.ConvertFrom(context, culture, value);
		}

		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (destinationType == typeof(string))
			{
				if (value != null)
				{
					Image image = (Image)value;
					return image.ToString();
				}
				return SR.GetString("toStringNone");
			}
			if (destinationType == typeof(byte[]))
			{
				if (value != null)
				{
					bool flag = false;
					MemoryStream memoryStream = null;
					Image image2 = null;
					try
					{
						memoryStream = new MemoryStream();
						image2 = (Image)value;
						if (image2.RawFormat.Equals(ImageFormat.Icon))
						{
							flag = true;
							image2 = new Bitmap(image2, image2.Width, image2.Height);
						}
						image2.Save(memoryStream);
					}
					finally
					{
						memoryStream?.Close();
						if (flag)
						{
							image2?.Dispose();
						}
					}
					return memoryStream?.ToArray();
				}
				return new byte[0];
			}
			return base.ConvertTo(context, culture, value, destinationType);
		}

		private unsafe Stream GetBitmapStream(byte[] rawData)
		{
			try
			{
				try
				{
					fixed (byte* ptr = rawData)
					{
						IntPtr intPtr = (IntPtr)ptr;
						if (intPtr == IntPtr.Zero)
						{
							return null;
						}
						if (rawData.Length <= sizeof(SafeNativeMethods.OBJECTHEADER) || Marshal.ReadInt16(intPtr) != 7189)
						{
							return null;
						}
						SafeNativeMethods.OBJECTHEADER oBJECTHEADER = (SafeNativeMethods.OBJECTHEADER)Marshal.PtrToStructure(intPtr, typeof(SafeNativeMethods.OBJECTHEADER));
						if (rawData.Length <= oBJECTHEADER.headersize + 18)
						{
							return null;
						}
						string @string = Encoding.ASCII.GetString(rawData, oBJECTHEADER.headersize + 12, 6);
						if (@string != "PBrush")
						{
							return null;
						}
						byte[] bytes = Encoding.ASCII.GetBytes("BM");
						for (int i = oBJECTHEADER.headersize + 18; i < oBJECTHEADER.headersize + 510 && i + 1 < rawData.Length; i++)
						{
							if (bytes[0] == ptr[i] && bytes[1] == ptr[i + 1])
							{
								return new MemoryStream(rawData, i, rawData.Length - i);
							}
						}
					}
				}
				finally
				{
				}
			}
			catch (OutOfMemoryException)
			{
			}
			catch (ArgumentException)
			{
			}
			return null;
		}

		public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
		{
			return TypeDescriptor.GetProperties(typeof(Image), attributes);
		}

		public override bool GetPropertiesSupported(ITypeDescriptorContext context)
		{
			return true;
		}
	}
	internal static class IntSecurity
	{
		private static readonly UIPermission AllWindows = new UIPermission(UIPermissionWindow.AllWindows);

		private static readonly UIPermission SafeSubWindows = new UIPermission(UIPermissionWindow.SafeSubWindows);

		public static readonly CodeAccessPermission UnmanagedCode = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);

		public static readonly CodeAccessPermission ObjectFromWin32Handle = UnmanagedCode;

		public static readonly CodeAccessPermission Win32HandleManipulation = UnmanagedCode;

		public static readonly PrintingPermission NoPrinting = new PrintingPermission(PrintingPermissionLevel.NoPrinting);

		public static readonly PrintingPermission SafePrinting = new PrintingPermission(PrintingPermissionLevel.SafePrinting);

		public static readonly PrintingPermission DefaultPrinting = new PrintingPermission(PrintingPermissionLevel.DefaultPrinting);

		public static readonly PrintingPermission AllPrinting = new PrintingPermission(PrintingPermissionLevel.AllPrinting);

		private static PermissionSet allPrintingAndUnmanagedCode;

		public static PermissionSet AllPrintingAndUnmanagedCode
		{
			get
			{
				if (allPrintingAndUnmanagedCode == null)
				{
					PermissionSet permissionSet = new PermissionSet(PermissionState.None);
					permissionSet.SetPermission(UnmanagedCode);
					permissionSet.SetPermission(AllPrinting);
					allPrintingAndUnmanagedCode = permissionSet;
				}
				return allPrintingAndUnmanagedCode;
			}
		}

		internal static void DemandReadFileIO(string fileName)
		{
			string text = fileName;
			text = UnsafeGetFullPath(fileName);
			new FileIOPermission(FileIOPermissionAccess.Read, text).Demand();
		}

		internal static void DemandWriteFileIO(string fileName)
		{
			string text = fileName;
			text = UnsafeGetFullPath(fileName);
			new FileIOPermission(FileIOPermissionAccess.Write, text).Demand();
		}

		internal static string UnsafeGetFullPath(string fileName)
		{
			FileIOPermission fileIOPermission = new FileIOPermission(PermissionState.None);
			fileIOPermission.AllFiles = FileIOPermissionAccess.PathDiscovery;
			fileIOPermission.Assert();
			try
			{
				return Path.GetFullPath(fileName);
			}
			finally
			{
				CodeAccessPermission.RevertAssert();
			}
		}

		internal static bool HasPermission(PrintingPermission permission)
		{
			try
			{
				permission.Demand();
				return true;
			}
			catch (SecurityException)
			{
				return false;
			}
		}
	}
	public enum KnownColor
	{
		ActiveBorder = 1,
		ActiveCaption,
		ActiveCaptionText,
		AppWorkspace,
		Control,
		ControlDark,
		ControlDarkDark,
		ControlLight,
		ControlLightLight,
		ControlText,
		Desktop,
		GrayText,
		Highlight,
		HighlightText,
		HotTrack,
		InactiveBorder,
		InactiveCaption,
		InactiveCaptionText,
		Info,
		InfoText,
		Menu,
		MenuText,
		ScrollBar,
		Window,
		WindowFrame,
		WindowText,
		Transparent,
		AliceBlue,
		AntiqueWhite,
		Aqua,
		Aquamarine,
		Azure,
		Beige,
		Bisque,
		Black,
		BlanchedAlmond,
		Blue,
		BlueViolet,
		Brown,
		BurlyWood,
		CadetBlue,
		Chartreuse,
		Chocolate,
		Coral,
		CornflowerBlue,
		Cornsilk,
		Crimson,
		Cyan,
		DarkBlue,
		DarkCyan,
		DarkGoldenrod,
		DarkGray,
		DarkGreen,
		DarkKhaki,
		DarkMagenta,
		DarkOliveGreen,
		DarkOrange,
		DarkOrchid,
		DarkRed,
		DarkSalmon,
		DarkSeaGreen,
		DarkSlateBlue,
		DarkSlateGray,
		DarkTurquoise,
		DarkViolet,
		DeepPink,
		DeepSkyBlue,
		DimGray,
		DodgerBlue,
		Firebrick,
		FloralWhite,
		ForestGreen,
		Fuchsia,
		Gainsboro,
		GhostWhite,
		Gold,
		Goldenrod,
		Gray,
		Green,
		GreenYellow,
		Honeydew,
		HotPink,
		IndianRed,
		Indigo,
		Ivory,
		Khaki,
		Lavender,
		LavenderBlush,
		LawnGreen,
		LemonChiffon,
		LightBlue,
		LightCoral,
		LightCyan,
		LightGoldenrodYellow,
		LightGray,
		LightGreen,
		LightPink,
		LightSalmon,
		LightSeaGreen,
		LightSkyBlue,
		LightSlateGray,
		LightSteelBlue,
		LightYellow,
		Lime,
		LimeGreen,
		Linen,
		Magenta,
		Maroon,
		MediumAquamarine,
		MediumBlue,
		MediumOrchid,
		MediumPurple,
		MediumSeaGreen,
		MediumSlateBlue,
		MediumSpringGreen,
		MediumTurquoise,
		MediumVioletRed,
		MidnightBlue,
		MintCream,
		MistyRose,
		Moccasin,
		NavajoWhite,
		Navy,
		OldLace,
		Olive,
		OliveDrab,
		Orange,
		OrangeRed,
		Orchid,
		PaleGoldenrod,
		PaleGreen,
		PaleTurquoise,
		PaleVioletRed,
		PapayaWhip,
		PeachPuff,
		Peru,
		Pink,
		Plum,
		PowderBlue,
		Purple,
		Red,
		RosyBrown,
		RoyalBlue,
		SaddleBrown,
		Salmon,
		SandyBrown,
		SeaGreen,
		SeaShell,
		Sienna,
		Silver,
		SkyBlue,
		SlateBlue,
		SlateGray,
		Snow,
		SpringGreen,
		SteelBlue,
		Tan,
		Teal,
		Thistle,
		Tomato,
		Turquoise,
		Violet,
		Wheat,
		White,
		WhiteSmoke,
		Yellow,
		YellowGreen,
		ButtonFace,
		ButtonHighlight,
		ButtonShadow,
		GradientActiveCaption,
		GradientInactiveCaption,
		MenuBar,
		MenuHighlight
	}
	internal static class KnownColorTable
	{
		private const int AlphaShift = 24;

		private const int RedShift = 16;

		private const int GreenShift = 8;

		private const int BlueShift = 0;

		private const int Win32RedShift = 0;

		private const int Win32GreenShift = 8;

		private const int Win32BlueShift = 16;

		private static int[] colorTable;

		private static string[] colorNameTable;

		public static Color ArgbToKnownColor(int targetARGB)
		{
			EnsureColorTable();
			for (int i = 0; i < colorTable.Length; i++)
			{
				int num = colorTable[i];
				if (num == targetARGB)
				{
					Color result = Color.FromKnownColor((KnownColor)i);
					if (!result.IsSystemColor)
					{
						return result;
					}
				}
			}
			return Color.FromArgb(targetARGB);
		}

		private static void EnsureColorTable()
		{
			if (colorTable == null)
			{
				InitColorTable();
			}
		}

		private static void InitColorTable()
		{
			int[] array = new int[175];
			SystemEvents.UserPreferenceChanging += OnUserPreferenceChanging;
			UpdateSystemColors(array);
			array[27] = 16777215;
			array[28] = -984833;
			array[29] = -332841;
			array[30] = -16711681;
			array[31] = -8388652;
			array[32] = -983041;
			array[33] = -657956;
			array[34] = -6972;
			array[35] = -16777216;
			array[36] = -5171;
			array[37] = -16776961;
			array[38] = -7722014;
			array[39] = -5952982;
			array[40] = -2180985;
			array[41] = -10510688;
			array[42] = -8388864;
			array[43] = -2987746;
			array[44] = -32944;
			array[45] = -10185235;
			array[46] = -1828;
			array[47] = -2354116;
			array[48] = -16711681;
			array[49] = -16777077;
			array[50] = -16741493;
			array[51] = -4684277;
			array[52] = -5658199;
			array[53] = -16751616;
			array[54] = -4343957;
			array[55] = -7667573;
			array[56] = -11179217;
			array[57] = -29696;
			array[58] = -6737204;
			array[59] = -7667712;
			array[60] = -1468806;
			array[61] = -7357301;
			array[62] = -12042869;
			array[63] = -13676721;
			array[64] = -16724271;
			array[65] = -7077677;
			array[66] = -60269;
			array[67] = -16728065;
			array[68] = -9868951;
			array[69] = -14774017;
			array[70] = -5103070;
			array[71] = -1296;
			array[72] = -14513374;
			array[73] = -65281;
			array[74] = -2302756;
			array[75] = -460545;
			array[76] = -10496;
			array[77] = -2448096;
			array[78] = -8355712;
			array[79] = -16744448;
			array[80] = -5374161;
			array[81] = -983056;
			array[82] = -38476;
			array[83] = -3318692;
			array[84] = -11861886;
			array[85] = -16;
			array[86] = -989556;
			array[87] = -1644806;
			array[88] = -3851;
			array[89] = -8586240;
			array[90] = -1331;
			array[91] = -5383962;
			array[92] = -1015680;
			array[93] = -2031617;
			array[94] = -329006;
			array[95] = -2894893;
			array[96] = -7278960;
			array[97] = -18751;
			array[98] = -24454;
			array[99] = -14634326;
			array[100] = -7876870;
			array[101] = -8943463;
			array[102] = -5192482;
			array[103] = -32;
			array[104] = -16711936;
			array[105] = -13447886;
			array[106] = -331546;
			array[107] = -65281;
			array[108] = -8388608;
			array[109] = -10039894;
			array[110] = -16777011;
			array[111] = -4565549;
			array[112] = -7114533;
			array[113] = -12799119;
			array[114] = -8689426;
			array[115] = -16713062;
			array[116] = -12004916;
			array[117] = -3730043;
			array[118] = -15132304;
			array[119] = -655366;
			array[120] = -6943;
			array[121] = -6987;
			array[122] = -8531;
			array[123] = -16777088;
			array[124] = -133658;
			array[125] = -8355840;
			array[126] = -9728477;
			array[127] = -23296;
			array[128] = -47872;
			array[129] = -2461482;
			array[130] = -1120086;
			array[131] = -6751336;
			array[132] = -5247250;
			array[133] = -2396013;
			array[134] = -4139;
			array[135] = -9543;
			array[136] = -3308225;
			array[137] = -16181;
			array[138] = -2252579;
			array[139] = -5185306;
			array[140] = -8388480;
			array[141] = -65536;
			array[142] = -4419697;
			array[143] = -12490271;
			array[144] = -7650029;
			array[145] = -360334;
			array[146] = -744352;
			array[147] = -13726889;
			array[148] = -2578;
			array[149] = -6270419;
			array[150] = -4144960;
			array[151] = -7876885;
			array[152] = -9807155;
			array[153] = -9404272;
			array[154] = -1286;
			array[155] = -16711809;
			array[156] = -12156236;
			array[157] = -2968436;
			array[158] = -16744320;
			array[159] = -2572328;
			array[160] = -40121;
			array[161] = -12525360;
			array[162] = -1146130;
			array[163] = -663885;
			array[164] = -1;
			array[165] = -657931;
			array[166] = -256;
			array[167] = -6632142;
			colorTable = array;
		}

		private static void EnsureColorNameTable()
		{
			if (colorNameTable == null)
			{
				InitColorNameTable();
			}
		}

		private static void InitColorNameTable()
		{
			string[] array = new string[175];
			array[1] = "ActiveBorder";
			array[2] = "ActiveCaption";
			array[3] = "ActiveCaptionText";
			array[4] = "AppWorkspace";
			array[168] = "ButtonFace";
			array[169] = "ButtonHighlight";
			array[170] = "ButtonShadow";
			array[5] = "Control";
			array[6] = "ControlDark";
			array[7] = "ControlDarkDark";
			array[8] = "ControlLight";
			array[9] = "ControlLightLight";
			array[10] = "ControlText";
			array[11] = "Desktop";
			array[171] = "GradientActiveCaption";
			array[172] = "GradientInactiveCaption";
			array[12] = "GrayText";
			array[13] = "Highlight";
			array[14] = "HighlightText";
			array[15] = "HotTrack";
			array[16] = "InactiveBorder";
			array[17] = "InactiveCaption";
			array[18] = "InactiveCaptionText";
			array[19] = "Info";
			array[20] = "InfoText";
			array[21] = "Menu";
			array[173] = "MenuBar";
			array[174] = "MenuHighlight";
			array[22] = "MenuText";
			array[23] = "ScrollBar";
			array[24] = "Window";
			array[25] = "WindowFrame";
			array[26] = "WindowText";
			array[27] = "Transparent";
			array[28] = "AliceBlue";
			array[29] = "AntiqueWhite";
			array[30] = "Aqua";
			array[31] = "Aquamarine";
			array[32] = "Azure";
			array[33] = "Beige";
			array[34] = "Bisque";
			array[35] = "Black";
			array[36] = "BlanchedAlmond";
			array[37] = "Blue";
			array[38] = "BlueViolet";
			array[39] = "Brown";
			array[40] = "BurlyWood";
			array[41] = "CadetBlue";
			array[42] = "Chartreuse";
			array[43] = "Chocolate";
			array[44] = "Coral";
			array[45] = "CornflowerBlue";
			array[46] = "Cornsilk";
			array[47] = "Crimson";
			array[48] = "Cyan";
			array[49] = "DarkBlue";
			array[50] = "DarkCyan";
			array[51] = "DarkGoldenrod";
			array[52] = "DarkGray";
			array[53] = "DarkGreen";
			array[54] = "DarkKhaki";
			array[55] = "DarkMagenta";
			array[56] = "DarkOliveGreen";
			array[57] = "DarkOrange";
			array[58] = "DarkOrchid";
			array[59] = "DarkRed";
			array[60] = "DarkSalmon";
			array[61] = "DarkSeaGreen";
			array[62] = "DarkSlateBlue";
			array[63] = "DarkSlateGray";
			array[64] = "DarkTurquoise";
			array[65] = "DarkViolet";
			array[66] = "DeepPink";
			array[67] = "DeepSkyBlue";
			array[68] = "DimGray";
			array[69] = "DodgerBlue";
			array[70] = "Firebrick";
			array[71] = "FloralWhite";
			array[72] = "ForestGreen";
			array[73] = "Fuchsia";
			array[74] = "Gainsboro";
			array[75] = "GhostWhite";
			array[76] = "Gold";
			array[77] = "Goldenrod";
			array[78] = "Gray";
			array[79] = "Green";
			array[80] = "GreenYellow";
			array[81] = "Honeydew";
			array[82] = "HotPink";
			array[83] = "IndianRed";
			array[84] = "Indigo";
			array[85] = "Ivory";
			array[86] = "Khaki";
			array[87] = "Lavender";
			array[88] = "LavenderBlush";
			array[89] = "LawnGreen";
			array[90] = "LemonChiffon";
			array[91] = "LightBlue";
			array[92] = "LightCoral";
			array[93] = "LightCyan";
			array[94] = "LightGoldenrodYellow";
			array[95] = "LightGray";
			array[96] = "LightGreen";
			array[97] = "LightPink";
			array[98] = "LightSalmon";
			array[99] = "LightSeaGreen";
			array[100] = "LightSkyBlue";
			array[101] = "LightSlateGray";
			array[102] = "LightSteelBlue";
			array[103] = "LightYellow";
			array[104] = "Lime";
			array[105] = "LimeGreen";
			array[106] = "Linen";
			array[107] = "Magenta";
			array[108] = "Maroon";
			array[109] = "MediumAquamarine";
			array[110] = "MediumBlue";
			array[111] = "MediumOrchid";
			array[112] = "MediumPurple";
			array[113] = "MediumSeaGreen";
			array[114] = "MediumSlateBlue";
			array[115] = "MediumSpringGreen";
			array[116] = "MediumTurquoise";
			array[117] = "MediumVioletRed";
			array[118] = "MidnightBlue";
			array[119] = "MintCream";
			array[120] = "MistyRose";
			array[121] = "Moccasin";
			array[122] = "NavajoWhite";
			array[123] = "Navy";
			array[124] = "OldLace";
			array[125] = "Olive";
			array[126] = "OliveDrab";
			array[127] = "Orange";
			array[128] = "OrangeRed";
			array[129] = "Orchid";
			array[130] = "PaleGoldenrod";
			array[131] = "PaleGreen";
			array[132] = "PaleTurquoise";
			array[133] = "PaleVioletRed";
			array[134] = "PapayaWhip";
			array[135] = "PeachPuff";
			array[136] = "Peru";
			array[137] = "Pink";
			array[138] = "Plum";
			array[139] = "PowderBlue";
			array[140] = "Purple";
			array[141] = "Red";
			array[142] = "RosyBrown";
			array[143] = "RoyalBlue";
			array[144] = "SaddleBrown";
			array[145] = "Salmon";
			array[146] = "SandyBrown";
			array[147] = "SeaGreen";
			array[148] = "SeaShell";
			array[149] = "Sienna";
			array[150] = "Silver";
			array[151] = "SkyBlue";
			array[152] = "SlateBlue";
			array[153] = "SlateGray";
			array[154] = "Snow";
			array[155] = "SpringGreen";
			array[156] = "SteelBlue";
			array[157] = "Tan";
			array[158] = "Teal";
			array[159] = "Thistle";
			array[160] = "Tomato";
			array[161] = "Turquoise";
			array[162] = "Violet";
			array[163] = "Wheat";
			array[164] = "White";
			array[165] = "WhiteSmoke";
			array[166] = "Yellow";
			array[167] = "YellowGreen";
			colorNameTable = array;
		}

		public static int KnownColorToArgb(KnownColor color)
		{
			EnsureColorTable();
			if (color <= KnownColor.MenuHighlight)
			{
				return colorTable[(int)color];
			}
			return 0;
		}

		public static string KnownColorToName(KnownColor color)
		{
			EnsureColorNameTable();
			if (color <= KnownColor.MenuHighlight)
			{
				return colorNameTable[(int)color];
			}
			return null;
		}

		private static int SystemColorToArgb(int index)
		{
			return FromWin32Value(SafeNativeMethods.GetSysColor(index));
		}

		private static int Encode(int alpha, int red, int green, int blue)
		{
			return (red << 16) | (green << 8) | blue | (alpha << 24);
		}

		private static int FromWin32Value(int value)
		{
			return Encode(255, value & 0xFF, (value >> 8) & 0xFF, (value >> 16) & 0xFF);
		}

		private static void OnUserPreferenceChanging(object sender, UserPreferenceChangingEventArgs e)
		{
			if (e.Category == UserPreferenceCategory.Color && colorTable != null)
			{
				UpdateSystemColors(colorTable);
			}
		}

		private static void UpdateSystemColors(int[] colorTable)
		{
			colorTable[1] = SystemColorToArgb(10);
			colorTable[2] = SystemColorToArgb(2);
			colorTable[3] = SystemColorToArgb(9);
			colorTable[4] = SystemColorToArgb(12);
			colorTable[168] = SystemColorToArgb(15);
			colorTable[169] = SystemColorToArgb(20);
			colorTable[170] = SystemColorToArgb(16);
			colorTable[5] = SystemColorToArgb(15);
			colorTable[6] = SystemColorToArgb(16);
			colorTable[7] = SystemColorToArgb(21);
			colorTable[8] = SystemColorToArgb(22);
			colorTable[9] = SystemColorToArgb(20);
			colorTable[10] = SystemColorToArgb(18);
			colorTable[11] = SystemColorToArgb(1);
			colorTable[171] = SystemColorToArgb(27);
			colorTable[172] = SystemColorToArgb(28);
			colorTable[12] = SystemColorToArgb(17);
			colorTable[13] = SystemColorToArgb(13);
			colorTable[14] = SystemColorToArgb(14);
			colorTable[15] = SystemColorToArgb(26);
			colorTable[16] = SystemColorToArgb(11);
			colorTable[17] = SystemColorToArgb(3);
			colorTable[18] = SystemColorToArgb(19);
			colorTable[19] = SystemColorToArgb(24);
			colorTable[20] = SystemColorToArgb(23);
			colorTable[21] = SystemColorToArgb(4);
			colorTable[173] = SystemColorToArgb(30);
			colorTable[174] = SystemColorToArgb(29);
			colorTable[22] = SystemColorToArgb(7);
			colorTable[23] = SystemColorToArgb(0);
			colorTable[24] = SystemColorToArgb(5);
			colorTable[25] = SystemColorToArgb(6);
			colorTable[26] = SystemColorToArgb(8);
		}
	}
	internal class NativeMethods
	{
		public enum RegionFlags
		{
			ERROR,
			NULLREGION,
			SIMPLEREGION,
			COMPLEXREGION
		}

		internal struct BITMAPINFO_FLAT
		{
			public int bmiHeader_biSize;

			public int bmiHeader_biWidth;

			public int bmiHeader_biHeight;

			public short bmiHeader_biPlanes;

			public short bmiHeader_biBitCount;

			public int bmiHeader_biCompression;

			public int bmiHeader_biSizeImage;

			public int bmiHeader_biXPelsPerMeter;

			public int bmiHeader_biYPelsPerMeter;

			public int bmiHeader_biClrUsed;

			public int bmiHeader_biClrImportant;

			[MarshalAs(UnmanagedType.ByValArray, SizeConst = 1024)]
			public byte[] bmiColors;
		}

		[StructLayout(LayoutKind.Sequential)]
		internal class BITMAPINFOHEADER
		{
			public int biSize = 40;

			public int biWidth;

			public int biHeight;

			public short biPlanes;

			public short biBitCount;

			public int biCompression;

			public int biSizeImage;

			public int biXPelsPerMeter;

			public int biYPelsPerMeter;

			public int biClrUsed;

			public int biClrImportant;
		}

		internal struct PALETTEENTRY
		{
			public byte peRed;

			public byte peGreen;

			public byte peBlue;

			public byte peFlags;
		}

		internal struct RGBQUAD
		{
			public byte rgbBlue;

			public byte rgbGreen;

			public byte rgbRed;

			public byte rgbReserved;
		}

		[StructLayout(LayoutKind.Sequential)]
		internal class NONCLIENTMETRICS
		{
			public int cbSize = Marshal.SizeOf(typeof(NONCLIENTMETRICS));

			public int iBorderWidth;

			public int iScrollWidth;

			public int iScrollHeight;

			public int iCaptionWidth;

			public int iCaptionHeight;

			[MarshalAs(UnmanagedType.Struct)]
			public SafeNativeMethods.LOGFONT lfCaptionFont;

			public int iSmCaptionWidth;

			public int iSmCaptionHeight;

			[MarshalAs(UnmanagedType.Struct)]
			public SafeNativeMethods.LOGFONT lfSmCaptionFont;

			public int iMenuWidth;

			public int iMenuHeight;

			[MarshalAs(UnmanagedType.Struct)]
			public SafeNativeMethods.LOGFONT lfMenuFont;

			[MarshalAs(UnmanagedType.Struct)]
			public SafeNativeMethods.LOGFONT lfStatusFont;

			[MarshalAs(UnmanagedType.Struct)]
			public SafeNativeMethods.LOGFONT lfMessageFont;
		}

		public const byte PC_NOCOLLAPSE = 4;

		public const int MAX_PATH = 260;

		internal const int SM_REMOTESESSION = 4096;

		internal const int OBJ_DC = 3;

		internal const int OBJ_METADC = 4;

		internal const int OBJ_MEMDC = 10;

		internal const int OBJ_ENHMETADC = 12;

		internal const int DIB_RGB_COLORS = 0;

		internal const int BI_BITFIELDS = 3;

		internal const int BI_RGB = 0;

		internal const int BITMAPINFO_MAX_COLORSIZE = 256;

		internal const int SPI_GETICONTITLELOGFONT = 31;

		internal const int SPI_GETNONCLIENTMETRICS = 41;

		internal const int DEFAULT_GUI_FONT = 17;

		internal static HandleRef NullHandleRef = new HandleRef(null, IntPtr.Zero);
	}
}
namespace System.Drawing.Internal
{
	internal interface ISystemColorTracker
	{
		void OnSystemColorChanged();
	}
}
namespace System.Drawing
{
	public sealed class Pen : MarshalByRefObject, ISystemColorTracker, ICloneable, IDisposable
	{
		private IntPtr nativePen;

		private Color color;

		private bool immutable;

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Browsable(false)]
		internal IntPtr NativePen => nativePen;

		public float Width
		{
			get
			{
				float[] array = new float[1];
				float[] array2 = array;
				int num = SafeNativeMethods.Gdip.GdipGetPenWidth(new HandleRef(this, NativePen), array2);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return array2[0];
			}
			set
			{
				if (immutable)
				{
					throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Pen"));
				}
				int num = SafeNativeMethods.Gdip.GdipSetPenWidth(new HandleRef(this, NativePen), value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		public LineCap StartCap
		{
			get
			{
				int startCap = 0;
				int num = SafeNativeMethods.Gdip.GdipGetPenStartCap(new HandleRef(this, NativePen), out startCap);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return (LineCap)startCap;
			}
			set
			{
				switch (value)
				{
				default:
					throw new InvalidEnumArgumentException("value", (int)value, typeof(LineCap));
				case LineCap.Flat:
				case LineCap.Square:
				case LineCap.Round:
				case LineCap.Triangle:
				case LineCap.NoAnchor:
				case LineCap.SquareAnchor:
				case LineCap.RoundAnchor:
				case LineCap.DiamondAnchor:
				case LineCap.ArrowAnchor:
				case LineCap.AnchorMask:
				case LineCap.Custom:
				{
					if (immutable)
					{
						throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Pen"));
					}
					int num = SafeNativeMethods.Gdip.GdipSetPenStartCap(new HandleRef(this, NativePen), (int)value);
					if (num != 0)
					{
						throw SafeNativeMethods.Gdip.StatusException(num);
					}
					break;
				}
				}
			}
		}

		public LineCap EndCap
		{
			get
			{
				int endCap = 0;
				int num = SafeNativeMethods.Gdip.GdipGetPenEndCap(new HandleRef(this, NativePen), out endCap);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return (LineCap)endCap;
			}
			set
			{
				switch (value)
				{
				default:
					throw new InvalidEnumArgumentException("value", (int)value, typeof(LineCap));
				case LineCap.Flat:
				case LineCap.Square:
				case LineCap.Round:
				case LineCap.Triangle:
				case LineCap.NoAnchor:
				case LineCap.SquareAnchor:
				case LineCap.RoundAnchor:
				case LineCap.DiamondAnchor:
				case LineCap.ArrowAnchor:
				case LineCap.AnchorMask:
				case LineCap.Custom:
				{
					if (immutable)
					{
						throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Pen"));
					}
					int num = SafeNativeMethods.Gdip.GdipSetPenEndCap(new HandleRef(this, NativePen), (int)value);
					if (num != 0)
					{
						throw SafeNativeMethods.Gdip.StatusException(num);
					}
					break;
				}
				}
			}
		}

		public DashCap DashCap
		{
			get
			{
				int dashCap = 0;
				int num = SafeNativeMethods.Gdip.GdipGetPenDashCap197819(new HandleRef(this, NativePen), out dashCap);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return (DashCap)dashCap;
			}
			set
			{
				if (!ClientUtils.IsEnumValid_NotSequential(value, (int)value, 0, 2, 3))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(DashCap));
				}
				if (immutable)
				{
					throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Pen"));
				}
				int num = SafeNativeMethods.Gdip.GdipSetPenDashCap197819(new HandleRef(this, NativePen), (int)value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		public LineJoin LineJoin
		{
			get
			{
				int lineJoin = 0;
				int num = SafeNativeMethods.Gdip.GdipGetPenLineJoin(new HandleRef(this, NativePen), out lineJoin);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return (LineJoin)lineJoin;
			}
			set
			{
				if (!ClientUtils.IsEnumValid(value, (int)value, 0, 3))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(LineJoin));
				}
				if (immutable)
				{
					throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Pen"));
				}
				int num = SafeNativeMethods.Gdip.GdipSetPenLineJoin(new HandleRef(this, NativePen), (int)value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		public CustomLineCap CustomStartCap
		{
			get
			{
				IntPtr customCap = IntPtr.Zero;
				int num = SafeNativeMethods.Gdip.GdipGetPenCustomStartCap(new HandleRef(this, NativePen), out customCap);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return CustomLineCap.CreateCustomLineCapObject(customCap);
			}
			set
			{
				if (immutable)
				{
					throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Pen"));
				}
				int num = SafeNativeMethods.Gdip.GdipSetPenCustomStartCap(new HandleRef(this, NativePen), new HandleRef(value, (value == null) ? IntPtr.Zero : ((IntPtr)value.nativeCap)));
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		public CustomLineCap CustomEndCap
		{
			get
			{
				IntPtr customCap = IntPtr.Zero;
				int num = SafeNativeMethods.Gdip.GdipGetPenCustomEndCap(new HandleRef(this, NativePen), out customCap);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return CustomLineCap.CreateCustomLineCapObject(customCap);
			}
			set
			{
				if (immutable)
				{
					throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Pen"));
				}
				int num = SafeNativeMethods.Gdip.GdipSetPenCustomEndCap(new HandleRef(this, NativePen), new HandleRef(value, (value == null) ? IntPtr.Zero : ((IntPtr)value.nativeCap)));
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		public float MiterLimit
		{
			get
			{
				float[] array = new float[1];
				float[] array2 = array;
				int num = SafeNativeMethods.Gdip.GdipGetPenMiterLimit(new HandleRef(this, NativePen), array2);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return array2[0];
			}
			set
			{
				if (immutable)
				{
					throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Pen"));
				}
				int num = SafeNativeMethods.Gdip.GdipSetPenMiterLimit(new HandleRef(this, NativePen), value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		public PenAlignment Alignment
		{
			get
			{
				PenAlignment penAlign = PenAlignment.Center;
				int num = SafeNativeMethods.Gdip.GdipGetPenMode(new HandleRef(this, NativePen), out penAlign);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return penAlign;
			}
			set
			{
				if (!ClientUtils.IsEnumValid(value, (int)value, 0, 4))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(PenAlignment));
				}
				if (immutable)
				{
					throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Pen"));
				}
				int num = SafeNativeMethods.Gdip.GdipSetPenMode(new HandleRef(this, NativePen), value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		public Matrix Transform
		{
			get
			{
				Matrix matrix = new Matrix();
				int num = SafeNativeMethods.Gdip.GdipGetPenTransform(new HandleRef(this, NativePen), new HandleRef(matrix, matrix.nativeMatrix));
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return matrix;
			}
			set
			{
				if (immutable)
				{
					throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Pen"));
				}
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				int num = SafeNativeMethods.Gdip.GdipSetPenTransform(new HandleRef(this, NativePen), new HandleRef(value, value.nativeMatrix));
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		public PenType PenType
		{
			get
			{
				int pentype = -1;
				int num = SafeNativeMethods.Gdip.GdipGetPenFillType(new HandleRef(this, NativePen), out pentype);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return (PenType)pentype;
			}
		}

		public Color Color
		{
			get
			{
				if (color == Color.Empty)
				{
					int argb = 0;
					int num = SafeNativeMethods.Gdip.GdipGetPenColor(new HandleRef(this, NativePen), out argb);
					if (num != 0)
					{
						throw SafeNativeMethods.Gdip.StatusException(num);
					}
					color = Color.FromArgb(argb);
				}
				return color;
			}
			set
			{
				if (immutable)
				{
					throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Pen"));
				}
				if (value != this.color)
				{
					Color color = this.color;
					this.color = value;
					InternalSetColor(value);
					if (value.IsSystemColor && !color.IsSystemColor)
					{
						SystemColorTracker.Add(this);
					}
				}
			}
		}

		public Brush Brush
		{
			get
			{
				Brush result = null;
				switch (PenType)
				{
				case PenType.SolidColor:
					result = new SolidBrush(GetNativeBrush());
					break;
				case PenType.HatchFill:
					result = new HatchBrush(GetNativeBrush());
					break;
				case PenType.TextureFill:
					result = new TextureBrush(GetNativeBrush());
					break;
				case PenType.PathGradient:
					result = new PathGradientBrush(GetNativeBrush());
					break;
				case PenType.LinearGradient:
					result = new LinearGradientBrush(GetNativeBrush());
					break;
				}
				return result;
			}
			set
			{
				if (immutable)
				{
					throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Pen"));
				}
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				int num = SafeNativeMethods.Gdip.GdipSetPenBrushFill(new HandleRef(this, NativePen), new HandleRef(value, value.NativeBrush));
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		public DashStyle DashStyle
		{
			get
			{
				int dashstyle = 0;
				int num = SafeNativeMethods.Gdip.GdipGetPenDashStyle(new HandleRef(this, NativePen), out dashstyle);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return (DashStyle)dashstyle;
			}
			set
			{
				if (!ClientUtils.IsEnumValid(value, (int)value, 0, 5))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(DashStyle));
				}
				if (immutable)
				{
					throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Pen"));
				}
				int num = SafeNativeMethods.Gdip.GdipSetPenDashStyle(new HandleRef(this, NativePen), (int)value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				if (value == DashStyle.Custom)
				{
					EnsureValidDashPattern();
				}
			}
		}

		public float DashOffset
		{
			get
			{
				float[] array = new float[1];
				float[] array2 = array;
				int num = SafeNativeMethods.Gdip.GdipGetPenDashOffset(new HandleRef(this, NativePen), array2);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return array2[0];
			}
			set
			{
				if (immutable)
				{
					throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Pen"));
				}
				int num = SafeNativeMethods.Gdip.GdipSetPenDashOffset(new HandleRef(this, NativePen), value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		public float[] DashPattern
		{
			get
			{
				int dashcount = 0;
				int num = SafeNativeMethods.Gdip.GdipGetPenDashCount(new HandleRef(this, NativePen), out dashcount);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				int num2 = dashcount;
				IntPtr intPtr = Marshal.AllocHGlobal(checked(4 * num2));
				num = SafeNativeMethods.Gdip.GdipGetPenDashArray(new HandleRef(this, NativePen), intPtr, num2);
				try
				{
					if (num != 0)
					{
						throw SafeNativeMethods.Gdip.StatusException(num);
					}
					float[] array = new float[num2];
					Marshal.Copy(intPtr, array, 0, num2);
					return array;
				}
				finally
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
			set
			{
				if (immutable)
				{
					throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Pen"));
				}
				if (value == null || value.Length == 0)
				{
					throw new ArgumentException(SR.GetString("InvalidDashPattern"));
				}
				int num = value.Length;
				IntPtr intPtr = Marshal.AllocHGlobal(checked(4 * num));
				try
				{
					Marshal.Copy(value, 0, intPtr, num);
					int num2 = SafeNativeMethods.Gdip.GdipSetPenDashArray(new HandleRef(this, NativePen), new HandleRef(intPtr, intPtr), num);
					if (num2 != 0)
					{
						throw SafeNativeMethods.Gdip.StatusException(num2);
					}
				}
				finally
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
		}

		public float[] CompoundArray
		{
			get
			{
				int count = 0;
				int num = SafeNativeMethods.Gdip.GdipGetPenCompoundCount(new HandleRef(this, NativePen), out count);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				float[] array = new float[count];
				num = SafeNativeMethods.Gdip.GdipGetPenCompoundArray(new HandleRef(this, NativePen), array, count);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return array;
			}
			set
			{
				if (immutable)
				{
					throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Pen"));
				}
				int num = SafeNativeMethods.Gdip.GdipSetPenCompoundArray(new HandleRef(this, NativePen), value, value.Length);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		private Pen(IntPtr nativePen)
		{
			SetNativePen(nativePen);
		}

		internal Pen(Color color, bool immutable)
			: this(color)
		{
			this.immutable = immutable;
		}

		public Pen(Color color)
			: this(color, 1f)
		{
		}

		public Pen(Color color, float width)
		{
			this.color = color;
			IntPtr pen = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreatePen1(color.ToArgb(), width, 0, out pen);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativePen(pen);
			if (this.color.IsSystemColor)
			{
				SystemColorTracker.Add(this);
			}
		}

		public Pen(Brush brush)
			: this(brush, 1f)
		{
		}

		public Pen(Brush brush, float width)
		{
			IntPtr pen = IntPtr.Zero;
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			int num = SafeNativeMethods.Gdip.GdipCreatePen2(new HandleRef(brush, brush.NativeBrush), width, 0, out pen);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativePen(pen);
		}

		internal void SetNativePen(IntPtr nativePen)
		{
			if (nativePen == IntPtr.Zero)
			{
				throw new ArgumentNullException("nativePen");
			}
			this.nativePen = nativePen;
		}

		public object Clone()
		{
			IntPtr clonepen = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipClonePen(new HandleRef(this, NativePen), out clonepen);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new Pen(clonepen);
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		private void Dispose(bool disposing)
		{
			if (!disposing)
			{
				immutable = false;
			}
			else if (immutable)
			{
				throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Brush"));
			}
			if (!(nativePen != IntPtr.Zero))
			{
				return;
			}
			try
			{
				SafeNativeMethods.Gdip.GdipDeletePen(new HandleRef(this, NativePen));
			}
			catch (Exception ex)
			{
				if (ClientUtils.IsSecurityOrCriticalException(ex))
				{
					throw;
				}
			}
			finally
			{
				nativePen = IntPtr.Zero;
			}
		}

		~Pen()
		{
			Dispose(disposing: false);
		}

		public void SetLineCap(LineCap startCap, LineCap endCap, DashCap dashCap)
		{
			if (immutable)
			{
				throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Pen"));
			}
			int num = SafeNativeMethods.Gdip.GdipSetPenLineCap197819(new HandleRef(this, NativePen), (int)startCap, (int)endCap, (int)dashCap);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void ResetTransform()
		{
			int num = SafeNativeMethods.Gdip.GdipResetPenTransform(new HandleRef(this, NativePen));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void MultiplyTransform(Matrix matrix)
		{
			MultiplyTransform(matrix, MatrixOrder.Prepend);
		}

		public void MultiplyTransform(Matrix matrix, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipMultiplyPenTransform(new HandleRef(this, NativePen), new HandleRef(matrix, matrix.nativeMatrix), order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void TranslateTransform(float dx, float dy)
		{
			TranslateTransform(dx, dy, MatrixOrder.Prepend);
		}

		public void TranslateTransform(float dx, float dy, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipTranslatePenTransform(new HandleRef(this, NativePen), dx, dy, order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void ScaleTransform(float sx, float sy)
		{
			ScaleTransform(sx, sy, MatrixOrder.Prepend);
		}

		public void ScaleTransform(float sx, float sy, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipScalePenTransform(new HandleRef(this, NativePen), sx, sy, order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void RotateTransform(float angle)
		{
			RotateTransform(angle, MatrixOrder.Prepend);
		}

		public void RotateTransform(float angle, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipRotatePenTransform(new HandleRef(this, NativePen), angle, order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private void InternalSetColor(Color value)
		{
			int num = SafeNativeMethods.Gdip.GdipSetPenColor(new HandleRef(this, NativePen), color.ToArgb());
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			color = value;
		}

		private IntPtr GetNativeBrush()
		{
			IntPtr brush = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipGetPenBrushFill(new HandleRef(this, NativePen), out brush);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return brush;
		}

		private void EnsureValidDashPattern()
		{
			int dashcount = 0;
			int num = SafeNativeMethods.Gdip.GdipGetPenDashCount(new HandleRef(this, NativePen), out dashcount);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			if (dashcount == 0)
			{
				DashPattern = new float[1] { 1f };
			}
		}

		void ISystemColorTracker.OnSystemColorChanged()
		{
			if (NativePen != IntPtr.Zero)
			{
				InternalSetColor(color);
			}
		}
	}
	public sealed class Pens
	{
		private static readonly object TransparentKey = new object();

		private static readonly object AliceBlueKey = new object();

		private static readonly object AntiqueWhiteKey = new object();

		private static readonly object AquaKey = new object();

		private static readonly object AquamarineKey = new object();

		private static readonly object AzureKey = new object();

		private static readonly object BeigeKey = new object();

		private static readonly object BisqueKey = new object();

		private static readonly object BlackKey = new object();

		private static readonly object BlanchedAlmondKey = new object();

		private static readonly object BlueKey = new object();

		private static readonly object BlueVioletKey = new object();

		private static readonly object BrownKey = new object();

		private static readonly object BurlyWoodKey = new object();

		private static readonly object CadetBlueKey = new object();

		private static readonly object ChartreuseKey = new object();

		private static readonly object ChocolateKey = new object();

		private static readonly object ChoralKey = new object();

		private static readonly object CornflowerBlueKey = new object();

		private static readonly object CornsilkKey = new object();

		private static readonly object CrimsonKey = new object();

		private static readonly object CyanKey = new object();

		private static readonly object DarkBlueKey = new object();

		private static readonly object DarkCyanKey = new object();

		private static readonly object DarkGoldenrodKey = new object();

		private static readonly object DarkGrayKey = new object();

		private static readonly object DarkGreenKey = new object();

		private static readonly object DarkKhakiKey = new object();

		private static readonly object DarkMagentaKey = new object();

		private static readonly object DarkOliveGreenKey = new object();

		private static readonly object DarkOrangeKey = new object();

		private static readonly object DarkOrchidKey = new object();

		private static readonly object DarkRedKey = new object();

		private static readonly object DarkSalmonKey = new object();

		private static readonly object DarkSeaGreenKey = new object();

		private static readonly object DarkSlateBlueKey = new object();

		private static readonly object DarkSlateGrayKey = new object();

		private static readonly object DarkTurquoiseKey = new object();

		private static readonly object DarkVioletKey = new object();

		private static readonly object DeepPinkKey = new object();

		private static readonly object DeepSkyBlueKey = new object();

		private static readonly object DimGrayKey = new object();

		private static readonly object DodgerBlueKey = new object();

		private static readonly object FirebrickKey = new object();

		private static readonly object FloralWhiteKey = new object();

		private static readonly object ForestGreenKey = new object();

		private static readonly object FuchiaKey = new object();

		private static readonly object GainsboroKey = new object();

		private static readonly object GhostWhiteKey = new object();

		private static readonly object GoldKey = new object();

		private static readonly object GoldenrodKey = new object();

		private static readonly object GrayKey = new object();

		private static readonly object GreenKey = new object();

		private static readonly object GreenYellowKey = new object();

		private static readonly object HoneydewKey = new object();

		private static readonly object HotPinkKey = new object();

		private static readonly object IndianRedKey = new object();

		private static readonly object IndigoKey = new object();

		private static readonly object IvoryKey = new object();

		private static readonly object KhakiKey = new object();

		private static readonly object LavenderKey = new object();

		private static readonly object LavenderBlushKey = new object();

		private static readonly object LawnGreenKey = new object();

		private static readonly object LemonChiffonKey = new object();

		private static readonly object LightBlueKey = new object();

		private static readonly object LightCoralKey = new object();

		private static readonly object LightCyanKey = new object();

		private static readonly object LightGoldenrodYellowKey = new object();

		private static readonly object LightGreenKey = new object();

		private static readonly object LightGrayKey = new object();

		private static readonly object LightPinkKey = new object();

		private static readonly object LightSalmonKey = new object();

		private static readonly object LightSeaGreenKey = new object();

		private static readonly object LightSkyBlueKey = new object();

		private static readonly object LightSlateGrayKey = new object();

		private static readonly object LightSteelBlueKey = new object();

		private static readonly object LightYellowKey = new object();

		private static readonly object LimeKey = new object();

		private static readonly object LimeGreenKey = new object();

		private static readonly object LinenKey = new object();

		private static readonly object MagentaKey = new object();

		private static readonly object MaroonKey = new object();

		private static readonly object MediumAquamarineKey = new object();

		private static readonly object MediumBlueKey = new object();

		private static readonly object MediumOrchidKey = new object();

		private static readonly object MediumPurpleKey = new object();

		private static readonly object MediumSeaGreenKey = new object();

		private static readonly object MediumSlateBlueKey = new object();

		private static readonly object MediumSpringGreenKey = new object();

		private static readonly object MediumTurquoiseKey = new object();

		private static readonly object MediumVioletRedKey = new object();

		private static readonly object MidnightBlueKey = new object();

		private static readonly object MintCreamKey = new object();

		private static readonly object MistyRoseKey = new object();

		private static readonly object MoccasinKey = new object();

		private static readonly object NavajoWhiteKey = new object();

		private static readonly object NavyKey = new object();

		private static readonly object OldLaceKey = new object();

		private static readonly object OliveKey = new object();

		private static readonly object OliveDrabKey = new object();

		private static readonly object OrangeKey = new object();

		private static readonly object OrangeRedKey = new object();

		private static readonly object OrchidKey = new object();

		private static readonly object PaleGoldenrodKey = new object();

		private static readonly object PaleGreenKey = new object();

		private static readonly object PaleTurquoiseKey = new object();

		private static readonly object PaleVioletRedKey = new object();

		private static readonly object PapayaWhipKey = new object();

		private static readonly object PeachPuffKey = new object();

		private static readonly object PeruKey = new object();

		private static readonly object PinkKey = new object();

		private static readonly object PlumKey = new object();

		private static readonly object PowderBlueKey = new object();

		private static readonly object PurpleKey = new object();

		private static readonly object RedKey = new object();

		private static readonly object RosyBrownKey = new object();

		private static readonly object RoyalBlueKey = new object();

		private static readonly object SaddleBrownKey = new object();

		private static readonly object SalmonKey = new object();

		private static readonly object SandyBrownKey = new object();

		private static readonly object SeaGreenKey = new object();

		private static readonly object SeaShellKey = new object();

		private static readonly object SiennaKey = new object();

		private static readonly object SilverKey = new object();

		private static readonly object SkyBlueKey = new object();

		private static readonly object SlateBlueKey = new object();

		private static readonly object SlateGrayKey = new object();

		private static readonly object SnowKey = new object();

		private static readonly object SpringGreenKey = new object();

		private static readonly object SteelBlueKey = new object();

		private static readonly object TanKey = new object();

		private static readonly object TealKey = new object();

		private static readonly object ThistleKey = new object();

		private static readonly object TomatoKey = new object();

		private static readonly object TurquoiseKey = new object();

		private static readonly object VioletKey = new object();

		private static readonly object WheatKey = new object();

		private static readonly object WhiteKey = new object();

		private static readonly object WhiteSmokeKey = new object();

		private static readonly object YellowKey = new object();

		private static readonly object YellowGreenKey = new object();

		public static Pen Transparent
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[TransparentKey];
				if (pen == null)
				{
					pen = new Pen(Color.Transparent, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[TransparentKey] = pen;
				}
				return pen;
			}
		}

		public static Pen AliceBlue
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[AliceBlueKey];
				if (pen == null)
				{
					pen = new Pen(Color.AliceBlue, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[AliceBlueKey] = pen;
				}
				return pen;
			}
		}

		public static Pen AntiqueWhite
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[AntiqueWhiteKey];
				if (pen == null)
				{
					pen = new Pen(Color.AntiqueWhite, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[AntiqueWhiteKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Aqua
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[AquaKey];
				if (pen == null)
				{
					pen = new Pen(Color.Aqua, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[AquaKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Aquamarine
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[AquamarineKey];
				if (pen == null)
				{
					pen = new Pen(Color.Aquamarine, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[AquamarineKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Azure
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[AzureKey];
				if (pen == null)
				{
					pen = new Pen(Color.Azure, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[AzureKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Beige
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[BeigeKey];
				if (pen == null)
				{
					pen = new Pen(Color.Beige, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[BeigeKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Bisque
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[BisqueKey];
				if (pen == null)
				{
					pen = new Pen(Color.Bisque, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[BisqueKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Black
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[BlackKey];
				if (pen == null)
				{
					pen = new Pen(Color.Black, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[BlackKey] = pen;
				}
				return pen;
			}
		}

		public static Pen BlanchedAlmond
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[BlanchedAlmondKey];
				if (pen == null)
				{
					pen = new Pen(Color.BlanchedAlmond, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[BlanchedAlmondKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Blue
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[BlueKey];
				if (pen == null)
				{
					pen = new Pen(Color.Blue, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[BlueKey] = pen;
				}
				return pen;
			}
		}

		public static Pen BlueViolet
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[BlueVioletKey];
				if (pen == null)
				{
					pen = new Pen(Color.BlueViolet, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[BlueVioletKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Brown
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[BrownKey];
				if (pen == null)
				{
					pen = new Pen(Color.Brown, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[BrownKey] = pen;
				}
				return pen;
			}
		}

		public static Pen BurlyWood
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[BurlyWoodKey];
				if (pen == null)
				{
					pen = new Pen(Color.BurlyWood, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[BurlyWoodKey] = pen;
				}
				return pen;
			}
		}

		public static Pen CadetBlue
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[CadetBlueKey];
				if (pen == null)
				{
					pen = new Pen(Color.CadetBlue, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[CadetBlueKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Chartreuse
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[ChartreuseKey];
				if (pen == null)
				{
					pen = new Pen(Color.Chartreuse, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[ChartreuseKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Chocolate
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[ChocolateKey];
				if (pen == null)
				{
					pen = new Pen(Color.Chocolate, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[ChocolateKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Coral
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[ChoralKey];
				if (pen == null)
				{
					pen = new Pen(Color.Coral, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[ChoralKey] = pen;
				}
				return pen;
			}
		}

		public static Pen CornflowerBlue
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[CornflowerBlueKey];
				if (pen == null)
				{
					pen = new Pen(Color.CornflowerBlue, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[CornflowerBlueKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Cornsilk
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[CornsilkKey];
				if (pen == null)
				{
					pen = new Pen(Color.Cornsilk, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[CornsilkKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Crimson
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[CrimsonKey];
				if (pen == null)
				{
					pen = new Pen(Color.Crimson, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[CrimsonKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Cyan
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[CyanKey];
				if (pen == null)
				{
					pen = new Pen(Color.Cyan, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[CyanKey] = pen;
				}
				return pen;
			}
		}

		public static Pen DarkBlue
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DarkBlueKey];
				if (pen == null)
				{
					pen = new Pen(Color.DarkBlue, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DarkBlueKey] = pen;
				}
				return pen;
			}
		}

		public static Pen DarkCyan
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DarkCyanKey];
				if (pen == null)
				{
					pen = new Pen(Color.DarkCyan, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DarkCyanKey] = pen;
				}
				return pen;
			}
		}

		public static Pen DarkGoldenrod
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DarkGoldenrodKey];
				if (pen == null)
				{
					pen = new Pen(Color.DarkGoldenrod, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DarkGoldenrodKey] = pen;
				}
				return pen;
			}
		}

		public static Pen DarkGray
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DarkGrayKey];
				if (pen == null)
				{
					pen = new Pen(Color.DarkGray, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DarkGrayKey] = pen;
				}
				return pen;
			}
		}

		public static Pen DarkGreen
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DarkGreenKey];
				if (pen == null)
				{
					pen = new Pen(Color.DarkGreen, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DarkGreenKey] = pen;
				}
				return pen;
			}
		}

		public static Pen DarkKhaki
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DarkKhakiKey];
				if (pen == null)
				{
					pen = new Pen(Color.DarkKhaki, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DarkKhakiKey] = pen;
				}
				return pen;
			}
		}

		public static Pen DarkMagenta
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DarkMagentaKey];
				if (pen == null)
				{
					pen = new Pen(Color.DarkMagenta, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DarkMagentaKey] = pen;
				}
				return pen;
			}
		}

		public static Pen DarkOliveGreen
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DarkOliveGreenKey];
				if (pen == null)
				{
					pen = new Pen(Color.DarkOliveGreen, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DarkOliveGreenKey] = pen;
				}
				return pen;
			}
		}

		public static Pen DarkOrange
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DarkOrangeKey];
				if (pen == null)
				{
					pen = new Pen(Color.DarkOrange, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DarkOrangeKey] = pen;
				}
				return pen;
			}
		}

		public static Pen DarkOrchid
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DarkOrchidKey];
				if (pen == null)
				{
					pen = new Pen(Color.DarkOrchid, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DarkOrchidKey] = pen;
				}
				return pen;
			}
		}

		public static Pen DarkRed
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DarkRedKey];
				if (pen == null)
				{
					pen = new Pen(Color.DarkRed, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DarkRedKey] = pen;
				}
				return pen;
			}
		}

		public static Pen DarkSalmon
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DarkSalmonKey];
				if (pen == null)
				{
					pen = new Pen(Color.DarkSalmon, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DarkSalmonKey] = pen;
				}
				return pen;
			}
		}

		public static Pen DarkSeaGreen
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DarkSeaGreenKey];
				if (pen == null)
				{
					pen = new Pen(Color.DarkSeaGreen, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DarkSeaGreenKey] = pen;
				}
				return pen;
			}
		}

		public static Pen DarkSlateBlue
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DarkSlateBlueKey];
				if (pen == null)
				{
					pen = new Pen(Color.DarkSlateBlue, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DarkSlateBlueKey] = pen;
				}
				return pen;
			}
		}

		public static Pen DarkSlateGray
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DarkSlateGrayKey];
				if (pen == null)
				{
					pen = new Pen(Color.DarkSlateGray, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DarkSlateGrayKey] = pen;
				}
				return pen;
			}
		}

		public static Pen DarkTurquoise
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DarkTurquoiseKey];
				if (pen == null)
				{
					pen = new Pen(Color.DarkTurquoise, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DarkTurquoiseKey] = pen;
				}
				return pen;
			}
		}

		public static Pen DarkViolet
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DarkVioletKey];
				if (pen == null)
				{
					pen = new Pen(Color.DarkViolet, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DarkVioletKey] = pen;
				}
				return pen;
			}
		}

		public static Pen DeepPink
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DeepPinkKey];
				if (pen == null)
				{
					pen = new Pen(Color.DeepPink, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DeepPinkKey] = pen;
				}
				return pen;
			}
		}

		public static Pen DeepSkyBlue
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DeepSkyBlueKey];
				if (pen == null)
				{
					pen = new Pen(Color.DeepSkyBlue, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DeepSkyBlueKey] = pen;
				}
				return pen;
			}
		}

		public static Pen DimGray
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DimGrayKey];
				if (pen == null)
				{
					pen = new Pen(Color.DimGray, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DimGrayKey] = pen;
				}
				return pen;
			}
		}

		public static Pen DodgerBlue
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DodgerBlueKey];
				if (pen == null)
				{
					pen = new Pen(Color.DodgerBlue, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DodgerBlueKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Firebrick
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[FirebrickKey];
				if (pen == null)
				{
					pen = new Pen(Color.Firebrick, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[FirebrickKey] = pen;
				}
				return pen;
			}
		}

		public static Pen FloralWhite
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[FloralWhiteKey];
				if (pen == null)
				{
					pen = new Pen(Color.FloralWhite, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[FloralWhiteKey] = pen;
				}
				return pen;
			}
		}

		public static Pen ForestGreen
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[ForestGreenKey];
				if (pen == null)
				{
					pen = new Pen(Color.ForestGreen, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[ForestGreenKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Fuchsia
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[FuchiaKey];
				if (pen == null)
				{
					pen = new Pen(Color.Fuchsia, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[FuchiaKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Gainsboro
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[GainsboroKey];
				if (pen == null)
				{
					pen = new Pen(Color.Gainsboro, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[GainsboroKey] = pen;
				}
				return pen;
			}
		}

		public static Pen GhostWhite
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[GhostWhiteKey];
				if (pen == null)
				{
					pen = new Pen(Color.GhostWhite, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[GhostWhiteKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Gold
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[GoldKey];
				if (pen == null)
				{
					pen = new Pen(Color.Gold, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[GoldKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Goldenrod
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[GoldenrodKey];
				if (pen == null)
				{
					pen = new Pen(Color.Goldenrod, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[GoldenrodKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Gray
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[GrayKey];
				if (pen == null)
				{
					pen = new Pen(Color.Gray, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[GrayKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Green
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[GreenKey];
				if (pen == null)
				{
					pen = new Pen(Color.Green, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[GreenKey] = pen;
				}
				return pen;
			}
		}

		public static Pen GreenYellow
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[GreenYellowKey];
				if (pen == null)
				{
					pen = new Pen(Color.GreenYellow, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[GreenYellowKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Honeydew
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[HoneydewKey];
				if (pen == null)
				{
					pen = new Pen(Color.Honeydew, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[HoneydewKey] = pen;
				}
				return pen;
			}
		}

		public static Pen HotPink
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[HotPinkKey];
				if (pen == null)
				{
					pen = new Pen(Color.HotPink, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[HotPinkKey] = pen;
				}
				return pen;
			}
		}

		public static Pen IndianRed
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[IndianRedKey];
				if (pen == null)
				{
					pen = new Pen(Color.IndianRed, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[IndianRedKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Indigo
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[IndigoKey];
				if (pen == null)
				{
					pen = new Pen(Color.Indigo, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[IndigoKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Ivory
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[IvoryKey];
				if (pen == null)
				{
					pen = new Pen(Color.Ivory, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[IvoryKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Khaki
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[KhakiKey];
				if (pen == null)
				{
					pen = new Pen(Color.Khaki, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[KhakiKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Lavender
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LavenderKey];
				if (pen == null)
				{
					pen = new Pen(Color.Lavender, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LavenderKey] = pen;
				}
				return pen;
			}
		}

		public static Pen LavenderBlush
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LavenderBlushKey];
				if (pen == null)
				{
					pen = new Pen(Color.LavenderBlush, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LavenderBlushKey] = pen;
				}
				return pen;
			}
		}

		public static Pen LawnGreen
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LawnGreenKey];
				if (pen == null)
				{
					pen = new Pen(Color.LawnGreen, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LawnGreenKey] = pen;
				}
				return pen;
			}
		}

		public static Pen LemonChiffon
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LemonChiffonKey];
				if (pen == null)
				{
					pen = new Pen(Color.LemonChiffon, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LemonChiffonKey] = pen;
				}
				return pen;
			}
		}

		public static Pen LightBlue
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LightBlueKey];
				if (pen == null)
				{
					pen = new Pen(Color.LightBlue, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LightBlueKey] = pen;
				}
				return pen;
			}
		}

		public static Pen LightCoral
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LightCoralKey];
				if (pen == null)
				{
					pen = new Pen(Color.LightCoral, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LightCoralKey] = pen;
				}
				return pen;
			}
		}

		public static Pen LightCyan
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LightCyanKey];
				if (pen == null)
				{
					pen = new Pen(Color.LightCyan, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LightCyanKey] = pen;
				}
				return pen;
			}
		}

		public static Pen LightGoldenrodYellow
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LightGoldenrodYellowKey];
				if (pen == null)
				{
					pen = new Pen(Color.LightGoldenrodYellow, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LightGoldenrodYellowKey] = pen;
				}
				return pen;
			}
		}

		public static Pen LightGreen
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LightGreenKey];
				if (pen == null)
				{
					pen = new Pen(Color.LightGreen, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LightGreenKey] = pen;
				}
				return pen;
			}
		}

		public static Pen LightGray
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LightGrayKey];
				if (pen == null)
				{
					pen = new Pen(Color.LightGray, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LightGrayKey] = pen;
				}
				return pen;
			}
		}

		public static Pen LightPink
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LightPinkKey];
				if (pen == null)
				{
					pen = new Pen(Color.LightPink, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LightPinkKey] = pen;
				}
				return pen;
			}
		}

		public static Pen LightSalmon
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LightSalmonKey];
				if (pen == null)
				{
					pen = new Pen(Color.LightSalmon, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LightSalmonKey] = pen;
				}
				return pen;
			}
		}

		public static Pen LightSeaGreen
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LightSeaGreenKey];
				if (pen == null)
				{
					pen = new Pen(Color.LightSeaGreen, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LightSeaGreenKey] = pen;
				}
				return pen;
			}
		}

		public static Pen LightSkyBlue
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LightSkyBlueKey];
				if (pen == null)
				{
					pen = new Pen(Color.LightSkyBlue, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LightSkyBlueKey] = pen;
				}
				return pen;
			}
		}

		public static Pen LightSlateGray
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LightSlateGrayKey];
				if (pen == null)
				{
					pen = new Pen(Color.LightSlateGray, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LightSlateGrayKey] = pen;
				}
				return pen;
			}
		}

		public static Pen LightSteelBlue
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LightSteelBlueKey];
				if (pen == null)
				{
					pen = new Pen(Color.LightSteelBlue, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LightSteelBlueKey] = pen;
				}
				return pen;
			}
		}

		public static Pen LightYellow
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LightYellowKey];
				if (pen == null)
				{
					pen = new Pen(Color.LightYellow, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LightYellowKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Lime
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LimeKey];
				if (pen == null)
				{
					pen = new Pen(Color.Lime, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LimeKey] = pen;
				}
				return pen;
			}
		}

		public static Pen LimeGreen
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LimeGreenKey];
				if (pen == null)
				{
					pen = new Pen(Color.LimeGreen, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LimeGreenKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Linen
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LinenKey];
				if (pen == null)
				{
					pen = new Pen(Color.Linen, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LinenKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Magenta
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[MagentaKey];
				if (pen == null)
				{
					pen = new Pen(Color.Magenta, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[MagentaKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Maroon
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[MaroonKey];
				if (pen == null)
				{
					pen = new Pen(Color.Maroon, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[MaroonKey] = pen;
				}
				return pen;
			}
		}

		public static Pen MediumAquamarine
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[MediumAquamarineKey];
				if (pen == null)
				{
					pen = new Pen(Color.MediumAquamarine, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[MediumAquamarineKey] = pen;
				}
				return pen;
			}
		}

		public static Pen MediumBlue
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[MediumBlueKey];
				if (pen == null)
				{
					pen = new Pen(Color.MediumBlue, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[MediumBlueKey] = pen;
				}
				return pen;
			}
		}

		public static Pen MediumOrchid
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[MediumOrchidKey];
				if (pen == null)
				{
					pen = new Pen(Color.MediumOrchid, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[MediumOrchidKey] = pen;
				}
				return pen;
			}
		}

		public static Pen MediumPurple
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[MediumPurpleKey];
				if (pen == null)
				{
					pen = new Pen(Color.MediumPurple, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[MediumPurpleKey] = pen;
				}
				return pen;
			}
		}

		public static Pen MediumSeaGreen
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[MediumSeaGreenKey];
				if (pen == null)
				{
					pen = new Pen(Color.MediumSeaGreen, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[MediumSeaGreenKey] = pen;
				}
				return pen;
			}
		}

		public static Pen MediumSlateBlue
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[MediumSlateBlueKey];
				if (pen == null)
				{
					pen = new Pen(Color.MediumSlateBlue, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[MediumSlateBlueKey] = pen;
				}
				return pen;
			}
		}

		public static Pen MediumSpringGreen
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[MediumSpringGreenKey];
				if (pen == null)
				{
					pen = new Pen(Color.MediumSpringGreen, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[MediumSpringGreenKey] = pen;
				}
				return pen;
			}
		}

		public static Pen MediumTurquoise
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[MediumTurquoiseKey];
				if (pen == null)
				{
					pen = new Pen(Color.MediumTurquoise, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[MediumTurquoiseKey] = pen;
				}
				return pen;
			}
		}

		public static Pen MediumVioletRed
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[MediumVioletRedKey];
				if (pen == null)
				{
					pen = new Pen(Color.MediumVioletRed, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[MediumVioletRedKey] = pen;
				}
				return pen;
			}
		}

		public static Pen MidnightBlue
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[MidnightBlueKey];
				if (pen == null)
				{
					pen = new Pen(Color.MidnightBlue, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[MidnightBlueKey] = pen;
				}
				return pen;
			}
		}

		public static Pen MintCream
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[MintCreamKey];
				if (pen == null)
				{
					pen = new Pen(Color.MintCream, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[MintCreamKey] = pen;
				}
				return pen;
			}
		}

		public static Pen MistyRose
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[MistyRoseKey];
				if (pen == null)
				{
					pen = new Pen(Color.MistyRose, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[MistyRoseKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Moccasin
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[MoccasinKey];
				if (pen == null)
				{
					pen = new Pen(Color.Moccasin, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[MoccasinKey] = pen;
				}
				return pen;
			}
		}

		public static Pen NavajoWhite
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[NavajoWhiteKey];
				if (pen == null)
				{
					pen = new Pen(Color.NavajoWhite, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[NavajoWhiteKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Navy
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[NavyKey];
				if (pen == null)
				{
					pen = new Pen(Color.Navy, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[NavyKey] = pen;
				}
				return pen;
			}
		}

		public static Pen OldLace
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[OldLaceKey];
				if (pen == null)
				{
					pen = new Pen(Color.OldLace, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[OldLaceKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Olive
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[OliveKey];
				if (pen == null)
				{
					pen = new Pen(Color.Olive, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[OliveKey] = pen;
				}
				return pen;
			}
		}

		public static Pen OliveDrab
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[OliveDrabKey];
				if (pen == null)
				{
					pen = new Pen(Color.OliveDrab, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[OliveDrabKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Orange
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[OrangeKey];
				if (pen == null)
				{
					pen = new Pen(Color.Orange, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[OrangeKey] = pen;
				}
				return pen;
			}
		}

		public static Pen OrangeRed
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[OrangeRedKey];
				if (pen == null)
				{
					pen = new Pen(Color.OrangeRed, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[OrangeRedKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Orchid
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[OrchidKey];
				if (pen == null)
				{
					pen = new Pen(Color.Orchid, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[OrchidKey] = pen;
				}
				return pen;
			}
		}

		public static Pen PaleGoldenrod
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[PaleGoldenrodKey];
				if (pen == null)
				{
					pen = new Pen(Color.PaleGoldenrod, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[PaleGoldenrodKey] = pen;
				}
				return pen;
			}
		}

		public static Pen PaleGreen
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[PaleGreenKey];
				if (pen == null)
				{
					pen = new Pen(Color.PaleGreen, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[PaleGreenKey] = pen;
				}
				return pen;
			}
		}

		public static Pen PaleTurquoise
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[PaleTurquoiseKey];
				if (pen == null)
				{
					pen = new Pen(Color.PaleTurquoise, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[PaleTurquoiseKey] = pen;
				}
				return pen;
			}
		}

		public static Pen PaleVioletRed
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[PaleVioletRedKey];
				if (pen == null)
				{
					pen = new Pen(Color.PaleVioletRed, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[PaleVioletRedKey] = pen;
				}
				return pen;
			}
		}

		public static Pen PapayaWhip
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[PapayaWhipKey];
				if (pen == null)
				{
					pen = new Pen(Color.PapayaWhip, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[PapayaWhipKey] = pen;
				}
				return pen;
			}
		}

		public static Pen PeachPuff
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[PeachPuffKey];
				if (pen == null)
				{
					pen = new Pen(Color.PeachPuff, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[PeachPuffKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Peru
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[PeruKey];
				if (pen == null)
				{
					pen = new Pen(Color.Peru, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[PeruKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Pink
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[PinkKey];
				if (pen == null)
				{
					pen = new Pen(Color.Pink, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[PinkKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Plum
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[PlumKey];
				if (pen == null)
				{
					pen = new Pen(Color.Plum, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[PlumKey] = pen;
				}
				return pen;
			}
		}

		public static Pen PowderBlue
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[PowderBlueKey];
				if (pen == null)
				{
					pen = new Pen(Color.PowderBlue, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[PowderBlueKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Purple
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[PurpleKey];
				if (pen == null)
				{
					pen = new Pen(Color.Purple, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[PurpleKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Red
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[RedKey];
				if (pen == null)
				{
					pen = new Pen(Color.Red, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[RedKey] = pen;
				}
				return pen;
			}
		}

		public static Pen RosyBrown
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[RosyBrownKey];
				if (pen == null)
				{
					pen = new Pen(Color.RosyBrown, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[RosyBrownKey] = pen;
				}
				return pen;
			}
		}

		public static Pen RoyalBlue
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[RoyalBlueKey];
				if (pen == null)
				{
					pen = new Pen(Color.RoyalBlue, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[RoyalBlueKey] = pen;
				}
				return pen;
			}
		}

		public static Pen SaddleBrown
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[SaddleBrownKey];
				if (pen == null)
				{
					pen = new Pen(Color.SaddleBrown, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[SaddleBrownKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Salmon
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[SalmonKey];
				if (pen == null)
				{
					pen = new Pen(Color.Salmon, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[SalmonKey] = pen;
				}
				return pen;
			}
		}

		public static Pen SandyBrown
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[SandyBrownKey];
				if (pen == null)
				{
					pen = new Pen(Color.SandyBrown, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[SandyBrownKey] = pen;
				}
				return pen;
			}
		}

		public static Pen SeaGreen
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[SeaGreenKey];
				if (pen == null)
				{
					pen = new Pen(Color.SeaGreen, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[SeaGreenKey] = pen;
				}
				return pen;
			}
		}

		public static Pen SeaShell
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[SeaShellKey];
				if (pen == null)
				{
					pen = new Pen(Color.SeaShell, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[SeaShellKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Sienna
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[SiennaKey];
				if (pen == null)
				{
					pen = new Pen(Color.Sienna, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[SiennaKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Silver
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[SilverKey];
				if (pen == null)
				{
					pen = new Pen(Color.Silver, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[SilverKey] = pen;
				}
				return pen;
			}
		}

		public static Pen SkyBlue
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[SkyBlueKey];
				if (pen == null)
				{
					pen = new Pen(Color.SkyBlue, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[SkyBlueKey] = pen;
				}
				return pen;
			}
		}

		public static Pen SlateBlue
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[SlateBlueKey];
				if (pen == null)
				{
					pen = new Pen(Color.SlateBlue, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[SlateBlueKey] = pen;
				}
				return pen;
			}
		}

		public static Pen SlateGray
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[SlateGrayKey];
				if (pen == null)
				{
					pen = new Pen(Color.SlateGray, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[SlateGrayKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Snow
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[SnowKey];
				if (pen == null)
				{
					pen = new Pen(Color.Snow, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[SnowKey] = pen;
				}
				return pen;
			}
		}

		public static Pen SpringGreen
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[SpringGreenKey];
				if (pen == null)
				{
					pen = new Pen(Color.SpringGreen, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[SpringGreenKey] = pen;
				}
				return pen;
			}
		}

		public static Pen SteelBlue
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[SteelBlueKey];
				if (pen == null)
				{
					pen = new Pen(Color.SteelBlue, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[SteelBlueKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Tan
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[TanKey];
				if (pen == null)
				{
					pen = new Pen(Color.Tan, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[TanKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Teal
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[TealKey];
				if (pen == null)
				{
					pen = new Pen(Color.Teal, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[TealKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Thistle
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[ThistleKey];
				if (pen == null)
				{
					pen = new Pen(Color.Thistle, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[ThistleKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Tomato
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[TomatoKey];
				if (pen == null)
				{
					pen = new Pen(Color.Tomato, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[TomatoKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Turquoise
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[TurquoiseKey];
				if (pen == null)
				{
					pen = new Pen(Color.Turquoise, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[TurquoiseKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Violet
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[VioletKey];
				if (pen == null)
				{
					pen = new Pen(Color.Violet, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[VioletKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Wheat
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[WheatKey];
				if (pen == null)
				{
					pen = new Pen(Color.Wheat, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[WheatKey] = pen;
				}
				return pen;
			}
		}

		public static Pen White
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[WhiteKey];
				if (pen == null)
				{
					pen = new Pen(Color.White, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[WhiteKey] = pen;
				}
				return pen;
			}
		}

		public static Pen WhiteSmoke
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[WhiteSmokeKey];
				if (pen == null)
				{
					pen = new Pen(Color.WhiteSmoke, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[WhiteSmokeKey] = pen;
				}
				return pen;
			}
		}

		public static Pen Yellow
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[YellowKey];
				if (pen == null)
				{
					pen = new Pen(Color.Yellow, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[YellowKey] = pen;
				}
				return pen;
			}
		}

		public static Pen YellowGreen
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[YellowGreenKey];
				if (pen == null)
				{
					pen = new Pen(Color.YellowGreen, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[YellowGreenKey] = pen;
				}
				return pen;
			}
		}

		private Pens()
		{
		}
	}
	[Serializable]
	[ComVisible(true)]
	[TypeConverter(typeof(PointConverter))]
	public struct Point
	{
		public static readonly Point Empty = default(Point);

		private int x;

		private int y;

		[Browsable(false)]
		public bool IsEmpty
		{
			get
			{
				if (x == 0)
				{
					return y == 0;
				}
				return false;
			}
		}

		public int X
		{
			get
			{
				return x;
			}
			set
			{
				x = value;
			}
		}

		public int Y
		{
			get
			{
				return y;
			}
			set
			{
				y = value;
			}
		}

		public Point(int x, int y)
		{
			this.x = x;
			this.y = y;
		}

		public Point(Size sz)
		{
			x = sz.Width;
			y = sz.Height;
		}

		public Point(int dw)
		{
			x = (short)LOWORD(dw);
			y = (short)HIWORD(dw);
		}

		public static implicit operator PointF(Point p)
		{
			return new PointF(p.X, p.Y);
		}

		public static explicit operator Size(Point p)
		{
			return new Size(p.X, p.Y);
		}

		public static Point operator +(Point pt, Size sz)
		{
			return Add(pt, sz);
		}

		public static Point operator -(Point pt, Size sz)
		{
			return Subtract(pt, sz);
		}

		public static bool operator ==(Point left, Point right)
		{
			if (left.X == right.X)
			{
				return left.Y == right.Y;
			}
			return false;
		}

		public static bool operator !=(Point left, Point right)
		{
			return !(left == right);
		}

		public static Point Add(Point pt, Size sz)
		{
			return new Point(pt.X + sz.Width, pt.Y + sz.Height);
		}

		public static Point Subtract(Point pt, Size sz)
		{
			return new Point(pt.X - sz.Width, pt.Y - sz.Height);
		}

		public static Point Ceiling(PointF value)
		{
			return new Point((int)Math.Ceiling(value.X), (int)Math.Ceiling(value.Y));
		}

		public static Point Truncate(PointF value)
		{
			return new Point((int)value.X, (int)value.Y);
		}

		public static Point Round(PointF value)
		{
			return new Point((int)Math.Round(value.X), (int)Math.Round(value.Y));
		}

		public override bool Equals(object obj)
		{
			if (!(obj is Point point))
			{
				return false;
			}
			if (point.X == X)
			{
				return point.Y == Y;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return x ^ y;
		}

		public void Offset(int dx, int dy)
		{
			X += dx;
			Y += dy;
		}

		public void Offset(Point p)
		{
			Offset(p.X, p.Y);
		}

		public override string ToString()
		{
			return "{X=" + X.ToString(CultureInfo.CurrentCulture) + ",Y=" + Y.ToString(CultureInfo.CurrentCulture) + "}";
		}

		private static int HIWORD(int n)
		{
			return (n >> 16) & 0xFFFF;
		}

		private static int LOWORD(int n)
		{
			return n & 0xFFFF;
		}
	}
	public class PointConverter : TypeConverter
	{
		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
		{
			if (sourceType == typeof(string))
			{
				return true;
			}
			return base.CanConvertFrom(context, sourceType);
		}

		public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
		{
			if (destinationType == typeof(InstanceDescriptor))
			{
				return true;
			}
			return base.CanConvertTo(context, destinationType);
		}

		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
		{
			if (value is string text)
			{
				string text2 = text.Trim();
				if (text2.Length == 0)
				{
					return null;
				}
				if (culture == null)
				{
					culture = CultureInfo.CurrentCulture;
				}
				char c = culture.TextInfo.ListSeparator[0];
				string[] array = text2.Split(c);
				int[] array2 = new int[array.Length];
				TypeConverter converter = TypeDescriptor.GetConverter(typeof(int));
				for (int i = 0; i < array2.Length; i++)
				{
					array2[i] = (int)converter.ConvertFromString(context, culture, array[i]);
				}
				if (array2.Length == 2)
				{
					return new Point(array2[0], array2[1]);
				}
				throw new ArgumentException(SR.GetString("TextParseFailedFormat", text2, "x, y"));
			}
			return base.ConvertFrom(context, culture, value);
		}

		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (value is Point)
			{
				if (destinationType == typeof(string))
				{
					Point point = (Point)value;
					if (culture == null)
					{
						culture = CultureInfo.CurrentCulture;
					}
					string separator = culture.TextInfo.ListSeparator + " ";
					TypeConverter converter = TypeDescriptor.GetConverter(typeof(int));
					string[] array = new string[2];
					int num = 0;
					array[num++] = converter.ConvertToString(context, culture, point.X);
					array[num++] = converter.ConvertToString(context, culture, point.Y);
					return string.Join(separator, array);
				}
				if (destinationType == typeof(InstanceDescriptor))
				{
					Point point2 = (Point)value;
					ConstructorInfo constructor = typeof(Point).GetConstructor(new Type[2]
					{
						typeof(int),
						typeof(int)
					});
					if (constructor != null)
					{
						return new InstanceDescriptor(constructor, new object[2] { point2.X, point2.Y });
					}
				}
			}
			return base.ConvertTo(context, culture, value, destinationType);
		}

		public override object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues)
		{
			if (propertyValues == null)
			{
				throw new ArgumentNullException("propertyValues");
			}
			object obj = propertyValues["X"];
			object obj2 = propertyValues["Y"];
			if (obj == null || obj2 == null || !(obj is int) || !(obj2 is int))
			{
				throw new ArgumentException(SR.GetString("PropertyValueInvalidEntry"));
			}
			return new Point((int)obj, (int)obj2);
		}

		public override bool GetCreateInstanceSupported(ITypeDescriptorContext context)
		{
			return true;
		}

		public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
		{
			PropertyDescriptorCollection properties = TypeDescriptor.GetProperties(typeof(Point), attributes);
			return properties.Sort(new string[2] { "X", "Y" });
		}

		public override bool GetPropertiesSupported(ITypeDescriptorContext context)
		{
			return true;
		}
	}
}
namespace System.Drawing.Imaging
{
	[StructLayout(LayoutKind.Sequential)]
	internal sealed class PropertyItemInternal : IDisposable
	{
		public int id;

		public int len;

		public short type;

		public IntPtr value = IntPtr.Zero;

		public byte[] Value
		{
			get
			{
				if (len == 0)
				{
					return null;
				}
				byte[] array = new byte[len];
				Marshal.Copy(value, array, 0, len);
				return array;
			}
		}

		internal PropertyItemInternal()
		{
		}

		~PropertyItemInternal()
		{
			Dispose(disposing: false);
		}

		public void Dispose()
		{
			Dispose(disposing: true);
		}

		private void Dispose(bool disposing)
		{
			if (value != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(value);
				value = IntPtr.Zero;
			}
			if (disposing)
			{
				GC.SuppressFinalize(this);
			}
		}

		internal static PropertyItemInternal ConvertFromPropertyItem(PropertyItem propItem)
		{
			PropertyItemInternal propertyItemInternal = new PropertyItemInternal();
			propertyItemInternal.id = propItem.Id;
			propertyItemInternal.len = 0;
			propertyItemInternal.type = propItem.Type;
			byte[] array = propItem.Value;
			if (array != null)
			{
				int num = (propertyItemInternal.len = array.Length);
				propertyItemInternal.value = Marshal.AllocHGlobal(num);
				Marshal.Copy(array, 0, propertyItemInternal.value, num);
			}
			return propertyItemInternal;
		}

		internal static PropertyItem[] ConvertFromMemory(IntPtr propdata, int count)
		{
			PropertyItem[] array = new PropertyItem[count];
			for (int i = 0; i < count; i++)
			{
				PropertyItemInternal propertyItemInternal = null;
				try
				{
					propertyItemInternal = (PropertyItemInternal)UnsafeNativeMethods.PtrToStructure(propdata, typeof(PropertyItemInternal));
					array[i] = new PropertyItem();
					array[i].Id = propertyItemInternal.id;
					array[i].Len = propertyItemInternal.len;
					array[i].Type = propertyItemInternal.type;
					array[i].Value = propertyItemInternal.Value;
					propertyItemInternal.value = IntPtr.Zero;
				}
				finally
				{
					propertyItemInternal?.Dispose();
				}
				propdata = (IntPtr)((long)propdata + Marshal.SizeOf(typeof(PropertyItemInternal)));
			}
			return array;
		}
	}
}
namespace System.Drawing
{
	[Serializable]
	[ComVisible(true)]
	[TypeConverter(typeof(RectangleConverter))]
	public struct Rectangle
	{
		public static readonly Rectangle Empty = default(Rectangle);

		private int x;

		private int y;

		private int width;

		private int height;

		[Browsable(false)]
		public Point Location
		{
			get
			{
				return new Point(X, Y);
			}
			set
			{
				X = value.X;
				Y = value.Y;
			}
		}

		[Browsable(false)]
		public Size Size
		{
			get
			{
				return new Size(Width, Height);
			}
			set
			{
				Width = value.Width;
				Height = value.Height;
			}
		}

		public int X
		{
			get
			{
				return x;
			}
			set
			{
				x = value;
			}
		}

		public int Y
		{
			get
			{
				return y;
			}
			set
			{
				y = value;
			}
		}

		public int Width
		{
			get
			{
				return width;
			}
			set
			{
				width = value;
			}
		}

		public int Height
		{
			get
			{
				return height;
			}
			set
			{
				height = value;
			}
		}

		[Browsable(false)]
		public int Left => X;

		[Browsable(false)]
		public int Top => Y;

		[Browsable(false)]
		public int Right => X + Width;

		[Browsable(false)]
		public int Bottom => Y + Height;

		[Browsable(false)]
		public bool IsEmpty
		{
			get
			{
				if (height == 0 && width == 0 && x == 0)
				{
					return y == 0;
				}
				return false;
			}
		}

		public Rectangle(int x, int y, int width, int height)
		{
			this.x = x;
			this.y = y;
			this.width = width;
			this.height = height;
		}

		public Rectangle(Point location, Size size)
		{
			x = location.X;
			y = location.Y;
			width = size.Width;
			height = size.Height;
		}

		public static Rectangle FromLTRB(int left, int top, int right, int bottom)
		{
			return new Rectangle(left, top, right - left, bottom - top);
		}

		public override bool Equals(object obj)
		{
			if (!(obj is Rectangle rectangle))
			{
				return false;
			}
			if (rectangle.X == X && rectangle.Y == Y && rectangle.Width == Width)
			{
				return rectangle.Height == Height;
			}
			return false;
		}

		public static bool operator ==(Rectangle left, Rectangle right)
		{
			if (left.X == right.X && left.Y == right.Y && left.Width == right.Width)
			{
				return left.Height == right.Height;
			}
			return false;
		}

		public static bool operator !=(Rectangle left, Rectangle right)
		{
			return !(left == right);
		}

		public static Rectangle Ceiling(RectangleF value)
		{
			return new Rectangle((int)Math.Ceiling(value.X), (int)Math.Ceiling(value.Y), (int)Math.Ceiling(value.Width), (int)Math.Ceiling(value.Height));
		}

		public static Rectangle Truncate(RectangleF value)
		{
			return new Rectangle((int)value.X, (int)value.Y, (int)value.Width, (int)value.Height);
		}

		public static Rectangle Round(RectangleF value)
		{
			return new Rectangle((int)Math.Round(value.X), (int)Math.Round(value.Y), (int)Math.Round(value.Width), (int)Math.Round(value.Height));
		}

		public bool Contains(int x, int y)
		{
			if (X <= x && x < X + Width && Y <= y)
			{
				return y < Y + Height;
			}
			return false;
		}

		public bool Contains(Point pt)
		{
			return Contains(pt.X, pt.Y);
		}

		public bool Contains(Rectangle rect)
		{
			if (X <= rect.X && rect.X + rect.Width <= X + Width && Y <= rect.Y)
			{
				return rect.Y + rect.Height <= Y + Height;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return X ^ ((Y << 13) | (int)((uint)Y >> 19)) ^ ((Width << 26) | (int)((uint)Width >> 6)) ^ ((Height << 7) | (int)((uint)Height >> 25));
		}

		public void Inflate(int width, int height)
		{
			X -= width;
			Y -= height;
			Width += 2 * width;
			Height += 2 * height;
		}

		public void Inflate(Size size)
		{
			Inflate(size.Width, size.Height);
		}

		public static Rectangle Inflate(Rectangle rect, int x, int y)
		{
			Rectangle result = rect;
			result.Inflate(x, y);
			return result;
		}

		public void Intersect(Rectangle rect)
		{
			Rectangle rectangle = Intersect(rect, this);
			X = rectangle.X;
			Y = rectangle.Y;
			Width = rectangle.Width;
			Height = rectangle.Height;
		}

		public static Rectangle Intersect(Rectangle a, Rectangle b)
		{
			int num = Math.Max(a.X, b.X);
			int num2 = Math.Min(a.X + a.Width, b.X + b.Width);
			int num3 = Math.Max(a.Y, b.Y);
			int num4 = Math.Min(a.Y + a.Height, b.Y + b.Height);
			if (num2 >= num && num4 >= num3)
			{
				return new Rectangle(num, num3, num2 - num, num4 - num3);
			}
			return Empty;
		}

		public bool IntersectsWith(Rectangle rect)
		{
			if (rect.X < X + Width && X < rect.X + rect.Width && rect.Y < Y + Height)
			{
				return Y < rect.Y + rect.Height;
			}
			return false;
		}

		public static Rectangle Union(Rectangle a, Rectangle b)
		{
			int num = Math.Min(a.X, b.X);
			int num2 = Math.Max(a.X + a.Width, b.X + b.Width);
			int num3 = Math.Min(a.Y, b.Y);
			int num4 = Math.Max(a.Y + a.Height, b.Y + b.Height);
			return new Rectangle(num, num3, num2 - num, num4 - num3);
		}

		public void Offset(Point pos)
		{
			Offset(pos.X, pos.Y);
		}

		public void Offset(int x, int y)
		{
			X += x;
			Y += y;
		}

		public override string ToString()
		{
			return "{X=" + X.ToString(CultureInfo.CurrentCulture) + ",Y=" + Y.ToString(CultureInfo.CurrentCulture) + ",Width=" + Width.ToString(CultureInfo.CurrentCulture) + ",Height=" + Height.ToString(CultureInfo.CurrentCulture) + "}";
		}
	}
	public class RectangleConverter : TypeConverter
	{
		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
		{
			if (sourceType == typeof(string))
			{
				return true;
			}
			return base.CanConvertFrom(context, sourceType);
		}

		public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
		{
			if (destinationType == typeof(InstanceDescriptor))
			{
				return true;
			}
			return base.CanConvertTo(context, destinationType);
		}

		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
		{
			if (value is string text)
			{
				string text2 = text.Trim();
				if (text2.Length == 0)
				{
					return null;
				}
				if (culture == null)
				{
					culture = CultureInfo.CurrentCulture;
				}
				char c = culture.TextInfo.ListSeparator[0];
				string[] array = text2.Split(c);
				int[] array2 = new int[array.Length];
				TypeConverter converter = TypeDescriptor.GetConverter(typeof(int));
				for (int i = 0; i < array2.Length; i++)
				{
					array2[i] = (int)converter.ConvertFromString(context, culture, array[i]);
				}
				if (array2.Length == 4)
				{
					return new Rectangle(array2[0], array2[1], array2[2], array2[3]);
				}
				throw new ArgumentException(SR.GetString("TextParseFailedFormat", "text", text2, "x, y, width, height"));
			}
			return base.ConvertFrom(context, culture, value);
		}

		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (value is Rectangle)
			{
				if (destinationType == typeof(string))
				{
					Rectangle rectangle = (Rectangle)value;
					if (culture == null)
					{
						culture = CultureInfo.CurrentCulture;
					}
					string separator = culture.TextInfo.ListSeparator + " ";
					TypeConverter converter = TypeDescriptor.GetConverter(typeof(int));
					string[] array = new string[4];
					int num = 0;
					array[num++] = converter.ConvertToString(context, culture, rectangle.X);
					array[num++] = converter.ConvertToString(context, culture, rectangle.Y);
					array[num++] = converter.ConvertToString(context, culture, rectangle.Width);
					array[num++] = converter.ConvertToString(context, culture, rectangle.Height);
					return string.Join(separator, array);
				}
				if (destinationType == typeof(InstanceDescriptor))
				{
					Rectangle rectangle2 = (Rectangle)value;
					ConstructorInfo constructor = typeof(Rectangle).GetConstructor(new Type[4]
					{
						typeof(int),
						typeof(int),
						typeof(int),
						typeof(int)
					});
					if (constructor != null)
					{
						return new InstanceDescriptor(constructor, new object[4] { rectangle2.X, rectangle2.Y, rectangle2.Width, rectangle2.Height });
					}
				}
			}
			return base.ConvertTo(context, culture, value, destinationType);
		}

		public override object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues)
		{
			if (propertyValues == null)
			{
				throw new ArgumentNullException("propertyValues");
			}
			object obj = propertyValues["X"];
			object obj2 = propertyValues["Y"];
			object obj3 = propertyValues["Width"];
			object obj4 = propertyValues["Height"];
			if (obj == null || obj2 == null || obj3 == null || obj4 == null || !(obj is int) || !(obj2 is int) || !(obj3 is int) || !(obj4 is int))
			{
				throw new ArgumentException(SR.GetString("PropertyValueInvalidEntry"));
			}
			return new Rectangle((int)obj, (int)obj2, (int)obj3, (int)obj4);
		}

		public override bool GetCreateInstanceSupported(ITypeDescriptorContext context)
		{
			return true;
		}

		public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
		{
			PropertyDescriptorCollection properties = TypeDescriptor.GetProperties(typeof(Rectangle), attributes);
			return properties.Sort(new string[4] { "X", "Y", "Width", "Height" });
		}

		public override bool GetPropertiesSupported(ITypeDescriptorContext context)
		{
			return true;
		}
	}
	public sealed class Region : MarshalByRefObject, IDisposable
	{
		internal IntPtr nativeRegion;

		public Region()
		{
			IntPtr region = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateRegion(out region);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeRegion(region);
		}

		public Region(RectangleF rect)
		{
			IntPtr region = IntPtr.Zero;
			GPRECTF gprectf = rect.ToGPRECTF();
			int num = SafeNativeMethods.Gdip.GdipCreateRegionRect(ref gprectf, out region);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeRegion(region);
		}

		public Region(Rectangle rect)
		{
			IntPtr region = IntPtr.Zero;
			GPRECT gprect = new GPRECT(rect);
			int num = SafeNativeMethods.Gdip.GdipCreateRegionRectI(ref gprect, out region);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeRegion(region);
		}

		public Region(GraphicsPath path)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			IntPtr region = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateRegionPath(new HandleRef(path, path.nativePath), out region);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeRegion(region);
		}

		public Region(RegionData rgnData)
		{
			if (rgnData == null)
			{
				throw new ArgumentNullException("rgnData");
			}
			IntPtr region = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateRegionRgnData(rgnData.Data, rgnData.Data.Length, out region);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeRegion(region);
		}

		internal Region(IntPtr nativeRegion)
		{
			SetNativeRegion(nativeRegion);
		}

		public static Region FromHrgn(IntPtr hrgn)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			IntPtr region = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateRegionHrgn(new HandleRef(null, hrgn), out region);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new Region(region);
		}

		private void SetNativeRegion(IntPtr nativeRegion)
		{
			if (nativeRegion == IntPtr.Zero)
			{
				throw new ArgumentNullException("nativeRegion");
			}
			this.nativeRegion = nativeRegion;
		}

		public Region Clone()
		{
			IntPtr cloneregion = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCloneRegion(new HandleRef(this, nativeRegion), out cloneregion);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new Region(cloneregion);
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		private void Dispose(bool disposing)
		{
			if (!(nativeRegion != IntPtr.Zero))
			{
				return;
			}
			try
			{
				SafeNativeMethods.Gdip.GdipDeleteRegion(new HandleRef(this, nativeRegion));
			}
			catch (Exception ex)
			{
				if (ClientUtils.IsSecurityOrCriticalException(ex))
				{
					throw;
				}
			}
			finally
			{
				nativeRegion = IntPtr.Zero;
			}
		}

		~Region()
		{
			Dispose(disposing: false);
		}

		public void MakeInfinite()
		{
			int num = SafeNativeMethods.Gdip.GdipSetInfinite(new HandleRef(this, nativeRegion));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void MakeEmpty()
		{
			int num = SafeNativeMethods.Gdip.GdipSetEmpty(new HandleRef(this, nativeRegion));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void Intersect(RectangleF rect)
		{
			GPRECTF gprectf = rect.ToGPRECTF();
			int num = SafeNativeMethods.Gdip.GdipCombineRegionRect(new HandleRef(this, nativeRegion), ref gprectf, CombineMode.Intersect);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void Intersect(Rectangle rect)
		{
			GPRECT gprect = new GPRECT(rect);
			int num = SafeNativeMethods.Gdip.GdipCombineRegionRectI(new HandleRef(this, nativeRegion), ref gprect, CombineMode.Intersect);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void Intersect(GraphicsPath path)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			int num = SafeNativeMethods.Gdip.GdipCombineRegionPath(new HandleRef(this, nativeRegion), new HandleRef(path, path.nativePath), CombineMode.Intersect);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void Intersect(Region region)
		{
			if (region == null)
			{
				throw new ArgumentNullException("region");
			}
			int num = SafeNativeMethods.Gdip.GdipCombineRegionRegion(new HandleRef(this, nativeRegion), new HandleRef(region, region.nativeRegion), CombineMode.Intersect);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void ReleaseHrgn(IntPtr regionHandle)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			if (regionHandle == IntPtr.Zero)
			{
				throw new ArgumentNullException("regionHandle");
			}
			SafeNativeMethods.IntDeleteObject(new HandleRef(this, regionHandle));
		}

		public void Union(RectangleF rect)
		{
			GPRECTF gprectf = new GPRECTF(rect);
			int num = SafeNativeMethods.Gdip.GdipCombineRegionRect(new HandleRef(this, nativeRegion), ref gprectf, CombineMode.Union);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void Union(Rectangle rect)
		{
			GPRECT gprect = new GPRECT(rect);
			int num = SafeNativeMethods.Gdip.GdipCombineRegionRectI(new HandleRef(this, nativeRegion), ref gprect, CombineMode.Union);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void Union(GraphicsPath path)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			int num = SafeNativeMethods.Gdip.GdipCombineRegionPath(new HandleRef(this, nativeRegion), new HandleRef(path, path.nativePath), CombineMode.Union);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void Union(Region region)
		{
			if (region == null)
			{
				throw new ArgumentNullException("region");
			}
			int num = SafeNativeMethods.Gdip.GdipCombineRegionRegion(new HandleRef(this, nativeRegion), new HandleRef(region, region.nativeRegion), CombineMode.Union);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void Xor(RectangleF rect)
		{
			GPRECTF gprectf = new GPRECTF(rect);
			int num = SafeNativeMethods.Gdip.GdipCombineRegionRect(new HandleRef(this, nativeRegion), ref gprectf, CombineMode.Xor);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void Xor(Rectangle rect)
		{
			GPRECT gprect = new GPRECT(rect);
			int num = SafeNativeMethods.Gdip.GdipCombineRegionRectI(new HandleRef(this, nativeRegion), ref gprect, CombineMode.Xor);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void Xor(GraphicsPath path)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			int num = SafeNativeMethods.Gdip.GdipCombineRegionPath(new HandleRef(this, nativeRegion), new HandleRef(path, path.nativePath), CombineMode.Xor);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void Xor(Region region)
		{
			if (region == null)
			{
				throw new ArgumentNullException("region");
			}
			int num = SafeNativeMethods.Gdip.GdipCombineRegionRegion(new HandleRef(this, nativeRegion), new HandleRef(region, region.nativeRegion), CombineMode.Xor);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void Exclude(RectangleF rect)
		{
			GPRECTF gprectf = new GPRECTF(rect);
			int num = SafeNativeMethods.Gdip.GdipCombineRegionRect(new HandleRef(this, nativeRegion), ref gprectf, CombineMode.Exclude);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void Exclude(Rectangle rect)
		{
			GPRECT gprect = new GPRECT(rect);
			int num = SafeNativeMethods.Gdip.GdipCombineRegionRectI(new HandleRef(this, nativeRegion), ref gprect, CombineMode.Exclude);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void Exclude(GraphicsPath path)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			int num = SafeNativeMethods.Gdip.GdipCombineRegionPath(new HandleRef(this, nativeRegion), new HandleRef(path, path.nativePath), CombineMode.Exclude);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void Exclude(Region region)
		{
			if (region == null)
			{
				throw new ArgumentNullException("region");
			}
			int num = SafeNativeMethods.Gdip.GdipCombineRegionRegion(new HandleRef(this, nativeRegion), new HandleRef(region, region.nativeRegion), CombineMode.Exclude);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void Complement(RectangleF rect)
		{
			GPRECTF gprectf = rect.ToGPRECTF();
			int num = SafeNativeMethods.Gdip.GdipCombineRegionRect(new HandleRef(this, nativeRegion), ref gprectf, CombineMode.Complement);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void Complement(Rectangle rect)
		{
			GPRECT gprect = new GPRECT(rect);
			int num = SafeNativeMethods.Gdip.GdipCombineRegionRectI(new HandleRef(this, nativeRegion), ref gprect, CombineMode.Complement);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void Complement(GraphicsPath path)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			int num = SafeNativeMethods.Gdip.GdipCombineRegionPath(new HandleRef(this, nativeRegion), new HandleRef(path, path.nativePath), CombineMode.Complement);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void Complement(Region region)
		{
			if (region == null)
			{
				throw new ArgumentNullException("region");
			}
			int num = SafeNativeMethods.Gdip.GdipCombineRegionRegion(new HandleRef(this, nativeRegion), new HandleRef(region, region.nativeRegion), CombineMode.Complement);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void Translate(float dx, float dy)
		{
			int num = SafeNativeMethods.Gdip.GdipTranslateRegion(new HandleRef(this, nativeRegion), dx, dy);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void Translate(int dx, int dy)
		{
			int num = SafeNativeMethods.Gdip.GdipTranslateRegionI(new HandleRef(this, nativeRegion), dx, dy);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void Transform(Matrix matrix)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			int num = SafeNativeMethods.Gdip.GdipTransformRegion(new HandleRef(this, nativeRegion), new HandleRef(matrix, matrix.nativeMatrix));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public RectangleF GetBounds(Graphics g)
		{
			if (g == null)
			{
				throw new ArgumentNullException("g");
			}
			GPRECTF gprectf = default(GPRECTF);
			int num = SafeNativeMethods.Gdip.GdipGetRegionBounds(new HandleRef(this, nativeRegion), new HandleRef(g, g.NativeGraphics), ref gprectf);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return gprectf.ToRectangleF();
		}

		public IntPtr GetHrgn(Graphics g)
		{
			if (g == null)
			{
				throw new ArgumentNullException("g");
			}
			IntPtr hrgn = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipGetRegionHRgn(new HandleRef(this, nativeRegion), new HandleRef(g, g.NativeGraphics), out hrgn);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return hrgn;
		}

		public bool IsEmpty(Graphics g)
		{
			if (g == null)
			{
				throw new ArgumentNullException("g");
			}
			int boolean;
			int num = SafeNativeMethods.Gdip.GdipIsEmptyRegion(new HandleRef(this, nativeRegion), new HandleRef(g, g.NativeGraphics), out boolean);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return boolean != 0;
		}

		public bool IsInfinite(Graphics g)
		{
			if (g == null)
			{
				throw new ArgumentNullException("g");
			}
			int boolean;
			int num = SafeNativeMethods.Gdip.GdipIsInfiniteRegion(new HandleRef(this, nativeRegion), new HandleRef(g, g.NativeGraphics), out boolean);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return boolean != 0;
		}

		public bool Equals(Region region, Graphics g)
		{
			if (g == null)
			{
				throw new ArgumentNullException("g");
			}
			if (region == null)
			{
				throw new ArgumentNullException("region");
			}
			int boolean;
			int num = SafeNativeMethods.Gdip.GdipIsEqualRegion(new HandleRef(this, nativeRegion), new HandleRef(region, region.nativeRegion), new HandleRef(g, g.NativeGraphics), out boolean);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return boolean != 0;
		}

		public RegionData GetRegionData()
		{
			int bufferSize = 0;
			int num = SafeNativeMethods.Gdip.GdipGetRegionDataSize(new HandleRef(this, nativeRegion), out bufferSize);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			if (bufferSize == 0)
			{
				return null;
			}
			byte[] array = new byte[bufferSize];
			num = SafeNativeMethods.Gdip.GdipGetRegionData(new HandleRef(this, nativeRegion), array, bufferSize, out bufferSize);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new RegionData(array);
		}

		public bool IsVisible(float x, float y)
		{
			return IsVisible(new PointF(x, y), null);
		}

		public bool IsVisible(PointF point)
		{
			return IsVisible(point, null);
		}

		public bool IsVisible(float x, float y, Graphics g)
		{
			return IsVisible(new PointF(x, y), g);
		}

		public bool IsVisible(PointF point, Graphics g)
		{
			int boolean;
			int num = SafeNativeMethods.Gdip.GdipIsVisibleRegionPoint(new HandleRef(this, nativeRegion), point.X, point.Y, new HandleRef(g, g?.NativeGraphics ?? IntPtr.Zero), out boolean);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return boolean != 0;
		}

		public bool IsVisible(float x, float y, float width, float height)
		{
			return IsVisible(new RectangleF(x, y, width, height), null);
		}

		public bool IsVisible(RectangleF rect)
		{
			return IsVisible(rect, null);
		}

		public bool IsVisible(float x, float y, float width, float height, Graphics g)
		{
			return IsVisible(new RectangleF(x, y, width, height), g);
		}

		public bool IsVisible(RectangleF rect, Graphics g)
		{
			int boolean = 0;
			int num = SafeNativeMethods.Gdip.GdipIsVisibleRegionRect(new HandleRef(this, nativeRegion), rect.X, rect.Y, rect.Width, rect.Height, new HandleRef(g, g?.NativeGraphics ?? IntPtr.Zero), out boolean);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return boolean != 0;
		}

		public bool IsVisible(int x, int y, Graphics g)
		{
			return IsVisible(new Point(x, y), g);
		}

		public bool IsVisible(Point point)
		{
			return IsVisible(point, null);
		}

		public bool IsVisible(Point point, Graphics g)
		{
			int boolean = 0;
			int num = SafeNativeMethods.Gdip.GdipIsVisibleRegionPointI(new HandleRef(this, nativeRegion), point.X, point.Y, new HandleRef(g, g?.NativeGraphics ?? IntPtr.Zero), out boolean);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return boolean != 0;
		}

		public bool IsVisible(int x, int y, int width, int height)
		{
			return IsVisible(new Rectangle(x, y, width, height), null);
		}

		public bool IsVisible(Rectangle rect)
		{
			return IsVisible(rect, null);
		}

		public bool IsVisible(int x, int y, int width, int height, Graphics g)
		{
			return IsVisible(new Rectangle(x, y, width, height), g);
		}

		public bool IsVisible(Rectangle rect, Graphics g)
		{
			int boolean = 0;
			int num = SafeNativeMethods.Gdip.GdipIsVisibleRegionRectI(new HandleRef(this, nativeRegion), rect.X, rect.Y, rect.Width, rect.Height, new HandleRef(g, g?.NativeGraphics ?? IntPtr.Zero), out boolean);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return boolean != 0;
		}

		public RectangleF[] GetRegionScans(Matrix matrix)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			int count = 0;
			int num = SafeNativeMethods.Gdip.GdipGetRegionScansCount(new HandleRef(this, nativeRegion), out count, new HandleRef(matrix, matrix.nativeMatrix));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			int num2 = Marshal.SizeOf(typeof(GPRECTF));
			IntPtr intPtr = Marshal.AllocHGlobal(checked(num2 * count));
			try
			{
				num = SafeNativeMethods.Gdip.GdipGetRegionScans(new HandleRef(this, nativeRegion), intPtr, out count, new HandleRef(matrix, matrix.nativeMatrix));
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				GPRECTF gPRECTF = default(GPRECTF);
				RectangleF[] array = new RectangleF[count];
				for (int i = 0; i < count; i++)
				{
					gPRECTF = (GPRECTF)UnsafeNativeMethods.PtrToStructure((IntPtr)checked((long)intPtr + num2 * i), typeof(GPRECTF));
					ref RectangleF reference = ref array[i];
					reference = gPRECTF.ToRectangleF();
				}
				return array;
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}
	}
	public enum RotateFlipType
	{
		RotateNoneFlipNone = 0,
		Rotate90FlipNone = 1,
		Rotate180FlipNone = 2,
		Rotate270FlipNone = 3,
		RotateNoneFlipX = 4,
		Rotate90FlipX = 5,
		Rotate180FlipX = 6,
		Rotate270FlipX = 7,
		RotateNoneFlipY = 6,
		Rotate90FlipY = 7,
		Rotate180FlipY = 4,
		Rotate270FlipY = 5,
		RotateNoneFlipXY = 2,
		Rotate90FlipXY = 3,
		Rotate180FlipXY = 0,
		Rotate270FlipXY = 1
	}
	[Serializable]
	[ComVisible(true)]
	[TypeConverter(typeof(SizeConverter))]
	public struct Size
	{
		public static readonly Size Empty = default(Size);

		private int width;

		private int height;

		[Browsable(false)]
		public bool IsEmpty
		{
			get
			{
				if (width == 0)
				{
					return height == 0;
				}
				return false;
			}
		}

		public int Width
		{
			get
			{
				return width;
			}
			set
			{
				width = value;
			}
		}

		public int Height
		{
			get
			{
				return height;
			}
			set
			{
				height = value;
			}
		}

		public Size(Point pt)
		{
			width = pt.X;
			height = pt.Y;
		}

		public Size(int width, int height)
		{
			this.width = width;
			this.height = height;
		}

		public static implicit operator SizeF(Size p)
		{
			return new SizeF(p.Width, p.Height);
		}

		public static Size operator +(Size sz1, Size sz2)
		{
			return Add(sz1, sz2);
		}

		public static Size operator -(Size sz1, Size sz2)
		{
			return Subtract(sz1, sz2);
		}

		public static bool operator ==(Size sz1, Size sz2)
		{
			if (sz1.Width == sz2.Width)
			{
				return sz1.Height == sz2.Height;
			}
			return false;
		}

		public static bool operator !=(Size sz1, Size sz2)
		{
			return !(sz1 == sz2);
		}

		public static explicit operator Point(Size size)
		{
			return new Point(size.Width, size.Height);
		}

		public static Size Add(Size sz1, Size sz2)
		{
			return new Size(sz1.Width + sz2.Width, sz1.Height + sz2.Height);
		}

		public static Size Ceiling(SizeF value)
		{
			return new Size((int)Math.Ceiling(value.Width), (int)Math.Ceiling(value.Height));
		}

		public static Size Subtract(Size sz1, Size sz2)
		{
			return new Size(sz1.Width - sz2.Width, sz1.Height - sz2.Height);
		}

		public static Size Truncate(SizeF value)
		{
			return new Size((int)value.Width, (int)value.Height);
		}

		public static Size Round(SizeF value)
		{
			return new Size((int)Math.Round(value.Width), (int)Math.Round(value.Height));
		}

		public override bool Equals(object obj)
		{
			if (!(obj is Size size))
			{
				return false;
			}
			if (size.width == width)
			{
				return size.height == height;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return width ^ height;
		}

		public override string ToString()
		{
			return "{Width=" + width.ToString(CultureInfo.CurrentCulture) + ", Height=" + height.ToString(CultureInfo.CurrentCulture) + "}";
		}
	}
	public class SizeConverter : TypeConverter
	{
		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
		{
			if (sourceType == typeof(string))
			{
				return true;
			}
			return base.CanConvertFrom(context, sourceType);
		}

		public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
		{
			if (destinationType == typeof(InstanceDescriptor))
			{
				return true;
			}
			return base.CanConvertTo(context, destinationType);
		}

		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
		{
			if (value is string text)
			{
				string text2 = text.Trim();
				if (text2.Length == 0)
				{
					return null;
				}
				if (culture == null)
				{
					culture = CultureInfo.CurrentCulture;
				}
				char c = culture.TextInfo.ListSeparator[0];
				string[] array = text2.Split(c);
				int[] array2 = new int[array.Length];
				TypeConverter converter = TypeDescriptor.GetConverter(typeof(int));
				for (int i = 0; i < array2.Length; i++)
				{
					array2[i] = (int)converter.ConvertFromString(context, culture, array[i]);
				}
				if (array2.Length == 2)
				{
					return new Size(array2[0], array2[1]);
				}
				throw new ArgumentException(SR.GetString("TextParseFailedFormat", text2, "Width,Height"));
			}
			return base.ConvertFrom(context, culture, value);
		}

		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (value is Size)
			{
				if (destinationType == typeof(string))
				{
					Size size = (Size)value;
					if (culture == null)
					{
						culture = CultureInfo.CurrentCulture;
					}
					string separator = culture.TextInfo.ListSeparator + " ";
					TypeConverter converter = TypeDescriptor.GetConverter(typeof(int));
					string[] array = new string[2];
					int num = 0;
					array[num++] = converter.ConvertToString(context, culture, size.Width);
					array[num++] = converter.ConvertToString(context, culture, size.Height);
					return string.Join(separator, array);
				}
				if (destinationType == typeof(InstanceDescriptor))
				{
					Size size2 = (Size)value;
					ConstructorInfo constructor = typeof(Size).GetConstructor(new Type[2]
					{
						typeof(int),
						typeof(int)
					});
					if (constructor != null)
					{
						return new InstanceDescriptor(constructor, new object[2] { size2.Width, size2.Height });
					}
				}
			}
			return base.ConvertTo(context, culture, value, destinationType);
		}

		public override object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues)
		{
			if (propertyValues == null)
			{
				throw new ArgumentNullException("propertyValues");
			}
			object obj = propertyValues["Width"];
			object obj2 = propertyValues["Height"];
			if (obj == null || obj2 == null || !(obj is int) || !(obj2 is int))
			{
				throw new ArgumentException(SR.GetString("PropertyValueInvalidEntry"));
			}
			return new Size((int)obj, (int)obj2);
		}

		public override bool GetCreateInstanceSupported(ITypeDescriptorContext context)
		{
			return true;
		}

		public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
		{
			PropertyDescriptorCollection properties = TypeDescriptor.GetProperties(typeof(Size), attributes);
			return properties.Sort(new string[2] { "Width", "Height" });
		}

		public override bool GetPropertiesSupported(ITypeDescriptorContext context)
		{
			return true;
		}
	}
	public sealed class SolidBrush : Brush, ISystemColorTracker
	{
		private Color color = Color.Empty;

		private bool immutable;

		public Color Color
		{
			get
			{
				if (color == Color.Empty)
				{
					int argb = 0;
					int num = SafeNativeMethods.Gdip.GdipGetSolidFillColor(new HandleRef(this, base.NativeBrush), out argb);
					if (num != 0)
					{
						throw SafeNativeMethods.Gdip.StatusException(num);
					}
					color = Color.FromArgb(argb);
				}
				return color;
			}
			set
			{
				if (immutable)
				{
					throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Brush"));
				}
				if (this.color != value)
				{
					Color color = this.color;
					InternalSetColor(value);
					if (value.IsSystemColor && !color.IsSystemColor)
					{
						SystemColorTracker.Add(this);
					}
				}
			}
		}

		public SolidBrush(Color color)
		{
			this.color = color;
			IntPtr brush = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateSolidFill(this.color.ToArgb(), out brush);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeBrushInternal(brush);
			if (color.IsSystemColor)
			{
				SystemColorTracker.Add(this);
			}
		}

		internal SolidBrush(Color color, bool immutable)
			: this(color)
		{
			this.immutable = immutable;
		}

		internal SolidBrush(IntPtr nativeBrush)
		{
			SetNativeBrushInternal(nativeBrush);
		}

		public override object Clone()
		{
			IntPtr clonebrush = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCloneBrush(new HandleRef(this, base.NativeBrush), out clonebrush);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new SolidBrush(clonebrush);
		}

		protected override void Dispose(bool disposing)
		{
			if (!disposing)
			{
				immutable = false;
			}
			else if (immutable)
			{
				throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Brush"));
			}
			base.Dispose(disposing);
		}

		private void InternalSetColor(Color value)
		{
			int num = SafeNativeMethods.Gdip.GdipSetSolidFillColor(new HandleRef(this, base.NativeBrush), value.ToArgb());
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			color = value;
		}

		void ISystemColorTracker.OnSystemColorChanged()
		{
			if (base.NativeBrush != IntPtr.Zero)
			{
				InternalSetColor(color);
			}
		}
	}
	public sealed class SystemBrushes
	{
		private static readonly object SystemBrushesKey = new object();

		public static Brush ActiveBorder => FromSystemColor(SystemColors.ActiveBorder);

		public static Brush ActiveCaption => FromSystemColor(SystemColors.ActiveCaption);

		public static Brush ActiveCaptionText => FromSystemColor(SystemColors.ActiveCaptionText);

		public static Brush AppWorkspace => FromSystemColor(SystemColors.AppWorkspace);

		public static Brush ButtonFace => FromSystemColor(SystemColors.ButtonFace);

		public static Brush ButtonHighlight => FromSystemColor(SystemColors.ButtonHighlight);

		public static Brush ButtonShadow => FromSystemColor(SystemColors.ButtonShadow);

		public static Brush Control => FromSystemColor(SystemColors.Control);

		public static Brush ControlLightLight => FromSystemColor(SystemColors.ControlLightLight);

		public static Brush ControlLight => FromSystemColor(SystemColors.ControlLight);

		public static Brush ControlDark => FromSystemColor(SystemColors.ControlDark);

		public static Brush ControlDarkDark => FromSystemColor(SystemColors.ControlDarkDark);

		public static Brush ControlText => FromSystemColor(SystemColors.ControlText);

		public static Brush Desktop => FromSystemColor(SystemColors.Desktop);

		public static Brush GradientActiveCaption => FromSystemColor(SystemColors.GradientActiveCaption);

		public static Brush GradientInactiveCaption => FromSystemColor(SystemColors.GradientInactiveCaption);

		public static Brush GrayText => FromSystemColor(SystemColors.GrayText);

		public static Brush Highlight => FromSystemColor(SystemColors.Highlight);

		public static Brush HighlightText => FromSystemColor(SystemColors.HighlightText);

		public static Brush HotTrack => FromSystemColor(SystemColors.HotTrack);

		public static Brush InactiveCaption => FromSystemColor(SystemColors.InactiveCaption);

		public static Brush InactiveBorder => FromSystemColor(SystemColors.InactiveBorder);

		public static Brush InactiveCaptionText => FromSystemColor(SystemColors.InactiveCaptionText);

		public static Brush Info => FromSystemColor(SystemColors.Info);

		public static Brush InfoText => FromSystemColor(SystemColors.InfoText);

		public static Brush Menu => FromSystemColor(SystemColors.Menu);

		public static Brush MenuBar => FromSystemColor(SystemColors.MenuBar);

		public static Brush MenuHighlight => FromSystemColor(SystemColors.MenuHighlight);

		public static Brush MenuText => FromSystemColor(SystemColors.MenuText);

		public static Brush ScrollBar => FromSystemColor(SystemColors.ScrollBar);

		public static Brush Window => FromSystemColor(SystemColors.Window);

		public static Brush WindowFrame => FromSystemColor(SystemColors.WindowFrame);

		public static Brush WindowText => FromSystemColor(SystemColors.WindowText);

		private SystemBrushes()
		{
		}

		public static Brush FromSystemColor(Color c)
		{
			if (!c.IsSystemColor)
			{
				throw new ArgumentException(SR.GetString("ColorNotSystemColor", c.ToString()));
			}
			Brush[] array = (Brush[])SafeNativeMethods.Gdip.ThreadData[SystemBrushesKey];
			if (array == null)
			{
				array = new Brush[33];
				SafeNativeMethods.Gdip.ThreadData[SystemBrushesKey] = array;
			}
			int num = (int)c.ToKnownColor();
			if (num > 167)
			{
				num -= 141;
			}
			num--;
			if (array[num] == null)
			{
				array[num] = new SolidBrush(c, immutable: true);
			}
			return array[num];
		}
	}
	public sealed class SystemColors
	{
		public static Color ActiveBorder => new Color(KnownColor.ActiveBorder);

		public static Color ActiveCaption => new Color(KnownColor.ActiveCaption);

		public static Color ActiveCaptionText => new Color(KnownColor.ActiveCaptionText);

		public static Color AppWorkspace => new Color(KnownColor.AppWorkspace);

		public static Color ButtonFace => new Color(KnownColor.ButtonFace);

		public static Color ButtonHighlight => new Color(KnownColor.ButtonHighlight);

		public static Color ButtonShadow => new Color(KnownColor.ButtonShadow);

		public static Color Control => new Color(KnownColor.Control);

		public static Color ControlDark => new Color(KnownColor.ControlDark);

		public static Color ControlDarkDark => new Color(KnownColor.ControlDarkDark);

		public static Color ControlLight => new Color(KnownColor.ControlLight);

		public static Color ControlLightLight => new Color(KnownColor.ControlLightLight);

		public static Color ControlText => new Color(KnownColor.ControlText);

		public static Color Desktop => new Color(KnownColor.Desktop);

		public static Color GradientActiveCaption => new Color(KnownColor.GradientActiveCaption);

		public static Color GradientInactiveCaption => new Color(KnownColor.GradientInactiveCaption);

		public static Color GrayText => new Color(KnownColor.GrayText);

		public static Color Highlight => new Color(KnownColor.Highlight);

		public static Color HighlightText => new Color(KnownColor.HighlightText);

		public static Color HotTrack => new Color(KnownColor.HotTrack);

		public static Color InactiveBorder => new Color(KnownColor.InactiveBorder);

		public static Color InactiveCaption => new Color(KnownColor.InactiveCaption);

		public static Color InactiveCaptionText => new Color(KnownColor.InactiveCaptionText);

		public static Color Info => new Color(KnownColor.Info);

		public static Color InfoText => new Color(KnownColor.InfoText);

		public static Color Menu => new Color(KnownColor.Menu);

		public static Color MenuBar => new Color(KnownColor.MenuBar);

		public static Color MenuHighlight => new Color(KnownColor.MenuHighlight);

		public static Color MenuText => new Color(KnownColor.MenuText);

		public static Color ScrollBar => new Color(KnownColor.ScrollBar);

		public static Color Window => new Color(KnownColor.Window);

		public static Color WindowFrame => new Color(KnownColor.WindowFrame);

		public static Color WindowText => new Color(KnownColor.WindowText);

		private SystemColors()
		{
		}
	}
	public sealed class SystemFonts
	{
		private static readonly object SystemFontsKey = new object();

		public static Font CaptionFont
		{
			get
			{
				Font font = null;
				NativeMethods.NONCLIENTMETRICS nONCLIENTMETRICS = new NativeMethods.NONCLIENTMETRICS();
				if (UnsafeNativeMethods.SystemParametersInfo(41, nONCLIENTMETRICS.cbSize, nONCLIENTMETRICS, 0) && nONCLIENTMETRICS.lfCaptionFont != null)
				{
					IntSecurity.ObjectFromWin32Handle.Assert();
					try
					{
						font = Font.FromLogFont(nONCLIENTMETRICS.lfCaptionFont);
					}
					catch (Exception ex)
					{
						if (IsCriticalFontException(ex))
						{
							throw;
						}
					}
					finally
					{
						CodeAccessPermission.RevertAssert();
					}
					if (font == null)
					{
						font = DefaultFont;
					}
					else if (font.Unit != GraphicsUnit.Point)
					{
						font = FontInPoints(font);
					}
				}
				font.SetSystemFontName("CaptionFont");
				return font;
			}
		}

		public static Font SmallCaptionFont
		{
			get
			{
				Font font = null;
				NativeMethods.NONCLIENTMETRICS nONCLIENTMETRICS = new NativeMethods.NONCLIENTMETRICS();
				if (UnsafeNativeMethods.SystemParametersInfo(41, nONCLIENTMETRICS.cbSize, nONCLIENTMETRICS, 0) && nONCLIENTMETRICS.lfSmCaptionFont != null)
				{
					IntSecurity.ObjectFromWin32Handle.Assert();
					try
					{
						font = Font.FromLogFont(nONCLIENTMETRICS.lfSmCaptionFont);
					}
					catch (Exception ex)
					{
						if (IsCriticalFontException(ex))
						{
							throw;
						}
					}
					finally
					{
						CodeAccessPermission.RevertAssert();
					}
					if (font == null)
					{
						font = DefaultFont;
					}
					else if (font.Unit != GraphicsUnit.Point)
					{
						font = FontInPoints(font);
					}
				}
				font.SetSystemFontName("SmallCaptionFont");
				return font;
			}
		}

		public static Font MenuFont
		{
			get
			{
				Font font = null;
				NativeMethods.NONCLIENTMETRICS nONCLIENTMETRICS = new NativeMethods.NONCLIENTMETRICS();
				if (UnsafeNativeMethods.SystemParametersInfo(41, nONCLIENTMETRICS.cbSize, nONCLIENTMETRICS, 0) && nONCLIENTMETRICS.lfMenuFont != null)
				{
					IntSecurity.ObjectFromWin32Handle.Assert();
					try
					{
						font = Font.FromLogFont(nONCLIENTMETRICS.lfMenuFont);
					}
					catch (Exception ex)
					{
						if (IsCriticalFontException(ex))
						{
							throw;
						}
					}
					finally
					{
						CodeAccessPermission.RevertAssert();
					}
					if (font == null)
					{
						font = DefaultFont;
					}
					else if (font.Unit != GraphicsUnit.Point)
					{
						font = FontInPoints(font);
					}
				}
				font.SetSystemFontName("MenuFont");
				return font;
			}
		}

		public static Font StatusFont
		{
			get
			{
				Font font = null;
				NativeMethods.NONCLIENTMETRICS nONCLIENTMETRICS = new NativeMethods.NONCLIENTMETRICS();
				if (UnsafeNativeMethods.SystemParametersInfo(41, nONCLIENTMETRICS.cbSize, nONCLIENTMETRICS, 0) && nONCLIENTMETRICS.lfStatusFont != null)
				{
					IntSecurity.ObjectFromWin32Handle.Assert();
					try
					{
						font = Font.FromLogFont(nONCLIENTMETRICS.lfStatusFont);
					}
					catch (Exception ex)
					{
						if (IsCriticalFontException(ex))
						{
							throw;
						}
					}
					finally
					{
						CodeAccessPermission.RevertAssert();
					}
					if (font == null)
					{
						font = DefaultFont;
					}
					else if (font.Unit != GraphicsUnit.Point)
					{
						font = FontInPoints(font);
					}
				}
				font.SetSystemFontName("StatusFont");
				return font;
			}
		}

		public static Font MessageBoxFont
		{
			get
			{
				Font font = null;
				NativeMethods.NONCLIENTMETRICS nONCLIENTMETRICS = new NativeMethods.NONCLIENTMETRICS();
				if (UnsafeNativeMethods.SystemParametersInfo(41, nONCLIENTMETRICS.cbSize, nONCLIENTMETRICS, 0) && nONCLIENTMETRICS.lfMessageFont != null)
				{
					IntSecurity.ObjectFromWin32Handle.Assert();
					try
					{
						font = Font.FromLogFont(nONCLIENTMETRICS.lfMessageFont);
					}
					catch (Exception ex)
					{
						if (IsCriticalFontException(ex))
						{
							throw;
						}
					}
					finally
					{
						CodeAccessPermission.RevertAssert();
					}
					if (font == null)
					{
						font = DefaultFont;
					}
					else if (font.Unit != GraphicsUnit.Point)
					{
						font = FontInPoints(font);
					}
				}
				font.SetSystemFontName("MessageBoxFont");
				return font;
			}
		}

		public static Font IconTitleFont
		{
			get
			{
				Font font = null;
				SafeNativeMethods.LOGFONT lOGFONT = new SafeNativeMethods.LOGFONT();
				if (UnsafeNativeMethods.SystemParametersInfo(31, Marshal.SizeOf(lOGFONT), lOGFONT, 0) && lOGFONT != null)
				{
					IntSecurity.ObjectFromWin32Handle.Assert();
					try
					{
						font = Font.FromLogFont(lOGFONT);
					}
					catch (Exception ex)
					{
						if (IsCriticalFontException(ex))
						{
							throw;
						}
					}
					finally
					{
						CodeAccessPermission.RevertAssert();
					}
					if (font == null)
					{
						font = DefaultFont;
					}
					else if (font.Unit != GraphicsUnit.Point)
					{
						font = FontInPoints(font);
					}
				}
				font.SetSystemFontName("IconTitleFont");
				return font;
			}
		}

		public static Font DefaultFont
		{
			get
			{
				Font font = null;
				bool flag = false;
				if (Environment.OSVersion.Platform == PlatformID.Win32NT && Environment.OSVersion.Version.Major <= 4 && (UnsafeNativeMethods.GetSystemDefaultLCID() & 0x3FF) == 17)
				{
					try
					{
						font = new Font("MS UI Gothic", 9f);
					}
					catch (Exception ex)
					{
						if (IsCriticalFontException(ex))
						{
							throw;
						}
					}
				}
				if (font == null)
				{
					flag = (UnsafeNativeMethods.GetSystemDefaultLCID() & 0x3FF) == 1;
				}
				if (flag)
				{
					try
					{
						font = new Font("Tahoma", 8f);
					}
					catch (Exception ex2)
					{
						if (IsCriticalFontException(ex2))
						{
							throw;
						}
					}
				}
				if (font == null)
				{
					IntPtr stockObject = UnsafeNativeMethods.GetStockObject(17);
					try
					{
						Font font2 = null;
						IntSecurity.ObjectFromWin32Handle.Assert();
						try
						{
							font2 = Font.FromHfont(stockObject);
						}
						finally
						{
							CodeAccessPermission.RevertAssert();
						}
						try
						{
							font = FontInPoints(font2);
						}
						finally
						{
							font2.Dispose();
						}
					}
					catch (ArgumentException)
					{
					}
				}
				if (font == null)
				{
					try
					{
						font = new Font("Tahoma", 8f);
					}
					catch (ArgumentException)
					{
					}
				}
				if (font == null)
				{
					font = new Font(FontFamily.GenericSansSerif, 8f);
				}
				if (font.Unit != GraphicsUnit.Point)
				{
					font = FontInPoints(font);
				}
				font.SetSystemFontName("DefaultFont");
				return font;
			}
		}

		public static Font DialogFont
		{
			get
			{
				Font font = null;
				if ((UnsafeNativeMethods.GetSystemDefaultLCID() & 0x3FF) == 17)
				{
					font = DefaultFont;
				}
				else if (Environment.OSVersion.Platform == PlatformID.Win32Windows)
				{
					font = DefaultFont;
				}
				else
				{
					try
					{
						font = new Font("Tahoma", 8f);
					}
					catch (ArgumentException)
					{
					}
				}
				if (font == null)
				{
					font = DefaultFont;
				}
				else if (font.Unit != GraphicsUnit.Point)
				{
					font = FontInPoints(font);
				}
				font.SetSystemFontName("DialogFont");
				return font;
			}
		}

		private SystemFonts()
		{
		}

		private static bool IsCriticalFontException(Exception ex)
		{
			if (!(ex is ExternalException) && !(ex is ArgumentException) && !(ex is OutOfMemoryException) && !(ex is InvalidOperationException) && !(ex is NotImplementedException))
			{
				return !(ex is FileNotFoundException);
			}
			return false;
		}

		private static Font FontInPoints(Font font)
		{
			return new Font(font.FontFamily, font.SizeInPoints, font.Style, GraphicsUnit.Point, font.GdiCharSet, font.GdiVerticalFont);
		}

		public static Font GetFontByName(string systemFontName)
		{
			if ("CaptionFont".Equals(systemFontName))
			{
				return CaptionFont;
			}
			if ("DefaultFont".Equals(systemFontName))
			{
				return DefaultFont;
			}
			if ("DialogFont".Equals(systemFontName))
			{
				return DialogFont;
			}
			if ("IconTitleFont".Equals(systemFontName))
			{
				return IconTitleFont;
			}
			if ("MenuFont".Equals(systemFontName))
			{
				return MenuFont;
			}
			if ("MessageBoxFont".Equals(systemFontName))
			{
				return MessageBoxFont;
			}
			if ("SmallCaptionFont".Equals(systemFontName))
			{
				return SmallCaptionFont;
			}
			if ("StatusFont".Equals(systemFontName))
			{
				return StatusFont;
			}
			return null;
		}
	}
	public sealed class SystemIcons
	{
		private static Icon _application;

		private static Icon _asterisk;

		private static Icon _error;

		private static Icon _exclamation;

		private static Icon _hand;

		private static Icon _information;

		private static Icon _question;

		private static Icon _warning;

		private static Icon _winlogo;

		private static Icon _shield;

		public static Icon Application
		{
			get
			{
				if (_application == null)
				{
					_application = new Icon(SafeNativeMethods.LoadIcon(NativeMethods.NullHandleRef, 32512));
				}
				return _application;
			}
		}

		public static Icon Asterisk
		{
			get
			{
				if (_asterisk == null)
				{
					_asterisk = new Icon(SafeNativeMethods.LoadIcon(NativeMethods.NullHandleRef, 32516));
				}
				return _asterisk;
			}
		}

		public static Icon Error
		{
			get
			{
				if (_error == null)
				{
					_error = new Icon(SafeNativeMethods.LoadIcon(NativeMethods.NullHandleRef, 32513));
				}
				return _error;
			}
		}

		public static Icon Exclamation
		{
			get
			{
				if (_exclamation == null)
				{
					_exclamation = new Icon(SafeNativeMethods.LoadIcon(NativeMethods.NullHandleRef, 32515));
				}
				return _exclamation;
			}
		}

		public static Icon Hand
		{
			get
			{
				if (_hand == null)
				{
					_hand = new Icon(SafeNativeMethods.LoadIcon(NativeMethods.NullHandleRef, 32513));
				}
				return _hand;
			}
		}

		public static Icon Information
		{
			get
			{
				if (_information == null)
				{
					_information = new Icon(SafeNativeMethods.LoadIcon(NativeMethods.NullHandleRef, 32516));
				}
				return _information;
			}
		}

		public static Icon Question
		{
			get
			{
				if (_question == null)
				{
					_question = new Icon(SafeNativeMethods.LoadIcon(NativeMethods.NullHandleRef, 32514));
				}
				return _question;
			}
		}

		public static Icon Warning
		{
			get
			{
				if (_warning == null)
				{
					_warning = new Icon(SafeNativeMethods.LoadIcon(NativeMethods.NullHandleRef, 32515));
				}
				return _warning;
			}
		}

		public static Icon WinLogo
		{
			get
			{
				if (_winlogo == null)
				{
					_winlogo = new Icon(SafeNativeMethods.LoadIcon(NativeMethods.NullHandleRef, 32517));
				}
				return _winlogo;
			}
		}

		public static Icon Shield
		{
			get
			{
				if (_shield == null)
				{
					_shield = new Icon(typeof(SystemIcons), "ShieldIcon.ico");
				}
				return _shield;
			}
		}

		private SystemIcons()
		{
		}
	}
	public sealed class SystemPens
	{
		private static readonly object SystemPensKey = new object();

		public static Pen ActiveBorder => FromSystemColor(SystemColors.ActiveBorder);

		public static Pen ActiveCaption => FromSystemColor(SystemColors.ActiveCaption);

		public static Pen ActiveCaptionText => FromSystemColor(SystemColors.ActiveCaptionText);

		public static Pen AppWorkspace => FromSystemColor(SystemColors.AppWorkspace);

		public static Pen ButtonFace => FromSystemColor(SystemColors.ButtonFace);

		public static Pen ButtonHighlight => FromSystemColor(SystemColors.ButtonHighlight);

		public static Pen ButtonShadow => FromSystemColor(SystemColors.ButtonShadow);

		public static Pen Control => FromSystemColor(SystemColors.Control);

		public static Pen ControlText => FromSystemColor(SystemColors.ControlText);

		public static Pen ControlDark => FromSystemColor(SystemColors.ControlDark);

		public static Pen ControlDarkDark => FromSystemColor(SystemColors.ControlDarkDark);

		public static Pen ControlLight => FromSystemColor(SystemColors.ControlLight);

		public static Pen ControlLightLight => FromSystemColor(SystemColors.ControlLightLight);

		public static Pen Desktop => FromSystemColor(SystemColors.Desktop);

		public static Pen GradientActiveCaption => FromSystemColor(SystemColors.GradientActiveCaption);

		public static Pen GradientInactiveCaption => FromSystemColor(SystemColors.GradientInactiveCaption);

		public static Pen GrayText => FromSystemColor(SystemColors.GrayText);

		public static Pen Highlight => FromSystemColor(SystemColors.Highlight);

		public static Pen HighlightText => FromSystemColor(SystemColors.HighlightText);

		public static Pen HotTrack => FromSystemColor(SystemColors.HotTrack);

		public static Pen InactiveBorder => FromSystemColor(SystemColors.InactiveBorder);

		public static Pen InactiveCaption => FromSystemColor(SystemColors.InactiveCaption);

		public static Pen InactiveCaptionText => FromSystemColor(SystemColors.InactiveCaptionText);

		public static Pen Info => FromSystemColor(SystemColors.Info);

		public static Pen InfoText => FromSystemColor(SystemColors.InfoText);

		public static Pen Menu => FromSystemColor(SystemColors.Menu);

		public static Pen MenuBar => FromSystemColor(SystemColors.MenuBar);

		public static Pen MenuHighlight => FromSystemColor(SystemColors.MenuHighlight);

		public static Pen MenuText => FromSystemColor(SystemColors.MenuText);

		public static Pen ScrollBar => FromSystemColor(SystemColors.ScrollBar);

		public static Pen Window => FromSystemColor(SystemColors.Window);

		public static Pen WindowFrame => FromSystemColor(SystemColors.WindowFrame);

		public static Pen WindowText => FromSystemColor(SystemColors.WindowText);

		private SystemPens()
		{
		}

		public static Pen FromSystemColor(Color c)
		{
			if (!c.IsSystemColor)
			{
				throw new ArgumentException(SR.GetString("ColorNotSystemColor", c.ToString()));
			}
			Pen[] array = (Pen[])SafeNativeMethods.Gdip.ThreadData[SystemPensKey];
			if (array == null)
			{
				array = new Pen[33];
				SafeNativeMethods.Gdip.ThreadData[SystemPensKey] = array;
			}
			int num = (int)c.ToKnownColor();
			if (num > 167)
			{
				num -= 141;
			}
			num--;
			if (array[num] == null)
			{
				array[num] = new Pen(c, immutable: true);
			}
			return array[num];
		}
	}
	[AttributeUsage(AttributeTargets.Class)]
	public class ToolboxBitmapAttribute : Attribute
	{
		private Image smallImage;

		private Image largeImage;

		private static readonly Point largeDim;

		private static readonly Point smallDim;

		public static readonly ToolboxBitmapAttribute Default;

		private static readonly ToolboxBitmapAttribute DefaultComponent;

		public ToolboxBitmapAttribute(string imageFile)
			: this(GetImageFromFile(imageFile, large: false), GetImageFromFile(imageFile, large: true))
		{
		}

		public ToolboxBitmapAttribute(Type t)
			: this(GetImageFromResource(t, null, large: false), GetImageFromResource(t, null, large: true))
		{
		}

		public ToolboxBitmapAttribute(Type t, string name)
			: this(GetImageFromResource(t, name, large: false), GetImageFromResource(t, name, large: true))
		{
		}

		private ToolboxBitmapAttribute(Image smallImage, Image largeImage)
		{
			this.smallImage = smallImage;
			this.largeImage = largeImage;
		}

		public override bool Equals(object value)
		{
			if (value == this)
			{
				return true;
			}
			if (value is ToolboxBitmapAttribute toolboxBitmapAttribute)
			{
				if (toolboxBitmapAttribute.smallImage == smallImage)
				{
					return toolboxBitmapAttribute.largeImage == largeImage;
				}
				return false;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return base.GetHashCode();
		}

		public Image GetImage(object component)
		{
			return GetImage(component, large: true);
		}

		public Image GetImage(object component, bool large)
		{
			if (component != null)
			{
				return GetImage(component.GetType(), large);
			}
			return null;
		}

		public Image GetImage(Type type)
		{
			return GetImage(type, large: false);
		}

		public Image GetImage(Type type, bool large)
		{
			return GetImage(type, null, large);
		}

		public Image GetImage(Type type, string imgName, bool large)
		{
			if ((large && largeImage == null) || (!large && smallImage == null))
			{
				Point point = new Point(32, 32);
				Image image = null;
				image = ((!large) ? smallImage : largeImage);
				if (image == null)
				{
					image = GetImageFromResource(type, imgName, large);
				}
				if (large && largeImage == null && smallImage != null)
				{
					image = new Bitmap((Bitmap)smallImage, point.X, point.Y);
				}
				if (image is Bitmap img)
				{
					MakeBackgroundAlphaZero(img);
				}
				if (image == null)
				{
					image = DefaultComponent.GetImage(type, large);
				}
				if (large)
				{
					largeImage = image;
				}
				else
				{
					smallImage = image;
				}
			}
			Image result = (large ? largeImage : smallImage);
			if (Equals(Default))
			{
				largeImage = null;
				smallImage = null;
			}
			return result;
		}

		private static Image GetIconFromStream(Stream stream, bool large)
		{
			if (stream == null)
			{
				return null;
			}
			Icon original = new Icon(stream);
			Icon icon = new Icon(original, large ? new Size(largeDim.X, largeDim.Y) : new Size(smallDim.X, smallDim.Y));
			return icon.ToBitmap();
		}

		private static Image GetImageFromFile(string imageFile, bool large)
		{
			Image result = null;
			try
			{
				if (imageFile != null)
				{
					string extension = Path.GetExtension(imageFile);
					if (extension != null && string.Equals(extension, ".ico", StringComparison.OrdinalIgnoreCase))
					{
						FileStream fileStream = File.Open(imageFile, FileMode.Open);
						if (fileStream != null)
						{
							try
							{
								result = GetIconFromStream(fileStream, large);
								return result;
							}
							finally
							{
								fileStream.Close();
							}
						}
						return result;
					}
					if (!large)
					{
						result = Image.FromFile(imageFile);
						return result;
					}
					return result;
				}
				return result;
			}
			catch (Exception ex)
			{
				if (ClientUtils.IsCriticalException(ex))
				{
					throw;
				}
				return result;
			}
		}

		private static Image GetBitmapFromResource(Type t, string bitmapname, bool large)
		{
			if (bitmapname == null)
			{
				return null;
			}
			Image result = null;
			Stream manifestResourceStream = t.Module.Assembly.GetManifestResourceStream(t, bitmapname);
			if (manifestResourceStream != null)
			{
				Bitmap bitmap = new Bitmap(manifestResourceStream);
				result = bitmap;
				MakeBackgroundAlphaZero(bitmap);
				if (large)
				{
					result = new Bitmap(bitmap, largeDim.X, largeDim.Y);
				}
			}
			return result;
		}

		private static Image GetIconFromResource(Type t, string bitmapname, bool large)
		{
			if (bitmapname == null)
			{
				return null;
			}
			return GetIconFromStream(t.Module.Assembly.GetManifestResourceStream(t, bitmapname), large);
		}

		public static Image GetImageFromResource(Type t, string imageName, bool large)
		{
			Image image = null;
			try
			{
				string text = imageName;
				string bitmapname = null;
				string bitmapname2 = null;
				string bitmapname3 = null;
				if (text == null)
				{
					text = t.FullName;
					int num = text.LastIndexOf('.');
					if (num != -1)
					{
						text = text.Substring(num + 1);
					}
					bitmapname = text + ".ico";
					bitmapname2 = text + ".bmp";
				}
				else if (string.Compare(Path.GetExtension(imageName), ".ico", ignoreCase: true, CultureInfo.CurrentCulture) == 0)
				{
					bitmapname = text;
				}
				else if (string.Compare(Path.GetExtension(imageName), ".bmp", ignoreCase: true, CultureInfo.CurrentCulture) == 0)
				{
					bitmapname2 = text;
				}
				else
				{
					bitmapname3 = text;
					bitmapname2 = text + ".bmp";
					bitmapname = text + ".ico";
				}
				image = GetBitmapFromResource(t, bitmapname3, large);
				if (image == null)
				{
					image = GetBitmapFromResource(t, bitmapname2, large);
				}
				if (image == null)
				{
					image = GetIconFromResource(t, bitmapname, large);
					return image;
				}
				return image;
			}
			catch (Exception)
			{
				return image;
			}
		}

		private static void MakeBackgroundAlphaZero(Bitmap img)
		{
			Color pixel = img.GetPixel(0, img.Height - 1);
			img.MakeTransparent();
			Color color = Color.FromArgb(0, pixel);
			img.SetPixel(0, img.Height - 1, color);
		}

		static ToolboxBitmapAttribute()
		{
			largeDim = new Point(32, 32);
			smallDim = new Point(16, 16);
			Default = new ToolboxBitmapAttribute((Image)null, (Image)null);
			Bitmap img = null;
			Stream manifestResourceStream = typeof(ToolboxBitmapAttribute).Module.Assembly.GetManifestResourceStream(typeof(ToolboxBitmapAttribute), "DefaultComponent.bmp");
			if (manifestResourceStream != null)
			{
				img = new Bitmap(manifestResourceStream);
				MakeBackgroundAlphaZero(img);
			}
			DefaultComponent = new ToolboxBitmapAttribute(img, null);
		}
	}
	[SuppressUnmanagedCodeSecurity]
	internal class UnsafeNativeMethods
	{
		[ComImport]
		[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
		[Guid("0000000C-0000-0000-C000-000000000046")]
		public interface IStream
		{
			int Read([In] IntPtr buf, [In] int len);

			int Write([In] IntPtr buf, [In] int len);

			[return: MarshalAs(UnmanagedType.I8)]
			long Seek([In][MarshalAs(UnmanagedType.I8)] long dlibMove, [In] int dwOrigin);

			void SetSize([In][MarshalAs(UnmanagedType.I8)] long libNewSize);

			[return: MarshalAs(UnmanagedType.I8)]
			long CopyTo([In][MarshalAs(UnmanagedType.Interface)] IStream pstm, [In][MarshalAs(UnmanagedType.I8)] long cb, [Out][MarshalAs(UnmanagedType.LPArray)] long[] pcbRead);

			void Commit([In] int grfCommitFlags);

			void Revert();

			void LockRegion([In][MarshalAs(UnmanagedType.I8)] long libOffset, [In][MarshalAs(UnmanagedType.I8)] long cb, [In] int dwLockType);

			void UnlockRegion([In][MarshalAs(UnmanagedType.I8)] long libOffset, [In][MarshalAs(UnmanagedType.I8)] long cb, [In] int dwLockType);

			void Stat([In] IntPtr pStatstg, [In] int grfStatFlag);

			[return: MarshalAs(UnmanagedType.Interface)]
			IStream Clone();
		}

		internal class ComStreamFromDataStream : IStream
		{
			protected Stream dataStream;

			private long virtualPosition = -1L;

			internal ComStreamFromDataStream(Stream dataStream)
			{
				if (dataStream == null)
				{
					throw new ArgumentNullException("dataStream");
				}
				this.dataStream = dataStream;
			}

			private void ActualizeVirtualPosition()
			{
				if (virtualPosition != -1)
				{
					if (virtualPosition > dataStream.Length)
					{
						dataStream.SetLength(virtualPosition);
					}
					dataStream.Position = virtualPosition;
					virtualPosition = -1L;
				}
			}

			public virtual IStream Clone()
			{
				NotImplemented();
				return null;
			}

			public virtual void Commit(int grfCommitFlags)
			{
				dataStream.Flush();
				ActualizeVirtualPosition();
			}

			public virtual long CopyTo(IStream pstm, long cb, long[] pcbRead)
			{
				int num = 4096;
				IntPtr intPtr = Marshal.AllocHGlobal(num);
				if (intPtr == IntPtr.Zero)
				{
					throw new OutOfMemoryException();
				}
				long num2 = 0L;
				try
				{
					int num4;
					for (; num2 < cb; num2 += num4)
					{
						int num3 = num;
						if (num2 + num3 > cb)
						{
							num3 = (int)(cb - num2);
						}
						num4 = Read(intPtr, num3);
						if (num4 != 0)
						{
							if (pstm.Write(intPtr, num4) != num4)
							{
								throw EFail("Wrote an incorrect number of bytes");
							}
							continue;
						}
						break;
					}
				}
				finally
				{
					Marshal.FreeHGlobal(intPtr);
				}
				if (pcbRead != null && pcbRead.Length > 0)
				{
					pcbRead[0] = num2;
				}
				return num2;
			}

			public virtual Stream GetDataStream()
			{
				return dataStream;
			}

			public virtual void LockRegion(long libOffset, long cb, int dwLockType)
			{
			}

			protected static ExternalException EFail(string msg)
			{
				throw new ExternalException(msg, -2147467259);
			}

			protected static void NotImplemented()
			{
				throw new ExternalException(SR.GetString("NotImplemented"), -2147467263);
			}

			public virtual int Read(IntPtr buf, int length)
			{
				byte[] array = new byte[length];
				int result = Read(array, length);
				Marshal.Copy(array, 0, buf, length);
				return result;
			}

			public virtual int Read(byte[] buffer, int length)
			{
				ActualizeVirtualPosition();
				return dataStream.Read(buffer, 0, length);
			}

			public virtual void Revert()
			{
				NotImplemented();
			}

			public virtual long Seek(long offset, int origin)
			{
				long position = virtualPosition;
				if (virtualPosition == -1)
				{
					position = dataStream.Position;
				}
				long length = dataStream.Length;
				switch (origin)
				{
				case 0:
					if (offset <= length)
					{
						dataStream.Position = offset;
						virtualPosition = -1L;
					}
					else
					{
						virtualPosition = offset;
					}
					break;
				case 2:
					if (offset <= 0)
					{
						dataStream.Position = length + offset;
						virtualPosition = -1L;
					}
					else
					{
						virtualPosition = length + offset;
					}
					break;
				case 1:
					if (offset + position <= length)
					{
						dataStream.Position = position + offset;
						virtualPosition = -1L;
					}
					else
					{
						virtualPosition = offset + position;
					}
					break;
				}
				if (virtualPosition != -1)
				{
					return virtualPosition;
				}
				return dataStream.Position;
			}

			public virtual void SetSize(long value)
			{
				dataStream.SetLength(value);
			}

			public virtual void Stat(IntPtr pstatstg, int grfStatFlag)
			{
				NotImplemented();
			}

			public virtual void UnlockRegion(long libOffset, long cb, int dwLockType)
			{
			}

			public virtual int Write(IntPtr buf, int length)
			{
				byte[] array = new byte[length];
				Marshal.Copy(buf, array, 0, length);
				return Write(array, length);
			}

			public virtual int Write(byte[] buffer, int length)
			{
				ActualizeVirtualPosition();
				dataStream.Write(buffer, 0, length);
				return length;
			}
		}

		[DllImport("kernel32.dll", CharSet = CharSet.Auto, EntryPoint = "RtlMoveMemory", ExactSpelling = true, SetLastError = true)]
		public static extern void CopyMemory(HandleRef destData, HandleRef srcData, int size);

		[DllImport("user32.dll", CharSet = CharSet.Auto, EntryPoint = "GetDC", ExactSpelling = true, SetLastError = true)]
		private static extern IntPtr IntGetDC(HandleRef hWnd);

		public static IntPtr GetDC(HandleRef hWnd)
		{
			return System.Internal.HandleCollector.Add(IntGetDC(hWnd), SafeNativeMethods.CommonHandles.HDC);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "DeleteDC", ExactSpelling = true, SetLastError = true)]
		private static extern bool IntDeleteDC(HandleRef hDC);

		public static bool DeleteDC(HandleRef hDC)
		{
			System.Internal.HandleCollector.Remove((IntPtr)hDC, SafeNativeMethods.CommonHandles.GDI);
			return IntDeleteDC(hDC);
		}

		[DllImport("user32.dll", CharSet = CharSet.Auto, EntryPoint = "ReleaseDC", ExactSpelling = true, SetLastError = true)]
		private static extern int IntReleaseDC(HandleRef hWnd, HandleRef hDC);

		public static int ReleaseDC(HandleRef hWnd, HandleRef hDC)
		{
			System.Internal.HandleCollector.Remove((IntPtr)hDC, SafeNativeMethods.CommonHandles.HDC);
			return IntReleaseDC(hWnd, hDC);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "CreateCompatibleDC", ExactSpelling = true, SetLastError = true)]
		private static extern IntPtr IntCreateCompatibleDC(HandleRef hDC);

		public static IntPtr CreateCompatibleDC(HandleRef hDC)
		{
			return System.Internal.HandleCollector.Add(IntCreateCompatibleDC(hDC), SafeNativeMethods.CommonHandles.GDI);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern IntPtr GetStockObject(int nIndex);

		[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern int GetSystemDefaultLCID();

		[DllImport("user32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int GetSystemMetrics(int nIndex);

		[DllImport("user32.dll", BestFitMapping = false, CharSet = CharSet.Auto, SetLastError = true)]
		public static extern bool SystemParametersInfo(int uiAction, int uiParam, [In][Out] NativeMethods.NONCLIENTMETRICS pvParam, int fWinIni);

		[DllImport("user32.dll", BestFitMapping = false, CharSet = CharSet.Auto, SetLastError = true)]
		public static extern bool SystemParametersInfo(int uiAction, int uiParam, [In][Out] SafeNativeMethods.LOGFONT pvParam, int fWinIni);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int GetDeviceCaps(HandleRef hDC, int nIndex);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int GetObjectType(HandleRef hObject);

		[SecurityPermission(SecurityAction.Assert, Flags = SecurityPermissionFlag.UnmanagedCode)]
		[ReflectionPermission(SecurityAction.Assert, Unrestricted = true)]
		public static object PtrToStructure(IntPtr lparam, Type cls)
		{
			return Marshal.PtrToStructure(lparam, cls);
		}

		[SecurityPermission(SecurityAction.Assert, Flags = SecurityPermissionFlag.UnmanagedCode)]
		[ReflectionPermission(SecurityAction.Assert, Unrestricted = true)]
		public static void PtrToStructure(IntPtr lparam, object data)
		{
			Marshal.PtrToStructure(lparam, data);
		}
	}
}
namespace System.Drawing.Drawing2D
{
	public class CustomLineCap : MarshalByRefObject, ICloneable, IDisposable
	{
		internal SafeCustomLineCapHandle nativeCap;

		private bool disposed;

		public LineJoin StrokeJoin
		{
			get
			{
				return _GetStrokeJoin();
			}
			set
			{
				_SetStrokeJoin(value);
			}
		}

		public LineCap BaseCap
		{
			get
			{
				return _GetBaseCap();
			}
			set
			{
				_SetBaseCap(value);
			}
		}

		public float BaseInset
		{
			get
			{
				return _GetBaseInset();
			}
			set
			{
				_SetBaseInset(value);
			}
		}

		public float WidthScale
		{
			get
			{
				return _GetWidthScale();
			}
			set
			{
				_SetWidthScale(value);
			}
		}

		internal CustomLineCap()
		{
		}

		public CustomLineCap(GraphicsPath fillPath, GraphicsPath strokePath)
			: this(fillPath, strokePath, LineCap.Flat)
		{
		}

		public CustomLineCap(GraphicsPath fillPath, GraphicsPath strokePath, LineCap baseCap)
			: this(fillPath, strokePath, baseCap, 0f)
		{
		}

		public CustomLineCap(GraphicsPath fillPath, GraphicsPath strokePath, LineCap baseCap, float baseInset)
		{
			IntPtr customCap = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateCustomLineCap(new HandleRef(fillPath, fillPath?.nativePath ?? IntPtr.Zero), new HandleRef(strokePath, strokePath?.nativePath ?? IntPtr.Zero), baseCap, baseInset, out customCap);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeLineCap(customCap);
		}

		internal CustomLineCap(IntPtr nativeLineCap)
		{
			SetNativeLineCap(nativeLineCap);
		}

		internal void SetNativeLineCap(IntPtr handle)
		{
			if (handle == IntPtr.Zero)
			{
				throw new ArgumentNullException("handle");
			}
			nativeCap = new SafeCustomLineCapHandle(handle);
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		protected virtual void Dispose(bool disposing)
		{
			if (!disposed)
			{
				if (disposing && nativeCap != null)
				{
					nativeCap.Dispose();
				}
				disposed = true;
			}
		}

		~CustomLineCap()
		{
			Dispose(disposing: false);
		}

		public object Clone()
		{
			IntPtr clonedCap = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCloneCustomLineCap(new HandleRef(this, nativeCap), out clonedCap);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return CreateCustomLineCapObject(clonedCap);
		}

		internal static CustomLineCap CreateCustomLineCapObject(IntPtr cap)
		{
			CustomLineCapType capType = CustomLineCapType.Default;
			int num = SafeNativeMethods.Gdip.GdipGetCustomLineCapType(new HandleRef(null, cap), out capType);
			if (num != 0)
			{
				SafeNativeMethods.Gdip.GdipDeleteCustomLineCap(new HandleRef(null, cap));
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			switch (capType)
			{
			case CustomLineCapType.Default:
				return new CustomLineCap(cap);
			case CustomLineCapType.AdjustableArrowCap:
				return new AdjustableArrowCap(cap);
			default:
				SafeNativeMethods.Gdip.GdipDeleteCustomLineCap(new HandleRef(null, cap));
				throw SafeNativeMethods.Gdip.StatusException(6);
			}
		}

		public void SetStrokeCaps(LineCap startCap, LineCap endCap)
		{
			int num = SafeNativeMethods.Gdip.GdipSetCustomLineCapStrokeCaps(new HandleRef(this, nativeCap), startCap, endCap);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void GetStrokeCaps(out LineCap startCap, out LineCap endCap)
		{
			int num = SafeNativeMethods.Gdip.GdipGetCustomLineCapStrokeCaps(new HandleRef(this, nativeCap), out startCap, out endCap);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private void _SetStrokeJoin(LineJoin lineJoin)
		{
			int num = SafeNativeMethods.Gdip.GdipSetCustomLineCapStrokeJoin(new HandleRef(this, nativeCap), lineJoin);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private LineJoin _GetStrokeJoin()
		{
			LineJoin lineJoin;
			int num = SafeNativeMethods.Gdip.GdipGetCustomLineCapStrokeJoin(new HandleRef(this, nativeCap), out lineJoin);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return lineJoin;
		}

		private void _SetBaseCap(LineCap baseCap)
		{
			int num = SafeNativeMethods.Gdip.GdipSetCustomLineCapBaseCap(new HandleRef(this, nativeCap), baseCap);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private LineCap _GetBaseCap()
		{
			LineCap baseCap;
			int num = SafeNativeMethods.Gdip.GdipGetCustomLineCapBaseCap(new HandleRef(this, nativeCap), out baseCap);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return baseCap;
		}

		private void _SetBaseInset(float inset)
		{
			int num = SafeNativeMethods.Gdip.GdipSetCustomLineCapBaseInset(new HandleRef(this, nativeCap), inset);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private float _GetBaseInset()
		{
			float inset;
			int num = SafeNativeMethods.Gdip.GdipGetCustomLineCapBaseInset(new HandleRef(this, nativeCap), out inset);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return inset;
		}

		private void _SetWidthScale(float widthScale)
		{
			int num = SafeNativeMethods.Gdip.GdipSetCustomLineCapWidthScale(new HandleRef(this, nativeCap), widthScale);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private float _GetWidthScale()
		{
			float widthScale;
			int num = SafeNativeMethods.Gdip.GdipGetCustomLineCapWidthScale(new HandleRef(this, nativeCap), out widthScale);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return widthScale;
		}
	}
	public sealed class AdjustableArrowCap : CustomLineCap
	{
		public float Height
		{
			get
			{
				return _GetHeight();
			}
			set
			{
				_SetHeight(value);
			}
		}

		public float Width
		{
			get
			{
				return _GetWidth();
			}
			set
			{
				_SetWidth(value);
			}
		}

		public float MiddleInset
		{
			get
			{
				return _GetMiddleInset();
			}
			set
			{
				_SetMiddleInset(value);
			}
		}

		public bool Filled
		{
			get
			{
				return _IsFilled();
			}
			set
			{
				_SetFillState(value);
			}
		}

		internal AdjustableArrowCap(IntPtr nativeCap)
			: base(nativeCap)
		{
		}

		public AdjustableArrowCap(float width, float height)
			: this(width, height, isFilled: true)
		{
		}

		public AdjustableArrowCap(float width, float height, bool isFilled)
		{
			IntPtr adjustableArrowCap = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateAdjustableArrowCap(height, width, isFilled, out adjustableArrowCap);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeLineCap(adjustableArrowCap);
		}

		private void _SetHeight(float height)
		{
			int num = SafeNativeMethods.Gdip.GdipSetAdjustableArrowCapHeight(new HandleRef(this, nativeCap), height);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private float _GetHeight()
		{
			float height;
			int num = SafeNativeMethods.Gdip.GdipGetAdjustableArrowCapHeight(new HandleRef(this, nativeCap), out height);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return height;
		}

		private void _SetWidth(float width)
		{
			int num = SafeNativeMethods.Gdip.GdipSetAdjustableArrowCapWidth(new HandleRef(this, nativeCap), width);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private float _GetWidth()
		{
			float width;
			int num = SafeNativeMethods.Gdip.GdipGetAdjustableArrowCapWidth(new HandleRef(this, nativeCap), out width);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return width;
		}

		private void _SetMiddleInset(float middleInset)
		{
			int num = SafeNativeMethods.Gdip.GdipSetAdjustableArrowCapMiddleInset(new HandleRef(this, nativeCap), middleInset);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private float _GetMiddleInset()
		{
			float middleInset;
			int num = SafeNativeMethods.Gdip.GdipGetAdjustableArrowCapMiddleInset(new HandleRef(this, nativeCap), out middleInset);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return middleInset;
		}

		private void _SetFillState(bool isFilled)
		{
			int num = SafeNativeMethods.Gdip.GdipSetAdjustableArrowCapFillState(new HandleRef(this, nativeCap), isFilled);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private bool _IsFilled()
		{
			bool fillState = false;
			int num = SafeNativeMethods.Gdip.GdipGetAdjustableArrowCapFillState(new HandleRef(this, nativeCap), out fillState);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return fillState;
		}
	}
}
namespace System.Drawing.Imaging
{
	[StructLayout(LayoutKind.Sequential)]
	public sealed class BitmapData
	{
		private int width;

		private int height;

		private int stride;

		private int pixelFormat;

		private IntPtr scan0;

		private int reserved;

		public int Width
		{
			get
			{
				return width;
			}
			set
			{
				width = value;
			}
		}

		public int Height
		{
			get
			{
				return height;
			}
			set
			{
				height = value;
			}
		}

		public int Stride
		{
			get
			{
				return stride;
			}
			set
			{
				stride = value;
			}
		}

		public PixelFormat PixelFormat
		{
			get
			{
				return (PixelFormat)pixelFormat;
			}
			set
			{
				switch (value)
				{
				default:
					throw new InvalidEnumArgumentException("value", (int)value, typeof(PixelFormat));
				case PixelFormat.Undefined:
				case PixelFormat.Max:
				case PixelFormat.Indexed:
				case PixelFormat.Gdi:
				case PixelFormat.Format16bppRgb555:
				case PixelFormat.Format16bppRgb565:
				case PixelFormat.Format24bppRgb:
				case PixelFormat.Format32bppRgb:
				case PixelFormat.Format1bppIndexed:
				case PixelFormat.Format4bppIndexed:
				case PixelFormat.Format8bppIndexed:
				case PixelFormat.Alpha:
				case PixelFormat.Format16bppArgb1555:
				case PixelFormat.PAlpha:
				case PixelFormat.Format32bppPArgb:
				case PixelFormat.Extended:
				case PixelFormat.Format16bppGrayScale:
				case PixelFormat.Format48bppRgb:
				case PixelFormat.Format64bppPArgb:
				case PixelFormat.Canonical:
				case PixelFormat.Format32bppArgb:
				case PixelFormat.Format64bppArgb:
					pixelFormat = (int)value;
					break;
				}
			}
		}

		public IntPtr Scan0
		{
			get
			{
				return scan0;
			}
			set
			{
				scan0 = value;
			}
		}

		public int Reserved
		{
			get
			{
				return reserved;
			}
			set
			{
				reserved = value;
			}
		}
	}
}
namespace System.Drawing.Drawing2D
{
	public sealed class Blend
	{
		private float[] factors;

		private float[] positions;

		public float[] Factors
		{
			get
			{
				return factors;
			}
			set
			{
				factors = value;
			}
		}

		public float[] Positions
		{
			get
			{
				return positions;
			}
			set
			{
				positions = value;
			}
		}

		public Blend()
		{
			factors = new float[1];
			positions = new float[1];
		}

		public Blend(int count)
		{
			factors = new float[count];
			positions = new float[count];
		}
	}
	internal enum BrushType
	{
		SolidColor,
		HatchFill,
		TextureFill,
		PathGradient,
		LinearGradient
	}
}
namespace System.Drawing.Imaging
{
	public enum ColorAdjustType
	{
		Default,
		Bitmap,
		Brush,
		Pen,
		Text,
		Count,
		Any
	}
}
namespace System.Drawing.Drawing2D
{
	public sealed class ColorBlend
	{
		private Color[] colors;

		private float[] positions;

		public Color[] Colors
		{
			get
			{
				return colors;
			}
			set
			{
				colors = value;
			}
		}

		public float[] Positions
		{
			get
			{
				return positions;
			}
			set
			{
				positions = value;
			}
		}

		public ColorBlend()
		{
			colors = new Color[1];
			positions = new float[1];
		}

		public ColorBlend(int count)
		{
			colors = new Color[count];
			positions = new float[count];
		}
	}
}
namespace System.Drawing.Imaging
{
	public enum ColorChannelFlag
	{
		ColorChannelC,
		ColorChannelM,
		ColorChannelY,
		ColorChannelK,
		ColorChannelLast
	}
	public sealed class ColorMap
	{
		private Color oldColor;

		private Color newColor;

		public Color OldColor
		{
			get
			{
				return oldColor;
			}
			set
			{
				oldColor = value;
			}
		}

		public Color NewColor
		{
			get
			{
				return newColor;
			}
			set
			{
				newColor = value;
			}
		}

		public ColorMap()
		{
			oldColor = default(Color);
			newColor = default(Color);
		}
	}
	public enum ColorMapType
	{
		Default,
		Brush
	}
	[StructLayout(LayoutKind.Sequential)]
	public sealed class ColorMatrix
	{
		private float matrix00;

		private float matrix01;

		private float matrix02;

		private float matrix03;

		private float matrix04;

		private float matrix10;

		private float matrix11;

		private float matrix12;

		private float matrix13;

		private float matrix14;

		private float matrix20;

		private float matrix21;

		private float matrix22;

		private float matrix23;

		private float matrix24;

		private float matrix30;

		private float matrix31;

		private float matrix32;

		private float matrix33;

		private float matrix34;

		private float matrix40;

		private float matrix41;

		private float matrix42;

		private float matrix43;

		private float matrix44;

		public float Matrix00
		{
			get
			{
				return matrix00;
			}
			set
			{
				matrix00 = value;
			}
		}

		public float Matrix01
		{
			get
			{
				return matrix01;
			}
			set
			{
				matrix01 = value;
			}
		}

		public float Matrix02
		{
			get
			{
				return matrix02;
			}
			set
			{
				matrix02 = value;
			}
		}

		public float Matrix03
		{
			get
			{
				return matrix03;
			}
			set
			{
				matrix03 = value;
			}
		}

		public float Matrix04
		{
			get
			{
				return matrix04;
			}
			set
			{
				matrix04 = value;
			}
		}

		public float Matrix10
		{
			get
			{
				return matrix10;
			}
			set
			{
				matrix10 = value;
			}
		}

		public float Matrix11
		{
			get
			{
				return matrix11;
			}
			set
			{
				matrix11 = value;
			}
		}

		public float Matrix12
		{
			get
			{
				return matrix12;
			}
			set
			{
				matrix12 = value;
			}
		}

		public float Matrix13
		{
			get
			{
				return matrix13;
			}
			set
			{
				matrix13 = value;
			}
		}

		public float Matrix14
		{
			get
			{
				return matrix14;
			}
			set
			{
				matrix14 = value;
			}
		}

		public float Matrix20
		{
			get
			{
				return matrix20;
			}
			set
			{
				matrix20 = value;
			}
		}

		public float Matrix21
		{
			get
			{
				return matrix21;
			}
			set
			{
				matrix21 = value;
			}
		}

		public float Matrix22
		{
			get
			{
				return matrix22;
			}
			set
			{
				matrix22 = value;
			}
		}

		public float Matrix23
		{
			get
			{
				return matrix23;
			}
			set
			{
				matrix23 = value;
			}
		}

		public float Matrix24
		{
			get
			{
				return matrix24;
			}
			set
			{
				matrix24 = value;
			}
		}

		public float Matrix30
		{
			get
			{
				return matrix30;
			}
			set
			{
				matrix30 = value;
			}
		}

		public float Matrix31
		{
			get
			{
				return matrix31;
			}
			set
			{
				matrix31 = value;
			}
		}

		public float Matrix32
		{
			get
			{
				return matrix32;
			}
			set
			{
				matrix32 = value;
			}
		}

		public float Matrix33
		{
			get
			{
				return matrix33;
			}
			set
			{
				matrix33 = value;
			}
		}

		public float Matrix34
		{
			get
			{
				return matrix34;
			}
			set
			{
				matrix34 = value;
			}
		}

		public float Matrix40
		{
			get
			{
				return matrix40;
			}
			set
			{
				matrix40 = value;
			}
		}

		public float Matrix41
		{
			get
			{
				return matrix41;
			}
			set
			{
				matrix41 = value;
			}
		}

		public float Matrix42
		{
			get
			{
				return matrix42;
			}
			set
			{
				matrix42 = value;
			}
		}

		public float Matrix43
		{
			get
			{
				return matrix43;
			}
			set
			{
				matrix43 = value;
			}
		}

		public float Matrix44
		{
			get
			{
				return matrix44;
			}
			set
			{
				matrix44 = value;
			}
		}

		public float this[int row, int column]
		{
			get
			{
				return GetMatrix()[row][column];
			}
			set
			{
				float[][] matrix = GetMatrix();
				matrix[row][column] = value;
				SetMatrix(matrix);
			}
		}

		public ColorMatrix()
		{
			matrix00 = 1f;
			matrix11 = 1f;
			matrix22 = 1f;
			matrix33 = 1f;
			matrix44 = 1f;
		}

		[CLSCompliant(false)]
		public ColorMatrix(float[][] newColorMatrix)
		{
			SetMatrix(newColorMatrix);
		}

		internal void SetMatrix(float[][] newColorMatrix)
		{
			matrix00 = newColorMatrix[0][0];
			matrix01 = newColorMatrix[0][1];
			matrix02 = newColorMatrix[0][2];
			matrix03 = newColorMatrix[0][3];
			matrix04 = newColorMatrix[0][4];
			matrix10 = newColorMatrix[1][0];
			matrix11 = newColorMatrix[1][1];
			matrix12 = newColorMatrix[1][2];
			matrix13 = newColorMatrix[1][3];
			matrix14 = newColorMatrix[1][4];
			matrix20 = newColorMatrix[2][0];
			matrix21 = newColorMatrix[2][1];
			matrix22 = newColorMatrix[2][2];
			matrix23 = newColorMatrix[2][3];
			matrix24 = newColorMatrix[2][4];
			matrix30 = newColorMatrix[3][0];
			matrix31 = newColorMatrix[3][1];
			matrix32 = newColorMatrix[3][2];
			matrix33 = newColorMatrix[3][3];
			matrix34 = newColorMatrix[3][4];
			matrix40 = newColorMatrix[4][0];
			matrix41 = newColorMatrix[4][1];
			matrix42 = newColorMatrix[4][2];
			matrix43 = newColorMatrix[4][3];
			matrix44 = newColorMatrix[4][4];
		}

		internal float[][] GetMatrix()
		{
			float[][] array = new float[5][];
			for (int i = 0; i < 5; i++)
			{
				array[i] = new float[5];
			}
			array[0][0] = matrix00;
			array[0][1] = matrix01;
			array[0][2] = matrix02;
			array[0][3] = matrix03;
			array[0][4] = matrix04;
			array[1][0] = matrix10;
			array[1][1] = matrix11;
			array[1][2] = matrix12;
			array[1][3] = matrix13;
			array[1][4] = matrix14;
			array[2][0] = matrix20;
			array[2][1] = matrix21;
			array[2][2] = matrix22;
			array[2][3] = matrix23;
			array[2][4] = matrix24;
			array[3][0] = matrix30;
			array[3][1] = matrix31;
			array[3][2] = matrix32;
			array[3][3] = matrix33;
			array[3][4] = matrix34;
			array[4][0] = matrix40;
			array[4][1] = matrix41;
			array[4][2] = matrix42;
			array[4][3] = matrix43;
			array[4][4] = matrix44;
			return array;
		}
	}
	public enum ColorMatrixFlag
	{
		Default,
		SkipGrays,
		AltGrays
	}
	public enum ColorMode
	{
		Argb32Mode,
		Argb64Mode
	}
	public sealed class ColorPalette
	{
		private int flags;

		private Color[] entries;

		public int Flags => flags;

		public Color[] Entries => entries;

		internal ColorPalette(int count)
		{
			entries = new Color[count];
		}

		internal ColorPalette()
		{
			entries = new Color[1];
		}

		internal void ConvertFromMemory(IntPtr memory)
		{
			flags = Marshal.ReadInt32(memory);
			int num = Marshal.ReadInt32((IntPtr)((long)memory + 4));
			entries = new Color[num];
			for (int i = 0; i < num; i++)
			{
				int argb = Marshal.ReadInt32((IntPtr)((long)memory + 8 + i * 4));
				ref Color reference = ref entries[i];
				reference = Color.FromArgb(argb);
			}
		}

		internal IntPtr ConvertToMemory()
		{
			int num = entries.Length;
			IntPtr intPtr;
			checked
			{
				intPtr = Marshal.AllocHGlobal(4 * (2 + num));
				Marshal.WriteInt32(intPtr, 0, flags);
				Marshal.WriteInt32((IntPtr)((long)intPtr + 4), 0, num);
			}
			for (int i = 0; i < num; i++)
			{
				Marshal.WriteInt32((IntPtr)((long)intPtr + 4 * (i + 2)), 0, entries[i].ToArgb());
			}
			return intPtr;
		}
	}
}
namespace System.Drawing
{
	public sealed class ColorTranslator
	{
		private const int Win32RedShift = 0;

		private const int Win32GreenShift = 8;

		private const int Win32BlueShift = 16;

		private static Hashtable htmlSysColorTable;

		private ColorTranslator()
		{
		}

		public static int ToWin32(Color c)
		{
			return c.R | (c.G << 8) | (c.B << 16);
		}

		public static int ToOle(Color c)
		{
			if (c.IsKnownColor)
			{
				switch (c.ToKnownColor())
				{
				case KnownColor.ActiveBorder:
					return -2147483638;
				case KnownColor.ActiveCaption:
					return -2147483646;
				case KnownColor.ActiveCaptionText:
					return -2147483639;
				case KnownColor.AppWorkspace:
					return -2147483636;
				case KnownColor.ButtonFace:
					return -2147483633;
				case KnownColor.ButtonHighlight:
					return -2147483628;
				case KnownColor.ButtonShadow:
					return -2147483632;
				case KnownColor.Control:
					return -2147483633;
				case KnownColor.ControlDark:
					return -2147483632;
				case KnownColor.ControlDarkDark:
					return -2147483627;
				case KnownColor.ControlLight:
					return -2147483626;
				case KnownColor.ControlLightLight:
					return -2147483628;
				case KnownColor.ControlText:
					return -2147483630;
				case KnownColor.Desktop:
					return -2147483647;
				case KnownColor.GradientActiveCaption:
					return -2147483621;
				case KnownColor.GradientInactiveCaption:
					return -2147483620;
				case KnownColor.GrayText:
					return -2147483631;
				case KnownColor.Highlight:
					return -2147483635;
				case KnownColor.HighlightText:
					return -2147483634;
				case KnownColor.HotTrack:
					return -2147483635;
				case KnownColor.InactiveBorder:
					return -2147483637;
				case KnownColor.InactiveCaption:
					return -2147483645;
				case KnownColor.InactiveCaptionText:
					return -2147483629;
				case KnownColor.Info:
					return -2147483624;
				case KnownColor.InfoText:
					return -2147483625;
				case KnownColor.Menu:
					return -2147483644;
				case KnownColor.MenuBar:
					return -2147483618;
				case KnownColor.MenuHighlight:
					return -2147483619;
				case KnownColor.MenuText:
					return -2147483641;
				case KnownColor.ScrollBar:
					return int.MinValue;
				case KnownColor.Window:
					return -2147483643;
				case KnownColor.WindowFrame:
					return -2147483642;
				case KnownColor.WindowText:
					return -2147483640;
				}
			}
			return ToWin32(c);
		}

		public static Color FromOle(int oleColor)
		{
			if ((int)(oleColor & 0xFF000000u) == int.MinValue && (oleColor & 0xFFFFFF) <= 24)
			{
				switch (oleColor)
				{
				case -2147483638:
					return Color.FromKnownColor(KnownColor.ActiveBorder);
				case -2147483646:
					return Color.FromKnownColor(KnownColor.ActiveCaption);
				case -2147483639:
					return Color.FromKnownColor(KnownColor.ActiveCaptionText);
				case -2147483636:
					return Color.FromKnownColor(KnownColor.AppWorkspace);
				case -2147483633:
					return Color.FromKnownColor(KnownColor.Control);
				case -2147483632:
					return Color.FromKnownColor(KnownColor.ControlDark);
				case -2147483627:
					return Color.FromKnownColor(KnownColor.ControlDarkDark);
				case -2147483626:
					return Color.FromKnownColor(KnownColor.ControlLight);
				case -2147483628:
					return Color.FromKnownColor(KnownColor.ControlLightLight);
				case -2147483630:
					return Color.FromKnownColor(KnownColor.ControlText);
				case -2147483647:
					return Color.FromKnownColor(KnownColor.Desktop);
				case -2147483621:
					return Color.FromKnownColor(KnownColor.GradientActiveCaption);
				case -2147483620:
					return Color.FromKnownColor(KnownColor.GradientInactiveCaption);
				case -2147483631:
					return Color.FromKnownColor(KnownColor.GrayText);
				case -2147483635:
					return Color.FromKnownColor(KnownColor.Highlight);
				case -2147483634:
					return Color.FromKnownColor(KnownColor.HighlightText);
				case -2147483637:
					return Color.FromKnownColor(KnownColor.InactiveBorder);
				case -2147483645:
					return Color.FromKnownColor(KnownColor.InactiveCaption);
				case -2147483629:
					return Color.FromKnownColor(KnownColor.InactiveCaptionText);
				case -2147483624:
					return Color.FromKnownColor(KnownColor.Info);
				case -2147483625:
					return Color.FromKnownColor(KnownColor.InfoText);
				case -2147483644:
					return Color.FromKnownColor(KnownColor.Menu);
				case -2147483618:
					return Color.FromKnownColor(KnownColor.MenuBar);
				case -2147483619:
					return Color.FromKnownColor(KnownColor.MenuHighlight);
				case -2147483641:
					return Color.FromKnownColor(KnownColor.MenuText);
				case int.MinValue:
					return Color.FromKnownColor(KnownColor.ScrollBar);
				case -2147483643:
					return Color.FromKnownColor(KnownColor.Window);
				case -2147483642:
					return Color.FromKnownColor(KnownColor.WindowFrame);
				case -2147483640:
					return Color.FromKnownColor(KnownColor.WindowText);
				}
			}
			return KnownColorTable.ArgbToKnownColor(Color.FromArgb((byte)(oleColor & 0xFF), (byte)((oleColor >> 8) & 0xFF), (byte)((oleColor >> 16) & 0xFF)).ToArgb());
		}

		public static Color FromWin32(int win32Color)
		{
			return FromOle(win32Color);
		}

		public static Color FromHtml(string htmlColor)
		{
			Color result = Color.Empty;
			if (htmlColor == null || htmlColor.Length == 0)
			{
				return result;
			}
			if (htmlColor[0] == '#' && (htmlColor.Length == 7 || htmlColor.Length == 4))
			{
				if (htmlColor.Length == 7)
				{
					result = Color.FromArgb(Convert.ToInt32(htmlColor.Substring(1, 2), 16), Convert.ToInt32(htmlColor.Substring(3, 2), 16), Convert.ToInt32(htmlColor.Substring(5, 2), 16));
				}
				else
				{
					string text = char.ToString(htmlColor[1]);
					string text2 = char.ToString(htmlColor[2]);
					string text3 = char.ToString(htmlColor[3]);
					result = Color.FromArgb(Convert.ToInt32(text + text, 16), Convert.ToInt32(text2 + text2, 16), Convert.ToInt32(text3 + text3, 16));
				}
			}
			if (result.IsEmpty && string.Equals(htmlColor, "LightGrey", StringComparison.OrdinalIgnoreCase))
			{
				result = Color.LightGray;
			}
			if (result.IsEmpty)
			{
				if (htmlSysColorTable == null)
				{
					InitializeHtmlSysColorTable();
				}
				object obj = htmlSysColorTable[htmlColor.ToLower(CultureInfo.InvariantCulture)];
				if (obj != null)
				{
					result = (Color)obj;
				}
			}
			if (result.IsEmpty)
			{
				result = (Color)TypeDescriptor.GetConverter(typeof(Color)).ConvertFromString(htmlColor);
			}
			return result;
		}

		public static string ToHtml(Color c)
		{
			string result = string.Empty;
			if (c.IsEmpty)
			{
				return result;
			}
			if (!c.IsSystemColor)
			{
				result = ((!c.IsNamedColor) ? ("#" + c.R.ToString("X2", null) + c.G.ToString("X2", null) + c.B.ToString("X2", null)) : ((!(c == Color.LightGray)) ? c.Name : "LightGrey"));
			}
			else
			{
				switch (c.ToKnownColor())
				{
				case KnownColor.ActiveBorder:
					result = "activeborder";
					break;
				case KnownColor.ActiveCaption:
				case KnownColor.GradientActiveCaption:
					result = "activecaption";
					break;
				case KnownColor.AppWorkspace:
					result = "appworkspace";
					break;
				case KnownColor.Desktop:
					result = "background";
					break;
				case KnownColor.Control:
					result = "buttonface";
					break;
				case KnownColor.ControlLight:
					result = "buttonface";
					break;
				case KnownColor.ControlDark:
					result = "buttonshadow";
					break;
				case KnownColor.ControlText:
					result = "buttontext";
					break;
				case KnownColor.ActiveCaptionText:
					result = "captiontext";
					break;
				case KnownColor.GrayText:
					result = "graytext";
					break;
				case KnownColor.Highlight:
				case KnownColor.HotTrack:
					result = "highlight";
					break;
				case KnownColor.HighlightText:
				case KnownColor.MenuHighlight:
					result = "highlighttext";
					break;
				case KnownColor.InactiveBorder:
					result = "inactiveborder";
					break;
				case KnownColor.InactiveCaption:
				case KnownColor.GradientInactiveCaption:
					result = "inactivecaption";
					break;
				case KnownColor.InactiveCaptionText:
					result = "inactivecaptiontext";
					break;
				case KnownColor.Info:
					result = "infobackground";
					break;
				case KnownColor.InfoText:
					result = "infotext";
					break;
				case KnownColor.Menu:
				case KnownColor.MenuBar:
					result = "menu";
					break;
				case KnownColor.MenuText:
					result = "menutext";
					break;
				case KnownColor.ScrollBar:
					result = "scrollbar";
					break;
				case KnownColor.ControlDarkDark:
					result = "threeddarkshadow";
					break;
				case KnownColor.ControlLightLight:
					result = "buttonhighlight";
					break;
				case KnownColor.Window:
					result = "window";
					break;
				case KnownColor.WindowFrame:
					result = "windowframe";
					break;
				case KnownColor.WindowText:
					result = "windowtext";
					break;
				}
			}
			return result;
		}

		private static void InitializeHtmlSysColorTable()
		{
			htmlSysColorTable = new Hashtable(26);
			htmlSysColorTable["activeborder"] = Color.FromKnownColor(KnownColor.ActiveBorder);
			htmlSysColorTable["activecaption"] = Color.FromKnownColor(KnownColor.ActiveCaption);
			htmlSysColorTable["appworkspace"] = Color.FromKnownColor(KnownColor.AppWorkspace);
			htmlSysColorTable["background"] = Color.FromKnownColor(KnownColor.Desktop);
			htmlSysColorTable["buttonface"] = Color.FromKnownColor(KnownColor.Control);
			htmlSysColorTable["buttonhighlight"] = Color.FromKnownColor(KnownColor.ControlLightLight);
			htmlSysColorTable["buttonshadow"] = Color.FromKnownColor(KnownColor.ControlDark);
			htmlSysColorTable["buttontext"] = Color.FromKnownColor(KnownColor.ControlText);
			htmlSysColorTable["captiontext"] = Color.FromKnownColor(KnownColor.ActiveCaptionText);
			htmlSysColorTable["graytext"] = Color.FromKnownColor(KnownColor.GrayText);
			htmlSysColorTable["highlight"] = Color.FromKnownColor(KnownColor.Highlight);
			htmlSysColorTable["highlighttext"] = Color.FromKnownColor(KnownColor.HighlightText);
			htmlSysColorTable["inactiveborder"] = Color.FromKnownColor(KnownColor.InactiveBorder);
			htmlSysColorTable["inactivecaption"] = Color.FromKnownColor(KnownColor.InactiveCaption);
			htmlSysColorTable["inactivecaptiontext"] = Color.FromKnownColor(KnownColor.InactiveCaptionText);
			htmlSysColorTable["infobackground"] = Color.FromKnownColor(KnownColor.Info);
			htmlSysColorTable["infotext"] = Color.FromKnownColor(KnownColor.InfoText);
			htmlSysColorTable["menu"] = Color.FromKnownColor(KnownColor.Menu);
			htmlSysColorTable["menutext"] = Color.FromKnownColor(KnownColor.MenuText);
			htmlSysColorTable["scrollbar"] = Color.FromKnownColor(KnownColor.ScrollBar);
			htmlSysColorTable["threeddarkshadow"] = Color.FromKnownColor(KnownColor.ControlDarkDark);
			htmlSysColorTable["threedface"] = Color.FromKnownColor(KnownColor.Control);
			htmlSysColorTable["threedhighlight"] = Color.FromKnownColor(KnownColor.ControlLight);
			htmlSysColorTable["threedlightshadow"] = Color.FromKnownColor(KnownColor.ControlLightLight);
			htmlSysColorTable["window"] = Color.FromKnownColor(KnownColor.Window);
			htmlSysColorTable["windowframe"] = Color.FromKnownColor(KnownColor.WindowFrame);
			htmlSysColorTable["windowtext"] = Color.FromKnownColor(KnownColor.WindowText);
		}
	}
}
namespace System.Drawing.Drawing2D
{
	public enum CombineMode
	{
		Replace,
		Intersect,
		Union,
		Xor,
		Exclude,
		Complement
	}
	public enum CompositingMode
	{
		SourceOver,
		SourceCopy
	}
	public enum CompositingQuality
	{
		Invalid = -1,
		Default,
		HighSpeed,
		HighQuality,
		GammaCorrected,
		AssumeLinear
	}
	public enum CoordinateSpace
	{
		World,
		Page,
		Device
	}
	internal enum CustomLineCapType
	{
		Default,
		AdjustableArrowCap
	}
	public enum DashStyle
	{
		Solid,
		Dash,
		Dot,
		DashDot,
		DashDotDot,
		Custom
	}
}
namespace System.Drawing.Imaging
{
	internal enum EmfPlusFlags
	{
		Display = 1,
		NonDualGdi
	}
	public enum EmfPlusRecordType
	{
		WmfRecordBase = 65536,
		WmfSetBkColor = 66049,
		WmfSetBkMode = 65794,
		WmfSetMapMode = 65795,
		WmfSetROP2 = 65796,
		WmfSetRelAbs = 65797,
		WmfSetPolyFillMode = 65798,
		WmfSetStretchBltMode = 65799,
		WmfSetTextCharExtra = 65800,
		WmfSetTextColor = 66057,
		WmfSetTextJustification = 66058,
		WmfSetWindowOrg = 66059,
		WmfSetWindowExt = 66060,
		WmfSetViewportOrg = 66061,
		WmfSetViewportExt = 66062,
		WmfOffsetWindowOrg = 66063,
		WmfScaleWindowExt = 66576,
		WmfOffsetViewportOrg = 66065,
		WmfScaleViewportExt = 66578,
		WmfLineTo = 66067,
		WmfMoveTo = 66068,
		WmfExcludeClipRect = 66581,
		WmfIntersectClipRect = 66582,
		WmfArc = 67607,
		WmfEllipse = 66584,
		WmfFloodFill = 66585,
		WmfPie = 67610,
		WmfRectangle = 66587,
		WmfRoundRect = 67100,
		WmfPatBlt = 67101,
		WmfSaveDC = 65566,
		WmfSetPixel = 66591,
		WmfOffsetCilpRgn = 66080,
		WmfTextOut = 66849,
		WmfBitBlt = 67874,
		WmfStretchBlt = 68387,
		WmfPolygon = 66340,
		WmfPolyline = 66341,
		WmfEscape = 67110,
		WmfRestoreDC = 65831,
		WmfFillRegion = 66088,
		WmfFrameRegion = 66601,
		WmfInvertRegion = 65834,
		WmfPaintRegion = 65835,
		WmfSelectClipRegion = 65836,
		WmfSelectObject = 65837,
		WmfSetTextAlign = 65838,
		WmfChord = 67632,
		WmfSetMapperFlags = 66097,
		WmfExtTextOut = 68146,
		WmfSetDibToDev = 68915,
		WmfSelectPalette = 66100,
		WmfRealizePalette = 65589,
		WmfAnimatePalette = 66614,
		WmfSetPalEntries = 65591,
		WmfPolyPolygon = 66872,
		WmfResizePalette = 65849,
		WmfDibBitBlt = 67904,
		WmfDibStretchBlt = 68417,
		WmfDibCreatePatternBrush = 65858,
		WmfStretchDib = 69443,
		WmfExtFloodFill = 66888,
		WmfSetLayout = 65865,
		WmfDeleteObject = 66032,
		WmfCreatePalette = 65783,
		WmfCreatePatternBrush = 66041,
		WmfCreatePenIndirect = 66298,
		WmfCreateFontIndirect = 66299,
		WmfCreateBrushIndirect = 66300,
		WmfCreateRegion = 67327,
		EmfHeader = 1,
		EmfPolyBezier = 2,
		EmfPolygon = 3,
		EmfPolyline = 4,
		EmfPolyBezierTo = 5,
		EmfPolyLineTo = 6,
		EmfPolyPolyline = 7,
		EmfPolyPolygon = 8,
		EmfSetWindowExtEx = 9,
		EmfSetWindowOrgEx = 10,
		EmfSetViewportExtEx = 11,
		EmfSetViewportOrgEx = 12,
		EmfSetBrushOrgEx = 13,
		EmfEof = 14,
		EmfSetPixelV = 15,
		EmfSetMapperFlags = 16,
		EmfSetMapMode = 17,
		EmfSetBkMode = 18,
		EmfSetPolyFillMode = 19,
		EmfSetROP2 = 20,
		EmfSetStretchBltMode = 21,
		EmfSetTextAlign = 22,
		EmfSetColorAdjustment = 23,
		EmfSetTextColor = 24,
		EmfSetBkColor = 25,
		EmfOffsetClipRgn = 26,
		EmfMoveToEx = 27,
		EmfSetMetaRgn = 28,
		EmfExcludeClipRect = 29,
		EmfIntersectClipRect = 30,
		EmfScaleViewportExtEx = 31,
		EmfScaleWindowExtEx = 32,
		EmfSaveDC = 33,
		EmfRestoreDC = 34,
		EmfSetWorldTransform = 35,
		EmfModifyWorldTransform = 36,
		EmfSelectObject = 37,
		EmfCreatePen = 38,
		EmfCreateBrushIndirect = 39,
		EmfDeleteObject = 40,
		EmfAngleArc = 41,
		EmfEllipse = 42,
		EmfRectangle = 43,
		EmfRoundRect = 44,
		EmfRoundArc = 45,
		EmfChord = 46,
		EmfPie = 47,
		EmfSelectPalette = 48,
		EmfCreatePalette = 49,
		EmfSetPaletteEntries = 50,
		EmfResizePalette = 51,
		EmfRealizePalette = 52,
		EmfExtFloodFill = 53,
		EmfLineTo = 54,
		EmfArcTo = 55,
		EmfPolyDraw = 56,
		EmfSetArcDirection = 57,
		EmfSetMiterLimit = 58,
		EmfBeginPath = 59,
		EmfEndPath = 60,
		EmfCloseFigure = 61,
		EmfFillPath = 62,
		EmfStrokeAndFillPath = 63,
		EmfStrokePath = 64,
		EmfFlattenPath = 65,
		EmfWidenPath = 66,
		EmfSelectClipPath = 67,
		EmfAbortPath = 68,
		EmfReserved069 = 69,
		EmfGdiComment = 70,
		EmfFillRgn = 71,
		EmfFrameRgn = 72,
		EmfInvertRgn = 73,
		EmfPaintRgn = 74,
		EmfExtSelectClipRgn = 75,
		EmfBitBlt = 76,
		EmfStretchBlt = 77,
		EmfMaskBlt = 78,
		EmfPlgBlt = 79,
		EmfSetDIBitsToDevice = 80,
		EmfStretchDIBits = 81,
		EmfExtCreateFontIndirect = 82,
		EmfExtTextOutA = 83,
		EmfExtTextOutW = 84,
		EmfPolyBezier16 = 85,
		EmfPolygon16 = 86,
		EmfPolyline16 = 87,
		EmfPolyBezierTo16 = 88,
		EmfPolylineTo16 = 89,
		EmfPolyPolyline16 = 90,
		EmfPolyPolygon16 = 91,
		EmfPolyDraw16 = 92,
		EmfCreateMonoBrush = 93,
		EmfCreateDibPatternBrushPt = 94,
		EmfExtCreatePen = 95,
		EmfPolyTextOutA = 96,
		EmfPolyTextOutW = 97,
		EmfSetIcmMode = 98,
		EmfCreateColorSpace = 99,
		EmfSetColorSpace = 100,
		EmfDeleteColorSpace = 101,
		EmfGlsRecord = 102,
		EmfGlsBoundedRecord = 103,
		EmfPixelFormat = 104,
		EmfDrawEscape = 105,
		EmfExtEscape = 106,
		EmfStartDoc = 107,
		EmfSmallTextOut = 108,
		EmfForceUfiMapping = 109,
		EmfNamedEscpae = 110,
		EmfColorCorrectPalette = 111,
		EmfSetIcmProfileA = 112,
		EmfSetIcmProfileW = 113,
		EmfAlphaBlend = 114,
		EmfSetLayout = 115,
		EmfTransparentBlt = 116,
		EmfReserved117 = 117,
		EmfGradientFill = 118,
		EmfSetLinkedUfis = 119,
		EmfSetTextJustification = 120,
		EmfColorMatchToTargetW = 121,
		EmfCreateColorSpaceW = 122,
		EmfMax = 122,
		EmfMin = 1,
		EmfPlusRecordBase = 16384,
		Invalid = 16384,
		Header = 16385,
		EndOfFile = 16386,
		Comment = 16387,
		GetDC = 16388,
		MultiFormatStart = 16389,
		MultiFormatSection = 16390,
		MultiFormatEnd = 16391,
		Object = 16392,
		Clear = 16393,
		FillRects = 16394,
		DrawRects = 16395,
		FillPolygon = 16396,
		DrawLines = 16397,
		FillEllipse = 16398,
		DrawEllipse = 16399,
		FillPie = 16400,
		DrawPie = 16401,
		DrawArc = 16402,
		FillRegion = 16403,
		FillPath = 16404,
		DrawPath = 16405,
		FillClosedCurve = 16406,
		DrawClosedCurve = 16407,
		DrawCurve = 16408,
		DrawBeziers = 16409,
		DrawImage = 16410,
		DrawImagePoints = 16411,
		DrawString = 16412,
		SetRenderingOrigin = 16413,
		SetAntiAliasMode = 16414,
		SetTextRenderingHint = 16415,
		SetTextContrast = 16416,
		SetInterpolationMode = 16417,
		SetPixelOffsetMode = 16418,
		SetCompositingMode = 16419,
		SetCompositingQuality = 16420,
		Save = 16421,
		Restore = 16422,
		BeginContainer = 16423,
		BeginContainerNoParams = 16424,
		EndContainer = 16425,
		SetWorldTransform = 16426,
		ResetWorldTransform = 16427,
		MultiplyWorldTransform = 16428,
		TranslateWorldTransform = 16429,
		ScaleWorldTransform = 16430,
		RotateWorldTransform = 16431,
		SetPageTransform = 16432,
		ResetClip = 16433,
		SetClipRect = 16434,
		SetClipPath = 16435,
		SetClipRegion = 16436,
		OffsetClip = 16437,
		DrawDriverString = 16438,
		Total = 16439,
		Max = 16438,
		Min = 16385
	}
	public enum EmfType
	{
		EmfOnly = 3,
		EmfPlusOnly,
		EmfPlusDual
	}
	public sealed class Encoder
	{
		public static readonly Encoder Compression = new Encoder(new Guid(-526552163, -13100, 17646, new byte[8] { 142, 186, 63, 191, 139, 228, 252, 88 }));

		public static readonly Encoder ColorDepth = new Encoder(new Guid(1711829077, -21146, 19580, new byte[8] { 154, 24, 56, 162, 49, 11, 131, 55 }));

		public static readonly Encoder ScanMethod = new Encoder(new Guid(978200161, 12553, 20054, new byte[8] { 133, 54, 66, 193, 86, 231, 220, 250 }));

		public static readonly Encoder Version = new Encoder(new Guid(617712758, -32438, 16804, new byte[8] { 191, 83, 28, 33, 156, 204, 247, 151 }));

		public static readonly Encoder RenderMethod = new Encoder(new Guid(1833092410, 8858, 18469, new byte[8] { 139, 183, 92, 153, 226, 185, 168, 184 }));

		public static readonly Encoder Quality = new Encoder(new Guid(492561589, -1462, 17709, new byte[8] { 156, 221, 93, 179, 81, 5, 231, 235 }));

		public static readonly Encoder Transformation = new Encoder(new Guid(-1928416559, -23154, 20136, new byte[8] { 170, 20, 16, 128, 116, 183, 182, 249 }));

		public static readonly Encoder LuminanceTable = new Encoder(new Guid(-307020850, 614, 19063, new byte[8] { 185, 4, 39, 33, 96, 153, 231, 23 }));

		public static readonly Encoder ChrominanceTable = new Encoder(new Guid(-219916836, 2483, 17174, new byte[8] { 130, 96, 103, 106, 218, 50, 72, 28 }));

		public static readonly Encoder SaveFlag = new Encoder(new Guid(690120444, -21440, 18367, new byte[8] { 140, 252, 168, 91, 137, 166, 85, 222 }));

		private Guid guid;

		public Guid Guid => guid;

		public Encoder(Guid guid)
		{
			this.guid = guid;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	public sealed class EncoderParameter : IDisposable
	{
		[MarshalAs(UnmanagedType.Struct)]
		private Guid parameterGuid;

		private int numberOfValues;

		private int parameterValueType;

		private IntPtr parameterValue;

		public Encoder Encoder
		{
			get
			{
				return new Encoder(parameterGuid);
			}
			set
			{
				parameterGuid = value.Guid;
			}
		}

		public EncoderParameterValueType Type => (EncoderParameterValueType)parameterValueType;

		public EncoderParameterValueType ValueType => (EncoderParameterValueType)parameterValueType;

		public int NumberOfValues => numberOfValues;

		~EncoderParameter()
		{
			Dispose(disposing: false);
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.KeepAlive(this);
			GC.SuppressFinalize(this);
		}

		private void Dispose(bool disposing)
		{
			if (parameterValue != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(parameterValue);
			}
			parameterValue = IntPtr.Zero;
		}

		public EncoderParameter(Encoder encoder, byte value)
		{
			parameterGuid = encoder.Guid;
			parameterValueType = 1;
			numberOfValues = 1;
			parameterValue = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(byte)));
			if (parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			Marshal.WriteByte(parameterValue, value);
			GC.KeepAlive(this);
		}

		public EncoderParameter(Encoder encoder, byte value, bool undefined)
		{
			parameterGuid = encoder.Guid;
			if (undefined)
			{
				parameterValueType = 7;
			}
			else
			{
				parameterValueType = 1;
			}
			numberOfValues = 1;
			parameterValue = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(byte)));
			if (parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			Marshal.WriteByte(parameterValue, value);
			GC.KeepAlive(this);
		}

		public EncoderParameter(Encoder encoder, short value)
		{
			parameterGuid = encoder.Guid;
			parameterValueType = 3;
			numberOfValues = 1;
			parameterValue = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(short)));
			if (parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			Marshal.WriteInt16(parameterValue, value);
			GC.KeepAlive(this);
		}

		public EncoderParameter(Encoder encoder, long value)
		{
			parameterGuid = encoder.Guid;
			parameterValueType = 4;
			numberOfValues = 1;
			parameterValue = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(int)));
			if (parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			Marshal.WriteInt32(parameterValue, (int)value);
			GC.KeepAlive(this);
		}

		public EncoderParameter(Encoder encoder, int numerator, int denominator)
		{
			parameterGuid = encoder.Guid;
			parameterValueType = 5;
			numberOfValues = 1;
			int num = Marshal.SizeOf(typeof(int));
			parameterValue = Marshal.AllocHGlobal(2 * num);
			if (parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			Marshal.WriteInt32(parameterValue, numerator);
			Marshal.WriteInt32(Add(parameterValue, num), denominator);
			GC.KeepAlive(this);
		}

		public EncoderParameter(Encoder encoder, long rangebegin, long rangeend)
		{
			parameterGuid = encoder.Guid;
			parameterValueType = 6;
			numberOfValues = 1;
			int num = Marshal.SizeOf(typeof(int));
			parameterValue = Marshal.AllocHGlobal(2 * num);
			if (parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			Marshal.WriteInt32(parameterValue, (int)rangebegin);
			Marshal.WriteInt32(Add(parameterValue, num), (int)rangeend);
			GC.KeepAlive(this);
		}

		public EncoderParameter(Encoder encoder, int numerator1, int demoninator1, int numerator2, int demoninator2)
		{
			parameterGuid = encoder.Guid;
			parameterValueType = 8;
			numberOfValues = 1;
			int num = Marshal.SizeOf(typeof(int));
			parameterValue = Marshal.AllocHGlobal(4 * num);
			if (parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			Marshal.WriteInt32(parameterValue, numerator1);
			Marshal.WriteInt32(Add(parameterValue, num), demoninator1);
			Marshal.WriteInt32(Add(parameterValue, 2 * num), numerator2);
			Marshal.WriteInt32(Add(parameterValue, 3 * num), demoninator2);
			GC.KeepAlive(this);
		}

		public EncoderParameter(Encoder encoder, string value)
		{
			parameterGuid = encoder.Guid;
			parameterValueType = 2;
			numberOfValues = value.Length;
			parameterValue = Marshal.StringToHGlobalAnsi(value);
			GC.KeepAlive(this);
			if (parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
		}

		public EncoderParameter(Encoder encoder, byte[] value)
		{
			parameterGuid = encoder.Guid;
			parameterValueType = 1;
			numberOfValues = value.Length;
			parameterValue = Marshal.AllocHGlobal(numberOfValues);
			if (parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			Marshal.Copy(value, 0, parameterValue, numberOfValues);
			GC.KeepAlive(this);
		}

		public EncoderParameter(Encoder encoder, byte[] value, bool undefined)
		{
			parameterGuid = encoder.Guid;
			if (undefined)
			{
				parameterValueType = 7;
			}
			else
			{
				parameterValueType = 1;
			}
			numberOfValues = value.Length;
			parameterValue = Marshal.AllocHGlobal(numberOfValues);
			if (parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			Marshal.Copy(value, 0, parameterValue, numberOfValues);
			GC.KeepAlive(this);
		}

		public EncoderParameter(Encoder encoder, short[] value)
		{
			parameterGuid = encoder.Guid;
			parameterValueType = 3;
			numberOfValues = value.Length;
			int num = Marshal.SizeOf(typeof(short));
			parameterValue = Marshal.AllocHGlobal(checked(numberOfValues * num));
			if (parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			Marshal.Copy(value, 0, parameterValue, numberOfValues);
			GC.KeepAlive(this);
		}

		public unsafe EncoderParameter(Encoder encoder, long[] value)
		{
			parameterGuid = encoder.Guid;
			parameterValueType = 4;
			numberOfValues = value.Length;
			int num = Marshal.SizeOf(typeof(int));
			parameterValue = Marshal.AllocHGlobal(checked(numberOfValues * num));
			if (parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			int* ptr = (int*)(void*)parameterValue;
			fixed (long* ptr2 = value)
			{
				for (int i = 0; i < value.Length; i++)
				{
					ptr[i] = (int)ptr2[i];
				}
			}
			GC.KeepAlive(this);
		}

		public EncoderParameter(Encoder encoder, int[] numerator, int[] denominator)
		{
			parameterGuid = encoder.Guid;
			if (numerator.Length != denominator.Length)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			parameterValueType = 5;
			numberOfValues = numerator.Length;
			int num = Marshal.SizeOf(typeof(int));
			parameterValue = Marshal.AllocHGlobal(checked(numberOfValues * 2 * num));
			if (parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			for (int i = 0; i < numberOfValues; i++)
			{
				Marshal.WriteInt32(Add(i * 2 * num, parameterValue), numerator[i]);
				Marshal.WriteInt32(Add((i * 2 + 1) * num, parameterValue), denominator[i]);
			}
			GC.KeepAlive(this);
		}

		public EncoderParameter(Encoder encoder, long[] rangebegin, long[] rangeend)
		{
			parameterGuid = encoder.Guid;
			if (rangebegin.Length != rangeend.Length)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			parameterValueType = 6;
			numberOfValues = rangebegin.Length;
			int num = Marshal.SizeOf(typeof(int));
			parameterValue = Marshal.AllocHGlobal(checked(numberOfValues * 2 * num));
			if (parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			for (int i = 0; i < numberOfValues; i++)
			{
				Marshal.WriteInt32(Add(i * 2 * num, parameterValue), (int)rangebegin[i]);
				Marshal.WriteInt32(Add((i * 2 + 1) * num, parameterValue), (int)rangeend[i]);
			}
			GC.KeepAlive(this);
		}

		public EncoderParameter(Encoder encoder, int[] numerator1, int[] denominator1, int[] numerator2, int[] denominator2)
		{
			parameterGuid = encoder.Guid;
			if (numerator1.Length != denominator1.Length || numerator1.Length != denominator2.Length || denominator1.Length != denominator2.Length)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			parameterValueType = 8;
			numberOfValues = numerator1.Length;
			int num = Marshal.SizeOf(typeof(int));
			parameterValue = Marshal.AllocHGlobal(checked(numberOfValues * 4 * num));
			if (parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			for (int i = 0; i < numberOfValues; i++)
			{
				Marshal.WriteInt32(Add(parameterValue, 4 * i * num), numerator1[i]);
				Marshal.WriteInt32(Add(parameterValue, (4 * i + 1) * num), denominator1[i]);
				Marshal.WriteInt32(Add(parameterValue, (4 * i + 2) * num), numerator2[i]);
				Marshal.WriteInt32(Add(parameterValue, (4 * i + 3) * num), denominator2[i]);
			}
			GC.KeepAlive(this);
		}

		public EncoderParameter(Encoder encoder, int NumberOfValues, int Type, int Value)
		{
			IntSecurity.UnmanagedCode.Demand();
			int num;
			switch (Type)
			{
			case 1:
			case 2:
				num = 1;
				break;
			case 3:
				num = 2;
				break;
			case 4:
				num = 4;
				break;
			case 5:
			case 6:
				num = 8;
				break;
			case 7:
				num = 1;
				break;
			case 8:
				num = 16;
				break;
			default:
				throw SafeNativeMethods.Gdip.StatusException(8);
			}
			int num2 = checked(num * NumberOfValues);
			parameterValue = Marshal.AllocHGlobal(num2);
			if (parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			for (int i = 0; i < num2; i++)
			{
				Marshal.WriteByte(Add(parameterValue, i), Marshal.ReadByte((IntPtr)(Value + i)));
			}
			parameterValueType = Type;
			numberOfValues = NumberOfValues;
			parameterGuid = encoder.Guid;
			GC.KeepAlive(this);
		}

		private static IntPtr Add(IntPtr a, int b)
		{
			return (IntPtr)((long)a + b);
		}

		private static IntPtr Add(int a, IntPtr b)
		{
			return (IntPtr)(a + (long)b);
		}
	}
	public sealed class EncoderParameters : IDisposable
	{
		private EncoderParameter[] param;

		public EncoderParameter[] Param
		{
			get
			{
				return param;
			}
			set
			{
				param = value;
			}
		}

		public EncoderParameters(int count)
		{
			param = new EncoderParameter[count];
		}

		public EncoderParameters()
		{
			param = new EncoderParameter[1];
		}

		internal IntPtr ConvertToMemory()
		{
			int num = Marshal.SizeOf(typeof(EncoderParameter));
			int num2 = param.Length;
			IntPtr intPtr;
			long num3;
			checked
			{
				intPtr = Marshal.AllocHGlobal(num2 * num + Marshal.SizeOf(typeof(IntPtr)));
				if (intPtr == IntPtr.Zero)
				{
					throw SafeNativeMethods.Gdip.StatusException(3);
				}
				Marshal.WriteIntPtr(intPtr, (IntPtr)num2);
				num3 = (long)intPtr + Marshal.SizeOf(typeof(IntPtr));
			}
			for (int i = 0; i < num2; i++)
			{
				Marshal.StructureToPtr(param[i], (IntPtr)(num3 + i * num), fDeleteOld: false);
			}
			return intPtr;
		}

		internal static EncoderParameters ConvertFromMemory(IntPtr memory)
		{
			if (memory == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			int num = Marshal.ReadIntPtr(memory).ToInt32();
			EncoderParameters encoderParameters = new EncoderParameters(num);
			int num2 = Marshal.SizeOf(typeof(EncoderParameter));
			long num3 = (long)memory + Marshal.SizeOf(typeof(IntPtr));
			IntSecurity.UnmanagedCode.Assert();
			try
			{
				for (int i = 0; i < num; i++)
				{
					Guid guid = (Guid)UnsafeNativeMethods.PtrToStructure((IntPtr)(i * num2 + num3), typeof(Guid));
					int numberOfValues = Marshal.ReadInt32((IntPtr)(i * num2 + num3 + 16));
					int type = Marshal.ReadInt32((IntPtr)(i * num2 + num3 + 20));
					int value = Marshal.ReadInt32((IntPtr)(i * num2 + num3 + 24));
					encoderParameters.param[i] = new EncoderParameter(new Encoder(guid), numberOfValues, type, value);
				}
				return encoderParameters;
			}
			finally
			{
				CodeAccessPermission.RevertAssert();
			}
		}

		public void Dispose()
		{
			EncoderParameter[] array = param;
			for (int i = 0; i < array.Length; i++)
			{
				array[i]?.Dispose();
			}
			param = null;
		}
	}
	public enum EncoderParameterValueType
	{
		ValueTypeByte = 1,
		ValueTypeAscii,
		ValueTypeShort,
		ValueTypeLong,
		ValueTypeRational,
		ValueTypeLongRange,
		ValueTypeUndefined,
		ValueTypeRationalRange
	}
	public enum EncoderValue
	{
		ColorTypeCMYK,
		ColorTypeYCCK,
		CompressionLZW,
		CompressionCCITT3,
		CompressionCCITT4,
		CompressionRle,
		CompressionNone,
		ScanMethodInterlaced,
		ScanMethodNonInterlaced,
		VersionGif87,
		VersionGif89,
		RenderProgressive,
		RenderNonProgressive,
		TransformRotate90,
		TransformRotate180,
		TransformRotate270,
		TransformFlipHorizontal,
		TransformFlipVertical,
		MultiFrame,
		LastFrame,
		Flush,
		FrameDimensionTime,
		FrameDimensionResolution,
		FrameDimensionPage
	}
}
namespace System.Drawing.Drawing2D
{
	public enum FillMode
	{
		Alternate,
		Winding
	}
	public enum FlushIntention
	{
		Flush,
		Sync
	}
}
namespace System.Drawing
{
	[Serializable]
	[ComVisible(true)]
	[Editor("System.Drawing.Design.FontEditor, System.Drawing.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(UITypeEditor))]
	[TypeConverter(typeof(FontConverter))]
	public sealed class Font : MarshalByRefObject, ICloneable, ISerializable, IDisposable
	{
		private const int LogFontCharSetOffset = 23;

		private const int LogFontNameOffset = 28;

		private IntPtr nativeFont;

		private float fontSize;

		private FontStyle fontStyle;

		private FontFamily fontFamily;

		private GraphicsUnit fontUnit;

		private byte gdiCharSet = 1;

		private bool gdiVerticalFont;

		private string systemFontName = "";

		private string originalFontName;

		internal IntPtr NativeFont => nativeFont;

		[Browsable(false)]
		public FontFamily FontFamily => fontFamily;

		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public bool Bold => (Style & FontStyle.Bold) != 0;

		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public byte GdiCharSet => gdiCharSet;

		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public bool GdiVerticalFont => gdiVerticalFont;

		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public bool Italic => (Style & FontStyle.Italic) != 0;

		[TypeConverter(typeof(FontConverter.FontNameConverter))]
		[Editor("System.Drawing.Design.FontNameEditor, System.Drawing.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(UITypeEditor))]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public string Name => FontFamily.Name;

		[Browsable(false)]
		public string OriginalFontName => originalFontName;

		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public bool Strikeout => (Style & FontStyle.Strikeout) != 0;

		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public bool Underline => (Style & FontStyle.Underline) != 0;

		[Browsable(false)]
		public FontStyle Style => fontStyle;

		public float Size => fontSize;

		[Browsable(false)]
		public float SizeInPoints
		{
			get
			{
				if (Unit == GraphicsUnit.Point)
				{
					return Size;
				}
				IntPtr dC = UnsafeNativeMethods.GetDC(NativeMethods.NullHandleRef);
				try
				{
					using Graphics graphics = Graphics.FromHdcInternal(dC);
					float num = (float)((double)graphics.DpiY / 72.0);
					float height = GetHeight(graphics);
					float num2 = height * (float)FontFamily.GetEmHeight(Style) / (float)FontFamily.GetLineSpacing(Style);
					return num2 / num;
				}
				finally
				{
					UnsafeNativeMethods.ReleaseDC(NativeMethods.NullHandleRef, new HandleRef(null, dC));
				}
			}
		}

		[TypeConverter(typeof(FontConverter.FontUnitConverter))]
		public GraphicsUnit Unit => fontUnit;

		[Browsable(false)]
		public int Height => (int)Math.Ceiling(GetHeight());

		[Browsable(false)]
		public bool IsSystemFont => !string.IsNullOrEmpty(systemFontName);

		[Browsable(false)]
		public string SystemFontName => systemFontName;

		private void CreateNativeFont()
		{
			int num = SafeNativeMethods.Gdip.GdipCreateFont(new HandleRef(this, fontFamily.NativeFamily), fontSize, fontStyle, fontUnit, out nativeFont);
			switch (num)
			{
			case 15:
				throw new ArgumentException(SR.GetString("GdiplusFontStyleNotFound", fontFamily.Name, fontStyle.ToString()));
			default:
				throw SafeNativeMethods.Gdip.StatusException(num);
			case 0:
				break;
			}
		}

		private Font(SerializationInfo info, StreamingContext context)
		{
			string familyName = null;
			float emSize = -1f;
			FontStyle style = FontStyle.Regular;
			GraphicsUnit unit = GraphicsUnit.Point;
			SingleConverter singleConverter = new SingleConverter();
			SerializationInfoEnumerator enumerator = info.GetEnumerator();
			while (enumerator.MoveNext())
			{
				if (string.Equals(enumerator.Name, "Name", StringComparison.OrdinalIgnoreCase))
				{
					familyName = (string)enumerator.Value;
				}
				else if (string.Equals(enumerator.Name, "Size", StringComparison.OrdinalIgnoreCase))
				{
					emSize = ((!(enumerator.Value is string)) ? ((float)enumerator.Value) : ((float)singleConverter.ConvertFrom(enumerator.Value)));
				}
				else if (string.Compare(enumerator.Name, "Style", ignoreCase: true, CultureInfo.InvariantCulture) == 0)
				{
					style = (FontStyle)enumerator.Value;
				}
				else if (string.Compare(enumerator.Name, "Unit", ignoreCase: true, CultureInfo.InvariantCulture) == 0)
				{
					unit = (GraphicsUnit)enumerator.Value;
				}
			}
			Initialize(familyName, emSize, style, unit, 1, IsVerticalName(familyName));
		}

		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
		void ISerializable.GetObjectData(SerializationInfo si, StreamingContext context)
		{
			si.AddValue("Name", string.IsNullOrEmpty(OriginalFontName) ? Name : OriginalFontName);
			si.AddValue("Size", Size);
			si.AddValue("Style", Style);
			si.AddValue("Unit", Unit);
		}

		public Font(Font prototype, FontStyle newStyle)
		{
			originalFontName = prototype.OriginalFontName;
			Initialize(prototype.FontFamily, prototype.Size, newStyle, prototype.Unit, 1, gdiVerticalFont: false);
		}

		public Font(FontFamily family, float emSize, FontStyle style, GraphicsUnit unit)
		{
			Initialize(family, emSize, style, unit, 1, gdiVerticalFont: false);
		}

		public Font(FontFamily family, float emSize, FontStyle style, GraphicsUnit unit, byte gdiCharSet)
		{
			Initialize(family, emSize, style, unit, gdiCharSet, gdiVerticalFont: false);
		}

		public Font(FontFamily family, float emSize, FontStyle style, GraphicsUnit unit, byte gdiCharSet, bool gdiVerticalFont)
		{
			Initialize(family, emSize, style, unit, gdiCharSet, gdiVerticalFont);
		}

		public Font(string familyName, float emSize, FontStyle style, GraphicsUnit unit, byte gdiCharSet)
		{
			Initialize(familyName, emSize, style, unit, gdiCharSet, IsVerticalName(familyName));
		}

		public Font(string familyName, float emSize, FontStyle style, GraphicsUnit unit, byte gdiCharSet, bool gdiVerticalFont)
		{
			if (float.IsNaN(emSize) || float.IsInfinity(emSize) || emSize <= 0f)
			{
				throw new ArgumentException(SR.GetString("InvalidBoundArgument", "emSize", emSize, 0, "System.Single.MaxValue"), "emSize");
			}
			Initialize(familyName, emSize, style, unit, gdiCharSet, gdiVerticalFont);
		}

		public Font(FontFamily family, float emSize, FontStyle style)
		{
			Initialize(family, emSize, style, GraphicsUnit.Point, 1, gdiVerticalFont: false);
		}

		public Font(FontFamily family, float emSize, GraphicsUnit unit)
		{
			Initialize(family, emSize, FontStyle.Regular, unit, 1, gdiVerticalFont: false);
		}

		public Font(FontFamily family, float emSize)
		{
			Initialize(family, emSize, FontStyle.Regular, GraphicsUnit.Point, 1, gdiVerticalFont: false);
		}

		public Font(string familyName, float emSize, FontStyle style, GraphicsUnit unit)
		{
			Initialize(familyName, emSize, style, unit, 1, IsVerticalName(familyName));
		}

		public Font(string familyName, float emSize, FontStyle style)
		{
			Initialize(familyName, emSize, style, GraphicsUnit.Point, 1, IsVerticalName(familyName));
		}

		public Font(string familyName, float emSize, GraphicsUnit unit)
		{
			Initialize(familyName, emSize, FontStyle.Regular, unit, 1, IsVerticalName(familyName));
		}

		public Font(string familyName, float emSize)
		{
			Initialize(familyName, emSize, FontStyle.Regular, GraphicsUnit.Point, 1, IsVerticalName(familyName));
		}

		private Font(IntPtr nativeFont, byte gdiCharSet, bool gdiVerticalFont)
		{
			int num = 0;
			float size = 0f;
			GraphicsUnit unit = GraphicsUnit.Point;
			FontStyle style = FontStyle.Regular;
			IntPtr family = IntPtr.Zero;
			this.nativeFont = nativeFont;
			num = SafeNativeMethods.Gdip.GdipGetFontUnit(new HandleRef(this, nativeFont), out unit);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			num = SafeNativeMethods.Gdip.GdipGetFontSize(new HandleRef(this, nativeFont), out size);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			num = SafeNativeMethods.Gdip.GdipGetFontStyle(new HandleRef(this, nativeFont), out style);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			num = SafeNativeMethods.Gdip.GdipGetFamily(new HandleRef(this, nativeFont), out family);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetFontFamily(new FontFamily(family));
			Initialize(fontFamily, size, style, unit, gdiCharSet, gdiVerticalFont);
		}

		private void Initialize(string familyName, float emSize, FontStyle style, GraphicsUnit unit, byte gdiCharSet, bool gdiVerticalFont)
		{
			originalFontName = familyName;
			SetFontFamily(new FontFamily(StripVerticalName(familyName), createDefaultOnFail: true));
			Initialize(fontFamily, emSize, style, unit, gdiCharSet, gdiVerticalFont);
		}

		private void Initialize(FontFamily family, float emSize, FontStyle style, GraphicsUnit unit, byte gdiCharSet, bool gdiVerticalFont)
		{
			if (family == null)
			{
				throw new ArgumentNullException("family");
			}
			if (float.IsNaN(emSize) || float.IsInfinity(emSize) || emSize <= 0f)
			{
				throw new ArgumentException(SR.GetString("InvalidBoundArgument", "emSize", emSize, 0, "System.Single.MaxValue"), "emSize");
			}
			fontSize = emSize;
			fontStyle = style;
			fontUnit = unit;
			this.gdiCharSet = gdiCharSet;
			this.gdiVerticalFont = gdiVerticalFont;
			if (fontFamily == null)
			{
				SetFontFamily(new FontFamily(family.NativeFamily));
			}
			if (nativeFont == IntPtr.Zero)
			{
				CreateNativeFont();
			}
			int num = SafeNativeMethods.Gdip.GdipGetFontSize(new HandleRef(this, nativeFont), out fontSize);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public static Font FromHfont(IntPtr hfont)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			SafeNativeMethods.LOGFONT lOGFONT = new SafeNativeMethods.LOGFONT();
			SafeNativeMethods.GetObject(new HandleRef(null, hfont), lOGFONT);
			IntPtr dC = UnsafeNativeMethods.GetDC(NativeMethods.NullHandleRef);
			try
			{
				return FromLogFont(lOGFONT, dC);
			}
			finally
			{
				UnsafeNativeMethods.ReleaseDC(NativeMethods.NullHandleRef, new HandleRef(null, dC));
			}
		}

		public static Font FromLogFont(object lf)
		{
			IntPtr dC = UnsafeNativeMethods.GetDC(NativeMethods.NullHandleRef);
			try
			{
				return FromLogFont(lf, dC);
			}
			finally
			{
				UnsafeNativeMethods.ReleaseDC(NativeMethods.NullHandleRef, new HandleRef(null, dC));
			}
		}

		public static Font FromLogFont(object lf, IntPtr hdc)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			IntPtr font = IntPtr.Zero;
			int num = ((Marshal.SystemDefaultCharSize != 1) ? SafeNativeMethods.Gdip.GdipCreateFontFromLogfontW(new HandleRef(null, hdc), lf, out font) : SafeNativeMethods.Gdip.GdipCreateFontFromLogfontA(new HandleRef(null, hdc), lf, out font));
			switch (num)
			{
			case 16:
				throw new ArgumentException(SR.GetString("GdiplusNotTrueTypeFont_NoName"));
			default:
				throw SafeNativeMethods.Gdip.StatusException(num);
			case 0:
				if (font == IntPtr.Zero)
				{
					throw new ArgumentException(SR.GetString("GdiplusNotTrueTypeFont", lf.ToString()));
				}
				return new Font(gdiVerticalFont: (Marshal.SystemDefaultCharSize != 1) ? (Marshal.ReadInt16(lf, 28) == 64) : (Marshal.ReadByte(lf, 28) == 64), nativeFont: font, gdiCharSet: Marshal.ReadByte(lf, 23));
			}
		}

		public static Font FromHdc(IntPtr hdc)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			IntPtr font = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateFontFromDC(new HandleRef(null, hdc), ref font);
			return num switch
			{
				16 => throw new ArgumentException(SR.GetString("GdiplusNotTrueTypeFont_NoName")), 
				0 => new Font(font, 0, gdiVerticalFont: false), 
				_ => throw SafeNativeMethods.Gdip.StatusException(num), 
			};
		}

		public object Clone()
		{
			IntPtr cloneFont = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCloneFont(new HandleRef(this, nativeFont), out cloneFont);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new Font(cloneFont, gdiCharSet, gdiVerticalFont);
		}

		private void SetFontFamily(FontFamily family)
		{
			fontFamily = family;
			new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Assert();
			GC.SuppressFinalize(fontFamily);
		}

		~Font()
		{
			Dispose(disposing: false);
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		private void Dispose(bool disposing)
		{
			if (!(nativeFont != IntPtr.Zero))
			{
				return;
			}
			try
			{
				SafeNativeMethods.Gdip.GdipDeleteFont(new HandleRef(this, nativeFont));
			}
			catch (Exception ex)
			{
				if (ClientUtils.IsCriticalException(ex))
				{
					throw;
				}
			}
			finally
			{
				nativeFont = IntPtr.Zero;
			}
		}

		private static bool IsVerticalName(string familyName)
		{
			if (familyName != null && familyName.Length > 0)
			{
				return familyName[0] == '@';
			}
			return false;
		}

		public override bool Equals(object obj)
		{
			if (obj == this)
			{
				return true;
			}
			if (!(obj is Font font))
			{
				return false;
			}
			if (font.FontFamily.Equals(FontFamily) && font.GdiVerticalFont == GdiVerticalFont && font.GdiCharSet == GdiCharSet && font.Style == Style && font.Size == Size)
			{
				return font.Unit == Unit;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return (((int)fontStyle << 13) | (int)((uint)fontStyle >> 19)) ^ (((int)fontUnit << 26) | (int)((uint)fontUnit >> 6)) ^ (int)(((uint)fontSize << 7) | ((uint)fontSize >> 25));
		}

		private static string StripVerticalName(string familyName)
		{
			if (familyName != null && familyName.Length > 1 && familyName[0] == '@')
			{
				return familyName.Substring(1);
			}
			return familyName;
		}

		public override string ToString()
		{
			return string.Format(CultureInfo.CurrentCulture, "[{0}: Name={1}, Size={2}, Units={3}, GdiCharSet={4}, GdiVerticalFont={5}]", GetType().Name, FontFamily.Name, fontSize, (int)fontUnit, gdiCharSet, gdiVerticalFont);
		}

		public void ToLogFont(object logFont)
		{
			IntPtr dC = UnsafeNativeMethods.GetDC(NativeMethods.NullHandleRef);
			try
			{
				Graphics graphics = Graphics.FromHdcInternal(dC);
				try
				{
					ToLogFont(logFont, graphics);
				}
				finally
				{
					graphics.Dispose();
				}
			}
			finally
			{
				UnsafeNativeMethods.ReleaseDC(NativeMethods.NullHandleRef, new HandleRef(null, dC));
			}
		}

		public void ToLogFont(object logFont, Graphics graphics)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			if (graphics == null)
			{
				throw new ArgumentNullException("graphics");
			}
			int num = ((Marshal.SystemDefaultCharSize != 1) ? SafeNativeMethods.Gdip.GdipGetLogFontW(new HandleRef(this, NativeFont), new HandleRef(graphics, graphics.NativeGraphics), logFont) : SafeNativeMethods.Gdip.GdipGetLogFontA(new HandleRef(this, NativeFont), new HandleRef(graphics, graphics.NativeGraphics), logFont));
			if (gdiVerticalFont)
			{
				if (Marshal.SystemDefaultCharSize == 1)
				{
					for (int num2 = 30; num2 >= 0; num2--)
					{
						Marshal.WriteByte(logFont, 28 + num2 + 1, Marshal.ReadByte(logFont, 28 + num2));
					}
					Marshal.WriteByte(logFont, 28, 64);
				}
				else
				{
					for (int num3 = 60; num3 >= 0; num3 -= 2)
					{
						Marshal.WriteInt16(logFont, 28 + num3 + 2, Marshal.ReadInt16(logFont, 28 + num3));
					}
					Marshal.WriteInt16(logFont, 28, 64);
				}
			}
			if (Marshal.ReadByte(logFont, 23) == 0)
			{
				Marshal.WriteByte(logFont, 23, gdiCharSet);
			}
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public IntPtr ToHfont()
		{
			SafeNativeMethods.LOGFONT lOGFONT = new SafeNativeMethods.LOGFONT();
			IntSecurity.ObjectFromWin32Handle.Assert();
			try
			{
				ToLogFont(lOGFONT);
			}
			finally
			{
				CodeAccessPermission.RevertAssert();
			}
			IntPtr intPtr = IntUnsafeNativeMethods.IntCreateFontIndirect(lOGFONT);
			if (intPtr == IntPtr.Zero)
			{
				throw new Win32Exception();
			}
			return intPtr;
		}

		public float GetHeight(Graphics graphics)
		{
			if (graphics == null)
			{
				throw new ArgumentNullException("graphics");
			}
			float size;
			int num = SafeNativeMethods.Gdip.GdipGetFontHeight(new HandleRef(this, NativeFont), new HandleRef(graphics, graphics.NativeGraphics), out size);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return size;
		}

		public float GetHeight()
		{
			IntPtr dC = UnsafeNativeMethods.GetDC(NativeMethods.NullHandleRef);
			float num = 0f;
			try
			{
				using Graphics graphics = Graphics.FromHdcInternal(dC);
				return GetHeight(graphics);
			}
			finally
			{
				UnsafeNativeMethods.ReleaseDC(NativeMethods.NullHandleRef, new HandleRef(null, dC));
			}
		}

		public float GetHeight(float dpi)
		{
			float size;
			int num = SafeNativeMethods.Gdip.GdipGetFontHeightGivenDPI(new HandleRef(this, NativeFont), dpi, out size);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return size;
		}

		internal void SetSystemFontName(string systemFontName)
		{
			this.systemFontName = systemFontName;
		}
	}
}
namespace System.Drawing.Text
{
	public abstract class FontCollection : IDisposable
	{
		internal IntPtr nativeFontCollection;

		public FontFamily[] Families
		{
			get
			{
				int numFound = 0;
				int num = SafeNativeMethods.Gdip.GdipGetFontCollectionFamilyCount(new HandleRef(this, nativeFontCollection), out numFound);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				IntPtr[] array = new IntPtr[numFound];
				int numFound2 = 0;
				num = SafeNativeMethods.Gdip.GdipGetFontCollectionFamilyList(new HandleRef(this, nativeFontCollection), numFound, array, out numFound2);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				FontFamily[] array2 = new FontFamily[numFound2];
				for (int i = 0; i < numFound2; i++)
				{
					SafeNativeMethods.Gdip.GdipCloneFontFamily(new HandleRef(null, array[i]), out var clonefontfamily);
					array2[i] = new FontFamily(clonefontfamily);
				}
				return array2;
			}
		}

		internal FontCollection()
		{
			nativeFontCollection = IntPtr.Zero;
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		protected virtual void Dispose(bool disposing)
		{
		}

		~FontCollection()
		{
			Dispose(disposing: false);
		}
	}
}
namespace System.Drawing
{
	public sealed class FontFamily : MarshalByRefObject, IDisposable
	{
		private const int LANG_NEUTRAL = 0;

		private IntPtr nativeFamily;

		private bool createDefaultOnFail;

		internal IntPtr NativeFamily => nativeFamily;

		private static int CurrentLanguage => CultureInfo.CurrentUICulture.LCID;

		public string Name => GetName(CurrentLanguage);

		public static FontFamily[] Families => new InstalledFontCollection().Families;

		public static FontFamily GenericSansSerif => new FontFamily(GetGdipGenericSansSerif());

		public static FontFamily GenericSerif => new FontFamily(GetNativeGenericSerif());

		public static FontFamily GenericMonospace => new FontFamily(GetNativeGenericMonospace());

		private void SetNativeFamily(IntPtr family)
		{
			nativeFamily = family;
		}

		internal FontFamily(IntPtr family)
		{
			SetNativeFamily(family);
		}

		internal FontFamily(string name, bool createDefaultOnFail)
		{
			this.createDefaultOnFail = createDefaultOnFail;
			CreateFontFamily(name, null);
		}

		public FontFamily(string name)
		{
			CreateFontFamily(name, null);
		}

		public FontFamily(string name, FontCollection fontCollection)
		{
			CreateFontFamily(name, fontCollection);
		}

		private void CreateFontFamily(string name, FontCollection fontCollection)
		{
			IntPtr FontFamily = IntPtr.Zero;
			IntPtr handle = fontCollection?.nativeFontCollection ?? IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateFontFamilyFromName(name, new HandleRef(fontCollection, handle), out FontFamily);
			if (num != 0)
			{
				if (!createDefaultOnFail)
				{
					switch (num)
					{
					case 14:
						throw new ArgumentException(SR.GetString("GdiplusFontFamilyNotFound", name));
					case 16:
						throw new ArgumentException(SR.GetString("GdiplusNotTrueTypeFont", name));
					default:
						throw SafeNativeMethods.Gdip.StatusException(num);
					}
				}
				FontFamily = GetGdipGenericSansSerif();
			}
			SetNativeFamily(FontFamily);
		}

		public FontFamily(GenericFontFamilies genericFamily)
		{
			IntPtr fontfamily = IntPtr.Zero;
			int num = genericFamily switch
			{
				GenericFontFamilies.Serif => SafeNativeMethods.Gdip.GdipGetGenericFontFamilySerif(out fontfamily), 
				GenericFontFamilies.SansSerif => SafeNativeMethods.Gdip.GdipGetGenericFontFamilySansSerif(out fontfamily), 
				_ => SafeNativeMethods.Gdip.GdipGetGenericFontFamilyMonospace(out fontfamily), 
			};
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeFamily(fontfamily);
		}

		~FontFamily()
		{
			Dispose(disposing: false);
		}

		public override bool Equals(object obj)
		{
			if (obj == this)
			{
				return true;
			}
			if (!(obj is FontFamily fontFamily))
			{
				return false;
			}
			return fontFamily.NativeFamily == NativeFamily;
		}

		public override string ToString()
		{
			return string.Format(CultureInfo.CurrentCulture, "[{0}: Name={1}]", GetType().Name, Name);
		}

		public override int GetHashCode()
		{
			return GetName(0).GetHashCode();
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		private void Dispose(bool disposing)
		{
			if (!(nativeFamily != IntPtr.Zero))
			{
				return;
			}
			try
			{
				SafeNativeMethods.Gdip.GdipDeleteFontFamily(new HandleRef(this, nativeFamily));
			}
			catch (Exception ex)
			{
				if (ClientUtils.IsCriticalException(ex))
				{
					throw;
				}
			}
			finally
			{
				nativeFamily = IntPtr.Zero;
			}
		}

		public string GetName(int language)
		{
			StringBuilder stringBuilder = new StringBuilder(32);
			int num = SafeNativeMethods.Gdip.GdipGetFamilyName(new HandleRef(this, NativeFamily), stringBuilder, language);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return stringBuilder.ToString();
		}

		private static IntPtr GetGdipGenericSansSerif()
		{
			IntPtr fontfamily = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipGetGenericFontFamilySansSerif(out fontfamily);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return fontfamily;
		}

		private static IntPtr GetNativeGenericSerif()
		{
			IntPtr fontfamily = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipGetGenericFontFamilySerif(out fontfamily);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return fontfamily;
		}

		private static IntPtr GetNativeGenericMonospace()
		{
			IntPtr fontfamily = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipGetGenericFontFamilyMonospace(out fontfamily);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return fontfamily;
		}

		[Obsolete("Do not use method GetFamilies, use property Families instead")]
		public static FontFamily[] GetFamilies(Graphics graphics)
		{
			if (graphics == null)
			{
				throw new ArgumentNullException("graphics");
			}
			return new InstalledFontCollection().Families;
		}

		public bool IsStyleAvailable(FontStyle style)
		{
			int isStyleAvailable;
			int num = SafeNativeMethods.Gdip.GdipIsStyleAvailable(new HandleRef(this, NativeFamily), style, out isStyleAvailable);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return isStyleAvailable != 0;
		}

		public int GetEmHeight(FontStyle style)
		{
			int EmHeight = 0;
			int num = SafeNativeMethods.Gdip.GdipGetEmHeight(new HandleRef(this, NativeFamily), style, out EmHeight);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return EmHeight;
		}

		public int GetCellAscent(FontStyle style)
		{
			int CellAscent = 0;
			int num = SafeNativeMethods.Gdip.GdipGetCellAscent(new HandleRef(this, NativeFamily), style, out CellAscent);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return CellAscent;
		}

		public int GetCellDescent(FontStyle style)
		{
			int CellDescent = 0;
			int num = SafeNativeMethods.Gdip.GdipGetCellDescent(new HandleRef(this, NativeFamily), style, out CellDescent);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return CellDescent;
		}

		public int GetLineSpacing(FontStyle style)
		{
			int LineSpaceing = 0;
			int num = SafeNativeMethods.Gdip.GdipGetLineSpacing(new HandleRef(this, NativeFamily), style, out LineSpaceing);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return LineSpaceing;
		}
	}
	[Flags]
	public enum FontStyle
	{
		Regular = 0,
		Bold = 1,
		Italic = 2,
		Underline = 4,
		Strikeout = 8
	}
}
namespace System.Drawing.Imaging
{
	public sealed class FrameDimension
	{
		private static FrameDimension time = new FrameDimension(new Guid("{6aedbd6d-3fb5-418a-83a6-7f45229dc872}"));

		private static FrameDimension resolution = new FrameDimension(new Guid("{84236f7b-3bd3-428f-8dab-4ea1439ca315}"));

		private static FrameDimension page = new FrameDimension(new Guid("{7462dc86-6180-4c7e-8e3f-ee7333a7a483}"));

		private Guid guid;

		public Guid Guid => guid;

		public static FrameDimension Time => time;

		public static FrameDimension Resolution => resolution;

		public static FrameDimension Page => page;

		public FrameDimension(Guid guid)
		{
			this.guid = guid;
		}

		public override bool Equals(object o)
		{
			if (!(o is FrameDimension frameDimension))
			{
				return false;
			}
			return guid == frameDimension.guid;
		}

		public override int GetHashCode()
		{
			return guid.GetHashCode();
		}

		public override string ToString()
		{
			if (this == time)
			{
				return "Time";
			}
			if (this == resolution)
			{
				return "Resolution";
			}
			if (this == page)
			{
				return "Page";
			}
			return string.Concat("[FrameDimension: ", guid, "]");
		}
	}
}
namespace System.Drawing
{
	[SuppressUnmanagedCodeSecurity]
	internal class SafeNativeMethods
	{
		[SuppressUnmanagedCodeSecurity]
		internal class Gdip
		{
			private struct StartupInput
			{
				public int GdiplusVersion;

				public IntPtr DebugEventCallback;

				public bool SuppressBackgroundThread;

				public bool SuppressExternalCodecs;

				public static StartupInput GetDefault()
				{
					StartupInput result = default(StartupInput);
					result.GdiplusVersion = 1;
					result.SuppressBackgroundThread = false;
					result.SuppressExternalCodecs = false;
					return result;
				}
			}

			private struct StartupOutput
			{
				public IntPtr hook;

				public IntPtr unhook;
			}

			private enum DebugEventLevel
			{
				Fatal,
				Warning
			}

			private const string ThreadDataSlotName = "system.drawing.threaddata";

			internal const int Ok = 0;

			internal const int GenericError = 1;

			internal const int InvalidParameter = 2;

			internal const int OutOfMemory = 3;

			internal const int ObjectBusy = 4;

			internal const int InsufficientBuffer = 5;

			internal const int NotImplemented = 6;

			internal const int Win32Error = 7;

			internal const int WrongState = 8;

			internal const int Aborted = 9;

			internal const int FileNotFound = 10;

			internal const int ValueOverflow = 11;

			internal const int AccessDenied = 12;

			internal const int UnknownImageFormat = 13;

			internal const int FontFamilyNotFound = 14;

			internal const int FontStyleNotFound = 15;

			internal const int NotTrueTypeFont = 16;

			internal const int UnsupportedGdiplusVersion = 17;

			internal const int GdiplusNotInitialized = 18;

			internal const int PropertyNotFound = 19;

			internal const int PropertyNotSupported = 20;

			private static readonly TraceSwitch GdiPlusInitialization;

			private static readonly BooleanSwitch GdiPlusIgnoreAtom;

			private static IntPtr initToken;

			private static string atomName;

			private static ushort hAtom;

			private static string AtomName
			{
				get
				{
					if (atomName == null)
					{
						atomName = VersioningHelper.MakeVersionSafeName("GDI+Atom", ResourceScope.Machine, ResourceScope.AppDomain);
					}
					return atomName;
				}
			}

			private static bool IsShutdown => FindAtom(AtomName) == 0;

			internal static IDictionary ThreadData
			{
				get
				{
					LocalDataStoreSlot namedDataSlot = Thread.GetNamedDataSlot("system.drawing.threaddata");
					IDictionary dictionary = (IDictionary)Thread.GetData(namedDataSlot);
					if (dictionary == null)
					{
						dictionary = new Hashtable();
						Thread.SetData(namedDataSlot, dictionary);
					}
					return dictionary;
				}
			}

			static Gdip()
			{
				GdiPlusInitialization = new TraceSwitch("GdiPlusInitialization", "Tracks GDI+ initialization and teardown");
				GdiPlusIgnoreAtom = new BooleanSwitch("GdiPlusIgnoreAtom", "Ignores the use of global atoms for startup/shutdown");
				atomName = null;
				hAtom = 0;
				Initialize();
			}

			private static bool EnsureAtomInitialized()
			{
				if (FindAtom(AtomName) != 0)
				{
					return true;
				}
				hAtom = AddAtom(AtomName);
				return false;
			}

			private static void DestroyAtom()
			{
				if (hAtom != 0)
				{
					DeleteAtom(hAtom);
				}
			}

			private static void Initialize()
			{
				if (!EnsureAtomInitialized())
				{
					string version = null;
					LoadLibraryShim("Gdiplus.dll", version, (IntPtr)0, out var _);
					StartupInput input = StartupInput.GetDefault();
					StartupOutput output;
					int num = GdiplusStartup(out initToken, ref input, out output);
					if (num != 0)
					{
						throw StatusException(num);
					}
				}
				AppDomain.CurrentDomain.ProcessExit += OnProcessExit;
			}

			private static void Shutdown()
			{
				DestroyAtom();
				if (!IsShutdown)
				{
					LocalDataStoreSlot namedDataSlot = Thread.GetNamedDataSlot("system.drawing.threaddata");
					Thread.SetData(namedDataSlot, null);
					GC.Collect();
					GC.WaitForPendingFinalizers();
					if (initToken != IntPtr.Zero)
					{
						GdiplusShutdown(new HandleRef(null, initToken));
					}
				}
			}

			[PrePrepareMethod]
			private static void OnProcessExit(object sender, EventArgs e)
			{
				Shutdown();
			}

			[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			private static extern int GetCurrentProcessId();

			[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			private static extern ushort AddAtom(string lpString);

			[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			private static extern ushort DeleteAtom(ushort hAtom);

			[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			private static extern ushort FindAtom(string lpString);

			[DllImport("mscoree.dll", CharSet = CharSet.Unicode, ExactSpelling = true)]
			private static extern int LoadLibraryShim(string dllName, string version, IntPtr reserved, out IntPtr dllModule);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			private static extern int GdiplusStartup(out IntPtr token, ref StartupInput input, out StartupOutput output);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			private static extern void GdiplusShutdown(HandleRef token);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreatePath(int brushMode, out IntPtr path);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreatePath2(HandleRef points, HandleRef types, int count, int brushMode, out IntPtr path);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreatePath2I(HandleRef points, HandleRef types, int count, int brushMode, out IntPtr path);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipClonePath(HandleRef path, out IntPtr clonepath);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, EntryPoint = "GdipDeletePath", ExactSpelling = true, SetLastError = true)]
			private static extern int IntGdipDeletePath(HandleRef path);

			internal static int GdipDeletePath(HandleRef path)
			{
				if (IsShutdown)
				{
					return 0;
				}
				return IntGdipDeletePath(path);
			}

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipResetPath(HandleRef path);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPointCount(HandleRef path, out int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPathTypes(HandleRef path, byte[] types, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPathPoints(HandleRef path, HandleRef points, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPathFillMode(HandleRef path, out int fillmode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPathFillMode(HandleRef path, int fillmode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPathData(HandleRef path, IntPtr pathData);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipStartPathFigure(HandleRef path);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipClosePathFigure(HandleRef path);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipClosePathFigures(HandleRef path);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPathMarker(HandleRef path);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipClearPathMarkers(HandleRef path);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipReversePath(HandleRef path);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPathLastPoint(HandleRef path, GPPOINTF lastPoint);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathLine(HandleRef path, float x1, float y1, float x2, float y2);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathLine2(HandleRef path, HandleRef memorypts, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathArc(HandleRef path, float x, float y, float width, float height, float startAngle, float sweepAngle);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathBezier(HandleRef path, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathBeziers(HandleRef path, HandleRef memorypts, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathCurve(HandleRef path, HandleRef memorypts, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathCurve2(HandleRef path, HandleRef memorypts, int count, float tension);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathCurve3(HandleRef path, HandleRef memorypts, int count, int offset, int numberOfSegments, float tension);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathClosedCurve(HandleRef path, HandleRef memorypts, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathClosedCurve2(HandleRef path, HandleRef memorypts, int count, float tension);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathRectangle(HandleRef path, float x, float y, float width, float height);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathRectangles(HandleRef path, HandleRef rects, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathEllipse(HandleRef path, float x, float y, float width, float height);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathPie(HandleRef path, float x, float y, float width, float height, float startAngle, float sweepAngle);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathPolygon(HandleRef path, HandleRef memorypts, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathPath(HandleRef path, HandleRef addingPath, bool connect);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathString(HandleRef path, string s, int length, HandleRef fontFamily, int style, float emSize, ref GPRECTF layoutRect, HandleRef format);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathStringI(HandleRef path, string s, int length, HandleRef fontFamily, int style, float emSize, ref GPRECT layoutRect, HandleRef format);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathLineI(HandleRef path, int x1, int y1, int x2, int y2);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathLine2I(HandleRef path, HandleRef memorypts, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathArcI(HandleRef path, int x, int y, int width, int height, float startAngle, float sweepAngle);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathBezierI(HandleRef path, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathBeziersI(HandleRef path, HandleRef memorypts, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathCurveI(HandleRef path, HandleRef memorypts, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathCurve2I(HandleRef path, HandleRef memorypts, int count, float tension);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathCurve3I(HandleRef path, HandleRef memorypts, int count, int offset, int numberOfSegments, float tension);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathClosedCurveI(HandleRef path, HandleRef memorypts, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathClosedCurve2I(HandleRef path, HandleRef memorypts, int count, float tension);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathRectangleI(HandleRef path, int x, int y, int width, int height);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathRectanglesI(HandleRef path, HandleRef rects, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathEllipseI(HandleRef path, int x, int y, int width, int height);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathPieI(HandleRef path, int x, int y, int width, int height, float startAngle, float sweepAngle);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathPolygonI(HandleRef path, HandleRef memorypts, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipFlattenPath(HandleRef path, HandleRef matrixfloat, float flatness);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipWidenPath(HandleRef path, HandleRef pen, HandleRef matrix, float flatness);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipWarpPath(HandleRef path, HandleRef matrix, HandleRef points, int count, float srcX, float srcY, float srcWidth, float srcHeight, WarpMode warpMode, float flatness);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipTransformPath(HandleRef path, HandleRef matrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPathWorldBounds(HandleRef path, ref GPRECTF gprectf, HandleRef matrix, HandleRef pen);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsVisiblePathPoint(HandleRef path, float x, float y, HandleRef graphics, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsVisiblePathPointI(HandleRef path, int x, int y, HandleRef graphics, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsOutlineVisiblePathPoint(HandleRef path, float x, float y, HandleRef pen, HandleRef graphics, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsOutlineVisiblePathPointI(HandleRef path, int x, int y, HandleRef pen, HandleRef graphics, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreatePathIter(out IntPtr pathIter, HandleRef path);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, EntryPoint = "GdipDeletePathIter", ExactSpelling = true, SetLastError = true)]
			private static extern int IntGdipDeletePathIter(HandleRef pathIter);

			internal static int GdipDeletePathIter(HandleRef pathIter)
			{
				if (IsShutdown)
				{
					return 0;
				}
				return IntGdipDeletePathIter(pathIter);
			}

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipPathIterNextSubpath(HandleRef pathIter, out int resultCount, out int startIndex, out int endIndex, out bool isClosed);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipPathIterNextSubpathPath(HandleRef pathIter, out int resultCount, HandleRef path, out bool isClosed);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipPathIterNextPathType(HandleRef pathIter, out int resultCount, out byte pathType, out int startIndex, out int endIndex);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipPathIterNextMarker(HandleRef pathIter, out int resultCount, out int startIndex, out int endIndex);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipPathIterNextMarkerPath(HandleRef pathIter, out int resultCount, HandleRef path);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipPathIterGetCount(HandleRef pathIter, out int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipPathIterGetSubpathCount(HandleRef pathIter, out int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipPathIterHasCurve(HandleRef pathIter, out bool hasCurve);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipPathIterRewind(HandleRef pathIter);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipPathIterEnumerate(HandleRef pathIter, out int resultCount, IntPtr memoryPts, [In][Out] byte[] types, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipPathIterCopyData(HandleRef pathIter, out int resultCount, IntPtr memoryPts, [In][Out] byte[] types, int startIndex, int endIndex);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateMatrix(out IntPtr matrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateMatrix2(float m11, float m12, float m21, float m22, float dx, float dy, out IntPtr matrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateMatrix3(ref GPRECTF rect, HandleRef dstplg, out IntPtr matrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateMatrix3I(ref GPRECT rect, HandleRef dstplg, out IntPtr matrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCloneMatrix(HandleRef matrix, out IntPtr cloneMatrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, EntryPoint = "GdipDeleteMatrix", ExactSpelling = true, SetLastError = true)]
			private static extern int IntGdipDeleteMatrix(HandleRef matrix);

			internal static int GdipDeleteMatrix(HandleRef matrix)
			{
				if (IsShutdown)
				{
					return 0;
				}
				return IntGdipDeleteMatrix(matrix);
			}

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetMatrixElements(HandleRef matrix, float m11, float m12, float m21, float m22, float dx, float dy);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipMultiplyMatrix(HandleRef matrix, HandleRef matrix2, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipTranslateMatrix(HandleRef matrix, float offsetX, float offsetY, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipScaleMatrix(HandleRef matrix, float scaleX, float scaleY, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipRotateMatrix(HandleRef matrix, float angle, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipShearMatrix(HandleRef matrix, float shearX, float shearY, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipInvertMatrix(HandleRef matrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipTransformMatrixPoints(HandleRef matrix, HandleRef pts, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipTransformMatrixPointsI(HandleRef matrix, HandleRef pts, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipVectorTransformMatrixPoints(HandleRef matrix, HandleRef pts, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipVectorTransformMatrixPointsI(HandleRef matrix, HandleRef pts, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetMatrixElements(HandleRef matrix, IntPtr m);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsMatrixInvertible(HandleRef matrix, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsMatrixIdentity(HandleRef matrix, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsMatrixEqual(HandleRef matrix, HandleRef matrix2, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateRegion(out IntPtr region);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateRegionRect(ref GPRECTF gprectf, out IntPtr region);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateRegionRectI(ref GPRECT gprect, out IntPtr region);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateRegionPath(HandleRef path, out IntPtr region);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateRegionRgnData(byte[] rgndata, int size, out IntPtr region);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateRegionHrgn(HandleRef hRgn, out IntPtr region);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCloneRegion(HandleRef region, out IntPtr cloneregion);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, EntryPoint = "GdipDeleteRegion", ExactSpelling = true, SetLastError = true)]
			private static extern int IntGdipDeleteRegion(HandleRef region);

			internal static int GdipDeleteRegion(HandleRef region)
			{
				if (IsShutdown)
				{
					return 0;
				}
				return IntGdipDeleteRegion(region);
			}

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetInfinite(HandleRef region);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetEmpty(HandleRef region);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCombineRegionRect(HandleRef region, ref GPRECTF gprectf, CombineMode mode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCombineRegionRectI(HandleRef region, ref GPRECT gprect, CombineMode mode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCombineRegionPath(HandleRef region, HandleRef path, CombineMode mode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCombineRegionRegion(HandleRef region, HandleRef region2, CombineMode mode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipTranslateRegion(HandleRef region, float dx, float dy);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipTranslateRegionI(HandleRef region, int dx, int dy);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipTransformRegion(HandleRef region, HandleRef matrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetRegionBounds(HandleRef region, HandleRef graphics, ref GPRECTF gprectf);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetRegionHRgn(HandleRef region, HandleRef graphics, out IntPtr hrgn);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsEmptyRegion(HandleRef region, HandleRef graphics, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsInfiniteRegion(HandleRef region, HandleRef graphics, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsEqualRegion(HandleRef region, HandleRef region2, HandleRef graphics, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetRegionDataSize(HandleRef region, out int bufferSize);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetRegionData(HandleRef region, byte[] regionData, int bufferSize, out int sizeFilled);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsVisibleRegionPoint(HandleRef region, float X, float Y, HandleRef graphics, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsVisibleRegionPointI(HandleRef region, int X, int Y, HandleRef graphics, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsVisibleRegionRect(HandleRef region, float X, float Y, float width, float height, HandleRef graphics, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsVisibleRegionRectI(HandleRef region, int X, int Y, int width, int height, HandleRef graphics, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetRegionScansCount(HandleRef region, out int count, HandleRef matrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetRegionScans(HandleRef region, IntPtr rects, out int count, HandleRef matrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCloneBrush(HandleRef brush, out IntPtr clonebrush);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, EntryPoint = "GdipDeleteBrush", ExactSpelling = true, SetLastError = true)]
			private static extern int IntGdipDeleteBrush(HandleRef brush);

			internal static int GdipDeleteBrush(HandleRef brush)
			{
				if (IsShutdown)
				{
					return 0;
				}
				return IntGdipDeleteBrush(brush);
			}

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateHatchBrush(int hatchstyle, int forecol, int backcol, out IntPtr brush);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetHatchStyle(HandleRef brush, out int hatchstyle);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetHatchForegroundColor(HandleRef brush, out int forecol);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetHatchBackgroundColor(HandleRef brush, out int backcol);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateTexture(HandleRef bitmap, int wrapmode, out IntPtr texture);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateTexture2(HandleRef bitmap, int wrapmode, float x, float y, float width, float height, out IntPtr texture);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateTextureIA(HandleRef bitmap, HandleRef imageAttrib, float x, float y, float width, float height, out IntPtr texture);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateTexture2I(HandleRef bitmap, int wrapmode, int x, int y, int width, int height, out IntPtr texture);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateTextureIAI(HandleRef bitmap, HandleRef imageAttrib, int x, int y, int width, int height, out IntPtr texture);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetTextureTransform(HandleRef brush, HandleRef matrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetTextureTransform(HandleRef brush, HandleRef matrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipResetTextureTransform(HandleRef brush);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipMultiplyTextureTransform(HandleRef brush, HandleRef matrix, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipTranslateTextureTransform(HandleRef brush, float dx, float dy, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipScaleTextureTransform(HandleRef brush, float sx, float sy, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipRotateTextureTransform(HandleRef brush, float angle, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetTextureWrapMode(HandleRef brush, int wrapMode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetTextureWrapMode(HandleRef brush, out int wrapMode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetTextureImage(HandleRef brush, out IntPtr image);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateSolidFill(int color, out IntPtr brush);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetSolidFillColor(HandleRef brush, int color);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetSolidFillColor(HandleRef brush, out int color);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateLineBrush(GPPOINTF point1, GPPOINTF point2, int color1, int color2, int wrapMode, out IntPtr lineGradient);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateLineBrushI(GPPOINT point1, GPPOINT point2, int color1, int color2, int wrapMode, out IntPtr lineGradient);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateLineBrushFromRect(ref GPRECTF rect, int color1, int color2, int lineGradientMode, int wrapMode, out IntPtr lineGradient);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateLineBrushFromRectI(ref GPRECT rect, int color1, int color2, int lineGradientMode, int wrapMode, out IntPtr lineGradient);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateLineBrushFromRectWithAngle(ref GPRECTF rect, int color1, int color2, float angle, bool isAngleScaleable, int wrapMode, out IntPtr lineGradient);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateLineBrushFromRectWithAngleI(ref GPRECT rect, int color1, int color2, float angle, bool isAngleScaleable, int wrapMode, out IntPtr lineGradient);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetLineColors(HandleRef brush, int color1, int color2);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetLineColors(HandleRef brush, int[] colors);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetLineRect(HandleRef brush, ref GPRECTF gprectf);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetLineGammaCorrection(HandleRef brush, out bool useGammaCorrection);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetLineGammaCorrection(HandleRef brush, bool useGammaCorrection);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetLineSigmaBlend(HandleRef brush, float focus, float scale);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetLineLinearBlend(HandleRef brush, float focus, float scale);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetLineBlendCount(HandleRef brush, out int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetLineBlend(HandleRef brush, IntPtr blend, IntPtr positions, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetLineBlend(HandleRef brush, HandleRef blend, HandleRef positions, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetLinePresetBlendCount(HandleRef brush, out int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetLinePresetBlend(HandleRef brush, IntPtr blend, IntPtr positions, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetLinePresetBlend(HandleRef brush, HandleRef blend, HandleRef positions, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetLineWrapMode(HandleRef brush, int wrapMode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetLineWrapMode(HandleRef brush, out int wrapMode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipResetLineTransform(HandleRef brush);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipMultiplyLineTransform(HandleRef brush, HandleRef matrix, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetLineTransform(HandleRef brush, HandleRef matrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetLineTransform(HandleRef brush, HandleRef matrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipTranslateLineTransform(HandleRef brush, float dx, float dy, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipScaleLineTransform(HandleRef brush, float sx, float sy, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipRotateLineTransform(HandleRef brush, float angle, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreatePathGradient(HandleRef points, int count, int wrapMode, out IntPtr brush);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreatePathGradientI(HandleRef points, int count, int wrapMode, out IntPtr brush);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreatePathGradientFromPath(HandleRef path, out IntPtr brush);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPathGradientCenterColor(HandleRef brush, out int color);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPathGradientCenterColor(HandleRef brush, int color);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPathGradientSurroundColorsWithCount(HandleRef brush, int[] color, ref int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPathGradientSurroundColorsWithCount(HandleRef brush, int[] argb, ref int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPathGradientCenterPoint(HandleRef brush, GPPOINTF point);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPathGradientCenterPoint(HandleRef brush, GPPOINTF point);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPathGradientRect(HandleRef brush, ref GPRECTF gprectf);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPathGradientPointCount(HandleRef brush, out int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPathGradientSurroundColorCount(HandleRef brush, out int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPathGradientBlendCount(HandleRef brush, out int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPathGradientBlend(HandleRef brush, IntPtr blend, IntPtr positions, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPathGradientBlend(HandleRef brush, HandleRef blend, HandleRef positions, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPathGradientPresetBlendCount(HandleRef brush, out int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPathGradientPresetBlend(HandleRef brush, IntPtr blend, IntPtr positions, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPathGradientPresetBlend(HandleRef brush, HandleRef blend, HandleRef positions, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPathGradientSigmaBlend(HandleRef brush, float focus, float scale);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPathGradientLinearBlend(HandleRef brush, float focus, float scale);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPathGradientWrapMode(HandleRef brush, int wrapmode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPathGradientWrapMode(HandleRef brush, out int wrapmode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPathGradientTransform(HandleRef brush, HandleRef matrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPathGradientTransform(HandleRef brush, HandleRef matrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipResetPathGradientTransform(HandleRef brush);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipMultiplyPathGradientTransform(HandleRef brush, HandleRef matrix, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipTranslatePathGradientTransform(HandleRef brush, float dx, float dy, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipScalePathGradientTransform(HandleRef brush, float sx, float sy, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipRotatePathGradientTransform(HandleRef brush, float angle, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPathGradientFocusScales(HandleRef brush, float[] xScale, float[] yScale);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPathGradientFocusScales(HandleRef brush, float xScale, float yScale);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreatePen1(int argb, float width, int unit, out IntPtr pen);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreatePen2(HandleRef brush, float width, int unit, out IntPtr pen);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipClonePen(HandleRef pen, out IntPtr clonepen);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, EntryPoint = "GdipDeletePen", ExactSpelling = true, SetLastError = true)]
			private static extern int IntGdipDeletePen(HandleRef Pen);

			internal static int GdipDeletePen(HandleRef pen)
			{
				if (IsShutdown)
				{
					return 0;
				}
				return IntGdipDeletePen(pen);
			}

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPenMode(HandleRef pen, PenAlignment penAlign);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPenMode(HandleRef pen, out PenAlignment penAlign);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPenWidth(HandleRef pen, float width);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPenWidth(HandleRef pen, float[] width);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPenLineCap197819(HandleRef pen, int startCap, int endCap, int dashCap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPenStartCap(HandleRef pen, int startCap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPenEndCap(HandleRef pen, int endCap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPenStartCap(HandleRef pen, out int startCap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPenEndCap(HandleRef pen, out int endCap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPenDashCap197819(HandleRef pen, out int dashCap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPenDashCap197819(HandleRef pen, int dashCap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPenLineJoin(HandleRef pen, int lineJoin);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPenLineJoin(HandleRef pen, out int lineJoin);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPenCustomStartCap(HandleRef pen, HandleRef customCap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPenCustomStartCap(HandleRef pen, out IntPtr customCap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPenCustomEndCap(HandleRef pen, HandleRef customCap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPenCustomEndCap(HandleRef pen, out IntPtr customCap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPenMiterLimit(HandleRef pen, float miterLimit);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPenMiterLimit(HandleRef pen, float[] miterLimit);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPenTransform(HandleRef pen, HandleRef matrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPenTransform(HandleRef pen, HandleRef matrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipResetPenTransform(HandleRef brush);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipMultiplyPenTransform(HandleRef brush, HandleRef matrix, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipTranslatePenTransform(HandleRef brush, float dx, float dy, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipScalePenTransform(HandleRef brush, float sx, float sy, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipRotatePenTransform(HandleRef brush, float angle, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPenColor(HandleRef pen, int argb);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPenColor(HandleRef pen, out int argb);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPenBrushFill(HandleRef pen, HandleRef brush);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPenBrushFill(HandleRef pen, out IntPtr brush);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPenFillType(HandleRef pen, out int pentype);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPenDashStyle(HandleRef pen, out int dashstyle);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPenDashStyle(HandleRef pen, int dashstyle);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPenDashArray(HandleRef pen, HandleRef memorydash, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPenDashOffset(HandleRef pen, float[] dashoffset);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPenDashOffset(HandleRef pen, float dashoffset);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPenDashCount(HandleRef pen, out int dashcount);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPenDashArray(HandleRef pen, IntPtr memorydash, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPenCompoundCount(HandleRef pen, out int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPenCompoundArray(HandleRef pen, float[] array, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPenCompoundArray(HandleRef pen, float[] array, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateCustomLineCap(HandleRef fillpath, HandleRef strokepath, LineCap baseCap, float baseInset, out IntPtr customCap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, EntryPoint = "GdipDeleteCustomLineCap", ExactSpelling = true, SetLastError = true)]
			private static extern int IntGdipDeleteCustomLineCap(HandleRef customCap);

			internal static int GdipDeleteCustomLineCap(HandleRef customCap)
			{
				if (IsShutdown)
				{
					return 0;
				}
				return IntGdipDeleteCustomLineCap(customCap);
			}

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCloneCustomLineCap(HandleRef customCap, out IntPtr clonedCap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetCustomLineCapType(HandleRef customCap, out CustomLineCapType capType);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetCustomLineCapStrokeCaps(HandleRef customCap, LineCap startCap, LineCap endCap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetCustomLineCapStrokeCaps(HandleRef customCap, out LineCap startCap, out LineCap endCap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetCustomLineCapStrokeJoin(HandleRef customCap, LineJoin lineJoin);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetCustomLineCapStrokeJoin(HandleRef customCap, out LineJoin lineJoin);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetCustomLineCapBaseCap(HandleRef customCap, LineCap baseCap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetCustomLineCapBaseCap(HandleRef customCap, out LineCap baseCap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetCustomLineCapBaseInset(HandleRef customCap, float inset);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetCustomLineCapBaseInset(HandleRef customCap, out float inset);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetCustomLineCapWidthScale(HandleRef customCap, float widthScale);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetCustomLineCapWidthScale(HandleRef customCap, out float widthScale);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateAdjustableArrowCap(float height, float width, bool isFilled, out IntPtr adjustableArrowCap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetAdjustableArrowCapHeight(HandleRef adjustableArrowCap, float height);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetAdjustableArrowCapHeight(HandleRef adjustableArrowCap, out float height);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetAdjustableArrowCapWidth(HandleRef adjustableArrowCap, float width);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetAdjustableArrowCapWidth(HandleRef adjustableArrowCap, out float width);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetAdjustableArrowCapMiddleInset(HandleRef adjustableArrowCap, float middleInset);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetAdjustableArrowCapMiddleInset(HandleRef adjustableArrowCap, out float middleInset);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetAdjustableArrowCapFillState(HandleRef adjustableArrowCap, bool fillState);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetAdjustableArrowCapFillState(HandleRef adjustableArrowCap, out bool fillState);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipLoadImageFromStream(UnsafeNativeMethods.IStream stream, out IntPtr image);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipLoadImageFromFile(string filename, out IntPtr image);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipLoadImageFromStreamICM(UnsafeNativeMethods.IStream stream, out IntPtr image);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipLoadImageFromFileICM(string filename, out IntPtr image);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCloneImage(HandleRef image, out IntPtr cloneimage);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, EntryPoint = "GdipDisposeImage", ExactSpelling = true, SetLastError = true)]
			private static extern int IntGdipDisposeImage(HandleRef image);

			internal static int GdipDisposeImage(HandleRef image)
			{
				if (IsShutdown)
				{
					return 0;
				}
				return IntGdipDisposeImage(image);
			}

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSaveImageToFile(HandleRef image, string filename, ref Guid classId, HandleRef encoderParams);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSaveImageToStream(HandleRef image, UnsafeNativeMethods.IStream stream, ref Guid classId, HandleRef encoderParams);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSaveAdd(HandleRef image, HandleRef encoderParams);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSaveAddImage(HandleRef image, HandleRef newImage, HandleRef encoderParams);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetImageGraphicsContext(HandleRef image, out IntPtr graphics);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetImageBounds(HandleRef image, ref GPRECTF gprectf, out GraphicsUnit unit);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetImageDimension(HandleRef image, out float width, out float height);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetImageType(HandleRef image, out int type);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetImageWidth(HandleRef image, out int width);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetImageHeight(HandleRef image, out int height);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetImageHorizontalResolution(HandleRef image, out float horzRes);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetImageVerticalResolution(HandleRef image, out float vertRes);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetImageFlags(HandleRef image, out int flags);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetImageRawFormat(HandleRef image, ref Guid format);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetImagePixelFormat(HandleRef image, out int format);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetImageThumbnail(HandleRef image, int thumbWidth, int thumbHeight, out IntPtr thumbImage, Image.GetThumbnailImageAbort callback, IntPtr callbackdata);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetEncoderParameterListSize(HandleRef image, ref Guid clsid, out int size);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetEncoderParameterList(HandleRef image, ref Guid clsid, int size, IntPtr buffer);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipImageGetFrameDimensionsCount(HandleRef image, out int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipImageGetFrameDimensionsList(HandleRef image, IntPtr buffer, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipImageGetFrameCount(HandleRef image, ref Guid dimensionID, int[] count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipImageSelectActiveFrame(HandleRef image, ref Guid dimensionID, int frameIndex);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipImageRotateFlip(HandleRef image, int rotateFlipType);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetImagePalette(HandleRef image, IntPtr palette, int size);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetImagePalette(HandleRef image, IntPtr palette);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetImagePaletteSize(HandleRef image, out int size);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPropertyCount(HandleRef image, out int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPropertyIdList(HandleRef image, int count, int[] list);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPropertyItemSize(HandleRef image, int propid, out int size);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPropertyItem(HandleRef image, int propid, int size, IntPtr buffer);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPropertySize(HandleRef image, out int totalSize, ref int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetAllPropertyItems(HandleRef image, int totalSize, int count, IntPtr buffer);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipRemovePropertyItem(HandleRef image, int propid);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPropertyItem(HandleRef image, PropertyItemInternal propitem);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipImageForceValidation(HandleRef image);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetImageDecodersSize(out int numDecoders, out int size);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetImageDecoders(int numDecoders, int size, IntPtr decoders);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetImageEncodersSize(out int numEncoders, out int size);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetImageEncoders(int numEncoders, int size, IntPtr encoders);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateBitmapFromStream(UnsafeNativeMethods.IStream stream, out IntPtr bitmap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateBitmapFromFile(string filename, out IntPtr bitmap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateBitmapFromStreamICM(UnsafeNativeMethods.IStream stream, out IntPtr bitmap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateBitmapFromFileICM(string filename, out IntPtr bitmap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateBitmapFromScan0(int width, int height, int stride, int format, HandleRef scan0, out IntPtr bitmap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateBitmapFromGraphics(int width, int height, HandleRef graphics, out IntPtr bitmap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateBitmapFromHBITMAP(HandleRef hbitmap, HandleRef hpalette, out IntPtr bitmap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateBitmapFromHICON(HandleRef hicon, out IntPtr bitmap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateBitmapFromResource(HandleRef hresource, HandleRef name, out IntPtr bitmap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateHBITMAPFromBitmap(HandleRef nativeBitmap, out IntPtr hbitmap, int argbBackground);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateHICONFromBitmap(HandleRef nativeBitmap, out IntPtr hicon);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCloneBitmapArea(float x, float y, float width, float height, int format, HandleRef srcbitmap, out IntPtr dstbitmap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCloneBitmapAreaI(int x, int y, int width, int height, int format, HandleRef srcbitmap, out IntPtr dstbitmap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipBitmapLockBits(HandleRef bitmap, ref GPRECT rect, ImageLockMode flags, PixelFormat format, [In][Out] BitmapData lockedBitmapData);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipBitmapUnlockBits(HandleRef bitmap, BitmapData lockedBitmapData);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipBitmapGetPixel(HandleRef bitmap, int x, int y, out int argb);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipBitmapSetPixel(HandleRef bitmap, int x, int y, int argb);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipBitmapSetResolution(HandleRef bitmap, float dpix, float dpiy);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateImageAttributes(out IntPtr imageattr);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCloneImageAttributes(HandleRef imageattr, out IntPtr cloneImageattr);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, EntryPoint = "GdipDisposeImageAttributes", ExactSpelling = true, SetLastError = true)]
			private static extern int IntGdipDisposeImageAttributes(HandleRef imageattr);

			internal static int GdipDisposeImageAttributes(HandleRef imageattr)
			{
				if (IsShutdown)
				{
					return 0;
				}
				return IntGdipDisposeImageAttributes(imageattr);
			}

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetImageAttributesColorMatrix(HandleRef imageattr, ColorAdjustType type, bool enableFlag, ColorMatrix colorMatrix, ColorMatrix grayMatrix, ColorMatrixFlag flags);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetImageAttributesThreshold(HandleRef imageattr, ColorAdjustType type, bool enableFlag, float threshold);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetImageAttributesGamma(HandleRef imageattr, ColorAdjustType type, bool enableFlag, float gamma);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetImageAttributesNoOp(HandleRef imageattr, ColorAdjustType type, bool enableFlag);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetImageAttributesColorKeys(HandleRef imageattr, ColorAdjustType type, bool enableFlag, int colorLow, int colorHigh);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetImageAttributesOutputChannel(HandleRef imageattr, ColorAdjustType type, bool enableFlag, ColorChannelFlag flags);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetImageAttributesOutputChannelColorProfile(HandleRef imageattr, ColorAdjustType type, bool enableFlag, string colorProfileFilename);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetImageAttributesRemapTable(HandleRef imageattr, ColorAdjustType type, bool enableFlag, int mapSize, HandleRef map);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetImageAttributesWrapMode(HandleRef imageattr, int wrapmode, int argb, bool clamp);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetImageAttributesAdjustedPalette(HandleRef imageattr, HandleRef palette, ColorAdjustType type);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipFlush(HandleRef graphics, FlushIntention intention);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateFromHDC(HandleRef hdc, out IntPtr graphics);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateFromHDC2(HandleRef hdc, HandleRef hdevice, out IntPtr graphics);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateFromHWND(HandleRef hwnd, out IntPtr graphics);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, EntryPoint = "GdipDeleteGraphics", ExactSpelling = true, SetLastError = true)]
			private static extern int IntGdipDeleteGraphics(HandleRef graphics);

			internal static int GdipDeleteGraphics(HandleRef graphics)
			{
				if (IsShutdown)
				{
					return 0;
				}
				return IntGdipDeleteGraphics(graphics);
			}

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetDC(HandleRef graphics, out IntPtr hdc);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, EntryPoint = "GdipReleaseDC", ExactSpelling = true, SetLastError = true)]
			private static extern int IntGdipReleaseDC(HandleRef graphics, HandleRef hdc);

			internal static int GdipReleaseDC(HandleRef graphics, HandleRef hdc)
			{
				if (IsShutdown)
				{
					return 0;
				}
				return IntGdipReleaseDC(graphics, hdc);
			}

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetCompositingMode(HandleRef graphics, int compositeMode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetTextRenderingHint(HandleRef graphics, TextRenderingHint textRenderingHint);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetTextContrast(HandleRef graphics, int textContrast);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetInterpolationMode(HandleRef graphics, int mode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetCompositingMode(HandleRef graphics, out int compositeMode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetRenderingOrigin(HandleRef graphics, int x, int y);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetRenderingOrigin(HandleRef graphics, out int x, out int y);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetCompositingQuality(HandleRef graphics, CompositingQuality quality);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetCompositingQuality(HandleRef graphics, out CompositingQuality quality);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetSmoothingMode(HandleRef graphics, SmoothingMode smoothingMode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetSmoothingMode(HandleRef graphics, out SmoothingMode smoothingMode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPixelOffsetMode(HandleRef graphics, PixelOffsetMode pixelOffsetMode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPixelOffsetMode(HandleRef graphics, out PixelOffsetMode pixelOffsetMode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetTextRenderingHint(HandleRef graphics, out TextRenderingHint textRenderingHint);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetTextContrast(HandleRef graphics, out int textContrast);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetInterpolationMode(HandleRef graphics, out int mode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetWorldTransform(HandleRef graphics, HandleRef matrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipResetWorldTransform(HandleRef graphics);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipMultiplyWorldTransform(HandleRef graphics, HandleRef matrix, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipTranslateWorldTransform(HandleRef graphics, float dx, float dy, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipScaleWorldTransform(HandleRef graphics, float sx, float sy, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipRotateWorldTransform(HandleRef graphics, float angle, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetWorldTransform(HandleRef graphics, HandleRef matrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPageUnit(HandleRef graphics, out int unit);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPageScale(HandleRef graphics, float[] scale);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPageUnit(HandleRef graphics, int unit);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPageScale(HandleRef graphics, float scale);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetDpiX(HandleRef graphics, float[] dpi);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetDpiY(HandleRef graphics, float[] dpi);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipTransformPoints(HandleRef graphics, int destSpace, int srcSpace, IntPtr points, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipTransformPointsI(HandleRef graphics, int destSpace, int srcSpace, IntPtr points, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetNearestColor(HandleRef graphics, ref int color);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern IntPtr GdipCreateHalftonePalette();

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawLine(HandleRef graphics, HandleRef pen, float x1, float y1, float x2, float y2);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawLineI(HandleRef graphics, HandleRef pen, int x1, int y1, int x2, int y2);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawLines(HandleRef graphics, HandleRef pen, HandleRef points, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawLinesI(HandleRef graphics, HandleRef pen, HandleRef points, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawArc(HandleRef graphics, HandleRef pen, float x, float y, float width, float height, float startAngle, float sweepAngle);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawArcI(HandleRef graphics, HandleRef pen, int x, int y, int width, int height, float startAngle, float sweepAngle);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawBezier(HandleRef graphics, HandleRef pen, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawBeziers(HandleRef graphics, HandleRef pen, HandleRef points, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawBeziersI(HandleRef graphics, HandleRef pen, HandleRef points, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawRectangle(HandleRef graphics, HandleRef pen, float x, float y, float width, float height);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawRectangleI(HandleRef graphics, HandleRef pen, int x, int y, int width, int height);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawRectangles(HandleRef graphics, HandleRef pen, HandleRef rects, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawRectanglesI(HandleRef graphics, HandleRef pen, HandleRef rects, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawEllipse(HandleRef graphics, HandleRef pen, float x, float y, float width, float height);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawEllipseI(HandleRef graphics, HandleRef pen, int x, int y, int width, int height);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawPie(HandleRef graphics, HandleRef pen, float x, float y, float width, float height, float startAngle, float sweepAngle);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawPieI(HandleRef graphics, HandleRef pen, int x, int y, int width, int height, float startAngle, float sweepAngle);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawPolygon(HandleRef graphics, HandleRef pen, HandleRef points, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawPolygonI(HandleRef graphics, HandleRef pen, HandleRef points, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawPath(HandleRef graphics, HandleRef pen, HandleRef path);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawCurve(HandleRef graphics, HandleRef pen, HandleRef points, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawCurveI(HandleRef graphics, HandleRef pen, HandleRef points, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawCurve2(HandleRef graphics, HandleRef pen, HandleRef points, int count, float tension);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawCurve2I(HandleRef graphics, HandleRef pen, HandleRef points, int count, float tension);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawCurve3(HandleRef graphics, HandleRef pen, HandleRef points, int count, int offset, int numberOfSegments, float tension);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawCurve3I(HandleRef graphics, HandleRef pen, HandleRef points, int count, int offset, int numberOfSegments, float tension);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawClosedCurve(HandleRef graphics, HandleRef pen, HandleRef points, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawClosedCurveI(HandleRef graphics, HandleRef pen, HandleRef points, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawClosedCurve2(HandleRef graphics, HandleRef pen, HandleRef points, int count, float tension);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawClosedCurve2I(HandleRef graphics, HandleRef pen, HandleRef points, int count, float tension);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGraphicsClear(HandleRef graphics, int argb);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipFillRectangle(HandleRef graphics, HandleRef brush, float x, float y, float width, float height);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipFillRectangleI(HandleRef graphics, HandleRef brush, int x, int y, int width, int height);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipFillRectangles(HandleRef graphics, HandleRef brush, HandleRef rects, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipFillRectanglesI(HandleRef graphics, HandleRef brush, HandleRef rects, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipFillPolygon(HandleRef graphics, HandleRef brush, HandleRef points, int count, int brushMode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipFillPolygonI(HandleRef graphics, HandleRef brush, HandleRef points, int count, int brushMode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipFillEllipse(HandleRef graphics, HandleRef brush, float x, float y, float width, float height);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipFillEllipseI(HandleRef graphics, HandleRef brush, int x, int y, int width, int height);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipFillPie(HandleRef graphics, HandleRef brush, float x, float y, float width, float height, float startAngle, float sweepAngle);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipFillPieI(HandleRef graphics, HandleRef brush, int x, int y, int width, int height, float startAngle, float sweepAngle);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipFillPath(HandleRef graphics, HandleRef brush, HandleRef path);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipFillClosedCurve(HandleRef graphics, HandleRef brush, HandleRef points, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipFillClosedCurveI(HandleRef graphics, HandleRef brush, HandleRef points, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipFillClosedCurve2(HandleRef graphics, HandleRef brush, HandleRef points, int count, float tension, int mode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipFillClosedCurve2I(HandleRef graphics, HandleRef brush, HandleRef points, int count, float tension, int mode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipFillRegion(HandleRef graphics, HandleRef brush, HandleRef region);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawImage(HandleRef graphics, HandleRef image, float x, float y);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawImageI(HandleRef graphics, HandleRef image, int x, int y);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawImageRect(HandleRef graphics, HandleRef image, float x, float y, float width, float height);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawImageRectI(HandleRef graphics, HandleRef image, int x, int y, int width, int height);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawImagePoints(HandleRef graphics, HandleRef image, HandleRef points, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawImagePointsI(HandleRef graphics, HandleRef image, HandleRef points, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawImagePointRect(HandleRef graphics, HandleRef image, float x, float y, float srcx, float srcy, float srcwidth, float srcheight, int srcunit);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawImagePointRectI(HandleRef graphics, HandleRef image, int x, int y, int srcx, int srcy, int srcwidth, int srcheight, int srcunit);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawImageRectRect(HandleRef graphics, HandleRef image, float dstx, float dsty, float dstwidth, float dstheight, float srcx, float srcy, float srcwidth, float srcheight, int srcunit, HandleRef imageAttributes, Graphics.DrawImageAbort callback, HandleRef callbackdata);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawImageRectRectI(HandleRef graphics, HandleRef image, int dstx, int dsty, int dstwidth, int dstheight, int srcx, int srcy, int srcwidth, int srcheight, int srcunit, HandleRef imageAttributes, Graphics.DrawImageAbort callback, HandleRef callbackdata);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawImagePointsRect(HandleRef graphics, HandleRef image, HandleRef points, int count, float srcx, float srcy, float srcwidth, float srcheight, int srcunit, HandleRef imageAttributes, Graphics.DrawImageAbort callback, HandleRef callbackdata);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawImagePointsRectI(HandleRef graphics, HandleRef image, HandleRef points, int count, int srcx, int srcy, int srcwidth, int srcheight, int srcunit, HandleRef imageAttributes, Graphics.DrawImageAbort callback, HandleRef callbackdata);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipEnumerateMetafileDestPoint(HandleRef graphics, HandleRef metafile, GPPOINTF destPoint, Graphics.EnumerateMetafileProc callback, HandleRef callbackdata, HandleRef imageattributes);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipEnumerateMetafileDestPointI(HandleRef graphics, HandleRef metafile, GPPOINT destPoint, Graphics.EnumerateMetafileProc callback, HandleRef callbackdata, HandleRef imageattributes);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipEnumerateMetafileDestRect(HandleRef graphics, HandleRef metafile, ref GPRECTF destRect, Graphics.EnumerateMetafileProc callback, HandleRef callbackdata, HandleRef imageattributes);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipEnumerateMetafileDestRectI(HandleRef graphics, HandleRef metafile, ref GPRECT destRect, Graphics.EnumerateMetafileProc callback, HandleRef callbackdata, HandleRef imageattributes);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipEnumerateMetafileDestPoints(HandleRef graphics, HandleRef metafile, IntPtr destPoints, int count, Graphics.EnumerateMetafileProc callback, HandleRef callbackdata, HandleRef imageattributes);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipEnumerateMetafileDestPointsI(HandleRef graphics, HandleRef metafile, IntPtr destPoints, int count, Graphics.EnumerateMetafileProc callback, HandleRef callbackdata, HandleRef imageattributes);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipEnumerateMetafileSrcRectDestPoint(HandleRef graphics, HandleRef metafile, GPPOINTF destPoint, ref GPRECTF srcRect, int pageUnit, Graphics.EnumerateMetafileProc callback, HandleRef callbackdata, HandleRef imageattributes);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipEnumerateMetafileSrcRectDestPointI(HandleRef graphics, HandleRef metafile, GPPOINT destPoint, ref GPRECT srcRect, int pageUnit, Graphics.EnumerateMetafileProc callback, HandleRef callbackdata, HandleRef imageattributes);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipEnumerateMetafileSrcRectDestRect(HandleRef graphics, HandleRef metafile, ref GPRECTF destRect, ref GPRECTF srcRect, int pageUnit, Graphics.EnumerateMetafileProc callback, HandleRef callbackdata, HandleRef imageattributes);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipEnumerateMetafileSrcRectDestRectI(HandleRef graphics, HandleRef metafile, ref GPRECT destRect, ref GPRECT srcRect, int pageUnit, Graphics.EnumerateMetafileProc callback, HandleRef callbackdata, HandleRef imageattributes);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipEnumerateMetafileSrcRectDestPoints(HandleRef graphics, HandleRef metafile, IntPtr destPoints, int count, ref GPRECTF srcRect, int pageUnit, Graphics.EnumerateMetafileProc callback, HandleRef callbackdata, HandleRef imageattributes);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipEnumerateMetafileSrcRectDestPointsI(HandleRef graphics, HandleRef metafile, IntPtr destPoints, int count, ref GPRECT srcRect, int pageUnit, Graphics.EnumerateMetafileProc callback, HandleRef callbackdata, HandleRef imageattributes);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipPlayMetafileRecord(HandleRef graphics, EmfPlusRecordType recordType, int flags, int dataSize, byte[] data);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetClipGraphics(HandleRef graphics, HandleRef srcgraphics, CombineMode mode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetClipRect(HandleRef graphics, float x, float y, float width, float height, CombineMode mode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetClipRectI(HandleRef graphics, int x, int y, int width, int height, CombineMode mode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetClipPath(HandleRef graphics, HandleRef path, CombineMode mode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetClipRegion(HandleRef graphics, HandleRef region, CombineMode mode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipResetClip(HandleRef graphics);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipTranslateClip(HandleRef graphics, float dx, float dy);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetClip(HandleRef graphics, HandleRef region);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetClipBounds(HandleRef graphics, ref GPRECTF rect);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsClipEmpty(HandleRef graphics, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetVisibleClipBounds(HandleRef graphics, ref GPRECTF rect);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsVisibleClipEmpty(HandleRef graphics, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsVisiblePoint(HandleRef graphics, float x, float y, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsVisiblePointI(HandleRef graphics, int x, int y, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsVisibleRect(HandleRef graphics, float x, float y, float width, float height, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsVisibleRectI(HandleRef graphics, int x, int y, int width, int height, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSaveGraphics(HandleRef graphics, out int state);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipRestoreGraphics(HandleRef graphics, int state);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipBeginContainer(HandleRef graphics, ref GPRECTF dstRect, ref GPRECTF srcRect, int unit, out int state);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipBeginContainer2(HandleRef graphics, out int state);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipBeginContainerI(HandleRef graphics, ref GPRECT dstRect, ref GPRECT srcRect, int unit, out int state);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipEndContainer(HandleRef graphics, int state);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetMetafileHeaderFromWmf(HandleRef hMetafile, WmfPlaceableFileHeader wmfplaceable, [In][Out] MetafileHeaderWmf metafileHeaderWmf);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetMetafileHeaderFromEmf(HandleRef hEnhMetafile, [In][Out] MetafileHeaderEmf metafileHeaderEmf);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetMetafileHeaderFromFile(string filename, IntPtr header);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetMetafileHeaderFromStream(UnsafeNativeMethods.IStream stream, IntPtr header);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetMetafileHeaderFromMetafile(HandleRef metafile, IntPtr header);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetHemfFromMetafile(HandleRef metafile, out IntPtr hEnhMetafile);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateMetafileFromWmf(HandleRef hMetafile, WmfPlaceableFileHeader wmfplacealbeHeader, bool deleteWmf, out IntPtr metafile);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateMetafileFromEmf(HandleRef hEnhMetafile, bool deleteEmf, out IntPtr metafile);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateMetafileFromFile(string file, out IntPtr metafile);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateMetafileFromStream(UnsafeNativeMethods.IStream stream, out IntPtr metafile);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipRecordMetafile(HandleRef referenceHdc, int emfType, ref GPRECTF frameRect, int frameUnit, string description, out IntPtr metafile);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipRecordMetafile(HandleRef referenceHdc, int emfType, HandleRef pframeRect, int frameUnit, string description, out IntPtr metafile);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipRecordMetafileI(HandleRef referenceHdc, int emfType, ref GPRECT frameRect, int frameUnit, string description, out IntPtr metafile);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipRecordMetafileFileName(string fileName, HandleRef referenceHdc, int emfType, ref GPRECTF frameRect, int frameUnit, string description, out IntPtr metafile);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipRecordMetafileFileName(string fileName, HandleRef referenceHdc, int emfType, HandleRef pframeRect, int frameUnit, string description, out IntPtr metafile);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipRecordMetafileFileNameI(string fileName, HandleRef referenceHdc, int emfType, ref GPRECT frameRect, int frameUnit, string description, out IntPtr metafile);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipRecordMetafileStream(UnsafeNativeMethods.IStream stream, HandleRef referenceHdc, int emfType, ref GPRECTF frameRect, int frameUnit, string description, out IntPtr metafile);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipRecordMetafileStream(UnsafeNativeMethods.IStream stream, HandleRef referenceHdc, int emfType, HandleRef pframeRect, int frameUnit, string description, out IntPtr metafile);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipRecordMetafileStreamI(UnsafeNativeMethods.IStream stream, HandleRef referenceHdc, int emfType, ref GPRECT frameRect, int frameUnit, string description, out IntPtr metafile);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipComment(HandleRef graphics, int sizeData, byte[] data);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipNewInstalledFontCollection(out IntPtr fontCollection);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipNewPrivateFontCollection(out IntPtr fontCollection);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, EntryPoint = "GdipDeletePrivateFontCollection", ExactSpelling = true, SetLastError = true)]
			private static extern int IntGdipDeletePrivateFontCollection(out IntPtr fontCollection);

			internal static int GdipDeletePrivateFontCollection(out IntPtr fontCollection)
			{
				if (IsShutdown)
				{
					fontCollection = IntPtr.Zero;
					return 0;
				}
				return IntGdipDeletePrivateFontCollection(out fontCollection);
			}

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetFontCollectionFamilyCount(HandleRef fontCollection, out int numFound);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetFontCollectionFamilyList(HandleRef fontCollection, int numSought, IntPtr[] gpfamilies, out int numFound);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipPrivateAddFontFile(HandleRef fontCollection, string filename);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipPrivateAddMemoryFont(HandleRef fontCollection, HandleRef memory, int length);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateFontFamilyFromName(string name, HandleRef fontCollection, out IntPtr FontFamily);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetGenericFontFamilySansSerif(out IntPtr fontfamily);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetGenericFontFamilySerif(out IntPtr fontfamily);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetGenericFontFamilyMonospace(out IntPtr fontfamily);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, EntryPoint = "GdipDeleteFontFamily", ExactSpelling = true, SetLastError = true)]
			private static extern int IntGdipDeleteFontFamily(HandleRef fontFamily);

			internal static int GdipDeleteFontFamily(HandleRef fontFamily)
			{
				if (IsShutdown)
				{
					return 0;
				}
				return IntGdipDeleteFontFamily(fontFamily);
			}

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCloneFontFamily(HandleRef fontfamily, out IntPtr clonefontfamily);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetFamilyName(HandleRef family, StringBuilder name, int language);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsStyleAvailable(HandleRef family, FontStyle style, out int isStyleAvailable);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetEmHeight(HandleRef family, FontStyle style, out int EmHeight);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetCellAscent(HandleRef family, FontStyle style, out int CellAscent);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetCellDescent(HandleRef family, FontStyle style, out int CellDescent);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetLineSpacing(HandleRef family, FontStyle style, out int LineSpaceing);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateFontFromDC(HandleRef hdc, ref IntPtr font);

			[DllImport("gdiplus.dll", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateFontFromLogfontA(HandleRef hdc, [In][Out][MarshalAs(UnmanagedType.AsAny)] object lf, out IntPtr font);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateFontFromLogfontW(HandleRef hdc, [In][Out][MarshalAs(UnmanagedType.AsAny)] object lf, out IntPtr font);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateFont(HandleRef fontFamily, float emSize, FontStyle style, GraphicsUnit unit, out IntPtr font);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetLogFontW(HandleRef font, HandleRef graphics, [In][Out][MarshalAs(UnmanagedType.AsAny)] object lf);

			[DllImport("gdiplus.dll", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetLogFontA(HandleRef font, HandleRef graphics, [In][Out][MarshalAs(UnmanagedType.AsAny)] object lf);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCloneFont(HandleRef font, out IntPtr cloneFont);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, EntryPoint = "GdipDeleteFont", ExactSpelling = true, SetLastError = true)]
			private static extern int IntGdipDeleteFont(HandleRef font);

			internal static int GdipDeleteFont(HandleRef font)
			{
				if (IsShutdown)
				{
					return 0;
				}
				return IntGdipDeleteFont(font);
			}

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetFamily(HandleRef font, out IntPtr family);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetFontStyle(HandleRef font, out FontStyle style);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetFontSize(HandleRef font, out float size);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetFontHeight(HandleRef font, HandleRef graphics, out float size);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetFontHeightGivenDPI(HandleRef font, float dpi, out float size);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetFontUnit(HandleRef font, out GraphicsUnit unit);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawString(HandleRef graphics, string textString, int length, HandleRef font, ref GPRECTF layoutRect, HandleRef stringFormat, HandleRef brush);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipMeasureString(HandleRef graphics, string textString, int length, HandleRef font, ref GPRECTF layoutRect, HandleRef stringFormat, [In][Out] ref GPRECTF boundingBox, out int codepointsFitted, out int linesFilled);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipMeasureCharacterRanges(HandleRef graphics, string textString, int length, HandleRef font, ref GPRECTF layoutRect, HandleRef stringFormat, int characterCount, [In][Out] IntPtr[] region);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetStringFormatMeasurableCharacterRanges(HandleRef format, int rangeCount, [In][Out] CharacterRange[] range);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateStringFormat(StringFormatFlags options, int language, out IntPtr format);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipStringFormatGetGenericDefault(out IntPtr format);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipStringFormatGetGenericTypographic(out IntPtr format);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, EntryPoint = "GdipDeleteStringFormat", ExactSpelling = true, SetLastError = true)]
			private static extern int IntGdipDeleteStringFormat(HandleRef format);

			internal static int GdipDeleteStringFormat(HandleRef format)
			{
				if (IsShutdown)
				{
					return 0;
				}
				return IntGdipDeleteStringFormat(format);
			}

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCloneStringFormat(HandleRef format, out IntPtr newFormat);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetStringFormatFlags(HandleRef format, StringFormatFlags options);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetStringFormatFlags(HandleRef format, out StringFormatFlags result);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetStringFormatAlign(HandleRef format, StringAlignment align);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetStringFormatAlign(HandleRef format, out StringAlignment align);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetStringFormatLineAlign(HandleRef format, StringAlignment align);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetStringFormatLineAlign(HandleRef format, out StringAlignment align);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetStringFormatHotkeyPrefix(HandleRef format, HotkeyPrefix hotkeyPrefix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetStringFormatHotkeyPrefix(HandleRef format, out HotkeyPrefix hotkeyPrefix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetStringFormatTabStops(HandleRef format, float firstTabOffset, int count, float[] tabStops);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetStringFormatTabStops(HandleRef format, int count, out float firstTabOffset, [In][Out] float[] tabStops);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetStringFormatTabStopCount(HandleRef format, out int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetStringFormatMeasurableCharacterRangeCount(HandleRef format, out int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetStringFormatTrimming(HandleRef format, StringTrimming trimming);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetStringFormatTrimming(HandleRef format, out StringTrimming trimming);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetStringFormatDigitSubstitution(HandleRef format, int langID, StringDigitSubstitute sds);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetStringFormatDigitSubstitution(HandleRef format, out int langID, out StringDigitSubstitute sds);

			internal static Exception StatusException(int status)
			{
				return status switch
				{
					1 => new ExternalException(SR.GetString("GdiplusGenericError"), -2147467259), 
					2 => new ArgumentException(SR.GetString("GdiplusInvalidParameter")), 
					3 => new OutOfMemoryException(SR.GetString("GdiplusOutOfMemory")), 
					4 => new InvalidOperationException(SR.GetString("GdiplusObjectBusy")), 
					5 => new OutOfMemoryException(SR.GetString("GdiplusInsufficientBuffer")), 
					6 => new NotImplementedException(SR.GetString("GdiplusNotImplemented")), 
					7 => new ExternalException(SR.GetString("GdiplusGenericError"), -2147467259), 
					8 => new InvalidOperationException(SR.GetString("GdiplusWrongState")), 
					9 => new ExternalException(SR.GetString("GdiplusAborted"), -2147467260), 
					10 => new FileNotFoundException(SR.GetString("GdiplusFileNotFound")), 
					11 => new OverflowException(SR.GetString("GdiplusOverflow")), 
					12 => new ExternalException(SR.GetString("GdiplusAccessDenied"), -2147024891), 
					13 => new ArgumentException(SR.GetString("GdiplusUnknownImageFormat")), 
					19 => new ArgumentException(SR.GetString("GdiplusPropertyNotFoundError")), 
					20 => new ArgumentException(SR.GetString("GdiplusPropertyNotSupportedError")), 
					14 => new ArgumentException(SR.GetString("GdiplusFontFamilyNotFound", "?")), 
					15 => new ArgumentException(SR.GetString("GdiplusFontStyleNotFound", "?", "?")), 
					16 => new ArgumentException(SR.GetString("GdiplusNotTrueTypeFont_NoName")), 
					17 => new ExternalException(SR.GetString("GdiplusUnsupportedGdiplusVersion"), -2147467259), 
					18 => new ExternalException(SR.GetString("GdiplusNotInitialized"), -2147467259), 
					_ => new ExternalException(SR.GetString("GdiplusUnknown"), -2147418113), 
				};
			}

			internal static PointF[] ConvertGPPOINTFArrayF(IntPtr memory, int count)
			{
				if (memory == IntPtr.Zero)
				{
					throw new ArgumentNullException("memory");
				}
				PointF[] array = new PointF[count];
				GPPOINTF gPPOINTF = new GPPOINTF();
				int num = Marshal.SizeOf(gPPOINTF.GetType());
				for (int i = 0; i < count; i++)
				{
					gPPOINTF = (GPPOINTF)UnsafeNativeMethods.PtrToStructure((IntPtr)((long)memory + i * num), gPPOINTF.GetType());
					ref PointF reference = ref array[i];
					reference = new PointF(gPPOINTF.X, gPPOINTF.Y);
				}
				return array;
			}

			internal static Point[] ConvertGPPOINTArray(IntPtr memory, int count)
			{
				if (memory == IntPtr.Zero)
				{
					throw new ArgumentNullException("memory");
				}
				Point[] array = new Point[count];
				GPPOINT gPPOINT = new GPPOINT();
				int num = Marshal.SizeOf(gPPOINT.GetType());
				for (int i = 0; i < count; i++)
				{
					gPPOINT = (GPPOINT)UnsafeNativeMethods.PtrToStructure((IntPtr)((long)memory + i * num), gPPOINT.GetType());
					ref Point reference = ref array[i];
					reference = new Point(gPPOINT.X, gPPOINT.Y);
				}
				return array;
			}

			internal static IntPtr ConvertPointToMemory(PointF[] points)
			{
				if (points == null)
				{
					throw new ArgumentNullException("points");
				}
				int num = Marshal.SizeOf(typeof(GPPOINTF));
				int num2 = points.Length;
				IntPtr intPtr = Marshal.AllocHGlobal(checked(num2 * num));
				for (int i = 0; i < num2; i++)
				{
					Marshal.StructureToPtr(new GPPOINTF(points[i]), (IntPtr)checked((long)intPtr + i * num), fDeleteOld: false);
				}
				return intPtr;
			}

			internal static IntPtr ConvertPointToMemory(Point[] points)
			{
				if (points == null)
				{
					throw new ArgumentNullException("points");
				}
				int num = Marshal.SizeOf(typeof(GPPOINT));
				int num2 = points.Length;
				IntPtr intPtr = Marshal.AllocHGlobal(checked(num2 * num));
				for (int i = 0; i < num2; i++)
				{
					Marshal.StructureToPtr(new GPPOINT(points[i]), (IntPtr)checked((long)intPtr + i * num), fDeleteOld: false);
				}
				return intPtr;
			}

			internal static IntPtr ConvertRectangleToMemory(RectangleF[] rect)
			{
				if (rect == null)
				{
					throw new ArgumentNullException("rect");
				}
				int num = Marshal.SizeOf(typeof(GPRECTF));
				int num2 = rect.Length;
				IntPtr intPtr = Marshal.AllocHGlobal(checked(num2 * num));
				for (int i = 0; i < num2; i++)
				{
					Marshal.StructureToPtr(new GPRECTF(rect[i]), (IntPtr)checked((long)intPtr + i * num), fDeleteOld: false);
				}
				return intPtr;
			}

			internal static IntPtr ConvertRectangleToMemory(Rectangle[] rect)
			{
				if (rect == null)
				{
					throw new ArgumentNullException("rect");
				}
				int num = Marshal.SizeOf(typeof(GPRECT));
				int num2 = rect.Length;
				IntPtr intPtr = Marshal.AllocHGlobal(checked(num2 * num));
				for (int i = 0; i < num2; i++)
				{
					Marshal.StructureToPtr(new GPRECT(rect[i]), (IntPtr)checked((long)intPtr + i * num), fDeleteOld: false);
				}
				return intPtr;
			}
		}

		[StructLayout(LayoutKind.Sequential)]
		public class ENHMETAHEADER
		{
			public int iType;

			public int nSize = 40;

			public int rclBounds_left;

			public int rclBounds_top;

			public int rclBounds_right;

			public int rclBounds_bottom;

			public int rclFrame_left;

			public int rclFrame_top;

			public int rclFrame_right;

			public int rclFrame_bottom;

			public int dSignature;

			public int nVersion;

			public int nBytes;

			public int nRecords;

			public short nHandles;

			public short sReserved;

			public int nDescription;

			public int offDescription;

			public int nPalEntries;

			public int szlDevice_cx;

			public int szlDevice_cy;

			public int szlMillimeters_cx;

			public int szlMillimeters_cy;

			public int cbPixelFormat;

			public int offPixelFormat;

			public int bOpenGL;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
		public class DOCINFO
		{
			public int cbSize = 20;

			public string lpszDocName;

			public string lpszOutput;

			public string lpszDatatype;

			public int fwType;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
		public class PRINTDLG
		{
			public int lStructSize;

			public IntPtr hwndOwner;

			public IntPtr hDevMode;

			public IntPtr hDevNames;

			public IntPtr hDC;

			public int Flags;

			public short nFromPage;

			public short nToPage;

			public short nMinPage;

			public short nMaxPage;

			public short nCopies;

			public IntPtr hInstance;

			public IntPtr lCustData;

			public IntPtr lpfnPrintHook;

			public IntPtr lpfnSetupHook;

			public string lpPrintTemplateName;

			public string lpSetupTemplateName;

			public IntPtr hPrintTemplate;

			public IntPtr hSetupTemplate;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto, Pack = 1)]
		public class PRINTDLGX86
		{
			public int lStructSize;

			public IntPtr hwndOwner;

			public IntPtr hDevMode;

			public IntPtr hDevNames;

			public IntPtr hDC;

			public int Flags;

			public short nFromPage;

			public short nToPage;

			public short nMinPage;

			public short nMaxPage;

			public short nCopies;

			public IntPtr hInstance;

			public IntPtr lCustData;

			public IntPtr lpfnPrintHook;

			public IntPtr lpfnSetupHook;

			public string lpPrintTemplateName;

			public string lpSetupTemplateName;

			public IntPtr hPrintTemplate;

			public IntPtr hSetupTemplate;
		}

		public enum StructFormat
		{
			Ansi = 1,
			Unicode,
			Auto
		}

		public struct RECT
		{
			public int left;

			public int top;

			public int right;

			public int bottom;
		}

		public struct MSG
		{
			public IntPtr hwnd;

			public int message;

			public IntPtr wParam;

			public IntPtr lParam;

			public int time;

			public int pt_x;

			public int pt_y;
		}

		[StructLayout(LayoutKind.Sequential)]
		public class ICONINFO
		{
			public int fIcon;

			public int xHotspot;

			public int yHotspot;

			public IntPtr hbmMask = IntPtr.Zero;

			public IntPtr hbmColor = IntPtr.Zero;
		}

		[StructLayout(LayoutKind.Sequential)]
		public class BITMAP
		{
			public int bmType;

			public int bmWidth;

			public int bmHeight;

			public int bmWidthBytes;

			public short bmPlanes;

			public short bmBitsPixel;

			public IntPtr bmBits = IntPtr.Zero;
		}

		[StructLayout(LayoutKind.Sequential)]
		public class BITMAPINFOHEADER
		{
			public int biSize = 40;

			public int biWidth;

			public int biHeight;

			public short biPlanes;

			public short biBitCount;

			public int biCompression;

			public int biSizeImage;

			public int biXPelsPerMeter;

			public int biYPelsPerMeter;

			public int biClrUsed;

			public int biClrImportant;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
		public class LOGFONT
		{
			public int lfHeight;

			public int lfWidth;

			public int lfEscapement;

			public int lfOrientation;

			public int lfWeight;

			public byte lfItalic;

			public byte lfUnderline;

			public byte lfStrikeOut;

			public byte lfCharSet;

			public byte lfOutPrecision;

			public byte lfClipPrecision;

			public byte lfQuality;

			public byte lfPitchAndFamily;

			[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]
			public string lfFaceName;

			public LOGFONT()
			{
			}

			public LOGFONT(LOGFONT lf)
			{
				lfHeight = lf.lfHeight;
				lfWidth = lf.lfWidth;
				lfEscapement = lf.lfEscapement;
				lfOrientation = lf.lfOrientation;
				lfWeight = lf.lfWeight;
				lfItalic = lf.lfItalic;
				lfUnderline = lf.lfUnderline;
				lfStrikeOut = lf.lfStrikeOut;
				lfCharSet = lf.lfCharSet;
				lfOutPrecision = lf.lfOutPrecision;
				lfClipPrecision = lf.lfClipPrecision;
				lfQuality = lf.lfQuality;
				lfPitchAndFamily = lf.lfPitchAndFamily;
				lfFaceName = lf.lfFaceName;
			}

			public override string ToString()
			{
				return "lfHeight=" + lfHeight + ", lfWidth=" + lfWidth + ", lfEscapement=" + lfEscapement + ", lfOrientation=" + lfOrientation + ", lfWeight=" + lfWeight + ", lfItalic=" + lfItalic + ", lfUnderline=" + lfUnderline + ", lfStrikeOut=" + lfStrikeOut + ", lfCharSet=" + lfCharSet + ", lfOutPrecision=" + lfOutPrecision + ", lfClipPrecision=" + lfClipPrecision + ", lfQuality=" + lfQuality + ", lfPitchAndFamily=" + lfPitchAndFamily + ", lfFaceName=" + lfFaceName;
			}
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		public struct TEXTMETRIC
		{
			public int tmHeight;

			public int tmAscent;

			public int tmDescent;

			public int tmInternalLeading;

			public int tmExternalLeading;

			public int tmAveCharWidth;

			public int tmMaxCharWidth;

			public int tmWeight;

			public int tmOverhang;

			public int tmDigitizedAspectX;

			public int tmDigitizedAspectY;

			public char tmFirstChar;

			public char tmLastChar;

			public char tmDefaultChar;

			public char tmBreakChar;

			public byte tmItalic;

			public byte tmUnderlined;

			public byte tmStruckOut;

			public byte tmPitchAndFamily;

			public byte tmCharSet;
		}

		public struct TEXTMETRICA
		{
			public int tmHeight;

			public int tmAscent;

			public int tmDescent;

			public int tmInternalLeading;

			public int tmExternalLeading;

			public int tmAveCharWidth;

			public int tmMaxCharWidth;

			public int tmWeight;

			public int tmOverhang;

			public int tmDigitizedAspectX;

			public int tmDigitizedAspectY;

			public byte tmFirstChar;

			public byte tmLastChar;

			public byte tmDefaultChar;

			public byte tmBreakChar;

			public byte tmItalic;

			public byte tmUnderlined;

			public byte tmStruckOut;

			public byte tmPitchAndFamily;

			public byte tmCharSet;
		}

		[StructLayout(LayoutKind.Sequential, Pack = 2)]
		public struct ICONDIR
		{
			public short idReserved;

			public short idType;

			public short idCount;

			public ICONDIRENTRY idEntries;
		}

		public struct ICONDIRENTRY
		{
			public byte bWidth;

			public byte bHeight;

			public byte bColorCount;

			public byte bReserved;

			public short wPlanes;

			public short wBitCount;

			public int dwBytesInRes;

			public int dwImageOffset;
		}

		public class Ole
		{
			public const int PICTYPE_UNINITIALIZED = -1;

			public const int PICTYPE_NONE = 0;

			public const int PICTYPE_BITMAP = 1;

			public const int PICTYPE_METAFILE = 2;

			public const int PICTYPE_ICON = 3;

			public const int PICTYPE_ENHMETAFILE = 4;

			public const int STATFLAG_DEFAULT = 0;

			public const int STATFLAG_NONAME = 1;
		}

		[StructLayout(LayoutKind.Sequential)]
		public class PICTDESC
		{
			internal int cbSizeOfStruct;

			public int picType;

			internal IntPtr union1;

			internal int union2;

			internal int union3;

			public static PICTDESC CreateIconPICTDESC(IntPtr hicon)
			{
				PICTDESC pICTDESC = new PICTDESC();
				pICTDESC.cbSizeOfStruct = 12;
				pICTDESC.picType = 3;
				pICTDESC.union1 = hicon;
				return pICTDESC;
			}

			public virtual IntPtr GetHandle()
			{
				return union1;
			}
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
		public class DEVMODE
		{
			[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]
			public string dmDeviceName;

			public short dmSpecVersion;

			public short dmDriverVersion;

			public short dmSize;

			public short dmDriverExtra;

			public int dmFields;

			public short dmOrientation;

			public short dmPaperSize;

			public short dmPaperLength;

			public short dmPaperWidth;

			public short dmScale;

			public short dmCopies;

			public short dmDefaultSource;

			public short dmPrintQuality;

			public short dmColor;

			public short dmDuplex;

			public short dmYResolution;

			public short dmTTOption;

			public short dmCollate;

			[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]
			public string dmFormName;

			public short dmLogPixels;

			public int dmBitsPerPel;

			public int dmPelsWidth;

			public int dmPelsHeight;

			public int dmDisplayFlags;

			public int dmDisplayFrequency;

			public int dmICMMethod;

			public int dmICMIntent;

			public int dmMediaType;

			public int dmDitherType;

			public int dmICCManufacturer;

			public int dmICCModel;

			public int dmPanningWidth;

			public int dmPanningHeight;

			public override string ToString()
			{
				return "[DEVMODE: dmDeviceName=" + dmDeviceName + ", dmSpecVersion=" + dmSpecVersion + ", dmDriverVersion=" + dmDriverVersion + ", dmSize=" + dmSize + ", dmDriverExtra=" + dmDriverExtra + ", dmFields=" + dmFields + ", dmOrientation=" + dmOrientation + ", dmPaperSize=" + dmPaperSize + ", dmPaperLength=" + dmPaperLength + ", dmPaperWidth=" + dmPaperWidth + ", dmScale=" + dmScale + ", dmCopies=" + dmCopies + ", dmDefaultSource=" + dmDefaultSource + ", dmPrintQuality=" + dmPrintQuality + ", dmColor=" + dmColor + ", dmDuplex=" + dmDuplex + ", dmYResolution=" + dmYResolution + ", dmTTOption=" + dmTTOption + ", dmCollate=" + dmCollate + ", dmFormName=" + dmFormName + ", dmLogPixels=" + dmLogPixels + ", dmBitsPerPel=" + dmBitsPerPel + ", dmPelsWidth=" + dmPelsWidth + ", dmPelsHeight=" + dmPelsHeight + ", dmDisplayFlags=" + dmDisplayFlags + ", dmDisplayFrequency=" + dmDisplayFrequency + ", dmICMMethod=" + dmICMMethod + ", dmICMIntent=" + dmICMIntent + ", dmMediaType=" + dmMediaType + ", dmDitherType=" + dmDitherType + ", dmICCManufacturer=" + dmICCManufacturer + ", dmICCModel=" + dmICCModel + ", dmPanningWidth=" + dmPanningWidth + ", dmPanningHeight=" + dmPanningHeight + "]";
			}
		}

		public sealed class CommonHandles
		{
			public static readonly int Accelerator;

			public static readonly int Cursor;

			public static readonly int EMF;

			public static readonly int Find;

			public static readonly int GDI;

			public static readonly int HDC;

			public static readonly int Icon;

			public static readonly int Kernel;

			public static readonly int Menu;

			public static readonly int Window;

			static CommonHandles()
			{
				Accelerator = System.Internal.HandleCollector.RegisterType("Accelerator", 80, 50);
				Cursor = System.Internal.HandleCollector.RegisterType("Cursor", 20, 500);
				EMF = System.Internal.HandleCollector.RegisterType("EnhancedMetaFile", 20, 500);
				Find = System.Internal.HandleCollector.RegisterType("Find", 0, 1000);
				GDI = System.Internal.HandleCollector.RegisterType("GDI", 50, 500);
				HDC = System.Internal.HandleCollector.RegisterType("HDC", 100, 2);
				Icon = System.Internal.HandleCollector.RegisterType("Icon", 20, 500);
				Kernel = System.Internal.HandleCollector.RegisterType("Kernel", 0, 1000);
				Menu = System.Internal.HandleCollector.RegisterType("Menu", 30, 1000);
				Window = System.Internal.HandleCollector.RegisterType("Window", 5, 1000);
			}
		}

		public class StreamConsts
		{
			public const int LOCK_WRITE = 1;

			public const int LOCK_EXCLUSIVE = 2;

			public const int LOCK_ONLYONCE = 4;

			public const int STATFLAG_DEFAULT = 0;

			public const int STATFLAG_NONAME = 1;

			public const int STATFLAG_NOOPEN = 2;

			public const int STGC_DEFAULT = 0;

			public const int STGC_OVERWRITE = 1;

			public const int STGC_ONLYIFCURRENT = 2;

			public const int STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE = 4;

			public const int STREAM_SEEK_SET = 0;

			public const int STREAM_SEEK_CUR = 1;

			public const int STREAM_SEEK_END = 2;
		}

		[ComImport]
		[Guid("7BF80980-BF32-101A-8BBB-00AA00300CAB")]
		[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
		public interface IPicture
		{
			[SuppressUnmanagedCodeSecurity]
			IntPtr GetHandle();

			[SuppressUnmanagedCodeSecurity]
			IntPtr GetHPal();

			[SuppressUnmanagedCodeSecurity]
			[return: MarshalAs(UnmanagedType.I2)]
			short GetPictureType();

			[SuppressUnmanagedCodeSecurity]
			int GetWidth();

			[SuppressUnmanagedCodeSecurity]
			int GetHeight();

			[SuppressUnmanagedCodeSecurity]
			void Render();

			[SuppressUnmanagedCodeSecurity]
			void SetHPal([In] IntPtr phpal);

			[SuppressUnmanagedCodeSecurity]
			IntPtr GetCurDC();

			[SuppressUnmanagedCodeSecurity]
			void SelectPicture([In] IntPtr hdcIn, [Out][MarshalAs(UnmanagedType.LPArray)] int[] phdcOut, [Out][MarshalAs(UnmanagedType.LPArray)] int[] phbmpOut);

			[SuppressUnmanagedCodeSecurity]
			[return: MarshalAs(UnmanagedType.Bool)]
			bool GetKeepOriginalFormat();

			[SuppressUnmanagedCodeSecurity]
			void SetKeepOriginalFormat([In][MarshalAs(UnmanagedType.Bool)] bool pfkeep);

			[SuppressUnmanagedCodeSecurity]
			void PictureChanged();

			[PreserveSig]
			[SuppressUnmanagedCodeSecurity]
			int SaveAsFile([In][MarshalAs(UnmanagedType.Interface)] UnsafeNativeMethods.IStream pstm, [In] int fSaveMemCopy, out int pcbSize);

			[SuppressUnmanagedCodeSecurity]
			int GetAttributes();

			[SuppressUnmanagedCodeSecurity]
			void SetHdc([In] IntPtr hdc);
		}

		public struct OBJECTHEADER
		{
			public short signature;

			public short headersize;

			public short objectType;

			public short nameLen;

			public short classLen;

			public short nameOffset;

			public short classOffset;

			public short width;

			public short height;

			public IntPtr pInfo;
		}

		internal enum Win32SystemColors
		{
			ActiveBorder = 10,
			ActiveCaption = 2,
			ActiveCaptionText = 9,
			AppWorkspace = 12,
			ButtonFace = 15,
			ButtonHighlight = 20,
			ButtonShadow = 16,
			Control = 15,
			ControlDark = 16,
			ControlDarkDark = 21,
			ControlLight = 22,
			ControlLightLight = 20,
			ControlText = 18,
			Desktop = 1,
			GradientActiveCaption = 27,
			GradientInactiveCaption = 28,
			GrayText = 17,
			Highlight = 13,
			HighlightText = 14,
			HotTrack = 26,
			InactiveBorder = 11,
			InactiveCaption = 3,
			InactiveCaptionText = 19,
			Info = 24,
			InfoText = 23,
			Menu = 4,
			MenuBar = 30,
			MenuHighlight = 29,
			MenuText = 7,
			ScrollBar = 0,
			Window = 5,
			WindowFrame = 6,
			WindowText = 8
		}

		public enum BackgroundMode
		{
			TRANSPARENT = 1,
			OPAQUE
		}

		public const int ERROR_CANCELLED = 1223;

		public const int RASTERCAPS = 38;

		public const int RC_PALETTE = 256;

		public const int SIZEPALETTE = 104;

		public const int SYSPAL_STATIC = 1;

		public const int BS_SOLID = 0;

		public const int HOLLOW_BRUSH = 5;

		public const int R2_BLACK = 1;

		public const int R2_NOTMERGEPEN = 2;

		public const int R2_MASKNOTPEN = 3;

		public const int R2_NOTCOPYPEN = 4;

		public const int R2_MASKPENNOT = 5;

		public const int R2_NOT = 6;

		public const int R2_XORPEN = 7;

		public const int R2_NOTMASKPEN = 8;

		public const int R2_MASKPEN = 9;

		public const int R2_NOTXORPEN = 10;

		public const int R2_NOP = 11;

		public const int R2_MERGENOTPEN = 12;

		public const int R2_COPYPEN = 13;

		public const int R2_MERGEPENNOT = 14;

		public const int R2_MERGEPEN = 15;

		public const int R2_WHITE = 16;

		public const int UOI_FLAGS = 1;

		public const int WSF_VISIBLE = 1;

		public const int E_UNEXPECTED = -2147418113;

		public const int E_NOTIMPL = -2147467263;

		public const int E_OUTOFMEMORY = -2147024882;

		public const int E_INVALIDARG = -2147024809;

		public const int E_NOINTERFACE = -2147467262;

		public const int E_POINTER = -2147467261;

		public const int E_HANDLE = -2147024890;

		public const int E_ABORT = -2147467260;

		public const int E_FAIL = -2147467259;

		public const int E_ACCESSDENIED = -2147024891;

		public const int PM_NOREMOVE = 0;

		public const int PM_REMOVE = 1;

		public const int PM_NOYIELD = 2;

		public const int GMEM_FIXED = 0;

		public const int GMEM_MOVEABLE = 2;

		public const int GMEM_NOCOMPACT = 16;

		public const int GMEM_NODISCARD = 32;

		public const int GMEM_ZEROINIT = 64;

		public const int GMEM_MODIFY = 128;

		public const int GMEM_DISCARDABLE = 256;

		public const int GMEM_NOT_BANKED = 4096;

		public const int GMEM_SHARE = 8192;

		public const int GMEM_DDESHARE = 8192;

		public const int GMEM_NOTIFY = 16384;

		public const int GMEM_LOWER = 4096;

		public const int GMEM_VALID_FLAGS = 32626;

		public const int GMEM_INVALID_HANDLE = 32768;

		public const int DM_UPDATE = 1;

		public const int DM_COPY = 2;

		public const int DM_PROMPT = 4;

		public const int DM_MODIFY = 8;

		public const int DM_IN_BUFFER = 8;

		public const int DM_IN_PROMPT = 4;

		public const int DM_OUT_BUFFER = 2;

		public const int DM_OUT_DEFAULT = 1;

		public const int DT_PLOTTER = 0;

		public const int DT_RASDISPLAY = 1;

		public const int DT_RASPRINTER = 2;

		public const int DT_RASCAMERA = 3;

		public const int DT_CHARSTREAM = 4;

		public const int DT_METAFILE = 5;

		public const int DT_DISPFILE = 6;

		public const int TECHNOLOGY = 2;

		public const int DC_FIELDS = 1;

		public const int DC_PAPERS = 2;

		public const int DC_PAPERSIZE = 3;

		public const int DC_MINEXTENT = 4;

		public const int DC_MAXEXTENT = 5;

		public const int DC_BINS = 6;

		public const int DC_DUPLEX = 7;

		public const int DC_SIZE = 8;

		public const int DC_EXTRA = 9;

		public const int DC_VERSION = 10;

		public const int DC_DRIVER = 11;

		public const int DC_BINNAMES = 12;

		public const int DC_ENUMRESOLUTIONS = 13;

		public const int DC_FILEDEPENDENCIES = 14;

		public const int DC_TRUETYPE = 15;

		public const int DC_PAPERNAMES = 16;

		public const int DC_ORIENTATION = 17;

		public const int DC_COPIES = 18;

		public const int PD_ALLPAGES = 0;

		public const int PD_SELECTION = 1;

		public const int PD_PAGENUMS = 2;

		public const int PD_CURRENTPAGE = 4194304;

		public const int PD_NOSELECTION = 4;

		public const int PD_NOPAGENUMS = 8;

		public const int PD_NOCURRENTPAGE = 8388608;

		public const int PD_COLLATE = 16;

		public const int PD_PRINTTOFILE = 32;

		public const int PD_PRINTSETUP = 64;

		public const int PD_NOWARNING = 128;

		public const int PD_RETURNDC = 256;

		public const int PD_RETURNIC = 512;

		public const int PD_RETURNDEFAULT = 1024;

		public const int PD_SHOWHELP = 2048;

		public const int PD_ENABLEPRINTHOOK = 4096;

		public const int PD_ENABLESETUPHOOK = 8192;

		public const int PD_ENABLEPRINTTEMPLATE = 16384;

		public const int PD_ENABLESETUPTEMPLATE = 32768;

		public const int PD_ENABLEPRINTTEMPLATEHANDLE = 65536;

		public const int PD_ENABLESETUPTEMPLATEHANDLE = 131072;

		public const int PD_USEDEVMODECOPIES = 262144;

		public const int PD_USEDEVMODECOPIESANDCOLLATE = 262144;

		public const int PD_DISABLEPRINTTOFILE = 524288;

		public const int PD_HIDEPRINTTOFILE = 1048576;

		public const int PD_NONETWORKBUTTON = 2097152;

		public const int DI_MASK = 1;

		public const int DI_IMAGE = 2;

		public const int DI_NORMAL = 3;

		public const int DI_COMPAT = 4;

		public const int DI_DEFAULTSIZE = 8;

		public const int IDC_ARROW = 32512;

		public const int IDC_IBEAM = 32513;

		public const int IDC_WAIT = 32514;

		public const int IDC_CROSS = 32515;

		public const int IDC_UPARROW = 32516;

		public const int IDC_SIZE = 32640;

		public const int IDC_ICON = 32641;

		public const int IDC_SIZENWSE = 32642;

		public const int IDC_SIZENESW = 32643;

		public const int IDC_SIZEWE = 32644;

		public const int IDC_SIZENS = 32645;

		public const int IDC_SIZEALL = 32646;

		public const int IDC_NO = 32648;

		public const int IDC_APPSTARTING = 32650;

		public const int IDC_HELP = 32651;

		public const int IMAGE_BITMAP = 0;

		public const int IMAGE_ICON = 1;

		public const int IMAGE_CURSOR = 2;

		public const int IMAGE_ENHMETAFILE = 3;

		public const int IDI_APPLICATION = 32512;

		public const int IDI_HAND = 32513;

		public const int IDI_QUESTION = 32514;

		public const int IDI_EXCLAMATION = 32515;

		public const int IDI_ASTERISK = 32516;

		public const int IDI_WINLOGO = 32517;

		public const int IDI_WARNING = 32515;

		public const int IDI_ERROR = 32513;

		public const int IDI_INFORMATION = 32516;

		public const int SRCCOPY = 13369376;

		public const int PLANES = 14;

		public const int PS_SOLID = 0;

		public const int PS_DASH = 1;

		public const int PS_DOT = 2;

		public const int PS_DASHDOT = 3;

		public const int PS_DASHDOTDOT = 4;

		public const int PS_NULL = 5;

		public const int PS_INSIDEFRAME = 6;

		public const int PS_USERSTYLE = 7;

		public const int PS_ALTERNATE = 8;

		public const int PS_STYLE_MASK = 15;

		public const int PS_ENDCAP_ROUND = 0;

		public const int PS_ENDCAP_SQUARE = 256;

		public const int PS_ENDCAP_FLAT = 512;

		public const int PS_ENDCAP_MASK = 3840;

		public const int PS_JOIN_ROUND = 0;

		public const int PS_JOIN_BEVEL = 4096;

		public const int PS_JOIN_MITER = 8192;

		public const int PS_JOIN_MASK = 61440;

		public const int PS_COSMETIC = 0;

		public const int PS_GEOMETRIC = 65536;

		public const int PS_TYPE_MASK = 983040;

		public const int BITSPIXEL = 12;

		public const int ALTERNATE = 1;

		public const int LOGPIXELSX = 88;

		public const int LOGPIXELSY = 90;

		public const int PHYSICALWIDTH = 110;

		public const int PHYSICALHEIGHT = 111;

		public const int PHYSICALOFFSETX = 112;

		public const int PHYSICALOFFSETY = 113;

		public const int WINDING = 2;

		public const int VERTRES = 10;

		public const int HORZRES = 8;

		public const int DM_SPECVERSION = 1025;

		public const int DM_ORIENTATION = 1;

		public const int DM_PAPERSIZE = 2;

		public const int DM_PAPERLENGTH = 4;

		public const int DM_PAPERWIDTH = 8;

		public const int DM_SCALE = 16;

		public const int DM_COPIES = 256;

		public const int DM_DEFAULTSOURCE = 512;

		public const int DM_PRINTQUALITY = 1024;

		public const int DM_COLOR = 2048;

		public const int DM_DUPLEX = 4096;

		public const int DM_YRESOLUTION = 8192;

		public const int DM_TTOPTION = 16384;

		public const int DM_COLLATE = 32768;

		public const int DM_FORMNAME = 65536;

		public const int DM_LOGPIXELS = 131072;

		public const int DM_BITSPERPEL = 262144;

		public const int DM_PELSWIDTH = 524288;

		public const int DM_PELSHEIGHT = 1048576;

		public const int DM_DISPLAYFLAGS = 2097152;

		public const int DM_DISPLAYFREQUENCY = 4194304;

		public const int DM_PANNINGWIDTH = 8388608;

		public const int DM_PANNINGHEIGHT = 16777216;

		public const int DM_ICMMETHOD = 33554432;

		public const int DM_ICMINTENT = 67108864;

		public const int DM_MEDIATYPE = 134217728;

		public const int DM_DITHERTYPE = 268435456;

		public const int DM_ICCMANUFACTURER = 536870912;

		public const int DM_ICCMODEL = 1073741824;

		public const int DMORIENT_PORTRAIT = 1;

		public const int DMORIENT_LANDSCAPE = 2;

		public const int DMPAPER_LETTER = 1;

		public const int DMPAPER_LETTERSMALL = 2;

		public const int DMPAPER_TABLOID = 3;

		public const int DMPAPER_LEDGER = 4;

		public const int DMPAPER_LEGAL = 5;

		public const int DMPAPER_STATEMENT = 6;

		public const int DMPAPER_EXECUTIVE = 7;

		public const int DMPAPER_A3 = 8;

		public const int DMPAPER_A4 = 9;

		public const int DMPAPER_A4SMALL = 10;

		public const int DMPAPER_A5 = 11;

		public const int DMPAPER_B4 = 12;

		public const int DMPAPER_B5 = 13;

		public const int DMPAPER_FOLIO = 14;

		public const int DMPAPER_QUARTO = 15;

		public const int DMPAPER_10X14 = 16;

		public const int DMPAPER_11X17 = 17;

		public const int DMPAPER_NOTE = 18;

		public const int DMPAPER_ENV_9 = 19;

		public const int DMPAPER_ENV_10 = 20;

		public const int DMPAPER_ENV_11 = 21;

		public const int DMPAPER_ENV_12 = 22;

		public const int DMPAPER_ENV_14 = 23;

		public const int DMPAPER_CSHEET = 24;

		public const int DMPAPER_DSHEET = 25;

		public const int DMPAPER_ESHEET = 26;

		public const int DMPAPER_ENV_DL = 27;

		public const int DMPAPER_ENV_C5 = 28;

		public const int DMPAPER_ENV_C3 = 29;

		public const int DMPAPER_ENV_C4 = 30;

		public const int DMPAPER_ENV_C6 = 31;

		public const int DMPAPER_ENV_C65 = 32;

		public const int DMPAPER_ENV_B4 = 33;

		public const int DMPAPER_ENV_B5 = 34;

		public const int DMPAPER_ENV_B6 = 35;

		public const int DMPAPER_ENV_ITALY = 36;

		public const int DMPAPER_ENV_MONARCH = 37;

		public const int DMPAPER_ENV_PERSONAL = 38;

		public const int DMPAPER_FANFOLD_US = 39;

		public const int DMPAPER_FANFOLD_STD_GERMAN = 40;

		public const int DMPAPER_FANFOLD_LGL_GERMAN = 41;

		public const int DMPAPER_ISO_B4 = 42;

		public const int DMPAPER_JAPANESE_POSTCARD = 43;

		public const int DMPAPER_9X11 = 44;

		public const int DMPAPER_10X11 = 45;

		public const int DMPAPER_15X11 = 46;

		public const int DMPAPER_ENV_INVITE = 47;

		public const int DMPAPER_RESERVED_48 = 48;

		public const int DMPAPER_RESERVED_49 = 49;

		public const int DMPAPER_LETTER_EXTRA = 50;

		public const int DMPAPER_LEGAL_EXTRA = 51;

		public const int DMPAPER_TABLOID_EXTRA = 52;

		public const int DMPAPER_A4_EXTRA = 53;

		public const int DMPAPER_LETTER_TRANSVERSE = 54;

		public const int DMPAPER_A4_TRANSVERSE = 55;

		public const int DMPAPER_LETTER_EXTRA_TRANSVERSE = 56;

		public const int DMPAPER_A_PLUS = 57;

		public const int DMPAPER_B_PLUS = 58;

		public const int DMPAPER_LETTER_PLUS = 59;

		public const int DMPAPER_A4_PLUS = 60;

		public const int DMPAPER_A5_TRANSVERSE = 61;

		public const int DMPAPER_B5_TRANSVERSE = 62;

		public const int DMPAPER_A3_EXTRA = 63;

		public const int DMPAPER_A5_EXTRA = 64;

		public const int DMPAPER_B5_EXTRA = 65;

		public const int DMPAPER_A2 = 66;

		public const int DMPAPER_A3_TRANSVERSE = 67;

		public const int DMPAPER_A3_EXTRA_TRANSVERSE = 68;

		public const int DMPAPER_DBL_JAPANESE_POSTCARD = 69;

		public const int DMPAPER_A6 = 70;

		public const int DMPAPER_JENV_KAKU2 = 71;

		public const int DMPAPER_JENV_KAKU3 = 72;

		public const int DMPAPER_JENV_CHOU3 = 73;

		public const int DMPAPER_JENV_CHOU4 = 74;

		public const int DMPAPER_LETTER_ROTATED = 75;

		public const int DMPAPER_A3_ROTATED = 76;

		public const int DMPAPER_A4_ROTATED = 77;

		public const int DMPAPER_A5_ROTATED = 78;

		public const int DMPAPER_B4_JIS_ROTATED = 79;

		public const int DMPAPER_B5_JIS_ROTATED = 80;

		public const int DMPAPER_JAPANESE_POSTCARD_ROTATED = 81;

		public const int DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED = 82;

		public const int DMPAPER_A6_ROTATED = 83;

		public const int DMPAPER_JENV_KAKU2_ROTATED = 84;

		public const int DMPAPER_JENV_KAKU3_ROTATED = 85;

		public const int DMPAPER_JENV_CHOU3_ROTATED = 86;

		public const int DMPAPER_JENV_CHOU4_ROTATED = 87;

		public const int DMPAPER_B6_JIS = 88;

		public const int DMPAPER_B6_JIS_ROTATED = 89;

		public const int DMPAPER_12X11 = 90;

		public const int DMPAPER_JENV_YOU4 = 91;

		public const int DMPAPER_JENV_YOU4_ROTATED = 92;

		public const int DMPAPER_P16K = 93;

		public const int DMPAPER_P32K = 94;

		public const int DMPAPER_P32KBIG = 95;

		public const int DMPAPER_PENV_1 = 96;

		public const int DMPAPER_PENV_2 = 97;

		public const int DMPAPER_PENV_3 = 98;

		public const int DMPAPER_PENV_4 = 99;

		public const int DMPAPER_PENV_5 = 100;

		public const int DMPAPER_PENV_6 = 101;

		public const int DMPAPER_PENV_7 = 102;

		public const int DMPAPER_PENV_8 = 103;

		public const int DMPAPER_PENV_9 = 104;

		public const int DMPAPER_PENV_10 = 105;

		public const int DMPAPER_P16K_ROTATED = 106;

		public const int DMPAPER_P32K_ROTATED = 107;

		public const int DMPAPER_P32KBIG_ROTATED = 108;

		public const int DMPAPER_PENV_1_ROTATED = 109;

		public const int DMPAPER_PENV_2_ROTATED = 110;

		public const int DMPAPER_PENV_3_ROTATED = 111;

		public const int DMPAPER_PENV_4_ROTATED = 112;

		public const int DMPAPER_PENV_5_ROTATED = 113;

		public const int DMPAPER_PENV_6_ROTATED = 114;

		public const int DMPAPER_PENV_7_ROTATED = 115;

		public const int DMPAPER_PENV_8_ROTATED = 116;

		public const int DMPAPER_PENV_9_ROTATED = 117;

		public const int DMPAPER_PENV_10_ROTATED = 118;

		public const int DMPAPER_LAST = 118;

		public const int DMPAPER_USER = 256;

		public const int DMBIN_UPPER = 1;

		public const int DMBIN_ONLYONE = 1;

		public const int DMBIN_LOWER = 2;

		public const int DMBIN_MIDDLE = 3;

		public const int DMBIN_MANUAL = 4;

		public const int DMBIN_ENVELOPE = 5;

		public const int DMBIN_ENVMANUAL = 6;

		public const int DMBIN_AUTO = 7;

		public const int DMBIN_TRACTOR = 8;

		public const int DMBIN_SMALLFMT = 9;

		public const int DMBIN_LARGEFMT = 10;

		public const int DMBIN_LARGECAPACITY = 11;

		public const int DMBIN_CASSETTE = 14;

		public const int DMBIN_FORMSOURCE = 15;

		public const int DMBIN_LAST = 15;

		public const int DMBIN_USER = 256;

		public const int DMRES_DRAFT = -1;

		public const int DMRES_LOW = -2;

		public const int DMRES_MEDIUM = -3;

		public const int DMRES_HIGH = -4;

		public const int DMCOLOR_MONOCHROME = 1;

		public const int DMCOLOR_COLOR = 2;

		public const int DMDUP_SIMPLEX = 1;

		public const int DMDUP_VERTICAL = 2;

		public const int DMDUP_HORIZONTAL = 3;

		public const int DMTT_BITMAP = 1;

		public const int DMTT_DOWNLOAD = 2;

		public const int DMTT_SUBDEV = 3;

		public const int DMTT_DOWNLOAD_OUTLINE = 4;

		public const int DMCOLLATE_FALSE = 0;

		public const int DMCOLLATE_TRUE = 1;

		public const int DMDISPLAYFLAGS_TEXTMODE = 4;

		public const int DMICMMETHOD_NONE = 1;

		public const int DMICMMETHOD_SYSTEM = 2;

		public const int DMICMMETHOD_DRIVER = 3;

		public const int DMICMMETHOD_DEVICE = 4;

		public const int DMICMMETHOD_USER = 256;

		public const int DMICM_SATURATE = 1;

		public const int DMICM_CONTRAST = 2;

		public const int DMICM_COLORMETRIC = 3;

		public const int DMICM_USER = 256;

		public const int DMMEDIA_STANDARD = 1;

		public const int DMMEDIA_TRANSPARENCY = 2;

		public const int DMMEDIA_GLOSSY = 3;

		public const int DMMEDIA_USER = 256;

		public const int DMDITHER_NONE = 1;

		public const int DMDITHER_COARSE = 2;

		public const int DMDITHER_FINE = 3;

		public const int DMDITHER_LINEART = 4;

		public const int DMDITHER_GRAYSCALE = 5;

		public const int DMDITHER_USER = 256;

		public const int PRINTER_ENUM_DEFAULT = 1;

		public const int PRINTER_ENUM_LOCAL = 2;

		public const int PRINTER_ENUM_CONNECTIONS = 4;

		public const int PRINTER_ENUM_FAVORITE = 4;

		public const int PRINTER_ENUM_NAME = 8;

		public const int PRINTER_ENUM_REMOTE = 16;

		public const int PRINTER_ENUM_SHARED = 32;

		public const int PRINTER_ENUM_NETWORK = 64;

		public const int PRINTER_ENUM_EXPAND = 16384;

		public const int PRINTER_ENUM_CONTAINER = 32768;

		public const int PRINTER_ENUM_ICONMASK = 16711680;

		public const int PRINTER_ENUM_ICON1 = 65536;

		public const int PRINTER_ENUM_ICON2 = 131072;

		public const int PRINTER_ENUM_ICON3 = 262144;

		public const int PRINTER_ENUM_ICON4 = 524288;

		public const int PRINTER_ENUM_ICON5 = 1048576;

		public const int PRINTER_ENUM_ICON6 = 2097152;

		public const int PRINTER_ENUM_ICON7 = 4194304;

		public const int PRINTER_ENUM_ICON8 = 8388608;

		public const int DC_BINADJUST = 19;

		public const int DC_EMF_COMPLIANT = 20;

		public const int DC_DATATYPE_PRODUCED = 21;

		public const int DC_COLLATE = 22;

		public const int DCTT_BITMAP = 1;

		public const int DCTT_DOWNLOAD = 2;

		public const int DCTT_SUBDEV = 4;

		public const int DCTT_DOWNLOAD_OUTLINE = 8;

		public const int DCBA_FACEUPNONE = 0;

		public const int DCBA_FACEUPCENTER = 1;

		public const int DCBA_FACEUPLEFT = 2;

		public const int DCBA_FACEUPRIGHT = 3;

		public const int DCBA_FACEDOWNNONE = 256;

		public const int DCBA_FACEDOWNCENTER = 257;

		public const int DCBA_FACEDOWNLEFT = 258;

		public const int DCBA_FACEDOWNRIGHT = 259;

		public const int SRCPAINT = 15597702;

		public const int SRCAND = 8913094;

		public const int SRCINVERT = 6684742;

		public const int SRCERASE = 4457256;

		public const int NOTSRCCOPY = 3342344;

		public const int NOTSRCERASE = 1114278;

		public const int MERGECOPY = 12583114;

		public const int MERGEPAINT = 12255782;

		public const int PATCOPY = 15728673;

		public const int PATPAINT = 16452105;

		public const int PATINVERT = 5898313;

		public const int DSTINVERT = 5570569;

		public const int BLACKNESS = 66;

		public const int WHITENESS = 16711778;

		public const int CAPTUREBLT = 1073741824;

		public const int SM_CXSCREEN = 0;

		public const int SM_CYSCREEN = 1;

		public const int SM_CXVSCROLL = 2;

		public const int SM_CYHSCROLL = 3;

		public const int SM_CYCAPTION = 4;

		public const int SM_CXBORDER = 5;

		public const int SM_CYBORDER = 6;

		public const int SM_CXDLGFRAME = 7;

		public const int SM_CYDLGFRAME = 8;

		public const int SM_CYVTHUMB = 9;

		public const int SM_CXHTHUMB = 10;

		public const int SM_CXICON = 11;

		public const int SM_CYICON = 12;

		public const int SM_CXCURSOR = 13;

		public const int SM_CYCURSOR = 14;

		public const int SM_CYMENU = 15;

		public const int SM_CXFULLSCREEN = 16;

		public const int SM_CYFULLSCREEN = 17;

		public const int SM_CYKANJIWINDOW = 18;

		public const int SM_MOUSEPRESENT = 19;

		public const int SM_CYVSCROLL = 20;

		public const int SM_CXHSCROLL = 21;

		public const int SM_DEBUG = 22;

		public const int SM_SWAPBUTTON = 23;

		public const int SM_RESERVED1 = 24;

		public const int SM_RESERVED2 = 25;

		public const int SM_RESERVED3 = 26;

		public const int SM_RESERVED4 = 27;

		public const int SM_CXMIN = 28;

		public const int SM_CYMIN = 29;

		public const int SM_CXSIZE = 30;

		public const int SM_CYSIZE = 31;

		public const int SM_CXFRAME = 32;

		public const int SM_CYFRAME = 33;

		public const int SM_CXMINTRACK = 34;

		public const int SM_CYMINTRACK = 35;

		public const int SM_CXDOUBLECLK = 36;

		public const int SM_CYDOUBLECLK = 37;

		public const int SM_CXICONSPACING = 38;

		public const int SM_CYICONSPACING = 39;

		public const int SM_MENUDROPALIGNMENT = 40;

		public const int SM_PENWINDOWS = 41;

		public const int SM_DBCSENABLED = 42;

		public const int SM_CMOUSEBUTTONS = 43;

		public const int SM_CXFIXEDFRAME = 7;

		public const int SM_CYFIXEDFRAME = 8;

		public const int SM_CXSIZEFRAME = 32;

		public const int SM_CYSIZEFRAME = 33;

		public const int SM_SECURE = 44;

		public const int SM_CXEDGE = 45;

		public const int SM_CYEDGE = 46;

		public const int SM_CXMINSPACING = 47;

		public const int SM_CYMINSPACING = 48;

		public const int SM_CXSMICON = 49;

		public const int SM_CYSMICON = 50;

		public const int SM_CYSMCAPTION = 51;

		public const int SM_CXSMSIZE = 52;

		public const int SM_CYSMSIZE = 53;

		public const int SM_CXMENUSIZE = 54;

		public const int SM_CYMENUSIZE = 55;

		public const int SM_ARRANGE = 56;

		public const int SM_CXMINIMIZED = 57;

		public const int SM_CYMINIMIZED = 58;

		public const int SM_CXMAXTRACK = 59;

		public const int SM_CYMAXTRACK = 60;

		public const int SM_CXMAXIMIZED = 61;

		public const int SM_CYMAXIMIZED = 62;

		public const int SM_NETWORK = 63;

		public const int SM_CLEANBOOT = 67;

		public const int SM_CXDRAG = 68;

		public const int SM_CYDRAG = 69;

		public const int SM_SHOWSOUNDS = 70;

		public const int SM_CXMENUCHECK = 71;

		public const int SM_CYMENUCHECK = 72;

		public const int SM_SLOWMACHINE = 73;

		public const int SM_MIDEASTENABLED = 74;

		public const int SM_MOUSEWHEELPRESENT = 75;

		public const int SM_XVIRTUALSCREEN = 76;

		public const int SM_YVIRTUALSCREEN = 77;

		public const int SM_CXVIRTUALSCREEN = 78;

		public const int SM_CYVIRTUALSCREEN = 79;

		public const int SM_CMONITORS = 80;

		public const int SM_SAMEDISPLAYFORMAT = 81;

		public const int SM_CMETRICS = 83;

		public const int GM_COMPATIBLE = 1;

		public const int GM_ADVANCED = 2;

		public const int MWT_IDENTITY = 1;

		public const int FW_DONTCARE = 0;

		public const int FW_NORMAL = 400;

		public const int FW_BOLD = 700;

		public const int ANSI_CHARSET = 0;

		public const int DEFAULT_CHARSET = 1;

		public const int OUT_DEFAULT_PRECIS = 0;

		public const int OUT_TT_PRECIS = 4;

		public const int OUT_TT_ONLY_PRECIS = 7;

		public const int CLIP_DEFAULT_PRECIS = 0;

		public const int DEFAULT_QUALITY = 0;

		public const int MM_TEXT = 1;

		public const int OBJ_FONT = 6;

		public const int TA_DEFAULT = 0;

		public const int FORMAT_MESSAGE_ALLOCATE_BUFFER = 256;

		public const int FORMAT_MESSAGE_IGNORE_INSERTS = 512;

		public const int FORMAT_MESSAGE_FROM_SYSTEM = 4096;

		public const int FORMAT_MESSAGE_DEFAULT = 4608;

		public const int NOMIRRORBITMAP = int.MinValue;

		public const int QUERYESCSUPPORT = 8;

		public const int CHECKJPEGFORMAT = 4119;

		public const int CHECKPNGFORMAT = 4120;

		public const int ERROR_ACCESS_DENIED = 5;

		public const int ERROR_INVALID_PARAMETER = 87;

		public const int ERROR_PROC_NOT_FOUND = 127;

		public static IntPtr InvalidIntPtr = (IntPtr)(-1);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "CreateCompatibleBitmap", ExactSpelling = true, SetLastError = true)]
		public static extern IntPtr IntCreateCompatibleBitmap(HandleRef hDC, int width, int height);

		public static IntPtr CreateCompatibleBitmap(HandleRef hDC, int width, int height)
		{
			return System.Internal.HandleCollector.Add(IntCreateCompatibleBitmap(hDC, width, height), CommonHandles.GDI);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "CreateBitmap", ExactSpelling = true, SetLastError = true)]
		public static extern IntPtr IntCreateBitmap(int width, int height, int planes, int bpp, IntPtr bitmapData);

		public static IntPtr CreateBitmap(int width, int height, int planes, int bpp, IntPtr bitmapData)
		{
			return System.Internal.HandleCollector.Add(IntCreateBitmap(width, height, planes, bpp, bitmapData), CommonHandles.GDI);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int BitBlt(HandleRef hDC, int x, int y, int nWidth, int nHeight, HandleRef hSrcDC, int xSrc, int ySrc, int dwRop);

		[DllImport("gdi32.dll")]
		public static extern int GetDIBits(HandleRef hdc, HandleRef hbm, int arg1, int arg2, IntPtr arg3, ref NativeMethods.BITMAPINFO_FLAT bmi, int arg5);

		[DllImport("gdi32.dll")]
		public static extern uint GetPaletteEntries(HandleRef hpal, int iStartIndex, int nEntries, byte[] lppe);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "CreateDIBSection", ExactSpelling = true, SetLastError = true)]
		public static extern IntPtr IntCreateDIBSection(HandleRef hdc, ref NativeMethods.BITMAPINFO_FLAT bmi, int iUsage, ref IntPtr ppvBits, IntPtr hSection, int dwOffset);

		public static IntPtr CreateDIBSection(HandleRef hdc, ref NativeMethods.BITMAPINFO_FLAT bmi, int iUsage, ref IntPtr ppvBits, IntPtr hSection, int dwOffset)
		{
			return System.Internal.HandleCollector.Add(IntCreateDIBSection(hdc, ref bmi, iUsage, ref ppvBits, hSection, dwOffset), CommonHandles.GDI);
		}

		[DllImport("kernel32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern IntPtr GlobalFree(HandleRef handle);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern int StartDoc(HandleRef hDC, DOCINFO lpDocInfo);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int StartPage(HandleRef hDC);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int EndPage(HandleRef hDC);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int AbortDoc(HandleRef hDC);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int EndDoc(HandleRef hDC);

		[DllImport("comdlg32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern bool PrintDlg([In][Out] PRINTDLG lppd);

		[DllImport("comdlg32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern bool PrintDlg([In][Out] PRINTDLGX86 lppd);

		[DllImport("winspool.drv", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern int DeviceCapabilities(string pDevice, string pPort, short fwCapabilities, IntPtr pOutput, IntPtr pDevMode);

		[DllImport("winspool.drv", BestFitMapping = false, CharSet = CharSet.Auto, SetLastError = true)]
		public static extern int DocumentProperties(HandleRef hwnd, HandleRef hPrinter, string pDeviceName, IntPtr pDevModeOutput, HandleRef pDevModeInput, int fMode);

		[DllImport("winspool.drv", BestFitMapping = false, CharSet = CharSet.Auto, SetLastError = true)]
		public static extern int DocumentProperties(HandleRef hwnd, HandleRef hPrinter, string pDeviceName, IntPtr pDevModeOutput, IntPtr pDevModeInput, int fMode);

		[DllImport("winspool.drv", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern int EnumPrinters(int flags, string name, int level, IntPtr pPrinterEnum, int cbBuf, out int pcbNeeded, out int pcReturned);

		[DllImport("kernel32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern IntPtr GlobalLock(HandleRef handle);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern IntPtr ResetDC(HandleRef hDC, HandleRef lpDevMode);

		[DllImport("kernel32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern bool GlobalUnlock(HandleRef handle);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "CreateRectRgn", ExactSpelling = true, SetLastError = true)]
		private static extern IntPtr IntCreateRectRgn(int x1, int y1, int x2, int y2);

		public static IntPtr CreateRectRgn(int x1, int y1, int x2, int y2)
		{
			return System.Internal.HandleCollector.Add(IntCreateRectRgn(x1, y1, x2, y2), CommonHandles.GDI);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int GetClipRgn(HandleRef hDC, HandleRef hRgn);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int SelectClipRgn(HandleRef hDC, HandleRef hRgn);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern int AddFontResourceEx(string lpszFilename, int fl, IntPtr pdv);

		public static int AddFontFile(string fileName)
		{
			if (Marshal.SystemDefaultCharSize == 1)
			{
				return 0;
			}
			return AddFontResourceEx(fileName, 16, IntPtr.Zero);
		}

		internal static IntPtr SaveClipRgn(IntPtr hDC)
		{
			IntPtr intPtr = CreateRectRgn(0, 0, 0, 0);
			IntPtr zero = IntPtr.Zero;
			try
			{
				int clipRgn = GetClipRgn(new HandleRef(null, hDC), new HandleRef(null, intPtr));
				if (clipRgn > 0)
				{
					zero = intPtr;
					intPtr = IntPtr.Zero;
					return zero;
				}
				return zero;
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					DeleteObject(new HandleRef(null, intPtr));
				}
			}
		}

		internal static void RestoreClipRgn(IntPtr hDC, IntPtr hRgn)
		{
			try
			{
				SelectClipRgn(new HandleRef(null, hDC), new HandleRef(null, hRgn));
			}
			finally
			{
				if (hRgn != IntPtr.Zero)
				{
					DeleteObject(new HandleRef(null, hRgn));
				}
			}
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int ExtEscape(HandleRef hDC, int nEscape, int cbInput, ref int inData, int cbOutput, out int outData);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int ExtEscape(HandleRef hDC, int nEscape, int cbInput, byte[] inData, int cbOutput, out int outData);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int IntersectClipRect(HandleRef hDC, int x1, int y1, int x2, int y2);

		[DllImport("kernel32.dll", CharSet = CharSet.Auto, EntryPoint = "GlobalAlloc", ExactSpelling = true, SetLastError = true)]
		public static extern IntPtr IntGlobalAlloc(int uFlags, UIntPtr dwBytes);

		public static IntPtr GlobalAlloc(int uFlags, uint dwBytes)
		{
			return IntGlobalAlloc(uFlags, new UIntPtr(dwBytes));
		}

		[DllImport("kernel32.dll")]
		internal static extern void ZeroMemory(IntPtr destination, UIntPtr length);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "DeleteObject", ExactSpelling = true, SetLastError = true)]
		internal static extern int IntDeleteObject(HandleRef hObject);

		public static int DeleteObject(HandleRef hObject)
		{
			System.Internal.HandleCollector.Remove((IntPtr)hObject, CommonHandles.GDI);
			return IntDeleteObject(hObject);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern IntPtr SelectObject(HandleRef hdc, HandleRef obj);

		[DllImport("user32.dll", EntryPoint = "CreateIconFromResourceEx", SetLastError = true)]
		private unsafe static extern IntPtr IntCreateIconFromResourceEx(byte* pbIconBits, int cbIconBits, bool fIcon, int dwVersion, int csDesired, int cyDesired, int flags);

		public unsafe static IntPtr CreateIconFromResourceEx(byte* pbIconBits, int cbIconBits, bool fIcon, int dwVersion, int csDesired, int cyDesired, int flags)
		{
			return System.Internal.HandleCollector.Add(IntCreateIconFromResourceEx(pbIconBits, cbIconBits, fIcon, dwVersion, csDesired, cyDesired, flags), CommonHandles.Icon);
		}

		[DllImport("shell32.dll", BestFitMapping = false, CharSet = CharSet.Auto, EntryPoint = "ExtractAssociatedIcon")]
		public static extern IntPtr IntExtractAssociatedIcon(HandleRef hInst, StringBuilder iconPath, ref int index);

		public static IntPtr ExtractAssociatedIcon(HandleRef hInst, StringBuilder iconPath, ref int index)
		{
			return System.Internal.HandleCollector.Add(IntExtractAssociatedIcon(hInst, iconPath, ref index), CommonHandles.Icon);
		}

		[DllImport("user32.dll", CharSet = CharSet.Auto, EntryPoint = "LoadIcon", SetLastError = true)]
		private static extern IntPtr IntLoadIcon(HandleRef hInst, IntPtr iconId);

		public static IntPtr LoadIcon(HandleRef hInst, int iconId)
		{
			return IntLoadIcon(hInst, new IntPtr(iconId));
		}

		[DllImport("user32.dll", CharSet = CharSet.Auto, EntryPoint = "DestroyIcon", ExactSpelling = true, SetLastError = true)]
		private static extern bool IntDestroyIcon(HandleRef hIcon);

		public static bool DestroyIcon(HandleRef hIcon)
		{
			System.Internal.HandleCollector.Remove((IntPtr)hIcon, CommonHandles.Icon);
			return IntDestroyIcon(hIcon);
		}

		[DllImport("user32.dll", CharSet = CharSet.Auto, EntryPoint = "CopyImage", ExactSpelling = true, SetLastError = true)]
		private static extern IntPtr IntCopyImage(HandleRef hImage, int uType, int cxDesired, int cyDesired, int fuFlags);

		public static IntPtr CopyImage(HandleRef hImage, int uType, int cxDesired, int cyDesired, int fuFlags)
		{
			return System.Internal.HandleCollector.Add(type: (uType != 1) ? CommonHandles.GDI : CommonHandles.Icon, handle: IntCopyImage(hImage, uType, cxDesired, cyDesired, fuFlags));
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern int GetObject(HandleRef hObject, int nSize, [In][Out] BITMAP bm);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern int GetObject(HandleRef hObject, int nSize, [In][Out] LOGFONT lf);

		public static int GetObject(HandleRef hObject, LOGFONT lp)
		{
			return GetObject(hObject, Marshal.SizeOf(typeof(LOGFONT)), lp);
		}

		[DllImport("user32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern bool GetIconInfo(HandleRef hIcon, [In][Out] ICONINFO info);

		[DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern int GetSysColor(int nIndex);

		[DllImport("user32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern bool DrawIconEx(HandleRef hDC, int x, int y, HandleRef hIcon, int width, int height, int iStepIfAniCursor, HandleRef hBrushFlickerFree, int diFlags);

		[DllImport("oleaut32.dll", PreserveSig = false)]
		public static extern IPicture OleCreatePictureIndirect(PICTDESC pictdesc, [In] ref Guid refiid, bool fOwn);
	}
}
namespace System.Drawing.Text
{
	public enum GenericFontFamilies
	{
		Serif,
		SansSerif,
		Monospace
	}
}
namespace System.Drawing.Internal
{
	[StructLayout(LayoutKind.Sequential)]
	internal class GPPOINT
	{
		internal int X;

		internal int Y;

		internal GPPOINT()
		{
		}

		internal GPPOINT(PointF pt)
		{
			X = (int)pt.X;
			Y = (int)pt.Y;
		}

		internal GPPOINT(Point pt)
		{
			X = pt.X;
			Y = pt.Y;
		}

		internal PointF ToPoint()
		{
			return new PointF(X, Y);
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class GPPOINTF
	{
		internal float X;

		internal float Y;

		internal GPPOINTF()
		{
		}

		internal GPPOINTF(PointF pt)
		{
			X = pt.X;
			Y = pt.Y;
		}

		internal GPPOINTF(Point pt)
		{
			X = pt.X;
			Y = pt.Y;
		}

		internal PointF ToPoint()
		{
			return new PointF(X, Y);
		}
	}
	internal struct GPRECT
	{
		internal int X;

		internal int Y;

		internal int Width;

		internal int Height;

		internal GPRECT(int x, int y, int width, int height)
		{
			X = x;
			Y = y;
			Width = width;
			Height = height;
		}

		internal GPRECT(Rectangle rect)
		{
			X = rect.X;
			Y = rect.Y;
			Width = rect.Width;
			Height = rect.Height;
		}

		internal Rectangle ToRectangle()
		{
			return new Rectangle(X, Y, Width, Height);
		}
	}
	internal struct GPRECTF
	{
		internal float X;

		internal float Y;

		internal float Width;

		internal float Height;

		internal SizeF SizeF => new SizeF(Width, Height);

		internal GPRECTF(float x, float y, float width, float height)
		{
			X = x;
			Y = y;
			Width = width;
			Height = height;
		}

		internal GPRECTF(RectangleF rect)
		{
			X = rect.X;
			Y = rect.Y;
			Width = rect.Width;
			Height = rect.Height;
		}

		internal RectangleF ToRectangleF()
		{
			return new RectangleF(X, Y, Width, Height);
		}
	}
	internal class GPStream : UnsafeNativeMethods.IStream
	{
		[StructLayout(LayoutKind.Sequential)]
		public class STATSTG
		{
			public IntPtr pwcsName = IntPtr.Zero;

			public int type;

			[MarshalAs(UnmanagedType.I8)]
			public long cbSize;

			[MarshalAs(UnmanagedType.I8)]
			public long mtime;

			[MarshalAs(UnmanagedType.I8)]
			public long ctime;

			[MarshalAs(UnmanagedType.I8)]
			public long atime;

			[MarshalAs(UnmanagedType.I4)]
			public int grfMode;

			[MarshalAs(UnmanagedType.I4)]
			public int grfLocksSupported;

			public int clsid_data1;

			[MarshalAs(UnmanagedType.I2)]
			public short clsid_data2;

			[MarshalAs(UnmanagedType.I2)]
			public short clsid_data3;

			[MarshalAs(UnmanagedType.U1)]
			public byte clsid_b0;

			[MarshalAs(UnmanagedType.U1)]
			public byte clsid_b1;

			[MarshalAs(UnmanagedType.U1)]
			public byte clsid_b2;

			[MarshalAs(UnmanagedType.U1)]
			public byte clsid_b3;

			[MarshalAs(UnmanagedType.U1)]
			public byte clsid_b4;

			[MarshalAs(UnmanagedType.U1)]
			public byte clsid_b5;

			[MarshalAs(UnmanagedType.U1)]
			public byte clsid_b6;

			[MarshalAs(UnmanagedType.U1)]
			public byte clsid_b7;

			[MarshalAs(UnmanagedType.I4)]
			public int grfStateBits;

			[MarshalAs(UnmanagedType.I4)]
			public int reserved;
		}

		protected Stream dataStream;

		private long virtualPosition = -1L;

		internal GPStream(Stream stream)
		{
			if (!stream.CanSeek)
			{
				byte[] array = new byte[256];
				int num = 0;
				int num2;
				do
				{
					if (array.Length < num + 256)
					{
						byte[] array2 = new byte[array.Length * 2];
						Array.Copy(array, array2, array.Length);
						array = array2;
					}
					num2 = stream.Read(array, num, 256);
					num += num2;
				}
				while (num2 != 0);
				dataStream = new MemoryStream(array);
			}
			else
			{
				dataStream = stream;
			}
		}

		private void ActualizeVirtualPosition()
		{
			if (virtualPosition != -1)
			{
				if (virtualPosition > dataStream.Length)
				{
					dataStream.SetLength(virtualPosition);
				}
				dataStream.Position = virtualPosition;
				virtualPosition = -1L;
			}
		}

		public virtual UnsafeNativeMethods.IStream Clone()
		{
			NotImplemented();
			return null;
		}

		public virtual void Commit(int grfCommitFlags)
		{
			dataStream.Flush();
			ActualizeVirtualPosition();
		}

		[SecurityPermission(SecurityAction.Assert, Flags = SecurityPermissionFlag.UnmanagedCode)]
		[UIPermission(SecurityAction.Demand, Window = UIPermissionWindow.AllWindows)]
		public virtual long CopyTo(UnsafeNativeMethods.IStream pstm, long cb, long[] pcbRead)
		{
			int num = 4096;
			IntPtr intPtr = Marshal.AllocHGlobal(num);
			if (intPtr == IntPtr.Zero)
			{
				throw new OutOfMemoryException();
			}
			long num2 = 0L;
			try
			{
				int num4;
				for (; num2 < cb; num2 += num4)
				{
					int num3 = num;
					if (num2 + num3 > cb)
					{
						num3 = (int)(cb - num2);
					}
					num4 = Read(intPtr, num3);
					if (num4 != 0)
					{
						if (pstm.Write(intPtr, num4) != num4)
						{
							throw EFail("Wrote an incorrect number of bytes");
						}
						continue;
					}
					break;
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (pcbRead != null && pcbRead.Length > 0)
			{
				pcbRead[0] = num2;
			}
			return num2;
		}

		public virtual Stream GetDataStream()
		{
			return dataStream;
		}

		public virtual void LockRegion(long libOffset, long cb, int dwLockType)
		{
		}

		protected static ExternalException EFail(string msg)
		{
			throw new ExternalException(msg, -2147467259);
		}

		protected static void NotImplemented()
		{
			throw new ExternalException(SR.GetString("NotImplemented"), -2147467263);
		}

		public virtual int Read(IntPtr buf, int length)
		{
			byte[] array = new byte[length];
			int result = Read(array, length);
			Marshal.Copy(array, 0, buf, length);
			return result;
		}

		public virtual int Read(byte[] buffer, int length)
		{
			ActualizeVirtualPosition();
			return dataStream.Read(buffer, 0, length);
		}

		public virtual void Revert()
		{
			NotImplemented();
		}

		public virtual long Seek(long offset, int origin)
		{
			long position = virtualPosition;
			if (virtualPosition == -1)
			{
				position = dataStream.Position;
			}
			long length = dataStream.Length;
			switch (origin)
			{
			case 0:
				if (offset <= length)
				{
					dataStream.Position = offset;
					virtualPosition = -1L;
				}
				else
				{
					virtualPosition = offset;
				}
				break;
			case 2:
				if (offset <= 0)
				{
					dataStream.Position = length + offset;
					virtualPosition = -1L;
				}
				else
				{
					virtualPosition = length + offset;
				}
				break;
			case 1:
				if (offset + position <= length)
				{
					dataStream.Position = position + offset;
					virtualPosition = -1L;
				}
				else
				{
					virtualPosition = offset + position;
				}
				break;
			}
			if (virtualPosition != -1)
			{
				return virtualPosition;
			}
			return dataStream.Position;
		}

		public virtual void SetSize(long value)
		{
			dataStream.SetLength(value);
		}

		public void Stat(IntPtr pstatstg, int grfStatFlag)
		{
			STATSTG sTATSTG = new STATSTG();
			sTATSTG.cbSize = dataStream.Length;
			Marshal.StructureToPtr(sTATSTG, pstatstg, fDeleteOld: true);
		}

		public virtual void UnlockRegion(long libOffset, long cb, int dwLockType)
		{
		}

		public virtual int Write(IntPtr buf, int length)
		{
			byte[] array = new byte[length];
			Marshal.Copy(buf, array, 0, length);
			return Write(array, length);
		}

		public virtual int Write(byte[] buffer, int length)
		{
			ActualizeVirtualPosition();
			dataStream.Write(buffer, 0, length);
			return length;
		}
	}
}
namespace System.Drawing.Drawing2D
{
	public sealed class GraphicsContainer : MarshalByRefObject
	{
		internal int nativeGraphicsContainer;

		internal GraphicsContainer(int graphicsContainer)
		{
			nativeGraphicsContainer = graphicsContainer;
		}
	}
	public sealed class GraphicsPath : MarshalByRefObject, ICloneable, IDisposable
	{
		internal IntPtr nativePath;

		public FillMode FillMode
		{
			get
			{
				int fillmode = 0;
				int num = SafeNativeMethods.Gdip.GdipGetPathFillMode(new HandleRef(this, nativePath), out fillmode);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return (FillMode)fillmode;
			}
			set
			{
				if (!ClientUtils.IsEnumValid(value, (int)value, 0, 1))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(FillMode));
				}
				int num = SafeNativeMethods.Gdip.GdipSetPathFillMode(new HandleRef(this, nativePath), (int)value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		public PathData PathData => _GetPathData();

		public int PointCount
		{
			get
			{
				int count = 0;
				int num = SafeNativeMethods.Gdip.GdipGetPointCount(new HandleRef(this, nativePath), out count);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return count;
			}
		}

		public byte[] PathTypes
		{
			get
			{
				int pointCount = PointCount;
				byte[] array = new byte[pointCount];
				int num = SafeNativeMethods.Gdip.GdipGetPathTypes(new HandleRef(this, nativePath), array, pointCount);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return array;
			}
		}

		public PointF[] PathPoints
		{
			get
			{
				int pointCount = PointCount;
				int num = Marshal.SizeOf(typeof(GPPOINTF));
				IntPtr intPtr = Marshal.AllocHGlobal(checked(pointCount * num));
				try
				{
					int num2 = SafeNativeMethods.Gdip.GdipGetPathPoints(new HandleRef(this, nativePath), new HandleRef(null, intPtr), pointCount);
					if (num2 != 0)
					{
						throw SafeNativeMethods.Gdip.StatusException(num2);
					}
					return SafeNativeMethods.Gdip.ConvertGPPOINTFArrayF(intPtr, pointCount);
				}
				finally
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
		}

		public GraphicsPath()
			: this(FillMode.Alternate)
		{
		}

		public GraphicsPath(FillMode fillMode)
		{
			IntPtr path = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreatePath((int)fillMode, out path);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			nativePath = path;
		}

		public GraphicsPath(PointF[] pts, byte[] types)
			: this(pts, types, FillMode.Alternate)
		{
		}

		public GraphicsPath(PointF[] pts, byte[] types, FillMode fillMode)
		{
			if (pts == null)
			{
				throw new ArgumentNullException("pts");
			}
			IntPtr path = IntPtr.Zero;
			if (pts.Length != types.Length)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			int num = types.Length;
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(pts);
			IntPtr intPtr2 = Marshal.AllocHGlobal(num);
			try
			{
				Marshal.Copy(types, 0, intPtr2, num);
				int num2 = SafeNativeMethods.Gdip.GdipCreatePath2(new HandleRef(null, intPtr), new HandleRef(null, intPtr2), num, (int)fillMode, out path);
				if (num2 != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num2);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
				Marshal.FreeHGlobal(intPtr2);
			}
			nativePath = path;
		}

		public GraphicsPath(Point[] pts, byte[] types)
			: this(pts, types, FillMode.Alternate)
		{
		}

		public GraphicsPath(Point[] pts, byte[] types, FillMode fillMode)
		{
			if (pts == null)
			{
				throw new ArgumentNullException("pts");
			}
			IntPtr path = IntPtr.Zero;
			if (pts.Length != types.Length)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			int num = types.Length;
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(pts);
			IntPtr intPtr2 = Marshal.AllocHGlobal(num);
			try
			{
				Marshal.Copy(types, 0, intPtr2, num);
				int num2 = SafeNativeMethods.Gdip.GdipCreatePath2I(new HandleRef(null, intPtr), new HandleRef(null, intPtr2), num, (int)fillMode, out path);
				if (num2 != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num2);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
				Marshal.FreeHGlobal(intPtr2);
			}
			nativePath = path;
		}

		public object Clone()
		{
			IntPtr clonepath = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipClonePath(new HandleRef(this, nativePath), out clonepath);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new GraphicsPath(clonepath, 0);
		}

		private GraphicsPath(IntPtr nativePath, int extra)
		{
			if (nativePath == IntPtr.Zero)
			{
				throw new ArgumentNullException("nativePath");
			}
			this.nativePath = nativePath;
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		private void Dispose(bool disposing)
		{
			if (!(nativePath != IntPtr.Zero))
			{
				return;
			}
			try
			{
				SafeNativeMethods.Gdip.GdipDeletePath(new HandleRef(this, nativePath));
			}
			catch (Exception ex)
			{
				if (ClientUtils.IsSecurityOrCriticalException(ex))
				{
					throw;
				}
			}
			finally
			{
				nativePath = IntPtr.Zero;
			}
		}

		~GraphicsPath()
		{
			Dispose(disposing: false);
		}

		public void Reset()
		{
			int num = SafeNativeMethods.Gdip.GdipResetPath(new HandleRef(this, nativePath));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private PathData _GetPathData()
		{
			int num = Marshal.SizeOf(typeof(GPPOINTF));
			int pointCount = PointCount;
			PathData pathData = new PathData();
			pathData.Types = new byte[pointCount];
			IntPtr intPtr = Marshal.AllocHGlobal(3 * IntPtr.Size);
			IntPtr intPtr2 = Marshal.AllocHGlobal(checked(num * pointCount));
			try
			{
				GCHandle gCHandle = GCHandle.Alloc(pathData.Types, GCHandleType.Pinned);
				try
				{
					IntPtr intPtr3 = gCHandle.AddrOfPinnedObject();
					Marshal.StructureToPtr(pointCount, intPtr, fDeleteOld: false);
					Marshal.StructureToPtr(intPtr2, (IntPtr)((long)intPtr + IntPtr.Size), fDeleteOld: false);
					Marshal.StructureToPtr(intPtr3, (IntPtr)((long)intPtr + 2 * IntPtr.Size), fDeleteOld: false);
					int num2 = SafeNativeMethods.Gdip.GdipGetPathData(new HandleRef(this, nativePath), intPtr);
					if (num2 != 0)
					{
						throw SafeNativeMethods.Gdip.StatusException(num2);
					}
					pathData.Points = SafeNativeMethods.Gdip.ConvertGPPOINTFArrayF(intPtr2, pointCount);
					return pathData;
				}
				finally
				{
					gCHandle.Free();
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
				Marshal.FreeHGlobal(intPtr2);
			}
		}

		public void StartFigure()
		{
			int num = SafeNativeMethods.Gdip.GdipStartPathFigure(new HandleRef(this, nativePath));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void CloseFigure()
		{
			int num = SafeNativeMethods.Gdip.GdipClosePathFigure(new HandleRef(this, nativePath));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void CloseAllFigures()
		{
			int num = SafeNativeMethods.Gdip.GdipClosePathFigures(new HandleRef(this, nativePath));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void SetMarkers()
		{
			int num = SafeNativeMethods.Gdip.GdipSetPathMarker(new HandleRef(this, nativePath));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void ClearMarkers()
		{
			int num = SafeNativeMethods.Gdip.GdipClearPathMarkers(new HandleRef(this, nativePath));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void Reverse()
		{
			int num = SafeNativeMethods.Gdip.GdipReversePath(new HandleRef(this, nativePath));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public PointF GetLastPoint()
		{
			GPPOINTF gPPOINTF = new GPPOINTF();
			int num = SafeNativeMethods.Gdip.GdipGetPathLastPoint(new HandleRef(this, nativePath), gPPOINTF);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return gPPOINTF.ToPoint();
		}

		public bool IsVisible(float x, float y)
		{
			return IsVisible(new PointF(x, y), null);
		}

		public bool IsVisible(PointF point)
		{
			return IsVisible(point, null);
		}

		public bool IsVisible(float x, float y, Graphics graphics)
		{
			return IsVisible(new PointF(x, y), graphics);
		}

		public bool IsVisible(PointF pt, Graphics graphics)
		{
			int boolean;
			int num = SafeNativeMethods.Gdip.GdipIsVisiblePathPoint(new HandleRef(this, nativePath), pt.X, pt.Y, new HandleRef(graphics, graphics?.NativeGraphics ?? IntPtr.Zero), out boolean);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return boolean != 0;
		}

		public bool IsVisible(int x, int y)
		{
			return IsVisible(new Point(x, y), null);
		}

		public bool IsVisible(Point point)
		{
			return IsVisible(point, null);
		}

		public bool IsVisible(int x, int y, Graphics graphics)
		{
			return IsVisible(new Point(x, y), graphics);
		}

		public bool IsVisible(Point pt, Graphics graphics)
		{
			int boolean;
			int num = SafeNativeMethods.Gdip.GdipIsVisiblePathPointI(new HandleRef(this, nativePath), pt.X, pt.Y, new HandleRef(graphics, graphics?.NativeGraphics ?? IntPtr.Zero), out boolean);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return boolean != 0;
		}

		public bool IsOutlineVisible(float x, float y, Pen pen)
		{
			return IsOutlineVisible(new PointF(x, y), pen, null);
		}

		public bool IsOutlineVisible(PointF point, Pen pen)
		{
			return IsOutlineVisible(point, pen, null);
		}

		public bool IsOutlineVisible(float x, float y, Pen pen, Graphics graphics)
		{
			return IsOutlineVisible(new PointF(x, y), pen, graphics);
		}

		public bool IsOutlineVisible(PointF pt, Pen pen, Graphics graphics)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			int boolean;
			int num = SafeNativeMethods.Gdip.GdipIsOutlineVisiblePathPoint(new HandleRef(this, nativePath), pt.X, pt.Y, new HandleRef(pen, pen.NativePen), new HandleRef(graphics, graphics?.NativeGraphics ?? IntPtr.Zero), out boolean);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return boolean != 0;
		}

		public bool IsOutlineVisible(int x, int y, Pen pen)
		{
			return IsOutlineVisible(new Point(x, y), pen, null);
		}

		public bool IsOutlineVisible(Point point, Pen pen)
		{
			return IsOutlineVisible(point, pen, null);
		}

		public bool IsOutlineVisible(int x, int y, Pen pen, Graphics graphics)
		{
			return IsOutlineVisible(new Point(x, y), pen, graphics);
		}

		public bool IsOutlineVisible(Point pt, Pen pen, Graphics graphics)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			int boolean;
			int num = SafeNativeMethods.Gdip.GdipIsOutlineVisiblePathPointI(new HandleRef(this, nativePath), pt.X, pt.Y, new HandleRef(pen, pen.NativePen), new HandleRef(graphics, graphics?.NativeGraphics ?? IntPtr.Zero), out boolean);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return boolean != 0;
		}

		public void AddLine(PointF pt1, PointF pt2)
		{
			AddLine(pt1.X, pt1.Y, pt2.X, pt2.Y);
		}

		public void AddLine(float x1, float y1, float x2, float y2)
		{
			int num = SafeNativeMethods.Gdip.GdipAddPathLine(new HandleRef(this, nativePath), x1, y1, x2, y2);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void AddLines(PointF[] points)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipAddPathLine2(new HandleRef(this, nativePath), new HandleRef(null, intPtr), points.Length);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		public void AddLine(Point pt1, Point pt2)
		{
			AddLine(pt1.X, pt1.Y, pt2.X, pt2.Y);
		}

		public void AddLine(int x1, int y1, int x2, int y2)
		{
			int num = SafeNativeMethods.Gdip.GdipAddPathLineI(new HandleRef(this, nativePath), x1, y1, x2, y2);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void AddLines(Point[] points)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipAddPathLine2I(new HandleRef(this, nativePath), new HandleRef(null, intPtr), points.Length);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		public void AddArc(RectangleF rect, float startAngle, float sweepAngle)
		{
			AddArc(rect.X, rect.Y, rect.Width, rect.Height, startAngle, sweepAngle);
		}

		public void AddArc(float x, float y, float width, float height, float startAngle, float sweepAngle)
		{
			int num = SafeNativeMethods.Gdip.GdipAddPathArc(new HandleRef(this, nativePath), x, y, width, height, startAngle, sweepAngle);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void AddArc(Rectangle rect, float startAngle, float sweepAngle)
		{
			AddArc(rect.X, rect.Y, rect.Width, rect.Height, startAngle, sweepAngle);
		}

		public void AddArc(int x, int y, int width, int height, float startAngle, float sweepAngle)
		{
			int num = SafeNativeMethods.Gdip.GdipAddPathArcI(new HandleRef(this, nativePath), x, y, width, height, startAngle, sweepAngle);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void AddBezier(PointF pt1, PointF pt2, PointF pt3, PointF pt4)
		{
			AddBezier(pt1.X, pt1.Y, pt2.X, pt2.Y, pt3.X, pt3.Y, pt4.X, pt4.Y);
		}

		public void AddBezier(float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4)
		{
			int num = SafeNativeMethods.Gdip.GdipAddPathBezier(new HandleRef(this, nativePath), x1, y1, x2, y2, x3, y3, x4, y4);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void AddBeziers(PointF[] points)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipAddPathBeziers(new HandleRef(this, nativePath), new HandleRef(null, intPtr), points.Length);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		public void AddBezier(Point pt1, Point pt2, Point pt3, Point pt4)
		{
			AddBezier(pt1.X, pt1.Y, pt2.X, pt2.Y, pt3.X, pt3.Y, pt4.X, pt4.Y);
		}

		public void AddBezier(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
		{
			int num = SafeNativeMethods.Gdip.GdipAddPathBezierI(new HandleRef(this, nativePath), x1, y1, x2, y2, x3, y3, x4, y4);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void AddBeziers(params Point[] points)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipAddPathBeziersI(new HandleRef(this, nativePath), new HandleRef(null, intPtr), points.Length);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		public void AddCurve(PointF[] points)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipAddPathCurve(new HandleRef(this, nativePath), new HandleRef(null, intPtr), points.Length);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		public void AddCurve(PointF[] points, float tension)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipAddPathCurve2(new HandleRef(this, nativePath), new HandleRef(null, intPtr), points.Length, tension);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		public void AddCurve(PointF[] points, int offset, int numberOfSegments, float tension)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipAddPathCurve3(new HandleRef(this, nativePath), new HandleRef(null, intPtr), points.Length, offset, numberOfSegments, tension);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		public void AddCurve(Point[] points)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipAddPathCurveI(new HandleRef(this, nativePath), new HandleRef(null, intPtr), points.Length);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		public void AddCurve(Point[] points, float tension)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipAddPathCurve2I(new HandleRef(this, nativePath), new HandleRef(null, intPtr), points.Length, tension);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		public void AddCurve(Point[] points, int offset, int numberOfSegments, float tension)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipAddPathCurve3I(new HandleRef(this, nativePath), new HandleRef(null, intPtr), points.Length, offset, numberOfSegments, tension);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		public void AddClosedCurve(PointF[] points)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipAddPathClosedCurve(new HandleRef(this, nativePath), new HandleRef(null, intPtr), points.Length);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		public void AddClosedCurve(PointF[] points, float tension)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipAddPathClosedCurve2(new HandleRef(this, nativePath), new HandleRef(null, intPtr), points.Length, tension);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		public void AddClosedCurve(Point[] points)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipAddPathClosedCurveI(new HandleRef(this, nativePath), new HandleRef(null, intPtr), points.Length);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		public void AddClosedCurve(Point[] points, float tension)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipAddPathClosedCurve2I(new HandleRef(this, nativePath), new HandleRef(null, intPtr), points.Length, tension);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		public void AddRectangle(RectangleF rect)
		{
			int num = SafeNativeMethods.Gdip.GdipAddPathRectangle(new HandleRef(this, nativePath), rect.X, rect.Y, rect.Width, rect.Height);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void AddRectangles(RectangleF[] rects)
		{
			if (rects == null)
			{
				throw new ArgumentNullException("rects");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertRectangleToMemory(rects);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipAddPathRectangles(new HandleRef(this, nativePath), new HandleRef(null, intPtr), rects.Length);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		public void AddRectangle(Rectangle rect)
		{
			int num = SafeNativeMethods.Gdip.GdipAddPathRectangleI(new HandleRef(this, nativePath), rect.X, rect.Y, rect.Width, rect.Height);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void AddRectangles(Rectangle[] rects)
		{
			if (rects == null)
			{
				throw new ArgumentNullException("rects");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertRectangleToMemory(rects);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipAddPathRectanglesI(new HandleRef(this, nativePath), new HandleRef(null, intPtr), rects.Length);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		public void AddEllipse(RectangleF rect)
		{
			AddEllipse(rect.X, rect.Y, rect.Width, rect.Height);
		}

		public void AddEllipse(float x, float y, float width, float height)
		{
			int num = SafeNativeMethods.Gdip.GdipAddPathEllipse(new HandleRef(this, nativePath), x, y, width, height);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void AddEllipse(Rectangle rect)
		{
			AddEllipse(rect.X, rect.Y, rect.Width, rect.Height);
		}

		public void AddEllipse(int x, int y, int width, int height)
		{
			int num = SafeNativeMethods.Gdip.GdipAddPathEllipseI(new HandleRef(this, nativePath), x, y, width, height);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void AddPie(Rectangle rect, float startAngle, float sweepAngle)
		{
			AddPie(rect.X, rect.Y, rect.Width, rect.Height, startAngle, sweepAngle);
		}

		public void AddPie(float x, float y, float width, float height, float startAngle, float sweepAngle)
		{
			int num = SafeNativeMethods.Gdip.GdipAddPathPie(new HandleRef(this, nativePath), x, y, width, height, startAngle, sweepAngle);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void AddPie(int x, int y, int width, int height, float startAngle, float sweepAngle)
		{
			int num = SafeNativeMethods.Gdip.GdipAddPathPieI(new HandleRef(this, nativePath), x, y, width, height, startAngle, sweepAngle);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void AddPolygon(PointF[] points)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipAddPathPolygon(new HandleRef(this, nativePath), new HandleRef(null, intPtr), points.Length);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		public void AddPolygon(Point[] points)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipAddPathPolygonI(new HandleRef(this, nativePath), new HandleRef(null, intPtr), points.Length);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		public void AddPath(GraphicsPath addingPath, bool connect)
		{
			if (addingPath == null)
			{
				throw new ArgumentNullException("addingPath");
			}
			int num = SafeNativeMethods.Gdip.GdipAddPathPath(new HandleRef(this, nativePath), new HandleRef(addingPath, addingPath.nativePath), connect);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void AddString(string s, FontFamily family, int style, float emSize, PointF origin, StringFormat format)
		{
			GPRECTF layoutRect = new GPRECTF(origin.X, origin.Y, 0f, 0f);
			int num = SafeNativeMethods.Gdip.GdipAddPathString(new HandleRef(this, nativePath), s, s.Length, new HandleRef(family, family?.NativeFamily ?? IntPtr.Zero), style, emSize, ref layoutRect, new HandleRef(format, format?.nativeFormat ?? IntPtr.Zero));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void AddString(string s, FontFamily family, int style, float emSize, Point origin, StringFormat format)
		{
			GPRECT layoutRect = new GPRECT(origin.X, origin.Y, 0, 0);
			int num = SafeNativeMethods.Gdip.GdipAddPathStringI(new HandleRef(this, nativePath), s, s.Length, new HandleRef(family, family?.NativeFamily ?? IntPtr.Zero), style, emSize, ref layoutRect, new HandleRef(format, format?.nativeFormat ?? IntPtr.Zero));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void AddString(string s, FontFamily family, int style, float emSize, RectangleF layoutRect, StringFormat format)
		{
			GPRECTF layoutRect2 = new GPRECTF(layoutRect);
			int num = SafeNativeMethods.Gdip.GdipAddPathString(new HandleRef(this, nativePath), s, s.Length, new HandleRef(family, family?.NativeFamily ?? IntPtr.Zero), style, emSize, ref layoutRect2, new HandleRef(format, format?.nativeFormat ?? IntPtr.Zero));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void AddString(string s, FontFamily family, int style, float emSize, Rectangle layoutRect, StringFormat format)
		{
			GPRECT layoutRect2 = new GPRECT(layoutRect);
			int num = SafeNativeMethods.Gdip.GdipAddPathStringI(new HandleRef(this, nativePath), s, s.Length, new HandleRef(family, family?.NativeFamily ?? IntPtr.Zero), style, emSize, ref layoutRect2, new HandleRef(format, format?.nativeFormat ?? IntPtr.Zero));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void Transform(Matrix matrix)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (!(matrix.nativeMatrix == IntPtr.Zero))
			{
				int num = SafeNativeMethods.Gdip.GdipTransformPath(new HandleRef(this, nativePath), new HandleRef(matrix, matrix.nativeMatrix));
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		public RectangleF GetBounds()
		{
			return GetBounds(null);
		}

		public RectangleF GetBounds(Matrix matrix)
		{
			return GetBounds(matrix, null);
		}

		public RectangleF GetBounds(Matrix matrix, Pen pen)
		{
			GPRECTF gprectf = default(GPRECTF);
			IntPtr handle = IntPtr.Zero;
			IntPtr handle2 = IntPtr.Zero;
			if (matrix != null)
			{
				handle = matrix.nativeMatrix;
			}
			if (pen != null)
			{
				handle2 = pen.NativePen;
			}
			int num = SafeNativeMethods.Gdip.GdipGetPathWorldBounds(new HandleRef(this, nativePath), ref gprectf, new HandleRef(matrix, handle), new HandleRef(pen, handle2));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return gprectf.ToRectangleF();
		}

		public void Flatten()
		{
			Flatten(null);
		}

		public void Flatten(Matrix matrix)
		{
			Flatten(matrix, 0.25f);
		}

		public void Flatten(Matrix matrix, float flatness)
		{
			int num = SafeNativeMethods.Gdip.GdipFlattenPath(new HandleRef(this, nativePath), new HandleRef(matrix, matrix?.nativeMatrix ?? IntPtr.Zero), flatness);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void Widen(Pen pen)
		{
			float flatness = 2f / 3f;
			Widen(pen, null, flatness);
		}

		public void Widen(Pen pen, Matrix matrix)
		{
			float flatness = 2f / 3f;
			Widen(pen, matrix, flatness);
		}

		public void Widen(Pen pen, Matrix matrix, float flatness)
		{
			IntPtr handle = matrix?.nativeMatrix ?? IntPtr.Zero;
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			SafeNativeMethods.Gdip.GdipGetPointCount(new HandleRef(this, nativePath), out var count);
			if (count != 0)
			{
				int num = SafeNativeMethods.Gdip.GdipWidenPath(new HandleRef(this, nativePath), new HandleRef(pen, pen.NativePen), new HandleRef(matrix, handle), flatness);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		public void Warp(PointF[] destPoints, RectangleF srcRect)
		{
			Warp(destPoints, srcRect, null);
		}

		public void Warp(PointF[] destPoints, RectangleF srcRect, Matrix matrix)
		{
			Warp(destPoints, srcRect, matrix, WarpMode.Perspective);
		}

		public void Warp(PointF[] destPoints, RectangleF srcRect, Matrix matrix, WarpMode warpMode)
		{
			Warp(destPoints, srcRect, matrix, warpMode, 0.25f);
		}

		public void Warp(PointF[] destPoints, RectangleF srcRect, Matrix matrix, WarpMode warpMode, float flatness)
		{
			if (destPoints == null)
			{
				throw new ArgumentNullException("destPoints");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(destPoints);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipWarpPath(new HandleRef(this, nativePath), new HandleRef(matrix, matrix?.nativeMatrix ?? IntPtr.Zero), new HandleRef(null, intPtr), destPoints.Length, srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, warpMode, flatness);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}
	}
	public sealed class GraphicsPathIterator : MarshalByRefObject, IDisposable
	{
		internal IntPtr nativeIter;

		public int Count
		{
			get
			{
				int count = 0;
				int num = SafeNativeMethods.Gdip.GdipPathIterGetCount(new HandleRef(this, nativeIter), out count);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return count;
			}
		}

		public int SubpathCount
		{
			get
			{
				int count = 0;
				int num = SafeNativeMethods.Gdip.GdipPathIterGetSubpathCount(new HandleRef(this, nativeIter), out count);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return count;
			}
		}

		public GraphicsPathIterator(GraphicsPath path)
		{
			IntPtr pathIter = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreatePathIter(out pathIter, new HandleRef(path, path?.nativePath ?? IntPtr.Zero));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			nativeIter = pathIter;
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		private void Dispose(bool disposing)
		{
			if (!(nativeIter != IntPtr.Zero))
			{
				return;
			}
			try
			{
				SafeNativeMethods.Gdip.GdipDeletePathIter(new HandleRef(this, nativeIter));
			}
			catch (Exception ex)
			{
				if (ClientUtils.IsSecurityOrCriticalException(ex))
				{
					throw;
				}
			}
			finally
			{
				nativeIter = IntPtr.Zero;
			}
		}

		~GraphicsPathIterator()
		{
			Dispose(disposing: false);
		}

		public int NextSubpath(out int startIndex, out int endIndex, out bool isClosed)
		{
			int resultCount = 0;
			int startIndex2 = 0;
			int endIndex2 = 0;
			int num = SafeNativeMethods.Gdip.GdipPathIterNextSubpath(new HandleRef(this, nativeIter), out resultCount, out startIndex2, out endIndex2, out isClosed);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			startIndex = startIndex2;
			endIndex = endIndex2;
			return resultCount;
		}

		public int NextSubpath(GraphicsPath path, out bool isClosed)
		{
			int resultCount = 0;
			int num = SafeNativeMethods.Gdip.GdipPathIterNextSubpathPath(new HandleRef(this, nativeIter), out resultCount, new HandleRef(path, path?.nativePath ?? IntPtr.Zero), out isClosed);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return resultCount;
		}

		public int NextPathType(out byte pathType, out int startIndex, out int endIndex)
		{
			int resultCount = 0;
			int num = SafeNativeMethods.Gdip.GdipPathIterNextPathType(new HandleRef(this, nativeIter), out resultCount, out pathType, out startIndex, out endIndex);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return resultCount;
		}

		public int NextMarker(out int startIndex, out int endIndex)
		{
			int resultCount = 0;
			int num = SafeNativeMethods.Gdip.GdipPathIterNextMarker(new HandleRef(this, nativeIter), out resultCount, out startIndex, out endIndex);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return resultCount;
		}

		public int NextMarker(GraphicsPath path)
		{
			int resultCount = 0;
			int num = SafeNativeMethods.Gdip.GdipPathIterNextMarkerPath(new HandleRef(this, nativeIter), out resultCount, new HandleRef(path, path?.nativePath ?? IntPtr.Zero));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return resultCount;
		}

		public bool HasCurve()
		{
			bool hasCurve = false;
			int num = SafeNativeMethods.Gdip.GdipPathIterHasCurve(new HandleRef(this, nativeIter), out hasCurve);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return hasCurve;
		}

		public void Rewind()
		{
			int num = SafeNativeMethods.Gdip.GdipPathIterRewind(new HandleRef(this, nativeIter));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public int Enumerate(ref PointF[] points, ref byte[] types)
		{
			if (points.Length != types.Length)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			int resultCount = 0;
			int num = Marshal.SizeOf(typeof(GPPOINTF));
			int num2 = points.Length;
			byte[] array = new byte[num2];
			IntPtr intPtr = Marshal.AllocHGlobal(checked(num2 * num));
			try
			{
				int num3 = SafeNativeMethods.Gdip.GdipPathIterEnumerate(new HandleRef(this, nativeIter), out resultCount, intPtr, array, num2);
				if (num3 != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num3);
				}
				if (resultCount < num2)
				{
					SafeNativeMethods.ZeroMemory((IntPtr)checked((long)intPtr + resultCount * num), (UIntPtr)(ulong)((num2 - resultCount) * num));
				}
				points = SafeNativeMethods.Gdip.ConvertGPPOINTFArrayF(intPtr, num2);
				array.CopyTo(types, 0);
				return resultCount;
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		public int CopyData(ref PointF[] points, ref byte[] types, int startIndex, int endIndex)
		{
			if (points.Length != types.Length || endIndex - startIndex + 1 > points.Length)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			int resultCount = 0;
			int num = Marshal.SizeOf(typeof(GPPOINTF));
			int num2 = points.Length;
			byte[] array = new byte[num2];
			IntPtr intPtr = Marshal.AllocHGlobal(checked(num2 * num));
			try
			{
				int num3 = SafeNativeMethods.Gdip.GdipPathIterCopyData(new HandleRef(this, nativeIter), out resultCount, intPtr, array, startIndex, endIndex);
				if (num3 != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num3);
				}
				if (resultCount < num2)
				{
					SafeNativeMethods.ZeroMemory((IntPtr)checked((long)intPtr + resultCount * num), (UIntPtr)(ulong)((num2 - resultCount) * num));
				}
				points = SafeNativeMethods.Gdip.ConvertGPPOINTFArrayF(intPtr, num2);
				array.CopyTo(types, 0);
				return resultCount;
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}
	}
	public sealed class GraphicsState : MarshalByRefObject
	{
		internal int nativeState;

		internal GraphicsState(int nativeState)
		{
			this.nativeState = nativeState;
		}
	}
	public sealed class HatchBrush : Brush
	{
		public HatchStyle HatchStyle
		{
			get
			{
				int hatchstyle = 0;
				int num = SafeNativeMethods.Gdip.GdipGetHatchStyle(new HandleRef(this, base.NativeBrush), out hatchstyle);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return (HatchStyle)hatchstyle;
			}
		}

		public Color ForegroundColor
		{
			get
			{
				int forecol;
				int num = SafeNativeMethods.Gdip.GdipGetHatchForegroundColor(new HandleRef(this, base.NativeBrush), out forecol);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return Color.FromArgb(forecol);
			}
		}

		public Color BackgroundColor
		{
			get
			{
				int backcol;
				int num = SafeNativeMethods.Gdip.GdipGetHatchBackgroundColor(new HandleRef(this, base.NativeBrush), out backcol);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return Color.FromArgb(backcol);
			}
		}

		public HatchBrush(HatchStyle hatchstyle, Color foreColor)
			: this(hatchstyle, foreColor, Color.FromArgb(-16777216))
		{
		}

		public HatchBrush(HatchStyle hatchstyle, Color foreColor, Color backColor)
		{
			IntPtr brush = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateHatchBrush((int)hatchstyle, foreColor.ToArgb(), backColor.ToArgb(), out brush);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeBrushInternal(brush);
		}

		internal HatchBrush(IntPtr nativeBrush)
		{
			SetNativeBrushInternal(nativeBrush);
		}

		public override object Clone()
		{
			IntPtr clonebrush = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCloneBrush(new HandleRef(this, base.NativeBrush), out clonebrush);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new HatchBrush(clonebrush);
		}
	}
	public enum HatchStyle
	{
		Horizontal = 0,
		Vertical = 1,
		ForwardDiagonal = 2,
		BackwardDiagonal = 3,
		Cross = 4,
		DiagonalCross = 5,
		Percent05 = 6,
		Percent10 = 7,
		Percent20 = 8,
		Percent25 = 9,
		Percent30 = 10,
		Percent40 = 11,
		Percent50 = 12,
		Percent60 = 13,
		Percent70 = 14,
		Percent75 = 15,
		Percent80 = 16,
		Percent90 = 17,
		LightDownwardDiagonal = 18,
		LightUpwardDiagonal = 19,
		DarkDownwardDiagonal = 20,
		DarkUpwardDiagonal = 21,
		WideDownwardDiagonal = 22,
		WideUpwardDiagonal = 23,
		LightVertical = 24,
		LightHorizontal = 25,
		NarrowVertical = 26,
		NarrowHorizontal = 27,
		DarkVertical = 28,
		DarkHorizontal = 29,
		DashedDownwardDiagonal = 30,
		DashedUpwardDiagonal = 31,
		DashedHorizontal = 32,
		DashedVertical = 33,
		SmallConfetti = 34,
		LargeConfetti = 35,
		ZigZag = 36,
		Wave = 37,
		DiagonalBrick = 38,
		HorizontalBrick = 39,
		Weave = 40,
		Plaid = 41,
		Divot = 42,
		DottedGrid = 43,
		DottedDiamond = 44,
		Shingle = 45,
		Trellis = 46,
		Sphere = 47,
		SmallGrid = 48,
		SmallCheckerBoard = 49,
		LargeCheckerBoard = 50,
		OutlinedDiamond = 51,
		SolidDiamond = 52,
		LargeGrid = 4,
		Min = 0,
		Max = 4
	}
}
namespace System.Drawing.Text
{
	public enum HotkeyPrefix
	{
		None,
		Show,
		Hide
	}
}
namespace System.Drawing.Imaging
{
	[StructLayout(LayoutKind.Sequential)]
	public sealed class ImageAttributes : ICloneable, IDisposable
	{
		internal IntPtr nativeImageAttributes;

		internal void SetNativeImageAttributes(IntPtr handle)
		{
			if (handle == IntPtr.Zero)
			{
				throw new ArgumentNullException("handle");
			}
			nativeImageAttributes = handle;
		}

		public ImageAttributes()
		{
			IntPtr imageattr = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateImageAttributes(out imageattr);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImageAttributes(imageattr);
		}

		internal ImageAttributes(IntPtr newNativeImageAttributes)
		{
			SetNativeImageAttributes(newNativeImageAttributes);
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		private void Dispose(bool disposing)
		{
			if (!(nativeImageAttributes != IntPtr.Zero))
			{
				return;
			}
			try
			{
				SafeNativeMethods.Gdip.GdipDisposeImageAttributes(new HandleRef(this, nativeImageAttributes));
			}
			catch (Exception ex)
			{
				if (ClientUtils.IsSecurityOrCriticalException(ex))
				{
					throw;
				}
			}
			finally
			{
				nativeImageAttributes = IntPtr.Zero;
			}
		}

		~ImageAttributes()
		{
			Dispose(disposing: false);
		}

		public object Clone()
		{
			IntPtr cloneImageattr = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCloneImageAttributes(new HandleRef(this, nativeImageAttributes), out cloneImageattr);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new ImageAttributes(cloneImageattr);
		}

		public void SetColorMatrix(ColorMatrix newColorMatrix)
		{
			SetColorMatrix(newColorMatrix, ColorMatrixFlag.Default, ColorAdjustType.Default);
		}

		public void SetColorMatrix(ColorMatrix newColorMatrix, ColorMatrixFlag flags)
		{
			SetColorMatrix(newColorMatrix, flags, ColorAdjustType.Default);
		}

		public void SetColorMatrix(ColorMatrix newColorMatrix, ColorMatrixFlag mode, ColorAdjustType type)
		{
			int num = SafeNativeMethods.Gdip.GdipSetImageAttributesColorMatrix(new HandleRef(this, nativeImageAttributes), type, enableFlag: true, newColorMatrix, null, mode);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void ClearColorMatrix()
		{
			ClearColorMatrix(ColorAdjustType.Default);
		}

		public void ClearColorMatrix(ColorAdjustType type)
		{
			int num = SafeNativeMethods.Gdip.GdipSetImageAttributesColorMatrix(new HandleRef(this, nativeImageAttributes), type, enableFlag: false, null, null, ColorMatrixFlag.Default);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void SetColorMatrices(ColorMatrix newColorMatrix, ColorMatrix grayMatrix)
		{
			SetColorMatrices(newColorMatrix, grayMatrix, ColorMatrixFlag.Default, ColorAdjustType.Default);
		}

		public void SetColorMatrices(ColorMatrix newColorMatrix, ColorMatrix grayMatrix, ColorMatrixFlag flags)
		{
			SetColorMatrices(newColorMatrix, grayMatrix, flags, ColorAdjustType.Default);
		}

		public void SetColorMatrices(ColorMatrix newColorMatrix, ColorMatrix grayMatrix, ColorMatrixFlag mode, ColorAdjustType type)
		{
			int num = SafeNativeMethods.Gdip.GdipSetImageAttributesColorMatrix(new HandleRef(this, nativeImageAttributes), type, enableFlag: true, newColorMatrix, grayMatrix, mode);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void SetThreshold(float threshold)
		{
			SetThreshold(threshold, ColorAdjustType.Default);
		}

		public void SetThreshold(float threshold, ColorAdjustType type)
		{
			int num = SafeNativeMethods.Gdip.GdipSetImageAttributesThreshold(new HandleRef(this, nativeImageAttributes), type, enableFlag: true, threshold);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void ClearThreshold()
		{
			ClearThreshold(ColorAdjustType.Default);
		}

		public void ClearThreshold(ColorAdjustType type)
		{
			int num = SafeNativeMethods.Gdip.GdipSetImageAttributesThreshold(new HandleRef(this, nativeImageAttributes), type, enableFlag: false, 0f);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void SetGamma(float gamma)
		{
			SetGamma(gamma, ColorAdjustType.Default);
		}

		public void SetGamma(float gamma, ColorAdjustType type)
		{
			int num = SafeNativeMethods.Gdip.GdipSetImageAttributesGamma(new HandleRef(this, nativeImageAttributes), type, enableFlag: true, gamma);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void ClearGamma()
		{
			ClearGamma(ColorAdjustType.Default);
		}

		public void ClearGamma(ColorAdjustType type)
		{
			int num = SafeNativeMethods.Gdip.GdipSetImageAttributesGamma(new HandleRef(this, nativeImageAttributes), type, enableFlag: false, 0f);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void SetNoOp()
		{
			SetNoOp(ColorAdjustType.Default);
		}

		public void SetNoOp(ColorAdjustType type)
		{
			int num = SafeNativeMethods.Gdip.GdipSetImageAttributesNoOp(new HandleRef(this, nativeImageAttributes), type, enableFlag: true);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void ClearNoOp()
		{
			ClearNoOp(ColorAdjustType.Default);
		}

		public void ClearNoOp(ColorAdjustType type)
		{
			int num = SafeNativeMethods.Gdip.GdipSetImageAttributesNoOp(new HandleRef(this, nativeImageAttributes), type, enableFlag: false);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void SetColorKey(Color colorLow, Color colorHigh)
		{
			SetColorKey(colorLow, colorHigh, ColorAdjustType.Default);
		}

		public void SetColorKey(Color colorLow, Color colorHigh, ColorAdjustType type)
		{
			int colorLow2 = colorLow.ToArgb();
			int colorHigh2 = colorHigh.ToArgb();
			int num = SafeNativeMethods.Gdip.GdipSetImageAttributesColorKeys(new HandleRef(this, nativeImageAttributes), type, enableFlag: true, colorLow2, colorHigh2);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void ClearColorKey()
		{
			ClearColorKey(ColorAdjustType.Default);
		}

		public void ClearColorKey(ColorAdjustType type)
		{
			int num = 0;
			int num2 = SafeNativeMethods.Gdip.GdipSetImageAttributesColorKeys(new HandleRef(this, nativeImageAttributes), type, enableFlag: false, num, num);
			if (num2 != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num2);
			}
		}

		public void SetOutputChannel(ColorChannelFlag flags)
		{
			SetOutputChannel(flags, ColorAdjustType.Default);
		}

		public void SetOutputChannel(ColorChannelFlag flags, ColorAdjustType type)
		{
			int num = SafeNativeMethods.Gdip.GdipSetImageAttributesOutputChannel(new HandleRef(this, nativeImageAttributes), type, enableFlag: true, flags);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void ClearOutputChannel()
		{
			ClearOutputChannel(ColorAdjustType.Default);
		}

		public void ClearOutputChannel(ColorAdjustType type)
		{
			int num = SafeNativeMethods.Gdip.GdipSetImageAttributesOutputChannel(new HandleRef(this, nativeImageAttributes), type, enableFlag: false, ColorChannelFlag.ColorChannelLast);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void SetOutputChannelColorProfile(string colorProfileFilename)
		{
			SetOutputChannelColorProfile(colorProfileFilename, ColorAdjustType.Default);
		}

		public void SetOutputChannelColorProfile(string colorProfileFilename, ColorAdjustType type)
		{
			IntSecurity.DemandReadFileIO(colorProfileFilename);
			int num = SafeNativeMethods.Gdip.GdipSetImageAttributesOutputChannelColorProfile(new HandleRef(this, nativeImageAttributes), type, enableFlag: true, colorProfileFilename);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void ClearOutputChannelColorProfile()
		{
			ClearOutputChannel(ColorAdjustType.Default);
		}

		public void ClearOutputChannelColorProfile(ColorAdjustType type)
		{
			int num = SafeNativeMethods.Gdip.GdipSetImageAttributesOutputChannel(new HandleRef(this, nativeImageAttributes), type, enableFlag: false, ColorChannelFlag.ColorChannelLast);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void SetRemapTable(ColorMap[] map)
		{
			SetRemapTable(map, ColorAdjustType.Default);
		}

		public void SetRemapTable(ColorMap[] map, ColorAdjustType type)
		{
			int num = 0;
			int num2 = map.Length;
			int num3 = 4;
			IntPtr intPtr = Marshal.AllocHGlobal(checked(num2 * num3 * 2));
			try
			{
				for (num = 0; num < num2; num++)
				{
					Marshal.StructureToPtr(map[num].OldColor.ToArgb(), (IntPtr)((long)intPtr + num * num3 * 2), fDeleteOld: false);
					Marshal.StructureToPtr(map[num].NewColor.ToArgb(), (IntPtr)((long)intPtr + num * num3 * 2 + num3), fDeleteOld: false);
				}
				int num4 = SafeNativeMethods.Gdip.GdipSetImageAttributesRemapTable(new HandleRef(this, nativeImageAttributes), type, enableFlag: true, num2, new HandleRef(null, intPtr));
				if (num4 != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num4);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		public void ClearRemapTable()
		{
			ClearRemapTable(ColorAdjustType.Default);
		}

		public void ClearRemapTable(ColorAdjustType type)
		{
			int num = SafeNativeMethods.Gdip.GdipSetImageAttributesRemapTable(new HandleRef(this, nativeImageAttributes), type, enableFlag: false, 0, NativeMethods.NullHandleRef);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void SetBrushRemapTable(ColorMap[] map)
		{
			SetRemapTable(map, ColorAdjustType.Brush);
		}

		public void ClearBrushRemapTable()
		{
			ClearRemapTable(ColorAdjustType.Brush);
		}

		public void SetWrapMode(WrapMode mode)
		{
			SetWrapMode(mode, default(Color), clamp: false);
		}

		public void SetWrapMode(WrapMode mode, Color color)
		{
			SetWrapMode(mode, color, clamp: false);
		}

		public void SetWrapMode(WrapMode mode, Color color, bool clamp)
		{
			int num = SafeNativeMethods.Gdip.GdipSetImageAttributesWrapMode(new HandleRef(this, nativeImageAttributes), (int)mode, color.ToArgb(), clamp);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void GetAdjustedPalette(ColorPalette palette, ColorAdjustType type)
		{
			IntPtr intPtr = palette.ConvertToMemory();
			try
			{
				int num = SafeNativeMethods.Gdip.GdipGetImageAttributesAdjustedPalette(new HandleRef(this, nativeImageAttributes), new HandleRef(null, intPtr), type);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				palette.ConvertFromMemory(intPtr);
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
		}
	}
	[Flags]
	public enum ImageCodecFlags
	{
		Encoder = 1,
		Decoder = 2,
		SupportBitmap = 4,
		SupportVector = 8,
		SeekableEncode = 0x10,
		BlockingDecode = 0x20,
		Builtin = 0x10000,
		System = 0x20000,
		User = 0x40000
	}
	public sealed class ImageCodecInfo
	{
		private Guid clsid;

		private Guid formatID;

		private string codecName;

		private string dllName;

		private string formatDescription;

		private string filenameExtension;

		private string mimeType;

		private ImageCodecFlags flags;

		private int version;

		private byte[][] signaturePatterns;

		private byte[][] signatureMasks;

		public Guid Clsid
		{
			get
			{
				return clsid;
			}
			set
			{
				clsid = value;
			}
		}

		public Guid FormatID
		{
			get
			{
				return formatID;
			}
			set
			{
				formatID = value;
			}
		}

		public string CodecName
		{
			get
			{
				return codecName;
			}
			set
			{
				codecName = value;
			}
		}

		public string DllName
		{
			get
			{
				if (dllName != null)
				{
					new FileIOPermission(FileIOPermissionAccess.PathDiscovery, dllName).Demand();
				}
				return dllName;
			}
			set
			{
				if (value != null)
				{
					new FileIOPermission(FileIOPermissionAccess.PathDiscovery, value).Demand();
				}
				dllName = value;
			}
		}

		public string FormatDescription
		{
			get
			{
				return formatDescription;
			}
			set
			{
				formatDescription = value;
			}
		}

		public string FilenameExtension
		{
			get
			{
				return filenameExtension;
			}
			set
			{
				filenameExtension = value;
			}
		}

		public string MimeType
		{
			get
			{
				return mimeType;
			}
			set
			{
				mimeType = value;
			}
		}

		public ImageCodecFlags Flags
		{
			get
			{
				return flags;
			}
			set
			{
				flags = value;
			}
		}

		public int Version
		{
			get
			{
				return version;
			}
			set
			{
				version = value;
			}
		}

		[CLSCompliant(false)]
		public byte[][] SignaturePatterns
		{
			get
			{
				return signaturePatterns;
			}
			set
			{
				signaturePatterns = value;
			}
		}

		[CLSCompliant(false)]
		public byte[][] SignatureMasks
		{
			get
			{
				return signatureMasks;
			}
			set
			{
				signatureMasks = value;
			}
		}

		internal ImageCodecInfo()
		{
		}

		public static ImageCodecInfo[] GetImageDecoders()
		{
			int num = SafeNativeMethods.Gdip.GdipGetImageDecodersSize(out var numDecoders, out var size);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			IntPtr intPtr = Marshal.AllocHGlobal(size);
			try
			{
				num = SafeNativeMethods.Gdip.GdipGetImageDecoders(numDecoders, size, intPtr);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return ConvertFromMemory(intPtr, numDecoders);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		public static ImageCodecInfo[] GetImageEncoders()
		{
			int num = SafeNativeMethods.Gdip.GdipGetImageEncodersSize(out var numEncoders, out var size);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			IntPtr intPtr = Marshal.AllocHGlobal(size);
			try
			{
				num = SafeNativeMethods.Gdip.GdipGetImageEncoders(numEncoders, size, intPtr);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return ConvertFromMemory(intPtr, numEncoders);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		private static ImageCodecInfo[] ConvertFromMemory(IntPtr memoryStart, int numCodecs)
		{
			ImageCodecInfo[] array = new ImageCodecInfo[numCodecs];
			for (int i = 0; i < numCodecs; i++)
			{
				IntPtr lparam = (IntPtr)((long)memoryStart + Marshal.SizeOf(typeof(ImageCodecInfoPrivate)) * i);
				ImageCodecInfoPrivate imageCodecInfoPrivate = new ImageCodecInfoPrivate();
				UnsafeNativeMethods.PtrToStructure(lparam, imageCodecInfoPrivate);
				array[i] = new ImageCodecInfo();
				array[i].Clsid = imageCodecInfoPrivate.Clsid;
				array[i].FormatID = imageCodecInfoPrivate.FormatID;
				array[i].CodecName = Marshal.PtrToStringUni(imageCodecInfoPrivate.CodecName);
				array[i].DllName = Marshal.PtrToStringUni(imageCodecInfoPrivate.DllName);
				array[i].FormatDescription = Marshal.PtrToStringUni(imageCodecInfoPrivate.FormatDescription);
				array[i].FilenameExtension = Marshal.PtrToStringUni(imageCodecInfoPrivate.FilenameExtension);
				array[i].MimeType = Marshal.PtrToStringUni(imageCodecInfoPrivate.MimeType);
				array[i].Flags = (ImageCodecFlags)imageCodecInfoPrivate.Flags;
				array[i].Version = imageCodecInfoPrivate.Version;
				array[i].SignaturePatterns = new byte[imageCodecInfoPrivate.SigCount][];
				array[i].SignatureMasks = new byte[imageCodecInfoPrivate.SigCount][];
				for (int j = 0; j < imageCodecInfoPrivate.SigCount; j++)
				{
					array[i].SignaturePatterns[j] = new byte[imageCodecInfoPrivate.SigSize];
					array[i].SignatureMasks[j] = new byte[imageCodecInfoPrivate.SigSize];
					Marshal.Copy((IntPtr)((long)imageCodecInfoPrivate.SigMask + j * imageCodecInfoPrivate.SigSize), array[i].SignatureMasks[j], 0, imageCodecInfoPrivate.SigSize);
					Marshal.Copy((IntPtr)((long)imageCodecInfoPrivate.SigPattern + j * imageCodecInfoPrivate.SigSize), array[i].SignaturePatterns[j], 0, imageCodecInfoPrivate.SigSize);
				}
			}
			return array;
		}
	}
	[StructLayout(LayoutKind.Sequential, Pack = 8)]
	internal class ImageCodecInfoPrivate
	{
		[MarshalAs(UnmanagedType.Struct)]
		public Guid Clsid;

		[MarshalAs(UnmanagedType.Struct)]
		public Guid FormatID;

		public IntPtr CodecName = IntPtr.Zero;

		public IntPtr DllName = IntPtr.Zero;

		public IntPtr FormatDescription = IntPtr.Zero;

		public IntPtr FilenameExtension = IntPtr.Zero;

		public IntPtr MimeType = IntPtr.Zero;

		public int Flags;

		public int Version;

		public int SigCount;

		public int SigSize;

		public IntPtr SigPattern = IntPtr.Zero;

		public IntPtr SigMask = IntPtr.Zero;
	}
	[Flags]
	public enum ImageFlags
	{
		None = 0,
		Scalable = 1,
		HasAlpha = 2,
		HasTranslucent = 4,
		PartiallyScalable = 8,
		ColorSpaceRgb = 0x10,
		ColorSpaceCmyk = 0x20,
		ColorSpaceGray = 0x40,
		ColorSpaceYcbcr = 0x80,
		ColorSpaceYcck = 0x100,
		HasRealDpi = 0x1000,
		HasRealPixelSize = 0x2000,
		ReadOnly = 0x10000,
		Caching = 0x20000
	}
	[TypeConverter(typeof(ImageFormatConverter))]
	public sealed class ImageFormat
	{
		private static ImageFormat memoryBMP = new ImageFormat(new Guid("{b96b3caa-0728-11d3-9d7b-0000f81ef32e}"));

		private static ImageFormat bmp = new ImageFormat(new Guid("{b96b3cab-0728-11d3-9d7b-0000f81ef32e}"));

		private static ImageFormat emf = new ImageFormat(new Guid("{b96b3cac-0728-11d3-9d7b-0000f81ef32e}"));

		private static ImageFormat wmf = new ImageFormat(new Guid("{b96b3cad-0728-11d3-9d7b-0000f81ef32e}"));

		private static ImageFormat jpeg = new ImageFormat(new Guid("{b96b3cae-0728-11d3-9d7b-0000f81ef32e}"));

		private static ImageFormat png = new ImageFormat(new Guid("{b96b3caf-0728-11d3-9d7b-0000f81ef32e}"));

		private static ImageFormat gif = new ImageFormat(new Guid("{b96b3cb0-0728-11d3-9d7b-0000f81ef32e}"));

		private static ImageFormat tiff = new ImageFormat(new Guid("{b96b3cb1-0728-11d3-9d7b-0000f81ef32e}"));

		private static ImageFormat exif = new ImageFormat(new Guid("{b96b3cb2-0728-11d3-9d7b-0000f81ef32e}"));

		private static ImageFormat photoCD = new ImageFormat(new Guid("{b96b3cb3-0728-11d3-9d7b-0000f81ef32e}"));

		private static ImageFormat flashPIX = new ImageFormat(new Guid("{b96b3cb4-0728-11d3-9d7b-0000f81ef32e}"));

		private static ImageFormat icon = new ImageFormat(new Guid("{b96b3cb5-0728-11d3-9d7b-0000f81ef32e}"));

		private Guid guid;

		public Guid Guid => guid;

		public static ImageFormat MemoryBmp => memoryBMP;

		public static ImageFormat Bmp => bmp;

		public static ImageFormat Emf => emf;

		public static ImageFormat Wmf => wmf;

		public static ImageFormat Gif => gif;

		public static ImageFormat Jpeg => jpeg;

		public static ImageFormat Png => png;

		public static ImageFormat Tiff => tiff;

		public static ImageFormat Exif => exif;

		public static ImageFormat Icon => icon;

		public ImageFormat(Guid guid)
		{
			this.guid = guid;
		}

		public override bool Equals(object o)
		{
			if (!(o is ImageFormat imageFormat))
			{
				return false;
			}
			return guid == imageFormat.guid;
		}

		public override int GetHashCode()
		{
			return guid.GetHashCode();
		}

		internal ImageCodecInfo FindEncoder()
		{
			ImageCodecInfo[] imageEncoders = ImageCodecInfo.GetImageEncoders();
			ImageCodecInfo[] array = imageEncoders;
			foreach (ImageCodecInfo imageCodecInfo in array)
			{
				if (imageCodecInfo.FormatID.Equals(guid))
				{
					return imageCodecInfo;
				}
			}
			return null;
		}

		public override string ToString()
		{
			if (this == memoryBMP)
			{
				return "MemoryBMP";
			}
			if (this == bmp)
			{
				return "Bmp";
			}
			if (this == emf)
			{
				return "Emf";
			}
			if (this == wmf)
			{
				return "Wmf";
			}
			if (this == gif)
			{
				return "Gif";
			}
			if (this == jpeg)
			{
				return "Jpeg";
			}
			if (this == png)
			{
				return "Png";
			}
			if (this == tiff)
			{
				return "Tiff";
			}
			if (this == exif)
			{
				return "Exif";
			}
			if (this == icon)
			{
				return "Icon";
			}
			return string.Concat("[ImageFormat: ", guid, "]");
		}
	}
}
namespace System.Drawing
{
	public class ImageFormatConverter : TypeConverter
	{
		private StandardValuesCollection values;

		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
		{
			if (sourceType == typeof(string))
			{
				return true;
			}
			return base.CanConvertFrom(context, sourceType);
		}

		public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
		{
			if (destinationType == typeof(InstanceDescriptor))
			{
				return true;
			}
			return base.CanConvertTo(context, destinationType);
		}

		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
		{
			if (value is string text)
			{
				string b = text.Trim();
				PropertyInfo[] properties = GetProperties();
				foreach (PropertyInfo propertyInfo in properties)
				{
					if (string.Equals(propertyInfo.Name, b, StringComparison.OrdinalIgnoreCase))
					{
						object[] index = null;
						return propertyInfo.GetValue(null, index);
					}
				}
			}
			return base.ConvertFrom(context, culture, value);
		}

		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (value is ImageFormat)
			{
				PropertyInfo propertyInfo = null;
				PropertyInfo[] properties = GetProperties();
				PropertyInfo[] array = properties;
				foreach (PropertyInfo propertyInfo2 in array)
				{
					if (propertyInfo2.GetValue(null, null).Equals(value))
					{
						propertyInfo = propertyInfo2;
						break;
					}
				}
				if (propertyInfo != null)
				{
					if (destinationType == typeof(string))
					{
						return propertyInfo.Name;
					}
					if (destinationType == typeof(InstanceDescriptor))
					{
						return new InstanceDescriptor(propertyInfo, null);
					}
				}
			}
			return base.ConvertTo(context, culture, value, destinationType);
		}

		private PropertyInfo[] GetProperties()
		{
			return typeof(ImageFormat).GetProperties(BindingFlags.Static | BindingFlags.Public);
		}

		public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
		{
			if (values == null)
			{
				ArrayList arrayList = new ArrayList();
				PropertyInfo[] properties = GetProperties();
				foreach (PropertyInfo propertyInfo in properties)
				{
					object[] index = null;
					arrayList.Add(propertyInfo.GetValue(null, index));
				}
				values = new StandardValuesCollection(arrayList.ToArray());
			}
			return values;
		}

		public override bool GetStandardValuesSupported(ITypeDescriptorContext context)
		{
			return true;
		}
	}
}
namespace System.Drawing.Imaging
{
	public enum ImageLockMode
	{
		ReadOnly = 1,
		WriteOnly,
		ReadWrite,
		UserInputBuffer
	}
}
namespace System.Drawing.Text
{
	public sealed class InstalledFontCollection : FontCollection
	{
		public InstalledFontCollection()
		{
			nativeFontCollection = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipNewInstalledFontCollection(out nativeFontCollection);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}
	}
}
namespace System.Drawing.Drawing2D
{
	public enum InterpolationMode
	{
		Invalid = -1,
		Default,
		Low,
		High,
		Bilinear,
		Bicubic,
		NearestNeighbor,
		HighQualityBilinear,
		HighQualityBicubic
	}
	public sealed class LinearGradientBrush : Brush
	{
		private bool interpolationColorsWasSet;

		public Color[] LinearColors
		{
			get
			{
				return _GetLinearColors();
			}
			set
			{
				_SetLinearColors(value[0], value[1]);
			}
		}

		public RectangleF Rectangle => _GetRectangle();

		public bool GammaCorrection
		{
			get
			{
				bool useGammaCorrection;
				int num = SafeNativeMethods.Gdip.GdipGetLineGammaCorrection(new HandleRef(this, base.NativeBrush), out useGammaCorrection);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return useGammaCorrection;
			}
			set
			{
				int num = SafeNativeMethods.Gdip.GdipSetLineGammaCorrection(new HandleRef(this, base.NativeBrush), value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		public Blend Blend
		{
			get
			{
				return _GetBlend();
			}
			set
			{
				_SetBlend(value);
			}
		}

		public ColorBlend InterpolationColors
		{
			get
			{
				return _GetInterpolationColors();
			}
			set
			{
				_SetInterpolationColors(value);
			}
		}

		public WrapMode WrapMode
		{
			get
			{
				return _GetWrapMode();
			}
			set
			{
				if (!ClientUtils.IsEnumValid(value, (int)value, 0, 4))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(WrapMode));
				}
				_SetWrapMode(value);
			}
		}

		public Matrix Transform
		{
			get
			{
				return _GetTransform();
			}
			set
			{
				_SetTransform(value);
			}
		}

		public LinearGradientBrush(PointF point1, PointF point2, Color color1, Color color2)
		{
			IntPtr lineGradient = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateLineBrush(new GPPOINTF(point1), new GPPOINTF(point2), color1.ToArgb(), color2.ToArgb(), 0, out lineGradient);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeBrushInternal(lineGradient);
		}

		public LinearGradientBrush(Point point1, Point point2, Color color1, Color color2)
		{
			IntPtr lineGradient = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateLineBrushI(new GPPOINT(point1), new GPPOINT(point2), color1.ToArgb(), color2.ToArgb(), 0, out lineGradient);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeBrushInternal(lineGradient);
		}

		public LinearGradientBrush(RectangleF rect, Color color1, Color color2, LinearGradientMode linearGradientMode)
		{
			if (!ClientUtils.IsEnumValid(linearGradientMode, (int)linearGradientMode, 0, 3))
			{
				throw new InvalidEnumArgumentException("linearGradientMode", (int)linearGradientMode, typeof(LinearGradientMode));
			}
			if ((double)rect.Width == 0.0 || (double)rect.Height == 0.0)
			{
				throw new ArgumentException(SR.GetString("GdiplusInvalidRectangle", rect.ToString()));
			}
			IntPtr lineGradient = IntPtr.Zero;
			GPRECTF rect2 = new GPRECTF(rect);
			int num = SafeNativeMethods.Gdip.GdipCreateLineBrushFromRect(ref rect2, color1.ToArgb(), color2.ToArgb(), (int)linearGradientMode, 0, out lineGradient);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeBrushInternal(lineGradient);
		}

		public LinearGradientBrush(Rectangle rect, Color color1, Color color2, LinearGradientMode linearGradientMode)
		{
			if (!ClientUtils.IsEnumValid(linearGradientMode, (int)linearGradientMode, 0, 3))
			{
				throw new InvalidEnumArgumentException("linearGradientMode", (int)linearGradientMode, typeof(LinearGradientMode));
			}
			if (rect.Width == 0 || rect.Height == 0)
			{
				throw new ArgumentException(SR.GetString("GdiplusInvalidRectangle", rect.ToString()));
			}
			IntPtr lineGradient = IntPtr.Zero;
			GPRECT rect2 = new GPRECT(rect);
			int num = SafeNativeMethods.Gdip.GdipCreateLineBrushFromRectI(ref rect2, color1.ToArgb(), color2.ToArgb(), (int)linearGradientMode, 0, out lineGradient);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeBrushInternal(lineGradient);
		}

		public LinearGradientBrush(RectangleF rect, Color color1, Color color2, float angle)
			: this(rect, color1, color2, angle, isAngleScaleable: false)
		{
		}

		public LinearGradientBrush(RectangleF rect, Color color1, Color color2, float angle, bool isAngleScaleable)
		{
			IntPtr lineGradient = IntPtr.Zero;
			if ((double)rect.Width == 0.0 || (double)rect.Height == 0.0)
			{
				throw new ArgumentException(SR.GetString("GdiplusInvalidRectangle", rect.ToString()));
			}
			GPRECTF rect2 = new GPRECTF(rect);
			int num = SafeNativeMethods.Gdip.GdipCreateLineBrushFromRectWithAngle(ref rect2, color1.ToArgb(), color2.ToArgb(), angle, isAngleScaleable, 0, out lineGradient);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeBrushInternal(lineGradient);
		}

		public LinearGradientBrush(Rectangle rect, Color color1, Color color2, float angle)
			: this(rect, color1, color2, angle, isAngleScaleable: false)
		{
		}

		public LinearGradientBrush(Rectangle rect, Color color1, Color color2, float angle, bool isAngleScaleable)
		{
			IntPtr lineGradient = IntPtr.Zero;
			if (rect.Width == 0 || rect.Height == 0)
			{
				throw new ArgumentException(SR.GetString("GdiplusInvalidRectangle", rect.ToString()));
			}
			GPRECT rect2 = new GPRECT(rect);
			int num = SafeNativeMethods.Gdip.GdipCreateLineBrushFromRectWithAngleI(ref rect2, color1.ToArgb(), color2.ToArgb(), angle, isAngleScaleable, 0, out lineGradient);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeBrushInternal(lineGradient);
		}

		internal LinearGradientBrush(IntPtr nativeBrush)
		{
			SetNativeBrushInternal(nativeBrush);
		}

		public override object Clone()
		{
			IntPtr clonebrush = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCloneBrush(new HandleRef(this, base.NativeBrush), out clonebrush);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new LinearGradientBrush(clonebrush);
		}

		private void _SetLinearColors(Color color1, Color color2)
		{
			int num = SafeNativeMethods.Gdip.GdipSetLineColors(new HandleRef(this, base.NativeBrush), color1.ToArgb(), color2.ToArgb());
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private Color[] _GetLinearColors()
		{
			int[] array = new int[2];
			int[] array2 = array;
			int num = SafeNativeMethods.Gdip.GdipGetLineColors(new HandleRef(this, base.NativeBrush), array2);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new Color[2]
			{
				Color.FromArgb(array2[0]),
				Color.FromArgb(array2[1])
			};
		}

		private RectangleF _GetRectangle()
		{
			GPRECTF gprectf = default(GPRECTF);
			int num = SafeNativeMethods.Gdip.GdipGetLineRect(new HandleRef(this, base.NativeBrush), ref gprectf);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return gprectf.ToRectangleF();
		}

		private Blend _GetBlend()
		{
			if (interpolationColorsWasSet)
			{
				return null;
			}
			int count = 0;
			int num = SafeNativeMethods.Gdip.GdipGetLineBlendCount(new HandleRef(this, base.NativeBrush), out count);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			if (count <= 0)
			{
				return null;
			}
			int num2 = count;
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			try
			{
				int cb = checked(4 * num2);
				intPtr = Marshal.AllocHGlobal(cb);
				intPtr2 = Marshal.AllocHGlobal(cb);
				num = SafeNativeMethods.Gdip.GdipGetLineBlend(new HandleRef(this, base.NativeBrush), intPtr, intPtr2, num2);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				Blend blend = new Blend(num2);
				Marshal.Copy(intPtr, blend.Factors, 0, num2);
				Marshal.Copy(intPtr2, blend.Positions, 0, num2);
				return blend;
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
				if (intPtr2 != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr2);
				}
			}
		}

		private void _SetBlend(Blend blend)
		{
			int num = blend.Factors.Length;
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			try
			{
				int cb = checked(4 * num);
				intPtr = Marshal.AllocHGlobal(cb);
				intPtr2 = Marshal.AllocHGlobal(cb);
				Marshal.Copy(blend.Factors, 0, intPtr, num);
				Marshal.Copy(blend.Positions, 0, intPtr2, num);
				int num2 = SafeNativeMethods.Gdip.GdipSetLineBlend(new HandleRef(this, base.NativeBrush), new HandleRef(null, intPtr), new HandleRef(null, intPtr2), num);
				if (num2 != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num2);
				}
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
				if (intPtr2 != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr2);
				}
			}
		}

		public void SetSigmaBellShape(float focus)
		{
			SetSigmaBellShape(focus, 1f);
		}

		public void SetSigmaBellShape(float focus, float scale)
		{
			int num = SafeNativeMethods.Gdip.GdipSetLineSigmaBlend(new HandleRef(this, base.NativeBrush), focus, scale);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void SetBlendTriangularShape(float focus)
		{
			SetBlendTriangularShape(focus, 1f);
		}

		public void SetBlendTriangularShape(float focus, float scale)
		{
			int num = SafeNativeMethods.Gdip.GdipSetLineLinearBlend(new HandleRef(this, base.NativeBrush), focus, scale);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private ColorBlend _GetInterpolationColors()
		{
			if (!interpolationColorsWasSet)
			{
				throw new ArgumentException(SR.GetString("InterpolationColorsCommon", SR.GetString("InterpolationColorsColorBlendNotSet"), ""));
			}
			int count = 0;
			int num = SafeNativeMethods.Gdip.GdipGetLinePresetBlendCount(new HandleRef(this, base.NativeBrush), out count);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			int num2 = count;
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			try
			{
				int cb = checked(4 * num2);
				intPtr = Marshal.AllocHGlobal(cb);
				intPtr2 = Marshal.AllocHGlobal(cb);
				num = SafeNativeMethods.Gdip.GdipGetLinePresetBlend(new HandleRef(this, base.NativeBrush), intPtr, intPtr2, num2);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				ColorBlend colorBlend = new ColorBlend(num2);
				int[] array = new int[num2];
				Marshal.Copy(intPtr, array, 0, num2);
				Marshal.Copy(intPtr2, colorBlend.Positions, 0, num2);
				colorBlend.Colors = new Color[array.Length];
				for (int i = 0; i < array.Length; i++)
				{
					ref Color reference = ref colorBlend.Colors[i];
					reference = Color.FromArgb(array[i]);
				}
				return colorBlend;
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
				if (intPtr2 != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr2);
				}
			}
		}

		private void _SetInterpolationColors(ColorBlend blend)
		{
			interpolationColorsWasSet = true;
			if (blend == null)
			{
				throw new ArgumentException(SR.GetString("InterpolationColorsCommon", SR.GetString("InterpolationColorsInvalidColorBlendObject"), ""));
			}
			if (blend.Colors.Length < 2)
			{
				throw new ArgumentException(SR.GetString("InterpolationColorsCommon", SR.GetString("InterpolationColorsInvalidColorBlendObject"), SR.GetString("InterpolationColorsLength")));
			}
			if (blend.Colors.Length != blend.Positions.Length)
			{
				throw new ArgumentException(SR.GetString("InterpolationColorsCommon", SR.GetString("InterpolationColorsInvalidColorBlendObject"), SR.GetString("InterpolationColorsLengthsDiffer")));
			}
			if (blend.Positions[0] != 0f)
			{
				throw new ArgumentException(SR.GetString("InterpolationColorsCommon", SR.GetString("InterpolationColorsInvalidColorBlendObject"), SR.GetString("InterpolationColorsInvalidStartPosition")));
			}
			if (blend.Positions[blend.Positions.Length - 1] != 1f)
			{
				throw new ArgumentException(SR.GetString("InterpolationColorsCommon", SR.GetString("InterpolationColorsInvalidColorBlendObject"), SR.GetString("InterpolationColorsInvalidEndPosition")));
			}
			int num = blend.Colors.Length;
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			try
			{
				int cb = checked(4 * num);
				intPtr = Marshal.AllocHGlobal(cb);
				intPtr2 = Marshal.AllocHGlobal(cb);
				int[] array = new int[num];
				for (int i = 0; i < num; i++)
				{
					array[i] = blend.Colors[i].ToArgb();
				}
				Marshal.Copy(array, 0, intPtr, num);
				Marshal.Copy(blend.Positions, 0, intPtr2, num);
				int num2 = SafeNativeMethods.Gdip.GdipSetLinePresetBlend(new HandleRef(this, base.NativeBrush), new HandleRef(null, intPtr), new HandleRef(null, intPtr2), num);
				if (num2 != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num2);
				}
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
				if (intPtr2 != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr2);
				}
			}
		}

		private void _SetWrapMode(WrapMode wrapMode)
		{
			int num = SafeNativeMethods.Gdip.GdipSetLineWrapMode(new HandleRef(this, base.NativeBrush), (int)wrapMode);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private WrapMode _GetWrapMode()
		{
			int wrapMode = 0;
			int num = SafeNativeMethods.Gdip.GdipGetLineWrapMode(new HandleRef(this, base.NativeBrush), out wrapMode);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return (WrapMode)wrapMode;
		}

		private void _SetTransform(Matrix matrix)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			int num = SafeNativeMethods.Gdip.GdipSetLineTransform(new HandleRef(this, base.NativeBrush), new HandleRef(matrix, matrix.nativeMatrix));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private Matrix _GetTransform()
		{
			Matrix matrix = new Matrix();
			int num = SafeNativeMethods.Gdip.GdipGetLineTransform(new HandleRef(this, base.NativeBrush), new HandleRef(matrix, matrix.nativeMatrix));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return matrix;
		}

		public void ResetTransform()
		{
			int num = SafeNativeMethods.Gdip.GdipResetLineTransform(new HandleRef(this, base.NativeBrush));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void MultiplyTransform(Matrix matrix)
		{
			MultiplyTransform(matrix, MatrixOrder.Prepend);
		}

		public void MultiplyTransform(Matrix matrix, MatrixOrder order)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			int num = SafeNativeMethods.Gdip.GdipMultiplyLineTransform(new HandleRef(this, base.NativeBrush), new HandleRef(matrix, matrix.nativeMatrix), order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void TranslateTransform(float dx, float dy)
		{
			TranslateTransform(dx, dy, MatrixOrder.Prepend);
		}

		public void TranslateTransform(float dx, float dy, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipTranslateLineTransform(new HandleRef(this, base.NativeBrush), dx, dy, order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void ScaleTransform(float sx, float sy)
		{
			ScaleTransform(sx, sy, MatrixOrder.Prepend);
		}

		public void ScaleTransform(float sx, float sy, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipScaleLineTransform(new HandleRef(this, base.NativeBrush), sx, sy, order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void RotateTransform(float angle)
		{
			RotateTransform(angle, MatrixOrder.Prepend);
		}

		public void RotateTransform(float angle, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipRotateLineTransform(new HandleRef(this, base.NativeBrush), angle, order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}
	}
	public enum LinearGradientMode
	{
		Horizontal,
		Vertical,
		ForwardDiagonal,
		BackwardDiagonal
	}
	public enum LineCap
	{
		Flat = 0,
		Square = 1,
		Round = 2,
		Triangle = 3,
		NoAnchor = 16,
		SquareAnchor = 17,
		RoundAnchor = 18,
		DiamondAnchor = 19,
		ArrowAnchor = 20,
		Custom = 255,
		AnchorMask = 240
	}
	public enum LineJoin
	{
		Miter,
		Bevel,
		Round,
		MiterClipped
	}
	public sealed class Matrix : MarshalByRefObject, IDisposable
	{
		internal IntPtr nativeMatrix;

		public float[] Elements
		{
			get
			{
				IntPtr intPtr = Marshal.AllocHGlobal(48);
				try
				{
					int num = SafeNativeMethods.Gdip.GdipGetMatrixElements(new HandleRef(this, nativeMatrix), intPtr);
					if (num != 0)
					{
						throw SafeNativeMethods.Gdip.StatusException(num);
					}
					float[] array = new float[6];
					Marshal.Copy(intPtr, array, 0, 6);
					return array;
				}
				finally
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
		}

		public float OffsetX => Elements[4];

		public float OffsetY => Elements[5];

		public bool IsInvertible
		{
			get
			{
				int boolean;
				int num = SafeNativeMethods.Gdip.GdipIsMatrixInvertible(new HandleRef(this, nativeMatrix), out boolean);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return boolean != 0;
			}
		}

		public bool IsIdentity
		{
			get
			{
				int boolean;
				int num = SafeNativeMethods.Gdip.GdipIsMatrixIdentity(new HandleRef(this, nativeMatrix), out boolean);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return boolean != 0;
			}
		}

		public Matrix()
		{
			IntPtr matrix = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateMatrix(out matrix);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			nativeMatrix = matrix;
		}

		public Matrix(float m11, float m12, float m21, float m22, float dx, float dy)
		{
			IntPtr matrix = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateMatrix2(m11, m12, m21, m22, dx, dy, out matrix);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			nativeMatrix = matrix;
		}

		public Matrix(RectangleF rect, PointF[] plgpts)
		{
			if (plgpts == null)
			{
				throw new ArgumentNullException("plgpts");
			}
			if (plgpts.Length != 3)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(plgpts);
			try
			{
				IntPtr matrix = IntPtr.Zero;
				GPRECTF rect2 = new GPRECTF(rect);
				int num = SafeNativeMethods.Gdip.GdipCreateMatrix3(ref rect2, new HandleRef(null, intPtr), out matrix);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				nativeMatrix = matrix;
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		public Matrix(Rectangle rect, Point[] plgpts)
		{
			if (plgpts == null)
			{
				throw new ArgumentNullException("plgpts");
			}
			if (plgpts.Length != 3)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(plgpts);
			try
			{
				IntPtr matrix = IntPtr.Zero;
				GPRECT rect2 = new GPRECT(rect);
				int num = SafeNativeMethods.Gdip.GdipCreateMatrix3I(ref rect2, new HandleRef(null, intPtr), out matrix);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				nativeMatrix = matrix;
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		private void Dispose(bool disposing)
		{
			if (nativeMatrix != IntPtr.Zero)
			{
				SafeNativeMethods.Gdip.GdipDeleteMatrix(new HandleRef(this, nativeMatrix));
				nativeMatrix = IntPtr.Zero;
			}
		}

		~Matrix()
		{
			Dispose(disposing: false);
		}

		public Matrix Clone()
		{
			IntPtr cloneMatrix = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCloneMatrix(new HandleRef(this, nativeMatrix), out cloneMatrix);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new Matrix(cloneMatrix);
		}

		public void Reset()
		{
			int num = SafeNativeMethods.Gdip.GdipSetMatrixElements(new HandleRef(this, nativeMatrix), 1f, 0f, 0f, 1f, 0f, 0f);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void Multiply(Matrix matrix)
		{
			Multiply(matrix, MatrixOrder.Prepend);
		}

		public void Multiply(Matrix matrix, MatrixOrder order)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			int num = SafeNativeMethods.Gdip.GdipMultiplyMatrix(new HandleRef(this, nativeMatrix), new HandleRef(matrix, matrix.nativeMatrix), order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void Translate(float offsetX, float offsetY)
		{
			Translate(offsetX, offsetY, MatrixOrder.Prepend);
		}

		public void Translate(float offsetX, float offsetY, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipTranslateMatrix(new HandleRef(this, nativeMatrix), offsetX, offsetY, order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void Scale(float scaleX, float scaleY)
		{
			Scale(scaleX, scaleY, MatrixOrder.Prepend);
		}

		public void Scale(float scaleX, float scaleY, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipScaleMatrix(new HandleRef(this, nativeMatrix), scaleX, scaleY, order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void Rotate(float angle)
		{
			Rotate(angle, MatrixOrder.Prepend);
		}

		public void Rotate(float angle, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipRotateMatrix(new HandleRef(this, nativeMatrix), angle, order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void RotateAt(float angle, PointF point)
		{
			RotateAt(angle, point, MatrixOrder.Prepend);
		}

		public void RotateAt(float angle, PointF point, MatrixOrder order)
		{
			int num;
			if (order == MatrixOrder.Prepend)
			{
				num = SafeNativeMethods.Gdip.GdipTranslateMatrix(new HandleRef(this, nativeMatrix), point.X, point.Y, order);
				num |= SafeNativeMethods.Gdip.GdipRotateMatrix(new HandleRef(this, nativeMatrix), angle, order);
				num |= SafeNativeMethods.Gdip.GdipTranslateMatrix(new HandleRef(this, nativeMatrix), 0f - point.X, 0f - point.Y, order);
			}
			else
			{
				num = SafeNativeMethods.Gdip.GdipTranslateMatrix(new HandleRef(this, nativeMatrix), 0f - point.X, 0f - point.Y, order);
				num |= SafeNativeMethods.Gdip.GdipRotateMatrix(new HandleRef(this, nativeMatrix), angle, order);
				num |= SafeNativeMethods.Gdip.GdipTranslateMatrix(new HandleRef(this, nativeMatrix), point.X, point.Y, order);
			}
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void Shear(float shearX, float shearY)
		{
			int num = SafeNativeMethods.Gdip.GdipShearMatrix(new HandleRef(this, nativeMatrix), shearX, shearY, MatrixOrder.Prepend);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void Shear(float shearX, float shearY, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipShearMatrix(new HandleRef(this, nativeMatrix), shearX, shearY, order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void Invert()
		{
			int num = SafeNativeMethods.Gdip.GdipInvertMatrix(new HandleRef(this, nativeMatrix));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void TransformPoints(PointF[] pts)
		{
			if (pts == null)
			{
				throw new ArgumentNullException("pts");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(pts);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipTransformMatrixPoints(new HandleRef(this, nativeMatrix), new HandleRef(null, intPtr), pts.Length);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				PointF[] array = SafeNativeMethods.Gdip.ConvertGPPOINTFArrayF(intPtr, pts.Length);
				for (int i = 0; i < pts.Length; i++)
				{
					ref PointF reference = ref pts[i];
					reference = array[i];
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		public void TransformPoints(Point[] pts)
		{
			if (pts == null)
			{
				throw new ArgumentNullException("pts");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(pts);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipTransformMatrixPointsI(new HandleRef(this, nativeMatrix), new HandleRef(null, intPtr), pts.Length);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				Point[] array = SafeNativeMethods.Gdip.ConvertGPPOINTArray(intPtr, pts.Length);
				for (int i = 0; i < pts.Length; i++)
				{
					ref Point reference = ref pts[i];
					reference = array[i];
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		public void TransformVectors(PointF[] pts)
		{
			if (pts == null)
			{
				throw new ArgumentNullException("pts");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(pts);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipVectorTransformMatrixPoints(new HandleRef(this, nativeMatrix), new HandleRef(null, intPtr), pts.Length);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				PointF[] array = SafeNativeMethods.Gdip.ConvertGPPOINTFArrayF(intPtr, pts.Length);
				for (int i = 0; i < pts.Length; i++)
				{
					ref PointF reference = ref pts[i];
					reference = array[i];
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		public void VectorTransformPoints(Point[] pts)
		{
			TransformVectors(pts);
		}

		public void TransformVectors(Point[] pts)
		{
			if (pts == null)
			{
				throw new ArgumentNullException("pts");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(pts);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipVectorTransformMatrixPointsI(new HandleRef(this, nativeMatrix), new HandleRef(null, intPtr), pts.Length);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				Point[] array = SafeNativeMethods.Gdip.ConvertGPPOINTArray(intPtr, pts.Length);
				for (int i = 0; i < pts.Length; i++)
				{
					ref Point reference = ref pts[i];
					reference = array[i];
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		public override bool Equals(object obj)
		{
			if (!(obj is Matrix matrix))
			{
				return false;
			}
			int boolean;
			int num = SafeNativeMethods.Gdip.GdipIsMatrixEqual(new HandleRef(this, nativeMatrix), new HandleRef(matrix, matrix.nativeMatrix), out boolean);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return boolean != 0;
		}

		public override int GetHashCode()
		{
			return base.GetHashCode();
		}

		internal Matrix(IntPtr nativeMatrix)
		{
			SetNativeMatrix(nativeMatrix);
		}

		internal void SetNativeMatrix(IntPtr nativeMatrix)
		{
			this.nativeMatrix = nativeMatrix;
		}
	}
	public enum MatrixOrder
	{
		Prepend,
		Append
	}
}
namespace System.Drawing.Imaging
{
	[Serializable]
	[Editor("System.Drawing.Design.MetafileEditor, System.Drawing.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(UITypeEditor))]
	public sealed class Metafile : Image
	{
		public Metafile(IntPtr hmetafile, WmfPlaceableFileHeader wmfHeader)
			: this(hmetafile, wmfHeader, deleteWmf: false)
		{
		}

		public Metafile(IntPtr hmetafile, WmfPlaceableFileHeader wmfHeader, bool deleteWmf)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			IntPtr metafile = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateMetafileFromWmf(new HandleRef(null, hmetafile), wmfHeader, deleteWmf, out metafile);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(metafile);
		}

		public Metafile(IntPtr henhmetafile, bool deleteEmf)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			IntPtr metafile = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateMetafileFromEmf(new HandleRef(null, henhmetafile), deleteEmf, out metafile);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(metafile);
		}

		public Metafile(string filename)
		{
			IntSecurity.DemandReadFileIO(filename);
			IntPtr metafile = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateMetafileFromFile(filename, out metafile);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(metafile);
		}

		public Metafile(Stream stream)
		{
			if (stream == null)
			{
				throw new ArgumentException(SR.GetString("InvalidArgument", "stream", "null"));
			}
			IntPtr metafile = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateMetafileFromStream(new GPStream(stream), out metafile);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(metafile);
		}

		public Metafile(IntPtr referenceHdc, EmfType emfType)
			: this(referenceHdc, emfType, null)
		{
		}

		public Metafile(IntPtr referenceHdc, EmfType emfType, string description)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			IntPtr metafile = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipRecordMetafile(new HandleRef(null, referenceHdc), (int)emfType, NativeMethods.NullHandleRef, 7, description, out metafile);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(metafile);
		}

		public Metafile(IntPtr referenceHdc, RectangleF frameRect)
			: this(referenceHdc, frameRect, MetafileFrameUnit.GdiCompatible)
		{
		}

		public Metafile(IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit)
			: this(referenceHdc, frameRect, frameUnit, EmfType.EmfPlusDual)
		{
		}

		public Metafile(IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, EmfType type)
			: this(referenceHdc, frameRect, frameUnit, type, null)
		{
		}

		public Metafile(IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, EmfType type, string description)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			IntPtr metafile = IntPtr.Zero;
			GPRECTF frameRect2 = new GPRECTF(frameRect);
			int num = SafeNativeMethods.Gdip.GdipRecordMetafile(new HandleRef(null, referenceHdc), (int)type, ref frameRect2, (int)frameUnit, description, out metafile);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(metafile);
		}

		public Metafile(IntPtr referenceHdc, Rectangle frameRect)
			: this(referenceHdc, frameRect, MetafileFrameUnit.GdiCompatible)
		{
		}

		public Metafile(IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit)
			: this(referenceHdc, frameRect, frameUnit, EmfType.EmfPlusDual)
		{
		}

		public Metafile(IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type)
			: this(referenceHdc, frameRect, frameUnit, type, null)
		{
		}

		public Metafile(IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type, string desc)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			IntPtr metafile = IntPtr.Zero;
			int num;
			if (frameRect.IsEmpty)
			{
				num = SafeNativeMethods.Gdip.GdipRecordMetafile(new HandleRef(null, referenceHdc), (int)type, NativeMethods.NullHandleRef, 7, desc, out metafile);
			}
			else
			{
				GPRECT frameRect2 = new GPRECT(frameRect);
				num = SafeNativeMethods.Gdip.GdipRecordMetafileI(new HandleRef(null, referenceHdc), (int)type, ref frameRect2, (int)frameUnit, desc, out metafile);
			}
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(metafile);
		}

		public Metafile(string fileName, IntPtr referenceHdc)
			: this(fileName, referenceHdc, EmfType.EmfPlusDual, null)
		{
		}

		public Metafile(string fileName, IntPtr referenceHdc, EmfType type)
			: this(fileName, referenceHdc, type, null)
		{
		}

		public Metafile(string fileName, IntPtr referenceHdc, EmfType type, string description)
		{
			IntSecurity.DemandReadFileIO(fileName);
			IntSecurity.ObjectFromWin32Handle.Demand();
			IntPtr metafile = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipRecordMetafileFileName(fileName, new HandleRef(null, referenceHdc), (int)type, NativeMethods.NullHandleRef, 7, description, out metafile);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(metafile);
		}

		public Metafile(string fileName, IntPtr referenceHdc, RectangleF frameRect)
			: this(fileName, referenceHdc, frameRect, MetafileFrameUnit.GdiCompatible)
		{
		}

		public Metafile(string fileName, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit)
			: this(fileName, referenceHdc, frameRect, frameUnit, EmfType.EmfPlusDual)
		{
		}

		public Metafile(string fileName, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, EmfType type)
			: this(fileName, referenceHdc, frameRect, frameUnit, type, null)
		{
		}

		public Metafile(string fileName, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, string desc)
			: this(fileName, referenceHdc, frameRect, frameUnit, EmfType.EmfPlusDual, desc)
		{
		}

		public Metafile(string fileName, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, EmfType type, string description)
		{
			IntSecurity.DemandReadFileIO(fileName);
			IntSecurity.ObjectFromWin32Handle.Demand();
			IntPtr metafile = IntPtr.Zero;
			GPRECTF frameRect2 = new GPRECTF(frameRect);
			int num = SafeNativeMethods.Gdip.GdipRecordMetafileFileName(fileName, new HandleRef(null, referenceHdc), (int)type, ref frameRect2, (int)frameUnit, description, out metafile);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(metafile);
		}

		public Metafile(string fileName, IntPtr referenceHdc, Rectangle frameRect)
			: this(fileName, referenceHdc, frameRect, MetafileFrameUnit.GdiCompatible)
		{
		}

		public Metafile(string fileName, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit)
			: this(fileName, referenceHdc, frameRect, frameUnit, EmfType.EmfPlusDual)
		{
		}

		public Metafile(string fileName, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type)
			: this(fileName, referenceHdc, frameRect, frameUnit, type, null)
		{
		}

		public Metafile(string fileName, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, string description)
			: this(fileName, referenceHdc, frameRect, frameUnit, EmfType.EmfPlusDual, description)
		{
		}

		public Metafile(string fileName, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type, string description)
		{
			IntSecurity.DemandReadFileIO(fileName);
			IntSecurity.ObjectFromWin32Handle.Demand();
			IntPtr metafile = IntPtr.Zero;
			int num;
			if (frameRect.IsEmpty)
			{
				num = SafeNativeMethods.Gdip.GdipRecordMetafileFileName(fileName, new HandleRef(null, referenceHdc), (int)type, NativeMethods.NullHandleRef, (int)frameUnit, description, out metafile);
			}
			else
			{
				GPRECT frameRect2 = new GPRECT(frameRect);
				num = SafeNativeMethods.Gdip.GdipRecordMetafileFileNameI(fileName, new HandleRef(null, referenceHdc), (int)type, ref frameRect2, (int)frameUnit, description, out metafile);
			}
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(metafile);
		}

		public Metafile(Stream stream, IntPtr referenceHdc)
			: this(stream, referenceHdc, EmfType.EmfPlusDual, null)
		{
		}

		public Metafile(Stream stream, IntPtr referenceHdc, EmfType type)
			: this(stream, referenceHdc, type, null)
		{
		}

		public Metafile(Stream stream, IntPtr referenceHdc, EmfType type, string description)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			IntPtr metafile = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipRecordMetafileStream(new GPStream(stream), new HandleRef(null, referenceHdc), (int)type, NativeMethods.NullHandleRef, 7, description, out metafile);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(metafile);
		}

		public Metafile(Stream stream, IntPtr referenceHdc, RectangleF frameRect)
			: this(stream, referenceHdc, frameRect, MetafileFrameUnit.GdiCompatible)
		{
		}

		public Metafile(Stream stream, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit)
			: this(stream, referenceHdc, frameRect, frameUnit, EmfType.EmfPlusDual)
		{
		}

		public Metafile(Stream stream, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, EmfType type)
			: this(stream, referenceHdc, frameRect, frameUnit, type, null)
		{
		}

		public Metafile(Stream stream, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, EmfType type, string description)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			IntPtr metafile = IntPtr.Zero;
			GPRECTF frameRect2 = new GPRECTF(frameRect);
			int num = SafeNativeMethods.Gdip.GdipRecordMetafileStream(new GPStream(stream), new HandleRef(null, referenceHdc), (int)type, ref frameRect2, (int)frameUnit, description, out metafile);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(metafile);
		}

		public Metafile(Stream stream, IntPtr referenceHdc, Rectangle frameRect)
			: this(stream, referenceHdc, frameRect, MetafileFrameUnit.GdiCompatible)
		{
		}

		public Metafile(Stream stream, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit)
			: this(stream, referenceHdc, frameRect, frameUnit, EmfType.EmfPlusDual)
		{
		}

		public Metafile(Stream stream, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type)
			: this(stream, referenceHdc, frameRect, frameUnit, type, null)
		{
		}

		public Metafile(Stream stream, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type, string description)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			IntPtr metafile = IntPtr.Zero;
			int num;
			if (frameRect.IsEmpty)
			{
				num = SafeNativeMethods.Gdip.GdipRecordMetafileStream(new GPStream(stream), new HandleRef(null, referenceHdc), (int)type, NativeMethods.NullHandleRef, (int)frameUnit, description, out metafile);
			}
			else
			{
				GPRECT frameRect2 = new GPRECT(frameRect);
				num = SafeNativeMethods.Gdip.GdipRecordMetafileStreamI(new GPStream(stream), new HandleRef(null, referenceHdc), (int)type, ref frameRect2, (int)frameUnit, description, out metafile);
			}
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(metafile);
		}

		private Metafile(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}

		public static MetafileHeader GetMetafileHeader(IntPtr hmetafile, WmfPlaceableFileHeader wmfHeader)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			MetafileHeader metafileHeader = new MetafileHeader();
			metafileHeader.wmf = new MetafileHeaderWmf();
			int num = SafeNativeMethods.Gdip.GdipGetMetafileHeaderFromWmf(new HandleRef(null, hmetafile), wmfHeader, metafileHeader.wmf);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return metafileHeader;
		}

		public static MetafileHeader GetMetafileHeader(IntPtr henhmetafile)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			MetafileHeader metafileHeader = new MetafileHeader();
			metafileHeader.emf = new MetafileHeaderEmf();
			int num = SafeNativeMethods.Gdip.GdipGetMetafileHeaderFromEmf(new HandleRef(null, henhmetafile), metafileHeader.emf);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return metafileHeader;
		}

		public static MetafileHeader GetMetafileHeader(string fileName)
		{
			IntSecurity.DemandReadFileIO(fileName);
			MetafileHeader metafileHeader = new MetafileHeader();
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(MetafileHeaderEmf)));
			try
			{
				int num = SafeNativeMethods.Gdip.GdipGetMetafileHeaderFromFile(fileName, intPtr);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				int[] array = new int[1];
				int[] array2 = array;
				Marshal.Copy(intPtr, array2, 0, 1);
				MetafileType metafileType = (MetafileType)array2[0];
				if (metafileType == MetafileType.Wmf || metafileType == MetafileType.WmfPlaceable)
				{
					metafileHeader.wmf = (MetafileHeaderWmf)UnsafeNativeMethods.PtrToStructure(intPtr, typeof(MetafileHeaderWmf));
					metafileHeader.emf = null;
					return metafileHeader;
				}
				metafileHeader.wmf = null;
				metafileHeader.emf = (MetafileHeaderEmf)UnsafeNativeMethods.PtrToStructure(intPtr, typeof(MetafileHeaderEmf));
				return metafileHeader;
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		public static MetafileHeader GetMetafileHeader(Stream stream)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(MetafileHeaderEmf)));
			try
			{
				int num = SafeNativeMethods.Gdip.GdipGetMetafileHeaderFromStream(new GPStream(stream), intPtr);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				int[] array = new int[1];
				int[] array2 = array;
				Marshal.Copy(intPtr, array2, 0, 1);
				MetafileType metafileType = (MetafileType)array2[0];
				MetafileHeader metafileHeader = new MetafileHeader();
				if (metafileType == MetafileType.Wmf || metafileType == MetafileType.WmfPlaceable)
				{
					metafileHeader.wmf = (MetafileHeaderWmf)UnsafeNativeMethods.PtrToStructure(intPtr, typeof(MetafileHeaderWmf));
					metafileHeader.emf = null;
					return metafileHeader;
				}
				metafileHeader.wmf = null;
				metafileHeader.emf = (MetafileHeaderEmf)UnsafeNativeMethods.PtrToStructure(intPtr, typeof(MetafileHeaderEmf));
				return metafileHeader;
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		public MetafileHeader GetMetafileHeader()
		{
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(MetafileHeaderEmf)));
			try
			{
				int num = SafeNativeMethods.Gdip.GdipGetMetafileHeaderFromMetafile(new HandleRef(this, nativeImage), intPtr);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				int[] array = new int[1];
				int[] array2 = array;
				Marshal.Copy(intPtr, array2, 0, 1);
				MetafileType metafileType = (MetafileType)array2[0];
				MetafileHeader metafileHeader = new MetafileHeader();
				if (metafileType == MetafileType.Wmf || metafileType == MetafileType.WmfPlaceable)
				{
					metafileHeader.wmf = (MetafileHeaderWmf)UnsafeNativeMethods.PtrToStructure(intPtr, typeof(MetafileHeaderWmf));
					metafileHeader.emf = null;
					return metafileHeader;
				}
				metafileHeader.wmf = null;
				metafileHeader.emf = (MetafileHeaderEmf)UnsafeNativeMethods.PtrToStructure(intPtr, typeof(MetafileHeaderEmf));
				return metafileHeader;
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		public IntPtr GetHenhmetafile()
		{
			IntPtr hEnhMetafile = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipGetHemfFromMetafile(new HandleRef(this, nativeImage), out hEnhMetafile);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return hEnhMetafile;
		}

		public void PlayRecord(EmfPlusRecordType recordType, int flags, int dataSize, byte[] data)
		{
			int num = SafeNativeMethods.Gdip.GdipPlayMetafileRecord(new HandleRef(this, nativeImage), recordType, flags, dataSize, data);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		internal static Metafile FromGDIplus(IntPtr nativeImage)
		{
			Metafile metafile = new Metafile();
			metafile.SetNativeImage(nativeImage);
			return metafile;
		}

		private Metafile()
		{
		}
	}
	public enum MetafileFrameUnit
	{
		Pixel = 2,
		Point,
		Inch,
		Document,
		Millimeter,
		GdiCompatible
	}
	[StructLayout(LayoutKind.Sequential)]
	public sealed class MetafileHeader
	{
		internal MetafileHeaderWmf wmf;

		internal MetafileHeaderEmf emf;

		public MetafileType Type
		{
			get
			{
				if (!IsWmf())
				{
					return emf.type;
				}
				return wmf.type;
			}
		}

		public int MetafileSize
		{
			get
			{
				if (!IsWmf())
				{
					return emf.size;
				}
				return wmf.size;
			}
		}

		public int Version
		{
			get
			{
				if (!IsWmf())
				{
					return emf.version;
				}
				return wmf.version;
			}
		}

		public float DpiX
		{
			get
			{
				if (!IsWmf())
				{
					return emf.dpiX;
				}
				return wmf.dpiX;
			}
		}

		public float DpiY
		{
			get
			{
				if (!IsWmf())
				{
					return emf.dpiY;
				}
				return wmf.dpiY;
			}
		}

		public Rectangle Bounds
		{
			get
			{
				if (!IsWmf())
				{
					return new Rectangle(emf.X, emf.Y, emf.Width, emf.Height);
				}
				return new Rectangle(wmf.X, wmf.Y, wmf.Width, wmf.Height);
			}
		}

		public MetaHeader WmfHeader
		{
			get
			{
				if (wmf == null)
				{
					throw SafeNativeMethods.Gdip.StatusException(2);
				}
				return wmf.WmfHeader;
			}
		}

		public int EmfPlusHeaderSize
		{
			get
			{
				if (wmf == null && emf == null)
				{
					throw SafeNativeMethods.Gdip.StatusException(2);
				}
				if (!IsWmf())
				{
					return emf.EmfPlusHeaderSize;
				}
				return wmf.EmfPlusHeaderSize;
			}
		}

		public int LogicalDpiX
		{
			get
			{
				if (wmf == null && emf == null)
				{
					throw SafeNativeMethods.Gdip.StatusException(2);
				}
				if (!IsWmf())
				{
					return emf.LogicalDpiX;
				}
				return wmf.LogicalDpiX;
			}
		}

		public int LogicalDpiY
		{
			get
			{
				if (wmf == null && emf == null)
				{
					throw SafeNativeMethods.Gdip.StatusException(2);
				}
				if (!IsWmf())
				{
					return emf.LogicalDpiX;
				}
				return wmf.LogicalDpiY;
			}
		}

		internal MetafileHeader()
		{
		}

		public bool IsWmf()
		{
			if (wmf == null && emf == null)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			if (wmf != null && (wmf.type == MetafileType.Wmf || wmf.type == MetafileType.WmfPlaceable))
			{
				return true;
			}
			return false;
		}

		public bool IsWmfPlaceable()
		{
			if (wmf == null && emf == null)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			if (wmf != null)
			{
				return wmf.type == MetafileType.WmfPlaceable;
			}
			return false;
		}

		public bool IsEmf()
		{
			if (wmf == null && emf == null)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			if (emf != null)
			{
				return emf.type == MetafileType.Emf;
			}
			return false;
		}

		public bool IsEmfOrEmfPlus()
		{
			if (wmf == null && emf == null)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			if (emf != null)
			{
				return emf.type >= MetafileType.Emf;
			}
			return false;
		}

		public bool IsEmfPlus()
		{
			if (wmf == null && emf == null)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			if (emf != null)
			{
				return emf.type >= MetafileType.EmfPlusOnly;
			}
			return false;
		}

		public bool IsEmfPlusDual()
		{
			if (wmf == null && emf == null)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			if (emf != null)
			{
				return emf.type == MetafileType.EmfPlusDual;
			}
			return false;
		}

		public bool IsEmfPlusOnly()
		{
			if (wmf == null && emf == null)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			if (emf != null)
			{
				return emf.type == MetafileType.EmfPlusOnly;
			}
			return false;
		}

		public bool IsDisplay()
		{
			if (IsEmfPlus())
			{
				return (emf.emfPlusFlags & EmfPlusFlags.Display) != 0;
			}
			return false;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class MetafileHeaderEmf
	{
		public MetafileType type;

		public int size;

		public int version;

		public EmfPlusFlags emfPlusFlags;

		public float dpiX;

		public float dpiY;

		public int X;

		public int Y;

		public int Width;

		public int Height;

		public SafeNativeMethods.ENHMETAHEADER EmfHeader;

		public int EmfPlusHeaderSize;

		public int LogicalDpiX;

		public int LogicalDpiY;
	}
	[StructLayout(LayoutKind.Sequential, Pack = 8)]
	internal class MetafileHeaderWmf
	{
		public MetafileType type;

		public int size = Marshal.SizeOf(typeof(MetafileHeaderWmf));

		public int version;

		public EmfPlusFlags emfPlusFlags;

		public float dpiX;

		public float dpiY;

		public int X;

		public int Y;

		public int Width;

		public int Height;

		[MarshalAs(UnmanagedType.Struct)]
		public MetaHeader WmfHeader = new MetaHeader();

		public int dummy1;

		public int dummy2;

		public int dummy3;

		public int dummy4;

		public int EmfPlusHeaderSize;

		public int LogicalDpiX;

		public int LogicalDpiY;
	}
	public enum MetafileType
	{
		Invalid,
		Wmf,
		WmfPlaceable,
		Emf,
		EmfPlusOnly,
		EmfPlusDual
	}
	[StructLayout(LayoutKind.Sequential, Pack = 2)]
	public sealed class MetaHeader
	{
		private short type;

		private short headerSize;

		private short version;

		private int size;

		private short noObjects;

		private int maxRecord;

		private short noParameters;

		public short Type
		{
			get
			{
				return type;
			}
			set
			{
				type = value;
			}
		}

		public short HeaderSize
		{
			get
			{
				return headerSize;
			}
			set
			{
				headerSize = value;
			}
		}

		public short Version
		{
			get
			{
				return version;
			}
			set
			{
				version = value;
			}
		}

		public int Size
		{
			get
			{
				return size;
			}
			set
			{
				size = value;
			}
		}

		public short NoObjects
		{
			get
			{
				return noObjects;
			}
			set
			{
				noObjects = value;
			}
		}

		public int MaxRecord
		{
			get
			{
				return maxRecord;
			}
			set
			{
				maxRecord = value;
			}
		}

		public short NoParameters
		{
			get
			{
				return noParameters;
			}
			set
			{
				noParameters = value;
			}
		}
	}
	[Flags]
	public enum PaletteFlags
	{
		HasAlpha = 1,
		GrayScale = 2,
		Halftone = 4
	}
}
namespace System.Drawing.Drawing2D
{
	public sealed class PathData
	{
		private PointF[] points;

		private byte[] types;

		public PointF[] Points
		{
			get
			{
				return points;
			}
			set
			{
				points = value;
			}
		}

		public byte[] Types
		{
			get
			{
				return types;
			}
			set
			{
				types = value;
			}
		}
	}
	public sealed class PathGradientBrush : Brush
	{
		public Color CenterColor
		{
			get
			{
				int color;
				int num = SafeNativeMethods.Gdip.GdipGetPathGradientCenterColor(new HandleRef(this, base.NativeBrush), out color);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return Color.FromArgb(color);
			}
			set
			{
				int num = SafeNativeMethods.Gdip.GdipSetPathGradientCenterColor(new HandleRef(this, base.NativeBrush), value.ToArgb());
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		public Color[] SurroundColors
		{
			get
			{
				return _GetSurroundColors();
			}
			set
			{
				_SetSurroundColors(value);
			}
		}

		public PointF CenterPoint
		{
			get
			{
				GPPOINTF gPPOINTF = new GPPOINTF();
				int num = SafeNativeMethods.Gdip.GdipGetPathGradientCenterPoint(new HandleRef(this, base.NativeBrush), gPPOINTF);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return gPPOINTF.ToPoint();
			}
			set
			{
				int num = SafeNativeMethods.Gdip.GdipSetPathGradientCenterPoint(new HandleRef(this, base.NativeBrush), new GPPOINTF(value));
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		public RectangleF Rectangle => _GetRectangle();

		public Blend Blend
		{
			get
			{
				return _GetBlend();
			}
			set
			{
				_SetBlend(value);
			}
		}

		public ColorBlend InterpolationColors
		{
			get
			{
				return _GetInterpolationColors();
			}
			set
			{
				_SetInterpolationColors(value);
			}
		}

		public Matrix Transform
		{
			get
			{
				return _GetTransform();
			}
			set
			{
				_SetTransform(value);
			}
		}

		public PointF FocusScales
		{
			get
			{
				float[] array = new float[1];
				float[] array2 = array;
				float[] array3 = new float[1];
				float[] array4 = array3;
				int num = SafeNativeMethods.Gdip.GdipGetPathGradientFocusScales(new HandleRef(this, base.NativeBrush), array2, array4);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return new PointF(array2[0], array4[0]);
			}
			set
			{
				int num = SafeNativeMethods.Gdip.GdipSetPathGradientFocusScales(new HandleRef(this, base.NativeBrush), value.X, value.Y);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		public WrapMode WrapMode
		{
			get
			{
				return _GetWrapMode();
			}
			set
			{
				if (!ClientUtils.IsEnumValid(value, (int)value, 0, 4))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(WrapMode));
				}
				_SetWrapMode(value);
			}
		}

		public PathGradientBrush(PointF[] points)
			: this(points, WrapMode.Clamp)
		{
		}

		public PathGradientBrush(PointF[] points, WrapMode wrapMode)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			if (!ClientUtils.IsEnumValid(wrapMode, (int)wrapMode, 0, 4))
			{
				throw new InvalidEnumArgumentException("wrapMode", (int)wrapMode, typeof(WrapMode));
			}
			IntPtr brush = IntPtr.Zero;
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipCreatePathGradient(new HandleRef(null, intPtr), points.Length, (int)wrapMode, out brush);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				SetNativeBrushInternal(brush);
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
		}

		public PathGradientBrush(Point[] points)
			: this(points, WrapMode.Clamp)
		{
		}

		public PathGradientBrush(Point[] points, WrapMode wrapMode)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			if (!ClientUtils.IsEnumValid(wrapMode, (int)wrapMode, 0, 4))
			{
				throw new InvalidEnumArgumentException("wrapMode", (int)wrapMode, typeof(WrapMode));
			}
			IntPtr brush = IntPtr.Zero;
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipCreatePathGradientI(new HandleRef(null, intPtr), points.Length, (int)wrapMode, out brush);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				SetNativeBrushInternal(brush);
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
		}

		public PathGradientBrush(GraphicsPath path)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			IntPtr brush = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreatePathGradientFromPath(new HandleRef(path, path.nativePath), out brush);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeBrushInternal(brush);
		}

		internal PathGradientBrush(IntPtr nativeBrush)
		{
			SetNativeBrushInternal(nativeBrush);
		}

		public override object Clone()
		{
			IntPtr clonebrush = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCloneBrush(new HandleRef(this, base.NativeBrush), out clonebrush);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new PathGradientBrush(clonebrush);
		}

		private void _SetSurroundColors(Color[] colors)
		{
			int num = SafeNativeMethods.Gdip.GdipGetPathGradientSurroundColorCount(new HandleRef(this, base.NativeBrush), out var count);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			if (colors.Length > count || count <= 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			count = colors.Length;
			int[] array = new int[count];
			for (int i = 0; i < colors.Length; i++)
			{
				array[i] = colors[i].ToArgb();
			}
			num = SafeNativeMethods.Gdip.GdipSetPathGradientSurroundColorsWithCount(new HandleRef(this, base.NativeBrush), array, ref count);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private Color[] _GetSurroundColors()
		{
			int num = SafeNativeMethods.Gdip.GdipGetPathGradientSurroundColorCount(new HandleRef(this, base.NativeBrush), out var count);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			int[] array = new int[count];
			num = SafeNativeMethods.Gdip.GdipGetPathGradientSurroundColorsWithCount(new HandleRef(this, base.NativeBrush), array, ref count);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			Color[] array2 = new Color[count];
			for (int i = 0; i < count; i++)
			{
				ref Color reference = ref array2[i];
				reference = Color.FromArgb(array[i]);
			}
			return array2;
		}

		private RectangleF _GetRectangle()
		{
			GPRECTF gprectf = default(GPRECTF);
			int num = SafeNativeMethods.Gdip.GdipGetPathGradientRect(new HandleRef(this, base.NativeBrush), ref gprectf);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return gprectf.ToRectangleF();
		}

		private Blend _GetBlend()
		{
			int count = 0;
			int num = SafeNativeMethods.Gdip.GdipGetPathGradientBlendCount(new HandleRef(this, base.NativeBrush), out count);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			int num2 = count;
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			try
			{
				int cb = checked(4 * num2);
				intPtr = Marshal.AllocHGlobal(cb);
				intPtr2 = Marshal.AllocHGlobal(cb);
				num = SafeNativeMethods.Gdip.GdipGetPathGradientBlend(new HandleRef(this, base.NativeBrush), intPtr, intPtr2, num2);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				Blend blend = new Blend(num2);
				Marshal.Copy(intPtr, blend.Factors, 0, num2);
				Marshal.Copy(intPtr2, blend.Positions, 0, num2);
				return blend;
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
				if (intPtr2 != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr2);
				}
			}
		}

		private void _SetBlend(Blend blend)
		{
			int num = blend.Factors.Length;
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			try
			{
				int cb = checked(4 * num);
				intPtr = Marshal.AllocHGlobal(cb);
				intPtr2 = Marshal.AllocHGlobal(cb);
				Marshal.Copy(blend.Factors, 0, intPtr, num);
				Marshal.Copy(blend.Positions, 0, intPtr2, num);
				int num2 = SafeNativeMethods.Gdip.GdipSetPathGradientBlend(new HandleRef(this, base.NativeBrush), new HandleRef(null, intPtr), new HandleRef(null, intPtr2), num);
				if (num2 != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num2);
				}
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
				if (intPtr2 != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr2);
				}
			}
		}

		public void SetSigmaBellShape(float focus)
		{
			SetSigmaBellShape(focus, 1f);
		}

		public void SetSigmaBellShape(float focus, float scale)
		{
			int num = SafeNativeMethods.Gdip.GdipSetPathGradientSigmaBlend(new HandleRef(this, base.NativeBrush), focus, scale);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void SetBlendTriangularShape(float focus)
		{
			SetBlendTriangularShape(focus, 1f);
		}

		public void SetBlendTriangularShape(float focus, float scale)
		{
			int num = SafeNativeMethods.Gdip.GdipSetPathGradientLinearBlend(new HandleRef(this, base.NativeBrush), focus, scale);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private ColorBlend _GetInterpolationColors()
		{
			int count = 0;
			int num = SafeNativeMethods.Gdip.GdipGetPathGradientPresetBlendCount(new HandleRef(this, base.NativeBrush), out count);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			if (count == 0)
			{
				return new ColorBlend();
			}
			int num2 = count;
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			try
			{
				int cb = checked(4 * num2);
				intPtr = Marshal.AllocHGlobal(cb);
				intPtr2 = Marshal.AllocHGlobal(cb);
				num = SafeNativeMethods.Gdip.GdipGetPathGradientPresetBlend(new HandleRef(this, base.NativeBrush), intPtr, intPtr2, num2);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				ColorBlend colorBlend = new ColorBlend(num2);
				int[] array = new int[num2];
				Marshal.Copy(intPtr, array, 0, num2);
				Marshal.Copy(intPtr2, colorBlend.Positions, 0, num2);
				colorBlend.Colors = new Color[array.Length];
				for (int i = 0; i < array.Length; i++)
				{
					ref Color reference = ref colorBlend.Colors[i];
					reference = Color.FromArgb(array[i]);
				}
				return colorBlend;
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
				if (intPtr2 != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr2);
				}
			}
		}

		private void _SetInterpolationColors(ColorBlend blend)
		{
			int num = blend.Colors.Length;
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			try
			{
				int cb = checked(4 * num);
				intPtr = Marshal.AllocHGlobal(cb);
				intPtr2 = Marshal.AllocHGlobal(cb);
				int[] array = new int[num];
				for (int i = 0; i < num; i++)
				{
					array[i] = blend.Colors[i].ToArgb();
				}
				Marshal.Copy(array, 0, intPtr, num);
				Marshal.Copy(blend.Positions, 0, intPtr2, num);
				int num2 = SafeNativeMethods.Gdip.GdipSetPathGradientPresetBlend(new HandleRef(this, base.NativeBrush), new HandleRef(null, intPtr), new HandleRef(null, intPtr2), num);
				if (num2 != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num2);
				}
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
				if (intPtr2 != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr2);
				}
			}
		}

		private void _SetTransform(Matrix matrix)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			int num = SafeNativeMethods.Gdip.GdipSetPathGradientTransform(new HandleRef(this, base.NativeBrush), new HandleRef(matrix, matrix.nativeMatrix));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private Matrix _GetTransform()
		{
			Matrix matrix = new Matrix();
			int num = SafeNativeMethods.Gdip.GdipGetPathGradientTransform(new HandleRef(this, base.NativeBrush), new HandleRef(matrix, matrix.nativeMatrix));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return matrix;
		}

		public void ResetTransform()
		{
			int num = SafeNativeMethods.Gdip.GdipResetPathGradientTransform(new HandleRef(this, base.NativeBrush));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void MultiplyTransform(Matrix matrix)
		{
			MultiplyTransform(matrix, MatrixOrder.Prepend);
		}

		public void MultiplyTransform(Matrix matrix, MatrixOrder order)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			int num = SafeNativeMethods.Gdip.GdipMultiplyPathGradientTransform(new HandleRef(this, base.NativeBrush), new HandleRef(matrix, matrix.nativeMatrix), order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void TranslateTransform(float dx, float dy)
		{
			TranslateTransform(dx, dy, MatrixOrder.Prepend);
		}

		public void TranslateTransform(float dx, float dy, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipTranslatePathGradientTransform(new HandleRef(this, base.NativeBrush), dx, dy, order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void ScaleTransform(float sx, float sy)
		{
			ScaleTransform(sx, sy, MatrixOrder.Prepend);
		}

		public void ScaleTransform(float sx, float sy, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipScalePathGradientTransform(new HandleRef(this, base.NativeBrush), sx, sy, order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void RotateTransform(float angle)
		{
			RotateTransform(angle, MatrixOrder.Prepend);
		}

		public void RotateTransform(float angle, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipRotatePathGradientTransform(new HandleRef(this, base.NativeBrush), angle, order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private void _SetWrapMode(WrapMode wrapMode)
		{
			int num = SafeNativeMethods.Gdip.GdipSetPathGradientWrapMode(new HandleRef(this, base.NativeBrush), (int)wrapMode);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private WrapMode _GetWrapMode()
		{
			int wrapmode = 0;
			int num = SafeNativeMethods.Gdip.GdipGetPathGradientWrapMode(new HandleRef(this, base.NativeBrush), out wrapmode);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return (WrapMode)wrapmode;
		}
	}
	public enum PathPointType
	{
		Start = 0,
		Line = 1,
		Bezier = 3,
		PathTypeMask = 7,
		DashMode = 16,
		PathMarker = 32,
		CloseSubpath = 128,
		Bezier3 = 3
	}
	public enum PenAlignment
	{
		Center,
		Inset,
		Outset,
		Left,
		Right
	}
	public enum PenType
	{
		SolidColor,
		HatchFill,
		TextureFill,
		PathGradient,
		LinearGradient
	}
}
namespace System.Drawing.Imaging
{
	public enum PixelFormat
	{
		Indexed = 65536,
		Gdi = 131072,
		Alpha = 262144,
		PAlpha = 524288,
		Extended = 1048576,
		Canonical = 2097152,
		Undefined = 0,
		DontCare = 0,
		Format1bppIndexed = 196865,
		Format4bppIndexed = 197634,
		Format8bppIndexed = 198659,
		Format16bppGrayScale = 1052676,
		Format16bppRgb555 = 135173,
		Format16bppRgb565 = 135174,
		Format16bppArgb1555 = 397319,
		Format24bppRgb = 137224,
		Format32bppRgb = 139273,
		Format32bppArgb = 2498570,
		Format32bppPArgb = 925707,
		Format48bppRgb = 1060876,
		Format64bppArgb = 3424269,
		Format64bppPArgb = 1851406,
		Max = 15
	}
}
namespace System.Drawing.Drawing2D
{
	public enum PixelOffsetMode
	{
		Invalid = -1,
		Default,
		HighSpeed,
		HighQuality,
		None,
		Half
	}
}
namespace System.Drawing.Imaging
{
	public delegate void PlayRecordCallback(EmfPlusRecordType recordType, int flags, int dataSize, IntPtr recordData);
}
namespace System.Drawing
{
	[Serializable]
	[ComVisible(true)]
	public struct PointF
	{
		public static readonly PointF Empty = default(PointF);

		private float x;

		private float y;

		[Browsable(false)]
		public bool IsEmpty
		{
			get
			{
				if (x == 0f)
				{
					return y == 0f;
				}
				return false;
			}
		}

		public float X
		{
			get
			{
				return x;
			}
			set
			{
				x = value;
			}
		}

		public float Y
		{
			get
			{
				return y;
			}
			set
			{
				y = value;
			}
		}

		public PointF(float x, float y)
		{
			this.x = x;
			this.y = y;
		}

		public static PointF operator +(PointF pt, Size sz)
		{
			return Add(pt, sz);
		}

		public static PointF operator -(PointF pt, Size sz)
		{
			return Subtract(pt, sz);
		}

		public static PointF operator +(PointF pt, SizeF sz)
		{
			return Add(pt, sz);
		}

		public static PointF operator -(PointF pt, SizeF sz)
		{
			return Subtract(pt, sz);
		}

		public static bool operator ==(PointF left, PointF right)
		{
			if (left.X == right.X)
			{
				return left.Y == right.Y;
			}
			return false;
		}

		public static bool operator !=(PointF left, PointF right)
		{
			return !(left == right);
		}

		public static PointF Add(PointF pt, Size sz)
		{
			return new PointF(pt.X + (float)sz.Width, pt.Y + (float)sz.Height);
		}

		public static PointF Subtract(PointF pt, Size sz)
		{
			return new PointF(pt.X - (float)sz.Width, pt.Y - (float)sz.Height);
		}

		public static PointF Add(PointF pt, SizeF sz)
		{
			return new PointF(pt.X + sz.Width, pt.Y + sz.Height);
		}

		public static PointF Subtract(PointF pt, SizeF sz)
		{
			return new PointF(pt.X - sz.Width, pt.Y - sz.Height);
		}

		public override bool Equals(object obj)
		{
			if (!(obj is PointF pointF))
			{
				return false;
			}
			if (pointF.X == X && pointF.Y == Y)
			{
				return pointF.GetType().Equals(GetType());
			}
			return false;
		}

		public override int GetHashCode()
		{
			return base.GetHashCode();
		}

		public override string ToString()
		{
			return string.Format(CultureInfo.CurrentCulture, "{{X={0}, Y={1}}}", x, y);
		}
	}
}
namespace System.Drawing.Text
{
	public sealed class PrivateFontCollection : FontCollection
	{
		public PrivateFontCollection()
		{
			nativeFontCollection = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipNewPrivateFontCollection(out nativeFontCollection);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		protected override void Dispose(bool disposing)
		{
			if (nativeFontCollection != IntPtr.Zero)
			{
				try
				{
					SafeNativeMethods.Gdip.GdipDeletePrivateFontCollection(out nativeFontCollection);
				}
				catch (Exception ex)
				{
					if (ClientUtils.IsSecurityOrCriticalException(ex))
					{
						throw;
					}
				}
				finally
				{
					nativeFontCollection = IntPtr.Zero;
				}
			}
			base.Dispose(disposing);
		}

		public void AddFontFile(string filename)
		{
			IntSecurity.DemandReadFileIO(filename);
			int num = SafeNativeMethods.Gdip.GdipPrivateAddFontFile(new HandleRef(this, nativeFontCollection), filename);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SafeNativeMethods.AddFontFile(filename);
		}

		public void AddMemoryFont(IntPtr memory, int length)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			int num = SafeNativeMethods.Gdip.GdipPrivateAddMemoryFont(new HandleRef(this, nativeFontCollection), new HandleRef(null, memory), length);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}
	}
}
namespace System.Drawing.Imaging
{
	public sealed class PropertyItem
	{
		private int id;

		private int len;

		private short type;

		private byte[] value;

		public int Id
		{
			get
			{
				return id;
			}
			set
			{
				id = value;
			}
		}

		public int Len
		{
			get
			{
				return len;
			}
			set
			{
				len = value;
			}
		}

		public short Type
		{
			get
			{
				return type;
			}
			set
			{
				type = value;
			}
		}

		public byte[] Value
		{
			get
			{
				return value;
			}
			set
			{
				this.value = value;
			}
		}

		internal PropertyItem()
		{
		}
	}
}
namespace System.Drawing.Drawing2D
{
	public enum QualityMode
	{
		Invalid = -1,
		Default,
		Low,
		High
	}
}
namespace System.Drawing
{
	[Serializable]
	public struct RectangleF
	{
		public static readonly RectangleF Empty = default(RectangleF);

		private float x;

		private float y;

		private float width;

		private float height;

		[Browsable(false)]
		public PointF Location
		{
			get
			{
				return new PointF(X, Y);
			}
			set
			{
				X = value.X;
				Y = value.Y;
			}
		}

		[Browsable(false)]
		public SizeF Size
		{
			get
			{
				return new SizeF(Width, Height);
			}
			set
			{
				Width = value.Width;
				Height = value.Height;
			}
		}

		public float X
		{
			get
			{
				return x;
			}
			set
			{
				x = value;
			}
		}

		public float Y
		{
			get
			{
				return y;
			}
			set
			{
				y = value;
			}
		}

		public float Width
		{
			get
			{
				return width;
			}
			set
			{
				width = value;
			}
		}

		public float Height
		{
			get
			{
				return height;
			}
			set
			{
				height = value;
			}
		}

		[Browsable(false)]
		public float Left => X;

		[Browsable(false)]
		public float Top => Y;

		[Browsable(false)]
		public float Right => X + Width;

		[Browsable(false)]
		public float Bottom => Y + Height;

		[Browsable(false)]
		public bool IsEmpty
		{
			get
			{
				if (!(Width <= 0f))
				{
					return Height <= 0f;
				}
				return true;
			}
		}

		public RectangleF(float x, float y, float width, float height)
		{
			this.x = x;
			this.y = y;
			this.width = width;
			this.height = height;
		}

		public RectangleF(PointF location, SizeF size)
		{
			x = location.X;
			y = location.Y;
			width = size.Width;
			height = size.Height;
		}

		public static RectangleF FromLTRB(float left, float top, float right, float bottom)
		{
			return new RectangleF(left, top, right - left, bottom - top);
		}

		public override bool Equals(object obj)
		{
			if (!(obj is RectangleF rectangleF))
			{
				return false;
			}
			if (rectangleF.X == X && rectangleF.Y == Y && rectangleF.Width == Width)
			{
				return rectangleF.Height == Height;
			}
			return false;
		}

		public static bool operator ==(RectangleF left, RectangleF right)
		{
			if (left.X == right.X && left.Y == right.Y && left.Width == right.Width)
			{
				return left.Height == right.Height;
			}
			return false;
		}

		public static bool operator !=(RectangleF left, RectangleF right)
		{
			return !(left == right);
		}

		public bool Contains(float x, float y)
		{
			if (X <= x && x < X + Width && Y <= y)
			{
				return y < Y + Height;
			}
			return false;
		}

		public bool Contains(PointF pt)
		{
			return Contains(pt.X, pt.Y);
		}

		public bool Contains(RectangleF rect)
		{
			if (X <= rect.X && rect.X + rect.Width <= X + Width && Y <= rect.Y)
			{
				return rect.Y + rect.Height <= Y + Height;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return (int)((uint)X ^ (((uint)Y << 13) | ((uint)Y >> 19)) ^ (((uint)Width << 26) | ((uint)Width >> 6)) ^ (((uint)Height << 7) | ((uint)Height >> 25)));
		}

		public void Inflate(float x, float y)
		{
			X -= x;
			Y -= y;
			Width += 2f * x;
			Height += 2f * y;
		}

		public void Inflate(SizeF size)
		{
			Inflate(size.Width, size.Height);
		}

		public static RectangleF Inflate(RectangleF rect, float x, float y)
		{
			RectangleF result = rect;
			result.Inflate(x, y);
			return result;
		}

		public void Intersect(RectangleF rect)
		{
			RectangleF rectangleF = Intersect(rect, this);
			X = rectangleF.X;
			Y = rectangleF.Y;
			Width = rectangleF.Width;
			Height = rectangleF.Height;
		}

		public static RectangleF Intersect(RectangleF a, RectangleF b)
		{
			float num = Math.Max(a.X, b.X);
			float num2 = Math.Min(a.X + a.Width, b.X + b.Width);
			float num3 = Math.Max(a.Y, b.Y);
			float num4 = Math.Min(a.Y + a.Height, b.Y + b.Height);
			if (num2 >= num && num4 >= num3)
			{
				return new RectangleF(num, num3, num2 - num, num4 - num3);
			}
			return Empty;
		}

		public bool IntersectsWith(RectangleF rect)
		{
			if (rect.X < X + Width && X < rect.X + rect.Width && rect.Y < Y + Height)
			{
				return Y < rect.Y + rect.Height;
			}
			return false;
		}

		public static RectangleF Union(RectangleF a, RectangleF b)
		{
			float num = Math.Min(a.X, b.X);
			float num2 = Math.Max(a.X + a.Width, b.X + b.Width);
			float num3 = Math.Min(a.Y, b.Y);
			float num4 = Math.Max(a.Y + a.Height, b.Y + b.Height);
			return new RectangleF(num, num3, num2 - num, num4 - num3);
		}

		public void Offset(PointF pos)
		{
			Offset(pos.X, pos.Y);
		}

		public void Offset(float x, float y)
		{
			X += x;
			Y += y;
		}

		internal GPRECTF ToGPRECTF()
		{
			return new GPRECTF(X, Y, Width, Height);
		}

		public static implicit operator RectangleF(Rectangle r)
		{
			return new RectangleF(r.X, r.Y, r.Width, r.Height);
		}

		public override string ToString()
		{
			return "{X=" + X.ToString(CultureInfo.CurrentCulture) + ",Y=" + Y.ToString(CultureInfo.CurrentCulture) + ",Width=" + Width.ToString(CultureInfo.CurrentCulture) + ",Height=" + Height.ToString(CultureInfo.CurrentCulture) + "}";
		}
	}
}
namespace System.Drawing.Drawing2D
{
	public sealed class RegionData
	{
		private byte[] data;

		public byte[] Data
		{
			get
			{
				return data;
			}
			set
			{
				data = value;
			}
		}

		internal RegionData(byte[] data)
		{
			this.data = data;
		}
	}
	[SecurityCritical]
	internal class SafeCustomLineCapHandle : SafeHandle
	{
		public override bool IsInvalid => handle == IntPtr.Zero;

		internal SafeCustomLineCapHandle(IntPtr h)
			: base(IntPtr.Zero, ownsHandle: true)
		{
			SetHandle(h);
		}

		[SecurityCritical]
		protected override bool ReleaseHandle()
		{
			int num = 0;
			if (!IsInvalid)
			{
				try
				{
					num = SafeNativeMethods.Gdip.GdipDeleteCustomLineCap(new HandleRef(this, handle));
				}
				catch (Exception ex)
				{
					if (ClientUtils.IsSecurityOrCriticalException(ex))
					{
						throw;
					}
				}
				finally
				{
					handle = IntPtr.Zero;
				}
			}
			return num != 0;
		}

		public static implicit operator IntPtr(SafeCustomLineCapHandle handle)
		{
			return handle?.handle ?? IntPtr.Zero;
		}

		public static explicit operator SafeCustomLineCapHandle(IntPtr handle)
		{
			return new SafeCustomLineCapHandle(handle);
		}
	}
}
namespace System.Drawing
{
	[Serializable]
	[TypeConverter(typeof(SizeFConverter))]
	[ComVisible(true)]
	public struct SizeF
	{
		public static readonly SizeF Empty = default(SizeF);

		private float width;

		private float height;

		[Browsable(false)]
		public bool IsEmpty
		{
			get
			{
				if (width == 0f)
				{
					return height == 0f;
				}
				return false;
			}
		}

		public float Width
		{
			get
			{
				return width;
			}
			set
			{
				width = value;
			}
		}

		public float Height
		{
			get
			{
				return height;
			}
			set
			{
				height = value;
			}
		}

		public SizeF(SizeF size)
		{
			width = size.width;
			height = size.height;
		}

		public SizeF(PointF pt)
		{
			width = pt.X;
			height = pt.Y;
		}

		public SizeF(float width, float height)
		{
			this.width = width;
			this.height = height;
		}

		public static SizeF operator +(SizeF sz1, SizeF sz2)
		{
			return Add(sz1, sz2);
		}

		public static SizeF operator -(SizeF sz1, SizeF sz2)
		{
			return Subtract(sz1, sz2);
		}

		public static bool operator ==(SizeF sz1, SizeF sz2)
		{
			if (sz1.Width == sz2.Width)
			{
				return sz1.Height == sz2.Height;
			}
			return false;
		}

		public static bool operator !=(SizeF sz1, SizeF sz2)
		{
			return !(sz1 == sz2);
		}

		public static explicit operator PointF(SizeF size)
		{
			return new PointF(size.Width, size.Height);
		}

		public static SizeF Add(SizeF sz1, SizeF sz2)
		{
			return new SizeF(sz1.Width + sz2.Width, sz1.Height + sz2.Height);
		}

		public static SizeF Subtract(SizeF sz1, SizeF sz2)
		{
			return new SizeF(sz1.Width - sz2.Width, sz1.Height - sz2.Height);
		}

		public override bool Equals(object obj)
		{
			if (!(obj is SizeF sizeF))
			{
				return false;
			}
			if (sizeF.Width == Width && sizeF.Height == Height)
			{
				return sizeF.GetType().Equals(GetType());
			}
			return false;
		}

		public override int GetHashCode()
		{
			return base.GetHashCode();
		}

		public PointF ToPointF()
		{
			return (PointF)this;
		}

		public Size ToSize()
		{
			return Size.Truncate(this);
		}

		public override string ToString()
		{
			return "{Width=" + width.ToString(CultureInfo.CurrentCulture) + ", Height=" + height.ToString(CultureInfo.CurrentCulture) + "}";
		}
	}
	public class SizeFConverter : TypeConverter
	{
		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
		{
			if (sourceType == typeof(string))
			{
				return true;
			}
			return base.CanConvertFrom(context, sourceType);
		}

		public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
		{
			if (destinationType == typeof(InstanceDescriptor))
			{
				return true;
			}
			return base.CanConvertTo(context, destinationType);
		}

		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
		{
			if (value is string text)
			{
				string text2 = text.Trim();
				if (text2.Length == 0)
				{
					return null;
				}
				if (culture == null)
				{
					culture = CultureInfo.CurrentCulture;
				}
				char c = culture.TextInfo.ListSeparator[0];
				string[] array = text2.Split(c);
				float[] array2 = new float[array.Length];
				TypeConverter converter = TypeDescriptor.GetConverter(typeof(float));
				for (int i = 0; i < array2.Length; i++)
				{
					array2[i] = (float)converter.ConvertFromString(context, culture, array[i]);
				}
				if (array2.Length == 2)
				{
					return new SizeF(array2[0], array2[1]);
				}
				throw new ArgumentException(SR.GetString("TextParseFailedFormat", text2, "Width,Height"));
			}
			return base.ConvertFrom(context, culture, value);
		}

		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (destinationType == typeof(string) && value is SizeF sizeF)
			{
				if (culture == null)
				{
					culture = CultureInfo.CurrentCulture;
				}
				string separator = culture.TextInfo.ListSeparator + " ";
				TypeConverter converter = TypeDescriptor.GetConverter(typeof(float));
				string[] array = new string[2];
				int num = 0;
				array[num++] = converter.ConvertToString(context, culture, sizeF.Width);
				array[num++] = converter.ConvertToString(context, culture, sizeF.Height);
				return string.Join(separator, array);
			}
			if (destinationType == typeof(InstanceDescriptor) && value is SizeF sizeF2)
			{
				ConstructorInfo constructor = typeof(SizeF).GetConstructor(new Type[2]
				{
					typeof(float),
					typeof(float)
				});
				if (constructor != null)
				{
					return new InstanceDescriptor(constructor, new object[2] { sizeF2.Width, sizeF2.Height });
				}
			}
			return base.ConvertTo(context, culture, value, destinationType);
		}

		public override object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues)
		{
			return new SizeF((float)propertyValues["Width"], (float)propertyValues["Height"]);
		}

		public override bool GetCreateInstanceSupported(ITypeDescriptorContext context)
		{
			return true;
		}

		public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
		{
			PropertyDescriptorCollection properties = TypeDescriptor.GetProperties(typeof(SizeF), attributes);
			return properties.Sort(new string[2] { "Width", "Height" });
		}

		public override bool GetPropertiesSupported(ITypeDescriptorContext context)
		{
			return true;
		}
	}
}
namespace System.Drawing.Drawing2D
{
	public enum SmoothingMode
	{
		Invalid = -1,
		Default,
		HighSpeed,
		HighQuality,
		None,
		AntiAlias
	}
}
namespace System.Drawing
{
	public enum StringAlignment
	{
		Near,
		Center,
		Far
	}
	public enum StringDigitSubstitute
	{
		User,
		None,
		National,
		Traditional
	}
	public struct CharacterRange
	{
		private int first;

		private int length;

		public int First
		{
			get
			{
				return first;
			}
			set
			{
				first = value;
			}
		}

		public int Length
		{
			get
			{
				return length;
			}
			set
			{
				length = value;
			}
		}

		public CharacterRange(int First, int Length)
		{
			first = First;
			length = Length;
		}

		public override bool Equals(object obj)
		{
			if (obj.GetType() != typeof(CharacterRange))
			{
				return false;
			}
			CharacterRange characterRange = (CharacterRange)obj;
			if (first == characterRange.First)
			{
				return length == characterRange.Length;
			}
			return false;
		}

		public static bool operator ==(CharacterRange cr1, CharacterRange cr2)
		{
			if (cr1.First == cr2.First)
			{
				return cr1.Length == cr2.Length;
			}
			return false;
		}

		public static bool operator !=(CharacterRange cr1, CharacterRange cr2)
		{
			return !(cr1 == cr2);
		}

		public override int GetHashCode()
		{
			return first << 8 + length;
		}
	}
	public sealed class StringFormat : MarshalByRefObject, ICloneable, IDisposable
	{
		internal IntPtr nativeFormat;

		public StringFormatFlags FormatFlags
		{
			get
			{
				StringFormatFlags result;
				int num = SafeNativeMethods.Gdip.GdipGetStringFormatFlags(new HandleRef(this, nativeFormat), out result);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return result;
			}
			set
			{
				int num = SafeNativeMethods.Gdip.GdipSetStringFormatFlags(new HandleRef(this, nativeFormat), value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		public StringAlignment Alignment
		{
			get
			{
				StringAlignment align = StringAlignment.Near;
				int num = SafeNativeMethods.Gdip.GdipGetStringFormatAlign(new HandleRef(this, nativeFormat), out align);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return align;
			}
			set
			{
				if (!ClientUtils.IsEnumValid(value, (int)value, 0, 2))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(StringAlignment));
				}
				int num = SafeNativeMethods.Gdip.GdipSetStringFormatAlign(new HandleRef(this, nativeFormat), value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		public StringAlignment LineAlignment
		{
			get
			{
				StringAlignment align = StringAlignment.Near;
				int num = SafeNativeMethods.Gdip.GdipGetStringFormatLineAlign(new HandleRef(this, nativeFormat), out align);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return align;
			}
			set
			{
				if (value < StringAlignment.Near || value > StringAlignment.Far)
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(StringAlignment));
				}
				int num = SafeNativeMethods.Gdip.GdipSetStringFormatLineAlign(new HandleRef(this, nativeFormat), value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		public HotkeyPrefix HotkeyPrefix
		{
			get
			{
				HotkeyPrefix hotkeyPrefix;
				int num = SafeNativeMethods.Gdip.GdipGetStringFormatHotkeyPrefix(new HandleRef(this, nativeFormat), out hotkeyPrefix);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return hotkeyPrefix;
			}
			set
			{
				if (!ClientUtils.IsEnumValid(value, (int)value, 0, 2))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(HotkeyPrefix));
				}
				int num = SafeNativeMethods.Gdip.GdipSetStringFormatHotkeyPrefix(new HandleRef(this, nativeFormat), value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		public StringTrimming Trimming
		{
			get
			{
				StringTrimming trimming;
				int num = SafeNativeMethods.Gdip.GdipGetStringFormatTrimming(new HandleRef(this, nativeFormat), out trimming);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return trimming;
			}
			set
			{
				if (!ClientUtils.IsEnumValid(value, (int)value, 0, 5))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(StringTrimming));
				}
				int num = SafeNativeMethods.Gdip.GdipSetStringFormatTrimming(new HandleRef(this, nativeFormat), value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		public static StringFormat GenericDefault
		{
			get
			{
				IntPtr format;
				int num = SafeNativeMethods.Gdip.GdipStringFormatGetGenericDefault(out format);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return new StringFormat(format);
			}
		}

		public static StringFormat GenericTypographic
		{
			get
			{
				IntPtr format;
				int num = SafeNativeMethods.Gdip.GdipStringFormatGetGenericTypographic(out format);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return new StringFormat(format);
			}
		}

		public StringDigitSubstitute DigitSubstitutionMethod
		{
			get
			{
				int langID = 0;
				StringDigitSubstitute sds;
				int num = SafeNativeMethods.Gdip.GdipGetStringFormatDigitSubstitution(new HandleRef(this, nativeFormat), out langID, out sds);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return sds;
			}
		}

		public int DigitSubstitutionLanguage
		{
			get
			{
				int langID = 0;
				StringDigitSubstitute sds;
				int num = SafeNativeMethods.Gdip.GdipGetStringFormatDigitSubstitution(new HandleRef(this, nativeFormat), out langID, out sds);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return langID;
			}
		}

		private StringFormat(IntPtr format)
		{
			nativeFormat = format;
		}

		public StringFormat()
			: this((StringFormatFlags)0, 0)
		{
		}

		public StringFormat(StringFormatFlags options)
			: this(options, 0)
		{
		}

		public StringFormat(StringFormatFlags options, int language)
		{
			int num = SafeNativeMethods.Gdip.GdipCreateStringFormat(options, language, out nativeFormat);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public StringFormat(StringFormat format)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = SafeNativeMethods.Gdip.GdipCloneStringFormat(new HandleRef(format, format.nativeFormat), out nativeFormat);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		private void Dispose(bool disposing)
		{
			if (!(nativeFormat != IntPtr.Zero))
			{
				return;
			}
			try
			{
				SafeNativeMethods.Gdip.GdipDeleteStringFormat(new HandleRef(this, nativeFormat));
			}
			catch (Exception ex)
			{
				if (ClientUtils.IsCriticalException(ex))
				{
					throw;
				}
			}
			finally
			{
				nativeFormat = IntPtr.Zero;
			}
		}

		public object Clone()
		{
			IntPtr newFormat = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCloneStringFormat(new HandleRef(this, nativeFormat), out newFormat);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new StringFormat(newFormat);
		}

		public void SetMeasurableCharacterRanges(CharacterRange[] ranges)
		{
			int num = SafeNativeMethods.Gdip.GdipSetStringFormatMeasurableCharacterRanges(new HandleRef(this, nativeFormat), ranges.Length, ranges);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void SetTabStops(float firstTabOffset, float[] tabStops)
		{
			if (firstTabOffset < 0f)
			{
				throw new ArgumentException(SR.GetString("InvalidArgument", "firstTabOffset", firstTabOffset));
			}
			int num = SafeNativeMethods.Gdip.GdipSetStringFormatTabStops(new HandleRef(this, nativeFormat), firstTabOffset, tabStops.Length, tabStops);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public float[] GetTabStops(out float firstTabOffset)
		{
			int count = 0;
			int num = SafeNativeMethods.Gdip.GdipGetStringFormatTabStopCount(new HandleRef(this, nativeFormat), out count);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			float[] array = new float[count];
			num = SafeNativeMethods.Gdip.GdipGetStringFormatTabStops(new HandleRef(this, nativeFormat), count, out firstTabOffset, array);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return array;
		}

		public void SetDigitSubstitution(int language, StringDigitSubstitute substitute)
		{
			int num = SafeNativeMethods.Gdip.GdipSetStringFormatDigitSubstitution(new HandleRef(this, nativeFormat), language, substitute);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		~StringFormat()
		{
			Dispose(disposing: false);
		}

		public override string ToString()
		{
			return "[StringFormat, FormatFlags=" + FormatFlags.ToString() + "]";
		}
	}
	[Flags]
	public enum StringFormatFlags
	{
		DirectionRightToLeft = 1,
		DirectionVertical = 2,
		FitBlackBox = 4,
		DisplayFormatControl = 0x20,
		NoFontFallback = 0x400,
		MeasureTrailingSpaces = 0x800,
		NoWrap = 0x1000,
		LineLimit = 0x2000,
		NoClip = 0x4000
	}
	public enum StringTrimming
	{
		None,
		Character,
		Word,
		EllipsisCharacter,
		EllipsisWord,
		EllipsisPath
	}
	public enum StringUnit
	{
		World = 0,
		Display = 1,
		Pixel = 2,
		Point = 3,
		Inch = 4,
		Document = 5,
		Millimeter = 6,
		Em = 32
	}
}
namespace System.Drawing.Internal
{
	internal class SystemColorTracker
	{
		private static int INITIAL_SIZE = 200;

		private static int WARNING_SIZE = 100000;

		private static float EXPAND_THRESHOLD = 0.75f;

		private static int EXPAND_FACTOR = 2;

		private static WeakReference[] list = new WeakReference[INITIAL_SIZE];

		private static int count = 0;

		private static bool addedTracker;

		private SystemColorTracker()
		{
		}

		internal static void Add(ISystemColorTracker obj)
		{
			lock (typeof(SystemColorTracker))
			{
				if (list.Length == count)
				{
					GarbageCollectList();
				}
				if (!addedTracker)
				{
					addedTracker = true;
					SystemEvents.UserPreferenceChanged += OnUserPreferenceChanged;
				}
				int num = count;
				count++;
				if (list[num] == null)
				{
					list[num] = new WeakReference(obj);
				}
				else
				{
					list[num].Target = obj;
				}
			}
		}

		private static void CleanOutBrokenLinks()
		{
			int num = list.Length - 1;
			int num2 = 0;
			int num3 = list.Length;
			while (true)
			{
				if (num2 < num3 && list[num2].Target != null)
				{
					num2++;
					continue;
				}
				while (num >= 0 && list[num].Target == null)
				{
					num--;
				}
				if (num2 >= num)
				{
					break;
				}
				WeakReference weakReference = list[num2];
				list[num2] = list[num];
				list[num] = weakReference;
				num2++;
				num--;
			}
			count = num2;
		}

		private static void GarbageCollectList()
		{
			CleanOutBrokenLinks();
			if ((float)count / (float)list.Length > EXPAND_THRESHOLD)
			{
				WeakReference[] array = new WeakReference[list.Length * EXPAND_FACTOR];
				list.CopyTo(array, 0);
				list = array;
				_ = list.Length;
				_ = WARNING_SIZE;
			}
		}

		private static void OnUserPreferenceChanged(object sender, UserPreferenceChangedEventArgs e)
		{
			if (e.Category == UserPreferenceCategory.Color)
			{
				for (int i = 0; i < count; i++)
				{
					((ISystemColorTracker)list[i].Target)?.OnSystemColorChanged();
				}
			}
		}
	}
}
namespace System.Drawing.Text
{
	public enum TextRenderingHint
	{
		SystemDefault,
		SingleBitPerPixelGridFit,
		SingleBitPerPixel,
		AntiAliasGridFit,
		AntiAlias,
		ClearTypeGridFit
	}
}
namespace System.Drawing
{
	public sealed class TextureBrush : Brush
	{
		public Matrix Transform
		{
			get
			{
				return _GetTransform();
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				_SetTransform(value);
			}
		}

		public WrapMode WrapMode
		{
			get
			{
				return _GetWrapMode();
			}
			set
			{
				if (!ClientUtils.IsEnumValid(value, (int)value, 0, 4))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(WrapMode));
				}
				_SetWrapMode(value);
			}
		}

		public Image Image
		{
			get
			{
				IntPtr image;
				int num = SafeNativeMethods.Gdip.GdipGetTextureImage(new HandleRef(this, base.NativeBrush), out image);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return Image.CreateImageObject(image);
			}
		}

		public TextureBrush(Image bitmap)
			: this(bitmap, WrapMode.Tile)
		{
		}

		public TextureBrush(Image image, WrapMode wrapMode)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			if (!ClientUtils.IsEnumValid(wrapMode, (int)wrapMode, 0, 4))
			{
				throw new InvalidEnumArgumentException("wrapMode", (int)wrapMode, typeof(WrapMode));
			}
			IntPtr texture = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateTexture(new HandleRef(image, image.nativeImage), (int)wrapMode, out texture);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeBrushInternal(texture);
		}

		public TextureBrush(Image image, WrapMode wrapMode, RectangleF dstRect)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			if (!ClientUtils.IsEnumValid(wrapMode, (int)wrapMode, 0, 4))
			{
				throw new InvalidEnumArgumentException("wrapMode", (int)wrapMode, typeof(WrapMode));
			}
			IntPtr texture = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateTexture2(new HandleRef(image, image.nativeImage), (int)wrapMode, dstRect.X, dstRect.Y, dstRect.Width, dstRect.Height, out texture);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeBrushInternal(texture);
		}

		public TextureBrush(Image image, WrapMode wrapMode, Rectangle dstRect)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			if (!ClientUtils.IsEnumValid(wrapMode, (int)wrapMode, 0, 4))
			{
				throw new InvalidEnumArgumentException("wrapMode", (int)wrapMode, typeof(WrapMode));
			}
			IntPtr texture = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateTexture2I(new HandleRef(image, image.nativeImage), (int)wrapMode, dstRect.X, dstRect.Y, dstRect.Width, dstRect.Height, out texture);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeBrushInternal(texture);
		}

		public TextureBrush(Image image, RectangleF dstRect)
			: this(image, dstRect, null)
		{
		}

		public TextureBrush(Image image, RectangleF dstRect, ImageAttributes imageAttr)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			IntPtr texture = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateTextureIA(new HandleRef(image, image.nativeImage), new HandleRef(imageAttr, imageAttr?.nativeImageAttributes ?? IntPtr.Zero), dstRect.X, dstRect.Y, dstRect.Width, dstRect.Height, out texture);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeBrushInternal(texture);
		}

		public TextureBrush(Image image, Rectangle dstRect)
			: this(image, dstRect, null)
		{
		}

		public TextureBrush(Image image, Rectangle dstRect, ImageAttributes imageAttr)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			IntPtr texture = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateTextureIAI(new HandleRef(image, image.nativeImage), new HandleRef(imageAttr, imageAttr?.nativeImageAttributes ?? IntPtr.Zero), dstRect.X, dstRect.Y, dstRect.Width, dstRect.Height, out texture);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeBrushInternal(texture);
		}

		internal TextureBrush(IntPtr nativeBrush)
		{
			SetNativeBrushInternal(nativeBrush);
		}

		public override object Clone()
		{
			IntPtr clonebrush = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCloneBrush(new HandleRef(this, base.NativeBrush), out clonebrush);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new TextureBrush(clonebrush);
		}

		private void _SetTransform(Matrix matrix)
		{
			int num = SafeNativeMethods.Gdip.GdipSetTextureTransform(new HandleRef(this, base.NativeBrush), new HandleRef(matrix, matrix.nativeMatrix));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private Matrix _GetTransform()
		{
			Matrix matrix = new Matrix();
			int num = SafeNativeMethods.Gdip.GdipGetTextureTransform(new HandleRef(this, base.NativeBrush), new HandleRef(matrix, matrix.nativeMatrix));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return matrix;
		}

		private void _SetWrapMode(WrapMode wrapMode)
		{
			int num = SafeNativeMethods.Gdip.GdipSetTextureWrapMode(new HandleRef(this, base.NativeBrush), (int)wrapMode);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private WrapMode _GetWrapMode()
		{
			int wrapMode = 0;
			int num = SafeNativeMethods.Gdip.GdipGetTextureWrapMode(new HandleRef(this, base.NativeBrush), out wrapMode);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return (WrapMode)wrapMode;
		}

		public void ResetTransform()
		{
			int num = SafeNativeMethods.Gdip.GdipResetTextureTransform(new HandleRef(this, base.NativeBrush));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void MultiplyTransform(Matrix matrix)
		{
			MultiplyTransform(matrix, MatrixOrder.Prepend);
		}

		public void MultiplyTransform(Matrix matrix, MatrixOrder order)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			int num = SafeNativeMethods.Gdip.GdipMultiplyTextureTransform(new HandleRef(this, base.NativeBrush), new HandleRef(matrix, matrix.nativeMatrix), order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void TranslateTransform(float dx, float dy)
		{
			TranslateTransform(dx, dy, MatrixOrder.Prepend);
		}

		public void TranslateTransform(float dx, float dy, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipTranslateTextureTransform(new HandleRef(this, base.NativeBrush), dx, dy, order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void ScaleTransform(float sx, float sy)
		{
			ScaleTransform(sx, sy, MatrixOrder.Prepend);
		}

		public void ScaleTransform(float sx, float sy, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipScaleTextureTransform(new HandleRef(this, base.NativeBrush), sx, sy, order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		public void RotateTransform(float angle)
		{
			RotateTransform(angle, MatrixOrder.Prepend);
		}

		public void RotateTransform(float angle, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipRotateTextureTransform(new HandleRef(this, base.NativeBrush), angle, order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}
	}
	public enum GraphicsUnit
	{
		World,
		Display,
		Pixel,
		Point,
		Inch,
		Document,
		Millimeter
	}
}
namespace System.Drawing.Drawing2D
{
	public enum WarpMode
	{
		Perspective,
		Bilinear
	}
}
namespace System.Drawing.Imaging
{
	[StructLayout(LayoutKind.Sequential)]
	public sealed class WmfPlaceableFileHeader
	{
		private int key = -1698247209;

		private short hmf;

		private short bboxLeft;

		private short bboxTop;

		private short bboxRight;

		private short bboxBottom;

		private short inch;

		private int reserved;

		private short checksum;

		public int Key
		{
			get
			{
				return key;
			}
			set
			{
				key = value;
			}
		}

		public short Hmf
		{
			get
			{
				return hmf;
			}
			set
			{
				hmf = value;
			}
		}

		public short BboxLeft
		{
			get
			{
				return bboxLeft;
			}
			set
			{
				bboxLeft = value;
			}
		}

		public short BboxTop
		{
			get
			{
				return bboxTop;
			}
			set
			{
				bboxTop = value;
			}
		}

		public short BboxRight
		{
			get
			{
				return bboxRight;
			}
			set
			{
				bboxRight = value;
			}
		}

		public short BboxBottom
		{
			get
			{
				return bboxBottom;
			}
			set
			{
				bboxBottom = value;
			}
		}

		public short Inch
		{
			get
			{
				return inch;
			}
			set
			{
				inch = value;
			}
		}

		public int Reserved
		{
			get
			{
				return reserved;
			}
			set
			{
				reserved = value;
			}
		}

		public short Checksum
		{
			get
			{
				return checksum;
			}
			set
			{
				checksum = value;
			}
		}
	}
}
namespace System.Drawing.Drawing2D
{
	public enum WrapMode
	{
		Tile,
		TileFlipX,
		TileFlipY,
		TileFlipXY,
		Clamp
	}
}
namespace System.Drawing.Design
{
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	public sealed class CategoryNameCollection : ReadOnlyCollectionBase
	{
		public string this[int index] => (string)base.InnerList[index];

		public CategoryNameCollection(CategoryNameCollection value)
		{
			base.InnerList.AddRange(value);
		}

		public CategoryNameCollection(string[] value)
		{
			base.InnerList.AddRange(value);
		}

		public bool Contains(string value)
		{
			return base.InnerList.Contains(value);
		}

		public void CopyTo(string[] array, int index)
		{
			base.InnerList.CopyTo(array, index);
		}

		public int IndexOf(string value)
		{
			return base.InnerList.IndexOf(value);
		}
	}
	public interface IPropertyValueUIService
	{
		event EventHandler PropertyUIValueItemsChanged;

		void AddPropertyValueUIHandler(PropertyValueUIHandler newHandler);

		PropertyValueUIItem[] GetPropertyUIValueItems(ITypeDescriptorContext context, PropertyDescriptor propDesc);

		void NotifyPropertyValueUIItemsChanged();

		void RemovePropertyValueUIHandler(PropertyValueUIHandler newHandler);
	}
	public interface IToolboxItemProvider
	{
		ToolboxItemCollection Items { get; }
	}
	[ComImport]
	[Guid("4BACD258-DE64-4048-BC4E-FEDBEF9ACB76")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	public interface IToolboxService
	{
		CategoryNameCollection CategoryNames { get; }

		string SelectedCategory { get; set; }

		void AddCreator(ToolboxItemCreatorCallback creator, string format);

		void AddCreator(ToolboxItemCreatorCallback creator, string format, IDesignerHost host);

		void AddLinkedToolboxItem(ToolboxItem toolboxItem, IDesignerHost host);

		void AddLinkedToolboxItem(ToolboxItem toolboxItem, string category, IDesignerHost host);

		void AddToolboxItem(ToolboxItem toolboxItem);

		void AddToolboxItem(ToolboxItem toolboxItem, string category);

		ToolboxItem DeserializeToolboxItem(object serializedObject);

		ToolboxItem DeserializeToolboxItem(object serializedObject, IDesignerHost host);

		ToolboxItem GetSelectedToolboxItem();

		ToolboxItem GetSelectedToolboxItem(IDesignerHost host);

		ToolboxItemCollection GetToolboxItems();

		ToolboxItemCollection GetToolboxItems(IDesignerHost host);

		ToolboxItemCollection GetToolboxItems(string category);

		ToolboxItemCollection GetToolboxItems(string category, IDesignerHost host);

		bool IsSupported(object serializedObject, IDesignerHost host);

		bool IsSupported(object serializedObject, ICollection filterAttributes);

		bool IsToolboxItem(object serializedObject);

		bool IsToolboxItem(object serializedObject, IDesignerHost host);

		void Refresh();

		void RemoveCreator(string format);

		void RemoveCreator(string format, IDesignerHost host);

		void RemoveToolboxItem(ToolboxItem toolboxItem);

		void RemoveToolboxItem(ToolboxItem toolboxItem, string category);

		void SelectedToolboxItemUsed();

		object SerializeToolboxItem(ToolboxItem toolboxItem);

		bool SetCursor();

		void SetSelectedToolboxItem(ToolboxItem toolboxItem);
	}
	public interface IToolboxUser
	{
		bool GetToolSupported(ToolboxItem tool);

		void ToolPicked(ToolboxItem tool);
	}
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	public class PaintValueEventArgs : EventArgs
	{
		private readonly ITypeDescriptorContext context;

		private readonly object valueToPaint;

		private readonly Graphics graphics;

		private readonly Rectangle bounds;

		public Rectangle Bounds => bounds;

		public ITypeDescriptorContext Context => context;

		public Graphics Graphics => graphics;

		public object Value => valueToPaint;

		public PaintValueEventArgs(ITypeDescriptorContext context, object value, Graphics graphics, Rectangle bounds)
		{
			this.context = context;
			valueToPaint = value;
			this.graphics = graphics;
			if (graphics == null)
			{
				throw new ArgumentNullException("graphics");
			}
			this.bounds = bounds;
		}
	}
	public delegate void PropertyValueUIHandler(ITypeDescriptorContext context, PropertyDescriptor propDesc, ArrayList valueUIItemList);
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	public class PropertyValueUIItem
	{
		private Image itemImage;

		private PropertyValueUIItemInvokeHandler handler;

		private string tooltip;

		public virtual Image Image => itemImage;

		public virtual PropertyValueUIItemInvokeHandler InvokeHandler => handler;

		public virtual string ToolTip => tooltip;

		public PropertyValueUIItem(Image uiItemImage, PropertyValueUIItemInvokeHandler handler, string tooltip)
		{
			itemImage = uiItemImage;
			this.handler = handler;
			if (itemImage == null)
			{
				throw new ArgumentNullException("uiItemImage");
			}
			if (handler == null)
			{
				throw new ArgumentNullException("handler");
			}
			this.tooltip = tooltip;
		}

		public virtual void Reset()
		{
		}
	}
	public delegate void PropertyValueUIItemInvokeHandler(ITypeDescriptorContext context, PropertyDescriptor descriptor, PropertyValueUIItem invokedItem);
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	public class ToolboxComponentsCreatedEventArgs : EventArgs
	{
		private readonly IComponent[] comps;

		public IComponent[] Components => (IComponent[])comps.Clone();

		public ToolboxComponentsCreatedEventArgs(IComponent[] components)
		{
			comps = components;
		}
	}
	public delegate void ToolboxComponentsCreatedEventHandler(object sender, ToolboxComponentsCreatedEventArgs e);
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	public class ToolboxComponentsCreatingEventArgs : EventArgs
	{
		private readonly IDesignerHost host;

		public IDesignerHost DesignerHost => host;

		public ToolboxComponentsCreatingEventArgs(IDesignerHost host)
		{
			this.host = host;
		}
	}
	public delegate void ToolboxComponentsCreatingEventHandler(object sender, ToolboxComponentsCreatingEventArgs e);
	[Serializable]
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	public class ToolboxItem : ISerializable
	{
		private class LockableDictionary : Hashtable
		{
			private ToolboxItem _item;

			public override bool IsFixedSize => _item.Locked;

			public override bool IsReadOnly => _item.Locked;

			public override object this[object key]
			{
				get
				{
					string propertyName = GetPropertyName(key);
					object value = base[propertyName];
					return _item.FilterPropertyValue(propertyName, value);
				}
				set
				{
					string propertyName = GetPropertyName(key);
					value = _item.ValidatePropertyValue(propertyName, value);
					CheckSerializable(value);
					_item.CheckUnlocked();
					base[propertyName] = value;
				}
			}

			internal LockableDictionary(ToolboxItem item, int capacity)
				: base(capacity)
			{
				_item = item;
			}

			public override void Add(object key, object value)
			{
				string propertyName = GetPropertyName(key);
				value = _item.ValidatePropertyValue(propertyName, value);
				CheckSerializable(value);
				_item.CheckUnlocked();
				base.Add(propertyName, value);
			}

			private void CheckSerializable(object value)
			{
				if (value != null && !value.GetType().IsSerializable)
				{
					throw new ArgumentException(SR.GetString("ToolboxItemValueNotSerializable", value.GetType().FullName));
				}
			}

			public override void Clear()
			{
				_item.CheckUnlocked();
				base.Clear();
			}

			private string GetPropertyName(object key)
			{
				if (key == null)
				{
					throw new ArgumentNullException("key");
				}
				if (!(key is string text) || text.Length == 0)
				{
					throw new ArgumentException(SR.GetString("ToolboxItemInvalidKey"), "key");
				}
				return text;
			}

			public override void Remove(object key)
			{
				_item.CheckUnlocked();
				base.Remove(key);
			}
		}

		private static TraceSwitch ToolboxItemPersist = new TraceSwitch("ToolboxPersisting", "ToolboxItem: write data");

		private static object EventComponentsCreated = new object();

		private static object EventComponentsCreating = new object();

		private bool locked;

		private LockableDictionary properties;

		private ToolboxComponentsCreatedEventHandler componentsCreatedEvent;

		private ToolboxComponentsCreatingEventHandler componentsCreatingEvent;

		public AssemblyName AssemblyName
		{
			get
			{
				return (AssemblyName)Properties["AssemblyName"];
			}
			set
			{
				Properties["AssemblyName"] = value;
			}
		}

		public AssemblyName[] DependentAssemblies
		{
			get
			{
				AssemblyName[] array = (AssemblyName[])Properties["DependentAssemblies"];
				if (array != null)
				{
					return (AssemblyName[])array.Clone();
				}
				return null;
			}
			set
			{
				Properties["DependentAssemblies"] = value.Clone();
			}
		}

		public Bitmap Bitmap
		{
			get
			{
				return (Bitmap)Properties["Bitmap"];
			}
			set
			{
				Properties["Bitmap"] = value;
			}
		}

		public string Company
		{
			get
			{
				return (string)Properties["Company"];
			}
			set
			{
				Properties["Company"] = value;
			}
		}

		public virtual string ComponentType => SR.GetString("DotNET_ComponentType");

		public string Description
		{
			get
			{
				return (string)Properties["Description"];
			}
			set
			{
				Properties["Description"] = value;
			}
		}

		public string DisplayName
		{
			get
			{
				return (string)Properties["DisplayName"];
			}
			set
			{
				Properties["DisplayName"] = value;
			}
		}

		public ICollection Filter
		{
			get
			{
				return (ICollection)Properties["Filter"];
			}
			set
			{
				Properties["Filter"] = value;
			}
		}

		public bool IsTransient
		{
			get
			{
				return (bool)Properties["IsTransient"];
			}
			set
			{
				Properties["IsTransient"] = value;
			}
		}

		public virtual bool Locked => locked;

		public IDictionary Properties
		{
			get
			{
				if (properties == null)
				{
					properties = new LockableDictionary(this, 8);
				}
				return properties;
			}
		}

		public string TypeName
		{
			get
			{
				return (string)Properties["TypeName"];
			}
			set
			{
				Properties["TypeName"] = value;
			}
		}

		public virtual string Version
		{
			get
			{
				if (AssemblyName != null)
				{
					return AssemblyName.Version.ToString();
				}
				return string.Empty;
			}
		}

		public event ToolboxComponentsCreatedEventHandler ComponentsCreated
		{
			add
			{
				componentsCreatedEvent = (ToolboxComponentsCreatedEventHandler)Delegate.Combine(componentsCreatedEvent, value);
			}
			remove
			{
				componentsCreatedEvent = (ToolboxComponentsCreatedEventHandler)Delegate.Remove(componentsCreatedEvent, value);
			}
		}

		public event ToolboxComponentsCreatingEventHandler ComponentsCreating
		{
			add
			{
				componentsCreatingEvent = (ToolboxComponentsCreatingEventHandler)Delegate.Combine(componentsCreatingEvent, value);
			}
			remove
			{
				componentsCreatingEvent = (ToolboxComponentsCreatingEventHandler)Delegate.Remove(componentsCreatingEvent, value);
			}
		}

		public ToolboxItem()
		{
		}

		public ToolboxItem(Type toolType)
		{
			Initialize(toolType);
		}

		private ToolboxItem(SerializationInfo info, StreamingContext context)
		{
			Deserialize(info, context);
		}

		protected void CheckUnlocked()
		{
			if (Locked)
			{
				throw new InvalidOperationException(SR.GetString("ToolboxItemLocked"));
			}
		}

		public IComponent[] CreateComponents()
		{
			return CreateComponents(null);
		}

		public IComponent[] CreateComponents(IDesignerHost host)
		{
			OnComponentsCreating(new ToolboxComponentsCreatingEventArgs(host));
			IComponent[] array = CreateComponentsCore(host, new Hashtable());
			if (array != null && array.Length > 0)
			{
				OnComponentsCreated(new ToolboxComponentsCreatedEventArgs(array));
			}
			return array;
		}

		public IComponent[] CreateComponents(IDesignerHost host, IDictionary defaultValues)
		{
			OnComponentsCreating(new ToolboxComponentsCreatingEventArgs(host));
			IComponent[] array = CreateComponentsCore(host, defaultValues);
			if (array != null && array.Length > 0)
			{
				OnComponentsCreated(new ToolboxComponentsCreatedEventArgs(array));
			}
			return array;
		}

		protected virtual IComponent[] CreateComponentsCore(IDesignerHost host)
		{
			ArrayList arrayList = new ArrayList();
			Type type = GetType(host, AssemblyName, TypeName, reference: true);
			if (type != null)
			{
				if (host != null)
				{
					arrayList.Add(host.CreateComponent(type));
				}
				else if (typeof(IComponent).IsAssignableFrom(type))
				{
					arrayList.Add(TypeDescriptor.CreateInstance(null, type, null, null));
				}
			}
			IComponent[] array = new IComponent[arrayList.Count];
			arrayList.CopyTo(array, 0);
			return array;
		}

		protected virtual IComponent[] CreateComponentsCore(IDesignerHost host, IDictionary defaultValues)
		{
			IComponent[] array = CreateComponentsCore(host);
			if (host != null)
			{
				for (int i = 0; i < array.Length; i++)
				{
					if (!(host.GetDesigner(array[i]) is IComponentInitializer componentInitializer))
					{
						continue;
					}
					bool flag = true;
					try
					{
						componentInitializer.InitializeNewComponent(defaultValues);
						flag = false;
					}
					finally
					{
						if (flag)
						{
							for (int j = 0; j < array.Length; j++)
							{
								host.DestroyComponent(array[j]);
							}
						}
					}
				}
			}
			return array;
		}

		protected virtual void Deserialize(SerializationInfo info, StreamingContext context)
		{
			string[] array = null;
			SerializationInfoEnumerator enumerator = info.GetEnumerator();
			while (enumerator.MoveNext())
			{
				SerializationEntry current = enumerator.Current;
				if (current.Name.Equals("PropertyNames"))
				{
					array = current.Value as string[];
					break;
				}
			}
			if (array == null)
			{
				array = new string[6] { "AssemblyName", "Bitmap", "DisplayName", "Filter", "IsTransient", "TypeName" };
			}
			SerializationInfoEnumerator enumerator2 = info.GetEnumerator();
			while (enumerator2.MoveNext())
			{
				SerializationEntry current2 = enumerator2.Current;
				string[] array2 = array;
				foreach (string text in array2)
				{
					if (text.Equals(current2.Name))
					{
						Properties[current2.Name] = current2.Value;
						break;
					}
				}
			}
			if (info.GetBoolean("Locked"))
			{
				Lock();
			}
		}

		public override bool Equals(object obj)
		{
			if (this == obj)
			{
				return true;
			}
			if (obj == null)
			{
				return false;
			}
			if (obj.GetType() != GetType())
			{
				return false;
			}
			ToolboxItem toolboxItem = (ToolboxItem)obj;
			if (TypeName != toolboxItem.TypeName)
			{
				if (TypeName == null || toolboxItem.TypeName == null)
				{
					return false;
				}
				if (!TypeName.Equals(toolboxItem.TypeName))
				{
					return false;
				}
			}
			if (AssemblyName != toolboxItem.AssemblyName)
			{
				if (AssemblyName == null || toolboxItem.AssemblyName == null)
				{
					return false;
				}
				if (!AssemblyName.FullName.Equals(toolboxItem.AssemblyName.FullName))
				{
					return false;
				}
			}
			if (DisplayName != toolboxItem.DisplayName)
			{
				if (DisplayName == null || toolboxItem.DisplayName == null)
				{
					return false;
				}
				if (!DisplayName.Equals(toolboxItem.DisplayName))
				{
					return false;
				}
			}
			return true;
		}

		public override int GetHashCode()
		{
			int num = 0;
			if (TypeName != null)
			{
				num ^= TypeName.GetHashCode();
			}
			return num ^ DisplayName.GetHashCode();
		}

		protected virtual object FilterPropertyValue(string propertyName, object value)
		{
			switch (propertyName)
			{
			case "AssemblyName":
				if (value != null)
				{
					value = ((AssemblyName)value).Clone();
				}
				break;
			case "DisplayName":
			case "TypeName":
				if (value == null)
				{
					value = string.Empty;
				}
				break;
			case "Filter":
				if (value == null)
				{
					value = new ToolboxItemFilterAttribute[0];
				}
				break;
			case "IsTransient":
				if (value == null)
				{
					value = false;
				}
				break;
			}
			return value;
		}

		public Type GetType(IDesignerHost host)
		{
			return GetType(host, AssemblyName, TypeName, reference: false);
		}

		protected virtual Type GetType(IDesignerHost host, AssemblyName assemblyName, string typeName, bool reference)
		{
			ITypeResolutionService typeResolutionService = null;
			Type type = null;
			if (typeName == null)
			{
				throw new ArgumentNullException("typeName");
			}
			if (host != null)
			{
				typeResolutionService = (ITypeResolutionService)host.GetService(typeof(ITypeResolutionService));
			}
			if (typeResolutionService != null)
			{
				if (reference)
				{
					if (assemblyName != null)
					{
						typeResolutionService.ReferenceAssembly(assemblyName);
						type = typeResolutionService.GetType(typeName);
					}
					else
					{
						type = typeResolutionService.GetType(typeName);
						if (type == null)
						{
							type = Type.GetType(typeName);
						}
						if (type != null)
						{
							typeResolutionService.ReferenceAssembly(type.Assembly.GetName());
						}
					}
				}
				else
				{
					if (assemblyName != null)
					{
						Assembly assembly = typeResolutionService.GetAssembly(assemblyName);
						if (assembly != null)
						{
							type = assembly.GetType(typeName);
						}
					}
					if (type == null)
					{
						type = typeResolutionService.GetType(typeName);
					}
				}
			}
			else if (!string.IsNullOrEmpty(typeName))
			{
				if (assemblyName != null)
				{
					Assembly assembly2 = null;
					try
					{
						assembly2 = Assembly.Load(assemblyName);
					}
					catch (FileNotFoundException)
					{
					}
					catch (BadImageFormatException)
					{
					}
					catch (IOException)
					{
					}
					if (assembly2 == null && assemblyName.CodeBase != null && assemblyName.CodeBase.Length > 0)
					{
						try
						{
							assembly2 = Assembly.LoadFrom(assemblyName.CodeBase);
						}
						catch (FileNotFoundException)
						{
						}
						catch (BadImageFormatException)
						{
						}
						catch (IOException)
						{
						}
					}
					if (assembly2 != null)
					{
						type = assembly2.GetType(typeName);
					}
				}
				if (type == null)
				{
					type = Type.GetType(typeName, throwOnError: false);
				}
			}
			return type;
		}

		private AssemblyName GetNonRetargetedAssemblyName(Type type, AssemblyName policiedAssemblyName)
		{
			if (type == null || policiedAssemblyName == null)
			{
				return null;
			}
			if (type.Assembly.FullName == policiedAssemblyName.FullName)
			{
				return policiedAssemblyName;
			}
			AssemblyName[] referencedAssemblies = type.Assembly.GetReferencedAssemblies();
			foreach (AssemblyName assemblyName in referencedAssemblies)
			{
				if (assemblyName.FullName == policiedAssemblyName.FullName)
				{
					return assemblyName;
				}
			}
			AssemblyName[] referencedAssemblies2 = type.Assembly.GetReferencedAssemblies();
			foreach (AssemblyName assemblyName2 in referencedAssemblies2)
			{
				if (assemblyName2.Name == policiedAssemblyName.Name)
				{
					return assemblyName2;
				}
			}
			AssemblyName[] referencedAssemblies3 = type.Assembly.GetReferencedAssemblies();
			foreach (AssemblyName assemblyName3 in referencedAssemblies3)
			{
				Assembly assembly = null;
				try
				{
					assembly = Assembly.Load(assemblyName3);
					if (assembly != null && assembly.FullName == policiedAssemblyName.FullName)
					{
						return assemblyName3;
					}
				}
				catch
				{
				}
			}
			return null;
		}

		public virtual void Initialize(Type type)
		{
			CheckUnlocked();
			if (type == null)
			{
				return;
			}
			TypeName = type.FullName;
			AssemblyName name = type.Assembly.GetName(copiedName: true);
			if (type.Assembly.GlobalAssemblyCache)
			{
				name.CodeBase = null;
			}
			Dictionary<string, AssemblyName> dictionary = new Dictionary<string, AssemblyName>();
			for (Type type2 = type; type2 != null; type2 = type2.BaseType)
			{
				AssemblyName name2 = type2.Assembly.GetName(copiedName: true);
				AssemblyName nonRetargetedAssemblyName = GetNonRetargetedAssemblyName(type, name2);
				if (nonRetargetedAssemblyName != null && !dictionary.ContainsKey(nonRetargetedAssemblyName.FullName))
				{
					dictionary[nonRetargetedAssemblyName.FullName] = nonRetargetedAssemblyName;
				}
			}
			AssemblyName[] array = new AssemblyName[dictionary.Count];
			int num = 0;
			foreach (AssemblyName value in dictionary.Values)
			{
				array[num++] = value;
			}
			DependentAssemblies = array;
			AssemblyName = name;
			DisplayName = type.Name;
			if (type.Assembly.ReflectionOnly)
			{
				return;
			}
			object[] customAttributes = type.Assembly.GetCustomAttributes(typeof(AssemblyCompanyAttribute), inherit: true);
			if (customAttributes != null && customAttributes.Length > 0 && customAttributes[0] is AssemblyCompanyAttribute assemblyCompanyAttribute && assemblyCompanyAttribute.Company != null)
			{
				Company = assemblyCompanyAttribute.Company;
			}
			DescriptionAttribute descriptionAttribute = (DescriptionAttribute)TypeDescriptor.GetAttributes(type)[typeof(DescriptionAttribute)];
			if (descriptionAttribute != null)
			{
				Description = descriptionAttribute.Description;
			}
			ToolboxBitmapAttribute toolboxBitmapAttribute = (ToolboxBitmapAttribute)TypeDescriptor.GetAttributes(type)[typeof(ToolboxBitmapAttribute)];
			if (toolboxBitmapAttribute != null)
			{
				Bitmap bitmap = toolboxBitmapAttribute.GetImage(type, large: false) as Bitmap;
				if (bitmap != null && (bitmap.Width != 16 || bitmap.Height != 16))
				{
					bitmap = new Bitmap(bitmap, new Size(16, 16));
				}
				Bitmap = bitmap;
			}
			bool flag = false;
			ArrayList arrayList = new ArrayList();
			foreach (Attribute attribute in TypeDescriptor.GetAttributes(type))
			{
				if (attribute is ToolboxItemFilterAttribute toolboxItemFilterAttribute)
				{
					if (toolboxItemFilterAttribute.FilterString.Equals(TypeName))
					{
						flag = true;
					}
					arrayList.Add(toolboxItemFilterAttribute);
				}
			}
			if (!flag)
			{
				arrayList.Add(new ToolboxItemFilterAttribute(TypeName));
			}
			Filter = (ToolboxItemFilterAttribute[])arrayList.ToArray(typeof(ToolboxItemFilterAttribute));
		}

		public virtual void Lock()
		{
			locked = true;
		}

		protected virtual void OnComponentsCreated(ToolboxComponentsCreatedEventArgs args)
		{
			if (componentsCreatedEvent != null)
			{
				componentsCreatedEvent(this, args);
			}
		}

		protected virtual void OnComponentsCreating(ToolboxComponentsCreatingEventArgs args)
		{
			if (componentsCreatingEvent != null)
			{
				componentsCreatingEvent(this, args);
			}
		}

		protected virtual void Serialize(SerializationInfo info, StreamingContext context)
		{
			_ = ToolboxItemPersist.TraceVerbose;
			info.AddValue("Locked", Locked);
			ArrayList arrayList = new ArrayList(Properties.Count);
			foreach (DictionaryEntry property in Properties)
			{
				arrayList.Add(property.Key);
				info.AddValue((string)property.Key, property.Value);
			}
			info.AddValue("PropertyNames", (string[])arrayList.ToArray(typeof(string)));
		}

		public override string ToString()
		{
			return DisplayName;
		}

		protected void ValidatePropertyType(string propertyName, object value, Type expectedType, bool allowNull)
		{
			if (value == null)
			{
				if (!allowNull)
				{
					throw new ArgumentNullException("value");
				}
			}
			else if (!expectedType.IsInstanceOfType(value))
			{
				throw new ArgumentException(SR.GetString("ToolboxItemInvalidPropertyType", propertyName, expectedType.FullName), "value");
			}
		}

		protected virtual object ValidatePropertyValue(string propertyName, object value)
		{
			switch (propertyName)
			{
			case "AssemblyName":
				ValidatePropertyType(propertyName, value, typeof(AssemblyName), allowNull: true);
				break;
			case "Bitmap":
				ValidatePropertyType(propertyName, value, typeof(Bitmap), allowNull: true);
				break;
			case "Company":
			case "Description":
			case "DisplayName":
			case "TypeName":
				ValidatePropertyType(propertyName, value, typeof(string), allowNull: true);
				if (value == null)
				{
					value = string.Empty;
				}
				break;
			case "Filter":
			{
				ValidatePropertyType(propertyName, value, typeof(ICollection), allowNull: true);
				int num = 0;
				ICollection collection = (ICollection)value;
				if (collection != null)
				{
					foreach (object item in collection)
					{
						if (item is ToolboxItemFilterAttribute)
						{
							num++;
						}
					}
				}
				ToolboxItemFilterAttribute[] array = new ToolboxItemFilterAttribute[num];
				if (collection != null)
				{
					num = 0;
					foreach (object item2 in collection)
					{
						if (item2 is ToolboxItemFilterAttribute toolboxItemFilterAttribute)
						{
							array[num++] = toolboxItemFilterAttribute;
						}
					}
				}
				value = array;
				break;
			}
			case "IsTransient":
				ValidatePropertyType(propertyName, value, typeof(bool), allowNull: false);
				break;
			}
			return value;
		}

		void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
		{
			IntSecurity.UnmanagedCode.Demand();
			Serialize(info, context);
		}
	}
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	public sealed class ToolboxItemCollection : ReadOnlyCollectionBase
	{
		public ToolboxItem this[int index] => (ToolboxItem)base.InnerList[index];

		public ToolboxItemCollection(ToolboxItemCollection value)
		{
			base.InnerList.AddRange(value);
		}

		public ToolboxItemCollection(ToolboxItem[] value)
		{
			base.InnerList.AddRange(value);
		}

		public bool Contains(ToolboxItem value)
		{
			return base.InnerList.Contains(value);
		}

		public void CopyTo(ToolboxItem[] array, int index)
		{
			base.InnerList.CopyTo(array, index);
		}

		public int IndexOf(ToolboxItem value)
		{
			return base.InnerList.IndexOf(value);
		}
	}
	public delegate ToolboxItem ToolboxItemCreatorCallback(object serializedObject, string format);
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	public class UITypeEditor
	{
		public virtual bool IsDropDownResizable => false;

		static UITypeEditor()
		{
			Hashtable table = new Hashtable
			{
				[typeof(DateTime)] = "System.ComponentModel.Design.DateTimeEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
				[typeof(Array)] = "System.ComponentModel.Design.ArrayEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
				[typeof(IList)] = "System.ComponentModel.Design.CollectionEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
				[typeof(ICollection)] = "System.ComponentModel.Design.CollectionEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
				[typeof(byte[])] = "System.ComponentModel.Design.BinaryEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
				[typeof(Stream)] = "System.ComponentModel.Design.BinaryEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
				[typeof(string[])] = "System.Windows.Forms.Design.StringArrayEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
				[typeof(Collection<string>)] = "System.Windows.Forms.Design.StringCollectionEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"
			};
			TypeDescriptor.AddEditorTable(typeof(UITypeEditor), table);
		}

		public object EditValue(IServiceProvider provider, object value)
		{
			return EditValue(null, provider, value);
		}

		public virtual object EditValue(ITypeDescriptorContext context, IServiceProvider provider, object value)
		{
			return value;
		}

		public UITypeEditorEditStyle GetEditStyle()
		{
			return GetEditStyle(null);
		}

		public bool GetPaintValueSupported()
		{
			return GetPaintValueSupported(null);
		}

		public virtual bool GetPaintValueSupported(ITypeDescriptorContext context)
		{
			return false;
		}

		public virtual UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context)
		{
			return UITypeEditorEditStyle.None;
		}

		public void PaintValue(object value, Graphics canvas, Rectangle rectangle)
		{
			PaintValue(new PaintValueEventArgs(null, value, canvas, rectangle));
		}

		public virtual void PaintValue(PaintValueEventArgs e)
		{
		}
	}
	public enum UITypeEditorEditStyle
	{
		None = 1,
		Modal,
		DropDown
	}
}
namespace System.Drawing.Printing
{
	public abstract class PrintController
	{
		[SecurityCritical]
		internal sealed class SafeDeviceModeHandle : SafeHandle
		{
			public override bool IsInvalid => handle == IntPtr.Zero;

			private SafeDeviceModeHandle()
				: base(IntPtr.Zero, ownsHandle: true)
			{
			}

			internal SafeDeviceModeHandle(IntPtr handle)
				: base(IntPtr.Zero, ownsHandle: true)
			{
				SetHandle(handle);
			}

			[SecurityCritical]
			protected override bool ReleaseHandle()
			{
				if (!IsInvalid)
				{
					SafeNativeMethods.GlobalFree(new HandleRef(this, handle));
				}
				handle = IntPtr.Zero;
				return true;
			}

			public static implicit operator IntPtr(SafeDeviceModeHandle handle)
			{
				return handle?.handle ?? IntPtr.Zero;
			}

			public static explicit operator SafeDeviceModeHandle(IntPtr handle)
			{
				return new SafeDeviceModeHandle(handle);
			}
		}

		internal SafeDeviceModeHandle modeHandle;

		public virtual bool IsPreview => false;

		protected PrintController()
		{
			IntSecurity.SafePrinting.Demand();
		}

		internal void Print(PrintDocument document)
		{
			IntSecurity.SafePrinting.Demand();
			PrintAction action = (IsPreview ? PrintAction.PrintToPreview : ((!document.PrinterSettings.PrintToFile) ? PrintAction.PrintToPrinter : PrintAction.PrintToFile));
			PrintEventArgs printEventArgs = new PrintEventArgs(action);
			document._OnBeginPrint(printEventArgs);
			if (printEventArgs.Cancel)
			{
				document._OnEndPrint(printEventArgs);
				return;
			}
			OnStartPrint(document, printEventArgs);
			if (printEventArgs.Cancel)
			{
				document._OnEndPrint(printEventArgs);
				OnEndPrint(document, printEventArgs);
				return;
			}
			bool flag = true;
			try
			{
				flag = PrintLoop(document);
			}
			finally
			{
				try
				{
					try
					{
						document._OnEndPrint(printEventArgs);
						printEventArgs.Cancel = flag | printEventArgs.Cancel;
					}
					finally
					{
						OnEndPrint(document, printEventArgs);
					}
				}
				finally
				{
					if (!IntSecurity.HasPermission(IntSecurity.AllPrinting))
					{
						IntSecurity.AllPrinting.Assert();
						document.PrinterSettings.PrintDialogDisplayed = false;
					}
				}
			}
		}

		private bool PrintLoop(PrintDocument document)
		{
			QueryPageSettingsEventArgs queryPageSettingsEventArgs = new QueryPageSettingsEventArgs((PageSettings)document.DefaultPageSettings.Clone());
			PrintPageEventArgs printPageEventArgs;
			do
			{
				document._OnQueryPageSettings(queryPageSettingsEventArgs);
				if (queryPageSettingsEventArgs.Cancel)
				{
					return true;
				}
				printPageEventArgs = CreatePrintPageEvent(queryPageSettingsEventArgs.PageSettings);
				Graphics graphics = OnStartPage(document, printPageEventArgs);
				printPageEventArgs.SetGraphics(graphics);
				try
				{
					document._OnPrintPage(printPageEventArgs);
					OnEndPage(document, printPageEventArgs);
				}
				finally
				{
					printPageEventArgs.Dispose();
				}
				if (printPageEventArgs.Cancel)
				{
					return true;
				}
			}
			while (printPageEventArgs.HasMorePages);
			return false;
		}

		private PrintPageEventArgs CreatePrintPageEvent(PageSettings pageSettings)
		{
			IntSecurity.AllPrintingAndUnmanagedCode.Assert();
			Rectangle bounds = pageSettings.GetBounds(modeHandle);
			Rectangle marginBounds = new Rectangle(pageSettings.Margins.Left, pageSettings.Margins.Top, bounds.Width - (pageSettings.Margins.Left + pageSettings.Margins.Right), bounds.Height - (pageSettings.Margins.Top + pageSettings.Margins.Bottom));
			return new PrintPageEventArgs(null, marginBounds, bounds, pageSettings);
		}

		public virtual void OnStartPrint(PrintDocument document, PrintEventArgs e)
		{
			IntSecurity.AllPrintingAndUnmanagedCode.Assert();
			modeHandle = (SafeDeviceModeHandle)document.PrinterSettings.GetHdevmode(document.DefaultPageSettings);
		}

		public virtual Graphics OnStartPage(PrintDocument document, PrintPageEventArgs e)
		{
			return null;
		}

		public virtual void OnEndPage(PrintDocument document, PrintPageEventArgs e)
		{
		}

		public virtual void OnEndPrint(PrintDocument document, PrintEventArgs e)
		{
			IntSecurity.UnmanagedCode.Assert();
			if (modeHandle != null)
			{
				modeHandle.Close();
			}
		}
	}
	public class StandardPrintController : PrintController
	{
		private DeviceContext dc;

		private Graphics graphics;

		private void CheckSecurity(PrintDocument document)
		{
			if (document.PrinterSettings.PrintDialogDisplayed)
			{
				IntSecurity.SafePrinting.Demand();
			}
			else if (document.PrinterSettings.IsDefaultPrinter)
			{
				IntSecurity.DefaultPrinting.Demand();
			}
			else
			{
				IntSecurity.AllPrinting.Demand();
			}
		}

		public override void OnStartPrint(PrintDocument document, PrintEventArgs e)
		{
			CheckSecurity(document);
			base.OnStartPrint(document, e);
			if (!document.PrinterSettings.IsValid)
			{
				throw new InvalidPrinterException(document.PrinterSettings);
			}
			dc = document.PrinterSettings.CreateDeviceContext(modeHandle);
			SafeNativeMethods.DOCINFO dOCINFO = new SafeNativeMethods.DOCINFO();
			dOCINFO.lpszDocName = document.DocumentName;
			if (document.PrinterSettings.PrintToFile)
			{
				dOCINFO.lpszOutput = document.PrinterSettings.OutputPort;
			}
			else
			{
				dOCINFO.lpszOutput = null;
			}
			dOCINFO.lpszDatatype = null;
			dOCINFO.fwType = 0;
			int num = SafeNativeMethods.StartDoc(new HandleRef(dc, dc.Hdc), dOCINFO);
			if (num <= 0)
			{
				int lastWin32Error = Marshal.GetLastWin32Error();
				if (lastWin32Error != 1223)
				{
					throw new Win32Exception(lastWin32Error);
				}
				e.Cancel = true;
			}
		}

		public override Graphics OnStartPage(PrintDocument document, PrintPageEventArgs e)
		{
			CheckSecurity(document);
			base.OnStartPage(document, e);
			try
			{
				IntSecurity.AllPrintingAndUnmanagedCode.Assert();
				e.PageSettings.CopyToHdevmode(modeHandle);
				IntPtr handle = SafeNativeMethods.GlobalLock(new HandleRef(this, modeHandle));
				try
				{
					SafeNativeMethods.ResetDC(new HandleRef(dc, dc.Hdc), new HandleRef(null, handle));
				}
				finally
				{
					SafeNativeMethods.GlobalUnlock(new HandleRef(this, modeHandle));
				}
			}
			finally
			{
				CodeAccessPermission.RevertAssert();
			}
			graphics = Graphics.FromHdcInternal(dc.Hdc);
			if (graphics != null && document.OriginAtMargins)
			{
				int deviceCaps = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(dc, dc.Hdc), 88);
				int deviceCaps2 = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(dc, dc.Hdc), 90);
				int deviceCaps3 = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(dc, dc.Hdc), 112);
				int deviceCaps4 = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(dc, dc.Hdc), 113);
				float num = deviceCaps3 * 100 / deviceCaps;
				float num2 = deviceCaps4 * 100 / deviceCaps2;
				graphics.TranslateTransform(0f - num, 0f - num2);
				graphics.TranslateTransform(document.DefaultPageSettings.Margins.Left, document.DefaultPageSettings.Margins.Top);
			}
			int num3 = SafeNativeMethods.StartPage(new HandleRef(dc, dc.Hdc));
			if (num3 <= 0)
			{
				throw new Win32Exception();
			}
			return graphics;
		}

		public override void OnEndPage(PrintDocument document, PrintPageEventArgs e)
		{
			CheckSecurity(document);
			IntSecurity.UnmanagedCode.Assert();
			try
			{
				int num = SafeNativeMethods.EndPage(new HandleRef(dc, dc.Hdc));
				if (num <= 0)
				{
					throw new Win32Exception();
				}
			}
			finally
			{
				CodeAccessPermission.RevertAssert();
				graphics.Dispose();
				graphics = null;
			}
			base.OnEndPage(document, e);
		}

		public override void OnEndPrint(PrintDocument document, PrintEventArgs e)
		{
			CheckSecurity(document);
			IntSecurity.UnmanagedCode.Assert();
			try
			{
				if (dc != null)
				{
					try
					{
						int num = (e.Cancel ? SafeNativeMethods.AbortDoc(new HandleRef(dc, dc.Hdc)) : SafeNativeMethods.EndDoc(new HandleRef(dc, dc.Hdc)));
						if (num <= 0)
						{
							throw new Win32Exception();
						}
					}
					finally
					{
						dc.Dispose();
						dc = null;
					}
				}
			}
			finally
			{
				CodeAccessPermission.RevertAssert();
			}
			base.OnEndPrint(document, e);
		}
	}
	[Serializable]
	public enum Duplex
	{
		Default = -1,
		Simplex = 1,
		Horizontal = 3,
		Vertical = 2
	}
	[Serializable]
	public class InvalidPrinterException : SystemException
	{
		private PrinterSettings settings;

		public InvalidPrinterException(PrinterSettings settings)
			: base(GenerateMessage(settings))
		{
			this.settings = settings;
		}

		protected InvalidPrinterException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
			settings = (PrinterSettings)info.GetValue("settings", typeof(PrinterSettings));
		}

		[SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
		public override void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			if (info == null)
			{
				throw new ArgumentNullException("info");
			}
			IntSecurity.AllPrinting.Demand();
			info.AddValue("settings", settings);
			base.GetObjectData(info, context);
		}

		private static string GenerateMessage(PrinterSettings settings)
		{
			if (settings.IsDefaultPrinter)
			{
				return SR.GetString("InvalidPrinterException_NoDefaultPrinter");
			}
			try
			{
				return SR.GetString("InvalidPrinterException_InvalidPrinter", settings.PrinterName);
			}
			catch (SecurityException)
			{
				return SR.GetString("InvalidPrinterException_InvalidPrinter", SR.GetString("CantTellPrinterName"));
			}
		}
	}
	[Serializable]
	[TypeConverter(typeof(MarginsConverter))]
	public class Margins : ICloneable
	{
		private int left;

		private int right;

		private int top;

		private int bottom;

		public int Left
		{
			get
			{
				return left;
			}
			set
			{
				CheckMargin(value, "Left");
				left = value;
			}
		}

		public int Right
		{
			get
			{
				return right;
			}
			set
			{
				CheckMargin(value, "Right");
				right = value;
			}
		}

		public int Top
		{
			get
			{
				return top;
			}
			set
			{
				CheckMargin(value, "Top");
				top = value;
			}
		}

		public int Bottom
		{
			get
			{
				return bottom;
			}
			set
			{
				CheckMargin(value, "Bottom");
				bottom = value;
			}
		}

		public Margins()
			: this(100, 100, 100, 100)
		{
		}

		public Margins(int left, int right, int top, int bottom)
		{
			CheckMargin(left, "left");
			CheckMargin(right, "right");
			CheckMargin(top, "top");
			CheckMargin(bottom, "bottom");
			this.left = left;
			this.right = right;
			this.top = top;
			this.bottom = bottom;
		}

		private void CheckMargin(int margin, string name)
		{
			if (margin < 0)
			{
				throw new ArgumentException(SR.GetString("InvalidLowBoundArgumentEx", name, margin, "0"));
			}
		}

		public object Clone()
		{
			return MemberwiseClone();
		}

		public override bool Equals(object obj)
		{
			Margins margins = obj as Margins;
			if (margins == this)
			{
				return true;
			}
			if (margins == null)
			{
				return false;
			}
			if (margins.left == left && margins.right == right && margins.top == top)
			{
				return margins.bottom == bottom;
			}
			return false;
		}

		public override int GetHashCode()
		{
			uint num = (uint)left;
			uint num2 = (uint)right;
			uint num3 = (uint)top;
			uint num4 = (uint)bottom;
			return (int)(num ^ ((num2 << 13) | (num2 >> 19)) ^ ((num3 << 26) | (num3 >> 6)) ^ ((num4 << 7) | (num4 >> 25)));
		}

		public static bool operator ==(Margins m1, Margins m2)
		{
			if (object.ReferenceEquals(m1, null) != object.ReferenceEquals(m2, null))
			{
				return false;
			}
			if (!object.ReferenceEquals(m1, null))
			{
				if (m1.Left == m2.Left && m1.Top == m2.Top && m1.Right == m2.Right)
				{
					return m1.Bottom == m2.Bottom;
				}
				return false;
			}
			return true;
		}

		public static bool operator !=(Margins m1, Margins m2)
		{
			return !(m1 == m2);
		}

		public override string ToString()
		{
			return "[Margins Left=" + Left.ToString(CultureInfo.InvariantCulture) + " Right=" + Right.ToString(CultureInfo.InvariantCulture) + " Top=" + Top.ToString(CultureInfo.InvariantCulture) + " Bottom=" + Bottom.ToString(CultureInfo.InvariantCulture) + "]";
		}
	}
	public class MarginsConverter : ExpandableObjectConverter
	{
		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
		{
			if (sourceType == typeof(string))
			{
				return true;
			}
			return base.CanConvertFrom(context, sourceType);
		}

		public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
		{
			if (destinationType == typeof(InstanceDescriptor))
			{
				return true;
			}
			return base.CanConvertTo(context, destinationType);
		}

		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
		{
			if (value is string text)
			{
				string text2 = text.Trim();
				if (text2.Length == 0)
				{
					return null;
				}
				if (culture == null)
				{
					culture = CultureInfo.CurrentCulture;
				}
				char c = culture.TextInfo.ListSeparator[0];
				string[] array = text2.Split(c);
				int[] array2 = new int[array.Length];
				TypeConverter converter = TypeDescriptor.GetConverter(typeof(int));
				for (int i = 0; i < array2.Length; i++)
				{
					array2[i] = (int)converter.ConvertFromString(context, culture, array[i]);
				}
				if (array2.Length != 4)
				{
					throw new ArgumentException(SR.GetString("TextParseFailedFormat", text2, "left, right, top, bottom"));
				}
				return new Margins(array2[0], array2[1], array2[2], array2[3]);
			}
			return base.ConvertFrom(context, culture, value);
		}

		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (value is Margins)
			{
				if (destinationType == typeof(string))
				{
					Margins margins = (Margins)value;
					if (culture == null)
					{
						culture = CultureInfo.CurrentCulture;
					}
					string separator = culture.TextInfo.ListSeparator + " ";
					TypeConverter converter = TypeDescriptor.GetConverter(typeof(int));
					string[] array = new string[4];
					int num = 0;
					array[num++] = converter.ConvertToString(context, culture, margins.Left);
					array[num++] = converter.ConvertToString(context, culture, margins.Right);
					array[num++] = converter.ConvertToString(context, culture, margins.Top);
					array[num++] = converter.ConvertToString(context, culture, margins.Bottom);
					return string.Join(separator, array);
				}
				if (destinationType == typeof(InstanceDescriptor))
				{
					Margins margins2 = (Margins)value;
					ConstructorInfo constructor = typeof(Margins).GetConstructor(new Type[4]
					{
						typeof(int),
						typeof(int),
						typeof(int),
						typeof(int)
					});
					if (constructor != null)
					{
						return new InstanceDescriptor(constructor, new object[4] { margins2.Left, margins2.Right, margins2.Top, margins2.Bottom });
					}
				}
			}
			return base.ConvertTo(context, culture, value, destinationType);
		}

		public override object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues)
		{
			if (propertyValues == null)
			{
				throw new ArgumentNullException("propertyValues");
			}
			object obj = propertyValues["Left"];
			object obj2 = propertyValues["Right"];
			object obj3 = propertyValues["Top"];
			object obj4 = propertyValues["Bottom"];
			if (obj == null || obj2 == null || obj4 == null || obj3 == null || !(obj is int) || !(obj2 is int) || !(obj4 is int) || !(obj3 is int))
			{
				throw new ArgumentException(SR.GetString("PropertyValueInvalidEntry"));
			}
			return new Margins((int)obj, (int)obj2, (int)obj3, (int)obj4);
		}

		public override bool GetCreateInstanceSupported(ITypeDescriptorContext context)
		{
			return true;
		}
	}
	internal enum ModeField
	{
		Orientation,
		PaperSize,
		PaperLength,
		PaperWidth,
		Copies,
		DefaultSource,
		PrintQuality,
		Color,
		Duplex,
		YResolution,
		TTOption,
		Collate
	}
	[Serializable]
	public class PageSettings : ICloneable
	{
		internal PrinterSettings printerSettings;

		private TriState color = TriState.Default;

		private PaperSize paperSize;

		private PaperSource paperSource;

		private PrinterResolution printerResolution;

		private TriState landscape = TriState.Default;

		private Margins margins = new Margins();

		public Rectangle Bounds
		{
			get
			{
				IntSecurity.AllPrintingAndUnmanagedCode.Assert();
				IntPtr hdevmode = printerSettings.GetHdevmode();
				Rectangle bounds = GetBounds(hdevmode);
				SafeNativeMethods.GlobalFree(new HandleRef(this, hdevmode));
				return bounds;
			}
		}

		public bool Color
		{
			get
			{
				if (color.IsDefault)
				{
					return printerSettings.GetModeField(ModeField.Color, 1) == 2;
				}
				return (bool)color;
			}
			set
			{
				color = value;
			}
		}

		public float HardMarginX
		{
			get
			{
				IntSecurity.AllPrintingAndUnmanagedCode.Assert();
				float num = 0f;
				DeviceContext deviceContext = printerSettings.CreateDeviceContext(this);
				try
				{
					int deviceCaps = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(deviceContext, deviceContext.Hdc), 88);
					int deviceCaps2 = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(deviceContext, deviceContext.Hdc), 112);
					return deviceCaps2 * 100 / deviceCaps;
				}
				finally
				{
					deviceContext.Dispose();
				}
			}
		}

		public float HardMarginY
		{
			get
			{
				float num = 0f;
				DeviceContext deviceContext = printerSettings.CreateDeviceContext(this);
				try
				{
					int deviceCaps = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(deviceContext, deviceContext.Hdc), 90);
					int deviceCaps2 = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(deviceContext, deviceContext.Hdc), 113);
					return deviceCaps2 * 100 / deviceCaps;
				}
				finally
				{
					deviceContext.Dispose();
				}
			}
		}

		public bool Landscape
		{
			get
			{
				if (landscape.IsDefault)
				{
					return printerSettings.GetModeField(ModeField.Orientation, 1) == 2;
				}
				return (bool)landscape;
			}
			set
			{
				landscape = value;
			}
		}

		public Margins Margins
		{
			get
			{
				return margins;
			}
			set
			{
				margins = value;
			}
		}

		public PaperSize PaperSize
		{
			get
			{
				IntSecurity.AllPrintingAndUnmanagedCode.Assert();
				return GetPaperSize(IntPtr.Zero);
			}
			set
			{
				paperSize = value;
			}
		}

		public PaperSource PaperSource
		{
			get
			{
				if (paperSource == null)
				{
					IntSecurity.AllPrintingAndUnmanagedCode.Assert();
					IntPtr hdevmode = printerSettings.GetHdevmode();
					IntPtr lparam = SafeNativeMethods.GlobalLock(new HandleRef(this, hdevmode));
					SafeNativeMethods.DEVMODE mode = (SafeNativeMethods.DEVMODE)UnsafeNativeMethods.PtrToStructure(lparam, typeof(SafeNativeMethods.DEVMODE));
					PaperSource result = PaperSourceFromMode(mode);
					SafeNativeMethods.GlobalUnlock(new HandleRef(this, hdevmode));
					SafeNativeMethods.GlobalFree(new HandleRef(this, hdevmode));
					return result;
				}
				return paperSource;
			}
			set
			{
				paperSource = value;
			}
		}

		public RectangleF PrintableArea
		{
			get
			{
				RectangleF result = default(RectangleF);
				DeviceContext deviceContext = printerSettings.CreateInformationContext(this);
				HandleRef hDC = new HandleRef(deviceContext, deviceContext.Hdc);
				try
				{
					int deviceCaps = UnsafeNativeMethods.GetDeviceCaps(hDC, 88);
					int deviceCaps2 = UnsafeNativeMethods.GetDeviceCaps(hDC, 90);
					if (!Landscape)
					{
						result.X = (float)UnsafeNativeMethods.GetDeviceCaps(hDC, 112) * 100f / (float)deviceCaps;
						result.Y = (float)UnsafeNativeMethods.GetDeviceCaps(hDC, 113) * 100f / (float)deviceCaps2;
						result.Width = (float)UnsafeNativeMethods.GetDeviceCaps(hDC, 8) * 100f / (float)deviceCaps;
						result.Height = (float)UnsafeNativeMethods.GetDeviceCaps(hDC, 10) * 100f / (float)deviceCaps2;
						return result;
					}
					result.Y = (float)UnsafeNativeMethods.GetDeviceCaps(hDC, 112) * 100f / (float)deviceCaps;
					result.X = (float)UnsafeNativeMethods.GetDeviceCaps(hDC, 113) * 100f / (float)deviceCaps2;
					result.Height = (float)UnsafeNativeMethods.GetDeviceCaps(hDC, 8) * 100f / (float)deviceCaps;
					result.Width = (float)UnsafeNativeMethods.GetDeviceCaps(hDC, 10) * 100f / (float)deviceCaps2;
					return result;
				}
				finally
				{
					deviceContext.Dispose();
				}
			}
		}

		public PrinterResolution PrinterResolution
		{
			get
			{
				if (printerResolution == null)
				{
					IntSecurity.AllPrintingAndUnmanagedCode.Assert();
					IntPtr hdevmode = printerSettings.GetHdevmode();
					IntPtr lparam = SafeNativeMethods.GlobalLock(new HandleRef(this, hdevmode));
					SafeNativeMethods.DEVMODE mode = (SafeNativeMethods.DEVMODE)UnsafeNativeMethods.PtrToStructure(lparam, typeof(SafeNativeMethods.DEVMODE));
					PrinterResolution result = PrinterResolutionFromMode(mode);
					SafeNativeMethods.GlobalUnlock(new HandleRef(this, hdevmode));
					SafeNativeMethods.GlobalFree(new HandleRef(this, hdevmode));
					return result;
				}
				return printerResolution;
			}
			set
			{
				printerResolution = value;
			}
		}

		public PrinterSettings PrinterSettings
		{
			get
			{
				return printerSettings;
			}
			set
			{
				if (value == null)
				{
					value = new PrinterSettings();
				}
				printerSettings = value;
			}
		}

		private short ExtraBytes
		{
			get
			{
				IntPtr hdevmodeInternal = printerSettings.GetHdevmodeInternal();
				IntPtr lparam = SafeNativeMethods.GlobalLock(new HandleRef(this, hdevmodeInternal));
				SafeNativeMethods.DEVMODE dEVMODE = (SafeNativeMethods.DEVMODE)UnsafeNativeMethods.PtrToStructure(lparam, typeof(SafeNativeMethods.DEVMODE));
				short dmDriverExtra = dEVMODE.dmDriverExtra;
				SafeNativeMethods.GlobalUnlock(new HandleRef(this, hdevmodeInternal));
				SafeNativeMethods.GlobalFree(new HandleRef(this, hdevmodeInternal));
				return dmDriverExtra;
			}
		}

		public PageSettings()
			: this(new PrinterSettings())
		{
		}

		public PageSettings(PrinterSettings printerSettings)
		{
			this.printerSettings = printerSettings;
		}

		public object Clone()
		{
			PageSettings pageSettings = (PageSettings)MemberwiseClone();
			pageSettings.margins = (Margins)margins.Clone();
			return pageSettings;
		}

		public void CopyToHdevmode(IntPtr hdevmode)
		{
			IntSecurity.AllPrintingAndUnmanagedCode.Demand();
			IntPtr intPtr = SafeNativeMethods.GlobalLock(new HandleRef(null, hdevmode));
			SafeNativeMethods.DEVMODE dEVMODE = (SafeNativeMethods.DEVMODE)UnsafeNativeMethods.PtrToStructure(intPtr, typeof(SafeNativeMethods.DEVMODE));
			if (color.IsNotDefault && (dEVMODE.dmFields & 0x800) == 2048)
			{
				dEVMODE.dmColor = (short)((!(bool)color) ? 1 : 2);
			}
			if (landscape.IsNotDefault && (dEVMODE.dmFields & 1) == 1)
			{
				dEVMODE.dmOrientation = (short)((!(bool)landscape) ? 1 : 2);
			}
			if (paperSize != null)
			{
				if ((dEVMODE.dmFields & 2) == 2)
				{
					dEVMODE.dmPaperSize = (short)paperSize.RawKind;
				}
				bool flag = false;
				bool flag2 = false;
				if ((dEVMODE.dmFields & 4) == 4)
				{
					dEVMODE.dmPaperLength = (short)PrinterUnitConvert.Convert(paperSize.Height, PrinterUnit.Display, PrinterUnit.TenthsOfAMillimeter);
					flag2 = true;
				}
				if ((dEVMODE.dmFields & 8) == 8)
				{
					dEVMODE.dmPaperWidth = (short)PrinterUnitConvert.Convert(paperSize.Width, PrinterUnit.Display, PrinterUnit.TenthsOfAMillimeter);
					flag = true;
				}
				if (paperSize.Kind == PaperKind.Custom)
				{
					if (!flag2)
					{
						dEVMODE.dmFields |= 4;
						dEVMODE.dmPaperLength = (short)PrinterUnitConvert.Convert(paperSize.Height, PrinterUnit.Display, PrinterUnit.TenthsOfAMillimeter);
					}
					if (!flag)
					{
						dEVMODE.dmFields |= 8;
						dEVMODE.dmPaperWidth = (short)PrinterUnitConvert.Convert(paperSize.Width, PrinterUnit.Display, PrinterUnit.TenthsOfAMillimeter);
					}
				}
			}
			if (paperSource != null && (dEVMODE.dmFields & 0x200) == 512)
			{
				dEVMODE.dmDefaultSource = (short)paperSource.RawKind;
			}
			if (printerResolution != null)
			{
				if (printerResolution.Kind == PrinterResolutionKind.Custom)
				{
					if ((dEVMODE.dmFields & 0x400) == 1024)
					{
						dEVMODE.dmPrintQuality = (short)printerResolution.X;
					}
					if ((dEVMODE.dmFields & 0x2000) == 8192)
					{
						dEVMODE.dmYResolution = (short)printerResolution.Y;
					}
				}
				else if ((dEVMODE.dmFields & 0x400) == 1024)
				{
					dEVMODE.dmPrintQuality = (short)printerResolution.Kind;
				}
			}
			Marshal.StructureToPtr(dEVMODE, intPtr, fDeleteOld: false);
			if (dEVMODE.dmDriverExtra >= ExtraBytes)
			{
				int num = SafeNativeMethods.DocumentProperties(NativeMethods.NullHandleRef, NativeMethods.NullHandleRef, printerSettings.PrinterName, intPtr, intPtr, 10);
				if (num < 0)
				{
					SafeNativeMethods.GlobalFree(new HandleRef(null, intPtr));
				}
			}
			SafeNativeMethods.GlobalUnlock(new HandleRef(null, hdevmode));
		}

		internal Rectangle GetBounds(IntPtr modeHandle)
		{
			PaperSize paperSize = GetPaperSize(modeHandle);
			return (!GetLandscape(modeHandle)) ? new Rectangle(0, 0, paperSize.Width, paperSize.Height) : new Rectangle(0, 0, paperSize.Height, paperSize.Width);
		}

		private bool GetLandscape(IntPtr modeHandle)
		{
			if (landscape.IsDefault)
			{
				return printerSettings.GetModeField(ModeField.Orientation, 1, modeHandle) == 2;
			}
			return (bool)landscape;
		}

		private PaperSize GetPaperSize(IntPtr modeHandle)
		{
			if (paperSize == null)
			{
				bool flag = false;
				if (modeHandle == IntPtr.Zero)
				{
					modeHandle = printerSettings.GetHdevmode();
					flag = true;
				}
				IntPtr lparam = SafeNativeMethods.GlobalLock(new HandleRef(null, modeHandle));
				SafeNativeMethods.DEVMODE mode = (SafeNativeMethods.DEVMODE)UnsafeNativeMethods.PtrToStructure(lparam, typeof(SafeNativeMethods.DEVMODE));
				PaperSize result = PaperSizeFromMode(mode);
				SafeNativeMethods.GlobalUnlock(new HandleRef(null, modeHandle));
				if (flag)
				{
					SafeNativeMethods.GlobalFree(new HandleRef(null, modeHandle));
				}
				return result;
			}
			return paperSize;
		}

		private PaperSize PaperSizeFromMode(SafeNativeMethods.DEVMODE mode)
		{
			PaperSize[] paperSizes = printerSettings.Get_PaperSizes();
			if ((mode.dmFields & 2) == 2)
			{
				for (int i = 0; i < paperSizes.Length; i++)
				{
					if (paperSizes[i].RawKind == mode.dmPaperSize)
					{
						return paperSizes[i];
					}
				}
			}
			return new PaperSize(PaperKind.Custom, "custom", PrinterUnitConvert.Convert(mode.dmPaperWidth, PrinterUnit.TenthsOfAMillimeter, PrinterUnit.Display), PrinterUnitConvert.Convert(mode.dmPaperLength, PrinterUnit.TenthsOfAMillimeter, PrinterUnit.Display));
		}

		private PaperSource PaperSourceFromMode(SafeNativeMethods.DEVMODE mode)
		{
			PaperSource[] paperSources = printerSettings.Get_PaperSources();
			if ((mode.dmFields & 0x200) == 512)
			{
				for (int i = 0; i < paperSources.Length; i++)
				{
					if ((short)paperSources[i].RawKind == mode.dmDefaultSource)
					{
						return paperSources[i];
					}
				}
			}
			return new PaperSource((PaperSourceKind)mode.dmDefaultSource, "unknown");
		}

		private PrinterResolution PrinterResolutionFromMode(SafeNativeMethods.DEVMODE mode)
		{
			PrinterResolution[] printerResolutions = printerSettings.Get_PrinterResolutions();
			for (int i = 0; i < printerResolutions.Length; i++)
			{
				if (mode.dmPrintQuality >= 0 && (mode.dmFields & 0x400) == 1024 && (mode.dmFields & 0x2000) == 8192)
				{
					if (printerResolutions[i].X == mode.dmPrintQuality && printerResolutions[i].Y == mode.dmYResolution)
					{
						return printerResolutions[i];
					}
				}
				else if ((mode.dmFields & 0x400) == 1024 && printerResolutions[i].Kind == (PrinterResolutionKind)mode.dmPrintQuality)
				{
					return printerResolutions[i];
				}
			}
			return new PrinterResolution(PrinterResolutionKind.Custom, mode.dmPrintQuality, mode.dmYResolution);
		}

		public void SetHdevmode(IntPtr hdevmode)
		{
			IntSecurity.AllPrintingAndUnmanagedCode.Demand();
			if (hdevmode == IntPtr.Zero)
			{
				throw new ArgumentException(SR.GetString("InvalidPrinterHandle", hdevmode));
			}
			IntPtr lparam = SafeNativeMethods.GlobalLock(new HandleRef(null, hdevmode));
			SafeNativeMethods.DEVMODE dEVMODE = (SafeNativeMethods.DEVMODE)UnsafeNativeMethods.PtrToStructure(lparam, typeof(SafeNativeMethods.DEVMODE));
			if ((dEVMODE.dmFields & 0x800) == 2048)
			{
				color = dEVMODE.dmColor == 2;
			}
			if ((dEVMODE.dmFields & 1) == 1)
			{
				landscape = dEVMODE.dmOrientation == 2;
			}
			paperSize = PaperSizeFromMode(dEVMODE);
			paperSource = PaperSourceFromMode(dEVMODE);
			printerResolution = PrinterResolutionFromMode(dEVMODE);
			SafeNativeMethods.GlobalUnlock(new HandleRef(null, hdevmode));
		}

		public override string ToString()
		{
			return "[PageSettings: Color=" + Color + ", Landscape=" + Landscape + ", Margins=" + Margins.ToString() + ", PaperSize=" + PaperSize.ToString() + ", PaperSource=" + PaperSource.ToString() + ", PrinterResolution=" + PrinterResolution.ToString() + "]";
		}
	}
	[Serializable]
	public enum PaperKind
	{
		Custom = 0,
		Letter = 1,
		Legal = 5,
		A4 = 9,
		CSheet = 24,
		DSheet = 25,
		ESheet = 26,
		LetterSmall = 2,
		Tabloid = 3,
		Ledger = 4,
		Statement = 6,
		Executive = 7,
		A3 = 8,
		A4Small = 10,
		A5 = 11,
		B4 = 12,
		B5 = 13,
		Folio = 14,
		Quarto = 15,
		Standard10x14 = 16,
		Standard11x17 = 17,
		Note = 18,
		Number9Envelope = 19,
		Number10Envelope = 20,
		Number11Envelope = 21,
		Number12Envelope = 22,
		Number14Envelope = 23,
		DLEnvelope = 27,
		C5Envelope = 28,
		C3Envelope = 29,
		C4Envelope = 30,
		C6Envelope = 31,
		C65Envelope = 32,
		B4Envelope = 33,
		B5Envelope = 34,
		B6Envelope = 35,
		ItalyEnvelope = 36,
		MonarchEnvelope = 37,
		PersonalEnvelope = 38,
		USStandardFanfold = 39,
		GermanStandardFanfold = 40,
		GermanLegalFanfold = 41,
		IsoB4 = 42,
		JapanesePostcard = 43,
		Standard9x11 = 44,
		Standard10x11 = 45,
		Standard15x11 = 46,
		InviteEnvelope = 47,
		LetterExtra = 50,
		LegalExtra = 51,
		TabloidExtra = 52,
		A4Extra = 53,
		LetterTransverse = 54,
		A4Transverse = 55,
		LetterExtraTransverse = 56,
		APlus = 57,
		BPlus = 58,
		LetterPlus = 59,
		A4Plus = 60,
		A5Transverse = 61,
		B5Transverse = 62,
		A3Extra = 63,
		A5Extra = 64,
		B5Extra = 65,
		A2 = 66,
		A3Transverse = 67,
		A3ExtraTransverse = 68,
		JapaneseDoublePostcard = 69,
		A6 = 70,
		JapaneseEnvelopeKakuNumber2 = 71,
		JapaneseEnvelopeKakuNumber3 = 72,
		JapaneseEnvelopeChouNumber3 = 73,
		JapaneseEnvelopeChouNumber4 = 74,
		LetterRotated = 75,
		A3Rotated = 76,
		A4Rotated = 77,
		A5Rotated = 78,
		B4JisRotated = 79,
		B5JisRotated = 80,
		JapanesePostcardRotated = 81,
		JapaneseDoublePostcardRotated = 82,
		A6Rotated = 83,
		JapaneseEnvelopeKakuNumber2Rotated = 84,
		JapaneseEnvelopeKakuNumber3Rotated = 85,
		JapaneseEnvelopeChouNumber3Rotated = 86,
		JapaneseEnvelopeChouNumber4Rotated = 87,
		B6Jis = 88,
		B6JisRotated = 89,
		Standard12x11 = 90,
		JapaneseEnvelopeYouNumber4 = 91,
		JapaneseEnvelopeYouNumber4Rotated = 92,
		Prc16K = 93,
		Prc32K = 94,
		Prc32KBig = 95,
		PrcEnvelopeNumber1 = 96,
		PrcEnvelopeNumber2 = 97,
		PrcEnvelopeNumber3 = 98,
		PrcEnvelopeNumber4 = 99,
		PrcEnvelopeNumber5 = 100,
		PrcEnvelopeNumber6 = 101,
		PrcEnvelopeNumber7 = 102,
		PrcEnvelopeNumber8 = 103,
		PrcEnvelopeNumber9 = 104,
		PrcEnvelopeNumber10 = 105,
		Prc16KRotated = 106,
		Prc32KRotated = 107,
		Prc32KBigRotated = 108,
		PrcEnvelopeNumber1Rotated = 109,
		PrcEnvelopeNumber2Rotated = 110,
		PrcEnvelopeNumber3Rotated = 111,
		PrcEnvelopeNumber4Rotated = 112,
		PrcEnvelopeNumber5Rotated = 113,
		PrcEnvelopeNumber6Rotated = 114,
		PrcEnvelopeNumber7Rotated = 115,
		PrcEnvelopeNumber8Rotated = 116,
		PrcEnvelopeNumber9Rotated = 117,
		PrcEnvelopeNumber10Rotated = 118
	}
	[Serializable]
	public class PaperSize
	{
		private PaperKind kind;

		private string name;

		private int width;

		private int height;

		private bool createdByDefaultConstructor;

		public int Height
		{
			get
			{
				return height;
			}
			set
			{
				if (kind != 0 && !createdByDefaultConstructor)
				{
					throw new ArgumentException(SR.GetString("PSizeNotCustom"));
				}
				height = value;
			}
		}

		public PaperKind Kind
		{
			get
			{
				if (kind <= PaperKind.PrcEnvelopeNumber10Rotated && kind != (PaperKind)48 && kind != (PaperKind)49)
				{
					return kind;
				}
				return PaperKind.Custom;
			}
		}

		public string PaperName
		{
			get
			{
				return name;
			}
			set
			{
				if (kind != 0 && !createdByDefaultConstructor)
				{
					throw new ArgumentException(SR.GetString("PSizeNotCustom"));
				}
				name = value;
			}
		}

		public int RawKind
		{
			get
			{
				return (int)kind;
			}
			set
			{
				kind = (PaperKind)value;
			}
		}

		public int Width
		{
			get
			{
				return width;
			}
			set
			{
				if (kind != 0 && !createdByDefaultConstructor)
				{
					throw new ArgumentException(SR.GetString("PSizeNotCustom"));
				}
				width = value;
			}
		}

		public PaperSize()
		{
			kind = PaperKind.Custom;
			name = string.Empty;
			createdByDefaultConstructor = true;
		}

		internal PaperSize(PaperKind kind, string name, int width, int height)
		{
			this.kind = kind;
			this.name = name;
			this.width = width;
			this.height = height;
		}

		public PaperSize(string name, int width, int height)
		{
			kind = PaperKind.Custom;
			this.name = name;
			this.width = width;
			this.height = height;
		}

		public override string ToString()
		{
			return "[PaperSize " + PaperName + " Kind=" + TypeDescriptor.GetConverter(typeof(PaperKind)).ConvertToString((int)Kind) + " Height=" + Height.ToString(CultureInfo.InvariantCulture) + " Width=" + Width.ToString(CultureInfo.InvariantCulture) + "]";
		}
	}
	[Serializable]
	public class PaperSource
	{
		private string name;

		private PaperSourceKind kind;

		public PaperSourceKind Kind
		{
			get
			{
				if (kind >= (PaperSourceKind)256)
				{
					return PaperSourceKind.Custom;
				}
				return kind;
			}
		}

		public int RawKind
		{
			get
			{
				return (int)kind;
			}
			set
			{
				kind = (PaperSourceKind)value;
			}
		}

		public string SourceName
		{
			get
			{
				return name;
			}
			set
			{
				name = value;
			}
		}

		public PaperSource()
		{
			kind = PaperSourceKind.Custom;
			name = string.Empty;
		}

		internal PaperSource(PaperSourceKind kind, string name)
		{
			this.kind = kind;
			this.name = name;
		}

		public override string ToString()
		{
			return "[PaperSource " + SourceName + " Kind=" + TypeDescriptor.GetConverter(typeof(PaperSourceKind)).ConvertToString(Kind) + "]";
		}
	}
	[Serializable]
	public enum PaperSourceKind
	{
		Upper = 1,
		Lower = 2,
		Middle = 3,
		Manual = 4,
		Envelope = 5,
		ManualFeed = 6,
		AutomaticFeed = 7,
		TractorFeed = 8,
		SmallFormat = 9,
		LargeFormat = 10,
		LargeCapacity = 11,
		Cassette = 14,
		FormSource = 15,
		Custom = 257
	}
	public sealed class PreviewPageInfo
	{
		private Image image;

		private Size physicalSize = Size.Empty;

		public Image Image => image;

		public Size PhysicalSize => physicalSize;

		public PreviewPageInfo(Image image, Size physicalSize)
		{
			this.image = image;
			this.physicalSize = physicalSize;
		}
	}
	public class PreviewPrintController : PrintController
	{
		private IList list = new ArrayList();

		private Graphics graphics;

		private DeviceContext dc;

		private bool antiAlias;

		public override bool IsPreview => true;

		public virtual bool UseAntiAlias
		{
			get
			{
				return antiAlias;
			}
			set
			{
				antiAlias = value;
			}
		}

		private void CheckSecurity()
		{
			IntSecurity.SafePrinting.Demand();
		}

		public override void OnStartPrint(PrintDocument document, PrintEventArgs e)
		{
			CheckSecurity();
			base.OnStartPrint(document, e);
			try
			{
				if (!document.PrinterSettings.IsValid)
				{
					throw new InvalidPrinterException(document.PrinterSettings);
				}
				IntSecurity.AllPrintingAndUnmanagedCode.Assert();
				dc = document.PrinterSettings.CreateInformationContext(modeHandle);
			}
			finally
			{
				CodeAccessPermission.RevertAssert();
			}
		}

		public override Graphics OnStartPage(PrintDocument document, PrintPageEventArgs e)
		{
			CheckSecurity();
			base.OnStartPage(document, e);
			try
			{
				IntSecurity.AllPrintingAndUnmanagedCode.Assert();
				e.PageSettings.CopyToHdevmode(modeHandle);
				Size size = e.PageBounds.Size;
				Size size2 = PrinterUnitConvert.Convert(size, PrinterUnit.Display, PrinterUnit.HundredthsOfAMillimeter);
				Metafile image = new Metafile(dc.Hdc, new Rectangle(0, 0, size2.Width, size2.Height), MetafileFrameUnit.GdiCompatible, EmfType.EmfPlusOnly);
				PreviewPageInfo value = new PreviewPageInfo(image, size);
				list.Add(value);
				PrintPreviewGraphics printingHelper = new PrintPreviewGraphics(document, e);
				graphics = Graphics.FromImage(image);
				if (graphics != null && document.OriginAtMargins)
				{
					int deviceCaps = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(dc, dc.Hdc), 88);
					int deviceCaps2 = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(dc, dc.Hdc), 90);
					int deviceCaps3 = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(dc, dc.Hdc), 112);
					int deviceCaps4 = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(dc, dc.Hdc), 113);
					float num = deviceCaps3 * 100 / deviceCaps;
					float num2 = deviceCaps4 * 100 / deviceCaps2;
					graphics.TranslateTransform(0f - num, 0f - num2);
					graphics.TranslateTransform(document.DefaultPageSettings.Margins.Left, document.DefaultPageSettings.Margins.Top);
				}
				graphics.PrintingHelper = printingHelper;
				if (antiAlias)
				{
					graphics.TextRenderingHint = TextRenderingHint.AntiAlias;
					graphics.SmoothingMode = SmoothingMode.AntiAlias;
				}
			}
			finally
			{
				CodeAccessPermission.RevertAssert();
			}
			return graphics;
		}

		public override void OnEndPage(PrintDocument document, PrintPageEventArgs e)
		{
			CheckSecurity();
			graphics.Dispose();
			graphics = null;
			base.OnEndPage(document, e);
		}

		public override void OnEndPrint(PrintDocument document, PrintEventArgs e)
		{
			CheckSecurity();
			dc.Dispose();
			dc = null;
			base.OnEndPrint(document, e);
		}

		public PreviewPageInfo[] GetPreviewPageInfo()
		{
			CheckSecurity();
			PreviewPageInfo[] array = new PreviewPageInfo[list.Count];
			list.CopyTo(array, 0);
			return array;
		}
	}
	public enum PrintAction
	{
		PrintToFile,
		PrintToPreview,
		PrintToPrinter
	}
	[DefaultEvent("PrintPage")]
	[ToolboxItemFilter("System.Drawing.Printing")]
	[DefaultProperty("DocumentName")]
	[SRDescription("PrintDocumentDesc")]
	public class PrintDocument : Component
	{
		private string documentName = "document";

		private PrintEventHandler beginPrintHandler;

		private PrintEventHandler endPrintHandler;

		private PrintPageEventHandler printPageHandler;

		private QueryPageSettingsEventHandler queryHandler;

		private PrinterSettings printerSettings = new PrinterSettings();

		private PageSettings defaultPageSettings;

		private PrintController printController;

		private bool originAtMargins;

		private bool userSetPageSettings;

		[Browsable(false)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[SRDescription("PDOCdocumentPageSettingsDescr")]
		public PageSettings DefaultPageSettings
		{
			get
			{
				return defaultPageSettings;
			}
			set
			{
				if (value == null)
				{
					value = new PageSettings();
				}
				defaultPageSettings = value;
				userSetPageSettings = true;
			}
		}

		[SRDescription("PDOCdocumentNameDescr")]
		[DefaultValue("document")]
		public string DocumentName
		{
			get
			{
				return documentName;
			}
			set
			{
				if (value == null)
				{
					value = "";
				}
				documentName = value;
			}
		}

		[SRDescription("PDOCoriginAtMarginsDescr")]
		[DefaultValue(false)]
		public bool OriginAtMargins
		{
			get
			{
				return originAtMargins;
			}
			set
			{
				originAtMargins = value;
			}
		}

		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[SRDescription("PDOCprintControllerDescr")]
		[Browsable(false)]
		public PrintController PrintController
		{
			get
			{
				IntSecurity.SafePrinting.Demand();
				if (printController == null)
				{
					printController = new StandardPrintController();
					new ReflectionPermission(PermissionState.Unrestricted).Assert();
					try
					{
						Type type = Type.GetType("System.Windows.Forms.PrintControllerWithStatusDialog, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089");
						printController = (PrintController)Activator.CreateInstance(type, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance, null, new object[1] { printController }, null);
					}
					catch (TypeLoadException)
					{
					}
					catch (TargetInvocationException)
					{
					}
					catch (MissingMethodException)
					{
					}
					catch (MethodAccessException)
					{
					}
					catch (MemberAccessException)
					{
					}
					catch (FileNotFoundException)
					{
					}
					finally
					{
						CodeAccessPermission.RevertAssert();
					}
				}
				return printController;
			}
			set
			{
				IntSecurity.SafePrinting.Demand();
				printController = value;
			}
		}

		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[SRDescription("PDOCprinterSettingsDescr")]
		[Browsable(false)]
		public PrinterSettings PrinterSettings
		{
			get
			{
				return printerSettings;
			}
			set
			{
				if (value == null)
				{
					value = new PrinterSettings();
				}
				printerSettings = value;
				if (!userSetPageSettings)
				{
					defaultPageSettings = printerSettings.DefaultPageSettings;
				}
			}
		}

		[SRDescription("PDOCbeginPrintDescr")]
		public event PrintEventHandler BeginPrint
		{
			add
			{
				beginPrintHandler = (PrintEventHandler)Delegate.Combine(beginPrintHandler, value);
			}
			remove
			{
				beginPrintHandler = (PrintEventHandler)Delegate.Remove(beginPrintHandler, value);
			}
		}

		[SRDescription("PDOCendPrintDescr")]
		public event PrintEventHandler EndPrint
		{
			add
			{
				endPrintHandler = (PrintEventHandler)Delegate.Combine(endPrintHandler, value);
			}
			remove
			{
				endPrintHandler = (PrintEventHandler)Delegate.Remove(endPrintHandler, value);
			}
		}

		[SRDescription("PDOCprintPageDescr")]
		public event PrintPageEventHandler PrintPage
		{
			add
			{
				printPageHandler = (PrintPageEventHandler)Delegate.Combine(printPageHandler, value);
			}
			remove
			{
				printPageHandler = (PrintPageEventHandler)Delegate.Remove(printPageHandler, value);
			}
		}

		[SRDescription("PDOCqueryPageSettingsDescr")]
		public event QueryPageSettingsEventHandler QueryPageSettings
		{
			add
			{
				queryHandler = (QueryPageSettingsEventHandler)Delegate.Combine(queryHandler, value);
			}
			remove
			{
				queryHandler = (QueryPageSettingsEventHandler)Delegate.Remove(queryHandler, value);
			}
		}

		public PrintDocument()
		{
			defaultPageSettings = new PageSettings(printerSettings);
		}

		internal void _OnBeginPrint(PrintEventArgs e)
		{
			OnBeginPrint(e);
		}

		protected virtual void OnBeginPrint(PrintEventArgs e)
		{
			if (beginPrintHandler != null)
			{
				beginPrintHandler(this, e);
			}
		}

		internal void _OnEndPrint(PrintEventArgs e)
		{
			OnEndPrint(e);
		}

		protected virtual void OnEndPrint(PrintEventArgs e)
		{
			if (endPrintHandler != null)
			{
				endPrintHandler(this, e);
			}
		}

		internal void _OnPrintPage(PrintPageEventArgs e)
		{
			OnPrintPage(e);
		}

		protected virtual void OnPrintPage(PrintPageEventArgs e)
		{
			if (printPageHandler != null)
			{
				printPageHandler(this, e);
			}
		}

		internal void _OnQueryPageSettings(QueryPageSettingsEventArgs e)
		{
			OnQueryPageSettings(e);
		}

		protected virtual void OnQueryPageSettings(QueryPageSettingsEventArgs e)
		{
			if (queryHandler != null)
			{
				queryHandler(this, e);
			}
		}

		public void Print()
		{
			if (!PrinterSettings.IsDefaultPrinter && !PrinterSettings.PrintDialogDisplayed)
			{
				IntSecurity.AllPrinting.Demand();
			}
			PrintController printController = PrintController;
			printController.Print(this);
		}

		public override string ToString()
		{
			return "[PrintDocument " + DocumentName + "]";
		}
	}
	[Serializable]
	public class PrinterResolution
	{
		private int x;

		private int y;

		private PrinterResolutionKind kind;

		public PrinterResolutionKind Kind
		{
			get
			{
				return kind;
			}
			set
			{
				if (!ClientUtils.IsEnumValid(value, (int)value, -4, 0))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(PrinterResolutionKind));
				}
				kind = value;
			}
		}

		public int X
		{
			get
			{
				return x;
			}
			set
			{
				x = value;
			}
		}

		public int Y
		{
			get
			{
				return y;
			}
			set
			{
				y = value;
			}
		}

		public PrinterResolution()
		{
			kind = PrinterResolutionKind.Custom;
		}

		internal PrinterResolution(PrinterResolutionKind kind, int x, int y)
		{
			this.kind = kind;
			this.x = x;
			this.y = y;
		}

		public override string ToString()
		{
			if (kind != 0)
			{
				return "[PrinterResolution " + TypeDescriptor.GetConverter(typeof(PrinterResolutionKind)).ConvertToString((int)Kind) + "]";
			}
			return "[PrinterResolution X=" + X.ToString(CultureInfo.InvariantCulture) + " Y=" + Y.ToString(CultureInfo.InvariantCulture) + "]";
		}
	}
	[Serializable]
	public enum PrinterResolutionKind
	{
		High = -4,
		Medium,
		Low,
		Draft,
		Custom
	}
	[Serializable]
	public class PrinterSettings : ICloneable
	{
		public class PaperSizeCollection : ICollection, IEnumerable
		{
			private PaperSize[] array;

			public int Count => array.Length;

			public virtual PaperSize this[int index] => array[index];

			int ICollection.Count => Count;

			bool ICollection.IsSynchronized => false;

			object ICollection.SyncRoot => this;

			public PaperSizeCollection(PaperSize[] array)
			{
				this.array = array;
			}

			public IEnumerator GetEnumerator()
			{
				return new ArrayEnumerator(array, 0, Count);
			}

			void ICollection.CopyTo(Array array, int index)
			{
				Array.Copy(this.array, index, array, 0, this.array.Length);
			}

			public void CopyTo(PaperSize[] paperSizes, int index)
			{
				Array.Copy(array, index, paperSizes, 0, array.Length);
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}

			[EditorBrowsable(EditorBrowsableState.Never)]
			public int Add(PaperSize paperSize)
			{
				PaperSize[] array = new PaperSize[Count + 1];
				((ICollection)this).CopyTo((Array)array, 0);
				array[Count] = paperSize;
				this.array = array;
				return Count;
			}
		}

		public class PaperSourceCollection : ICollection, IEnumerable
		{
			private PaperSource[] array;

			public int Count => array.Length;

			public virtual PaperSource this[int index] => array[index];

			int ICollection.Count => Count;

			bool ICollection.IsSynchronized => false;

			object ICollection.SyncRoot => this;

			public PaperSourceCollection(PaperSource[] array)
			{
				this.array = array;
			}

			public IEnumerator GetEnumerator()
			{
				return new ArrayEnumerator(array, 0, Count);
			}

			void ICollection.CopyTo(Array array, int index)
			{
				Array.Copy(this.array, index, array, 0, this.array.Length);
			}

			public void CopyTo(PaperSource[] paperSources, int index)
			{
				Array.Copy(array, index, paperSources, 0, array.Length);
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}

			[EditorBrowsable(EditorBrowsableState.Never)]
			public int Add(PaperSource paperSource)
			{
				PaperSource[] array = new PaperSource[Count + 1];
				((ICollection)this).CopyTo((Array)array, 0);
				array[Count] = paperSource;
				this.array = array;
				return Count;
			}
		}

		public class PrinterResolutionCollection : ICollection, IEnumerable
		{
			private PrinterResolution[] array;

			public int Count => array.Length;

			public virtual PrinterResolution this[int index] => array[index];

			int ICollection.Count => Count;

			bool ICollection.IsSynchronized => false;

			object ICollection.SyncRoot => this;

			public PrinterResolutionCollection(PrinterResolution[] array)
			{
				this.array = array;
			}

			public IEnumerator GetEnumerator()
			{
				return new ArrayEnumerator(array, 0, Count);
			}

			void ICollection.CopyTo(Array array, int index)
			{
				Array.Copy(this.array, index, array, 0, this.array.Length);
			}

			public void CopyTo(PrinterResolution[] printerResolutions, int index)
			{
				Array.Copy(array, index, printerResolutions, 0, array.Length);
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}

			[EditorBrowsable(EditorBrowsableState.Never)]
			public int Add(PrinterResolution printerResolution)
			{
				PrinterResolution[] array = new PrinterResolution[Count + 1];
				((ICollection)this).CopyTo((Array)array, 0);
				array[Count] = printerResolution;
				this.array = array;
				return Count;
			}
		}

		public class StringCollection : ICollection, IEnumerable
		{
			private string[] array;

			public int Count => array.Length;

			public virtual string this[int index] => array[index];

			int ICollection.Count => Count;

			bool ICollection.IsSynchronized => false;

			object ICollection.SyncRoot => this;

			public StringCollection(string[] array)
			{
				this.array = array;
			}

			public IEnumerator GetEnumerator()
			{
				return new ArrayEnumerator(array, 0, Count);
			}

			void ICollection.CopyTo(Array array, int index)
			{
				Array.Copy(this.array, index, array, 0, this.array.Length);
			}

			public void CopyTo(string[] strings, int index)
			{
				Array.Copy(array, index, strings, 0, array.Length);
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}

			[EditorBrowsable(EditorBrowsableState.Never)]
			public int Add(string value)
			{
				string[] array = new string[Count + 1];
				((ICollection)this).CopyTo((Array)array, 0);
				array[Count] = value;
				this.array = array;
				return Count;
			}
		}

		private class ArrayEnumerator : IEnumerator
		{
			private object[] array;

			private object item;

			private int index;

			private int startIndex;

			private int endIndex;

			public object Current => item;

			public ArrayEnumerator(object[] array, int startIndex, int count)
			{
				this.array = array;
				this.startIndex = startIndex;
				endIndex = index + count;
				index = this.startIndex;
			}

			public bool MoveNext()
			{
				if (index >= endIndex)
				{
					return false;
				}
				item = array[index++];
				return true;
			}

			public void Reset()
			{
				index = startIndex;
				item = null;
			}
		}

		private const int PADDING_IA64 = 4;

		private string printerName;

		private string driverName = "";

		private string outputPort = "";

		private bool printToFile;

		private bool printDialogDisplayed;

		private short extrabytes;

		private byte[] extrainfo;

		private short copies = -1;

		private Duplex duplex = Duplex.Default;

		private TriState collate = TriState.Default;

		private PageSettings defaultPageSettings;

		private int fromPage;

		private int toPage;

		private int maxPage = 9999;

		private int minPage;

		private PrintRange printRange;

		private short devmodebytes;

		private byte[] cachedDevmode;

		public bool CanDuplex => DeviceCapabilities(7, IntPtr.Zero, 0) == 1;

		public short Copies
		{
			get
			{
				if (copies != -1)
				{
					return copies;
				}
				return GetModeField(ModeField.Copies, 1);
			}
			set
			{
				if (value < 0)
				{
					throw new ArgumentException(SR.GetString("InvalidLowBoundArgumentEx", "value", value.ToString(CultureInfo.CurrentCulture), 0.ToString(CultureInfo.CurrentCulture)));
				}
				IntSecurity.SafePrinting.Demand();
				copies = value;
			}
		}

		public bool Collate
		{
			get
			{
				if (!collate.IsDefault)
				{
					return (bool)collate;
				}
				return GetModeField(ModeField.Collate, 0) == 1;
			}
			set
			{
				collate = value;
			}
		}

		public PageSettings DefaultPageSettings => defaultPageSettings;

		internal string DriverName => driverName;

		public Duplex Duplex
		{
			get
			{
				if (duplex != Duplex.Default)
				{
					return duplex;
				}
				return (Duplex)GetModeField(ModeField.Duplex, 1);
			}
			set
			{
				if (!ClientUtils.IsEnumValid(value, (int)value, -1, 3))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(Duplex));
				}
				duplex = value;
			}
		}

		public int FromPage
		{
			get
			{
				return fromPage;
			}
			set
			{
				if (value < 0)
				{
					throw new ArgumentException(SR.GetString("InvalidLowBoundArgumentEx", "value", value.ToString(CultureInfo.CurrentCulture), 0.ToString(CultureInfo.CurrentCulture)));
				}
				fromPage = value;
			}
		}

		public static StringCollection InstalledPrinters
		{
			get
			{
				IntSecurity.AllPrinting.Demand();
				int level;
				int num;
				if (Environment.OSVersion.Platform == PlatformID.Win32NT)
				{
					level = 4;
					num = ((IntPtr.Size != 8) ? (IntPtr.Size * 2 + Marshal.SizeOf(typeof(int))) : (IntPtr.Size * 2 + Marshal.SizeOf(typeof(int)) + 4));
				}
				else
				{
					level = 5;
					num = IntPtr.Size * 2 + Marshal.SizeOf(typeof(int)) * 3;
				}
				IntSecurity.UnmanagedCode.Assert();
				string[] array;
				try
				{
					SafeNativeMethods.EnumPrinters(6, null, level, IntPtr.Zero, 0, out var pcbNeeded, out var pcReturned);
					IntPtr intPtr = Marshal.AllocCoTaskMem(pcbNeeded);
					int num2 = SafeNativeMethods.EnumPrinters(6, null, level, intPtr, pcbNeeded, out pcbNeeded, out pcReturned);
					array = new string[pcReturned];
					if (num2 == 0)
					{
						Marshal.FreeCoTaskMem(intPtr);
						throw new Win32Exception();
					}
					for (int i = 0; i < pcReturned; i++)
					{
						IntPtr ptr = Marshal.ReadIntPtr((IntPtr)checked((long)intPtr + i * num));
						array[i] = Marshal.PtrToStringAuto(ptr);
					}
					Marshal.FreeCoTaskMem(intPtr);
				}
				finally
				{
					CodeAccessPermission.RevertAssert();
				}
				return new StringCollection(array);
			}
		}

		public bool IsDefaultPrinter
		{
			get
			{
				if (printerName != null)
				{
					return printerName == GetDefaultPrinterName();
				}
				return true;
			}
		}

		public bool IsPlotter => GetDeviceCaps(2, 2) == 0;

		public bool IsValid => DeviceCapabilities(18, IntPtr.Zero, -1) != -1;

		public int LandscapeAngle => DeviceCapabilities(17, IntPtr.Zero, 0);

		public int MaximumCopies => DeviceCapabilities(18, IntPtr.Zero, 1);

		public int MaximumPage
		{
			get
			{
				return maxPage;
			}
			set
			{
				if (value < 0)
				{
					throw new ArgumentException(SR.GetString("InvalidLowBoundArgumentEx", "value", value.ToString(CultureInfo.CurrentCulture), 0.ToString(CultureInfo.CurrentCulture)));
				}
				maxPage = value;
			}
		}

		public int MinimumPage
		{
			get
			{
				return minPage;
			}
			set
			{
				if (value < 0)
				{
					throw new ArgumentException(SR.GetString("InvalidLowBoundArgumentEx", "value", value.ToString(CultureInfo.CurrentCulture), 0.ToString(CultureInfo.CurrentCulture)));
				}
				minPage = value;
			}
		}

		internal string OutputPort
		{
			get
			{
				return outputPort;
			}
			set
			{
				outputPort = value;
			}
		}

		public string PrintFileName
		{
			get
			{
				string text = OutputPort;
				if (!string.IsNullOrEmpty(text))
				{
					IntSecurity.DemandReadFileIO(text);
				}
				return text;
			}
			set
			{
				if (string.IsNullOrEmpty(value))
				{
					throw new ArgumentNullException(value);
				}
				IntSecurity.DemandWriteFileIO(value);
				OutputPort = value;
			}
		}

		public PaperSizeCollection PaperSizes => new PaperSizeCollection(Get_PaperSizes());

		public PaperSourceCollection PaperSources => new PaperSourceCollection(Get_PaperSources());

		internal bool PrintDialogDisplayed
		{
			get
			{
				return printDialogDisplayed;
			}
			set
			{
				IntSecurity.AllPrinting.Demand();
				printDialogDisplayed = value;
			}
		}

		public PrintRange PrintRange
		{
			get
			{
				return printRange;
			}
			set
			{
				if (!Enum.IsDefined(typeof(PrintRange), value))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(PrintRange));
				}
				printRange = value;
			}
		}

		public bool PrintToFile
		{
			get
			{
				return printToFile;
			}
			set
			{
				printToFile = value;
			}
		}

		public string PrinterName
		{
			get
			{
				IntSecurity.AllPrinting.Demand();
				return PrinterNameInternal;
			}
			set
			{
				IntSecurity.AllPrinting.Demand();
				PrinterNameInternal = value;
			}
		}

		private string PrinterNameInternal
		{
			get
			{
				if (printerName == null)
				{
					return GetDefaultPrinterName();
				}
				return printerName;
			}
			set
			{
				cachedDevmode = null;
				extrainfo = null;
				printerName = value;
			}
		}

		public PrinterResolutionCollection PrinterResolutions => new PrinterResolutionCollection(Get_PrinterResolutions());

		public bool SupportsColor => GetDeviceCaps(12, 1) > 1;

		public int ToPage
		{
			get
			{
				return toPage;
			}
			set
			{
				if (value < 0)
				{
					throw new ArgumentException(SR.GetString("InvalidLowBoundArgumentEx", "value", value.ToString(CultureInfo.CurrentCulture), 0.ToString(CultureInfo.CurrentCulture)));
				}
				toPage = value;
			}
		}

		public PrinterSettings()
		{
			defaultPageSettings = new PageSettings(this);
		}

		public bool IsDirectPrintingSupported(ImageFormat imageFormat)
		{
			bool result = false;
			if (imageFormat.Equals(ImageFormat.Jpeg) || imageFormat.Equals(ImageFormat.Png))
			{
				int inData = (imageFormat.Equals(ImageFormat.Jpeg) ? 4119 : 4120);
				int outData = 0;
				DeviceContext deviceContext = CreateInformationContext(DefaultPageSettings);
				HandleRef hDC = new HandleRef(deviceContext, deviceContext.Hdc);
				try
				{
					return SafeNativeMethods.ExtEscape(hDC, 8, Marshal.SizeOf(typeof(int)), ref inData, 0, out outData) > 0;
				}
				finally
				{
					deviceContext.Dispose();
				}
			}
			return result;
		}

		public bool IsDirectPrintingSupported(Image image)
		{
			bool result = false;
			if (image.RawFormat.Equals(ImageFormat.Jpeg) || image.RawFormat.Equals(ImageFormat.Png))
			{
				MemoryStream memoryStream = new MemoryStream();
				try
				{
					image.Save(memoryStream, image.RawFormat);
					memoryStream.Position = 0L;
					using BufferedStream bufferedStream = new BufferedStream(memoryStream);
					int num = (int)bufferedStream.Length;
					byte[] array = new byte[num];
					bufferedStream.Read(array, 0, num);
					int inData = (image.RawFormat.Equals(ImageFormat.Jpeg) ? 4119 : 4120);
					int outData = 0;
					DeviceContext deviceContext = CreateInformationContext(DefaultPageSettings);
					HandleRef hDC = new HandleRef(deviceContext, deviceContext.Hdc);
					try
					{
						if (SafeNativeMethods.ExtEscape(hDC, 8, Marshal.SizeOf(typeof(int)), ref inData, 0, out outData) > 0)
						{
							return SafeNativeMethods.ExtEscape(hDC, inData, num, array, Marshal.SizeOf(typeof(int)), out outData) > 0 && outData == 1;
						}
						return result;
					}
					finally
					{
						deviceContext.Dispose();
					}
				}
				finally
				{
					memoryStream.Close();
				}
			}
			return result;
		}

		public object Clone()
		{
			PrinterSettings printerSettings = (PrinterSettings)MemberwiseClone();
			printerSettings.printDialogDisplayed = false;
			return printerSettings;
		}

		internal DeviceContext CreateDeviceContext(PageSettings pageSettings)
		{
			IntPtr hdevmodeInternal = GetHdevmodeInternal();
			DeviceContext deviceContext = null;
			try
			{
				IntSecurity.AllPrintingAndUnmanagedCode.Assert();
				try
				{
					pageSettings.CopyToHdevmode(hdevmodeInternal);
				}
				finally
				{
					CodeAccessPermission.RevertAssert();
				}
				return CreateDeviceContext(hdevmodeInternal);
			}
			finally
			{
				SafeNativeMethods.GlobalFree(new HandleRef(null, hdevmodeInternal));
			}
		}

		internal DeviceContext CreateDeviceContext(IntPtr hdevmode)
		{
			IntPtr handle = SafeNativeMethods.GlobalLock(new HandleRef(null, hdevmode));
			DeviceContext result = DeviceContext.CreateDC(DriverName, PrinterNameInternal, null, new HandleRef(null, handle));
			SafeNativeMethods.GlobalUnlock(new HandleRef(null, hdevmode));
			return result;
		}

		internal DeviceContext CreateInformationContext(PageSettings pageSettings)
		{
			IntPtr hdevmodeInternal = GetHdevmodeInternal();
			try
			{
				IntSecurity.AllPrintingAndUnmanagedCode.Assert();
				try
				{
					pageSettings.CopyToHdevmode(hdevmodeInternal);
				}
				finally
				{
					CodeAccessPermission.RevertAssert();
				}
				return CreateInformationContext(hdevmodeInternal);
			}
			finally
			{
				SafeNativeMethods.GlobalFree(new HandleRef(null, hdevmodeInternal));
			}
		}

		internal DeviceContext CreateInformationContext(IntPtr hdevmode)
		{
			IntPtr handle = SafeNativeMethods.GlobalLock(new HandleRef(null, hdevmode));
			DeviceContext result = DeviceContext.CreateIC(DriverName, PrinterNameInternal, null, new HandleRef(null, handle));
			SafeNativeMethods.GlobalUnlock(new HandleRef(null, hdevmode));
			return result;
		}

		public Graphics CreateMeasurementGraphics()
		{
			return CreateMeasurementGraphics(DefaultPageSettings);
		}

		public Graphics CreateMeasurementGraphics(bool honorOriginAtMargins)
		{
			Graphics graphics = CreateMeasurementGraphics();
			if (graphics != null && honorOriginAtMargins)
			{
				IntSecurity.AllPrintingAndUnmanagedCode.Assert();
				try
				{
					graphics.TranslateTransform(0f - defaultPageSettings.HardMarginX, 0f - defaultPageSettings.HardMarginY);
				}
				finally
				{
					CodeAccessPermission.RevertAssert();
				}
				graphics.TranslateTransform(defaultPageSettings.Margins.Left, defaultPageSettings.Margins.Top);
			}
			return graphics;
		}

		public Graphics CreateMeasurementGraphics(PageSettings pageSettings)
		{
			DeviceContext deviceContext = CreateDeviceContext(pageSettings);
			Graphics graphics = Graphics.FromHdcInternal(deviceContext.Hdc);
			graphics.PrintingHelper = deviceContext;
			return graphics;
		}

		public Graphics CreateMeasurementGraphics(PageSettings pageSettings, bool honorOriginAtMargins)
		{
			Graphics graphics = CreateMeasurementGraphics();
			if (graphics != null && honorOriginAtMargins)
			{
				IntSecurity.AllPrintingAndUnmanagedCode.Assert();
				try
				{
					graphics.TranslateTransform(0f - pageSettings.HardMarginX, 0f - pageSettings.HardMarginY);
				}
				finally
				{
					CodeAccessPermission.RevertAssert();
				}
				graphics.TranslateTransform(pageSettings.Margins.Left, pageSettings.Margins.Top);
			}
			return graphics;
		}

		private static SafeNativeMethods.PRINTDLGX86 CreatePRINTDLGX86()
		{
			SafeNativeMethods.PRINTDLGX86 pRINTDLGX = new SafeNativeMethods.PRINTDLGX86();
			pRINTDLGX.lStructSize = Marshal.SizeOf(typeof(SafeNativeMethods.PRINTDLGX86));
			pRINTDLGX.hwndOwner = IntPtr.Zero;
			pRINTDLGX.hDevMode = IntPtr.Zero;
			pRINTDLGX.hDevNames = IntPtr.Zero;
			pRINTDLGX.Flags = 0;
			pRINTDLGX.hwndOwner = IntPtr.Zero;
			pRINTDLGX.hDC = IntPtr.Zero;
			pRINTDLGX.nFromPage = 1;
			pRINTDLGX.nToPage = 1;
			pRINTDLGX.nMinPage = 0;
			pRINTDLGX.nMaxPage = 9999;
			pRINTDLGX.nCopies = 1;
			pRINTDLGX.hInstance = IntPtr.Zero;
			pRINTDLGX.lCustData = IntPtr.Zero;
			pRINTDLGX.lpfnPrintHook = IntPtr.Zero;
			pRINTDLGX.lpfnSetupHook = IntPtr.Zero;
			pRINTDLGX.lpPrintTemplateName = null;
			pRINTDLGX.lpSetupTemplateName = null;
			pRINTDLGX.hPrintTemplate = IntPtr.Zero;
			pRINTDLGX.hSetupTemplate = IntPtr.Zero;
			return pRINTDLGX;
		}

		private static SafeNativeMethods.PRINTDLG CreatePRINTDLG()
		{
			SafeNativeMethods.PRINTDLG pRINTDLG = new SafeNativeMethods.PRINTDLG();
			pRINTDLG.lStructSize = Marshal.SizeOf(typeof(SafeNativeMethods.PRINTDLG));
			pRINTDLG.hwndOwner = IntPtr.Zero;
			pRINTDLG.hDevMode = IntPtr.Zero;
			pRINTDLG.hDevNames = IntPtr.Zero;
			pRINTDLG.Flags = 0;
			pRINTDLG.hwndOwner = IntPtr.Zero;
			pRINTDLG.hDC = IntPtr.Zero;
			pRINTDLG.nFromPage = 1;
			pRINTDLG.nToPage = 1;
			pRINTDLG.nMinPage = 0;
			pRINTDLG.nMaxPage = 9999;
			pRINTDLG.nCopies = 1;
			pRINTDLG.hInstance = IntPtr.Zero;
			pRINTDLG.lCustData = IntPtr.Zero;
			pRINTDLG.lpfnPrintHook = IntPtr.Zero;
			pRINTDLG.lpfnSetupHook = IntPtr.Zero;
			pRINTDLG.lpPrintTemplateName = null;
			pRINTDLG.lpSetupTemplateName = null;
			pRINTDLG.hPrintTemplate = IntPtr.Zero;
			pRINTDLG.hSetupTemplate = IntPtr.Zero;
			return pRINTDLG;
		}

		private int DeviceCapabilities(short capability, IntPtr pointerToBuffer, int defaultValue)
		{
			IntSecurity.AllPrinting.Assert();
			string text = PrinterName;
			CodeAccessPermission.RevertAssert();
			IntSecurity.UnmanagedCode.Assert();
			return FastDeviceCapabilities(capability, pointerToBuffer, defaultValue, text);
		}

		private static int FastDeviceCapabilities(short capability, IntPtr pointerToBuffer, int defaultValue, string printerName)
		{
			int num = SafeNativeMethods.DeviceCapabilities(printerName, GetOutputPort(), capability, pointerToBuffer, IntPtr.Zero);
			if (num == -1)
			{
				return defaultValue;
			}
			return num;
		}

		private static string GetDefaultPrinterName()
		{
			IntSecurity.UnmanagedCode.Assert();
			if (IntPtr.Size == 8)
			{
				SafeNativeMethods.PRINTDLG pRINTDLG = CreatePRINTDLG();
				pRINTDLG.Flags = 1024;
				if (!SafeNativeMethods.PrintDlg(pRINTDLG))
				{
					return SR.GetString("NoDefaultPrinter");
				}
				IntPtr hDevNames = pRINTDLG.hDevNames;
				IntPtr intPtr = SafeNativeMethods.GlobalLock(new HandleRef(pRINTDLG, hDevNames));
				if (intPtr == IntPtr.Zero)
				{
					throw new Win32Exception();
				}
				string result = ReadOneDEVNAME(intPtr, 1);
				SafeNativeMethods.GlobalUnlock(new HandleRef(pRINTDLG, hDevNames));
				intPtr = IntPtr.Zero;
				SafeNativeMethods.GlobalFree(new HandleRef(pRINTDLG, pRINTDLG.hDevNames));
				SafeNativeMethods.GlobalFree(new HandleRef(pRINTDLG, pRINTDLG.hDevMode));
				return result;
			}
			SafeNativeMethods.PRINTDLGX86 pRINTDLGX = CreatePRINTDLGX86();
			pRINTDLGX.Flags = 1024;
			if (!SafeNativeMethods.PrintDlg(pRINTDLGX))
			{
				return SR.GetString("NoDefaultPrinter");
			}
			IntPtr hDevNames2 = pRINTDLGX.hDevNames;
			IntPtr intPtr2 = SafeNativeMethods.GlobalLock(new HandleRef(pRINTDLGX, hDevNames2));
			if (intPtr2 == IntPtr.Zero)
			{
				throw new Win32Exception();
			}
			string result2 = ReadOneDEVNAME(intPtr2, 1);
			SafeNativeMethods.GlobalUnlock(new HandleRef(pRINTDLGX, hDevNames2));
			intPtr2 = IntPtr.Zero;
			SafeNativeMethods.GlobalFree(new HandleRef(pRINTDLGX, pRINTDLGX.hDevNames));
			SafeNativeMethods.GlobalFree(new HandleRef(pRINTDLGX, pRINTDLGX.hDevMode));
			return result2;
		}

		private static string GetOutputPort()
		{
			IntSecurity.UnmanagedCode.Assert();
			if (IntPtr.Size == 8)
			{
				SafeNativeMethods.PRINTDLG pRINTDLG = CreatePRINTDLG();
				pRINTDLG.Flags = 1024;
				if (!SafeNativeMethods.PrintDlg(pRINTDLG))
				{
					return SR.GetString("NoDefaultPrinter");
				}
				IntPtr hDevNames = pRINTDLG.hDevNames;
				IntPtr intPtr = SafeNativeMethods.GlobalLock(new HandleRef(pRINTDLG, hDevNames));
				if (intPtr == IntPtr.Zero)
				{
					throw new Win32Exception();
				}
				string result = ReadOneDEVNAME(intPtr, 2);
				SafeNativeMethods.GlobalUnlock(new HandleRef(pRINTDLG, hDevNames));
				intPtr = IntPtr.Zero;
				SafeNativeMethods.GlobalFree(new HandleRef(pRINTDLG, pRINTDLG.hDevNames));
				SafeNativeMethods.GlobalFree(new HandleRef(pRINTDLG, pRINTDLG.hDevMode));
				return result;
			}
			SafeNativeMethods.PRINTDLGX86 pRINTDLGX = CreatePRINTDLGX86();
			pRINTDLGX.Flags = 1024;
			if (!SafeNativeMethods.PrintDlg(pRINTDLGX))
			{
				return SR.GetString("NoDefaultPrinter");
			}
			IntPtr hDevNames2 = pRINTDLGX.hDevNames;
			IntPtr intPtr2 = SafeNativeMethods.GlobalLock(new HandleRef(pRINTDLGX, hDevNames2));
			if (intPtr2 == IntPtr.Zero)
			{
				throw new Win32Exception();
			}
			string result2 = ReadOneDEVNAME(intPtr2, 2);
			SafeNativeMethods.GlobalUnlock(new HandleRef(pRINTDLGX, hDevNames2));
			intPtr2 = IntPtr.Zero;
			SafeNativeMethods.GlobalFree(new HandleRef(pRINTDLGX, pRINTDLGX.hDevNames));
			SafeNativeMethods.GlobalFree(new HandleRef(pRINTDLGX, pRINTDLGX.hDevMode));
			return result2;
		}

		private int GetDeviceCaps(int capability, int defaultValue)
		{
			DeviceContext deviceContext = CreateInformationContext(DefaultPageSettings);
			int result = defaultValue;
			try
			{
				result = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(deviceContext, deviceContext.Hdc), capability);
				return result;
			}
			catch (InvalidPrinterException)
			{
				return result;
			}
			finally
			{
				deviceContext.Dispose();
			}
		}

		public IntPtr GetHdevmode()
		{
			IntSecurity.AllPrintingAndUnmanagedCode.Demand();
			IntPtr hdevmodeInternal = GetHdevmodeInternal();
			defaultPageSettings.CopyToHdevmode(hdevmodeInternal);
			return hdevmodeInternal;
		}

		internal IntPtr GetHdevmodeInternal()
		{
			return GetHdevmodeInternal(PrinterNameInternal);
		}

		private IntPtr GetHdevmodeInternal(string printer)
		{
			int num = SafeNativeMethods.DocumentProperties(NativeMethods.NullHandleRef, NativeMethods.NullHandleRef, printer, IntPtr.Zero, NativeMethods.NullHandleRef, 0);
			if (num < 1)
			{
				throw new InvalidPrinterException(this);
			}
			IntPtr intPtr = SafeNativeMethods.GlobalAlloc(2, (uint)num);
			IntPtr intPtr2 = SafeNativeMethods.GlobalLock(new HandleRef(null, intPtr));
			if (cachedDevmode != null)
			{
				Marshal.Copy(cachedDevmode, 0, intPtr2, devmodebytes);
			}
			else
			{
				int num2 = SafeNativeMethods.DocumentProperties(NativeMethods.NullHandleRef, NativeMethods.NullHandleRef, printer, intPtr2, NativeMethods.NullHandleRef, 2);
				if (num2 < 0)
				{
					throw new Win32Exception();
				}
			}
			SafeNativeMethods.DEVMODE dEVMODE = (SafeNativeMethods.DEVMODE)UnsafeNativeMethods.PtrToStructure(intPtr2, typeof(SafeNativeMethods.DEVMODE));
			if (extrainfo != null && extrabytes <= dEVMODE.dmDriverExtra)
			{
				IntPtr destination = (IntPtr)checked((long)intPtr2 + dEVMODE.dmSize);
				Marshal.Copy(extrainfo, 0, destination, extrabytes);
			}
			if ((dEVMODE.dmFields & 0x100) == 256 && copies != -1)
			{
				dEVMODE.dmCopies = copies;
			}
			if ((dEVMODE.dmFields & 0x1000) == 4096 && duplex != Duplex.Default)
			{
				dEVMODE.dmDuplex = (short)duplex;
			}
			if ((dEVMODE.dmFields & 0x8000) == 32768 && collate.IsNotDefault)
			{
				dEVMODE.dmCollate = (short)(((bool)collate) ? 1 : 0);
			}
			Marshal.StructureToPtr(dEVMODE, intPtr2, fDeleteOld: false);
			int num3 = SafeNativeMethods.DocumentProperties(NativeMethods.NullHandleRef, NativeMethods.NullHandleRef, printer, intPtr2, intPtr2, 10);
			if (num3 < 0)
			{
				SafeNativeMethods.GlobalFree(new HandleRef(null, intPtr));
				SafeNativeMethods.GlobalUnlock(new HandleRef(null, intPtr));
				return IntPtr.Zero;
			}
			SafeNativeMethods.GlobalUnlock(new HandleRef(null, intPtr));
			return intPtr;
		}

		public IntPtr GetHdevmode(PageSettings pageSettings)
		{
			IntSecurity.AllPrintingAndUnmanagedCode.Demand();
			IntPtr hdevmodeInternal = GetHdevmodeInternal();
			pageSettings.CopyToHdevmode(hdevmodeInternal);
			return hdevmodeInternal;
		}

		public IntPtr GetHdevnames()
		{
			IntSecurity.AllPrintingAndUnmanagedCode.Demand();
			string text = PrinterName;
			string text2 = DriverName;
			string text3 = OutputPort;
			int num = checked(4 + text.Length + text2.Length + text3.Length);
			short num2 = (short)(8 / Marshal.SystemDefaultCharSize);
			uint dwBytes = (uint)checked(Marshal.SystemDefaultCharSize * (num2 + num));
			IntPtr intPtr = SafeNativeMethods.GlobalAlloc(66, dwBytes);
			IntPtr intPtr2 = SafeNativeMethods.GlobalLock(new HandleRef(null, intPtr));
			Marshal.WriteInt16(intPtr2, num2);
			num2 = (short)(num2 + WriteOneDEVNAME(text2, intPtr2, num2));
			Marshal.WriteInt16((IntPtr)checked((long)intPtr2 + 2), num2);
			num2 = (short)(num2 + WriteOneDEVNAME(text, intPtr2, num2));
			Marshal.WriteInt16((IntPtr)checked((long)intPtr2 + 4), num2);
			num2 = (short)(num2 + WriteOneDEVNAME(text3, intPtr2, num2));
			Marshal.WriteInt16((IntPtr)checked((long)intPtr2 + 6), num2);
			SafeNativeMethods.GlobalUnlock(new HandleRef(null, intPtr));
			return intPtr;
		}

		internal short GetModeField(ModeField field, short defaultValue)
		{
			return GetModeField(field, defaultValue, IntPtr.Zero);
		}

		internal short GetModeField(ModeField field, short defaultValue, IntPtr modeHandle)
		{
			bool flag = false;
			try
			{
				if (modeHandle == IntPtr.Zero)
				{
					try
					{
						modeHandle = GetHdevmodeInternal();
						flag = true;
					}
					catch (InvalidPrinterException)
					{
						return defaultValue;
					}
				}
				IntPtr lparam = SafeNativeMethods.GlobalLock(new HandleRef(this, modeHandle));
				SafeNativeMethods.DEVMODE dEVMODE = (SafeNativeMethods.DEVMODE)UnsafeNativeMethods.PtrToStructure(lparam, typeof(SafeNativeMethods.DEVMODE));
				short result = field switch
				{
					ModeField.Orientation => dEVMODE.dmOrientation, 
					ModeField.PaperSize => dEVMODE.dmPaperSize, 
					ModeField.PaperLength => dEVMODE.dmPaperLength, 
					ModeField.PaperWidth => dEVMODE.dmPaperWidth, 
					ModeField.Copies => dEVMODE.dmCopies, 
					ModeField.DefaultSource => dEVMODE.dmDefaultSource, 
					ModeField.PrintQuality => dEVMODE.dmPrintQuality, 
					ModeField.Color => dEVMODE.dmColor, 
					ModeField.Duplex => dEVMODE.dmDuplex, 
					ModeField.YResolution => dEVMODE.dmYResolution, 
					ModeField.TTOption => dEVMODE.dmTTOption, 
					ModeField.Collate => dEVMODE.dmCollate, 
					_ => defaultValue, 
				};
				SafeNativeMethods.GlobalUnlock(new HandleRef(this, modeHandle));
				return result;
			}
			finally
			{
				if (flag)
				{
					SafeNativeMethods.GlobalFree(new HandleRef(this, modeHandle));
				}
			}
		}

		internal PaperSize[] Get_PaperSizes()
		{
			IntSecurity.AllPrintingAndUnmanagedCode.Assert();
			string text = PrinterName;
			int num = FastDeviceCapabilities(16, IntPtr.Zero, -1, text);
			if (num == -1)
			{
				return new PaperSize[0];
			}
			int num2 = Marshal.SystemDefaultCharSize * 64;
			IntPtr intPtr = Marshal.AllocCoTaskMem(checked(num2 * num));
			FastDeviceCapabilities(16, intPtr, -1, text);
			IntPtr intPtr2 = Marshal.AllocCoTaskMem(2 * num);
			FastDeviceCapabilities(2, intPtr2, -1, text);
			IntPtr intPtr3 = Marshal.AllocCoTaskMem(8 * num);
			FastDeviceCapabilities(3, intPtr3, -1, text);
			PaperSize[] array = new PaperSize[num];
			for (int i = 0; i < num; i++)
			{
				string text2;
				short kind;
				int value;
				int value2;
				checked
				{
					text2 = Marshal.PtrToStringAuto((IntPtr)((long)intPtr + num2 * i), 64);
					int num3 = text2.IndexOf('\0');
					if (num3 > -1)
					{
						text2 = text2.Substring(0, num3);
					}
					kind = Marshal.ReadInt16((IntPtr)((long)intPtr2 + i * 2));
					value = Marshal.ReadInt32((IntPtr)((long)intPtr3 + i * 8));
					value2 = Marshal.ReadInt32((IntPtr)((long)intPtr3 + i * 8 + 4));
				}
				array[i] = new PaperSize((PaperKind)kind, text2, PrinterUnitConvert.Convert(value, PrinterUnit.TenthsOfAMillimeter, PrinterUnit.Display), PrinterUnitConvert.Convert(value2, PrinterUnit.TenthsOfAMillimeter, PrinterUnit.Display));
			}
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			Marshal.FreeCoTaskMem(intPtr3);
			return array;
		}

		internal PaperSource[] Get_PaperSources()
		{
			IntSecurity.AllPrintingAndUnmanagedCode.Assert();
			string text = PrinterName;
			int num = FastDeviceCapabilities(12, IntPtr.Zero, -1, text);
			if (num == -1)
			{
				return new PaperSource[0];
			}
			int num2 = Marshal.SystemDefaultCharSize * 24;
			IntPtr intPtr = Marshal.AllocCoTaskMem(checked(num2 * num));
			FastDeviceCapabilities(12, intPtr, -1, text);
			IntPtr intPtr2 = Marshal.AllocCoTaskMem(2 * num);
			FastDeviceCapabilities(6, intPtr2, -1, text);
			PaperSource[] array = new PaperSource[num];
			for (int i = 0; i < num; i++)
			{
				string name;
				short kind;
				checked
				{
					name = Marshal.PtrToStringAuto((IntPtr)((long)intPtr + num2 * i));
					kind = Marshal.ReadInt16((IntPtr)((long)intPtr2 + 2 * i));
				}
				array[i] = new PaperSource((PaperSourceKind)kind, name);
			}
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return array;
		}

		internal PrinterResolution[] Get_PrinterResolutions()
		{
			IntSecurity.AllPrintingAndUnmanagedCode.Assert();
			string text = PrinterName;
			int num = FastDeviceCapabilities(13, IntPtr.Zero, -1, text);
			if (num == -1)
			{
				return new PrinterResolution[4]
				{
					new PrinterResolution(PrinterResolutionKind.High, -4, -1),
					new PrinterResolution(PrinterResolutionKind.Medium, -3, -1),
					new PrinterResolution(PrinterResolutionKind.Low, -2, -1),
					new PrinterResolution(PrinterResolutionKind.Draft, -1, -1)
				};
			}
			PrinterResolution[] array = new PrinterResolution[num + 4];
			array[0] = new PrinterResolution(PrinterResolutionKind.High, -4, -1);
			array[1] = new PrinterResolution(PrinterResolutionKind.Medium, -3, -1);
			array[2] = new PrinterResolution(PrinterResolutionKind.Low, -2, -1);
			array[3] = new PrinterResolution(PrinterResolutionKind.Draft, -1, -1);
			IntPtr intPtr = Marshal.AllocCoTaskMem(checked(8 * num));
			FastDeviceCapabilities(13, intPtr, -1, text);
			for (int i = 0; i < num; i++)
			{
				int x;
				int y;
				checked
				{
					x = Marshal.ReadInt32((IntPtr)((long)intPtr + i * 8));
					y = Marshal.ReadInt32((IntPtr)((long)intPtr + i * 8 + 4));
				}
				array[i + 4] = new PrinterResolution(PrinterResolutionKind.Custom, x, y);
			}
			Marshal.FreeCoTaskMem(intPtr);
			return array;
		}

		private static string ReadOneDEVNAME(IntPtr pDevnames, int slot)
		{
			checked
			{
				int num = Marshal.SystemDefaultCharSize * Marshal.ReadInt16((IntPtr)((long)pDevnames + slot * 2));
				return Marshal.PtrToStringAuto((IntPtr)((long)pDevnames + num));
			}
		}

		public void SetHdevmode(IntPtr hdevmode)
		{
			IntSecurity.AllPrintingAndUnmanagedCode.Demand();
			if (hdevmode == IntPtr.Zero)
			{
				throw new ArgumentException(SR.GetString("InvalidPrinterHandle", hdevmode));
			}
			IntPtr intPtr = SafeNativeMethods.GlobalLock(new HandleRef(null, hdevmode));
			SafeNativeMethods.DEVMODE dEVMODE = (SafeNativeMethods.DEVMODE)UnsafeNativeMethods.PtrToStructure(intPtr, typeof(SafeNativeMethods.DEVMODE));
			devmodebytes = dEVMODE.dmSize;
			if (devmodebytes > 0)
			{
				cachedDevmode = new byte[devmodebytes];
				Marshal.Copy(intPtr, cachedDevmode, 0, devmodebytes);
			}
			extrabytes = dEVMODE.dmDriverExtra;
			if (extrabytes > 0)
			{
				extrainfo = new byte[extrabytes];
				Marshal.Copy((IntPtr)checked((long)intPtr + dEVMODE.dmSize), extrainfo, 0, extrabytes);
			}
			if ((dEVMODE.dmFields & 0x100) == 256)
			{
				copies = dEVMODE.dmCopies;
			}
			if ((dEVMODE.dmFields & 0x1000) == 4096)
			{
				duplex = (Duplex)dEVMODE.dmDuplex;
			}
			if ((dEVMODE.dmFields & 0x8000) == 32768)
			{
				collate = dEVMODE.dmCollate == 1;
			}
			SafeNativeMethods.GlobalUnlock(new HandleRef(null, hdevmode));
		}

		public void SetHdevnames(IntPtr hdevnames)
		{
			IntSecurity.AllPrintingAndUnmanagedCode.Demand();
			if (hdevnames == IntPtr.Zero)
			{
				throw new ArgumentException(SR.GetString("InvalidPrinterHandle", hdevnames));
			}
			IntPtr pDevnames = SafeNativeMethods.GlobalLock(new HandleRef(null, hdevnames));
			driverName = ReadOneDEVNAME(pDevnames, 0);
			printerName = ReadOneDEVNAME(pDevnames, 1);
			outputPort = ReadOneDEVNAME(pDevnames, 2);
			PrintDialogDisplayed = true;
			SafeNativeMethods.GlobalUnlock(new HandleRef(null, hdevnames));
		}

		public override string ToString()
		{
			string text = (IntSecurity.HasPermission(IntSecurity.AllPrinting) ? PrinterName : "<printer name unavailable>");
			return "[PrinterSettings " + text + " Copies=" + Copies.ToString(CultureInfo.InvariantCulture) + " Collate=" + Collate.ToString(CultureInfo.InvariantCulture) + " Duplex=" + TypeDescriptor.GetConverter(typeof(Duplex)).ConvertToString((int)Duplex) + " FromPage=" + FromPage.ToString(CultureInfo.InvariantCulture) + " LandscapeAngle=" + LandscapeAngle.ToString(CultureInfo.InvariantCulture) + " MaximumCopies=" + MaximumCopies.ToString(CultureInfo.InvariantCulture) + " OutputPort=" + OutputPort.ToString(CultureInfo.InvariantCulture) + " ToPage=" + ToPage.ToString(CultureInfo.InvariantCulture) + "]";
		}

		private short WriteOneDEVNAME(string str, IntPtr bufferStart, int index)
		{
			if (str == null)
			{
				str = "";
			}
			checked
			{
				IntPtr intPtr = (IntPtr)((long)bufferStart + index * Marshal.SystemDefaultCharSize);
				if (Marshal.SystemDefaultCharSize == 1)
				{
					byte[] bytes = Encoding.Default.GetBytes(str);
					Marshal.Copy(bytes, 0, intPtr, bytes.Length);
					Marshal.WriteByte((IntPtr)((long)intPtr + bytes.Length), 0);
				}
				else
				{
					char[] array = str.ToCharArray();
					Marshal.Copy(array, 0, intPtr, array.Length);
					Marshal.WriteInt16((IntPtr)((long)intPtr + array.Length * 2), 0);
				}
				return (short)(str.Length + 1);
			}
		}
	}
	public enum PrinterUnit
	{
		Display,
		ThousandthsOfAnInch,
		HundredthsOfAMillimeter,
		TenthsOfAMillimeter
	}
	public sealed class PrinterUnitConvert
	{
		private PrinterUnitConvert()
		{
		}

		public static double Convert(double value, PrinterUnit fromUnit, PrinterUnit toUnit)
		{
			double num = UnitsPerDisplay(fromUnit);
			double num2 = UnitsPerDisplay(toUnit);
			return value * num2 / num;
		}

		public static int Convert(int value, PrinterUnit fromUnit, PrinterUnit toUnit)
		{
			return (int)Math.Round(Convert((double)value, fromUnit, toUnit));
		}

		public static Point Convert(Point value, PrinterUnit fromUnit, PrinterUnit toUnit)
		{
			return new Point(Convert(value.X, fromUnit, toUnit), Convert(value.Y, fromUnit, toUnit));
		}

		public static Size Convert(Size value, PrinterUnit fromUnit, PrinterUnit toUnit)
		{
			return new Size(Convert(value.Width, fromUnit, toUnit), Convert(value.Height, fromUnit, toUnit));
		}

		public static Rectangle Convert(Rectangle value, PrinterUnit fromUnit, PrinterUnit toUnit)
		{
			return new Rectangle(Convert(value.X, fromUnit, toUnit), Convert(value.Y, fromUnit, toUnit), Convert(value.Width, fromUnit, toUnit), Convert(value.Height, fromUnit, toUnit));
		}

		public static Margins Convert(Margins value, PrinterUnit fromUnit, PrinterUnit toUnit)
		{
			Margins margins = new Margins();
			margins.Left = Convert(value.Left, fromUnit, toUnit);
			margins.Right = Convert(value.Right, fromUnit, toUnit);
			margins.Top = Convert(value.Top, fromUnit, toUnit);
			margins.Bottom = Convert(value.Bottom, fromUnit, toUnit);
			return margins;
		}

		private static double UnitsPerDisplay(PrinterUnit unit)
		{
			return unit switch
			{
				PrinterUnit.Display => 1.0, 
				PrinterUnit.ThousandthsOfAnInch => 10.0, 
				PrinterUnit.HundredthsOfAMillimeter => 25.4, 
				PrinterUnit.TenthsOfAMillimeter => 2.54, 
				_ => 1.0, 
			};
		}
	}
	public class PrintEventArgs : CancelEventArgs
	{
		private PrintAction printAction;

		public PrintAction PrintAction => printAction;

		public PrintEventArgs()
		{
		}

		internal PrintEventArgs(PrintAction action)
		{
			printAction = action;
		}
	}
	public delegate void PrintEventHandler(object sender, PrintEventArgs e);
	[Serializable]
	public sealed class PrintingPermission : CodeAccessPermission, IUnrestrictedPermission
	{
		private PrintingPermissionLevel printingLevel;

		public PrintingPermissionLevel Level
		{
			get
			{
				return printingLevel;
			}
			set
			{
				VerifyPrintingLevel(value);
				printingLevel = value;
			}
		}

		public PrintingPermission(PermissionState state)
		{
			switch (state)
			{
			case PermissionState.Unrestricted:
				printingLevel = PrintingPermissionLevel.AllPrinting;
				break;
			case PermissionState.None:
				printingLevel = PrintingPermissionLevel.NoPrinting;
				break;
			default:
				throw new ArgumentException(SR.GetString("InvalidPermissionState"));
			}
		}

		public PrintingPermission(PrintingPermissionLevel printingLevel)
		{
			VerifyPrintingLevel(printingLevel);
			this.printingLevel = printingLevel;
		}

		private static void VerifyPrintingLevel(PrintingPermissionLevel level)
		{
			if (level < PrintingPermissionLevel.NoPrinting || level > PrintingPermissionLevel.AllPrinting)
			{
				throw new ArgumentException(SR.GetString("InvalidPermissionLevel"));
			}
		}

		public bool IsUnrestricted()
		{
			return printingLevel == PrintingPermissionLevel.AllPrinting;
		}

		public override bool IsSubsetOf(IPermission target)
		{
			if (target == null)
			{
				return printingLevel == PrintingPermissionLevel.NoPrinting;
			}
			if (!(target is PrintingPermission printingPermission))
			{
				throw new ArgumentException(SR.GetString("TargetNotPrintingPermission"));
			}
			return printingLevel <= printingPermission.printingLevel;
		}

		public override IPermission Intersect(IPermission target)
		{
			if (target == null)
			{
				return null;
			}
			if (!(target is PrintingPermission printingPermission))
			{
				throw new ArgumentException(SR.GetString("TargetNotPrintingPermission"));
			}
			PrintingPermissionLevel printingPermissionLevel = ((printingLevel < printingPermission.printingLevel) ? printingLevel : printingPermission.printingLevel);
			if (printingPermissionLevel == PrintingPermissionLevel.NoPrinting)
			{
				return null;
			}
			return new PrintingPermission(printingPermissionLevel);
		}

		public override IPermission Union(IPermission target)
		{
			if (target == null)
			{
				return Copy();
			}
			if (!(target is PrintingPermission printingPermission))
			{
				throw new ArgumentException(SR.GetString("TargetNotPrintingPermission"));
			}
			PrintingPermissionLevel printingPermissionLevel = ((printingLevel > printingPermission.printingLevel) ? printingLevel : printingPermission.printingLevel);
			if (printingPermissionLevel == PrintingPermissionLevel.NoPrinting)
			{
				return null;
			}
			return new PrintingPermission(printingPermissionLevel);
		}

		public override IPermission Copy()
		{
			return new PrintingPermission(printingLevel);
		}

		public override SecurityElement ToXml()
		{
			SecurityElement securityElement = new SecurityElement("IPermission");
			securityElement.AddAttribute("class", GetType().FullName + ", " + GetType().Module.Assembly.FullName.Replace('"', '\''));
			securityElement.AddAttribute("version", "1");
			if (!IsUnrestricted())
			{
				securityElement.AddAttribute("Level", Enum.GetName(typeof(PrintingPermissionLevel), printingLevel));
			}
			else
			{
				securityElement.AddAttribute("Unrestricted", "true");
			}
			return securityElement;
		}

		public override void FromXml(SecurityElement esd)
		{
			if (esd == null)
			{
				throw new ArgumentNullException("esd");
			}
			string text = esd.Attribute("class");
			if (text == null || text.IndexOf(GetType().FullName) == -1)
			{
				throw new ArgumentException(SR.GetString("InvalidClassName"));
			}
			string text2 = esd.Attribute("Unrestricted");
			if (text2 != null && string.Equals(text2, "true", StringComparison.OrdinalIgnoreCase))
			{
				printingLevel = PrintingPermissionLevel.AllPrinting;
				return;
			}
			printingLevel = PrintingPermissionLevel.NoPrinting;
			string text3 = esd.Attribute("Level");
			if (text3 != null)
			{
				printingLevel = (PrintingPermissionLevel)Enum.Parse(typeof(PrintingPermissionLevel), text3);
			}
		}
	}
	[AttributeUsage(AttributeTargets.All, AllowMultiple = true)]
	public sealed class PrintingPermissionAttribute : CodeAccessSecurityAttribute
	{
		private PrintingPermissionLevel level;

		public PrintingPermissionLevel Level
		{
			get
			{
				return level;
			}
			set
			{
				if (value < PrintingPermissionLevel.NoPrinting || value > PrintingPermissionLevel.AllPrinting)
				{
					throw new ArgumentException(SR.GetString("PrintingPermissionAttributeInvalidPermissionLevel"), "value");
				}
				level = value;
			}
		}

		public PrintingPermissionAttribute(SecurityAction action)
			: base(action)
		{
		}

		public override IPermission CreatePermission()
		{
			if (base.Unrestricted)
			{
				return new PrintingPermission(PermissionState.Unrestricted);
			}
			return new PrintingPermission(level);
		}
	}
	[Serializable]
	public enum PrintingPermissionLevel
	{
		NoPrinting,
		SafePrinting,
		DefaultPrinting,
		AllPrinting
	}
	public class PrintPageEventArgs : EventArgs
	{
		private bool hasMorePages;

		private bool cancel;

		private Graphics graphics;

		private readonly Rectangle marginBounds;

		private readonly Rectangle pageBounds;

		private readonly PageSettings pageSettings;

		public bool Cancel
		{
			get
			{
				return cancel;
			}
			set
			{
				cancel = value;
			}
		}

		public Graphics Graphics => graphics;

		public bool HasMorePages
		{
			get
			{
				return hasMorePages;
			}
			set
			{
				hasMorePages = value;
			}
		}

		public Rectangle MarginBounds => marginBounds;

		public Rectangle PageBounds => pageBounds;

		public PageSettings PageSettings => pageSettings;

		public PrintPageEventArgs(Graphics graphics, Rectangle marginBounds, Rectangle pageBounds, PageSettings pageSettings)
		{
			this.graphics = graphics;
			this.marginBounds = marginBounds;
			this.pageBounds = pageBounds;
			this.pageSettings = pageSettings;
		}

		internal void Dispose()
		{
			graphics.Dispose();
		}

		internal void SetGraphics(Graphics value)
		{
			graphics = value;
		}
	}
	public delegate void PrintPageEventHandler(object sender, PrintPageEventArgs e);
}
namespace System.Drawing
{
	internal class PrintPreviewGraphics
	{
		private PrintPageEventArgs printPageEventArgs;

		private PrintDocument printDocument;

		public RectangleF VisibleClipBounds
		{
			get
			{
				IntPtr hdevmodeInternal = printPageEventArgs.PageSettings.PrinterSettings.GetHdevmodeInternal();
				using DeviceContext deviceContext = printPageEventArgs.PageSettings.PrinterSettings.CreateDeviceContext(hdevmodeInternal);
				using Graphics graphics = Graphics.FromHdcInternal(deviceContext.Hdc);
				if (printDocument.OriginAtMargins)
				{
					int deviceCaps = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(deviceContext, deviceContext.Hdc), 88);
					int deviceCaps2 = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(deviceContext, deviceContext.Hdc), 90);
					int deviceCaps3 = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(deviceContext, deviceContext.Hdc), 112);
					int deviceCaps4 = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(deviceContext, deviceContext.Hdc), 113);
					float num = deviceCaps3 * 100 / deviceCaps;
					float num2 = deviceCaps4 * 100 / deviceCaps2;
					graphics.TranslateTransform(0f - num, 0f - num2);
					graphics.TranslateTransform(printDocument.DefaultPageSettings.Margins.Left, printDocument.DefaultPageSettings.Margins.Top);
				}
				return graphics.VisibleClipBounds;
			}
		}

		public PrintPreviewGraphics(PrintDocument document, PrintPageEventArgs e)
		{
			printPageEventArgs = e;
			printDocument = document;
		}
	}
}
namespace System.Drawing.Printing
{
	[Serializable]
	public enum PrintRange
	{
		AllPages = 0,
		SomePages = 2,
		Selection = 1,
		CurrentPage = 4194304
	}
	public class QueryPageSettingsEventArgs : PrintEventArgs
	{
		private PageSettings pageSettings;

		public PageSettings PageSettings
		{
			get
			{
				return pageSettings;
			}
			set
			{
				if (value == null)
				{
					value = new PageSettings();
				}
				pageSettings = value;
			}
		}

		public QueryPageSettingsEventArgs(PageSettings pageSettings)
		{
			this.pageSettings = pageSettings;
		}
	}
	public delegate void QueryPageSettingsEventHandler(object sender, QueryPageSettingsEventArgs e);
	[Serializable]
	internal struct TriState
	{
		private byte value;

		public static readonly TriState Default = new TriState(0);

		public static readonly TriState False = new TriState(1);

		public static readonly TriState True = new TriState(2);

		public bool IsDefault => this == Default;

		public bool IsFalse => this == False;

		public bool IsNotDefault => this != Default;

		public bool IsTrue => this == True;

		private TriState(byte value)
		{
			this.value = value;
		}

		public static bool operator ==(TriState left, TriState right)
		{
			return left.value == right.value;
		}

		public static bool operator !=(TriState left, TriState right)
		{
			return !(left == right);
		}

		public override bool Equals(object o)
		{
			TriState triState = (TriState)o;
			return value == triState.value;
		}

		public override int GetHashCode()
		{
			return value;
		}

		public static implicit operator TriState(bool value)
		{
			if (!value)
			{
				return False;
			}
			return True;
		}

		public static explicit operator bool(TriState value)
		{
			if (value.IsDefault)
			{
				throw new InvalidCastException(SR.GetString("TriStateCompareError"));
			}
			return value == True;
		}

		public override string ToString()
		{
			if (this == Default)
			{
				return "Default";
			}
			if (this == False)
			{
				return "False";
			}
			return "True";
		}
	}
}
