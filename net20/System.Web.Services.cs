
// C:\WINDOWS\assembly\GAC_MSIL\System.Web.Services\2.0.0.0__b03f5f7f11d50a3a\System.Web.Services.dll
// System.Web.Services, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
// Global type: <Module>
// Architecture: AnyCPU (64-bit preferred)
// Runtime: v2.0.50727
// This assembly is signed with a strong name key.
// Hash algorithm: SHA1
// Public key: 002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293

#define TRACE
using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Configuration;
using System.Data;
using System.Data.Design;
using System.Diagnostics;
using System.DirectoryServices;
using System.EnterpriseServices;
using System.Globalization;
using System.IO;
using System.Net;
using System.Net.Cache;
using System.Reflection;
using System.Resources;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Security;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Security.Permissions;
using System.Security.Policy;
using System.Security.Principal;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Web.Caching;
using System.Web.Configuration;
using System.Web.Hosting;
using System.Web.Services.Configuration;
using System.Web.Services.Description;
using System.Web.Services.Diagnostics;
using System.Web.Services.Discovery;
using System.Web.Services.Interop;
using System.Web.Services.Protocols;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.Util;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;
using Microsoft.CSharp;

[assembly: AssemblyDescription("System.Web.Services.dll")]
[assembly: AssemblyDefaultAlias("System.Web.Services.dll")]
[assembly: AllowPartiallyTrustedCallers]
[assembly: AssemblyTitle("System.Web.Services.dll")]
[assembly: CLSCompliant(true)]
[assembly: ComVisible(false)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: AssemblyKeyFile("f:\\dd\\Tools\\devdiv\\FinalPublicKey.snk")]
[assembly: AssemblyDelaySign(true)]
[assembly: NeutralResourcesLanguage("en-US")]
[assembly: SatelliteContractVersion("2.0.0.0")]
[assembly: AssemblyInformationalVersion("2.0.50727.9149")]
[assembly: AssemblyFileVersion("2.0.50727.9149")]
[assembly: AssemblyCopyright("© Microsoft Corporation.  All rights reserved.")]
[assembly: AssemblyProduct("Microsoft® .NET Framework")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyVersion("2.0.0.0")]
namespace System.Web.Services
{
	[AttributeUsage(AttributeTargets.All)]
	internal sealed class ResDescriptionAttribute : System.ComponentModel.DescriptionAttribute
	{
		private bool replaced;

		public override string Description
		{
			get
			{
				if (!replaced)
				{
					replaced = true;
					base.DescriptionValue = Res.GetString(base.Description);
				}
				return base.Description;
			}
		}

		public ResDescriptionAttribute(string description)
			: base(description)
		{
		}
	}
	[AttributeUsage(AttributeTargets.All)]
	internal sealed class ResCategoryAttribute : CategoryAttribute
	{
		public ResCategoryAttribute(string category)
			: base(category)
		{
		}

		protected override string GetLocalizedString(string value)
		{
			return Res.GetString(value);
		}
	}
	internal sealed class Res
	{
		internal const string NonClsCompliantException = "NonClsCompliantException";

		internal const string WebConfigInvalidExtensionPriority = "WebConfigInvalidExtensionPriority";

		internal const string ConfigKeyNotFoundInElementCollection = "ConfigKeyNotFoundInElementCollection";

		internal const string ConfigKeysDoNotMatch = "ConfigKeysDoNotMatch";

		internal const string Invalid_priority_group_value = "Invalid_priority_group_value";

		internal const string WebSchemaNotFound = "WebSchemaNotFound";

		internal const string WebReflectionError = "WebReflectionError";

		internal const string WebInvalidMethodName = "WebInvalidMethodName";

		internal const string WebInvalidMethodNameCase = "WebInvalidMethodNameCase";

		internal const string WebInvalidRequestFormat = "WebInvalidRequestFormat";

		internal const string WebInvalidRequestFormatDetails = "WebInvalidRequestFormatDetails";

		internal const string WebMethodStatic = "WebMethodStatic";

		internal const string WebMethodMissingParams = "WebMethodMissingParams";

		internal const string WebBadOutParameter = "WebBadOutParameter";

		internal const string WebInOutParameter = "WebInOutParameter";

		internal const string WebAsyncMissingEnd = "WebAsyncMissingEnd";

		internal const string WebMissingPath = "WebMissingPath";

		internal const string WebResponseKnownError = "WebResponseKnownError";

		internal const string WebResponseUnknownError = "WebResponseUnknownError";

		internal const string WebResponseUnknownErrorEmptyBody = "WebResponseUnknownErrorEmptyBody";

		internal const string WebResponseContent = "WebResponseContent";

		internal const string WebBadStreamState = "WebBadStreamState";

		internal const string WebResponseBadXml = "WebResponseBadXml";

		internal const string WebCannotUnderstandHeader = "WebCannotUnderstandHeader";

		internal const string WebMissingHeader = "WebMissingHeader";

		internal const string WebNoReturnValue = "WebNoReturnValue";

		internal const string WebCannotAccessValue = "WebCannotAccessValue";

		internal const string WebCannotAccessValueStage = "WebCannotAccessValueStage";

		internal const string WebInvalidBindingPlacement = "WebInvalidBindingPlacement";

		internal const string WebInvalidBindingName = "WebInvalidBindingName";

		internal const string WebBothMethodAttrs = "WebBothMethodAttrs";

		internal const string WebBothServiceAttrs = "WebBothServiceAttrs";

		internal const string WebOneWayOutParameters = "WebOneWayOutParameters";

		internal const string WebOneWayReturnValue = "WebOneWayReturnValue";

		internal const string WebReflectionErrorMethod = "WebReflectionErrorMethod";

		internal const string WebMultiDimArray = "WebMultiDimArray";

		internal const string WebHeaderMissing = "WebHeaderMissing";

		internal const string WebHeaderStatic = "WebHeaderStatic";

		internal const string WebHeaderRead = "WebHeaderRead";

		internal const string WebHeaderWrite = "WebHeaderWrite";

		internal const string WebHeaderType = "WebHeaderType";

		internal const string WebHeaderOneWayOut = "WebHeaderOneWayOut";

		internal const string WebHeaderInvalidMustUnderstand = "WebHeaderInvalidMustUnderstand";

		internal const string WebMultiplyDeclaredHeaderTypes = "WebMultiplyDeclaredHeaderTypes";

		internal const string WebHttpHeader = "WebHttpHeader";

		internal const string WebRequestContent = "WebRequestContent";

		internal const string WebRequestUnableToRead = "WebRequestUnableToRead";

		internal const string WebRequestUnableToProcess = "WebRequestUnableToProcess";

		internal const string WebMissingParameter = "WebMissingParameter";

		internal const string WebUnrecognizedRequestFormat = "WebUnrecognizedRequestFormat";

		internal const string WebUnrecognizedRequestFormatUrl = "WebUnrecognizedRequestFormatUrl";

		internal const string WebTimeout = "WebTimeout";

		internal const string WebMissingHelpContext = "WebMissingHelpContext";

		internal const string WebMissingCustomAttribute = "WebMissingCustomAttribute";

		internal const string WebMissingClientProtocol = "WebMissingClientProtocol";

		internal const string WebResolveMissingClientProtocol = "WebResolveMissingClientProtocol";

		internal const string WebPathNotFound = "WebPathNotFound";

		internal const string WebMissingResource = "WebMissingResource";

		internal const string WebContractReferenceName = "WebContractReferenceName";

		internal const string WebShemaReferenceName = "WebShemaReferenceName";

		internal const string WebDiscoveryDocumentReferenceName = "WebDiscoveryDocumentReferenceName";

		internal const string WebMissingDocument = "WebMissingDocument";

		internal const string WebInvalidContentType = "WebInvalidContentType";

		internal const string WebInvalidFormat = "WebInvalidFormat";

		internal const string WebInvalidEnvelopeNamespace = "WebInvalidEnvelopeNamespace";

		internal const string WebResultNotXml = "WebResultNotXml";

		internal const string WebDescriptionMissingItem = "WebDescriptionMissingItem";

		internal const string WebDescriptionMissing = "WebDescriptionMissing";

		internal const string WebDescriptionPartElementRequired = "WebDescriptionPartElementRequired";

		internal const string WebDescriptionPartTypeRequired = "WebDescriptionPartTypeRequired";

		internal const string WebDescriptionPartElementWarning = "WebDescriptionPartElementWarning";

		internal const string WebDescriptionPartTypeWarning = "WebDescriptionPartTypeWarning";

		internal const string WebDescriptionMissingBodyUseAttribute = "WebDescriptionMissingBodyUseAttribute";

		internal const string WebDescriptionTooManyMessages = "WebDescriptionTooManyMessages";

		internal const string WebDescriptionHeaderAndBodyUseMismatch = "WebDescriptionHeaderAndBodyUseMismatch";

		internal const string WebQNamePrefixUndefined = "WebQNamePrefixUndefined";

		internal const string WebNegativeValue = "WebNegativeValue";

		internal const string WebEmptyRef = "WebEmptyRef";

		internal const string WebNullRef = "WebNullRef";

		internal const string WebRefInvalidAttribute = "WebRefInvalidAttribute";

		internal const string WebRefInvalidAttribute2 = "WebRefInvalidAttribute2";

		internal const string WebInvalidDocType = "WebInvalidDocType";

		internal const string WebDiscoRefReport = "WebDiscoRefReport";

		internal const string WebTextMatchMissingPattern = "WebTextMatchMissingPattern";

		internal const string WebTextMatchIgnoredTypeWarning = "WebTextMatchIgnoredTypeWarning";

		internal const string WebTextMatchBadCaptureIndex = "WebTextMatchBadCaptureIndex";

		internal const string WebTextMatchBadGroupIndex = "WebTextMatchBadGroupIndex";

		internal const string WebServiceDescriptionIgnoredOptional = "WebServiceDescriptionIgnoredOptional";

		internal const string WebServiceDescriptionIgnoredRequired = "WebServiceDescriptionIgnoredRequired";

		internal const string WebDuplicateServiceDescription = "WebDuplicateServiceDescription";

		internal const string WebDuplicateFormatExtension = "WebDuplicateFormatExtension";

		internal const string WebDuplicateOperationMessage = "WebDuplicateOperationMessage";

		internal const string WebDuplicateImport = "WebDuplicateImport";

		internal const string WebDuplicateMessage = "WebDuplicateMessage";

		internal const string WebDuplicatePort = "WebDuplicatePort";

		internal const string WebDuplicatePortType = "WebDuplicatePortType";

		internal const string WebDuplicateBinding = "WebDuplicateBinding";

		internal const string WebDuplicateService = "WebDuplicateService";

		internal const string WebDuplicateMessagePart = "WebDuplicateMessagePart";

		internal const string WebDuplicateOperationBinding = "WebDuplicateOperationBinding";

		internal const string WebDuplicateFaultBinding = "WebDuplicateFaultBinding";

		internal const string WebDuplicateOperation = "WebDuplicateOperation";

		internal const string WebDuplicateOperationFault = "WebDuplicateOperationFault";

		internal const string WebDuplicateUnknownElement = "WebDuplicateUnknownElement";

		internal const string WebUnknownEncodingStyle = "WebUnknownEncodingStyle";

		internal const string WebSoap11EncodingStyleNotSupported1 = "WebSoap11EncodingStyleNotSupported1";

		internal const string WebNullAsyncResultInBegin = "WebNullAsyncResultInBegin";

		internal const string WebNullAsyncResultInEnd = "WebNullAsyncResultInEnd";

		internal const string WebAsyncTransaction = "WebAsyncTransaction";

		internal const string WebConfigExtensionError = "WebConfigExtensionError";

		internal const string WebExtensionError = "WebExtensionError";

		internal const string WebChangeTypeFailed = "WebChangeTypeFailed";

		internal const string WebBadEnum = "WebBadEnum";

		internal const string WebBadHex = "WebBadHex";

		internal const string WebClientBindingAttributeRequired = "WebClientBindingAttributeRequired";

		internal const string WebHeaderInvalidRelay = "WebHeaderInvalidRelay";

		internal const string WebVirtualDisoRoot = "WebVirtualDisoRoot";

		internal const string WebRefDuplicateSchema = "WebRefDuplicateSchema";

		internal const string WebRefDuplicateService = "WebRefDuplicateService";

		internal const string WebWsiContentTypeEncoding = "WebWsiContentTypeEncoding";

		internal const string WebWsiViolation = "WebWsiViolation";

		internal const string WebNullReaderForMessage = "WebNullReaderForMessage";

		internal const string WebNullWriterForMessage = "WebNullWriterForMessage";

		internal const string NeedConcreteType = "NeedConcreteType";

		internal const string WebUnknownElement = "WebUnknownElement";

		internal const string WebUnknownElement1 = "WebUnknownElement1";

		internal const string WebUnknownElement2 = "WebUnknownElement2";

		internal const string WebUnknownAttribute = "WebUnknownAttribute";

		internal const string WebUnknownAttribute2 = "WebUnknownAttribute2";

		internal const string WebUnknownAttribute3 = "WebUnknownAttribute3";

		internal const string WebUnreferencedObject = "WebUnreferencedObject";

		internal const string WebSuppressedExceptionMessage = "WebSuppressedExceptionMessage";

		internal const string WebServiceContext = "WebServiceContext";

		internal const string WebServiceSession = "WebServiceSession";

		internal const string WebServiceServer = "WebServiceServer";

		internal const string WebServiceUser = "WebServiceUser";

		internal const string WebServiceSoapVersion = "WebServiceSoapVersion";

		internal const string ClientProtocolAllowAutoRedirect = "ClientProtocolAllowAutoRedirect";

		internal const string ClientProtocolCookieContainer = "ClientProtocolCookieContainer";

		internal const string ClientProtocolPreAuthenticate = "ClientProtocolPreAuthenticate";

		internal const string ClientProtocolClientCertificates = "ClientProtocolClientCertificates";

		internal const string ClientProtocolUrl = "ClientProtocolUrl";

		internal const string ClientProtocolEncoding = "ClientProtocolEncoding";

		internal const string ClientProtocolTimeout = "ClientProtocolTimeout";

		internal const string ClientProtocolUserAgent = "ClientProtocolUserAgent";

		internal const string ClientProtocolUsername = "ClientProtocolUsername";

		internal const string ClientProtocolPassword = "ClientProtocolPassword";

		internal const string ClientProtocolDomain = "ClientProtocolDomain";

		internal const string ClientProtocolProxyName = "ClientProtocolProxyName";

		internal const string ClientProtocolProxyPort = "ClientProtocolProxyPort";

		internal const string ClientProtocolSoapVersion = "ClientProtocolSoapVersion";

		internal const string ClientProtocolEnableDecompression = "ClientProtocolEnableDecompression";

		internal const string XmlLang = "XmlLang";

		internal const string HelpGeneratorHttpGetTitle = "HelpGeneratorHttpGetTitle";

		internal const string HelpGeneratorHttpGetText = "HelpGeneratorHttpGetText";

		internal const string HelpGeneratorHttpPostTitle = "HelpGeneratorHttpPostTitle";

		internal const string HelpGeneratorHttpPostText = "HelpGeneratorHttpPostText";

		internal const string HelpGeneratorSoapTitle = "HelpGeneratorSoapTitle";

		internal const string HelpGeneratorSoap1_2Title = "HelpGeneratorSoap1_2Title";

		internal const string HelpGeneratorSoapText = "HelpGeneratorSoapText";

		internal const string HelpGeneratorSoap1_2Text = "HelpGeneratorSoap1_2Text";

		internal const string HelpGeneratorInvokeButton = "HelpGeneratorInvokeButton";

		internal const string HelpGeneratorParameter = "HelpGeneratorParameter";

		internal const string HelpGeneratorValue = "HelpGeneratorValue";

		internal const string HelpGeneratorTestHeader = "HelpGeneratorTestHeader";

		internal const string HelpGeneratorTestText = "HelpGeneratorTestText";

		internal const string HelpGeneratorNoTestFormRemote = "HelpGeneratorNoTestFormRemote";

		internal const string HelpGeneratorLinkBack = "HelpGeneratorLinkBack";

		internal const string HelpGeneratorEnableHttpPostHeader = "HelpGeneratorEnableHttpPostHeader";

		internal const string HelpGeneratorEnableHttpPostInstructions = "HelpGeneratorEnableHttpPostInstructions";

		internal const string HelpGeneratorOperationsIntro = "HelpGeneratorOperationsIntro";

		internal const string HelpGeneratorWebService = "HelpGeneratorWebService";

		internal const string HelpGeneratorNoHttpGetTest = "HelpGeneratorNoHttpGetTest";

		internal const string HelpGeneratorNoHttpPostTest = "HelpGeneratorNoHttpPostTest";

		internal const string HelpGeneratorNoTestNonPrimitive = "HelpGeneratorNoTestNonPrimitive";

		internal const string HelpGeneratorMethodNotFound = "HelpGeneratorMethodNotFound";

		internal const string HelpGeneratorMethodNotFoundText = "HelpGeneratorMethodNotFoundText";

		internal const string HelpGeneratorStyleBODY = "HelpGeneratorStyleBODY";

		internal const string HelpGeneratorStylecontent = "HelpGeneratorStylecontent";

		internal const string HelpGeneratorStyleAlink = "HelpGeneratorStyleAlink";

		internal const string HelpGeneratorStyleAvisited = "HelpGeneratorStyleAvisited";

		internal const string HelpGeneratorStyleAactive = "HelpGeneratorStyleAactive";

		internal const string HelpGeneratorStyleAhover = "HelpGeneratorStyleAhover";

		internal const string HelpGeneratorStyleP = "HelpGeneratorStyleP";

		internal const string HelpGeneratorStylepre = "HelpGeneratorStylepre";

		internal const string HelpGeneratorStyletd = "HelpGeneratorStyletd";

		internal const string HelpGeneratorStyleh2 = "HelpGeneratorStyleh2";

		internal const string HelpGeneratorStyleh3 = "HelpGeneratorStyleh3";

		internal const string HelpGeneratorStyleul = "HelpGeneratorStyleul";

		internal const string HelpGeneratorStyleol = "HelpGeneratorStyleol";

		internal const string HelpGeneratorStyleli = "HelpGeneratorStyleli";

		internal const string HelpGeneratorStylefontvalue = "HelpGeneratorStylefontvalue";

		internal const string HelpGeneratorStylefontkey = "HelpGeneratorStylefontkey";

		internal const string HelpGeneratorStylefontError = "HelpGeneratorStylefontError";

		internal const string HelpGeneratorStyleheading1 = "HelpGeneratorStyleheading1";

		internal const string HelpGeneratorStylebutton = "HelpGeneratorStylebutton";

		internal const string HelpGeneratorStylefrmheader = "HelpGeneratorStylefrmheader";

		internal const string HelpGeneratorStylefrmtext = "HelpGeneratorStylefrmtext";

		internal const string HelpGeneratorStylefrmInput = "HelpGeneratorStylefrmInput";

		internal const string HelpGeneratorStyleintro = "HelpGeneratorStyleintro";

		internal const string HelpGeneratorImplementation = "HelpGeneratorImplementation";

		internal const string HelpGeneratorDefaultNamespaceWarning1 = "HelpGeneratorDefaultNamespaceWarning1";

		internal const string HelpGeneratorDefaultNamespaceWarning2 = "HelpGeneratorDefaultNamespaceWarning2";

		internal const string HelpGeneratorDefaultNamespaceHelp1 = "HelpGeneratorDefaultNamespaceHelp1";

		internal const string HelpGeneratorDefaultNamespaceHelp2 = "HelpGeneratorDefaultNamespaceHelp2";

		internal const string HelpGeneratorDefaultNamespaceHelp3 = "HelpGeneratorDefaultNamespaceHelp3";

		internal const string HelpGeneratorDefaultNamespaceHelp4 = "HelpGeneratorDefaultNamespaceHelp4";

		internal const string HelpGeneratorDefaultNamespaceHelp5 = "HelpGeneratorDefaultNamespaceHelp5";

		internal const string HelpGeneratorDefaultNamespaceHelp6 = "HelpGeneratorDefaultNamespaceHelp6";

		internal const string HelpGeneratorServiceConformance = "HelpGeneratorServiceConformance";

		internal const string HelpGeneratorServiceConformanceDetails = "HelpGeneratorServiceConformanceDetails";

		internal const string HelpGeneratorServiceConformanceConfig = "HelpGeneratorServiceConformanceConfig";

		internal const string HelpGeneratorRecommendation = "HelpGeneratorRecommendation";

		internal const string Rxxxx = "Rxxxx";

		internal const string HelpGeneratorServiceConformanceRxxxx = "HelpGeneratorServiceConformanceRxxxx";

		internal const string HelpGeneratorServiceConformanceRxxxx_r = "HelpGeneratorServiceConformanceRxxxx_r";

		internal const string HelpGeneratorServiceConformanceR2028 = "HelpGeneratorServiceConformanceR2028";

		internal const string HelpGeneratorServiceConformanceR2026 = "HelpGeneratorServiceConformanceR2026";

		internal const string HelpGeneratorServiceConformanceR2705 = "HelpGeneratorServiceConformanceR2705";

		internal const string HelpGeneratorServiceConformanceR2705_r = "HelpGeneratorServiceConformanceR2705_r";

		internal const string HelpGeneratorServiceConformanceR2706 = "HelpGeneratorServiceConformanceR2706";

		internal const string HelpGeneratorServiceConformanceR2706_r = "HelpGeneratorServiceConformanceR2706_r";

		internal const string HelpGeneratorServiceConformanceR2007 = "HelpGeneratorServiceConformanceR2007";

		internal const string HelpGeneratorServiceConformanceR2007_r = "HelpGeneratorServiceConformanceR2007_r";

		internal const string HelpGeneratorServiceConformanceR2803 = "HelpGeneratorServiceConformanceR2803";

		internal const string HelpGeneratorServiceConformanceR2803_r = "HelpGeneratorServiceConformanceR2803_r";

		internal const string HelpGeneratorServiceConformanceR2105 = "HelpGeneratorServiceConformanceR2105";

		internal const string HelpGeneratorServiceConformanceR2105_r = "HelpGeneratorServiceConformanceR2105_r";

		internal const string HelpGeneratorServiceConformanceR1014 = "HelpGeneratorServiceConformanceR1014";

		internal const string HelpGeneratorServiceConformanceR1014_r = "HelpGeneratorServiceConformanceR1014_r";

		internal const string HelpGeneratorServiceConformanceR2201 = "HelpGeneratorServiceConformanceR2201";

		internal const string HelpGeneratorServiceConformanceR2210 = "HelpGeneratorServiceConformanceR2210";

		internal const string HelpGeneratorServiceConformanceR2210_r = "HelpGeneratorServiceConformanceR2210_r";

		internal const string HelpGeneratorServiceConformanceR2306 = "HelpGeneratorServiceConformanceR2306";

		internal const string HelpGeneratorServiceConformanceR2203 = "HelpGeneratorServiceConformanceR2203";

		internal const string HelpGeneratorServiceConformanceR2204 = "HelpGeneratorServiceConformanceR2204";

		internal const string HelpGeneratorServiceConformanceR2205 = "HelpGeneratorServiceConformanceR2205";

		internal const string HelpGeneratorServiceConformanceR2303 = "HelpGeneratorServiceConformanceR2303";

		internal const string HelpGeneratorServiceConformanceR2304 = "HelpGeneratorServiceConformanceR2304";

		internal const string HelpGeneratorServiceConformanceR2304_r = "HelpGeneratorServiceConformanceR2304_r";

		internal const string HelpGeneratorServiceConformanceR2701 = "HelpGeneratorServiceConformanceR2701";

		internal const string HelpGeneratorServiceConformanceR2702 = "HelpGeneratorServiceConformanceR2702";

		internal const string HelpGeneratorServiceConformanceR2710 = "HelpGeneratorServiceConformanceR2710";

		internal const string HelpGeneratorServiceConformanceR2710_r = "HelpGeneratorServiceConformanceR2710_r";

		internal const string HelpGeneratorServiceConformanceR2716 = "HelpGeneratorServiceConformanceR2716";

		internal const string HelpGeneratorServiceConformanceR2717 = "HelpGeneratorServiceConformanceR2717";

		internal const string HelpGeneratorServiceConformanceR2726 = "HelpGeneratorServiceConformanceR2726";

		internal const string HelpGeneratorServiceConformanceR2718 = "HelpGeneratorServiceConformanceR2718";

		internal const string HelpGeneratorServiceConformanceR2720 = "HelpGeneratorServiceConformanceR2720";

		internal const string HelpGeneratorServiceConformanceR2749 = "HelpGeneratorServiceConformanceR2749";

		internal const string HelpGeneratorServiceConformanceR2721 = "HelpGeneratorServiceConformanceR2721";

		internal const string HelpGeneratorServiceConformanceR2754 = "HelpGeneratorServiceConformanceR2754";

		internal const string HelpGeneratorServiceConformanceHelp = "HelpGeneratorServiceConformanceHelp";

		internal const string BindingMissingAttribute = "BindingMissingAttribute";

		internal const string BindingInvalidAttribute = "BindingInvalidAttribute";

		internal const string OperationFlowNotification = "OperationFlowNotification";

		internal const string OperationFlowSolicitResponse = "OperationFlowSolicitResponse";

		internal const string PortTypeOperationMissing = "PortTypeOperationMissing";

		internal const string BindingOperationMissing = "BindingOperationMissing";

		internal const string BindingMultipleParts = "BindingMultipleParts";

		internal const string ElementEncodedExtension = "ElementEncodedExtension";

		internal const string InputElement = "InputElement";

		internal const string OutputElement = "OutputElement";

		internal const string Fault = "Fault";

		internal const string HeaderFault = "HeaderFault";

		internal const string Binding = "Binding";

		internal const string Operation = "Operation";

		internal const string OperationBinding = "OperationBinding";

		internal const string FaultBinding = "FaultBinding";

		internal const string Description = "Description";

		internal const string Element = "Element";

		internal const string Port = "Port";

		internal const string Message = "Message";

		internal const string Part = "Part";

		internal const string OperationMissingBinding = "OperationMissingBinding";

		internal const string UriValueRelative = "UriValueRelative";

		internal const string HelpGeneratorLanguageConfig = "HelpGeneratorLanguageConfig";

		internal const string HelpGeneratorInternalError = "HelpGeneratorInternalError";

		internal const string OperationOverload = "OperationOverload";

		internal const string WireSignature = "WireSignature";

		internal const string WireSignatureEmpty = "WireSignatureEmpty";

		internal const string WsdlInstanceValidation = "WsdlInstanceValidation";

		internal const string WsdlInstanceValidationDetails = "WsdlInstanceValidationDetails";

		internal const string WhenUsingAMessageStyleOfParametersAsDocument0 = "WhenUsingAMessageStyleOfParametersAsDocument0";

		internal const string UnsupportedMessageStyle1 = "UnsupportedMessageStyle1";

		internal const string TheMethodsAndUseTheSameSoapActionWhenTheService3 = "TheMethodsAndUseTheSameSoapActionWhenTheService3";

		internal const string TheMethodDoesNotHaveARequestElementEither1 = "TheMethodDoesNotHaveARequestElementEither1";

		internal const string TheMethodsAndUseTheSameRequestElementXmlns4 = "TheMethodsAndUseTheSameRequestElementXmlns4";

		internal const string TheMethodsAndUseTheSameRequestElementAndSoapActionXmlns6 = "TheMethodsAndUseTheSameRequestElementAndSoapActionXmlns6";

		internal const string TheRootElementForTheRequestCouldNotBeDetermined0 = "TheRootElementForTheRequestCouldNotBeDetermined0";

		internal const string TheRequestElementXmlnsWasNotRecognized2 = "TheRequestElementXmlnsWasNotRecognized2";

		internal const string ServiceDescriptionWasNotFound0 = "ServiceDescriptionWasNotFound0";

		internal const string internalError0 = "internalError0";

		internal const string DiscoveryIsNotPossibleBecauseTypeIsMissing1 = "DiscoveryIsNotPossibleBecauseTypeIsMissing1";

		internal const string TheBindingNamedFromNamespaceWasNotFoundIn3 = "TheBindingNamedFromNamespaceWasNotFoundIn3";

		internal const string Missing2 = "Missing2";

		internal const string MissingHttpOperationElement0 = "MissingHttpOperationElement0";

		internal const string MessageHasNoParts1 = "MessageHasNoParts1";

		internal const string DuplicateInputOutputNames0 = "DuplicateInputOutputNames0";

		internal const string MissingBinding0 = "MissingBinding0";

		internal const string MissingInputBinding0 = "MissingInputBinding0";

		internal const string MissingOutputBinding0 = "MissingOutputBinding0";

		internal const string UnableToImportOperation1 = "UnableToImportOperation1";

		internal const string UnableToImportBindingFromNamespace2 = "UnableToImportBindingFromNamespace2";

		internal const string TheOperationFromNamespaceHadInvalidSyntax3 = "TheOperationFromNamespaceHadInvalidSyntax3";

		internal const string TheOperationBindingFromNamespaceHadInvalid3 = "TheOperationBindingFromNamespaceHadInvalid3";

		internal const string IfAppSettingBaseUrlArgumentIsSpecifiedThen0 = "IfAppSettingBaseUrlArgumentIsSpecifiedThen0";

		internal const string MissingMessagePartForMessageFromNamespace3 = "MissingMessagePartForMessageFromNamespace3";

		internal const string MissingMessage2 = "MissingMessage2";

		internal const string OnlyXmlElementsOrTypesDerivingFromServiceDescriptionFormatExtension0 = "OnlyXmlElementsOrTypesDerivingFromServiceDescriptionFormatExtension0";

		internal const string OnlyOperationInputOrOperationOutputTypes = "OnlyOperationInputOrOperationOutputTypes";

		internal const string ProtocolWithNameIsNotRecognized1 = "ProtocolWithNameIsNotRecognized1";

		internal const string BothAndUseTheMessageNameUseTheMessageName3 = "BothAndUseTheMessageNameUseTheMessageName3";

		internal const string MissingSoapOperationBinding0 = "MissingSoapOperationBinding0";

		internal const string OnlyOneWebServiceBindingAttributeMayBeSpecified1 = "OnlyOneWebServiceBindingAttributeMayBeSpecified1";

		internal const string ContractOverride = "ContractOverride";

		internal const string TypeIsMissingWebServiceBindingAttributeThat2 = "TypeIsMissingWebServiceBindingAttributeThat2";

		internal const string MultipleBindingsWithSameName2 = "MultipleBindingsWithSameName2";

		internal const string UnknownWebServicesProtocolInConfigFile1 = "UnknownWebServicesProtocolInConfigFile1";

		internal const string RequiredXmlFormatExtensionAttributeIsMissing1 = "RequiredXmlFormatExtensionAttributeIsMissing1";

		internal const string TheSyntaxOfTypeMayNotBeExtended1 = "TheSyntaxOfTypeMayNotBeExtended1";

		internal const string InternalConfigurationError0 = "InternalConfigurationError0";

		internal const string ThereIsNoSoapTransportImporterThatUnderstands1 = "ThereIsNoSoapTransportImporterThatUnderstands1";

		internal const string MissingSoapBodyInputBinding0 = "MissingSoapBodyInputBinding0";

		internal const string MissingSoapBodyOutputBinding0 = "MissingSoapBodyOutputBinding0";

		internal const string TheOperationStyleRpcButBothMessagesAreNot0 = "TheOperationStyleRpcButBothMessagesAreNot0";

		internal const string TheCombinationOfStyleRpcWithUseLiteralIsNot0 = "TheCombinationOfStyleRpcWithUseLiteralIsNot0";

		internal const string TheEncodingIsNotSupported1 = "TheEncodingIsNotSupported1";

		internal const string SpecifyingAnElementForUseEncodedMessageParts0 = "SpecifyingAnElementForUseEncodedMessageParts0";

		internal const string EachMessagePartInAnUseEncodedMessageMustSpecify0 = "EachMessagePartInAnUseEncodedMessageMustSpecify0";

		internal const string SpecifyingATypeForUseLiteralMessagesIs0 = "SpecifyingATypeForUseLiteralMessagesIs0";

		internal const string SpecifyingATypeForUseLiteralMessagesIsAny = "SpecifyingATypeForUseLiteralMessagesIsAny";

		internal const string EachMessagePartInAUseLiteralMessageMustSpecify0 = "EachMessagePartInAUseLiteralMessageMustSpecify0";

		internal const string EachMessagePartInRpcUseLiteralMessageMustSpecify0 = "EachMessagePartInRpcUseLiteralMessageMustSpecify0";

		internal const string NoInputMIMEFormatsWereRecognized0 = "NoInputMIMEFormatsWereRecognized0";

		internal const string NoInputHTTPFormatsWereRecognized0 = "NoInputHTTPFormatsWereRecognized0";

		internal const string NoOutputMIMEFormatsWereRecognized0 = "NoOutputMIMEFormatsWereRecognized0";

		internal const string MissingMatchElement0 = "MissingMatchElement0";

		internal const string SolicitResponseIsNotSupported0 = "SolicitResponseIsNotSupported0";

		internal const string RequestResponseIsNotSupported0 = "RequestResponseIsNotSupported0";

		internal const string OneWayIsNotSupported0 = "OneWayIsNotSupported0";

		internal const string NotificationIsNotSupported0 = "NotificationIsNotSupported0";

		internal const string SyntaxErrorInWSDLDocumentMessageDoesNotHave1 = "SyntaxErrorInWSDLDocumentMessageDoesNotHave1";

		internal const string WebMissingBodyElement = "WebMissingBodyElement";

		internal const string WebMissingEnvelopeElement = "WebMissingEnvelopeElement";

		internal const string UnableToHandleRequestActionNotRecognized1 = "UnableToHandleRequestActionNotRecognized1";

		internal const string UnableToHandleRequestActionRequired0 = "UnableToHandleRequestActionRequired0";

		internal const string UnableToHandleRequest0 = "UnableToHandleRequest0";

		internal const string FailedToHandleRequest0 = "FailedToHandleRequest0";

		internal const string CodeGenSupportReferenceParameters = "CodeGenSupportReferenceParameters";

		internal const string CodeGenSupportParameterAttributes = "CodeGenSupportParameterAttributes";

		internal const string CodeGenSupportReturnTypeAttributes = "CodeGenSupportReturnTypeAttributes";

		internal const string TheBinding0FromNamespace1WasIgnored2 = "TheBinding0FromNamespace1WasIgnored2";

		internal const string TheOperation0FromNamespace1WasIgnored2 = "TheOperation0FromNamespace1WasIgnored2";

		internal const string TheOperationBinding0FromNamespace1WasIgnored = "TheOperationBinding0FromNamespace1WasIgnored";

		internal const string NoMethodsWereFoundInTheWSDLForThisProtocol = "NoMethodsWereFoundInTheWSDLForThisProtocol";

		internal const string UnexpectedFlush = "UnexpectedFlush";

		internal const string ThereWasAnErrorDuringAsyncProcessing = "ThereWasAnErrorDuringAsyncProcessing";

		internal const string CanTCallTheEndMethodOfAnAsyncCallMoreThan = "CanTCallTheEndMethodOfAnAsyncCallMoreThan";

		internal const string AsyncDuplicateUserState = "AsyncDuplicateUserState";

		internal const string StreamDoesNotSeek = "StreamDoesNotSeek";

		internal const string StreamDoesNotRead = "StreamDoesNotRead";

		internal const string ElementTypeMustBeObjectOrSoapReflectedException = "ElementTypeMustBeObjectOrSoapReflectedException";

		internal const string ElementTypeMustBeObjectOrSoapExtensionOrSoapReflectedException = "ElementTypeMustBeObjectOrSoapExtensionOrSoapReflectedException";

		internal const string ProtocolDoesNotAsyncSerialize = "ProtocolDoesNotAsyncSerialize";

		internal const string ThereWasAnErrorDownloading0 = "ThereWasAnErrorDownloading0";

		internal const string TheHTMLDocumentDoesNotContainDiscoveryInformation = "TheHTMLDocumentDoesNotContainDiscoveryInformation";

		internal const string TheDocumentWasNotRecognizedAsAKnownDocumentType = "TheDocumentWasNotRecognizedAsAKnownDocumentType";

		internal const string TheDocumentWasUnderstoodButContainsErrors = "TheDocumentWasUnderstoodButContainsErrors";

		internal const string TheWSDLDocumentContainsLinksThatCouldNotBeResolved = "TheWSDLDocumentContainsLinksThatCouldNotBeResolved";

		internal const string TheSchemaDocumentContainsLinksThatCouldNotBeResolved = "TheSchemaDocumentContainsLinksThatCouldNotBeResolved";

		internal const string CanTSpecifyElementOnEncodedMessagePartsPart = "CanTSpecifyElementOnEncodedMessagePartsPart";

		internal const string CanTMergeMessage = "CanTMergeMessage";

		internal const string CanTMergePortType = "CanTMergePortType";

		internal const string CanTMergeBinding = "CanTMergeBinding";

		internal const string CanTMergeTypes = "CanTMergeTypes";

		internal const string CanTMergeService = "CanTMergeService";

		internal const string indexMustBeBetweenAnd0Inclusive = "indexMustBeBetweenAnd0Inclusive";

		internal const string BPConformanceSoapEncodedMethod = "BPConformanceSoapEncodedMethod";

		internal const string BPConformanceHeaderFault = "BPConformanceHeaderFault";

		internal const string WsdlGenRpcLitAnonimousType = "WsdlGenRpcLitAnonimousType";

		internal const string WsdlGenRpcLitAccessorNamespace = "WsdlGenRpcLitAccessorNamespace";

		internal const string StackTraceEnd = "StackTraceEnd";

		internal const string CodeRemarks = "CodeRemarks";

		internal const string CodegenWarningDetails = "CodegenWarningDetails";

		internal const string ValidationError = "ValidationError";

		internal const string SchemaValidationError = "SchemaValidationError";

		internal const string SchemaValidationWarning = "SchemaValidationWarning";

		internal const string SchemaSyntaxErrorDetails = "SchemaSyntaxErrorDetails";

		internal const string SchemaSyntaxErrorItemDetails = "SchemaSyntaxErrorItemDetails";

		internal const string InitFailed = "InitFailed";

		internal const string XmlSchemaElementReference = "XmlSchemaElementReference";

		internal const string XmlSchemaAttributeReference = "XmlSchemaAttributeReference";

		internal const string XmlSchemaItem = "XmlSchemaItem";

		internal const string XmlSchemaNamedItem = "XmlSchemaNamedItem";

		internal const string XmlSchemaContentDef = "XmlSchemaContentDef";

		internal const string XmlSchema = "XmlSchema";

		internal const string TraceCallEnter = "TraceCallEnter";

		internal const string TraceCallEnterDetails = "TraceCallEnterDetails";

		internal const string TraceCallExit = "TraceCallExit";

		internal const string TraceExceptionThrown = "TraceExceptionThrown";

		internal const string TraceExceptionCought = "TraceExceptionCought";

		internal const string TraceExceptionIgnored = "TraceExceptionIgnored";

		internal const string TraceExceptionDetails = "TraceExceptionDetails";

		internal const string TracePostWorkItemIn = "TracePostWorkItemIn";

		internal const string TracePostWorkItemOut = "TracePostWorkItemOut";

		internal const string TraceUserHostName = "TraceUserHostName";

		internal const string TraceUserHostAddress = "TraceUserHostAddress";

		internal const string TraceUrl = "TraceUrl";

		internal const string TraceUrlReferrer = "TraceUrlReferrer";

		internal const string TraceCreateSerializer = "TraceCreateSerializer";

		internal const string TraceWriteRequest = "TraceWriteRequest";

		internal const string TraceWriteResponse = "TraceWriteResponse";

		internal const string TraceWriteHeaders = "TraceWriteHeaders";

		internal const string TraceReadRequest = "TraceReadRequest";

		internal const string TraceReadResponse = "TraceReadResponse";

		internal const string TraceReadHeaders = "TraceReadHeaders";

		private static Res loader;

		private ResourceManager resources;

		private static object s_InternalSyncObject;

		private static object InternalSyncObject
		{
			get
			{
				if (s_InternalSyncObject == null)
				{
					object value = new object();
					Interlocked.CompareExchange(ref s_InternalSyncObject, value, null);
				}
				return s_InternalSyncObject;
			}
		}

		private static CultureInfo Culture => null;

		public static ResourceManager Resources => GetLoader().resources;

		internal Res()
		{
			resources = new ResourceManager("System.Web.Services", GetType().Assembly);
		}

		private static Res GetLoader()
		{
			if (loader == null)
			{
				lock (InternalSyncObject)
				{
					if (loader == null)
					{
						loader = new Res();
					}
				}
			}
			return loader;
		}

		public static string GetString(string name, params object[] args)
		{
			Res res = GetLoader();
			if (res == null)
			{
				return null;
			}
			string @string = res.resources.GetString(name, Culture);
			if (args != null && args.Length > 0)
			{
				for (int i = 0; i < args.Length; i++)
				{
					if (args[i] is string text && text.Length > 1024)
					{
						args[i] = text.Substring(0, 1021) + "...";
					}
				}
				return string.Format(CultureInfo.CurrentCulture, @string, args);
			}
			return @string;
		}

		public static string GetString(string name)
		{
			return GetLoader()?.resources.GetString(name, Culture);
		}

		public static object GetObject(string name)
		{
			return GetLoader()?.resources.GetObject(name, Culture);
		}
	}
}
namespace System
{
	internal static class ExternDll
	{
		public const string Activeds = "activeds.dll";

		public const string Advapi32 = "advapi32.dll";

		public const string Comctl32 = "comctl32.dll";

		public const string Comdlg32 = "comdlg32.dll";

		public const string Gdi32 = "gdi32.dll";

		public const string Gdiplus = "gdiplus.dll";

		public const string Hhctrl = "hhctrl.ocx";

		public const string Imm32 = "imm32.dll";

		public const string Kernel32 = "kernel32.dll";

		public const string Loadperf = "Loadperf.dll";

		public const string Mscoree = "mscoree.dll";

		public const string Mscorwks = "mscorwks.dll";

		public const string Msi = "msi.dll";

		public const string Mqrt = "mqrt.dll";

		public const string Ntdll = "ntdll.dll";

		public const string Ole32 = "ole32.dll";

		public const string Oleacc = "oleacc.dll";

		public const string Oleaut32 = "oleaut32.dll";

		public const string Olepro32 = "olepro32.dll";

		public const string PerfCounter = "perfcounter.dll";

		public const string Powrprof = "Powrprof.dll";

		public const string Psapi = "psapi.dll";

		public const string Shell32 = "shell32.dll";

		public const string Shfolder = "shfolder.dll";

		public const string User32 = "user32.dll";

		public const string Uxtheme = "uxtheme.dll";

		public const string WinMM = "winmm.dll";

		public const string Winspool = "winspool.drv";

		public const string Wtsapi32 = "wtsapi32.dll";

		public const string Version = "version.dll";

		public const string Vsassert = "vsassert.dll";

		public const string Shlwapi = "shlwapi.dll";

		public const string Crypt32 = "crypt32.dll";

		internal const string Odbc32 = "odbc32.dll";

		internal const string SNI = "System.Data.dll";

		internal const string OciDll = "oci.dll";

		internal const string OraMtsDll = "oramts.dll";
	}
}
namespace System.Configuration
{
	[ConfigurationPermission(SecurityAction.Assert, Unrestricted = true)]
	internal static class PrivilegedConfigurationManager
	{
		internal static ConnectionStringSettingsCollection ConnectionStrings => ConfigurationManager.ConnectionStrings;

		internal static object GetSection(string sectionName)
		{
			return ConfigurationManager.GetSection(sectionName);
		}
	}
}
namespace System.ComponentModel
{
	internal sealed class CompModSwitches
	{
		private static BooleanSwitch dynamicDiscoVirtualSearch;

		private static TraceSwitch dynamicDiscoSearcher;

		private static BooleanSwitch disableRemoteDebugging;

		private static TraceSwitch remote;

		public static BooleanSwitch DisableRemoteDebugging
		{
			get
			{
				if (disableRemoteDebugging == null)
				{
					disableRemoteDebugging = new BooleanSwitch("Remote.Disable", "Disable remote debugging for web methods.");
				}
				return disableRemoteDebugging;
			}
		}

		public static TraceSwitch DynamicDiscoverySearcher
		{
			get
			{
				if (dynamicDiscoSearcher == null)
				{
					dynamicDiscoSearcher = new TraceSwitch("DynamicDiscoverySearcher", "Enable tracing for the DynamicDiscoverySearcher class.");
				}
				return dynamicDiscoSearcher;
			}
		}

		public static BooleanSwitch DynamicDiscoveryVirtualSearch
		{
			get
			{
				if (dynamicDiscoVirtualSearch == null)
				{
					dynamicDiscoVirtualSearch = new BooleanSwitch("DynamicDiscoveryVirtualSearch", "Force virtual search for DiscoveryRequestHandler class.");
				}
				return dynamicDiscoVirtualSearch;
			}
		}

		public static TraceSwitch Remote
		{
			get
			{
				if (remote == null)
				{
					remote = new TraceSwitch("Microsoft.WFC.Remote", "Enable tracing for remote method calls.");
				}
				return remote;
			}
		}
	}
}
namespace System.Web.Services
{
	internal class Soap
	{
		internal class Attribute
		{
			internal const string MustUnderstand = "mustUnderstand";

			internal const string Actor = "actor";

			internal const string EncodingStyle = "encodingStyle";

			internal const string Lang = "lang";

			internal const string ConformsTo = "conformsTo";

			private Attribute()
			{
			}
		}

		internal class Element
		{
			internal const string Envelope = "Envelope";

			internal const string Header = "Header";

			internal const string Body = "Body";

			internal const string Fault = "Fault";

			internal const string FaultActor = "faultactor";

			internal const string FaultCode = "faultcode";

			internal const string FaultDetail = "detail";

			internal const string FaultString = "faultstring";

			internal const string StackTrace = "StackTrace";

			internal const string Message = "Message";

			internal const string Claim = "Claim";

			private Element()
			{
			}
		}

		internal class Code
		{
			internal const string Server = "Server";

			internal const string VersionMismatch = "VersionMismatch";

			internal const string MustUnderstand = "MustUnderstand";

			internal const string Client = "Client";

			private Code()
			{
			}
		}

		internal const string XmlNamespace = "http://www.w3.org/XML/1998/namespace";

		internal const string Encoding = "http://schemas.xmlsoap.org/soap/encoding/";

		internal const string Namespace = "http://schemas.xmlsoap.org/soap/envelope/";

		internal const string ConformanceClaim = "http://ws-i.org/schemas/conformanceClaim/";

		internal const string BasicProfile1_1 = "http://ws-i.org/profiles/basic/1.1";

		internal const string Action = "SOAPAction";

		internal const string ArrayType = "Array";

		internal const string Prefix = "soap";

		internal const string ClaimPrefix = "wsi";

		internal const string DimeContentType = "application/dime";

		internal const string SoapContentType = "text/xml";

		private Soap()
		{
		}
	}
	internal sealed class Soap12
	{
		internal class Attribute
		{
			internal const string UpgradeEnvelopeQname = "qname";

			internal const string Role = "role";

			internal const string Relay = "relay";

			private Attribute()
			{
			}
		}

		internal sealed class Element
		{
			internal const string Upgrade = "Upgrade";

			internal const string UpgradeEnvelope = "SupportedEnvelope";

			internal const string FaultRole = "Role";

			internal const string FaultReason = "Reason";

			internal const string FaultReasonText = "Text";

			internal const string FaultCode = "Code";

			internal const string FaultNode = "Node";

			internal const string FaultCodeValue = "Value";

			internal const string FaultSubcode = "Subcode";

			internal const string FaultDetail = "Detail";

			private Element()
			{
			}
		}

		internal sealed class Code
		{
			internal const string VersionMismatch = "VersionMismatch";

			internal const string MustUnderstand = "MustUnderstand";

			internal const string DataEncodingUnknown = "DataEncodingUnknown";

			internal const string Sender = "Sender";

			internal const string Receiver = "Receiver";

			internal const string RpcProcedureNotPresentSubcode = "ProcedureNotPresent";

			internal const string RpcBadArgumentsSubcode = "BadArguments";

			internal const string EncodingMissingIDFaultSubcode = "MissingID";

			internal const string EncodingUntypedValueFaultSubcode = "UntypedValue";

			private Code()
			{
			}
		}

		internal const string Namespace = "http://www.w3.org/2003/05/soap-envelope";

		internal const string Encoding = "http://www.w3.org/2003/05/soap-encoding";

		internal const string RpcNamespace = "http://www.w3.org/2003/05/soap-rpc";

		internal const string Prefix = "soap12";

		private Soap12()
		{
		}
	}
	[ComVisible(false)]
	[SuppressUnmanagedCodeSecurity]
	[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
	internal class UnsafeNativeMethods
	{
		private UnsafeNativeMethods()
		{
		}

		[DllImport("ole32.dll", ExactSpelling = true)]
		internal static extern int CoCreateInstance([In] ref Guid clsid, [MarshalAs(UnmanagedType.Interface)] object punkOuter, int context, [In] ref Guid iid, [MarshalAs(UnmanagedType.Interface)] out object punk);

		internal static INotifySink2 RegisterNotifySource(INotifyConnection2 connection, INotifySource2 source)
		{
			return connection.RegisterNotifySource(source);
		}

		internal static void UnregisterNotifySource(INotifyConnection2 connection, INotifySource2 source)
		{
			connection.UnregisterNotifySource(source);
		}

		internal static void OnSyncCallOut(INotifySink2 sink, CallId callId, out IntPtr out_ppBuffer, ref int inout_pBufferSize)
		{
			sink.OnSyncCallOut(callId, out out_ppBuffer, ref inout_pBufferSize);
		}

		internal static void OnSyncCallEnter(INotifySink2 sink, CallId callId, byte[] in_pBuffer, int in_BufferSize)
		{
			sink.OnSyncCallEnter(callId, in_pBuffer, in_BufferSize);
		}

		internal static void OnSyncCallReturn(INotifySink2 sink, CallId callId, byte[] in_pBuffer, int in_BufferSize)
		{
			sink.OnSyncCallReturn(callId, in_pBuffer, in_BufferSize);
		}

		internal static void OnSyncCallExit(INotifySink2 sink, CallId callId, out IntPtr out_ppBuffer, ref int inout_pBufferSize)
		{
			sink.OnSyncCallExit(callId, out out_ppBuffer, ref inout_pBufferSize);
		}
	}
	[AttributeUsage(AttributeTargets.Method)]
	public sealed class WebMethodAttribute : Attribute
	{
		private int transactionOption;

		private bool enableSession;

		private int cacheDuration;

		private bool bufferResponse;

		private string description;

		private string messageName;

		private bool transactionOptionSpecified;

		private bool enableSessionSpecified;

		private bool cacheDurationSpecified;

		private bool bufferResponseSpecified;

		private bool descriptionSpecified;

		private bool messageNameSpecified;

		public string Description
		{
			get
			{
				if (description != null)
				{
					return description;
				}
				return string.Empty;
			}
			set
			{
				description = value;
				descriptionSpecified = true;
			}
		}

		internal bool DescriptionSpecified => descriptionSpecified;

		public bool EnableSession
		{
			get
			{
				return enableSession;
			}
			set
			{
				enableSession = value;
				enableSessionSpecified = true;
			}
		}

		internal bool EnableSessionSpecified => enableSessionSpecified;

		public int CacheDuration
		{
			get
			{
				return cacheDuration;
			}
			set
			{
				cacheDuration = value;
				cacheDurationSpecified = true;
			}
		}

		internal bool CacheDurationSpecified => cacheDurationSpecified;

		public bool BufferResponse
		{
			get
			{
				return bufferResponse;
			}
			set
			{
				bufferResponse = value;
				bufferResponseSpecified = true;
			}
		}

		internal bool BufferResponseSpecified => bufferResponseSpecified;

		public TransactionOption TransactionOption
		{
			get
			{
				return (TransactionOption)transactionOption;
			}
			set
			{
				transactionOption = (int)value;
				transactionOptionSpecified = true;
			}
		}

		internal bool TransactionOptionSpecified => transactionOptionSpecified;

		internal bool TransactionEnabled => transactionOption != 0;

		public string MessageName
		{
			get
			{
				if (messageName != null)
				{
					return messageName;
				}
				return string.Empty;
			}
			set
			{
				messageName = value;
				messageNameSpecified = true;
			}
		}

		internal bool MessageNameSpecified => messageNameSpecified;

		public WebMethodAttribute()
		{
			enableSession = false;
			transactionOption = 0;
			cacheDuration = 0;
			bufferResponse = true;
		}

		public WebMethodAttribute(bool enableSession)
			: this()
		{
			EnableSession = enableSession;
		}

		public WebMethodAttribute(bool enableSession, TransactionOption transactionOption)
			: this()
		{
			EnableSession = enableSession;
			this.transactionOption = (int)transactionOption;
			transactionOptionSpecified = true;
		}

		public WebMethodAttribute(bool enableSession, TransactionOption transactionOption, int cacheDuration)
		{
			EnableSession = enableSession;
			this.transactionOption = (int)transactionOption;
			transactionOptionSpecified = true;
			CacheDuration = cacheDuration;
			BufferResponse = true;
		}

		public WebMethodAttribute(bool enableSession, TransactionOption transactionOption, int cacheDuration, bool bufferResponse)
		{
			EnableSession = enableSession;
			this.transactionOption = (int)transactionOption;
			transactionOptionSpecified = true;
			CacheDuration = cacheDuration;
			BufferResponse = bufferResponse;
		}
	}
	internal class WebMethodReflector
	{
		private WebMethodReflector()
		{
		}

		internal static WebMethodAttribute GetAttribute(MethodInfo implementation, MethodInfo declaration)
		{
			WebMethodAttribute webMethodAttribute = null;
			WebMethodAttribute webMethodAttribute2 = null;
			object[] customAttributes;
			if (declaration != null)
			{
				customAttributes = declaration.GetCustomAttributes(typeof(WebMethodAttribute), inherit: false);
				if (customAttributes.Length > 0)
				{
					webMethodAttribute = (WebMethodAttribute)customAttributes[0];
				}
			}
			customAttributes = implementation.GetCustomAttributes(typeof(WebMethodAttribute), inherit: false);
			if (customAttributes.Length > 0)
			{
				webMethodAttribute2 = (WebMethodAttribute)customAttributes[0];
			}
			if (webMethodAttribute == null)
			{
				return webMethodAttribute2;
			}
			if (webMethodAttribute2 == null)
			{
				return webMethodAttribute;
			}
			if (webMethodAttribute2.MessageNameSpecified)
			{
				throw new InvalidOperationException(Res.GetString("ContractOverride", implementation.Name, implementation.DeclaringType.FullName, declaration.DeclaringType.FullName, declaration.ToString(), "WebMethod.MessageName"));
			}
			WebMethodAttribute webMethodAttribute3 = new WebMethodAttribute(webMethodAttribute2.EnableSessionSpecified ? webMethodAttribute2.EnableSession : webMethodAttribute.EnableSession);
			webMethodAttribute3.TransactionOption = (webMethodAttribute2.TransactionOptionSpecified ? webMethodAttribute2.TransactionOption : webMethodAttribute.TransactionOption);
			webMethodAttribute3.CacheDuration = (webMethodAttribute2.CacheDurationSpecified ? webMethodAttribute2.CacheDuration : webMethodAttribute.CacheDuration);
			webMethodAttribute3.BufferResponse = (webMethodAttribute2.BufferResponseSpecified ? webMethodAttribute2.BufferResponse : webMethodAttribute.BufferResponse);
			webMethodAttribute3.Description = (webMethodAttribute2.DescriptionSpecified ? webMethodAttribute2.Description : webMethodAttribute.Description);
			return webMethodAttribute3;
		}

		internal static MethodInfo FindInterfaceMethodInfo(Type type, string signature)
		{
			Type[] interfaces = type.GetInterfaces();
			Type[] array = interfaces;
			foreach (Type interfaceType in array)
			{
				InterfaceMapping interfaceMap = type.GetInterfaceMap(interfaceType);
				MethodInfo[] targetMethods = interfaceMap.TargetMethods;
				for (int j = 0; j < targetMethods.Length; j++)
				{
					if (targetMethods[j].ToString() == signature)
					{
						return interfaceMap.InterfaceMethods[j];
					}
				}
			}
			return null;
		}

		internal static LogicalMethodInfo[] GetMethods(Type type)
		{
			if (type.IsInterface)
			{
				throw new InvalidOperationException(Res.GetString("NeedConcreteType", type.FullName));
			}
			ArrayList arrayList = new ArrayList();
			MethodInfo[] methods = type.GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			Hashtable hashtable = new Hashtable();
			Hashtable hashtable2 = new Hashtable();
			for (int i = 0; i < methods.Length; i++)
			{
				Type declaringType = methods[i].DeclaringType;
				if (declaringType == typeof(object) || declaringType == typeof(WebService))
				{
					continue;
				}
				string text = methods[i].ToString();
				MethodInfo methodInfo = FindInterfaceMethodInfo(declaringType, text);
				WebServiceBindingAttribute webServiceBindingAttribute = null;
				if (methodInfo != null)
				{
					object[] customAttributes = methodInfo.DeclaringType.GetCustomAttributes(typeof(WebServiceBindingAttribute), inherit: false);
					if (customAttributes.Length > 0)
					{
						if (customAttributes.Length > 1)
						{
							throw new ArgumentException(Res.GetString("OnlyOneWebServiceBindingAttributeMayBeSpecified1", methodInfo.DeclaringType.FullName), "type");
						}
						webServiceBindingAttribute = (WebServiceBindingAttribute)customAttributes[0];
						if (webServiceBindingAttribute.Name == null || webServiceBindingAttribute.Name.Length == 0)
						{
							webServiceBindingAttribute.Name = methodInfo.DeclaringType.Name;
						}
					}
					else
					{
						methodInfo = null;
					}
				}
				else if (!methods[i].IsPublic)
				{
					continue;
				}
				WebMethodAttribute attribute = GetAttribute(methods[i], methodInfo);
				if (attribute != null)
				{
					WebMethod value = new WebMethod(methodInfo, webServiceBindingAttribute, attribute);
					hashtable2.Add(methods[i], value);
					MethodInfo methodInfo2 = (MethodInfo)hashtable[text];
					if (methodInfo2 == null)
					{
						hashtable.Add(text, methods[i]);
						arrayList.Add(methods[i]);
					}
					else if (methodInfo2.DeclaringType.IsAssignableFrom(methods[i].DeclaringType))
					{
						hashtable[text] = methods[i];
						arrayList[arrayList.IndexOf(methodInfo2)] = methods[i];
					}
				}
			}
			return LogicalMethodInfo.Create((MethodInfo[])arrayList.ToArray(typeof(MethodInfo)), (LogicalMethodTypes)3, hashtable2);
		}

		internal static void IncludeTypes(LogicalMethodInfo[] methods, XmlReflectionImporter importer)
		{
			foreach (LogicalMethodInfo method in methods)
			{
				IncludeTypes(method, importer);
			}
		}

		internal static void IncludeTypes(LogicalMethodInfo method, XmlReflectionImporter importer)
		{
			if (method.Declaration != null)
			{
				importer.IncludeTypes(method.Declaration.DeclaringType);
				importer.IncludeTypes(method.Declaration);
			}
			importer.IncludeTypes(method.DeclaringType);
			importer.IncludeTypes(method.CustomAttributeProvider);
		}
	}
	internal class WebMethod
	{
		internal MethodInfo declaration;

		internal WebServiceBindingAttribute binding;

		internal WebMethodAttribute attribute;

		internal WebMethod(MethodInfo declaration, WebServiceBindingAttribute binding, WebMethodAttribute attribute)
		{
			this.declaration = declaration;
			this.binding = binding;
			this.attribute = attribute;
		}
	}
	public class WebService : MarshalByValueComponent
	{
		private HttpContext context;

		internal static readonly string SoapVersionContextSlot = "WebServiceSoapVersion";

		[System.ComponentModel.Description("The ASP.NET application object for the current request.")]
		[Browsable(false)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public HttpApplicationState Application
		{
			[AspNetHostingPermission(SecurityAction.LinkDemand, Level = AspNetHostingPermissionLevel.Minimal)]
			get
			{
				return Context.Application;
			}
		}

		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[WebServicesDescription("WebServiceContext")]
		[Browsable(false)]
		public HttpContext Context
		{
			[AspNetHostingPermission(SecurityAction.LinkDemand, Level = AspNetHostingPermissionLevel.Minimal)]
			get
			{
				if (context == null)
				{
					context = HttpContext.Current;
				}
				if (context == null)
				{
					throw new InvalidOperationException(Res.GetString("WebMissingHelpContext"));
				}
				return context;
			}
		}

		[WebServicesDescription("WebServiceSession")]
		[Browsable(false)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public HttpSessionState Session
		{
			[AspNetHostingPermission(SecurityAction.LinkDemand, Level = AspNetHostingPermissionLevel.Minimal)]
			get
			{
				return Context.Session;
			}
		}

		[Browsable(false)]
		[WebServicesDescription("WebServiceServer")]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public HttpServerUtility Server
		{
			[AspNetHostingPermission(SecurityAction.LinkDemand, Level = AspNetHostingPermissionLevel.Minimal)]
			get
			{
				return Context.Server;
			}
		}

		[Browsable(false)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[WebServicesDescription("WebServiceUser")]
		public IPrincipal User
		{
			[AspNetHostingPermission(SecurityAction.LinkDemand, Level = AspNetHostingPermissionLevel.Minimal)]
			get
			{
				return Context.User;
			}
		}

		[ComVisible(false)]
		[WebServicesDescription("WebServiceSoapVersion")]
		[Browsable(false)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public SoapProtocolVersion SoapVersion
		{
			[AspNetHostingPermission(SecurityAction.LinkDemand, Level = AspNetHostingPermissionLevel.Minimal)]
			get
			{
				object obj = Context.Items[SoapVersionContextSlot];
				if (obj != null && obj is SoapProtocolVersion)
				{
					return (SoapProtocolVersion)obj;
				}
				return SoapProtocolVersion.Default;
			}
		}

		internal void SetContext(HttpContext context)
		{
			this.context = context;
		}
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface)]
	public sealed class WebServiceAttribute : Attribute
	{
		public const string DefaultNamespace = "http://tempuri.org/";

		private string description;

		private string ns = "http://tempuri.org/";

		private string name;

		public string Description
		{
			get
			{
				if (description != null)
				{
					return description;
				}
				return string.Empty;
			}
			set
			{
				description = value;
			}
		}

		public string Namespace
		{
			get
			{
				return ns;
			}
			set
			{
				ns = value;
			}
		}

		public string Name
		{
			get
			{
				if (name != null)
				{
					return name;
				}
				return string.Empty;
			}
			set
			{
				name = value;
			}
		}
	}
	internal class WebServiceReflector
	{
		private WebServiceReflector()
		{
		}

		internal static WebServiceAttribute GetAttribute(Type type)
		{
			object[] customAttributes = type.GetCustomAttributes(typeof(WebServiceAttribute), inherit: false);
			if (customAttributes.Length == 0)
			{
				return new WebServiceAttribute();
			}
			return (WebServiceAttribute)customAttributes[0];
		}

		internal static WebServiceAttribute GetAttribute(LogicalMethodInfo[] methodInfos)
		{
			if (methodInfos.Length == 0)
			{
				return new WebServiceAttribute();
			}
			Type mostDerivedType = GetMostDerivedType(methodInfos);
			return GetAttribute(mostDerivedType);
		}

		internal static Type GetMostDerivedType(LogicalMethodInfo[] methodInfos)
		{
			if (methodInfos.Length == 0)
			{
				return null;
			}
			Type type = methodInfos[0].DeclaringType;
			for (int i = 1; i < methodInfos.Length; i++)
			{
				Type declaringType = methodInfos[i].DeclaringType;
				if (declaringType.IsSubclassOf(type))
				{
					type = declaringType;
				}
			}
			return type;
		}
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple = true)]
	public sealed class WebServiceBindingAttribute : Attribute
	{
		private string name;

		private string ns;

		private string location;

		private WsiProfiles claims;

		private bool emitClaims;

		public WsiProfiles ConformsTo
		{
			get
			{
				return claims;
			}
			set
			{
				claims = value;
			}
		}

		public bool EmitConformanceClaims
		{
			get
			{
				return emitClaims;
			}
			set
			{
				emitClaims = value;
			}
		}

		public string Location
		{
			get
			{
				if (location != null)
				{
					return location;
				}
				return string.Empty;
			}
			set
			{
				location = value;
			}
		}

		public string Name
		{
			get
			{
				if (name != null)
				{
					return name;
				}
				return string.Empty;
			}
			set
			{
				name = value;
			}
		}

		public string Namespace
		{
			get
			{
				if (ns != null)
				{
					return ns;
				}
				return string.Empty;
			}
			set
			{
				ns = value;
			}
		}

		public WebServiceBindingAttribute()
		{
		}

		public WebServiceBindingAttribute(string name)
		{
			this.name = name;
		}

		public WebServiceBindingAttribute(string name, string ns)
		{
			this.name = name;
			this.ns = ns;
		}

		public WebServiceBindingAttribute(string name, string ns, string location)
		{
			this.name = name;
			this.ns = ns;
			this.location = location;
		}
	}
	internal class WebServiceBindingReflector
	{
		private WebServiceBindingReflector()
		{
		}

		internal static WebServiceBindingAttribute GetAttribute(Type type)
		{
			while (type != null)
			{
				object[] customAttributes = type.GetCustomAttributes(typeof(WebServiceBindingAttribute), inherit: false);
				if (customAttributes.Length != 0)
				{
					if (customAttributes.Length > 1)
					{
						throw new ArgumentException(Res.GetString("OnlyOneWebServiceBindingAttributeMayBeSpecified1", type.FullName), "type");
					}
					return (WebServiceBindingAttribute)customAttributes[0];
				}
				type = type.BaseType;
			}
			return null;
		}

		internal static WebServiceBindingAttribute GetAttribute(LogicalMethodInfo methodInfo, string binding)
		{
			if (methodInfo.Binding != null)
			{
				if (binding.Length > 0 && methodInfo.Binding.Name != binding)
				{
					throw new InvalidOperationException(Res.GetString("WebInvalidBindingName", binding, methodInfo.Binding.Name));
				}
				return methodInfo.Binding;
			}
			Type declaringType = methodInfo.DeclaringType;
			object[] customAttributes = declaringType.GetCustomAttributes(typeof(WebServiceBindingAttribute), inherit: false);
			WebServiceBindingAttribute webServiceBindingAttribute = null;
			object[] array = customAttributes;
			for (int i = 0; i < array.Length; i++)
			{
				WebServiceBindingAttribute webServiceBindingAttribute2 = (WebServiceBindingAttribute)array[i];
				if (webServiceBindingAttribute2.Name == binding)
				{
					if (webServiceBindingAttribute != null)
					{
						throw new ArgumentException(Res.GetString("MultipleBindingsWithSameName2", declaringType.FullName, binding, "methodInfo"));
					}
					webServiceBindingAttribute = webServiceBindingAttribute2;
				}
			}
			if (webServiceBindingAttribute == null && binding != null && binding.Length > 0)
			{
				throw new ArgumentException(Res.GetString("TypeIsMissingWebServiceBindingAttributeThat2", declaringType.FullName, binding), "methodInfo");
			}
			return webServiceBindingAttribute;
		}
	}
	[AttributeUsage(AttributeTargets.All)]
	internal class WebServicesDescriptionAttribute : System.ComponentModel.DescriptionAttribute
	{
		private bool replaced;

		public override string Description
		{
			get
			{
				if (!replaced)
				{
					replaced = true;
					base.DescriptionValue = Res.GetString(base.Description);
				}
				return base.Description;
			}
		}

		internal WebServicesDescriptionAttribute(string description)
			: base(description)
		{
		}
	}
	[Flags]
	public enum WsiProfiles
	{
		None = 0,
		BasicProfile1_1 = 1
	}
}
namespace System.Web.Services.Interop
{
	[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
	internal struct CallId
	{
		public string szMachine;

		public int dwPid;

		public IntPtr userThread;

		public long addStackPointer;

		public string szEntryPoint;

		public string szDestinationMachine;

		public CallId(string machine, int pid, IntPtr userThread, long stackPtr, string entryPoint, string destMachine)
		{
			szMachine = machine;
			dwPid = pid;
			this.userThread = userThread;
			addStackPointer = stackPtr;
			szEntryPoint = entryPoint;
			szDestinationMachine = destMachine;
		}
	}
	[ComImport]
	[SuppressUnmanagedCodeSecurity]
	[Guid("1AF04045-6659-4aaa-9F4B-2741AC56224B")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	internal interface INotifyConnection2
	{
		[return: MarshalAs(UnmanagedType.Interface)]
		INotifySink2 RegisterNotifySource([In][MarshalAs(UnmanagedType.Interface)] INotifySource2 in_pNotifySource);

		void UnregisterNotifySource([In][MarshalAs(UnmanagedType.Interface)] INotifySource2 in_pNotifySource);
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[SuppressUnmanagedCodeSecurity]
	[Guid("C43CC2F3-90AF-4e93-9112-DFB8B36749B5")]
	internal interface INotifySink2
	{
		void OnSyncCallOut([In] CallId callId, out IntPtr out_ppBuffer, [In][Out] ref int inout_pBufferSize);

		void OnSyncCallEnter([In] CallId callId, [In][MarshalAs(UnmanagedType.LPArray)] byte[] in_pBuffer, [In] int in_BufferSize);

		void OnSyncCallReturn([In] CallId callId, [In][MarshalAs(UnmanagedType.LPArray)] byte[] in_pBuffer, [In] int in_BufferSize);

		void OnSyncCallExit([In] CallId callId, out IntPtr out_ppBuffer, [In][Out] ref int inout_pBufferSize);
	}
	[ComImport]
	[Guid("26E7F0F1-B49C-48cb-B43E-78DCD577E1D9")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	internal interface INotifySource2
	{
		void SetNotifyFilter([In] NotifyFilter in_NotifyFilter, [In] UserThread in_pUserThreadFilter);
	}
	internal enum NotifyFilter
	{
		OnSyncCallOut = 1,
		OnSyncCallEnter = 2,
		OnSyncCallExit = 4,
		OnSyncCallReturn = 8,
		AllSync = 15,
		All = -1,
		None = 0
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class UserThread
	{
		internal int pSidBuffer;

		internal int dwSidLen;

		internal int dwTid;

		internal UserThread()
		{
			pSidBuffer = 0;
			dwSidLen = 0;
			dwTid = 0;
		}

		public override bool Equals(object obj)
		{
			if (!(obj is UserThread))
			{
				return false;
			}
			UserThread userThread = (UserThread)obj;
			if (userThread.dwTid == dwTid && userThread.pSidBuffer == pSidBuffer && userThread.dwSidLen == dwSidLen)
			{
				return true;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return base.GetHashCode();
		}
	}
}
namespace System.Web.Services.Protocols
{
	public abstract class MimeFormatter
	{
		public abstract object GetInitializer(LogicalMethodInfo methodInfo);

		public abstract void Initialize(object initializer);

		public virtual object[] GetInitializers(LogicalMethodInfo[] methodInfos)
		{
			object[] array = new object[methodInfos.Length];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = GetInitializer(methodInfos[i]);
			}
			return array;
		}

		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public static object GetInitializer(Type type, LogicalMethodInfo methodInfo)
		{
			return ((MimeFormatter)Activator.CreateInstance(type)).GetInitializer(methodInfo);
		}

		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public static object[] GetInitializers(Type type, LogicalMethodInfo[] methodInfos)
		{
			return ((MimeFormatter)Activator.CreateInstance(type)).GetInitializers(methodInfos);
		}

		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public static MimeFormatter CreateInstance(Type type, object initializer)
		{
			MimeFormatter mimeFormatter = (MimeFormatter)Activator.CreateInstance(type);
			mimeFormatter.Initialize(initializer);
			return mimeFormatter;
		}
	}
	public abstract class MimeReturnReader : MimeFormatter
	{
		public abstract object Read(WebResponse response, Stream responseStream);
	}
	public class AnyReturnReader : MimeReturnReader
	{
		public override void Initialize(object o)
		{
		}

		public override object GetInitializer(LogicalMethodInfo methodInfo)
		{
			if (methodInfo.IsVoid)
			{
				return null;
			}
			return this;
		}

		public override object Read(WebResponse response, Stream responseStream)
		{
			return responseStream;
		}
	}
	internal class BufferedResponseStream : Stream
	{
		private Stream outputStream;

		private byte[] buffer;

		private int position;

		private bool flushEnabled = true;

		public override bool CanRead => false;

		public override bool CanSeek => false;

		public override bool CanWrite => true;

		public override long Length
		{
			get
			{
				throw new NotSupportedException(Res.GetString("StreamDoesNotSeek"));
			}
		}

		public override long Position
		{
			get
			{
				throw new NotSupportedException(Res.GetString("StreamDoesNotSeek"));
			}
			set
			{
				throw new NotSupportedException(Res.GetString("StreamDoesNotSeek"));
			}
		}

		internal bool FlushEnabled
		{
			set
			{
				flushEnabled = value;
			}
		}

		internal BufferedResponseStream(Stream outputStream, int buffersize)
		{
			buffer = new byte[buffersize];
			this.outputStream = outputStream;
		}

		protected override void Dispose(bool disposing)
		{
			try
			{
				if (disposing)
				{
					outputStream.Close();
				}
			}
			finally
			{
				base.Dispose(disposing);
			}
		}

		public override void Flush()
		{
			if (flushEnabled)
			{
				FlushWrite();
			}
		}

		public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
		{
			throw new NotSupportedException(Res.GetString("StreamDoesNotRead"));
		}

		public override int EndRead(IAsyncResult asyncResult)
		{
			throw new NotSupportedException(Res.GetString("StreamDoesNotRead"));
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			throw new NotSupportedException(Res.GetString("StreamDoesNotSeek"));
		}

		public override void SetLength(long value)
		{
			throw new NotSupportedException(Res.GetString("StreamDoesNotSeek"));
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			throw new NotSupportedException(Res.GetString("StreamDoesNotRead"));
		}

		public override int ReadByte()
		{
			throw new NotSupportedException(Res.GetString("StreamDoesNotRead"));
		}

		public override void Write(byte[] array, int offset, int count)
		{
			if (position > 0)
			{
				int num = buffer.Length - position;
				if (num > 0)
				{
					if (num > count)
					{
						num = count;
					}
					Array.Copy(array, offset, buffer, position, num);
					position += num;
					if (count == num)
					{
						return;
					}
					offset += num;
					count -= num;
				}
				FlushWrite();
			}
			if (count >= buffer.Length)
			{
				outputStream.Write(array, offset, count);
				return;
			}
			Array.Copy(array, offset, buffer, position, count);
			position = count;
		}

		private void FlushWrite()
		{
			if (position > 0)
			{
				outputStream.Write(buffer, 0, position);
				position = 0;
			}
			outputStream.Flush();
		}

		public override void WriteByte(byte value)
		{
			if (position == buffer.Length)
			{
				FlushWrite();
			}
			buffer[position++] = value;
		}
	}
	internal class ClientTypeCache
	{
		private Hashtable cache = new Hashtable();

		internal object this[Type key] => cache[key];

		internal void Add(Type key, object value)
		{
			lock (this)
			{
				if (cache[key] == value)
				{
					return;
				}
				Hashtable hashtable = new Hashtable();
				foreach (object key2 in cache.Keys)
				{
					hashtable.Add(key2, cache[key2]);
				}
				cache = hashtable;
				cache[key] = value;
			}
		}
	}
	[ComVisible(true)]
	public abstract class WebClientProtocol : Component
	{
		private static AsyncCallback getRequestStreamAsyncCallback;

		private static AsyncCallback getResponseAsyncCallback;

		private static AsyncCallback readResponseAsyncCallback;

		private static ClientTypeCache cache;

		private static RequestCachePolicy bypassCache;

		private ICredentials credentials;

		private bool preAuthenticate;

		private Uri uri;

		private int timeout;

		private string connectionGroupName;

		private Encoding requestEncoding;

		private RemoteDebugger debugger;

		private WebRequest pendingSyncRequest;

		private object nullToken = new object();

		private Hashtable asyncInvokes = Hashtable.Synchronized(new Hashtable());

		private static object s_InternalSyncObject;

		internal static object InternalSyncObject
		{
			get
			{
				if (s_InternalSyncObject == null)
				{
					object value = new object();
					Interlocked.CompareExchange(ref s_InternalSyncObject, value, null);
				}
				return s_InternalSyncObject;
			}
		}

		internal static RequestCachePolicy BypassCache
		{
			get
			{
				if (bypassCache == null)
				{
					bypassCache = new RequestCachePolicy(RequestCacheLevel.BypassCache);
				}
				return bypassCache;
			}
		}

		public ICredentials Credentials
		{
			get
			{
				return credentials;
			}
			set
			{
				credentials = value;
			}
		}

		public bool UseDefaultCredentials
		{
			get
			{
				if (credentials != CredentialCache.DefaultCredentials)
				{
					return false;
				}
				return true;
			}
			set
			{
				credentials = (value ? CredentialCache.DefaultCredentials : null);
			}
		}

		[DefaultValue("")]
		public string ConnectionGroupName
		{
			get
			{
				if (connectionGroupName != null)
				{
					return connectionGroupName;
				}
				return string.Empty;
			}
			set
			{
				connectionGroupName = value;
			}
		}

		internal WebRequest PendingSyncRequest
		{
			get
			{
				return pendingSyncRequest;
			}
			set
			{
				pendingSyncRequest = value;
			}
		}

		[WebServicesDescription("ClientProtocolPreAuthenticate")]
		[DefaultValue(false)]
		public bool PreAuthenticate
		{
			get
			{
				return preAuthenticate;
			}
			set
			{
				preAuthenticate = value;
			}
		}

		[DefaultValue("")]
		[RecommendedAsConfigurable(true)]
		[WebServicesDescription("ClientProtocolUrl")]
		public string Url
		{
			get
			{
				if (!(uri == null))
				{
					return uri.ToString();
				}
				return string.Empty;
			}
			set
			{
				uri = new Uri(value);
			}
		}

		internal Hashtable AsyncInvokes => asyncInvokes;

		internal object NullToken => nullToken;

		internal Uri Uri
		{
			get
			{
				return uri;
			}
			set
			{
				uri = value;
			}
		}

		[WebServicesDescription("ClientProtocolEncoding")]
		[RecommendedAsConfigurable(true)]
		[DefaultValue(null)]
		public Encoding RequestEncoding
		{
			get
			{
				return requestEncoding;
			}
			set
			{
				requestEncoding = value;
			}
		}

		[DefaultValue(100000)]
		[WebServicesDescription("ClientProtocolTimeout")]
		[RecommendedAsConfigurable(true)]
		public int Timeout
		{
			get
			{
				return timeout;
			}
			set
			{
				timeout = ((value < -1) ? (-1) : value);
			}
		}

		static WebClientProtocol()
		{
			cache = new ClientTypeCache();
		}

		protected WebClientProtocol()
		{
			timeout = 100000;
		}

		internal WebClientProtocol(WebClientProtocol protocol)
		{
			credentials = protocol.credentials;
			uri = protocol.uri;
			timeout = protocol.timeout;
			connectionGroupName = protocol.connectionGroupName;
			requestEncoding = protocol.requestEncoding;
		}

		public virtual void Abort()
		{
			PendingSyncRequest?.Abort();
		}

		internal IAsyncResult BeginSend(Uri requestUri, WebClientAsyncResult asyncResult, bool callWriteAsyncRequest)
		{
			if (readResponseAsyncCallback == null)
			{
				lock (InternalSyncObject)
				{
					if (readResponseAsyncCallback == null)
					{
						getRequestStreamAsyncCallback = GetRequestStreamAsyncCallback;
						getResponseAsyncCallback = GetResponseAsyncCallback;
						readResponseAsyncCallback = ReadResponseAsyncCallback;
					}
				}
			}
			WebRequest webRequest = (asyncResult.Request = GetWebRequest(requestUri));
			InitializeAsyncRequest(webRequest, asyncResult.InternalAsyncState);
			if (callWriteAsyncRequest)
			{
				webRequest.BeginGetRequestStream(getRequestStreamAsyncCallback, asyncResult);
			}
			else
			{
				webRequest.BeginGetResponse(getResponseAsyncCallback, asyncResult);
			}
			if (!asyncResult.IsCompleted)
			{
				asyncResult.CombineCompletedSynchronously(innerCompletedSynchronously: false);
			}
			return asyncResult;
		}

		private static void ProcessAsyncException(WebClientAsyncResult client, Exception e, string method)
		{
			if (Tracing.On)
			{
				Tracing.ExceptionCatch(TraceEventType.Error, typeof(WebClientProtocol), method, e);
			}
			if (e is WebException ex && ex.Response != null)
			{
				client.Response = ex.Response;
				return;
			}
			if (client.IsCompleted)
			{
				throw new InvalidOperationException(Res.GetString("ThereWasAnErrorDuringAsyncProcessing"), e);
			}
			client.Complete(e);
		}

		private static void GetRequestStreamAsyncCallback(IAsyncResult asyncResult)
		{
			WebClientAsyncResult webClientAsyncResult = (WebClientAsyncResult)asyncResult.AsyncState;
			webClientAsyncResult.CombineCompletedSynchronously(asyncResult.CompletedSynchronously);
			bool flag = true;
			try
			{
				Stream stream = webClientAsyncResult.Request.EndGetRequestStream(asyncResult);
				flag = false;
				try
				{
					webClientAsyncResult.ClientProtocol.AsyncBufferedSerialize(webClientAsyncResult.Request, stream, webClientAsyncResult.InternalAsyncState);
				}
				finally
				{
					stream.Close();
				}
				webClientAsyncResult.Request.BeginGetResponse(getResponseAsyncCallback, webClientAsyncResult);
			}
			catch (Exception ex)
			{
				if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
				{
					throw;
				}
				ProcessAsyncException(webClientAsyncResult, ex, "GetRequestStreamAsyncCallback");
				if (flag && ex is WebException ex2 && ex2.Response != null)
				{
					webClientAsyncResult.Complete(ex);
				}
			}
			catch
			{
				ProcessAsyncException(webClientAsyncResult, new Exception(Res.GetString("NonClsCompliantException")), "GetRequestStreamAsyncCallback");
			}
		}

		private static void GetResponseAsyncCallback(IAsyncResult asyncResult)
		{
			WebClientAsyncResult webClientAsyncResult = (WebClientAsyncResult)asyncResult.AsyncState;
			webClientAsyncResult.CombineCompletedSynchronously(asyncResult.CompletedSynchronously);
			try
			{
				webClientAsyncResult.Response = webClientAsyncResult.ClientProtocol.GetWebResponse(webClientAsyncResult.Request, asyncResult);
			}
			catch (Exception ex)
			{
				if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
				{
					throw;
				}
				ProcessAsyncException(webClientAsyncResult, ex, "GetResponseAsyncCallback");
				if (webClientAsyncResult.Response == null)
				{
					return;
				}
			}
			catch
			{
				ProcessAsyncException(webClientAsyncResult, new Exception(Res.GetString("NonClsCompliantException")), "GetResponseAsyncCallback");
				if (webClientAsyncResult.Response == null)
				{
					return;
				}
			}
			ReadAsyncResponse(webClientAsyncResult);
		}

		private static void ReadAsyncResponse(WebClientAsyncResult client)
		{
			if (client.Response.ContentLength == 0)
			{
				client.Complete();
				return;
			}
			try
			{
				client.ResponseStream = client.Response.GetResponseStream();
				ReadAsyncResponseStream(client);
			}
			catch (Exception ex)
			{
				if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
				{
					throw;
				}
				ProcessAsyncException(client, ex, "ReadAsyncResponse");
			}
			catch
			{
				ProcessAsyncException(client, new Exception(Res.GetString("NonClsCompliantException")), "ReadAsyncResponse");
			}
		}

		private static void ReadAsyncResponseStream(WebClientAsyncResult client)
		{
			IAsyncResult asyncResult;
			do
			{
				byte[] array = client.Buffer;
				long contentLength = client.Response.ContentLength;
				if (array == null)
				{
					array = (client.Buffer = new byte[(contentLength == -1) ? 1024 : contentLength]);
				}
				else if (contentLength != -1 && contentLength > array.Length)
				{
					array = (client.Buffer = new byte[contentLength]);
				}
				asyncResult = client.ResponseStream.BeginRead(array, 0, array.Length, readResponseAsyncCallback, client);
			}
			while (asyncResult.CompletedSynchronously && !ProcessAsyncResponseStreamResult(client, asyncResult));
		}

		private static bool ProcessAsyncResponseStreamResult(WebClientAsyncResult client, IAsyncResult asyncResult)
		{
			int num = client.ResponseStream.EndRead(asyncResult);
			long contentLength = client.Response.ContentLength;
			bool flag;
			if (contentLength > 0 && num == contentLength)
			{
				client.ResponseBufferedStream = new MemoryStream(client.Buffer);
				flag = true;
			}
			else if (num > 0)
			{
				if (client.ResponseBufferedStream == null)
				{
					int capacity = (int)((contentLength == -1) ? client.Buffer.Length : contentLength);
					client.ResponseBufferedStream = new MemoryStream(capacity);
				}
				client.ResponseBufferedStream.Write(client.Buffer, 0, num);
				flag = false;
			}
			else
			{
				flag = true;
			}
			if (flag)
			{
				client.Complete();
			}
			return flag;
		}

		private static void ReadResponseAsyncCallback(IAsyncResult asyncResult)
		{
			WebClientAsyncResult webClientAsyncResult = (WebClientAsyncResult)asyncResult.AsyncState;
			webClientAsyncResult.CombineCompletedSynchronously(asyncResult.CompletedSynchronously);
			if (asyncResult.CompletedSynchronously)
			{
				return;
			}
			try
			{
				if (!ProcessAsyncResponseStreamResult(webClientAsyncResult, asyncResult))
				{
					ReadAsyncResponseStream(webClientAsyncResult);
				}
			}
			catch (Exception ex)
			{
				if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
				{
					throw;
				}
				ProcessAsyncException(webClientAsyncResult, ex, "ReadResponseAsyncCallback");
			}
			catch
			{
				ProcessAsyncException(webClientAsyncResult, new Exception(Res.GetString("NonClsCompliantException")), "ReadResponseAsyncCallback");
			}
		}

		internal void NotifyClientCallOut(WebRequest request)
		{
			if (RemoteDebugger.IsClientCallOutEnabled())
			{
				debugger = new RemoteDebugger();
				debugger.NotifyClientCallOut(request);
			}
			else
			{
				debugger = null;
			}
		}

		protected virtual WebRequest GetWebRequest(Uri uri)
		{
			if (uri == null)
			{
				throw new InvalidOperationException(Res.GetString("WebMissingPath"));
			}
			WebRequest webRequest2 = (PendingSyncRequest = WebRequest.Create(uri));
			webRequest2.Timeout = timeout;
			webRequest2.ConnectionGroupName = connectionGroupName;
			webRequest2.Credentials = Credentials;
			webRequest2.PreAuthenticate = PreAuthenticate;
			webRequest2.CachePolicy = BypassCache;
			return webRequest2;
		}

		protected virtual WebResponse GetWebResponse(WebRequest request)
		{
			TraceMethod caller = (Tracing.On ? new TraceMethod(this, "GetWebResponse") : null);
			WebResponse webResponse = null;
			try
			{
				if (Tracing.On)
				{
					Tracing.Enter("WebRequest.GetResponse", caller, new TraceMethod(request, "GetResponse"));
				}
				webResponse = request.GetResponse();
				if (Tracing.On)
				{
					Tracing.Exit("WebRequest.GetResponse", caller);
				}
			}
			catch (WebException ex)
			{
				if (ex.Response == null)
				{
					throw ex;
				}
				if (Tracing.On)
				{
					Tracing.ExceptionCatch(TraceEventType.Error, this, "GetWebResponse", ex);
				}
				webResponse = ex.Response;
			}
			finally
			{
				if (debugger != null)
				{
					debugger.NotifyClientCallReturn(webResponse);
				}
			}
			return webResponse;
		}

		protected virtual WebResponse GetWebResponse(WebRequest request, IAsyncResult result)
		{
			WebResponse webResponse = request.EndGetResponse(result);
			if (webResponse != null && debugger != null)
			{
				debugger.NotifyClientCallReturn(webResponse);
			}
			return webResponse;
		}

		[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
		internal virtual void InitializeAsyncRequest(WebRequest request, object internalAsyncState)
		{
		}

		[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
		internal virtual void AsyncBufferedSerialize(WebRequest request, Stream requestStream, object internalAsyncState)
		{
			throw new NotSupportedException(Res.GetString("ProtocolDoesNotAsyncSerialize"));
		}

		internal WebResponse EndSend(IAsyncResult asyncResult, ref object internalAsyncState, ref Stream responseStream)
		{
			if (asyncResult == null)
			{
				throw new ArgumentNullException(Res.GetString("WebNullAsyncResultInEnd"));
			}
			WebClientAsyncResult webClientAsyncResult = (WebClientAsyncResult)asyncResult;
			if (webClientAsyncResult.EndSendCalled)
			{
				throw new InvalidOperationException(Res.GetString("CanTCallTheEndMethodOfAnAsyncCallMoreThan"));
			}
			webClientAsyncResult.EndSendCalled = true;
			WebResponse result = webClientAsyncResult.WaitForResponse();
			internalAsyncState = webClientAsyncResult.InternalAsyncState;
			responseStream = webClientAsyncResult.ResponseBufferedStream;
			return result;
		}

		protected static object GetFromCache(Type type)
		{
			return cache[type];
		}

		protected static void AddToCache(Type type, object value)
		{
			cache.Add(type, value);
		}
	}
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	public class WebClientAsyncResult : IAsyncResult
	{
		private object userAsyncState;

		private bool completedSynchronously;

		private bool isCompleted;

		private ManualResetEvent manualResetEvent;

		private AsyncCallback userCallback;

		internal WebClientProtocol ClientProtocol;

		internal object InternalAsyncState;

		internal Exception Exception;

		internal WebResponse Response;

		internal WebRequest Request;

		internal Stream ResponseStream;

		internal Stream ResponseBufferedStream;

		internal byte[] Buffer;

		internal bool EndSendCalled;

		public object AsyncState => userAsyncState;

		public WaitHandle AsyncWaitHandle
		{
			get
			{
				bool flag = isCompleted;
				if (manualResetEvent == null)
				{
					lock (this)
					{
						if (manualResetEvent == null)
						{
							manualResetEvent = new ManualResetEvent(flag);
						}
					}
				}
				if (!flag && isCompleted)
				{
					manualResetEvent.Set();
				}
				return manualResetEvent;
			}
		}

		public bool CompletedSynchronously => completedSynchronously;

		public bool IsCompleted => isCompleted;

		internal WebClientAsyncResult(WebClientProtocol clientProtocol, object internalAsyncState, WebRequest request, AsyncCallback userCallback, object userAsyncState)
		{
			ClientProtocol = clientProtocol;
			InternalAsyncState = internalAsyncState;
			this.userAsyncState = userAsyncState;
			this.userCallback = userCallback;
			Request = request;
			completedSynchronously = true;
		}

		public void Abort()
		{
			Request?.Abort();
		}

		internal void Complete()
		{
			try
			{
				if (ResponseStream != null)
				{
					ResponseStream.Close();
					ResponseStream = null;
				}
				if (ResponseBufferedStream != null)
				{
					ResponseBufferedStream.Position = 0L;
				}
			}
			catch (Exception ex)
			{
				if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
				{
					throw;
				}
				if (Exception == null)
				{
					Exception = ex;
				}
				if (Tracing.On)
				{
					Tracing.ExceptionCatch(TraceEventType.Error, this, "Complete", ex);
				}
			}
			catch
			{
				if (Exception == null)
				{
					Exception = new Exception(Res.GetString("NonClsCompliantException"));
				}
			}
			isCompleted = true;
			try
			{
				if (manualResetEvent != null)
				{
					manualResetEvent.Set();
				}
			}
			catch (Exception ex2)
			{
				if (ex2 is ThreadAbortException || ex2 is StackOverflowException || ex2 is OutOfMemoryException)
				{
					throw;
				}
				if (Exception == null)
				{
					Exception = ex2;
				}
				if (Tracing.On)
				{
					Tracing.ExceptionCatch(TraceEventType.Error, this, "Complete", ex2);
				}
			}
			catch
			{
				if (Exception == null)
				{
					Exception = new Exception(Res.GetString("NonClsCompliantException"));
				}
			}
			if (userCallback != null)
			{
				userCallback(this);
			}
		}

		internal void Complete(Exception e)
		{
			Exception = e;
			Complete();
		}

		internal WebResponse WaitForResponse()
		{
			if (!isCompleted)
			{
				AsyncWaitHandle.WaitOne();
			}
			if (Exception != null)
			{
				throw Exception;
			}
			return Response;
		}

		internal void CombineCompletedSynchronously(bool innerCompletedSynchronously)
		{
			completedSynchronously = completedSynchronously && innerCompletedSynchronously;
		}
	}
	public delegate void InvokeCompletedEventHandler(object sender, InvokeCompletedEventArgs e);
	public class InvokeCompletedEventArgs : AsyncCompletedEventArgs
	{
		private object[] results;

		public object[] Results => results;

		internal InvokeCompletedEventArgs(object[] results, Exception exception, bool cancelled, object userState)
			: base(exception, cancelled, userState)
		{
			this.results = results;
		}
	}
	internal class UserToken
	{
		private SendOrPostCallback callback;

		private object userState;

		internal SendOrPostCallback Callback => callback;

		internal object UserState => userState;

		internal UserToken(SendOrPostCallback callback, object userState)
		{
			this.callback = callback;
			this.userState = userState;
		}
	}
	[ComVisible(true)]
	public abstract class HttpWebClientProtocol : WebClientProtocol
	{
		private bool allowAutoRedirect;

		private bool enableDecompression;

		private CookieContainer cookieJar;

		private X509CertificateCollection clientCertificates;

		private IWebProxy proxy;

		private static string UserAgentDefault = "Mozilla/4.0 (compatible; MSIE 6.0; MS Web Services Client Protocol " + Environment.Version.ToString() + ")";

		private string userAgent;

		private bool unsafeAuthenticatedConnectionSharing;

		[WebServicesDescription("ClientProtocolAllowAutoRedirect")]
		[DefaultValue(false)]
		public bool AllowAutoRedirect
		{
			get
			{
				return allowAutoRedirect;
			}
			set
			{
				allowAutoRedirect = value;
			}
		}

		[WebServicesDescription("ClientProtocolCookieContainer")]
		[DefaultValue(null)]
		public CookieContainer CookieContainer
		{
			get
			{
				return cookieJar;
			}
			set
			{
				cookieJar = value;
			}
		}

		[Browsable(false)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[WebServicesDescription("ClientProtocolClientCertificates")]
		public X509CertificateCollection ClientCertificates
		{
			get
			{
				if (clientCertificates == null)
				{
					clientCertificates = new X509CertificateCollection();
				}
				return clientCertificates;
			}
		}

		[DefaultValue(false)]
		[WebServicesDescription("ClientProtocolEnableDecompression")]
		public bool EnableDecompression
		{
			get
			{
				return enableDecompression;
			}
			set
			{
				enableDecompression = value;
			}
		}

		[Browsable(false)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[WebServicesDescription("ClientProtocolUserAgent")]
		public string UserAgent
		{
			get
			{
				if (userAgent != null)
				{
					return userAgent;
				}
				return string.Empty;
			}
			set
			{
				userAgent = value;
			}
		}

		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
		public IWebProxy Proxy
		{
			get
			{
				return proxy;
			}
			set
			{
				proxy = value;
			}
		}

		[Browsable(false)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public bool UnsafeAuthenticatedConnectionSharing
		{
			get
			{
				return unsafeAuthenticatedConnectionSharing;
			}
			set
			{
				unsafeAuthenticatedConnectionSharing = value;
			}
		}

		protected HttpWebClientProtocol()
		{
			allowAutoRedirect = false;
			userAgent = UserAgentDefault;
		}

		internal HttpWebClientProtocol(HttpWebClientProtocol protocol)
			: base(protocol)
		{
			allowAutoRedirect = protocol.allowAutoRedirect;
			enableDecompression = protocol.enableDecompression;
			cookieJar = protocol.cookieJar;
			clientCertificates = protocol.clientCertificates;
			proxy = protocol.proxy;
			userAgent = protocol.userAgent;
		}

		protected override WebRequest GetWebRequest(Uri uri)
		{
			WebRequest webRequest = base.GetWebRequest(uri);
			if (webRequest is HttpWebRequest httpWebRequest)
			{
				httpWebRequest.UserAgent = UserAgent;
				httpWebRequest.AllowAutoRedirect = allowAutoRedirect;
				httpWebRequest.AutomaticDecompression = (enableDecompression ? DecompressionMethods.GZip : DecompressionMethods.None);
				httpWebRequest.AllowWriteStreamBuffering = true;
				httpWebRequest.SendChunked = false;
				if (unsafeAuthenticatedConnectionSharing != httpWebRequest.UnsafeAuthenticatedConnectionSharing)
				{
					httpWebRequest.UnsafeAuthenticatedConnectionSharing = unsafeAuthenticatedConnectionSharing;
				}
				if (proxy != null)
				{
					httpWebRequest.Proxy = proxy;
				}
				if (clientCertificates != null && clientCertificates.Count > 0)
				{
					httpWebRequest.ClientCertificates.AddRange(clientCertificates);
				}
				httpWebRequest.CookieContainer = cookieJar;
			}
			return webRequest;
		}

		protected override WebResponse GetWebResponse(WebRequest request)
		{
			return base.GetWebResponse(request);
		}

		protected override WebResponse GetWebResponse(WebRequest request, IAsyncResult result)
		{
			return base.GetWebResponse(request, result);
		}

		protected void CancelAsync(object userState)
		{
			if (userState == null)
			{
				userState = base.NullToken;
			}
			object userState2 = userState;
			object[] parameters = new object[1];
			OperationCompleted(userState2, parameters, null, canceled: true)?.Abort();
		}

		internal WebClientAsyncResult OperationCompleted(object userState, object[] parameters, Exception e, bool canceled)
		{
			WebClientAsyncResult webClientAsyncResult = (WebClientAsyncResult)base.AsyncInvokes[userState];
			if (webClientAsyncResult != null)
			{
				AsyncOperation asyncOperation = (AsyncOperation)webClientAsyncResult.AsyncState;
				UserToken userToken = (UserToken)asyncOperation.UserSuppliedState;
				InvokeCompletedEventArgs arg = new InvokeCompletedEventArgs(parameters, e, canceled, userState);
				base.AsyncInvokes.Remove(userState);
				asyncOperation.PostOperationCompleted(userToken.Callback, arg);
			}
			return webClientAsyncResult;
		}

		public static bool GenerateXmlMappings(Type type, ArrayList mappings)
		{
			if (typeof(SoapHttpClientProtocol).IsAssignableFrom(type))
			{
				WebServiceBindingAttribute attribute = WebServiceBindingReflector.GetAttribute(type);
				if (attribute == null)
				{
					throw new InvalidOperationException(Res.GetString("WebClientBindingAttributeRequired"));
				}
				string @namespace = attribute.Namespace;
				bool serviceDefaultIsEncoded = SoapReflector.ServiceDefaultIsEncoded(type);
				ArrayList soapMethodList = new ArrayList();
				SoapClientType.GenerateXmlMappings(type, soapMethodList, @namespace, serviceDefaultIsEncoded, mappings);
				return true;
			}
			return false;
		}

		public static Hashtable GenerateXmlMappings(Type[] types, ArrayList mappings)
		{
			if (types == null)
			{
				throw new ArgumentNullException("types");
			}
			Hashtable hashtable = new Hashtable();
			foreach (Type type in types)
			{
				ArrayList value = new ArrayList();
				if (GenerateXmlMappings(type, mappings))
				{
					hashtable.Add(type, value);
					mappings.Add(value);
				}
			}
			return hashtable;
		}
	}
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	public class ServerType
	{
		private Type type;

		internal Type Type => type;

		internal Evidence Evidence
		{
			get
			{
				new SecurityPermission(SecurityPermissionFlag.ControlEvidence).Assert();
				return Type.Assembly.Evidence;
			}
		}

		public ServerType(Type type)
		{
			this.type = type;
		}
	}
	internal class DiscoveryServerType : ServerType
	{
		private ServiceDescription description;

		private LogicalMethodInfo methodInfo;

		private Hashtable schemaTable = new Hashtable();

		private Hashtable wsdlTable = new Hashtable();

		private DiscoveryDocument discoDoc;

		internal ServiceDescription Description => description;

		internal LogicalMethodInfo MethodInfo => methodInfo;

		internal DiscoveryDocument Disco => discoDoc;

		internal DiscoveryServerType(Type type, string uri)
			: base(typeof(DiscoveryServerProtocol))
		{
			Uri uri2 = new Uri(uri, dontEscape: true);
			uri = uri2.GetLeftPart(UriPartial.Path);
			methodInfo = new LogicalMethodInfo(typeof(DiscoveryServerProtocol).GetMethod("Discover", BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic));
			ServiceDescriptionReflector serviceDescriptionReflector = new ServiceDescriptionReflector();
			serviceDescriptionReflector.Reflect(type, uri);
			XmlSchemas schemas = serviceDescriptionReflector.Schemas;
			description = serviceDescriptionReflector.ServiceDescription;
			_ = ServiceDescription.Serializer;
			AddSchemaImports(schemas, uri, serviceDescriptionReflector.ServiceDescriptions);
			for (int i = 1; i < serviceDescriptionReflector.ServiceDescriptions.Count; i++)
			{
				ServiceDescription serviceDescription = serviceDescriptionReflector.ServiceDescriptions[i];
				Import import = new Import
				{
					Namespace = serviceDescription.TargetNamespace
				};
				string text = "wsdl" + i.ToString(CultureInfo.InvariantCulture);
				import.Location = uri + "?wsdl=" + text;
				serviceDescriptionReflector.ServiceDescription.Imports.Add(import);
				wsdlTable.Add(text, serviceDescription);
			}
			discoDoc = new DiscoveryDocument();
			discoDoc.References.Add(new ContractReference(uri + "?wsdl", uri));
			foreach (Service service in serviceDescriptionReflector.ServiceDescription.Services)
			{
				foreach (Port port in service.Ports)
				{
					SoapAddressBinding soapAddressBinding = (SoapAddressBinding)port.Extensions.Find(typeof(SoapAddressBinding));
					if (soapAddressBinding != null)
					{
						System.Web.Services.Discovery.SoapBinding value = new System.Web.Services.Discovery.SoapBinding
						{
							Binding = port.Binding,
							Address = soapAddressBinding.Location
						};
						discoDoc.References.Add(value);
					}
				}
			}
		}

		internal void AddExternal(XmlSchema schema, string ns, string location)
		{
			if (schema != null)
			{
				if (schema.TargetNamespace == ns)
				{
					XmlSchemaInclude xmlSchemaInclude = new XmlSchemaInclude();
					xmlSchemaInclude.SchemaLocation = location;
					schema.Includes.Add(xmlSchemaInclude);
				}
				else
				{
					XmlSchemaImport xmlSchemaImport = new XmlSchemaImport();
					xmlSchemaImport.SchemaLocation = location;
					xmlSchemaImport.Namespace = ns;
					schema.Includes.Add(xmlSchemaImport);
				}
			}
		}

		private void AddSchemaImports(XmlSchemas schemas, string uri, ServiceDescriptionCollection descriptions)
		{
			int num = 0;
			foreach (XmlSchema schema in schemas)
			{
				if (schema == null)
				{
					continue;
				}
				if (schema.Id == null || schema.Id.Length == 0)
				{
					int num2 = ++num;
					schema.Id = "schema" + num2.ToString(CultureInfo.InvariantCulture);
				}
				string location = uri + "?schema=" + schema.Id;
				foreach (ServiceDescription description in descriptions)
				{
					if (description.Types.Schemas.Count == 0)
					{
						XmlSchema xmlSchema2 = new XmlSchema();
						xmlSchema2.TargetNamespace = description.TargetNamespace;
						schema.ElementFormDefault = XmlSchemaForm.Qualified;
						AddExternal(xmlSchema2, schema.TargetNamespace, location);
						description.Types.Schemas.Add(xmlSchema2);
					}
					else
					{
						AddExternal(description.Types.Schemas[0], schema.TargetNamespace, location);
					}
				}
				schemaTable.Add(schema.Id, schema);
			}
		}

		internal XmlSchema GetSchema(string id)
		{
			return (XmlSchema)schemaTable[id];
		}

		internal ServiceDescription GetServiceDescription(string id)
		{
			return (ServiceDescription)wsdlTable[id];
		}
	}
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	public abstract class ServerProtocolFactory
	{
		internal ServerProtocol Create(Type type, HttpContext context, HttpRequest request, HttpResponse response, out bool abortProcessing)
		{
			ServerProtocol serverProtocol = null;
			abortProcessing = false;
			serverProtocol = CreateIfRequestCompatible(request);
			try
			{
				serverProtocol?.SetContext(type, context, request, response);
				return serverProtocol;
			}
			catch (Exception ex)
			{
				abortProcessing = true;
				if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
				{
					throw;
				}
				if (Tracing.On)
				{
					Tracing.ExceptionCatch(TraceEventType.Warning, this, "Create", ex);
				}
				if (serverProtocol != null && !serverProtocol.WriteException(ex, serverProtocol.Response.OutputStream))
				{
					throw new InvalidOperationException(Res.GetString("UnableToHandleRequest0"), ex);
				}
				return null;
			}
			catch
			{
				abortProcessing = true;
				if (serverProtocol != null && !serverProtocol.WriteException(new Exception(Res.GetString("NonClsCompliantException")), serverProtocol.Response.OutputStream))
				{
					throw new InvalidOperationException(Res.GetString("UnableToHandleRequest0"), null);
				}
				return null;
			}
		}

		protected abstract ServerProtocol CreateIfRequestCompatible(HttpRequest request);
	}
	internal class DiscoveryServerProtocolFactory : ServerProtocolFactory
	{
		protected override ServerProtocol CreateIfRequestCompatible(HttpRequest request)
		{
			if (request.PathInfo.Length > 0)
			{
				return null;
			}
			if (request.HttpMethod != "GET")
			{
				return new UnsupportedRequestProtocol(405);
			}
			string text = request.QueryString[null];
			if (text == null)
			{
				text = "";
			}
			if (request.QueryString["schema"] == null && request.QueryString["wsdl"] == null && string.Compare(text, "wsdl", StringComparison.OrdinalIgnoreCase) != 0 && string.Compare(text, "disco", StringComparison.OrdinalIgnoreCase) != 0)
			{
				return null;
			}
			return new DiscoveryServerProtocol();
		}
	}
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	public abstract class ServerProtocol
	{
		private Type type;

		private HttpRequest request;

		private HttpResponse response;

		private HttpContext context;

		private object target;

		private WebMethodAttribute methodAttr;

		private static object s_InternalSyncObject;

		internal static object InternalSyncObject
		{
			get
			{
				if (s_InternalSyncObject == null)
				{
					object value = new object();
					Interlocked.CompareExchange(ref s_InternalSyncObject, value, null);
				}
				return s_InternalSyncObject;
			}
		}

		protected internal HttpContext Context => context;

		protected internal HttpRequest Request => request;

		protected internal HttpResponse Response => response;

		internal Type Type => type;

		protected internal virtual object Target => target;

		internal abstract LogicalMethodInfo MethodInfo { get; }

		internal abstract ServerType ServerType { get; }

		internal abstract bool IsOneWay { get; }

		internal virtual Exception OnewayInitException => null;

		internal WebMethodAttribute MethodAttribute
		{
			get
			{
				if (methodAttr == null)
				{
					methodAttr = MethodInfo.MethodAttribute;
				}
				return methodAttr;
			}
		}

		internal void SetContext(Type type, HttpContext context, HttpRequest request, HttpResponse response)
		{
			this.type = type;
			this.context = context;
			this.request = request;
			this.response = response;
			Initialize();
		}

		internal virtual void CreateServerInstance()
		{
			target = Activator.CreateInstance(ServerType.Type);
			if (target is WebService webService)
			{
				webService.SetContext(context);
			}
		}

		internal virtual void DisposeServerInstance()
		{
			if (target != null)
			{
				if (target is IDisposable disposable)
				{
					disposable.Dispose();
				}
				target = null;
			}
		}

		internal virtual bool WriteException(Exception e, Stream outputStream)
		{
			return false;
		}

		internal abstract bool Initialize();

		internal abstract object[] ReadParameters();

		internal abstract void WriteReturns(object[] returns, Stream outputStream);

		internal string GenerateFaultString(Exception e)
		{
			return GenerateFaultString(e, htmlEscapeMessage: false);
		}

		internal static void SetHttpResponseStatusCode(HttpResponse httpResponse, int statusCode)
		{
			httpResponse.TrySkipIisCustomErrors = true;
			httpResponse.StatusCode = statusCode;
		}

		internal string GenerateFaultString(Exception e, bool htmlEscapeMessage)
		{
			bool flag = Context != null && !Context.IsCustomErrorEnabled;
			if (flag && !htmlEscapeMessage)
			{
				return e.ToString();
			}
			StringBuilder stringBuilder = new StringBuilder();
			if (flag)
			{
				GenerateFaultString(e, stringBuilder);
			}
			else
			{
				for (Exception ex = e; ex != null; ex = ex.InnerException)
				{
					string text = (htmlEscapeMessage ? HttpUtility.HtmlEncode(ex.Message) : ex.Message);
					if (text.Length == 0)
					{
						text = e.GetType().Name;
					}
					stringBuilder.Append(text);
					if (ex.InnerException != null)
					{
						stringBuilder.Append(" ---> ");
					}
				}
			}
			return stringBuilder.ToString();
		}

		private static void GenerateFaultString(Exception e, StringBuilder builder)
		{
			builder.Append(e.GetType().FullName);
			if (e.Message != null && e.Message.Length > 0)
			{
				builder.Append(": ");
				builder.Append(HttpUtility.HtmlEncode(e.Message));
			}
			if (e.InnerException != null)
			{
				builder.Append(" ---> ");
				GenerateFaultString(e.InnerException, builder);
				builder.Append(Environment.NewLine);
				builder.Append("   ");
				builder.Append(Res.GetString("StackTraceEnd"));
			}
			if (e.StackTrace != null)
			{
				builder.Append(Environment.NewLine);
				builder.Append(e.StackTrace);
			}
		}

		internal void WriteOneWayResponse()
		{
			context.Response.ContentType = null;
			Response.StatusCode = 202;
		}

		private string CreateKey(Type protocolType, Type serverType)
		{
			string fullName = protocolType.FullName;
			string fullName2 = serverType.FullName;
			string text = serverType.TypeHandle.Value.ToString();
			string urlKeyComponent = GetUrlKeyComponent();
			int capacity = fullName.Length + urlKeyComponent.Length + fullName2.Length + text.Length + 2;
			StringBuilder stringBuilder = new StringBuilder(capacity);
			stringBuilder.Append(fullName);
			stringBuilder.Append('[');
			stringBuilder.Append(urlKeyComponent);
			stringBuilder.Append(']');
			stringBuilder.Append(fullName2);
			stringBuilder.Append(text);
			return stringBuilder.ToString();
		}

		internal virtual string GetUrlKeyComponent()
		{
			return Request.Url.GetLeftPart(UriPartial.Path);
		}

		protected void AddToCache(Type protocolType, Type serverType, object value)
		{
			HttpRuntime.Cache.Insert(CreateKey(protocolType, serverType), value, null, Cache.NoAbsoluteExpiration, Cache.NoSlidingExpiration, CacheItemPriority.NotRemovable, null);
		}

		protected object GetFromCache(Type protocolType, Type serverType)
		{
			return HttpRuntime.Cache.Get(CreateKey(protocolType, serverType));
		}
	}
	internal sealed class DiscoveryServerProtocol : ServerProtocol
	{
		private DiscoveryServerType serverType;

		internal override ServerType ServerType => serverType;

		internal override bool IsOneWay => false;

		internal override LogicalMethodInfo MethodInfo => serverType.MethodInfo;

		internal override bool Initialize()
		{
			serverType = (DiscoveryServerType)GetFromCache(typeof(DiscoveryServerProtocol), base.Type);
			if (serverType == null)
			{
				lock (ServerProtocol.InternalSyncObject)
				{
					serverType = (DiscoveryServerType)GetFromCache(typeof(DiscoveryServerProtocol), base.Type);
					if (serverType == null)
					{
						string uri = base.Request.Url.GetComponents(UriComponents.AbsoluteUri, UriFormat.UriEscaped).Replace("#", "%23");
						serverType = new DiscoveryServerType(base.Type, uri);
						AddToCache(typeof(DiscoveryServerProtocol), base.Type, serverType);
					}
				}
			}
			return true;
		}

		internal override object[] ReadParameters()
		{
			return new object[0];
		}

		internal override void WriteReturns(object[] returnValues, Stream outputStream)
		{
			string text = base.Request.QueryString["schema"];
			Encoding encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);
			if (text != null)
			{
				XmlSchema schema = serverType.GetSchema(text);
				if (schema == null)
				{
					throw new InvalidOperationException(Res.GetString("WebSchemaNotFound"));
				}
				base.Response.ContentType = ContentType.Compose("text/xml", encoding);
				schema.Write(new StreamWriter(outputStream, encoding));
				return;
			}
			text = base.Request.QueryString["wsdl"];
			if (text != null)
			{
				ServiceDescription serviceDescription = serverType.GetServiceDescription(text);
				if (serviceDescription == null)
				{
					throw new InvalidOperationException(Res.GetString("ServiceDescriptionWasNotFound0"));
				}
				base.Response.ContentType = ContentType.Compose("text/xml", encoding);
				serviceDescription.Write(new StreamWriter(outputStream, encoding));
				return;
			}
			string text2 = base.Request.QueryString[null];
			if (text2 != null && string.Compare(text2, "wsdl", StringComparison.OrdinalIgnoreCase) == 0)
			{
				base.Response.ContentType = ContentType.Compose("text/xml", encoding);
				serverType.Description.Write(new StreamWriter(outputStream, encoding));
				return;
			}
			if (text2 != null && string.Compare(text2, "disco", StringComparison.OrdinalIgnoreCase) == 0)
			{
				base.Response.ContentType = ContentType.Compose("text/xml", encoding);
				serverType.Disco.Write(new StreamWriter(outputStream, encoding));
				return;
			}
			throw new InvalidOperationException(Res.GetString("internalError0"));
		}

		internal override bool WriteException(Exception e, Stream outputStream)
		{
			base.Response.Clear();
			base.Response.ClearHeaders();
			base.Response.ContentType = ContentType.Compose("text/plain", Encoding.UTF8);
			base.Response.StatusCode = 500;
			base.Response.StatusDescription = HttpWorkerRequest.GetStatusDescription(base.Response.StatusCode);
			StreamWriter streamWriter = new StreamWriter(outputStream, new UTF8Encoding(encoderShouldEmitUTF8Identifier: false));
			streamWriter.WriteLine(GenerateFaultString(e, htmlEscapeMessage: true));
			streamWriter.Flush();
			return true;
		}

		internal void Discover()
		{
		}
	}
	internal class DocumentationServerType : ServerType
	{
		private ServiceDescriptionCollection serviceDescriptions;

		private ServiceDescriptionCollection serviceDescriptionsWithPost;

		private XmlSchemas schemas;

		private XmlSchemas schemasWithPost;

		private LogicalMethodInfo methodInfo;

		internal LogicalMethodInfo MethodInfo => methodInfo;

		internal XmlSchemas Schemas => schemas;

		internal ServiceDescriptionCollection ServiceDescriptions => serviceDescriptions;

		internal ServiceDescriptionCollection ServiceDescriptionsWithPost => serviceDescriptionsWithPost;

		internal XmlSchemas SchemasWithPost => schemasWithPost;

		internal DocumentationServerType(Type type, string uri)
			: base(typeof(DocumentationServerProtocol))
		{
			Uri uri2 = new Uri(uri, dontEscape: true);
			uri = uri2.GetLeftPart(UriPartial.Path);
			methodInfo = new LogicalMethodInfo(typeof(DocumentationServerProtocol).GetMethod("Documentation", BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic));
			ServiceDescriptionReflector serviceDescriptionReflector = new ServiceDescriptionReflector();
			serviceDescriptionReflector.Reflect(type, uri);
			schemas = serviceDescriptionReflector.Schemas;
			serviceDescriptions = serviceDescriptionReflector.ServiceDescriptions;
			schemasWithPost = serviceDescriptionReflector.SchemasWithPost;
			serviceDescriptionsWithPost = serviceDescriptionReflector.ServiceDescriptionsWithPost;
		}
	}
	internal class DocumentationServerProtocolFactory : ServerProtocolFactory
	{
		protected override ServerProtocol CreateIfRequestCompatible(HttpRequest request)
		{
			if (request.PathInfo.Length > 0)
			{
				return null;
			}
			if (request.HttpMethod != "GET")
			{
				return new UnsupportedRequestProtocol(405);
			}
			return new DocumentationServerProtocol();
		}
	}
	internal sealed class DocumentationServerProtocol : ServerProtocol
	{
		private const int MAX_PATH_SIZE = 1024;

		private DocumentationServerType serverType;

		private IHttpHandler handler;

		internal override ServerType ServerType => serverType;

		internal override bool IsOneWay => false;

		internal override LogicalMethodInfo MethodInfo => serverType.MethodInfo;

		internal override bool Initialize()
		{
			serverType = (DocumentationServerType)GetFromCache(typeof(DocumentationServerProtocol), base.Type);
			if (serverType == null)
			{
				lock (ServerProtocol.InternalSyncObject)
				{
					serverType = (DocumentationServerType)GetFromCache(typeof(DocumentationServerProtocol), base.Type);
					if (serverType == null)
					{
						string uri = base.Request.Url.GetComponents(UriComponents.AbsoluteUri, UriFormat.UriEscaped).Replace("#", "%23");
						serverType = new DocumentationServerType(base.Type, uri);
						AddToCache(typeof(DocumentationServerProtocol), base.Type, serverType);
					}
				}
			}
			WebServicesSection current = WebServicesSection.Current;
			if (current.WsdlHelpGenerator.Href != null && current.WsdlHelpGenerator.Href.Length > 0)
			{
				TraceMethod caller = (Tracing.On ? new TraceMethod(this, "Initialize") : null);
				if (Tracing.On)
				{
					Tracing.Enter("ASP.NET", caller, new TraceMethod(typeof(PageParser), "GetCompiledPageInstance", current.WsdlHelpGenerator.HelpGeneratorVirtualPath, current.WsdlHelpGenerator.HelpGeneratorPath, base.Context));
				}
				handler = PageParser.GetCompiledPageInstance(current.WsdlHelpGenerator.HelpGeneratorVirtualPath, current.WsdlHelpGenerator.HelpGeneratorPath, base.Context);
				if (Tracing.On)
				{
					Tracing.Exit("ASP.NET", caller);
				}
			}
			return true;
		}

		internal override object[] ReadParameters()
		{
			return new object[0];
		}

		internal override void WriteReturns(object[] returnValues, Stream outputStream)
		{
			try
			{
				if (handler != null)
				{
					base.Context.Items.Add("wsdls", serverType.ServiceDescriptions);
					base.Context.Items.Add("schemas", serverType.Schemas);
					string text = base.Context.Request.ServerVariables["LOCAL_ADDR"];
					string text2 = base.Context.Request.ServerVariables["REMOTE_ADDR"];
					if (base.Context.Request.Url.IsLoopback || (text != null && text2 != null && text == text2))
					{
						base.Context.Items.Add("wsdlsWithPost", serverType.ServiceDescriptionsWithPost);
						base.Context.Items.Add("schemasWithPost", serverType.SchemasWithPost);
					}
					base.Context.Items.Add("conformanceWarnings", WebServicesSection.Current.EnabledConformanceWarnings);
					base.Response.ContentType = "text/html";
					handler.ProcessRequest(base.Context);
				}
			}
			catch (Exception ex)
			{
				if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
				{
					throw;
				}
				throw new InvalidOperationException(Res.GetString("HelpGeneratorInternalError"), ex);
			}
			catch
			{
				throw new InvalidOperationException(Res.GetString("HelpGeneratorInternalError"), null);
			}
		}

		internal override bool WriteException(Exception e, Stream outputStream)
		{
			return false;
		}

		internal void Documentation()
		{
		}
	}
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	public abstract class MimeParameterReader : MimeFormatter
	{
		public abstract object[] Read(HttpRequest request);
	}
	public abstract class ValueCollectionParameterReader : MimeParameterReader
	{
		private ParameterInfo[] paramInfos;

		public override void Initialize(object o)
		{
			paramInfos = (ParameterInfo[])o;
		}

		public override object GetInitializer(LogicalMethodInfo methodInfo)
		{
			if (!IsSupported(methodInfo))
			{
				return null;
			}
			return methodInfo.InParameters;
		}

		protected object[] Read(NameValueCollection collection)
		{
			object[] array = new object[paramInfos.Length];
			for (int i = 0; i < paramInfos.Length; i++)
			{
				ParameterInfo parameterInfo = paramInfos[i];
				if (parameterInfo.ParameterType.IsArray)
				{
					string[] values = collection.GetValues(parameterInfo.Name);
					Type elementType = parameterInfo.ParameterType.GetElementType();
					Array array2 = Array.CreateInstance(elementType, values.Length);
					for (int j = 0; j < values.Length; j++)
					{
						string value = values[j];
						array2.SetValue(ScalarFormatter.FromString(value, elementType), j);
					}
					array[i] = array2;
				}
				else
				{
					string text = collection[parameterInfo.Name];
					if (text == null)
					{
						throw new InvalidOperationException(Res.GetString("WebMissingParameter", parameterInfo.Name));
					}
					array[i] = ScalarFormatter.FromString(text, parameterInfo.ParameterType);
				}
			}
			return array;
		}

		public static bool IsSupported(LogicalMethodInfo methodInfo)
		{
			if (methodInfo.OutParameters.Length > 0)
			{
				return false;
			}
			ParameterInfo[] inParameters = methodInfo.InParameters;
			for (int i = 0; i < inParameters.Length; i++)
			{
				if (!IsSupported(inParameters[i]))
				{
					return false;
				}
			}
			return true;
		}

		public static bool IsSupported(ParameterInfo paramInfo)
		{
			Type type = paramInfo.ParameterType;
			if (type.IsArray)
			{
				type = type.GetElementType();
			}
			return ScalarFormatter.IsTypeSupported(type);
		}
	}
	public class HtmlFormParameterReader : ValueCollectionParameterReader
	{
		internal const string MimeType = "application/x-www-form-urlencoded";

		public override object[] Read(HttpRequest request)
		{
			if (!ContentType.MatchesBase(request.ContentType, "application/x-www-form-urlencoded"))
			{
				return null;
			}
			return Read(request.Form);
		}
	}
	public abstract class MimeParameterWriter : MimeFormatter
	{
		public virtual bool UsesWriteRequest => false;

		public virtual Encoding RequestEncoding
		{
			get
			{
				return null;
			}
			set
			{
			}
		}

		public virtual string GetRequestUrl(string url, object[] parameters)
		{
			return url;
		}

		public virtual void InitializeRequest(WebRequest request, object[] values)
		{
		}

		public virtual void WriteRequest(Stream requestStream, object[] values)
		{
		}
	}
	public abstract class UrlEncodedParameterWriter : MimeParameterWriter
	{
		private ParameterInfo[] paramInfos;

		private int numberEncoded;

		private Encoding encoding;

		public override Encoding RequestEncoding
		{
			get
			{
				return encoding;
			}
			set
			{
				encoding = value;
			}
		}

		public override object GetInitializer(LogicalMethodInfo methodInfo)
		{
			if (!ValueCollectionParameterReader.IsSupported(methodInfo))
			{
				return null;
			}
			return methodInfo.InParameters;
		}

		public override void Initialize(object initializer)
		{
			paramInfos = (ParameterInfo[])initializer;
		}

		protected void Encode(TextWriter writer, object[] values)
		{
			numberEncoded = 0;
			for (int i = 0; i < paramInfos.Length; i++)
			{
				ParameterInfo parameterInfo = paramInfos[i];
				if (parameterInfo.ParameterType.IsArray)
				{
					Array array = (Array)values[i];
					for (int j = 0; j < array.Length; j++)
					{
						Encode(writer, parameterInfo.Name, array.GetValue(j));
					}
				}
				else
				{
					Encode(writer, parameterInfo.Name, values[i]);
				}
			}
		}

		protected void Encode(TextWriter writer, string name, object value)
		{
			if (numberEncoded > 0)
			{
				writer.Write('&');
			}
			writer.Write(UrlEncode(name));
			writer.Write('=');
			writer.Write(UrlEncode(ScalarFormatter.ToString(value)));
			numberEncoded++;
		}

		private string UrlEncode(string value)
		{
			if (encoding != null)
			{
				return UrlEncoder.UrlEscapeString(value, encoding);
			}
			return UrlEncoder.UrlEscapeStringUnicode(value);
		}
	}
	public class HtmlFormParameterWriter : UrlEncodedParameterWriter
	{
		public override bool UsesWriteRequest => true;

		public override void InitializeRequest(WebRequest request, object[] values)
		{
			request.ContentType = ContentType.Compose("application/x-www-form-urlencoded", RequestEncoding);
		}

		public override void WriteRequest(Stream requestStream, object[] values)
		{
			if (values.Length != 0)
			{
				TextWriter textWriter = new StreamWriter(requestStream, new ASCIIEncoding());
				Encode(textWriter, values);
				textWriter.Flush();
			}
		}
	}
	internal class HttpClientMethod
	{
		internal Type readerType;

		internal object readerInitializer;

		internal Type writerType;

		internal object writerInitializer;

		internal LogicalMethodInfo methodInfo;
	}
	internal class HttpClientType
	{
		private Hashtable methods = new Hashtable();

		internal HttpClientType(Type type)
		{
			LogicalMethodInfo[] array = LogicalMethodInfo.Create(type.GetMethods(), LogicalMethodTypes.Sync);
			Hashtable hashtable = new Hashtable();
			foreach (LogicalMethodInfo logicalMethodInfo in array)
			{
				try
				{
					object[] customAttributes = logicalMethodInfo.GetCustomAttributes(typeof(HttpMethodAttribute));
					if (customAttributes.Length != 0)
					{
						HttpMethodAttribute httpMethodAttribute = (HttpMethodAttribute)customAttributes[0];
						HttpClientMethod httpClientMethod = new HttpClientMethod
						{
							readerType = httpMethodAttribute.ReturnFormatter,
							writerType = httpMethodAttribute.ParameterFormatter,
							methodInfo = logicalMethodInfo
						};
						AddFormatter(hashtable, httpClientMethod.readerType, httpClientMethod);
						AddFormatter(hashtable, httpClientMethod.writerType, httpClientMethod);
						methods.Add(logicalMethodInfo.Name, httpClientMethod);
					}
				}
				catch (Exception ex)
				{
					if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
					{
						throw;
					}
					throw new InvalidOperationException(Res.GetString("WebReflectionError", logicalMethodInfo.DeclaringType.FullName, logicalMethodInfo.Name), ex);
				}
				catch
				{
					throw new InvalidOperationException(Res.GetString("WebReflectionError", logicalMethodInfo.DeclaringType.FullName, logicalMethodInfo.Name), null);
				}
			}
			foreach (Type key in hashtable.Keys)
			{
				ArrayList arrayList = (ArrayList)hashtable[key];
				LogicalMethodInfo[] array2 = new LogicalMethodInfo[arrayList.Count];
				for (int j = 0; j < arrayList.Count; j++)
				{
					array2[j] = ((HttpClientMethod)arrayList[j]).methodInfo;
				}
				object[] initializers = MimeFormatter.GetInitializers(key, array2);
				bool flag = typeof(MimeParameterWriter).IsAssignableFrom(key);
				for (int k = 0; k < arrayList.Count; k++)
				{
					if (flag)
					{
						((HttpClientMethod)arrayList[k]).writerInitializer = initializers[k];
					}
					else
					{
						((HttpClientMethod)arrayList[k]).readerInitializer = initializers[k];
					}
				}
			}
		}

		private static void AddFormatter(Hashtable formatterTypes, Type formatterType, HttpClientMethod method)
		{
			if (formatterType != null)
			{
				ArrayList arrayList = (ArrayList)formatterTypes[formatterType];
				if (arrayList == null)
				{
					arrayList = new ArrayList();
					formatterTypes.Add(formatterType, arrayList);
				}
				arrayList.Add(method);
			}
		}

		internal HttpClientMethod GetMethod(string name)
		{
			return (HttpClientMethod)methods[name];
		}
	}
	[ComVisible(true)]
	public abstract class HttpSimpleClientProtocol : HttpWebClientProtocol
	{
		private class InvokeAsyncState
		{
			internal object[] Parameters;

			internal MimeParameterWriter ParamWriter;

			internal HttpClientMethod Method;

			internal InvokeAsyncState(HttpClientMethod method, MimeParameterWriter paramWriter, object[] parameters)
			{
				Method = method;
				ParamWriter = paramWriter;
				Parameters = parameters;
			}
		}

		private HttpClientType clientType;

		protected HttpSimpleClientProtocol()
		{
			Type type = GetType();
			clientType = (HttpClientType)WebClientProtocol.GetFromCache(type);
			if (clientType != null)
			{
				return;
			}
			lock (WebClientProtocol.InternalSyncObject)
			{
				clientType = (HttpClientType)WebClientProtocol.GetFromCache(type);
				if (clientType == null)
				{
					clientType = new HttpClientType(type);
					WebClientProtocol.AddToCache(type, clientType);
				}
			}
		}

		protected object Invoke(string methodName, string requestUrl, object[] parameters)
		{
			WebResponse webResponse = null;
			HttpClientMethod clientMethod = GetClientMethod(methodName);
			MimeParameterWriter parameterWriter = GetParameterWriter(clientMethod);
			Uri uri = new Uri(requestUrl);
			if (parameterWriter != null)
			{
				parameterWriter.RequestEncoding = base.RequestEncoding;
				requestUrl = parameterWriter.GetRequestUrl(uri.AbsoluteUri, parameters);
				uri = new Uri(requestUrl, dontEscape: true);
			}
			WebRequest webRequest = null;
			try
			{
				webRequest = GetWebRequest(uri);
				NotifyClientCallOut(webRequest);
				base.PendingSyncRequest = webRequest;
				if (parameterWriter != null)
				{
					parameterWriter.InitializeRequest(webRequest, parameters);
					if (parameterWriter.UsesWriteRequest)
					{
						if (parameters.Length == 0)
						{
							webRequest.ContentLength = 0L;
						}
						else
						{
							Stream stream = null;
							try
							{
								stream = webRequest.GetRequestStream();
								parameterWriter.WriteRequest(stream, parameters);
							}
							finally
							{
								stream?.Close();
							}
						}
					}
				}
				webResponse = GetWebResponse(webRequest);
				Stream responseStream = null;
				if (webResponse.ContentLength != 0)
				{
					responseStream = webResponse.GetResponseStream();
				}
				return ReadResponse(clientMethod, webResponse, responseStream);
			}
			finally
			{
				if (webRequest == base.PendingSyncRequest)
				{
					base.PendingSyncRequest = null;
				}
			}
		}

		protected IAsyncResult BeginInvoke(string methodName, string requestUrl, object[] parameters, AsyncCallback callback, object asyncState)
		{
			HttpClientMethod clientMethod = GetClientMethod(methodName);
			MimeParameterWriter parameterWriter = GetParameterWriter(clientMethod);
			Uri uri = new Uri(requestUrl);
			if (parameterWriter != null)
			{
				parameterWriter.RequestEncoding = base.RequestEncoding;
				requestUrl = parameterWriter.GetRequestUrl(uri.AbsoluteUri, parameters);
				uri = new Uri(requestUrl, dontEscape: true);
			}
			InvokeAsyncState internalAsyncState = new InvokeAsyncState(clientMethod, parameterWriter, parameters);
			WebClientAsyncResult asyncResult = new WebClientAsyncResult(this, internalAsyncState, null, callback, asyncState);
			return BeginSend(uri, asyncResult, parameterWriter.UsesWriteRequest);
		}

		internal override void InitializeAsyncRequest(WebRequest request, object internalAsyncState)
		{
			InvokeAsyncState invokeAsyncState = (InvokeAsyncState)internalAsyncState;
			if (invokeAsyncState.ParamWriter.UsesWriteRequest && invokeAsyncState.Parameters.Length == 0)
			{
				request.ContentLength = 0L;
			}
		}

		internal override void AsyncBufferedSerialize(WebRequest request, Stream requestStream, object internalAsyncState)
		{
			InvokeAsyncState invokeAsyncState = (InvokeAsyncState)internalAsyncState;
			if (invokeAsyncState.ParamWriter != null)
			{
				invokeAsyncState.ParamWriter.InitializeRequest(request, invokeAsyncState.Parameters);
				if (invokeAsyncState.ParamWriter.UsesWriteRequest && invokeAsyncState.Parameters.Length > 0)
				{
					invokeAsyncState.ParamWriter.WriteRequest(requestStream, invokeAsyncState.Parameters);
				}
			}
		}

		protected object EndInvoke(IAsyncResult asyncResult)
		{
			object internalAsyncState = null;
			Stream responseStream = null;
			WebResponse response = EndSend(asyncResult, ref internalAsyncState, ref responseStream);
			InvokeAsyncState invokeAsyncState = (InvokeAsyncState)internalAsyncState;
			return ReadResponse(invokeAsyncState.Method, response, responseStream);
		}

		private void InvokeAsyncCallback(IAsyncResult result)
		{
			object obj = null;
			Exception e = null;
			WebClientAsyncResult webClientAsyncResult = (WebClientAsyncResult)result;
			if (webClientAsyncResult.Request != null)
			{
				try
				{
					object internalAsyncState = null;
					Stream responseStream = null;
					WebResponse response = EndSend(webClientAsyncResult, ref internalAsyncState, ref responseStream);
					InvokeAsyncState invokeAsyncState = (InvokeAsyncState)internalAsyncState;
					obj = ReadResponse(invokeAsyncState.Method, response, responseStream);
				}
				catch (Exception ex)
				{
					if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
					{
						throw;
					}
					e = ex;
					if (Tracing.On)
					{
						Tracing.ExceptionCatch(TraceEventType.Error, this, "InvokeAsyncCallback", ex);
					}
				}
				catch
				{
					e = new Exception(Res.GetString("NonClsCompliantException"));
				}
			}
			AsyncOperation asyncOperation = (AsyncOperation)result.AsyncState;
			UserToken userToken = (UserToken)asyncOperation.UserSuppliedState;
			OperationCompleted(userToken.UserState, new object[1] { obj }, e, canceled: false);
		}

		protected void InvokeAsync(string methodName, string requestUrl, object[] parameters, SendOrPostCallback callback)
		{
			InvokeAsync(methodName, requestUrl, parameters, callback, null);
		}

		protected void InvokeAsync(string methodName, string requestUrl, object[] parameters, SendOrPostCallback callback, object userState)
		{
			if (userState == null)
			{
				userState = base.NullToken;
			}
			AsyncOperation asyncOperation = AsyncOperationManager.CreateOperation(new UserToken(callback, userState));
			WebClientAsyncResult webClientAsyncResult = new WebClientAsyncResult(this, null, null, InvokeAsyncCallback, asyncOperation);
			try
			{
				base.AsyncInvokes.Add(userState, webClientAsyncResult);
			}
			catch (Exception ex)
			{
				if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
				{
					throw;
				}
				if (Tracing.On)
				{
					Tracing.ExceptionCatch(TraceEventType.Error, this, "InvokeAsync", ex);
				}
				Exception exception = new ArgumentException(Res.GetString("AsyncDuplicateUserState"), ex);
				object[] results = new object[1];
				InvokeCompletedEventArgs arg = new InvokeCompletedEventArgs(results, exception, cancelled: false, userState);
				asyncOperation.PostOperationCompleted(callback, arg);
				return;
			}
			catch
			{
				Exception exception2 = new ArgumentException(Res.GetString("AsyncDuplicateUserState"), new Exception(Res.GetString("NonClsCompliantException")));
				object[] results2 = new object[1];
				InvokeCompletedEventArgs arg2 = new InvokeCompletedEventArgs(results2, exception2, cancelled: false, userState);
				asyncOperation.PostOperationCompleted(callback, arg2);
				return;
			}
			try
			{
				HttpClientMethod clientMethod = GetClientMethod(methodName);
				MimeParameterWriter parameterWriter = GetParameterWriter(clientMethod);
				Uri uri = new Uri(requestUrl);
				if (parameterWriter != null)
				{
					parameterWriter.RequestEncoding = base.RequestEncoding;
					requestUrl = parameterWriter.GetRequestUrl(uri.AbsoluteUri, parameters);
					uri = new Uri(requestUrl, dontEscape: true);
				}
				webClientAsyncResult.InternalAsyncState = new InvokeAsyncState(clientMethod, parameterWriter, parameters);
				BeginSend(uri, webClientAsyncResult, parameterWriter.UsesWriteRequest);
			}
			catch (Exception ex2)
			{
				if (ex2 is ThreadAbortException || ex2 is StackOverflowException || ex2 is OutOfMemoryException)
				{
					throw;
				}
				if (Tracing.On)
				{
					Tracing.ExceptionCatch(TraceEventType.Error, this, "InvokeAsync", ex2);
				}
				object userState2 = userState;
				object[] parameters2 = new object[1];
				OperationCompleted(userState2, parameters2, ex2, canceled: false);
			}
			catch
			{
				object userState3 = userState;
				object[] parameters3 = new object[1];
				OperationCompleted(userState3, parameters3, new Exception(Res.GetString("NonClsCompliantException")), canceled: false);
			}
		}

		private MimeParameterWriter GetParameterWriter(HttpClientMethod method)
		{
			if (method.writerType == null)
			{
				return null;
			}
			return (MimeParameterWriter)MimeFormatter.CreateInstance(method.writerType, method.writerInitializer);
		}

		private HttpClientMethod GetClientMethod(string methodName)
		{
			HttpClientMethod method = clientType.GetMethod(methodName);
			if (method == null)
			{
				throw new ArgumentException(Res.GetString("WebInvalidMethodName", methodName), "methodName");
			}
			return method;
		}

		private object ReadResponse(HttpClientMethod method, WebResponse response, Stream responseStream)
		{
			if (response is HttpWebResponse httpWebResponse && httpWebResponse.StatusCode >= HttpStatusCode.MultipleChoices)
			{
				throw new WebException(RequestResponseUtils.CreateResponseExceptionString(httpWebResponse, responseStream), null, WebExceptionStatus.ProtocolError, httpWebResponse);
			}
			if (method.readerType == null)
			{
				return null;
			}
			if (responseStream != null)
			{
				MimeReturnReader mimeReturnReader = (MimeReturnReader)MimeFormatter.CreateInstance(method.readerType, method.readerInitializer);
				return mimeReturnReader.Read(response, responseStream);
			}
			return null;
		}
	}
	public class HttpGetClientProtocol : HttpSimpleClientProtocol
	{
		protected override WebRequest GetWebRequest(Uri uri)
		{
			WebRequest webRequest = base.GetWebRequest(uri);
			webRequest.Method = "GET";
			return webRequest;
		}
	}
	internal class HttpGetServerProtocolFactory : ServerProtocolFactory
	{
		protected override ServerProtocol CreateIfRequestCompatible(HttpRequest request)
		{
			if (request.PathInfo.Length < 2)
			{
				return null;
			}
			if (request.HttpMethod != "GET")
			{
				return new UnsupportedRequestProtocol(405);
			}
			return new HttpGetServerProtocol();
		}
	}
	internal abstract class HttpServerProtocol : ServerProtocol
	{
		private HttpServerMethod serverMethod;

		private HttpServerType serverType;

		private bool hasInputPayload;

		internal override bool IsOneWay => false;

		internal override LogicalMethodInfo MethodInfo => serverMethod.methodInfo;

		internal override ServerType ServerType => serverType;

		protected HttpServerProtocol(bool hasInputPayload)
		{
			this.hasInputPayload = hasInputPayload;
		}

		internal override bool Initialize()
		{
			string text = base.Request.PathInfo.Substring(1);
			serverType = (HttpServerType)GetFromCache(typeof(HttpServerProtocol), base.Type);
			if (serverType == null)
			{
				lock (ServerProtocol.InternalSyncObject)
				{
					serverType = (HttpServerType)GetFromCache(typeof(HttpServerProtocol), base.Type);
					if (serverType == null)
					{
						serverType = new HttpServerType(base.Type);
						AddToCache(typeof(HttpServerProtocol), base.Type, serverType);
					}
				}
			}
			serverMethod = serverType.GetMethod(text);
			if (serverMethod == null)
			{
				serverMethod = serverType.GetMethodIgnoreCase(text);
				if (serverMethod != null)
				{
					throw new ArgumentException(Res.GetString("WebInvalidMethodNameCase", text, serverMethod.name), "methodName");
				}
				string @string = Encoding.UTF8.GetString(Encoding.Default.GetBytes(text));
				serverMethod = serverType.GetMethod(@string);
				if (serverMethod == null)
				{
					throw new InvalidOperationException(Res.GetString("WebInvalidMethodName", text));
				}
			}
			return true;
		}

		internal override object[] ReadParameters()
		{
			if (serverMethod.readerTypes == null)
			{
				return new object[0];
			}
			for (int i = 0; i < serverMethod.readerTypes.Length; i++)
			{
				if (!hasInputPayload)
				{
					if (serverMethod.readerTypes[i] != typeof(UrlParameterReader))
					{
						continue;
					}
				}
				else if (serverMethod.readerTypes[i] == typeof(UrlParameterReader))
				{
					continue;
				}
				MimeParameterReader mimeParameterReader = (MimeParameterReader)MimeFormatter.CreateInstance(serverMethod.readerTypes[i], serverMethod.readerInitializers[i]);
				object[] array = mimeParameterReader.Read(base.Request);
				if (array != null)
				{
					return array;
				}
			}
			if (!hasInputPayload)
			{
				throw new InvalidOperationException(Res.GetString("WebInvalidRequestFormat"));
			}
			throw new InvalidOperationException(Res.GetString("WebInvalidRequestFormatDetails", base.Request.ContentType));
		}

		internal override void WriteReturns(object[] returnValues, Stream outputStream)
		{
			if (serverMethod.writerType != null)
			{
				MimeReturnWriter mimeReturnWriter = (MimeReturnWriter)MimeFormatter.CreateInstance(serverMethod.writerType, serverMethod.writerInitializer);
				mimeReturnWriter.Write(base.Response, outputStream, returnValues[0]);
			}
		}

		internal override bool WriteException(Exception e, Stream outputStream)
		{
			base.Response.Clear();
			base.Response.ClearHeaders();
			base.Response.ContentType = ContentType.Compose("text/plain", Encoding.UTF8);
			ServerProtocol.SetHttpResponseStatusCode(base.Response, 500);
			base.Response.StatusDescription = HttpWorkerRequest.GetStatusDescription(base.Response.StatusCode);
			StreamWriter streamWriter = new StreamWriter(outputStream, new UTF8Encoding(encoderShouldEmitUTF8Identifier: false));
			if (WebServicesSection.Current.Diagnostics.SuppressReturningExceptions)
			{
				streamWriter.WriteLine(Res.GetString("WebSuppressedExceptionMessage"));
			}
			else
			{
				streamWriter.WriteLine(GenerateFaultString(e, htmlEscapeMessage: true));
			}
			streamWriter.Flush();
			return true;
		}

		internal static bool AreUrlParametersSupported(LogicalMethodInfo methodInfo)
		{
			if (methodInfo.OutParameters.Length > 0)
			{
				return false;
			}
			ParameterInfo[] inParameters = methodInfo.InParameters;
			foreach (ParameterInfo parameterInfo in inParameters)
			{
				Type parameterType = parameterInfo.ParameterType;
				if (parameterType.IsArray)
				{
					if (!ScalarFormatter.IsTypeSupported(parameterType.GetElementType()))
					{
						return false;
					}
				}
				else if (!ScalarFormatter.IsTypeSupported(parameterType))
				{
					return false;
				}
			}
			return true;
		}
	}
	internal class HttpGetServerProtocol : HttpServerProtocol
	{
		internal HttpGetServerProtocol()
			: base(hasInputPayload: false)
		{
		}
	}
	[AttributeUsage(AttributeTargets.Method)]
	public sealed class HttpMethodAttribute : Attribute
	{
		private Type returnFormatter;

		private Type parameterFormatter;

		public Type ReturnFormatter
		{
			get
			{
				return returnFormatter;
			}
			set
			{
				returnFormatter = value;
			}
		}

		public Type ParameterFormatter
		{
			get
			{
				return parameterFormatter;
			}
			set
			{
				parameterFormatter = value;
			}
		}

		public HttpMethodAttribute()
		{
			returnFormatter = null;
			parameterFormatter = null;
		}

		public HttpMethodAttribute(Type returnFormatter, Type parameterFormatter)
		{
			this.returnFormatter = returnFormatter;
			this.parameterFormatter = parameterFormatter;
		}
	}
	public class HttpPostClientProtocol : HttpSimpleClientProtocol
	{
		protected override WebRequest GetWebRequest(Uri uri)
		{
			WebRequest webRequest = base.GetWebRequest(uri);
			webRequest.Method = "POST";
			return webRequest;
		}
	}
	internal class HttpPostLocalhostServerProtocolFactory : ServerProtocolFactory
	{
		protected override ServerProtocol CreateIfRequestCompatible(HttpRequest request)
		{
			if (request.PathInfo.Length < 2)
			{
				return null;
			}
			if (request.HttpMethod != "POST")
			{
				return new UnsupportedRequestProtocol(405);
			}
			string text = request.ServerVariables["LOCAL_ADDR"];
			string text2 = request.ServerVariables["REMOTE_ADDR"];
			if (!request.Url.IsLoopback && (text == null || text2 == null || !(text == text2)))
			{
				return null;
			}
			return new HttpPostServerProtocol();
		}
	}
	internal class HttpPostServerProtocolFactory : ServerProtocolFactory
	{
		protected override ServerProtocol CreateIfRequestCompatible(HttpRequest request)
		{
			if (request.PathInfo.Length < 2)
			{
				return null;
			}
			if (request.HttpMethod != "POST")
			{
				return new UnsupportedRequestProtocol(405);
			}
			return new HttpPostServerProtocol();
		}
	}
	internal class HttpPostServerProtocol : HttpServerProtocol
	{
		internal HttpPostServerProtocol()
			: base(hasInputPayload: true)
		{
		}
	}
	internal class HttpServerType : ServerType
	{
		private Hashtable methods = new Hashtable();

		internal HttpServerType(Type type)
			: base(type)
		{
			WebServicesSection current = WebServicesSection.Current;
			Type[] returnWriterTypes = current.ReturnWriterTypes;
			Type[] parameterReaderTypes = current.ParameterReaderTypes;
			LogicalMethodInfo[] array = WebMethodReflector.GetMethods(type);
			HttpServerMethod[] array2 = new HttpServerMethod[array.Length];
			object[] array3 = new object[returnWriterTypes.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = MimeFormatter.GetInitializers(returnWriterTypes[i], array);
			}
			for (int j = 0; j < array.Length; j++)
			{
				LogicalMethodInfo logicalMethodInfo = array[j];
				HttpServerMethod httpServerMethod = null;
				if (logicalMethodInfo.ReturnType == typeof(void))
				{
					httpServerMethod = new HttpServerMethod();
				}
				else
				{
					for (int k = 0; k < returnWriterTypes.Length; k++)
					{
						object[] array4 = (object[])array3[k];
						if (array4[j] != null)
						{
							httpServerMethod = new HttpServerMethod
							{
								writerInitializer = array4[j],
								writerType = returnWriterTypes[k]
							};
							break;
						}
					}
				}
				if (httpServerMethod != null)
				{
					httpServerMethod.methodInfo = logicalMethodInfo;
					array2[j] = httpServerMethod;
				}
			}
			array3 = new object[parameterReaderTypes.Length];
			for (int l = 0; l < array3.Length; l++)
			{
				array3[l] = MimeFormatter.GetInitializers(parameterReaderTypes[l], array);
			}
			for (int m = 0; m < array.Length; m++)
			{
				HttpServerMethod httpServerMethod2 = array2[m];
				if (httpServerMethod2 == null)
				{
					continue;
				}
				LogicalMethodInfo logicalMethodInfo2 = array[m];
				if (logicalMethodInfo2.InParameters.Length <= 0)
				{
					continue;
				}
				int num = 0;
				for (int n = 0; n < parameterReaderTypes.Length; n++)
				{
					object[] array5 = (object[])array3[n];
					if (array5[m] != null)
					{
						num++;
					}
				}
				if (num == 0)
				{
					array2[m] = null;
					continue;
				}
				httpServerMethod2.readerTypes = new Type[num];
				httpServerMethod2.readerInitializers = new object[num];
				num = 0;
				for (int num2 = 0; num2 < parameterReaderTypes.Length; num2++)
				{
					object[] array6 = (object[])array3[num2];
					if (array6[m] != null)
					{
						httpServerMethod2.readerTypes[num] = parameterReaderTypes[num2];
						httpServerMethod2.readerInitializers[num] = array6[m];
						num++;
					}
				}
			}
			foreach (HttpServerMethod httpServerMethod3 in array2)
			{
				if (httpServerMethod3 != null)
				{
					WebMethodAttribute methodAttribute = httpServerMethod3.methodInfo.MethodAttribute;
					httpServerMethod3.name = methodAttribute.MessageName;
					if (httpServerMethod3.name.Length == 0)
					{
						httpServerMethod3.name = httpServerMethod3.methodInfo.Name;
					}
					methods.Add(httpServerMethod3.name, httpServerMethod3);
				}
			}
		}

		internal HttpServerMethod GetMethod(string name)
		{
			return (HttpServerMethod)methods[name];
		}

		internal HttpServerMethod GetMethodIgnoreCase(string name)
		{
			foreach (DictionaryEntry method in methods)
			{
				HttpServerMethod httpServerMethod = (HttpServerMethod)method.Value;
				if (string.Compare(httpServerMethod.name, name, StringComparison.OrdinalIgnoreCase) == 0)
				{
					return httpServerMethod;
				}
			}
			return null;
		}
	}
	internal class HttpServerMethod
	{
		internal string name;

		internal LogicalMethodInfo methodInfo;

		internal Type[] readerTypes;

		internal object[] readerInitializers;

		internal Type writerType;

		internal object writerInitializer;
	}
	public enum LogicalMethodTypes
	{
		Sync = 1,
		Async
	}
	public sealed class LogicalMethodInfo
	{
		private MethodInfo methodInfo;

		private MethodInfo endMethodInfo;

		private ParameterInfo[] inParams;

		private ParameterInfo[] outParams;

		private ParameterInfo[] parameters;

		private Hashtable attributes;

		private Type retType;

		private ParameterInfo callbackParam;

		private ParameterInfo stateParam;

		private ParameterInfo resultParam;

		private string methodName;

		private bool isVoid;

		private static object[] emptyObjectArray = new object[0];

		private WebServiceBindingAttribute binding;

		private WebMethodAttribute attribute;

		private MethodInfo declaration;

		private static HashAlgorithm hash;

		internal WebServiceBindingAttribute Binding => binding;

		internal MethodInfo Declaration => declaration;

		public Type DeclaringType => methodInfo.DeclaringType;

		public string Name => methodName;

		public ParameterInfo AsyncResultParameter => resultParam;

		public ParameterInfo AsyncCallbackParameter => callbackParam;

		public ParameterInfo AsyncStateParameter => stateParam;

		public Type ReturnType => retType;

		public bool IsVoid => isVoid;

		public bool IsAsync => endMethodInfo != null;

		public ParameterInfo[] InParameters => inParams;

		public ParameterInfo[] OutParameters => outParams;

		public ParameterInfo[] Parameters => parameters;

		internal WebMethodAttribute MethodAttribute
		{
			get
			{
				if (attribute == null)
				{
					attribute = (WebMethodAttribute)GetCustomAttribute(typeof(WebMethodAttribute));
					if (attribute == null)
					{
						attribute = new WebMethodAttribute();
					}
				}
				return attribute;
			}
		}

		public ICustomAttributeProvider CustomAttributeProvider => methodInfo;

		public ICustomAttributeProvider ReturnTypeCustomAttributeProvider
		{
			get
			{
				if (declaration != null)
				{
					return declaration.ReturnTypeCustomAttributes;
				}
				return methodInfo.ReturnTypeCustomAttributes;
			}
		}

		public MethodInfo MethodInfo
		{
			get
			{
				if (endMethodInfo != null)
				{
					return null;
				}
				return methodInfo;
			}
		}

		public MethodInfo BeginMethodInfo => methodInfo;

		public MethodInfo EndMethodInfo => endMethodInfo;

		internal static HashAlgorithm HashAlgorithm
		{
			get
			{
				if (hash == null)
				{
					hash = SHA1.Create();
				}
				return hash;
			}
		}

		public LogicalMethodInfo(MethodInfo methodInfo)
			: this(methodInfo, null)
		{
		}

		internal LogicalMethodInfo(MethodInfo methodInfo, WebMethod webMethod)
		{
			if (methodInfo.IsStatic)
			{
				throw new InvalidOperationException(Res.GetString("WebMethodStatic", methodInfo.Name));
			}
			this.methodInfo = methodInfo;
			if (webMethod != null)
			{
				binding = webMethod.binding;
				attribute = webMethod.attribute;
				declaration = webMethod.declaration;
			}
			MethodInfo methodInfo2 = ((declaration != null) ? declaration : methodInfo);
			parameters = methodInfo2.GetParameters();
			inParams = GetInParameters(methodInfo2, parameters, 0, parameters.Length, mustBeIn: false);
			outParams = GetOutParameters(methodInfo2, parameters, 0, parameters.Length, mustBeOut: false);
			retType = methodInfo2.ReturnType;
			isVoid = retType == typeof(void);
			methodName = methodInfo2.Name;
			attributes = new Hashtable();
		}

		private LogicalMethodInfo(MethodInfo beginMethodInfo, MethodInfo endMethodInfo, WebMethod webMethod)
		{
			methodInfo = beginMethodInfo;
			this.endMethodInfo = endMethodInfo;
			methodName = beginMethodInfo.Name.Substring(5);
			if (webMethod != null)
			{
				binding = webMethod.binding;
				attribute = webMethod.attribute;
				declaration = webMethod.declaration;
			}
			ParameterInfo[] array = beginMethodInfo.GetParameters();
			if (array.Length < 2 || array[array.Length - 1].ParameterType != typeof(object) || array[array.Length - 2].ParameterType != typeof(AsyncCallback))
			{
				throw new InvalidOperationException(Res.GetString("WebMethodMissingParams", beginMethodInfo.DeclaringType.FullName, beginMethodInfo.Name, typeof(AsyncCallback).FullName, typeof(object).FullName));
			}
			stateParam = array[array.Length - 1];
			callbackParam = array[array.Length - 2];
			inParams = GetInParameters(beginMethodInfo, array, 0, array.Length - 2, mustBeIn: true);
			ParameterInfo[] array2 = endMethodInfo.GetParameters();
			resultParam = array2[0];
			outParams = GetOutParameters(endMethodInfo, array2, 1, array2.Length - 1, mustBeOut: true);
			parameters = new ParameterInfo[inParams.Length + outParams.Length];
			inParams.CopyTo(parameters, 0);
			outParams.CopyTo(parameters, inParams.Length);
			retType = endMethodInfo.ReturnType;
			isVoid = retType == typeof(void);
			attributes = new Hashtable();
		}

		public override string ToString()
		{
			return methodInfo.ToString();
		}

		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public object[] Invoke(object target, object[] values)
		{
			if (outParams.Length > 0)
			{
				object[] array = new object[parameters.Length];
				for (int i = 0; i < inParams.Length; i++)
				{
					array[inParams[i].Position] = values[i];
				}
				values = array;
			}
			object obj = methodInfo.Invoke(target, values);
			if (outParams.Length > 0)
			{
				int num = outParams.Length;
				if (!isVoid)
				{
					num++;
				}
				object[] array2 = new object[num];
				num = 0;
				if (!isVoid)
				{
					array2[num++] = obj;
				}
				for (int j = 0; j < outParams.Length; j++)
				{
					array2[num++] = values[outParams[j].Position];
				}
				return array2;
			}
			if (isVoid)
			{
				return emptyObjectArray;
			}
			return new object[1] { obj };
		}

		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public IAsyncResult BeginInvoke(object target, object[] values, AsyncCallback callback, object asyncState)
		{
			object[] array = new object[values.Length + 2];
			values.CopyTo(array, 0);
			array[values.Length] = callback;
			array[values.Length + 1] = asyncState;
			return (IAsyncResult)methodInfo.Invoke(target, array);
		}

		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public object[] EndInvoke(object target, IAsyncResult asyncResult)
		{
			object[] array = new object[outParams.Length + 1];
			array[0] = asyncResult;
			object obj = endMethodInfo.Invoke(target, array);
			if (!isVoid)
			{
				array[0] = obj;
				return array;
			}
			if (outParams.Length > 0)
			{
				object[] array2 = new object[outParams.Length];
				Array.Copy(array, 1, array2, 0, array2.Length);
				return array2;
			}
			return emptyObjectArray;
		}

		public object[] GetCustomAttributes(Type type)
		{
			object[] array = null;
			array = (object[])attributes[type];
			if (array != null)
			{
				return array;
			}
			lock (attributes)
			{
				array = (object[])attributes[type];
				if (array == null)
				{
					if (declaration != null)
					{
						object[] customAttributes = declaration.GetCustomAttributes(type, inherit: false);
						object[] customAttributes2 = methodInfo.GetCustomAttributes(type, inherit: false);
						if (customAttributes2.Length > 0)
						{
							if (!CanMerge(type))
							{
								throw new InvalidOperationException(Res.GetString("ContractOverride", methodInfo.Name, methodInfo.DeclaringType.FullName, declaration.DeclaringType.FullName, declaration.ToString(), customAttributes2[0].ToString()));
							}
							ArrayList arrayList = new ArrayList();
							for (int i = 0; i < customAttributes.Length; i++)
							{
								arrayList.Add(customAttributes[i]);
							}
							for (int j = 0; j < customAttributes2.Length; j++)
							{
								arrayList.Add(customAttributes2[j]);
							}
							array = (object[])arrayList.ToArray(type);
						}
						else
						{
							array = customAttributes;
						}
					}
					else
					{
						array = methodInfo.GetCustomAttributes(type, inherit: false);
					}
					attributes[type] = array;
					return array;
				}
				return array;
			}
		}

		public object GetCustomAttribute(Type type)
		{
			object[] customAttributes = GetCustomAttributes(type);
			if (customAttributes.Length == 0)
			{
				return null;
			}
			return customAttributes[0];
		}

		private static ParameterInfo[] GetInParameters(MethodInfo methodInfo, ParameterInfo[] paramInfos, int start, int length, bool mustBeIn)
		{
			int num = 0;
			for (int i = 0; i < length; i++)
			{
				ParameterInfo parameterInfo = paramInfos[i + start];
				if (IsInParameter(parameterInfo))
				{
					num++;
				}
				else if (mustBeIn)
				{
					throw new InvalidOperationException(Res.GetString("WebBadOutParameter", parameterInfo.Name, methodInfo.DeclaringType.FullName, parameterInfo.Name));
				}
			}
			ParameterInfo[] array = new ParameterInfo[num];
			num = 0;
			for (int j = 0; j < length; j++)
			{
				ParameterInfo parameterInfo2 = paramInfos[j + start];
				if (IsInParameter(parameterInfo2))
				{
					array[num++] = parameterInfo2;
				}
			}
			return array;
		}

		private static ParameterInfo[] GetOutParameters(MethodInfo methodInfo, ParameterInfo[] paramInfos, int start, int length, bool mustBeOut)
		{
			int num = 0;
			for (int i = 0; i < length; i++)
			{
				ParameterInfo parameterInfo = paramInfos[i + start];
				if (IsOutParameter(parameterInfo))
				{
					num++;
				}
				else if (mustBeOut)
				{
					throw new InvalidOperationException(Res.GetString("WebInOutParameter", parameterInfo.Name, methodInfo.DeclaringType.FullName, parameterInfo.Name));
				}
			}
			ParameterInfo[] array = new ParameterInfo[num];
			num = 0;
			for (int j = 0; j < length; j++)
			{
				ParameterInfo parameterInfo2 = paramInfos[j + start];
				if (IsOutParameter(parameterInfo2))
				{
					array[num++] = parameterInfo2;
				}
			}
			return array;
		}

		private static bool IsInParameter(ParameterInfo paramInfo)
		{
			return !paramInfo.IsOut;
		}

		private static bool IsOutParameter(ParameterInfo paramInfo)
		{
			if (!paramInfo.IsOut)
			{
				return paramInfo.ParameterType.IsByRef;
			}
			return true;
		}

		public static bool IsBeginMethod(MethodInfo methodInfo)
		{
			if (typeof(IAsyncResult).IsAssignableFrom(methodInfo.ReturnType))
			{
				return methodInfo.Name.StartsWith("Begin", StringComparison.Ordinal);
			}
			return false;
		}

		public static bool IsEndMethod(MethodInfo methodInfo)
		{
			ParameterInfo[] array = methodInfo.GetParameters();
			if (array.Length > 0 && typeof(IAsyncResult).IsAssignableFrom(array[0].ParameterType))
			{
				return methodInfo.Name.StartsWith("End", StringComparison.Ordinal);
			}
			return false;
		}

		public static LogicalMethodInfo[] Create(MethodInfo[] methodInfos)
		{
			return Create(methodInfos, (LogicalMethodTypes)3, null);
		}

		public static LogicalMethodInfo[] Create(MethodInfo[] methodInfos, LogicalMethodTypes types)
		{
			return Create(methodInfos, types, null);
		}

		internal static LogicalMethodInfo[] Create(MethodInfo[] methodInfos, LogicalMethodTypes types, Hashtable declarations)
		{
			ArrayList arrayList = (((types & LogicalMethodTypes.Async) != 0) ? new ArrayList() : null);
			Hashtable hashtable = (((types & LogicalMethodTypes.Async) != 0) ? new Hashtable() : null);
			ArrayList arrayList2 = (((types & LogicalMethodTypes.Sync) != 0) ? new ArrayList() : null);
			foreach (MethodInfo methodInfo in methodInfos)
			{
				if (IsBeginMethod(methodInfo))
				{
					arrayList?.Add(methodInfo);
				}
				else if (IsEndMethod(methodInfo))
				{
					hashtable?.Add(methodInfo.Name, methodInfo);
				}
				else
				{
					arrayList2?.Add(methodInfo);
				}
			}
			int num = arrayList?.Count ?? 0;
			int num2 = arrayList2?.Count ?? 0;
			int num3 = num2 + num;
			LogicalMethodInfo[] array = new LogicalMethodInfo[num3];
			num3 = 0;
			for (int j = 0; j < num2; j++)
			{
				MethodInfo key = (MethodInfo)arrayList2[j];
				WebMethod webMethod = ((declarations == null) ? null : ((WebMethod)declarations[key]));
				array[num3] = new LogicalMethodInfo(key, webMethod);
				array[num3].CheckContractOverride();
				num3++;
			}
			for (int k = 0; k < num; k++)
			{
				MethodInfo methodInfo2 = (MethodInfo)arrayList[k];
				string text = "End" + methodInfo2.Name.Substring(5);
				MethodInfo methodInfo3 = (MethodInfo)hashtable[text];
				if (methodInfo3 == null)
				{
					throw new InvalidOperationException(Res.GetString("WebAsyncMissingEnd", methodInfo2.DeclaringType.FullName, methodInfo2.Name, text));
				}
				WebMethod webMethod2 = ((declarations == null) ? null : ((WebMethod)declarations[methodInfo2]));
				array[num3++] = new LogicalMethodInfo(methodInfo2, methodInfo3, webMethod2);
			}
			return array;
		}

		internal string GetKey()
		{
			if (methodInfo == null)
			{
				return string.Empty;
			}
			string text = methodInfo.DeclaringType.FullName + ":" + methodInfo.ToString();
			if (text.Length > 1024)
			{
				byte[] inArray = HashAlgorithm.ComputeHash(Encoding.UTF8.GetBytes(text));
				text = Convert.ToBase64String(inArray);
			}
			return text;
		}

		internal void CheckContractOverride()
		{
			if (declaration == null)
			{
				return;
			}
			methodInfo.GetParameters();
			ParameterInfo[] array = methodInfo.GetParameters();
			ParameterInfo[] array2 = array;
			foreach (ParameterInfo parameterInfo in array2)
			{
				object[] customAttributes = parameterInfo.GetCustomAttributes(inherit: false);
				object[] array3 = customAttributes;
				foreach (object obj in array3)
				{
					if (obj.GetType().Namespace == "System.Xml.Serialization")
					{
						throw new InvalidOperationException(Res.GetString("ContractOverride", methodInfo.Name, methodInfo.DeclaringType.FullName, declaration.DeclaringType.FullName, declaration.ToString(), obj.ToString()));
					}
				}
			}
		}

		internal static bool CanMerge(Type type)
		{
			if (type == typeof(SoapHeaderAttribute))
			{
				return true;
			}
			if (typeof(SoapExtensionAttribute).IsAssignableFrom(type))
			{
				return true;
			}
			return false;
		}
	}
	[AttributeUsage(AttributeTargets.All)]
	public sealed class MatchAttribute : Attribute
	{
		private string pattern;

		private int group = 1;

		private int capture;

		private bool ignoreCase;

		private int repeats = -1;

		public string Pattern
		{
			get
			{
				if (pattern != null)
				{
					return pattern;
				}
				return string.Empty;
			}
			set
			{
				pattern = value;
			}
		}

		public int Group
		{
			get
			{
				return group;
			}
			set
			{
				group = value;
			}
		}

		public int Capture
		{
			get
			{
				return capture;
			}
			set
			{
				capture = value;
			}
		}

		public bool IgnoreCase
		{
			get
			{
				return ignoreCase;
			}
			set
			{
				ignoreCase = value;
			}
		}

		public int MaxRepeats
		{
			get
			{
				return repeats;
			}
			set
			{
				repeats = value;
			}
		}

		public MatchAttribute(string pattern)
		{
			this.pattern = pattern;
		}
	}
	internal abstract class MimeReturnWriter : MimeFormatter
	{
		internal abstract void Write(HttpResponse response, Stream outputStream, object returnValue);
	}
	public class NopReturnReader : MimeReturnReader
	{
		public override object GetInitializer(LogicalMethodInfo methodInfo)
		{
			return this;
		}

		public override void Initialize(object initializer)
		{
		}

		public override object Read(WebResponse response, Stream responseStream)
		{
			response.Close();
			return null;
		}
	}
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	public sealed class PatternMatcher
	{
		private MatchType matchType;

		public PatternMatcher(Type type)
		{
			matchType = MatchType.Reflect(type);
		}

		public object Match(string text)
		{
			return matchType.Match(text);
		}
	}
	internal class MatchType
	{
		private Type type;

		private MatchMember[] fields;

		internal Type Type => type;

		internal static MatchType Reflect(Type type)
		{
			MatchType matchType = new MatchType();
			matchType.type = type;
			MemberInfo[] members = type.GetMembers(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public);
			ArrayList arrayList = new ArrayList();
			for (int i = 0; i < members.Length; i++)
			{
				MatchMember matchMember = MatchMember.Reflect(members[i]);
				if (matchMember != null)
				{
					arrayList.Add(matchMember);
				}
			}
			matchType.fields = (MatchMember[])arrayList.ToArray(typeof(MatchMember));
			return matchType;
		}

		internal object Match(string text)
		{
			object obj = Activator.CreateInstance(type);
			for (int i = 0; i < fields.Length; i++)
			{
				fields[i].Match(obj, text);
			}
			return obj;
		}
	}
	internal class MatchMember
	{
		private MemberInfo memberInfo;

		private Regex regex;

		private int group;

		private int capture;

		private int maxRepeats;

		private MatchType matchType;

		internal void Match(object target, string text)
		{
			if (memberInfo is FieldInfo)
			{
				((FieldInfo)memberInfo).SetValue(target, (matchType == null) ? MatchString(text) : MatchClass(text));
			}
			else if (memberInfo is PropertyInfo)
			{
				((PropertyInfo)memberInfo).SetValue(target, (matchType == null) ? MatchString(text) : MatchClass(text), new object[0]);
			}
		}

		private object MatchString(string text)
		{
			Match match = regex.Match(text);
			Type type = ((memberInfo is FieldInfo) ? ((FieldInfo)memberInfo).FieldType : ((PropertyInfo)memberInfo).PropertyType);
			if (type.IsArray)
			{
				ArrayList arrayList = new ArrayList();
				int num = 0;
				while (match.Success && num < maxRepeats)
				{
					if (match.Groups.Count <= this.group)
					{
						throw BadGroupIndexException(this.group, memberInfo.Name, match.Groups.Count - 1);
					}
					Group group = match.Groups[this.group];
					foreach (Capture capture3 in group.Captures)
					{
						arrayList.Add(text.Substring(capture3.Index, capture3.Length));
					}
					match = match.NextMatch();
					num++;
				}
				return arrayList.ToArray(typeof(string));
			}
			if (match.Success)
			{
				if (match.Groups.Count <= this.group)
				{
					throw BadGroupIndexException(this.group, memberInfo.Name, match.Groups.Count - 1);
				}
				Group group2 = match.Groups[this.group];
				if (group2.Captures.Count > 0)
				{
					if (group2.Captures.Count <= capture)
					{
						throw BadCaptureIndexException(capture, memberInfo.Name, group2.Captures.Count - 1);
					}
					Capture capture2 = group2.Captures[capture];
					return text.Substring(capture2.Index, capture2.Length);
				}
			}
			return null;
		}

		private object MatchClass(string text)
		{
			Match match = regex.Match(text);
			Type type = ((memberInfo is FieldInfo) ? ((FieldInfo)memberInfo).FieldType : ((PropertyInfo)memberInfo).PropertyType);
			if (type.IsArray)
			{
				ArrayList arrayList = new ArrayList();
				int num = 0;
				while (match.Success && num < maxRepeats)
				{
					if (match.Groups.Count <= this.group)
					{
						throw BadGroupIndexException(this.group, memberInfo.Name, match.Groups.Count - 1);
					}
					Group group = match.Groups[this.group];
					foreach (Capture capture3 in group.Captures)
					{
						arrayList.Add(matchType.Match(text.Substring(capture3.Index, capture3.Length)));
					}
					match = match.NextMatch();
					num++;
				}
				return arrayList.ToArray(matchType.Type);
			}
			if (match.Success)
			{
				if (match.Groups.Count <= this.group)
				{
					throw BadGroupIndexException(this.group, memberInfo.Name, match.Groups.Count - 1);
				}
				Group group2 = match.Groups[this.group];
				if (group2.Captures.Count > 0)
				{
					if (group2.Captures.Count <= capture)
					{
						throw BadCaptureIndexException(capture, memberInfo.Name, group2.Captures.Count - 1);
					}
					Capture capture2 = group2.Captures[capture];
					return matchType.Match(text.Substring(capture2.Index, capture2.Length));
				}
			}
			return null;
		}

		private static Exception BadCaptureIndexException(int index, string matchName, int highestIndex)
		{
			return new Exception(Res.GetString("WebTextMatchBadCaptureIndex", index, matchName, highestIndex));
		}

		private static Exception BadGroupIndexException(int index, string matchName, int highestIndex)
		{
			return new Exception(Res.GetString("WebTextMatchBadGroupIndex", index, matchName, highestIndex));
		}

		internal static MatchMember Reflect(MemberInfo memberInfo)
		{
			Type type = null;
			if (memberInfo is PropertyInfo)
			{
				PropertyInfo propertyInfo = (PropertyInfo)memberInfo;
				if (!propertyInfo.CanRead)
				{
					return null;
				}
				if (!propertyInfo.CanWrite)
				{
					return null;
				}
				MethodInfo getMethod = propertyInfo.GetGetMethod();
				if (getMethod.IsStatic)
				{
					return null;
				}
				ParameterInfo[] parameters = getMethod.GetParameters();
				if (parameters.Length > 0)
				{
					return null;
				}
				type = propertyInfo.PropertyType;
			}
			if (memberInfo is FieldInfo)
			{
				FieldInfo fieldInfo = (FieldInfo)memberInfo;
				if (!fieldInfo.IsPublic)
				{
					return null;
				}
				if (fieldInfo.IsStatic)
				{
					return null;
				}
				if (fieldInfo.IsSpecialName)
				{
					return null;
				}
				type = fieldInfo.FieldType;
			}
			object[] customAttributes = memberInfo.GetCustomAttributes(typeof(MatchAttribute), inherit: false);
			if (customAttributes.Length == 0)
			{
				return null;
			}
			MatchAttribute matchAttribute = (MatchAttribute)customAttributes[0];
			MatchMember matchMember = new MatchMember();
			matchMember.regex = new Regex(matchAttribute.Pattern, RegexOptions.Singleline | (matchAttribute.IgnoreCase ? (RegexOptions.IgnoreCase | RegexOptions.CultureInvariant) : RegexOptions.None));
			matchMember.group = matchAttribute.Group;
			matchMember.capture = matchAttribute.Capture;
			matchMember.maxRepeats = matchAttribute.MaxRepeats;
			matchMember.memberInfo = memberInfo;
			if (matchMember.maxRepeats < 0)
			{
				matchMember.maxRepeats = ((!type.IsArray) ? 1 : int.MaxValue);
			}
			if (type.IsArray)
			{
				type = type.GetElementType();
			}
			if (type != typeof(string))
			{
				matchMember.matchType = MatchType.Reflect(type);
			}
			return matchMember;
		}
	}
	internal class RemoteDebugger : INotifySource2
	{
		private const int INPROC_SERVER = 1;

		private static INotifyConnection2 connection;

		private static bool getConnection = true;

		private INotifySink2 notifySink;

		private NotifyFilter notifyFilter;

		private UserThread userThread;

		private static Guid IID_NotifyConnectionClassGuid = new Guid("12A5B9F0-7A1C-4fcb-8163-160A30F519B5");

		private static Guid IID_NotifyConnection2Guid = new Guid("1AF04045-6659-4aaa-9F4B-2741AC56224B");

		private static string debuggerHeader = "VsDebuggerCausalityData";

		private static object s_InternalSyncObject;

		private static object InternalSyncObject
		{
			get
			{
				if (s_InternalSyncObject == null)
				{
					object value = new object();
					Interlocked.CompareExchange(ref s_InternalSyncObject, value, null);
				}
				return s_InternalSyncObject;
			}
		}

		private static INotifyConnection2 Connection
		{
			get
			{
				if (connection == null && getConnection)
				{
					lock (InternalSyncObject)
					{
						if (connection == null)
						{
							AppDomain.CurrentDomain.DomainUnload += OnAppDomainUnload;
							AppDomain.CurrentDomain.ProcessExit += OnProcessExit;
							TraceMethod caller = (Tracing.On ? new TraceMethod(typeof(RemoteDebugger), "get_Connection") : null);
							if (Tracing.On)
							{
								Tracing.Enter("RemoteDebugger", caller);
							}
							object punk;
							int num = UnsafeNativeMethods.CoCreateInstance(ref IID_NotifyConnectionClassGuid, null, 1, ref IID_NotifyConnection2Guid, out punk);
							if (Tracing.On)
							{
								Tracing.Exit("RemoteDebugger", caller);
							}
							if (num >= 0)
							{
								connection = (INotifyConnection2)punk;
							}
							else
							{
								connection = null;
							}
						}
						getConnection = false;
					}
				}
				return connection;
			}
		}

		private INotifySink2 NotifySink
		{
			get
			{
				if (notifySink == null && Connection != null)
				{
					TraceMethod caller = (Tracing.On ? new TraceMethod(this, "get_NotifySink") : null);
					if (Tracing.On)
					{
						Tracing.Enter("RemoteDebugger", caller);
					}
					notifySink = UnsafeNativeMethods.RegisterNotifySource(Connection, this);
					if (Tracing.On)
					{
						Tracing.Exit("RemoteDebugger", caller);
					}
				}
				return notifySink;
			}
		}

		[DebuggerHidden]
		[DebuggerStepThrough]
		internal RemoteDebugger()
		{
		}

		~RemoteDebugger()
		{
			Close();
		}

		internal static bool IsClientCallOutEnabled()
		{
			bool result = false;
			try
			{
				result = !System.ComponentModel.CompModSwitches.DisableRemoteDebugging.Enabled && Debugger.IsAttached && Connection != null;
				return result;
			}
			catch (Exception ex)
			{
				if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
				{
					throw;
				}
				if (Tracing.On)
				{
					Tracing.ExceptionCatch(TraceEventType.Warning, typeof(RemoteDebugger), "IsClientCallOutEnabled", ex);
					return result;
				}
				return result;
			}
			catch
			{
				return result;
			}
		}

		internal static bool IsServerCallInEnabled(ServerProtocol protocol, out string stringBuffer)
		{
			stringBuffer = null;
			bool flag = false;
			try
			{
				if (System.ComponentModel.CompModSwitches.DisableRemoteDebugging.Enabled)
				{
					return false;
				}
				flag = protocol.Context.IsDebuggingEnabled && Connection != null;
				if (flag)
				{
					stringBuffer = protocol.Request.Headers[debuggerHeader];
					return stringBuffer != null && stringBuffer.Length > 0;
				}
				return flag;
			}
			catch (Exception ex)
			{
				if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
				{
					throw;
				}
				if (Tracing.On)
				{
					Tracing.ExceptionCatch(TraceEventType.Warning, typeof(RemoteDebugger), "IsServerCallInEnabled", ex);
				}
				return false;
			}
			catch
			{
				return false;
			}
		}

		private static void CloseSharedResources()
		{
			if (connection == null)
			{
				return;
			}
			lock (InternalSyncObject)
			{
				if (connection == null)
				{
					return;
				}
				TraceMethod caller = (Tracing.On ? new TraceMethod(typeof(RemoteDebugger), "CloseSharedResources") : null);
				if (Tracing.On)
				{
					Tracing.Enter("RemoteDebugger", caller);
				}
				try
				{
					Marshal.ReleaseComObject(connection);
				}
				catch (Exception ex)
				{
					if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
					{
						throw;
					}
					if (Tracing.On)
					{
						Tracing.ExceptionCatch(TraceEventType.Warning, typeof(RemoteDebugger), "CloseSharedResources", ex);
					}
				}
				catch
				{
				}
				if (Tracing.On)
				{
					Tracing.Exit("RemoteDebugger", caller);
				}
				connection = null;
			}
		}

		private void Close()
		{
			if (notifySink == null || connection == null)
			{
				return;
			}
			lock (InternalSyncObject)
			{
				if (notifySink == null || connection == null)
				{
					return;
				}
				TraceMethod traceMethod = (Tracing.On ? new TraceMethod(this, "Close") : null);
				if (Tracing.On)
				{
					Tracing.Enter("RemoteDebugger", traceMethod);
				}
				try
				{
					UnsafeNativeMethods.UnregisterNotifySource(connection, this);
				}
				catch (Exception ex)
				{
					if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
					{
						throw;
					}
					if (Tracing.On)
					{
						Tracing.ExceptionCatch(TraceEventType.Warning, traceMethod, ex);
					}
				}
				catch
				{
				}
				if (Tracing.On)
				{
					Tracing.Exit("RemoteDebugger", traceMethod);
				}
				notifySink = null;
			}
		}

		[DebuggerHidden]
		[DebuggerStepThrough]
		internal void NotifyClientCallOut(WebRequest request)
		{
			try
			{
				if (NotifySink == null)
				{
					return;
				}
				int inout_pBufferSize = 0;
				CallId callId = new CallId(null, 0, (IntPtr)0, 0L, null, request.RequestUri.Host);
				TraceMethod caller = (Tracing.On ? new TraceMethod(this, "NotifyClientCallOut") : null);
				if (Tracing.On)
				{
					Tracing.Enter("RemoteDebugger", caller);
				}
				UnsafeNativeMethods.OnSyncCallOut(NotifySink, callId, out var out_ppBuffer, ref inout_pBufferSize);
				if (Tracing.On)
				{
					Tracing.Exit("RemoteDebugger", caller);
				}
				if (!(out_ppBuffer == IntPtr.Zero))
				{
					byte[] array = null;
					try
					{
						array = new byte[inout_pBufferSize];
						Marshal.Copy(out_ppBuffer, array, 0, inout_pBufferSize);
					}
					finally
					{
						Marshal.FreeCoTaskMem(out_ppBuffer);
					}
					string value = Convert.ToBase64String(array);
					request.Headers.Add(debuggerHeader, value);
				}
			}
			catch (Exception ex)
			{
				if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
				{
					throw;
				}
				if (Tracing.On)
				{
					Tracing.ExceptionCatch(TraceEventType.Warning, typeof(RemoteDebugger), "NotifyClientCallOut", ex);
				}
			}
			catch
			{
			}
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal void NotifyClientCallReturn(WebResponse response)
		{
			try
			{
				if (NotifySink == null)
				{
					return;
				}
				byte[] array = new byte[0];
				if (response != null)
				{
					string text = response.Headers[debuggerHeader];
					if (text != null && text.Length != 0)
					{
						array = Convert.FromBase64String(text);
					}
				}
				CallId callId = new CallId(null, 0, (IntPtr)0, 0L, null, null);
				TraceMethod caller = (Tracing.On ? new TraceMethod(this, "NotifyClientCallReturn") : null);
				if (Tracing.On)
				{
					Tracing.Enter("RemoteDebugger", caller);
				}
				UnsafeNativeMethods.OnSyncCallReturn(NotifySink, callId, array, array.Length);
				if (Tracing.On)
				{
					Tracing.Exit("RemoteDebugger", caller);
				}
			}
			catch (Exception ex)
			{
				if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
				{
					throw;
				}
				if (Tracing.On)
				{
					Tracing.ExceptionCatch(TraceEventType.Warning, typeof(RemoteDebugger), "NotifyClientCallReturn", ex);
				}
			}
			catch
			{
			}
			Close();
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal void NotifyServerCallEnter(ServerProtocol protocol, string stringBuffer)
		{
			try
			{
				if (NotifySink == null)
				{
					return;
				}
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.Append(protocol.Type.FullName);
				stringBuilder.Append('.');
				stringBuilder.Append(protocol.MethodInfo.Name);
				stringBuilder.Append('(');
				ParameterInfo[] parameters = protocol.MethodInfo.Parameters;
				for (int i = 0; i < parameters.Length; i++)
				{
					if (i != 0)
					{
						stringBuilder.Append(',');
					}
					stringBuilder.Append(parameters[i].ParameterType.FullName);
				}
				stringBuilder.Append(')');
				byte[] array = Convert.FromBase64String(stringBuffer);
				CallId callId = new CallId(null, 0, (IntPtr)0, 0L, stringBuilder.ToString(), null);
				TraceMethod caller = (Tracing.On ? new TraceMethod(this, "NotifyServerCallEnter") : null);
				if (Tracing.On)
				{
					Tracing.Enter("RemoteDebugger", caller);
				}
				UnsafeNativeMethods.OnSyncCallEnter(NotifySink, callId, array, array.Length);
				if (Tracing.On)
				{
					Tracing.Exit("RemoteDebugger", caller);
				}
			}
			catch (Exception ex)
			{
				if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
				{
					throw;
				}
				if (Tracing.On)
				{
					Tracing.ExceptionCatch(TraceEventType.Warning, typeof(RemoteDebugger), "NotifyServerCallEnter", ex);
				}
			}
			catch
			{
			}
		}

		[DebuggerHidden]
		[DebuggerStepThrough]
		internal void NotifyServerCallExit(HttpResponse response)
		{
			try
			{
				if (NotifySink == null)
				{
					return;
				}
				int inout_pBufferSize = 0;
				CallId callId = new CallId(null, 0, (IntPtr)0, 0L, null, null);
				TraceMethod caller = (Tracing.On ? new TraceMethod(this, "NotifyServerCallExit") : null);
				if (Tracing.On)
				{
					Tracing.Enter("RemoteDebugger", caller);
				}
				UnsafeNativeMethods.OnSyncCallExit(NotifySink, callId, out var out_ppBuffer, ref inout_pBufferSize);
				if (Tracing.On)
				{
					Tracing.Exit("RemoteDebugger", caller);
				}
				if (out_ppBuffer == IntPtr.Zero)
				{
					return;
				}
				byte[] array = null;
				try
				{
					array = new byte[inout_pBufferSize];
					Marshal.Copy(out_ppBuffer, array, 0, inout_pBufferSize);
				}
				finally
				{
					Marshal.FreeCoTaskMem(out_ppBuffer);
				}
				string value = Convert.ToBase64String(array);
				response.AddHeader(debuggerHeader, value);
			}
			catch (Exception ex)
			{
				if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
				{
					throw;
				}
				if (Tracing.On)
				{
					Tracing.ExceptionCatch(TraceEventType.Warning, typeof(RemoteDebugger), "NotifyServerCallExit", ex);
				}
			}
			catch
			{
			}
			Close();
		}

		private static void OnAppDomainUnload(object sender, EventArgs args)
		{
			CloseSharedResources();
		}

		private static void OnProcessExit(object sender, EventArgs args)
		{
			CloseSharedResources();
		}

		void INotifySource2.SetNotifyFilter(NotifyFilter in_NotifyFilter, UserThread in_pUserThreadFilter)
		{
			notifyFilter = in_NotifyFilter;
			userThread = in_pUserThreadFilter;
		}
	}
	internal class RequestResponseUtils
	{
		private static class HttpUtility
		{
			private static class HtmlEntities
			{
				private static object _lookupLockObject = new object();

				private static string[] _entitiesList = new string[252]
				{
					"\"-quot", "&-amp", "<-lt", ">-gt", "\u00a0-nbsp", "¡-iexcl", "¢-cent", "£-pound", "¤-curren", "¥-yen",
					"¦-brvbar", "§-sect", "\u00a8-uml", "©-copy", "ª-ordf", "«-laquo", "¬-not", "­-shy", "®-reg", "\u00af-macr",
					"°-deg", "±-plusmn", "²-sup2", "³-sup3", "\u00b4-acute", "µ-micro", "¶-para", "·-middot", "\u00b8-cedil", "¹-sup1",
					"º-ordm", "»-raquo", "¼-frac14", "½-frac12", "¾-frac34", "¿-iquest", "À-Agrave", "Á-Aacute", "Â-Acirc", "Ã-Atilde",
					"Ä-Auml", "Å-Aring", "Æ-AElig", "Ç-Ccedil", "È-Egrave", "É-Eacute", "Ê-Ecirc", "Ë-Euml", "Ì-Igrave", "Í-Iacute",
					"Î-Icirc", "Ï-Iuml", "Ð-ETH", "Ñ-Ntilde", "Ò-Ograve", "Ó-Oacute", "Ô-Ocirc", "Õ-Otilde", "Ö-Ouml", "×-times",
					"Ø-Oslash", "Ù-Ugrave", "Ú-Uacute", "Û-Ucirc", "Ü-Uuml", "Ý-Yacute", "Þ-THORN", "ß-szlig", "à-agrave", "á-aacute",
					"â-acirc", "ã-atilde", "ä-auml", "å-aring", "æ-aelig", "ç-ccedil", "è-egrave", "é-eacute", "ê-ecirc", "ë-euml",
					"ì-igrave", "í-iacute", "î-icirc", "ï-iuml", "ð-eth", "ñ-ntilde", "ò-ograve", "ó-oacute", "ô-ocirc", "õ-otilde",
					"ö-ouml", "÷-divide", "ø-oslash", "ù-ugrave", "ú-uacute", "û-ucirc", "ü-uuml", "ý-yacute", "þ-thorn", "ÿ-yuml",
					"Œ-OElig", "œ-oelig", "Š-Scaron", "š-scaron", "Ÿ-Yuml", "ƒ-fnof", "ˆ-circ", "\u02dc-tilde", "Α-Alpha", "Β-Beta",
					"Γ-Gamma", "Δ-Delta", "Ε-Epsilon", "Ζ-Zeta", "Η-Eta", "Θ-Theta", "Ι-Iota", "Κ-Kappa", "Λ-Lambda", "Μ-Mu",
					"Ν-Nu", "Ξ-Xi", "Ο-Omicron", "Π-Pi", "Ρ-Rho", "Σ-Sigma", "Τ-Tau", "Υ-Upsilon", "Φ-Phi", "Χ-Chi",
					"Ψ-Psi", "Ω-Omega", "α-alpha", "β-beta", "γ-gamma", "δ-delta", "ε-epsilon", "ζ-zeta", "η-eta", "θ-theta",
					"ι-iota", "κ-kappa", "λ-lambda", "μ-mu", "ν-nu", "ξ-xi", "ο-omicron", "π-pi", "ρ-rho", "ς-sigmaf",
					"σ-sigma", "τ-tau", "υ-upsilon", "φ-phi", "χ-chi", "ψ-psi", "ω-omega", "ϑ-thetasym", "ϒ-upsih", "ϖ-piv",
					"\u2002-ensp", "\u2003-emsp", "\u2009-thinsp", "\u200c-zwnj", "\u200d-zwj", "\u200e-lrm", "\u200f-rlm", "–-ndash", "—-mdash", "‘-lsquo",
					"’-rsquo", "‚-sbquo", "“-ldquo", "”-rdquo", "„-bdquo", "†-dagger", "‡-Dagger", "•-bull", "…-hellip", "‰-permil",
					"′-prime", "″-Prime", "‹-lsaquo", "›-rsaquo", "‾-oline", "⁄-frasl", "€-euro", "ℑ-image", "℘-weierp", "ℜ-real",
					"™-trade", "ℵ-alefsym", "←-larr", "↑-uarr", "→-rarr", "↓-darr", "↔-harr", "↵-crarr", "⇐-lArr", "⇑-uArr",
					"⇒-rArr", "⇓-dArr", "⇔-hArr", "∀-forall", "∂-part", "∃-exist", "∅-empty", "∇-nabla", "∈-isin", "∉-notin",
					"∋-ni", "∏-prod", "∑-sum", "−-minus", "∗-lowast", "√-radic", "∝-prop", "∞-infin", "∠-ang", "∧-and",
					"∨-or", "∩-cap", "∪-cup", "∫-int", "∴-there4", "∼-sim", "≅-cong", "≈-asymp", "≠-ne", "≡-equiv",
					"≤-le", "≥-ge", "⊂-sub", "⊃-sup", "⊄-nsub", "⊆-sube", "⊇-supe", "⊕-oplus", "⊗-otimes", "⊥-perp",
					"⋅-sdot", "⌈-lceil", "⌉-rceil", "⌊-lfloor", "⌋-rfloor", "〈-lang", "〉-rang", "◊-loz", "♠-spades", "♣-clubs",
					"♥-hearts", "♦-diams"
				};

				private static Hashtable _entitiesLookupTable;

				internal static char Lookup(string entity)
				{
					if (_entitiesLookupTable == null)
					{
						lock (_lookupLockObject)
						{
							if (_entitiesLookupTable == null)
							{
								Hashtable hashtable = new Hashtable();
								string[] entitiesList = _entitiesList;
								foreach (string text in entitiesList)
								{
									hashtable[text.Substring(2)] = text[0];
								}
								_entitiesLookupTable = hashtable;
							}
						}
					}
					object obj = _entitiesLookupTable[entity];
					if (obj != null)
					{
						return (char)obj;
					}
					return '\0';
				}
			}

			private static char[] s_entityEndingChars = new char[2] { ';', '&' };

			internal static string HtmlDecode(string s)
			{
				if (s == null)
				{
					return null;
				}
				if (s.IndexOf('&') < 0)
				{
					return s;
				}
				StringBuilder stringBuilder = new StringBuilder();
				StringWriter output = new StringWriter(stringBuilder, CultureInfo.InvariantCulture);
				HtmlDecode(s, output);
				return stringBuilder.ToString();
			}

			public static void HtmlDecode(string s, TextWriter output)
			{
				if (s == null)
				{
					return;
				}
				if (s.IndexOf('&') < 0)
				{
					output.Write(s);
					return;
				}
				int length = s.Length;
				for (int i = 0; i < length; i++)
				{
					char c = s[i];
					if (c == '&')
					{
						int num = s.IndexOfAny(s_entityEndingChars, i + 1);
						if (num > 0 && s[num] == ';')
						{
							string text = s.Substring(i + 1, num - i - 1);
							if (text.Length > 1 && text[0] == '#')
							{
								try
								{
									c = ((text[1] != 'x' && text[1] != 'X') ? ((char)int.Parse(text.Substring(1), CultureInfo.InvariantCulture)) : ((char)int.Parse(text.Substring(2), NumberStyles.AllowHexSpecifier, CultureInfo.InvariantCulture)));
									i = num;
								}
								catch (FormatException e)
								{
									i++;
									if (Tracing.On)
									{
										Tracing.ExceptionCatch(TraceEventType.Warning, typeof(HttpUtility), "HtmlDecode", e);
									}
								}
								catch (ArgumentException e2)
								{
									i++;
									if (Tracing.On)
									{
										Tracing.ExceptionCatch(TraceEventType.Warning, typeof(HttpUtility), "HtmlDecode", e2);
									}
								}
							}
							else
							{
								i = num;
								char c2 = HtmlEntities.Lookup(text);
								if (c2 == '\0')
								{
									output.Write('&');
									output.Write(text);
									output.Write(';');
									continue;
								}
								c = c2;
							}
						}
					}
					output.Write(c);
				}
			}
		}

		private RequestResponseUtils()
		{
		}

		internal static Encoding GetEncoding(string contentType)
		{
			string charset = ContentType.GetCharset(contentType);
			Encoding encoding = null;
			try
			{
				if (charset != null && charset.Length > 0)
				{
					encoding = Encoding.GetEncoding(charset);
				}
			}
			catch (Exception ex)
			{
				if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
				{
					throw;
				}
				if (Tracing.On)
				{
					Tracing.ExceptionCatch(TraceEventType.Warning, typeof(RequestResponseUtils), "GetEncoding", ex);
				}
			}
			catch
			{
			}
			if (encoding != null)
			{
				return encoding;
			}
			return new ASCIIEncoding();
		}

		internal static Encoding GetEncoding2(string contentType)
		{
			if (!ContentType.IsApplication(contentType))
			{
				return GetEncoding(contentType);
			}
			string charset = ContentType.GetCharset(contentType);
			Encoding result = null;
			try
			{
				if (charset != null)
				{
					if (charset.Length > 0)
					{
						result = Encoding.GetEncoding(charset);
						return result;
					}
					return result;
				}
				return result;
			}
			catch (Exception ex)
			{
				if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
				{
					throw;
				}
				if (Tracing.On)
				{
					Tracing.ExceptionCatch(TraceEventType.Warning, typeof(RequestResponseUtils), "GetEncoding2", ex);
					return result;
				}
				return result;
			}
			catch
			{
				return result;
			}
		}

		internal static string ReadResponse(WebResponse response)
		{
			return ReadResponse(response, response.GetResponseStream());
		}

		internal static string ReadResponse(WebResponse response, Stream stream)
		{
			Encoding encoding = GetEncoding(response.ContentType);
			if (encoding == null)
			{
				encoding = Encoding.Default;
			}
			StreamReader streamReader = new StreamReader(stream, encoding, detectEncodingFromByteOrderMarks: true);
			try
			{
				return streamReader.ReadToEnd();
			}
			finally
			{
				stream.Close();
			}
		}

		internal static Stream StreamToMemoryStream(Stream stream)
		{
			MemoryStream memoryStream = new MemoryStream(1024);
			byte[] array = new byte[1024];
			int count;
			while ((count = stream.Read(array, 0, array.Length)) != 0)
			{
				memoryStream.Write(array, 0, count);
			}
			memoryStream.Position = 0L;
			return memoryStream;
		}

		internal static string CreateResponseExceptionString(WebResponse response)
		{
			return CreateResponseExceptionString(response, response.GetResponseStream());
		}

		internal static string CreateResponseExceptionString(WebResponse response, Stream stream)
		{
			if (response is HttpWebResponse)
			{
				HttpWebResponse httpWebResponse = (HttpWebResponse)response;
				int statusCode = (int)httpWebResponse.StatusCode;
				if (statusCode >= 400 && statusCode != 500)
				{
					return Res.GetString("WebResponseKnownError", statusCode, httpWebResponse.StatusDescription);
				}
			}
			string text = ((stream != null) ? ReadResponse(response, stream) : string.Empty);
			if (text.Length > 0)
			{
				text = HttpUtility.HtmlDecode(text);
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.Append(Res.GetString("WebResponseUnknownError"));
				stringBuilder.Append(Environment.NewLine);
				stringBuilder.Append("--");
				stringBuilder.Append(Environment.NewLine);
				stringBuilder.Append(text);
				stringBuilder.Append(Environment.NewLine);
				stringBuilder.Append("--");
				stringBuilder.Append(".");
				return stringBuilder.ToString();
			}
			return Res.GetString("WebResponseUnknownErrorEmptyBody");
		}

		internal static int GetBufferSize(int contentLength)
		{
			if (contentLength == -1)
			{
				return 8000;
			}
			if (contentLength <= 16000)
			{
				return contentLength;
			}
			return 16000;
		}
	}
	internal class RuntimeUtils
	{
		private RuntimeUtils()
		{
		}

		internal static XmlDeserializationEvents GetDeserializationEvents()
		{
			XmlDeserializationEvents result = default(XmlDeserializationEvents);
			result.OnUnknownElement = OnUnknownElement;
			result.OnUnknownAttribute = OnUnknownAttribute;
			return result;
		}

		private static void OnUnknownAttribute(object sender, XmlAttributeEventArgs e)
		{
			if (e.Attr == null || IsKnownNamespace(e.Attr.NamespaceURI))
			{
				return;
			}
			Tracing.OnUnknownAttribute(sender, e);
			if (e.ExpectedAttributes == null)
			{
				throw new InvalidOperationException(Res.GetString("WebUnknownAttribute", e.Attr.Name, e.Attr.Value));
			}
			if (e.ExpectedAttributes.Length == 0)
			{
				throw new InvalidOperationException(Res.GetString("WebUnknownAttribute2", e.Attr.Name, e.Attr.Value));
			}
			throw new InvalidOperationException(Res.GetString("WebUnknownAttribute3", e.Attr.Name, e.Attr.Value, e.ExpectedAttributes));
		}

		internal static string ElementString(XmlElement element)
		{
			StringWriter stringWriter = new StringWriter(CultureInfo.InvariantCulture);
			stringWriter.Write("<");
			stringWriter.Write(element.Name);
			if (element.NamespaceURI != null && element.NamespaceURI.Length > 0)
			{
				stringWriter.Write(" xmlns");
				if (element.Prefix != null && element.Prefix.Length > 0)
				{
					stringWriter.Write(":");
					stringWriter.Write(element.Prefix);
				}
				stringWriter.Write("='");
				stringWriter.Write(element.NamespaceURI);
				stringWriter.Write("'");
			}
			stringWriter.Write(">..</");
			stringWriter.Write(element.Name);
			stringWriter.Write(">");
			return stringWriter.ToString();
		}

		internal static void OnUnknownElement(object sender, XmlElementEventArgs e)
		{
			if (e.Element == null)
			{
				return;
			}
			string text = ElementString(e.Element);
			Tracing.OnUnknownElement(sender, e);
			if (e.ExpectedElements == null)
			{
				throw new InvalidOperationException(Res.GetString("WebUnknownElement", text));
			}
			if (e.ExpectedElements.Length == 0)
			{
				throw new InvalidOperationException(Res.GetString("WebUnknownElement1", text));
			}
			throw new InvalidOperationException(Res.GetString("WebUnknownElement2", text, e.ExpectedElements));
		}

		internal static bool IsKnownNamespace(string ns)
		{
			switch (ns)
			{
			case "http://www.w3.org/2001/XMLSchema-instance":
				return true;
			case "http://www.w3.org/XML/1998/namespace":
				return true;
			case "http://schemas.xmlsoap.org/soap/encoding/":
			case "http://schemas.xmlsoap.org/soap/envelope/":
				return true;
			case "http://www.w3.org/2003/05/soap-envelope":
			case "http://www.w3.org/2003/05/soap-encoding":
			case "http://www.w3.org/2003/05/soap-rpc":
				return true;
			default:
				return false;
			}
		}
	}
	internal class ScalarFormatter
	{
		private ScalarFormatter()
		{
		}

		internal static string ToString(object value)
		{
			if (value == null)
			{
				return string.Empty;
			}
			if (value is string)
			{
				return (string)value;
			}
			if (value.GetType().IsEnum)
			{
				return EnumToString(value);
			}
			return Convert.ToString(value, CultureInfo.InvariantCulture);
		}

		internal static object FromString(string value, Type type)
		{
			try
			{
				if (type == typeof(string))
				{
					return value;
				}
				if (type.IsEnum)
				{
					return EnumFromString(value, type);
				}
				return Convert.ChangeType(value, type, CultureInfo.InvariantCulture);
			}
			catch (Exception ex)
			{
				if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
				{
					throw;
				}
				throw new ArgumentException(Res.GetString("WebChangeTypeFailed", value, type.FullName), "type", ex);
			}
			catch
			{
				throw new ArgumentException(Res.GetString("WebChangeTypeFailed", value, type.FullName), "type", null);
			}
		}

		private static object EnumFromString(string value, Type type)
		{
			return Enum.Parse(type, value);
		}

		private static string EnumToString(object value)
		{
			return Enum.Format(value.GetType(), value, "G");
		}

		internal static bool IsTypeSupported(Type type)
		{
			if (type.IsEnum)
			{
				return true;
			}
			if (type != typeof(int) && type != typeof(string) && type != typeof(long) && type != typeof(byte) && type != typeof(sbyte) && type != typeof(short) && type != typeof(bool) && type != typeof(char) && type != typeof(float) && type != typeof(decimal) && type != typeof(DateTime) && type != typeof(ushort) && type != typeof(uint) && type != typeof(ulong))
			{
				return type == typeof(double);
			}
			return true;
		}
	}
	internal class UrlEncoder
	{
		private const int Max16BitUtf8SequenceLength = 4;

		internal static readonly char[] HexUpperChars = new char[16]
		{
			'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
			'A', 'B', 'C', 'D', 'E', 'F'
		};

		private UrlEncoder()
		{
		}

		internal static string EscapeString(string s, Encoding e)
		{
			return EscapeStringInternal(s, (e == null) ? new ASCIIEncoding() : e, escapeUriStuff: false);
		}

		internal static string UrlEscapeString(string s, Encoding e)
		{
			return EscapeStringInternal(s, (e == null) ? new ASCIIEncoding() : e, escapeUriStuff: true);
		}

		private static string EscapeStringInternal(string s, Encoding e, bool escapeUriStuff)
		{
			if (s == null)
			{
				return null;
			}
			byte[] bytes = e.GetBytes(s);
			StringBuilder stringBuilder = new StringBuilder(bytes.Length);
			foreach (byte b in bytes)
			{
				char c = (char)b;
				if (b > 127 || b < 32 || c == '%' || (escapeUriStuff && !IsSafe(c)))
				{
					HexEscape8(stringBuilder, c);
				}
				else
				{
					stringBuilder.Append(c);
				}
			}
			return stringBuilder.ToString();
		}

		internal static string UrlEscapeStringUnicode(string s)
		{
			int length = s.Length;
			StringBuilder stringBuilder = new StringBuilder(length);
			for (int i = 0; i < length; i++)
			{
				char c = s[i];
				if (IsSafe(c))
				{
					stringBuilder.Append(c);
				}
				else if (c == ' ')
				{
					stringBuilder.Append('+');
				}
				else if ((c & 0xFF80) == 0)
				{
					HexEscape8(stringBuilder, c);
				}
				else
				{
					HexEscape16(stringBuilder, c);
				}
			}
			return stringBuilder.ToString();
		}

		private static void HexEscape8(StringBuilder sb, char c)
		{
			sb.Append('%');
			sb.Append(HexUpperChars[((int)c >> 4) & 0xF]);
			sb.Append(HexUpperChars[c & 0xF]);
		}

		private static void HexEscape16(StringBuilder sb, char c)
		{
			sb.Append("%u");
			sb.Append(HexUpperChars[((int)c >> 12) & 0xF]);
			sb.Append(HexUpperChars[((int)c >> 8) & 0xF]);
			sb.Append(HexUpperChars[((int)c >> 4) & 0xF]);
			sb.Append(HexUpperChars[c & 0xF]);
		}

		private static bool IsSafe(char ch)
		{
			if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9'))
			{
				return true;
			}
			switch (ch)
			{
			case '!':
			case '\'':
			case '(':
			case ')':
			case '*':
			case '-':
			case '.':
			case '_':
				return true;
			default:
				return false;
			}
		}
	}
	internal class ContentType
	{
		internal const string TextBase = "text";

		internal const string TextXml = "text/xml";

		internal const string TextPlain = "text/plain";

		internal const string TextHtml = "text/html";

		internal const string ApplicationBase = "application";

		internal const string ApplicationXml = "application/xml";

		internal const string ApplicationSoap = "application/soap+xml";

		internal const string ApplicationOctetStream = "application/octet-stream";

		internal const string ContentEncoding = "Content-Encoding";

		private ContentType()
		{
		}

		internal static string GetBase(string contentType)
		{
			int num = contentType.IndexOf(';');
			if (num >= 0)
			{
				return contentType.Substring(0, num);
			}
			return contentType;
		}

		internal static string GetMediaType(string contentType)
		{
			string @base = GetBase(contentType);
			int num = @base.IndexOf('/');
			if (num >= 0)
			{
				return @base.Substring(0, num);
			}
			return @base;
		}

		internal static string GetCharset(string contentType)
		{
			return GetParameter(contentType, "charset");
		}

		internal static string GetAction(string contentType)
		{
			return GetParameter(contentType, "action");
		}

		private static string GetParameter(string contentType, string paramName)
		{
			string[] array = contentType.Split(';');
			for (int i = 1; i < array.Length; i++)
			{
				string text = array[i].TrimStart(null);
				if (string.Compare(text, 0, paramName, 0, paramName.Length, StringComparison.OrdinalIgnoreCase) == 0)
				{
					int num = text.IndexOf('=', paramName.Length);
					if (num >= 0)
					{
						return text.Substring(num + 1).Trim(' ', '\'', '"', '\t');
					}
				}
			}
			return null;
		}

		internal static bool MatchesBase(string contentType, string baseContentType)
		{
			return string.Compare(GetBase(contentType), baseContentType, StringComparison.OrdinalIgnoreCase) == 0;
		}

		internal static bool IsApplication(string contentType)
		{
			return string.Compare(GetMediaType(contentType), "application", StringComparison.OrdinalIgnoreCase) == 0;
		}

		internal static bool IsSoap(string contentType)
		{
			string @base = GetBase(contentType);
			if (string.Compare(@base, "text/xml", StringComparison.OrdinalIgnoreCase) != 0)
			{
				return string.Compare(@base, "application/soap+xml", StringComparison.OrdinalIgnoreCase) == 0;
			}
			return true;
		}

		internal static bool IsXml(string contentType)
		{
			string @base = GetBase(contentType);
			if (string.Compare(@base, "text/xml", StringComparison.OrdinalIgnoreCase) != 0)
			{
				return string.Compare(@base, "application/xml", StringComparison.OrdinalIgnoreCase) == 0;
			}
			return true;
		}

		internal static bool IsHtml(string contentType)
		{
			string @base = GetBase(contentType);
			return string.Compare(@base, "text/html", StringComparison.OrdinalIgnoreCase) == 0;
		}

		internal static string Compose(string contentType, Encoding encoding)
		{
			return Compose(contentType, encoding, null);
		}

		internal static string Compose(string contentType, Encoding encoding, string action)
		{
			if (encoding == null && action == null)
			{
				return contentType;
			}
			StringBuilder stringBuilder = new StringBuilder(contentType);
			if (encoding != null)
			{
				stringBuilder.Append("; charset=");
				stringBuilder.Append(encoding.WebName);
			}
			if (action != null)
			{
				stringBuilder.Append("; action=\"");
				stringBuilder.Append(action);
				stringBuilder.Append("\"");
			}
			return stringBuilder.ToString();
		}
	}
	internal class MemberHelper
	{
		private static object[] emptyObjectArray = new object[0];

		private MemberHelper()
		{
		}

		internal static void SetValue(MemberInfo memberInfo, object target, object value)
		{
			if (memberInfo is FieldInfo)
			{
				((FieldInfo)memberInfo).SetValue(target, value);
			}
			else
			{
				((PropertyInfo)memberInfo).SetValue(target, value, emptyObjectArray);
			}
		}

		internal static object GetValue(MemberInfo memberInfo, object target)
		{
			if (memberInfo is FieldInfo)
			{
				return ((FieldInfo)memberInfo).GetValue(target);
			}
			return ((PropertyInfo)memberInfo).GetValue(target, emptyObjectArray);
		}

		internal static bool IsStatic(MemberInfo memberInfo)
		{
			if (memberInfo is FieldInfo)
			{
				return ((FieldInfo)memberInfo).IsStatic;
			}
			return false;
		}

		internal static bool CanRead(MemberInfo memberInfo)
		{
			if (memberInfo is FieldInfo)
			{
				return true;
			}
			return ((PropertyInfo)memberInfo).CanRead;
		}

		internal static bool CanWrite(MemberInfo memberInfo)
		{
			if (memberInfo is FieldInfo)
			{
				return true;
			}
			return ((PropertyInfo)memberInfo).CanWrite;
		}
	}
	internal abstract class SoapServerProtocolHelper
	{
		private SoapServerProtocol protocol;

		private string requestNamespace;

		internal abstract SoapProtocolVersion Version { get; }

		internal abstract WebServiceProtocols Protocol { get; }

		internal abstract string EnvelopeNs { get; }

		internal abstract string EncodingNs { get; }

		internal abstract string HttpContentType { get; }

		internal string RequestNamespace => requestNamespace;

		protected SoapServerProtocol ServerProtocol => protocol;

		protected SoapServerType ServerType => (SoapServerType)protocol.ServerType;

		protected SoapServerProtocolHelper(SoapServerProtocol protocol)
		{
			this.protocol = protocol;
		}

		protected SoapServerProtocolHelper(SoapServerProtocol protocol, string requestNamespace)
		{
			this.protocol = protocol;
			this.requestNamespace = requestNamespace;
		}

		internal static SoapServerProtocolHelper GetHelper(SoapServerProtocol protocol, string envelopeNs)
		{
			if (envelopeNs == "http://schemas.xmlsoap.org/soap/envelope/")
			{
				return new Soap11ServerProtocolHelper(protocol, envelopeNs);
			}
			if (envelopeNs == "http://www.w3.org/2003/05/soap-envelope")
			{
				return new Soap12ServerProtocolHelper(protocol, envelopeNs);
			}
			return new Soap11ServerProtocolHelper(protocol, envelopeNs);
		}

		internal HttpStatusCode SetResponseErrorCode(HttpResponse response, SoapException soapException)
		{
			if (soapException.SubCode != null && soapException.SubCode.Code == Soap12FaultCodes.UnsupportedMediaTypeFaultCode)
			{
				response.StatusCode = 415;
				soapException.ClearSubCode();
			}
			else if (SoapException.IsClientFaultCode(soapException.Code))
			{
				System.Web.Services.Protocols.ServerProtocol.SetHttpResponseStatusCode(response, 500);
				for (Exception ex = soapException; ex != null; ex = ex.InnerException)
				{
					if (ex is XmlException)
					{
						response.StatusCode = 400;
					}
				}
			}
			else
			{
				System.Web.Services.Protocols.ServerProtocol.SetHttpResponseStatusCode(response, 500);
			}
			response.StatusDescription = HttpWorkerRequest.GetStatusDescription(response.StatusCode);
			return (HttpStatusCode)response.StatusCode;
		}

		internal abstract void WriteFault(XmlWriter writer, SoapException soapException, HttpStatusCode statusCode);

		internal abstract SoapServerMethod RouteRequest();

		protected XmlQualifiedName GetRequestElement()
		{
			SoapServerMessage message = ServerProtocol.Message;
			long position = message.Stream.Position;
			XmlReader xmlReader = protocol.GetXmlReader();
			xmlReader.MoveToContent();
			requestNamespace = xmlReader.NamespaceURI;
			if (!xmlReader.IsStartElement("Envelope", requestNamespace))
			{
				throw new InvalidOperationException(Res.GetString("WebMissingEnvelopeElement"));
			}
			if (xmlReader.IsEmptyElement)
			{
				throw new InvalidOperationException(Res.GetString("WebMissingBodyElement"));
			}
			xmlReader.ReadStartElement("Envelope", requestNamespace);
			xmlReader.MoveToContent();
			while (!xmlReader.EOF && !xmlReader.IsStartElement("Body", requestNamespace))
			{
				xmlReader.Skip();
			}
			if (xmlReader.EOF)
			{
				throw new InvalidOperationException(Res.GetString("WebMissingBodyElement"));
			}
			XmlQualifiedName result;
			if (xmlReader.IsEmptyElement)
			{
				result = XmlQualifiedName.Empty;
			}
			else
			{
				xmlReader.ReadStartElement("Body", requestNamespace);
				xmlReader.MoveToContent();
				result = new XmlQualifiedName(xmlReader.LocalName, xmlReader.NamespaceURI);
			}
			message.Stream.Position = position;
			return result;
		}
	}
	internal class Soap11ServerProtocolHelper : SoapServerProtocolHelper
	{
		internal override SoapProtocolVersion Version => SoapProtocolVersion.Soap11;

		internal override WebServiceProtocols Protocol => WebServiceProtocols.HttpSoap;

		internal override string EnvelopeNs => "http://schemas.xmlsoap.org/soap/envelope/";

		internal override string EncodingNs => "http://schemas.xmlsoap.org/soap/encoding/";

		internal override string HttpContentType => "text/xml";

		internal Soap11ServerProtocolHelper(SoapServerProtocol protocol)
			: base(protocol)
		{
		}

		internal Soap11ServerProtocolHelper(SoapServerProtocol protocol, string requestNamespace)
			: base(protocol, requestNamespace)
		{
		}

		internal override SoapServerMethod RouteRequest()
		{
			string text = base.ServerProtocol.Request.Headers["SOAPAction"];
			if (text == null)
			{
				throw new SoapException(Res.GetString("UnableToHandleRequestActionRequired0"), new XmlQualifiedName("Client", "http://schemas.xmlsoap.org/soap/envelope/"));
			}
			object obj;
			if (base.ServerType.routingOnSoapAction)
			{
				if (text.StartsWith("\"", StringComparison.Ordinal) && text.EndsWith("\"", StringComparison.Ordinal))
				{
					text = text.Substring(1, text.Length - 2);
				}
				obj = HttpUtility.UrlDecode(text);
			}
			else
			{
				try
				{
					obj = GetRequestElement();
				}
				catch (SoapException)
				{
					throw;
				}
				catch (Exception ex2)
				{
					if (ex2 is ThreadAbortException || ex2 is StackOverflowException || ex2 is OutOfMemoryException)
					{
						throw;
					}
					throw new SoapException(Res.GetString("TheRootElementForTheRequestCouldNotBeDetermined0"), new XmlQualifiedName("Server", "http://schemas.xmlsoap.org/soap/envelope/"), ex2);
				}
				catch
				{
					throw new SoapException(Res.GetString("TheRootElementForTheRequestCouldNotBeDetermined0"), new XmlQualifiedName("Server", "http://schemas.xmlsoap.org/soap/envelope/"), (Exception)null);
				}
			}
			TraceMethod caller = (Tracing.On ? new TraceMethod(this, "RouteRequest") : null);
			if (Tracing.On)
			{
				Tracing.Enter("RouteRequest", caller, new TraceMethod(base.ServerType, "GetMethod", obj), Tracing.Details(base.ServerProtocol.Request));
			}
			SoapServerMethod method = base.ServerType.GetMethod(obj);
			if (Tracing.On)
			{
				Tracing.Exit("RouteRequest", caller);
			}
			if (method == null)
			{
				if (base.ServerType.routingOnSoapAction)
				{
					throw new SoapException(Res.GetString("WebHttpHeader", "SOAPAction", (string)obj), new XmlQualifiedName("Client", "http://schemas.xmlsoap.org/soap/envelope/"));
				}
				throw new SoapException(Res.GetString("TheRequestElementXmlnsWasNotRecognized2", ((XmlQualifiedName)obj).Name, ((XmlQualifiedName)obj).Namespace), new XmlQualifiedName("Client", "http://schemas.xmlsoap.org/soap/envelope/"));
			}
			return method;
		}

		internal override void WriteFault(XmlWriter writer, SoapException soapException, HttpStatusCode statusCode)
		{
			if (statusCode != HttpStatusCode.InternalServerError || soapException == null)
			{
				return;
			}
			SoapServerMessage message = base.ServerProtocol.Message;
			writer.WriteStartDocument();
			writer.WriteStartElement("soap", "Envelope", "http://schemas.xmlsoap.org/soap/envelope/");
			writer.WriteAttributeString("xmlns", "soap", null, "http://schemas.xmlsoap.org/soap/envelope/");
			writer.WriteAttributeString("xmlns", "xsi", null, "http://www.w3.org/2001/XMLSchema-instance");
			writer.WriteAttributeString("xmlns", "xsd", null, "http://www.w3.org/2001/XMLSchema");
			if (base.ServerProtocol.ServerMethod != null)
			{
				SoapHeaderHandling.WriteHeaders(writer, base.ServerProtocol.ServerMethod.outHeaderSerializer, message.Headers, base.ServerProtocol.ServerMethod.outHeaderMappings, SoapHeaderDirection.Fault, base.ServerProtocol.ServerMethod.use == SoapBindingUse.Encoded, base.ServerType.serviceNamespace, base.ServerType.serviceDefaultIsEncoded, "http://schemas.xmlsoap.org/soap/envelope/");
			}
			else
			{
				SoapHeaderHandling.WriteUnknownHeaders(writer, message.Headers, "http://schemas.xmlsoap.org/soap/envelope/");
			}
			writer.WriteStartElement("Body", "http://schemas.xmlsoap.org/soap/envelope/");
			writer.WriteStartElement("Fault", "http://schemas.xmlsoap.org/soap/envelope/");
			writer.WriteStartElement("faultcode", "");
			XmlQualifiedName xmlQualifiedName = TranslateFaultCode(soapException.Code);
			if (xmlQualifiedName.Namespace != null && xmlQualifiedName.Namespace.Length > 0 && writer.LookupPrefix(xmlQualifiedName.Namespace) == null)
			{
				writer.WriteAttributeString("xmlns", "q0", null, xmlQualifiedName.Namespace);
			}
			writer.WriteQualifiedName(xmlQualifiedName.Name, xmlQualifiedName.Namespace);
			writer.WriteEndElement();
			writer.WriteStartElement("faultstring", "");
			if (soapException.Lang != null && soapException.Lang.Length != 0)
			{
				writer.WriteAttributeString("xml", "lang", "http://www.w3.org/XML/1998/namespace", soapException.Lang);
			}
			writer.WriteString(base.ServerProtocol.GenerateFaultString(soapException));
			writer.WriteEndElement();
			string actor = soapException.Actor;
			if (actor.Length > 0)
			{
				writer.WriteElementString("faultactor", "", actor);
			}
			if (!(soapException is SoapHeaderException))
			{
				if (soapException.Detail == null)
				{
					writer.WriteStartElement("detail", "");
					writer.WriteEndElement();
				}
				else
				{
					soapException.Detail.WriteTo(writer);
				}
			}
			writer.WriteEndElement();
			writer.WriteEndElement();
			writer.WriteEndElement();
			writer.Flush();
		}

		private static XmlQualifiedName TranslateFaultCode(XmlQualifiedName code)
		{
			if (code.Namespace == "http://schemas.xmlsoap.org/soap/envelope/")
			{
				return code;
			}
			if (code.Namespace == "http://www.w3.org/2003/05/soap-envelope")
			{
				if (code.Name == "Receiver")
				{
					return SoapException.ServerFaultCode;
				}
				if (code.Name == "Sender")
				{
					return SoapException.ClientFaultCode;
				}
				if (code.Name == "MustUnderstand")
				{
					return SoapException.MustUnderstandFaultCode;
				}
				if (code.Name == "VersionMismatch")
				{
					return SoapException.VersionMismatchFaultCode;
				}
			}
			return code;
		}
	}
	internal class Soap12ServerProtocolHelper : SoapServerProtocolHelper
	{
		internal override SoapProtocolVersion Version => SoapProtocolVersion.Soap12;

		internal override WebServiceProtocols Protocol => WebServiceProtocols.HttpSoap12;

		internal override string EnvelopeNs => "http://www.w3.org/2003/05/soap-envelope";

		internal override string EncodingNs => "http://www.w3.org/2003/05/soap-encoding";

		internal override string HttpContentType => "application/soap+xml";

		internal Soap12ServerProtocolHelper(SoapServerProtocol protocol)
			: base(protocol)
		{
		}

		internal Soap12ServerProtocolHelper(SoapServerProtocol protocol, string requestNamespace)
			: base(protocol, requestNamespace)
		{
		}

		internal override SoapServerMethod RouteRequest()
		{
			string text = ContentType.GetAction(base.ServerProtocol.Request.ContentType);
			SoapServerMethod soapServerMethod = null;
			bool flag = false;
			bool flag2 = false;
			TraceMethod caller = (Tracing.On ? new TraceMethod(this, "RouteRequest") : null);
			if (text != null && text.Length > 0)
			{
				text = HttpUtility.UrlDecode(text);
				if (Tracing.On)
				{
					Tracing.Enter("RouteRequest", caller, new TraceMethod(base.ServerType, "GetMethod", text), Tracing.Details(base.ServerProtocol.Request));
				}
				soapServerMethod = base.ServerType.GetMethod(text);
				if (Tracing.On)
				{
					Tracing.Exit("RouteRequest", caller);
				}
				if (soapServerMethod != null && base.ServerType.GetDuplicateMethod(text) != null)
				{
					soapServerMethod = null;
					flag = true;
				}
			}
			XmlQualifiedName xmlQualifiedName = XmlQualifiedName.Empty;
			if (soapServerMethod == null)
			{
				xmlQualifiedName = GetRequestElement();
				if (Tracing.On)
				{
					Tracing.Enter("RouteRequest", caller, new TraceMethod(base.ServerType, "GetMethod", xmlQualifiedName), Tracing.Details(base.ServerProtocol.Request));
				}
				soapServerMethod = base.ServerType.GetMethod(xmlQualifiedName);
				if (Tracing.On)
				{
					Tracing.Exit("RouteRequest", caller);
				}
				if (soapServerMethod != null && base.ServerType.GetDuplicateMethod(xmlQualifiedName) != null)
				{
					soapServerMethod = null;
					flag2 = true;
				}
			}
			if (soapServerMethod == null)
			{
				if (text == null || text.Length == 0)
				{
					throw new SoapException(Res.GetString("UnableToHandleRequestActionRequired0"), Soap12FaultCodes.SenderFaultCode);
				}
				if (flag)
				{
					if (flag2)
					{
						throw new SoapException(Res.GetString("UnableToHandleRequest0"), Soap12FaultCodes.ReceiverFaultCode);
					}
					throw new SoapException(Res.GetString("TheRequestElementXmlnsWasNotRecognized2", xmlQualifiedName.Name, xmlQualifiedName.Namespace), Soap12FaultCodes.SenderFaultCode);
				}
				throw new SoapException(Res.GetString("UnableToHandleRequestActionNotRecognized1", text), Soap12FaultCodes.SenderFaultCode);
			}
			return soapServerMethod;
		}

		internal override void WriteFault(XmlWriter writer, SoapException soapException, HttpStatusCode statusCode)
		{
			if (statusCode != HttpStatusCode.InternalServerError || soapException == null)
			{
				return;
			}
			writer.WriteStartDocument();
			writer.WriteStartElement("soap", "Envelope", "http://www.w3.org/2003/05/soap-envelope");
			writer.WriteAttributeString("xmlns", "soap", null, "http://www.w3.org/2003/05/soap-envelope");
			writer.WriteAttributeString("xmlns", "xsi", null, "http://www.w3.org/2001/XMLSchema-instance");
			writer.WriteAttributeString("xmlns", "xsd", null, "http://www.w3.org/2001/XMLSchema");
			if (base.ServerProtocol.ServerMethod != null)
			{
				SoapHeaderHandling.WriteHeaders(writer, base.ServerProtocol.ServerMethod.outHeaderSerializer, base.ServerProtocol.Message.Headers, base.ServerProtocol.ServerMethod.outHeaderMappings, SoapHeaderDirection.Fault, base.ServerProtocol.ServerMethod.use == SoapBindingUse.Encoded, base.ServerType.serviceNamespace, base.ServerType.serviceDefaultIsEncoded, "http://www.w3.org/2003/05/soap-envelope");
			}
			else
			{
				SoapHeaderHandling.WriteUnknownHeaders(writer, base.ServerProtocol.Message.Headers, "http://www.w3.org/2003/05/soap-envelope");
			}
			writer.WriteStartElement("Body", "http://www.w3.org/2003/05/soap-envelope");
			writer.WriteStartElement("Fault", "http://www.w3.org/2003/05/soap-envelope");
			writer.WriteStartElement("Code", "http://www.w3.org/2003/05/soap-envelope");
			WriteFaultCodeValue(writer, TranslateFaultCode(soapException.Code), soapException.SubCode);
			writer.WriteEndElement();
			writer.WriteStartElement("Reason", "http://www.w3.org/2003/05/soap-envelope");
			writer.WriteStartElement("Text", "http://www.w3.org/2003/05/soap-envelope");
			writer.WriteAttributeString("xml", "lang", "http://www.w3.org/XML/1998/namespace", Res.GetString("XmlLang"));
			writer.WriteString(base.ServerProtocol.GenerateFaultString(soapException));
			writer.WriteEndElement();
			writer.WriteEndElement();
			string actor = soapException.Actor;
			if (actor.Length > 0)
			{
				writer.WriteElementString("Node", "http://www.w3.org/2003/05/soap-envelope", actor);
			}
			string role = soapException.Role;
			if (role.Length > 0)
			{
				writer.WriteElementString("Role", "http://www.w3.org/2003/05/soap-envelope", role);
			}
			if (!(soapException is SoapHeaderException))
			{
				if (soapException.Detail == null)
				{
					writer.WriteStartElement("Detail", "http://www.w3.org/2003/05/soap-envelope");
					writer.WriteEndElement();
				}
				else
				{
					soapException.Detail.WriteTo(writer);
				}
			}
			writer.WriteEndElement();
			writer.WriteEndElement();
			writer.WriteEndElement();
			writer.Flush();
		}

		private static void WriteFaultCodeValue(XmlWriter writer, XmlQualifiedName code, SoapFaultSubCode subcode)
		{
			if (!(code == null))
			{
				writer.WriteStartElement("Value", "http://www.w3.org/2003/05/soap-envelope");
				if (code.Namespace != null && code.Namespace.Length > 0 && writer.LookupPrefix(code.Namespace) == null)
				{
					writer.WriteAttributeString("xmlns", "q0", null, code.Namespace);
				}
				writer.WriteQualifiedName(code.Name, code.Namespace);
				writer.WriteEndElement();
				if (subcode != null)
				{
					writer.WriteStartElement("Subcode", "http://www.w3.org/2003/05/soap-envelope");
					WriteFaultCodeValue(writer, subcode.Code, subcode.SubCode);
					writer.WriteEndElement();
				}
			}
		}

		private static XmlQualifiedName TranslateFaultCode(XmlQualifiedName code)
		{
			if (code.Namespace == "http://schemas.xmlsoap.org/soap/envelope/")
			{
				if (code.Name == "Server")
				{
					return Soap12FaultCodes.ReceiverFaultCode;
				}
				if (code.Name == "Client")
				{
					return Soap12FaultCodes.SenderFaultCode;
				}
				if (code.Name == "MustUnderstand")
				{
					return Soap12FaultCodes.MustUnderstandFaultCode;
				}
				if (code.Name == "VersionMismatch")
				{
					return Soap12FaultCodes.VersionMismatchFaultCode;
				}
			}
			return code;
		}
	}
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	public abstract class SoapMessage
	{
		private SoapMessageStage stage;

		private SoapHeaderCollection headers = new SoapHeaderCollection();

		private Stream stream;

		private SoapExtensionStream extensionStream;

		private string contentType;

		private string contentEncoding;

		private object[] parameterValues;

		private SoapException exception;

		public abstract bool OneWay { get; }

		public SoapException Exception
		{
			get
			{
				return exception;
			}
			set
			{
				exception = value;
			}
		}

		public abstract LogicalMethodInfo MethodInfo { get; }

		public SoapHeaderCollection Headers => headers;

		public Stream Stream => stream;

		public string ContentType
		{
			get
			{
				EnsureStage((SoapMessageStage)5);
				return contentType;
			}
			set
			{
				EnsureStage((SoapMessageStage)5);
				contentType = value;
			}
		}

		public string ContentEncoding
		{
			get
			{
				EnsureStage((SoapMessageStage)5);
				return contentEncoding;
			}
			set
			{
				EnsureStage((SoapMessageStage)5);
				contentEncoding = value;
			}
		}

		public SoapMessageStage Stage => stage;

		public abstract string Url { get; }

		public abstract string Action { get; }

		[DefaultValue(SoapProtocolVersion.Default)]
		[ComVisible(false)]
		public virtual SoapProtocolVersion SoapVersion => SoapProtocolVersion.Default;

		internal SoapMessage()
		{
		}

		internal void SetParameterValues(object[] parameterValues)
		{
			this.parameterValues = parameterValues;
		}

		internal object[] GetParameterValues()
		{
			return parameterValues;
		}

		public object GetInParameterValue(int index)
		{
			EnsureInStage();
			EnsureNoException();
			if (index < 0 || index >= parameterValues.Length)
			{
				throw new IndexOutOfRangeException(Res.GetString("indexMustBeBetweenAnd0Inclusive", parameterValues.Length));
			}
			return parameterValues[index];
		}

		public object GetOutParameterValue(int index)
		{
			EnsureOutStage();
			EnsureNoException();
			if (!MethodInfo.IsVoid)
			{
				if (index == int.MaxValue)
				{
					throw new IndexOutOfRangeException(Res.GetString("indexMustBeBetweenAnd0Inclusive", parameterValues.Length));
				}
				index++;
			}
			if (index < 0 || index >= parameterValues.Length)
			{
				throw new IndexOutOfRangeException(Res.GetString("indexMustBeBetweenAnd0Inclusive", parameterValues.Length));
			}
			return parameterValues[index];
		}

		public object GetReturnValue()
		{
			EnsureOutStage();
			EnsureNoException();
			if (MethodInfo.IsVoid)
			{
				throw new InvalidOperationException(Res.GetString("WebNoReturnValue"));
			}
			return parameterValues[0];
		}

		protected abstract void EnsureOutStage();

		protected abstract void EnsureInStage();

		private void EnsureNoException()
		{
			if (exception != null)
			{
				throw new InvalidOperationException(Res.GetString("WebCannotAccessValue"), exception);
			}
		}

		protected void EnsureStage(SoapMessageStage stage)
		{
			if ((this.stage & stage) == 0)
			{
				throw new InvalidOperationException(Res.GetString("WebCannotAccessValueStage", this.stage.ToString()));
			}
		}

		internal void SetStream(Stream stream)
		{
			if (extensionStream != null)
			{
				extensionStream.SetInnerStream(stream);
				extensionStream.SetStreamReady();
				extensionStream = null;
			}
			else
			{
				this.stream = stream;
			}
		}

		internal void SetExtensionStream(SoapExtensionStream extensionStream)
		{
			this.extensionStream = extensionStream;
			stream = extensionStream;
		}

		internal void SetStage(SoapMessageStage stage)
		{
			this.stage = stage;
		}

		internal static SoapExtension[] InitializeExtensions(SoapReflectedExtension[] reflectedExtensions, object[] extensionInitializers)
		{
			if (reflectedExtensions == null)
			{
				return null;
			}
			SoapExtension[] array = new SoapExtension[reflectedExtensions.Length];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = reflectedExtensions[i].CreateInstance(extensionInitializers[i]);
			}
			return array;
		}

		internal void InitExtensionStreamChain(SoapExtension[] extensions)
		{
			if (extensions != null)
			{
				for (int i = 0; i < extensions.Length; i++)
				{
					stream = extensions[i].ChainStream(stream);
				}
			}
		}

		internal void RunExtensions(SoapExtension[] extensions, bool throwOnException)
		{
			if (extensions == null)
			{
				return;
			}
			TraceMethod traceMethod = (Tracing.On ? new TraceMethod(this, "RunExtensions", extensions, throwOnException) : null);
			if ((stage & (SoapMessageStage)12) != 0)
			{
				for (int i = 0; i < extensions.Length; i++)
				{
					if (Tracing.On)
					{
						Tracing.Enter("SoapExtension", traceMethod, new TraceMethod(extensions[i], "ProcessMessage", stage));
					}
					extensions[i].ProcessMessage(this);
					if (Tracing.On)
					{
						Tracing.Exit("SoapExtension", traceMethod);
					}
					if (Exception != null)
					{
						if (throwOnException)
						{
							throw Exception;
						}
						if (Tracing.On)
						{
							Tracing.ExceptionIgnore(TraceEventType.Warning, traceMethod, Exception);
						}
					}
				}
				return;
			}
			for (int num = extensions.Length - 1; num >= 0; num--)
			{
				if (Tracing.On)
				{
					Tracing.Enter("SoapExtension", traceMethod, new TraceMethod(extensions[num], "ProcessMessage", stage));
				}
				extensions[num].ProcessMessage(this);
				if (Tracing.On)
				{
					Tracing.Exit("SoapExtension", traceMethod);
				}
				if (Exception != null)
				{
					if (throwOnException)
					{
						throw Exception;
					}
					if (Tracing.On)
					{
						Tracing.ExceptionIgnore(TraceEventType.Warning, traceMethod, Exception);
					}
				}
			}
		}
	}
	public sealed class SoapClientMessage : SoapMessage
	{
		private SoapClientMethod method;

		private SoapHttpClientProtocol protocol;

		private string url;

		internal SoapExtension[] initializedExtensions;

		public override bool OneWay => method.oneWay;

		public SoapHttpClientProtocol Client => protocol;

		public override LogicalMethodInfo MethodInfo => method.methodInfo;

		public override string Url => url;

		public override string Action => method.action;

		[ComVisible(false)]
		public override SoapProtocolVersion SoapVersion
		{
			get
			{
				if (protocol.SoapVersion != 0)
				{
					return protocol.SoapVersion;
				}
				return SoapProtocolVersion.Soap11;
			}
		}

		internal SoapClientMethod Method => method;

		internal SoapClientMessage(SoapHttpClientProtocol protocol, SoapClientMethod method, string url)
		{
			this.method = method;
			this.protocol = protocol;
			this.url = url;
		}

		protected override void EnsureOutStage()
		{
			EnsureStage(SoapMessageStage.AfterDeserialize);
		}

		protected override void EnsureInStage()
		{
			EnsureStage(SoapMessageStage.BeforeSerialize);
		}
	}
	internal class SoapClientType
	{
		private Hashtable methods = new Hashtable();

		private WebServiceBindingAttribute binding;

		internal SoapReflectedExtension[] HighPriExtensions;

		internal SoapReflectedExtension[] LowPriExtensions;

		internal object[] HighPriExtensionInitializers;

		internal object[] LowPriExtensionInitializers;

		internal string serviceNamespace;

		internal bool serviceDefaultIsEncoded;

		internal WebServiceBindingAttribute Binding => binding;

		internal SoapClientType(Type type)
		{
			binding = WebServiceBindingReflector.GetAttribute(type);
			if (binding == null)
			{
				throw new InvalidOperationException(Res.GetString("WebClientBindingAttributeRequired"));
			}
			serviceNamespace = binding.Namespace;
			serviceDefaultIsEncoded = SoapReflector.ServiceDefaultIsEncoded(type);
			ArrayList arrayList = new ArrayList();
			ArrayList arrayList2 = new ArrayList();
			GenerateXmlMappings(type, arrayList, serviceNamespace, serviceDefaultIsEncoded, arrayList2);
			XmlMapping[] array = (XmlMapping[])arrayList2.ToArray(typeof(XmlMapping));
			TraceMethod caller = (Tracing.On ? new TraceMethod(this, ".ctor", type) : null);
			if (Tracing.On)
			{
				Tracing.Enter(Tracing.TraceId("TraceCreateSerializer"), caller, new TraceMethod(typeof(XmlSerializer), "FromMappings", array, type));
			}
			XmlSerializer[] array2 = XmlSerializer.FromMappings(array, type);
			if (Tracing.On)
			{
				Tracing.Exit(Tracing.TraceId("TraceCreateSerializer"), caller);
			}
			SoapExtensionTypeElementCollection soapExtensionTypes = WebServicesSection.Current.SoapExtensionTypes;
			ArrayList arrayList3 = new ArrayList();
			ArrayList arrayList4 = new ArrayList();
			for (int i = 0; i < soapExtensionTypes.Count; i++)
			{
				_ = soapExtensionTypes[i];
				SoapReflectedExtension value = new SoapReflectedExtension(soapExtensionTypes[i].Type, null, soapExtensionTypes[i].Priority);
				if (soapExtensionTypes[i].Group == PriorityGroup.High)
				{
					arrayList3.Add(value);
				}
				else
				{
					arrayList4.Add(value);
				}
			}
			HighPriExtensions = (SoapReflectedExtension[])arrayList3.ToArray(typeof(SoapReflectedExtension));
			LowPriExtensions = (SoapReflectedExtension[])arrayList4.ToArray(typeof(SoapReflectedExtension));
			Array.Sort(HighPriExtensions);
			Array.Sort(LowPriExtensions);
			HighPriExtensionInitializers = SoapReflectedExtension.GetInitializers(type, HighPriExtensions);
			LowPriExtensionInitializers = SoapReflectedExtension.GetInitializers(type, LowPriExtensions);
			int num = 0;
			for (int j = 0; j < arrayList.Count; j++)
			{
				SoapReflectedMethod soapReflectedMethod = (SoapReflectedMethod)arrayList[j];
				SoapClientMethod soapClientMethod = new SoapClientMethod
				{
					parameterSerializer = array2[num++]
				};
				if (soapReflectedMethod.responseMappings != null)
				{
					soapClientMethod.returnSerializer = array2[num++];
				}
				soapClientMethod.inHeaderSerializer = array2[num++];
				if (soapReflectedMethod.outHeaderMappings != null)
				{
					soapClientMethod.outHeaderSerializer = array2[num++];
				}
				soapClientMethod.action = soapReflectedMethod.action;
				soapClientMethod.oneWay = soapReflectedMethod.oneWay;
				soapClientMethod.rpc = soapReflectedMethod.rpc;
				soapClientMethod.use = soapReflectedMethod.use;
				soapClientMethod.paramStyle = soapReflectedMethod.paramStyle;
				soapClientMethod.methodInfo = soapReflectedMethod.methodInfo;
				soapClientMethod.extensions = soapReflectedMethod.extensions;
				soapClientMethod.extensionInitializers = SoapReflectedExtension.GetInitializers(soapClientMethod.methodInfo, soapReflectedMethod.extensions);
				ArrayList arrayList5 = new ArrayList();
				ArrayList arrayList6 = new ArrayList();
				for (int k = 0; k < soapReflectedMethod.headers.Length; k++)
				{
					SoapHeaderMapping soapHeaderMapping = new SoapHeaderMapping();
					SoapReflectedHeader soapReflectedHeader = soapReflectedMethod.headers[k];
					soapHeaderMapping.memberInfo = soapReflectedHeader.memberInfo;
					soapHeaderMapping.repeats = soapReflectedHeader.repeats;
					soapHeaderMapping.custom = soapReflectedHeader.custom;
					soapHeaderMapping.direction = soapReflectedHeader.direction;
					soapHeaderMapping.headerType = soapReflectedHeader.headerType;
					if ((soapHeaderMapping.direction & SoapHeaderDirection.In) != 0)
					{
						arrayList5.Add(soapHeaderMapping);
					}
					if ((soapHeaderMapping.direction & (SoapHeaderDirection.Out | SoapHeaderDirection.Fault)) != 0)
					{
						arrayList6.Add(soapHeaderMapping);
					}
				}
				soapClientMethod.inHeaderMappings = (SoapHeaderMapping[])arrayList5.ToArray(typeof(SoapHeaderMapping));
				if (soapClientMethod.outHeaderSerializer != null)
				{
					soapClientMethod.outHeaderMappings = (SoapHeaderMapping[])arrayList6.ToArray(typeof(SoapHeaderMapping));
				}
				methods.Add(soapReflectedMethod.name, soapClientMethod);
			}
		}

		internal static void GenerateXmlMappings(Type type, ArrayList soapMethodList, string serviceNamespace, bool serviceDefaultIsEncoded, ArrayList mappings)
		{
			LogicalMethodInfo[] array = LogicalMethodInfo.Create(type.GetMethods(BindingFlags.Instance | BindingFlags.Public), LogicalMethodTypes.Sync);
			SoapReflectionImporter soapReflectionImporter = SoapReflector.CreateSoapImporter(serviceNamespace, serviceDefaultIsEncoded);
			XmlReflectionImporter xmlReflectionImporter = SoapReflector.CreateXmlImporter(serviceNamespace, serviceDefaultIsEncoded);
			WebMethodReflector.IncludeTypes(array, xmlReflectionImporter);
			SoapReflector.IncludeTypes(array, soapReflectionImporter);
			foreach (LogicalMethodInfo methodInfo in array)
			{
				SoapReflectedMethod soapReflectedMethod = SoapReflector.ReflectMethod(methodInfo, client: true, xmlReflectionImporter, soapReflectionImporter, serviceNamespace);
				if (soapReflectedMethod != null)
				{
					soapMethodList.Add(soapReflectedMethod);
					mappings.Add(soapReflectedMethod.requestMappings);
					if (soapReflectedMethod.responseMappings != null)
					{
						mappings.Add(soapReflectedMethod.responseMappings);
					}
					mappings.Add(soapReflectedMethod.inHeaderMappings);
					if (soapReflectedMethod.outHeaderMappings != null)
					{
						mappings.Add(soapReflectedMethod.outHeaderMappings);
					}
				}
			}
		}

		internal SoapClientMethod GetMethod(string name)
		{
			return (SoapClientMethod)methods[name];
		}
	}
	internal class SoapClientMethod
	{
		internal XmlSerializer returnSerializer;

		internal XmlSerializer parameterSerializer;

		internal XmlSerializer inHeaderSerializer;

		internal XmlSerializer outHeaderSerializer;

		internal string action;

		internal LogicalMethodInfo methodInfo;

		internal SoapHeaderMapping[] inHeaderMappings;

		internal SoapHeaderMapping[] outHeaderMappings;

		internal SoapReflectedExtension[] extensions;

		internal object[] extensionInitializers;

		internal bool oneWay;

		internal bool rpc;

		internal SoapBindingUse use;

		internal SoapParameterStyle paramStyle;
	}
	[ComVisible(true)]
	public class SoapHttpClientProtocol : HttpWebClientProtocol
	{
		private class InvokeAsyncState
		{
			public string MethodName;

			public object[] Parameters;

			public SoapClientMessage Message;

			public InvokeAsyncState(string methodName, object[] parameters)
			{
				MethodName = methodName;
				Parameters = parameters;
			}
		}

		private SoapClientType clientType;

		private SoapProtocolVersion version;

		[DefaultValue(SoapProtocolVersion.Default)]
		[ComVisible(false)]
		[WebServicesDescription("ClientProtocolSoapVersion")]
		public SoapProtocolVersion SoapVersion
		{
			get
			{
				return version;
			}
			set
			{
				version = value;
			}
		}

		private string EnvelopeNs
		{
			get
			{
				if (version != SoapProtocolVersion.Soap12)
				{
					return "http://schemas.xmlsoap.org/soap/envelope/";
				}
				return "http://www.w3.org/2003/05/soap-envelope";
			}
		}

		private string EncodingNs
		{
			get
			{
				if (version != SoapProtocolVersion.Soap12)
				{
					return "http://schemas.xmlsoap.org/soap/encoding/";
				}
				return "http://www.w3.org/2003/05/soap-encoding";
			}
		}

		private string HttpContentType
		{
			get
			{
				if (version != SoapProtocolVersion.Soap12)
				{
					return "text/xml";
				}
				return "application/soap+xml";
			}
		}

		public SoapHttpClientProtocol()
		{
			Type type = GetType();
			clientType = (SoapClientType)WebClientProtocol.GetFromCache(type);
			if (clientType != null)
			{
				return;
			}
			lock (WebClientProtocol.InternalSyncObject)
			{
				clientType = (SoapClientType)WebClientProtocol.GetFromCache(type);
				if (clientType == null)
				{
					clientType = new SoapClientType(type);
					WebClientProtocol.AddToCache(type, clientType);
				}
			}
		}

		public void Discover()
		{
			if (clientType.Binding == null)
			{
				throw new InvalidOperationException(Res.GetString("DiscoveryIsNotPossibleBecauseTypeIsMissing1", GetType().FullName));
			}
			DiscoveryClientProtocol discoveryClientProtocol = new DiscoveryClientProtocol(this);
			DiscoveryDocument discoveryDocument = discoveryClientProtocol.Discover(base.Url);
			foreach (object reference in discoveryDocument.References)
			{
				if (reference is System.Web.Services.Discovery.SoapBinding soapBinding && clientType.Binding.Name == soapBinding.Binding.Name && clientType.Binding.Namespace == soapBinding.Binding.Namespace)
				{
					base.Url = soapBinding.Address;
					return;
				}
			}
			throw new InvalidOperationException(Res.GetString("TheBindingNamedFromNamespaceWasNotFoundIn3", clientType.Binding.Name, clientType.Binding.Namespace, base.Url));
		}

		protected override WebRequest GetWebRequest(Uri uri)
		{
			return base.GetWebRequest(uri);
		}

		[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
		protected virtual XmlWriter GetWriterForMessage(SoapClientMessage message, int bufferSize)
		{
			if (bufferSize < 512)
			{
				bufferSize = 512;
			}
			return new XmlTextWriter(new StreamWriter(message.Stream, (base.RequestEncoding != null) ? base.RequestEncoding : new UTF8Encoding(encoderShouldEmitUTF8Identifier: false), bufferSize));
		}

		[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
		protected virtual XmlReader GetReaderForMessage(SoapClientMessage message, int bufferSize)
		{
			Encoding encoding = ((message.SoapVersion == SoapProtocolVersion.Soap12) ? RequestResponseUtils.GetEncoding2(message.ContentType) : RequestResponseUtils.GetEncoding(message.ContentType));
			if (bufferSize < 512)
			{
				bufferSize = 512;
			}
			XmlTextReader xmlTextReader = ((encoding == null) ? new XmlTextReader(message.Stream) : new XmlTextReader(new StreamReader(message.Stream, encoding, detectEncodingFromByteOrderMarks: true, bufferSize)));
			xmlTextReader.ProhibitDtd = true;
			xmlTextReader.Normalization = true;
			xmlTextReader.XmlResolver = null;
			return xmlTextReader;
		}

		protected object[] Invoke(string methodName, object[] parameters)
		{
			WebResponse webResponse = null;
			WebRequest webRequest = null;
			try
			{
				webRequest = GetWebRequest(base.Uri);
				NotifyClientCallOut(webRequest);
				base.PendingSyncRequest = webRequest;
				SoapClientMessage soapClientMessage = BeforeSerialize(webRequest, methodName, parameters);
				Stream requestStream = webRequest.GetRequestStream();
				try
				{
					soapClientMessage.SetStream(requestStream);
					Serialize(soapClientMessage);
				}
				finally
				{
					requestStream.Close();
				}
				webResponse = GetWebResponse(webRequest);
				Stream stream = null;
				try
				{
					stream = webResponse.GetResponseStream();
					return ReadResponse(soapClientMessage, webResponse, stream, asyncCall: false);
				}
				catch (XmlException innerException)
				{
					throw new InvalidOperationException(Res.GetString("WebResponseBadXml"), innerException);
				}
				finally
				{
					stream?.Close();
				}
			}
			finally
			{
				if (webRequest == base.PendingSyncRequest)
				{
					base.PendingSyncRequest = null;
				}
			}
		}

		protected IAsyncResult BeginInvoke(string methodName, object[] parameters, AsyncCallback callback, object asyncState)
		{
			InvokeAsyncState internalAsyncState = new InvokeAsyncState(methodName, parameters);
			WebClientAsyncResult asyncResult = new WebClientAsyncResult(this, internalAsyncState, null, callback, asyncState);
			return BeginSend(base.Uri, asyncResult, callWriteAsyncRequest: true);
		}

		internal override void InitializeAsyncRequest(WebRequest request, object internalAsyncState)
		{
			InvokeAsyncState invokeAsyncState = (InvokeAsyncState)internalAsyncState;
			invokeAsyncState.Message = BeforeSerialize(request, invokeAsyncState.MethodName, invokeAsyncState.Parameters);
		}

		internal override void AsyncBufferedSerialize(WebRequest request, Stream requestStream, object internalAsyncState)
		{
			InvokeAsyncState invokeAsyncState = (InvokeAsyncState)internalAsyncState;
			SoapClientMessage message = invokeAsyncState.Message;
			message.SetStream(requestStream);
			Serialize(invokeAsyncState.Message);
		}

		protected object[] EndInvoke(IAsyncResult asyncResult)
		{
			object internalAsyncState = null;
			Stream responseStream = null;
			try
			{
				WebResponse response = EndSend(asyncResult, ref internalAsyncState, ref responseStream);
				InvokeAsyncState invokeAsyncState = (InvokeAsyncState)internalAsyncState;
				return ReadResponse(invokeAsyncState.Message, response, responseStream, asyncCall: true);
			}
			catch (XmlException innerException)
			{
				throw new InvalidOperationException(Res.GetString("WebResponseBadXml"), innerException);
			}
			finally
			{
				responseStream?.Close();
			}
		}

		private void InvokeAsyncCallback(IAsyncResult result)
		{
			object[] parameters = null;
			Exception e = null;
			WebClientAsyncResult webClientAsyncResult = (WebClientAsyncResult)result;
			if (webClientAsyncResult.Request != null)
			{
				object internalAsyncState = null;
				Stream responseStream = null;
				try
				{
					WebResponse response = EndSend(webClientAsyncResult, ref internalAsyncState, ref responseStream);
					InvokeAsyncState invokeAsyncState = (InvokeAsyncState)internalAsyncState;
					parameters = ReadResponse(invokeAsyncState.Message, response, responseStream, asyncCall: true);
				}
				catch (XmlException ex)
				{
					if (Tracing.On)
					{
						Tracing.ExceptionCatch(TraceEventType.Warning, this, "InvokeAsyncCallback", ex);
					}
					e = new InvalidOperationException(Res.GetString("WebResponseBadXml"), ex);
				}
				catch (Exception ex2)
				{
					if (ex2 is ThreadAbortException || ex2 is StackOverflowException || ex2 is OutOfMemoryException)
					{
						throw;
					}
					if (Tracing.On)
					{
						Tracing.ExceptionCatch(TraceEventType.Warning, this, "InvokeAsyncCallback", ex2);
					}
					e = ex2;
				}
				catch
				{
					e = new Exception(Res.GetString("NonClsCompliantException"));
				}
				finally
				{
					responseStream?.Close();
				}
			}
			AsyncOperation asyncOperation = (AsyncOperation)result.AsyncState;
			UserToken userToken = (UserToken)asyncOperation.UserSuppliedState;
			OperationCompleted(userToken.UserState, parameters, e, canceled: false);
		}

		protected void InvokeAsync(string methodName, object[] parameters, SendOrPostCallback callback)
		{
			InvokeAsync(methodName, parameters, callback, null);
		}

		protected void InvokeAsync(string methodName, object[] parameters, SendOrPostCallback callback, object userState)
		{
			if (userState == null)
			{
				userState = base.NullToken;
			}
			InvokeAsyncState internalAsyncState = new InvokeAsyncState(methodName, parameters);
			AsyncOperation asyncOperation = AsyncOperationManager.CreateOperation(new UserToken(callback, userState));
			WebClientAsyncResult webClientAsyncResult = new WebClientAsyncResult(this, internalAsyncState, null, InvokeAsyncCallback, asyncOperation);
			try
			{
				base.AsyncInvokes.Add(userState, webClientAsyncResult);
			}
			catch (Exception ex)
			{
				if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
				{
					throw;
				}
				if (Tracing.On)
				{
					Tracing.ExceptionCatch(TraceEventType.Warning, this, "InvokeAsync", ex);
				}
				Exception exception = new ArgumentException(Res.GetString("AsyncDuplicateUserState"), ex);
				object[] results = new object[1];
				InvokeCompletedEventArgs arg = new InvokeCompletedEventArgs(results, exception, cancelled: false, userState);
				asyncOperation.PostOperationCompleted(callback, arg);
				return;
			}
			catch
			{
				Exception exception2 = new ArgumentException(Res.GetString("AsyncDuplicateUserState"), new Exception(Res.GetString("NonClsCompliantException")));
				object[] results2 = new object[1];
				InvokeCompletedEventArgs arg2 = new InvokeCompletedEventArgs(results2, exception2, cancelled: false, userState);
				asyncOperation.PostOperationCompleted(callback, arg2);
				return;
			}
			try
			{
				BeginSend(base.Uri, webClientAsyncResult, callWriteAsyncRequest: true);
			}
			catch (Exception ex2)
			{
				if (ex2 is ThreadAbortException || ex2 is StackOverflowException || ex2 is OutOfMemoryException)
				{
					throw;
				}
				if (Tracing.On)
				{
					Tracing.ExceptionCatch(TraceEventType.Warning, this, "InvokeAsync", ex2);
				}
				object userState2 = userState;
				object[] parameters2 = new object[1];
				OperationCompleted(userState2, parameters2, ex2, canceled: false);
			}
			catch
			{
				object userState3 = userState;
				object[] parameters3 = new object[1];
				OperationCompleted(userState3, parameters3, new Exception(Res.GetString("NonClsCompliantException")), canceled: false);
			}
		}

		private static Array CombineExtensionsHelper(Array array1, Array array2, Array array3, Type elementType)
		{
			int num = array1.Length + array2.Length + array3.Length;
			if (num == 0)
			{
				return null;
			}
			Array array4 = null;
			if (elementType == typeof(SoapReflectedExtension))
			{
				array4 = new SoapReflectedExtension[num];
			}
			else
			{
				if (elementType != typeof(object))
				{
					throw new ArgumentException(Res.GetString("ElementTypeMustBeObjectOrSoapReflectedException"), "elementType");
				}
				array4 = new object[num];
			}
			int num2 = 0;
			Array.Copy(array1, 0, array4, num2, array1.Length);
			num2 += array1.Length;
			Array.Copy(array2, 0, array4, num2, array2.Length);
			num2 += array2.Length;
			Array.Copy(array3, 0, array4, num2, array3.Length);
			return array4;
		}

		private SoapClientMessage BeforeSerialize(WebRequest request, string methodName, object[] parameters)
		{
			if (parameters == null)
			{
				throw new ArgumentNullException("parameters");
			}
			SoapClientMethod method = clientType.GetMethod(methodName);
			if (method == null)
			{
				throw new ArgumentException(Res.GetString("WebInvalidMethodName", methodName));
			}
			SoapReflectedExtension[] reflectedExtensions = (SoapReflectedExtension[])CombineExtensionsHelper(clientType.HighPriExtensions, method.extensions, clientType.LowPriExtensions, typeof(SoapReflectedExtension));
			object[] extensionInitializers = (object[])CombineExtensionsHelper(clientType.HighPriExtensionInitializers, method.extensionInitializers, clientType.LowPriExtensionInitializers, typeof(object));
			SoapExtension[] array = SoapMessage.InitializeExtensions(reflectedExtensions, extensionInitializers);
			SoapClientMessage soapClientMessage = new SoapClientMessage(this, method, base.Url);
			soapClientMessage.initializedExtensions = array;
			if (array != null)
			{
				soapClientMessage.SetExtensionStream(new SoapExtensionStream());
			}
			soapClientMessage.InitExtensionStreamChain(soapClientMessage.initializedExtensions);
			string text = UrlEncoder.EscapeString(method.action, Encoding.UTF8);
			soapClientMessage.SetStage(SoapMessageStage.BeforeSerialize);
			if (version == SoapProtocolVersion.Soap12)
			{
				soapClientMessage.ContentType = ContentType.Compose("application/soap+xml", (base.RequestEncoding != null) ? base.RequestEncoding : Encoding.UTF8, text);
			}
			else
			{
				soapClientMessage.ContentType = ContentType.Compose("text/xml", (base.RequestEncoding != null) ? base.RequestEncoding : Encoding.UTF8);
			}
			soapClientMessage.SetParameterValues(parameters);
			SoapHeaderHandling.GetHeaderMembers(soapClientMessage.Headers, this, method.inHeaderMappings, SoapHeaderDirection.In, client: true);
			soapClientMessage.RunExtensions(soapClientMessage.initializedExtensions, throwOnException: true);
			request.ContentType = soapClientMessage.ContentType;
			if (soapClientMessage.ContentEncoding != null && soapClientMessage.ContentEncoding.Length > 0)
			{
				request.Headers["Content-Encoding"] = soapClientMessage.ContentEncoding;
			}
			request.Method = "POST";
			if (version != SoapProtocolVersion.Soap12 && request.Headers["SOAPAction"] == null)
			{
				StringBuilder stringBuilder = new StringBuilder(text.Length + 2);
				stringBuilder.Append('"');
				stringBuilder.Append(text);
				stringBuilder.Append('"');
				request.Headers.Add("SOAPAction", stringBuilder.ToString());
			}
			return soapClientMessage;
		}

		private void Serialize(SoapClientMessage message)
		{
			_ = message.Stream;
			SoapClientMethod method = message.Method;
			bool flag = method.use == SoapBindingUse.Encoded;
			string envelopeNs = EnvelopeNs;
			string encodingNs = EncodingNs;
			XmlWriter writerForMessage = GetWriterForMessage(message, 1024);
			if (writerForMessage == null)
			{
				throw new InvalidOperationException(Res.GetString("WebNullWriterForMessage"));
			}
			writerForMessage.WriteStartDocument();
			writerForMessage.WriteStartElement("soap", "Envelope", envelopeNs);
			writerForMessage.WriteAttributeString("xmlns", "soap", null, envelopeNs);
			if (flag)
			{
				writerForMessage.WriteAttributeString("xmlns", "soapenc", null, encodingNs);
				writerForMessage.WriteAttributeString("xmlns", "tns", null, clientType.serviceNamespace);
				writerForMessage.WriteAttributeString("xmlns", "types", null, SoapReflector.GetEncodedNamespace(clientType.serviceNamespace, clientType.serviceDefaultIsEncoded));
			}
			writerForMessage.WriteAttributeString("xmlns", "xsi", null, "http://www.w3.org/2001/XMLSchema-instance");
			writerForMessage.WriteAttributeString("xmlns", "xsd", null, "http://www.w3.org/2001/XMLSchema");
			SoapHeaderHandling.WriteHeaders(writerForMessage, method.inHeaderSerializer, message.Headers, method.inHeaderMappings, SoapHeaderDirection.In, flag, clientType.serviceNamespace, clientType.serviceDefaultIsEncoded, envelopeNs);
			writerForMessage.WriteStartElement("Body", envelopeNs);
			if (flag && version != SoapProtocolVersion.Soap12)
			{
				writerForMessage.WriteAttributeString("soap", "encodingStyle", null, encodingNs);
			}
			object[] parameterValues = message.GetParameterValues();
			TraceMethod caller = (Tracing.On ? new TraceMethod(this, "Serialize") : null);
			if (Tracing.On)
			{
				Tracing.Enter(Tracing.TraceId("TraceWriteRequest"), caller, new TraceMethod(method.parameterSerializer, "Serialize", writerForMessage, parameterValues, null, flag ? encodingNs : null));
			}
			method.parameterSerializer.Serialize(writerForMessage, parameterValues, null, flag ? encodingNs : null);
			if (Tracing.On)
			{
				Tracing.Exit(Tracing.TraceId("TraceWriteRequest"), caller);
			}
			writerForMessage.WriteEndElement();
			writerForMessage.WriteEndElement();
			writerForMessage.Flush();
			message.SetStage(SoapMessageStage.AfterSerialize);
			message.RunExtensions(message.initializedExtensions, throwOnException: true);
		}

		private object[] ReadResponse(SoapClientMessage message, WebResponse response, Stream responseStream, bool asyncCall)
		{
			SoapClientMethod method = message.Method;
			HttpWebResponse httpWebResponse = response as HttpWebResponse;
			int num = (int)(httpWebResponse?.StatusCode ?? ((HttpStatusCode)(-1)));
			if (num >= 300 && num != 500 && num != 400)
			{
				throw new WebException(RequestResponseUtils.CreateResponseExceptionString(httpWebResponse, responseStream), null, WebExceptionStatus.ProtocolError, httpWebResponse);
			}
			message.Headers.Clear();
			message.SetStream(responseStream);
			message.InitExtensionStreamChain(message.initializedExtensions);
			message.SetStage(SoapMessageStage.BeforeDeserialize);
			message.ContentType = response.ContentType;
			message.ContentEncoding = response.Headers["Content-Encoding"];
			message.RunExtensions(message.initializedExtensions, throwOnException: false);
			if (method.oneWay && (httpWebResponse == null || httpWebResponse.StatusCode != HttpStatusCode.InternalServerError))
			{
				return new object[0];
			}
			bool flag = ContentType.IsSoap(message.ContentType);
			if (!flag || (flag && httpWebResponse != null && httpWebResponse.ContentLength == 0))
			{
				if (num == 400)
				{
					throw new WebException(RequestResponseUtils.CreateResponseExceptionString(httpWebResponse, responseStream), null, WebExceptionStatus.ProtocolError, httpWebResponse);
				}
				throw new InvalidOperationException(Res.GetString("WebResponseContent", message.ContentType, HttpContentType) + Environment.NewLine + RequestResponseUtils.CreateResponseExceptionString(response, responseStream));
			}
			if (message.Exception != null)
			{
				throw message.Exception;
			}
			int bufferSize = ((!asyncCall && httpWebResponse != null) ? RequestResponseUtils.GetBufferSize((int)httpWebResponse.ContentLength) : 512);
			XmlReader readerForMessage = GetReaderForMessage(message, bufferSize);
			if (readerForMessage == null)
			{
				throw new InvalidOperationException(Res.GetString("WebNullReaderForMessage"));
			}
			readerForMessage.MoveToContent();
			int depth = readerForMessage.Depth;
			string encodingNs = EncodingNs;
			string namespaceURI = readerForMessage.NamespaceURI;
			if (namespaceURI == null || namespaceURI.Length == 0)
			{
				readerForMessage.ReadStartElement("Envelope");
			}
			else if (readerForMessage.NamespaceURI == "http://schemas.xmlsoap.org/soap/envelope/")
			{
				readerForMessage.ReadStartElement("Envelope", "http://schemas.xmlsoap.org/soap/envelope/");
			}
			else
			{
				if (!(readerForMessage.NamespaceURI == "http://www.w3.org/2003/05/soap-envelope"))
				{
					throw new SoapException(Res.GetString("WebInvalidEnvelopeNamespace", namespaceURI, EnvelopeNs), SoapException.VersionMismatchFaultCode);
				}
				readerForMessage.ReadStartElement("Envelope", "http://www.w3.org/2003/05/soap-envelope");
			}
			readerForMessage.MoveToContent();
			SoapHeaderHandling soapHeaderHandling = new SoapHeaderHandling();
			soapHeaderHandling.ReadHeaders(readerForMessage, method.outHeaderSerializer, message.Headers, method.outHeaderMappings, SoapHeaderDirection.Out | SoapHeaderDirection.Fault, namespaceURI, (method.use == SoapBindingUse.Encoded) ? encodingNs : null, checkRequiredHeaders: false);
			readerForMessage.MoveToContent();
			readerForMessage.ReadStartElement("Body", namespaceURI);
			readerForMessage.MoveToContent();
			if (readerForMessage.IsStartElement("Fault", namespaceURI))
			{
				message.Exception = ReadSoapException(readerForMessage);
			}
			else if (method.oneWay)
			{
				readerForMessage.Skip();
				message.SetParameterValues(new object[0]);
			}
			else
			{
				TraceMethod caller = (Tracing.On ? new TraceMethod(this, "ReadResponse") : null);
				bool flag2 = method.use == SoapBindingUse.Encoded;
				if (Tracing.On)
				{
					Tracing.Enter(Tracing.TraceId("TraceReadResponse"), caller, new TraceMethod(method.returnSerializer, "Deserialize", readerForMessage, flag2 ? encodingNs : null));
				}
				if (!flag2 && (WebServicesSection.Current.SoapEnvelopeProcessing.IsStrict || Tracing.On))
				{
					XmlDeserializationEvents xmlDeserializationEvents = (Tracing.On ? Tracing.GetDeserializationEvents() : RuntimeUtils.GetDeserializationEvents());
					message.SetParameterValues((object[])method.returnSerializer.Deserialize(readerForMessage, null, xmlDeserializationEvents));
				}
				else
				{
					message.SetParameterValues((object[])method.returnSerializer.Deserialize(readerForMessage, flag2 ? encodingNs : null));
				}
				if (Tracing.On)
				{
					Tracing.Exit(Tracing.TraceId("TraceReadResponse"), caller);
				}
			}
			while (depth < readerForMessage.Depth && readerForMessage.Read())
			{
			}
			if (readerForMessage.NodeType == XmlNodeType.EndElement)
			{
				readerForMessage.Read();
			}
			message.SetStage(SoapMessageStage.AfterDeserialize);
			message.RunExtensions(message.initializedExtensions, throwOnException: false);
			SoapHeaderHandling.SetHeaderMembers(message.Headers, this, method.outHeaderMappings, SoapHeaderDirection.Out | SoapHeaderDirection.Fault, client: true);
			if (message.Exception != null)
			{
				throw message.Exception;
			}
			return message.GetParameterValues();
		}

		private SoapException ReadSoapException(XmlReader reader)
		{
			XmlQualifiedName code = XmlQualifiedName.Empty;
			string message = null;
			string actor = null;
			string role = null;
			XmlNode xmlNode = null;
			SoapFaultSubCode subcode = null;
			string lang = null;
			bool flag = reader.NamespaceURI == "http://www.w3.org/2003/05/soap-envelope";
			if (reader.IsEmptyElement)
			{
				reader.Skip();
			}
			else
			{
				reader.ReadStartElement();
				reader.MoveToContent();
				int depth = reader.Depth;
				while (reader.NodeType != XmlNodeType.EndElement && reader.NodeType != 0)
				{
					if (reader.NamespaceURI == "http://schemas.xmlsoap.org/soap/envelope/" || reader.NamespaceURI == "http://www.w3.org/2003/05/soap-envelope" || reader.NamespaceURI == null || reader.NamespaceURI.Length == 0)
					{
						if (reader.LocalName == "faultcode" || reader.LocalName == "Code")
						{
							code = ((!flag) ? ReadFaultCode(reader) : ReadSoap12FaultCode(reader, out subcode));
						}
						else if (reader.LocalName == "faultstring")
						{
							lang = reader.GetAttribute("lang", "http://www.w3.org/XML/1998/namespace");
							reader.MoveToElement();
							message = reader.ReadElementString();
						}
						else if (reader.LocalName == "Reason")
						{
							if (reader.IsEmptyElement)
							{
								reader.Skip();
							}
							else
							{
								reader.ReadStartElement();
								reader.MoveToContent();
								while (reader.NodeType != XmlNodeType.EndElement && reader.NodeType != 0)
								{
									if (reader.LocalName == "Text" && reader.NamespaceURI == "http://www.w3.org/2003/05/soap-envelope")
									{
										message = reader.ReadElementString();
									}
									else
									{
										reader.Skip();
									}
									reader.MoveToContent();
								}
								while (reader.NodeType == XmlNodeType.Whitespace)
								{
									reader.Skip();
								}
								if (reader.NodeType == XmlNodeType.None)
								{
									reader.Skip();
								}
								else
								{
									reader.ReadEndElement();
								}
							}
						}
						else if (reader.LocalName == "faultactor" || reader.LocalName == "Node")
						{
							actor = reader.ReadElementString();
						}
						else if (reader.LocalName == "detail" || reader.LocalName == "Detail")
						{
							xmlNode = new XmlDocument().ReadNode(reader);
						}
						else if (reader.LocalName == "Role")
						{
							role = reader.ReadElementString();
						}
						else
						{
							reader.Skip();
						}
					}
					else
					{
						reader.Skip();
					}
					reader.MoveToContent();
				}
				while (reader.Read() && depth < reader.Depth)
				{
				}
				if (reader.NodeType == XmlNodeType.EndElement)
				{
					reader.Read();
				}
			}
			if (xmlNode != null || flag)
			{
				return new SoapException(message, code, actor, role, lang, xmlNode, subcode, null);
			}
			return new SoapHeaderException(message, code, actor, role, lang, subcode, null);
		}

		private XmlQualifiedName ReadSoap12FaultCode(XmlReader reader, out SoapFaultSubCode subcode)
		{
			SoapFaultSubCode soapFaultSubCode = ReadSoap12FaultCodesRecursive(reader, 0);
			if (soapFaultSubCode == null)
			{
				subcode = null;
				return null;
			}
			subcode = soapFaultSubCode.SubCode;
			return soapFaultSubCode.Code;
		}

		private SoapFaultSubCode ReadSoap12FaultCodesRecursive(XmlReader reader, int depth)
		{
			if (depth > 100)
			{
				return null;
			}
			if (reader.IsEmptyElement)
			{
				reader.Skip();
				return null;
			}
			XmlQualifiedName code = null;
			SoapFaultSubCode subCode = null;
			int depth2 = reader.Depth;
			reader.ReadStartElement();
			reader.MoveToContent();
			while (reader.NodeType != XmlNodeType.EndElement && reader.NodeType != 0)
			{
				if (reader.NamespaceURI == "http://www.w3.org/2003/05/soap-envelope" || reader.NamespaceURI == null || reader.NamespaceURI.Length == 0)
				{
					if (reader.LocalName == "Value")
					{
						code = ReadFaultCode(reader);
					}
					else if (reader.LocalName == "Subcode")
					{
						subCode = ReadSoap12FaultCodesRecursive(reader, depth + 1);
					}
					else
					{
						reader.Skip();
					}
				}
				else
				{
					reader.Skip();
				}
				reader.MoveToContent();
			}
			while (depth2 < reader.Depth && reader.Read())
			{
			}
			if (reader.NodeType == XmlNodeType.EndElement)
			{
				reader.Read();
			}
			return new SoapFaultSubCode(code, subCode);
		}

		private XmlQualifiedName ReadFaultCode(XmlReader reader)
		{
			if (reader.IsEmptyElement)
			{
				reader.Skip();
				return null;
			}
			reader.ReadStartElement();
			string text = reader.ReadString();
			int num = text.IndexOf(":", StringComparison.Ordinal);
			string text2 = reader.NamespaceURI;
			if (num >= 0)
			{
				string text3 = text.Substring(0, num);
				text2 = reader.LookupNamespace(text3);
				if (text2 == null)
				{
					throw new InvalidOperationException(Res.GetString("WebQNamePrefixUndefined", text3));
				}
			}
			reader.ReadEndElement();
			return new XmlQualifiedName(text.Substring(num + 1), text2);
		}
	}
	[AttributeUsage(AttributeTargets.Method)]
	public sealed class SoapDocumentMethodAttribute : Attribute
	{
		private string action;

		private string requestName;

		private string responseName;

		private string requestNamespace;

		private string responseNamespace;

		private bool oneWay;

		private SoapBindingUse use;

		private SoapParameterStyle style;

		private string binding;

		public string Action
		{
			get
			{
				return action;
			}
			set
			{
				action = value;
			}
		}

		public bool OneWay
		{
			get
			{
				return oneWay;
			}
			set
			{
				oneWay = value;
			}
		}

		public string RequestNamespace
		{
			get
			{
				return requestNamespace;
			}
			set
			{
				requestNamespace = value;
			}
		}

		public string ResponseNamespace
		{
			get
			{
				return responseNamespace;
			}
			set
			{
				responseNamespace = value;
			}
		}

		public string RequestElementName
		{
			get
			{
				if (requestName != null)
				{
					return requestName;
				}
				return string.Empty;
			}
			set
			{
				requestName = value;
			}
		}

		public string ResponseElementName
		{
			get
			{
				if (responseName != null)
				{
					return responseName;
				}
				return string.Empty;
			}
			set
			{
				responseName = value;
			}
		}

		public SoapBindingUse Use
		{
			get
			{
				return use;
			}
			set
			{
				use = value;
			}
		}

		public SoapParameterStyle ParameterStyle
		{
			get
			{
				return style;
			}
			set
			{
				style = value;
			}
		}

		public string Binding
		{
			get
			{
				if (binding != null)
				{
					return binding;
				}
				return string.Empty;
			}
			set
			{
				binding = value;
			}
		}

		public SoapDocumentMethodAttribute()
		{
		}

		public SoapDocumentMethodAttribute(string action)
		{
			this.action = action;
		}
	}
	[AttributeUsage(AttributeTargets.Class)]
	public sealed class SoapDocumentServiceAttribute : Attribute
	{
		private SoapBindingUse use;

		private SoapParameterStyle paramStyle;

		private SoapServiceRoutingStyle routingStyle;

		public SoapBindingUse Use
		{
			get
			{
				return use;
			}
			set
			{
				use = value;
			}
		}

		public SoapParameterStyle ParameterStyle
		{
			get
			{
				return paramStyle;
			}
			set
			{
				paramStyle = value;
			}
		}

		public SoapServiceRoutingStyle RoutingStyle
		{
			get
			{
				return routingStyle;
			}
			set
			{
				routingStyle = value;
			}
		}

		public SoapDocumentServiceAttribute()
		{
		}

		public SoapDocumentServiceAttribute(SoapBindingUse use)
		{
			this.use = use;
		}

		public SoapDocumentServiceAttribute(SoapBindingUse use, SoapParameterStyle paramStyle)
		{
			this.use = use;
			this.paramStyle = paramStyle;
		}
	}
	[Serializable]
	public class SoapException : SystemException
	{
		private XmlQualifiedName code = XmlQualifiedName.Empty;

		private string actor;

		private string role;

		private XmlNode detail;

		private SoapFaultSubCode subCode;

		private string lang;

		public static readonly XmlQualifiedName ServerFaultCode = new XmlQualifiedName("Server", "http://schemas.xmlsoap.org/soap/envelope/");

		public static readonly XmlQualifiedName ClientFaultCode = new XmlQualifiedName("Client", "http://schemas.xmlsoap.org/soap/envelope/");

		public static readonly XmlQualifiedName VersionMismatchFaultCode = new XmlQualifiedName("VersionMismatch", "http://schemas.xmlsoap.org/soap/envelope/");

		public static readonly XmlQualifiedName MustUnderstandFaultCode = new XmlQualifiedName("MustUnderstand", "http://schemas.xmlsoap.org/soap/envelope/");

		public static readonly XmlQualifiedName DetailElementName = new XmlQualifiedName("detail", "");

		public string Actor
		{
			get
			{
				if (actor != null)
				{
					return actor;
				}
				return string.Empty;
			}
		}

		public XmlQualifiedName Code => code;

		public XmlNode Detail => detail;

		[ComVisible(false)]
		public string Lang
		{
			get
			{
				if (lang != null)
				{
					return lang;
				}
				return string.Empty;
			}
		}

		[ComVisible(false)]
		public string Node
		{
			get
			{
				if (actor != null)
				{
					return actor;
				}
				return string.Empty;
			}
		}

		[ComVisible(false)]
		public string Role
		{
			get
			{
				if (role != null)
				{
					return role;
				}
				return string.Empty;
			}
		}

		[ComVisible(false)]
		public SoapFaultSubCode SubCode => subCode;

		public static bool IsServerFaultCode(XmlQualifiedName code)
		{
			if (!(code == ServerFaultCode))
			{
				return code == Soap12FaultCodes.ReceiverFaultCode;
			}
			return true;
		}

		public static bool IsClientFaultCode(XmlQualifiedName code)
		{
			if (!(code == ClientFaultCode))
			{
				return code == Soap12FaultCodes.SenderFaultCode;
			}
			return true;
		}

		public static bool IsVersionMismatchFaultCode(XmlQualifiedName code)
		{
			if (!(code == VersionMismatchFaultCode))
			{
				return code == Soap12FaultCodes.VersionMismatchFaultCode;
			}
			return true;
		}

		public static bool IsMustUnderstandFaultCode(XmlQualifiedName code)
		{
			if (!(code == MustUnderstandFaultCode))
			{
				return code == Soap12FaultCodes.MustUnderstandFaultCode;
			}
			return true;
		}

		public SoapException()
			: base(null)
		{
		}

		public SoapException(string message, XmlQualifiedName code, string actor)
			: base(message)
		{
			this.code = code;
			this.actor = actor;
		}

		public SoapException(string message, XmlQualifiedName code, string actor, Exception innerException)
			: base(message, innerException)
		{
			this.code = code;
			this.actor = actor;
		}

		public SoapException(string message, XmlQualifiedName code)
			: base(message)
		{
			this.code = code;
		}

		public SoapException(string message, XmlQualifiedName code, Exception innerException)
			: base(message, innerException)
		{
			this.code = code;
		}

		public SoapException(string message, XmlQualifiedName code, string actor, XmlNode detail)
			: base(message)
		{
			this.code = code;
			this.actor = actor;
			this.detail = detail;
		}

		public SoapException(string message, XmlQualifiedName code, string actor, XmlNode detail, Exception innerException)
			: base(message, innerException)
		{
			this.code = code;
			this.actor = actor;
			this.detail = detail;
		}

		public SoapException(string message, XmlQualifiedName code, SoapFaultSubCode subCode)
			: base(message)
		{
			this.code = code;
			this.subCode = subCode;
		}

		public SoapException(string message, XmlQualifiedName code, string actor, string role, XmlNode detail, SoapFaultSubCode subCode, Exception innerException)
			: base(message, innerException)
		{
			this.code = code;
			this.actor = actor;
			this.role = role;
			this.detail = detail;
			this.subCode = subCode;
		}

		public SoapException(string message, XmlQualifiedName code, string actor, string role, string lang, XmlNode detail, SoapFaultSubCode subCode, Exception innerException)
			: base(message, innerException)
		{
			this.code = code;
			this.actor = actor;
			this.role = role;
			this.detail = detail;
			this.lang = lang;
			this.subCode = subCode;
		}

		protected SoapException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
			IDictionary data = base.Data;
			code = (XmlQualifiedName)data["code"];
			actor = (string)data["actor"];
			role = (string)data["role"];
			subCode = (SoapFaultSubCode)data["subCode"];
			lang = (string)data["lang"];
		}

		internal void ClearSubCode()
		{
			if (subCode != null)
			{
				subCode = subCode.SubCode;
			}
		}

		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
		public override void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			IDictionary data = Data;
			data["code"] = Code;
			data["actor"] = Actor;
			data["role"] = Role;
			data["subCode"] = SubCode;
			data["lang"] = Lang;
			base.GetObjectData(info, context);
		}

		private static SoapException CreateSuppressedException(SoapProtocolVersion soapVersion, string message, Exception innerException)
		{
			return new SoapException(Res.GetString("WebSuppressedExceptionMessage"), (soapVersion == SoapProtocolVersion.Soap12) ? new XmlQualifiedName("Receiver", "http://www.w3.org/2003/05/soap-envelope") : new XmlQualifiedName("Server", "http://schemas.xmlsoap.org/soap/envelope/"));
		}

		internal static SoapException Create(SoapProtocolVersion soapVersion, string message, XmlQualifiedName code, string actor, string role, XmlNode detail, SoapFaultSubCode subCode, Exception innerException)
		{
			if (WebServicesSection.Current.Diagnostics.SuppressReturningExceptions)
			{
				return CreateSuppressedException(soapVersion, Res.GetString("WebSuppressedExceptionMessage"), innerException);
			}
			return new SoapException(message, code, actor, role, detail, subCode, innerException);
		}

		internal static SoapException Create(SoapProtocolVersion soapVersion, string message, XmlQualifiedName code, Exception innerException)
		{
			if (WebServicesSection.Current.Diagnostics.SuppressReturningExceptions)
			{
				return CreateSuppressedException(soapVersion, Res.GetString("WebSuppressedExceptionMessage"), innerException);
			}
			return new SoapException(message, code, innerException);
		}
	}
	public abstract class SoapExtension
	{
		public abstract object GetInitializer(LogicalMethodInfo methodInfo, SoapExtensionAttribute attribute);

		public abstract object GetInitializer(Type serviceType);

		public abstract void Initialize(object initializer);

		public abstract void ProcessMessage(SoapMessage message);

		public virtual Stream ChainStream(Stream stream)
		{
			return stream;
		}
	}
	public abstract class SoapExtensionAttribute : Attribute
	{
		public abstract Type ExtensionType { get; }

		public abstract int Priority { get; set; }
	}
	internal class SoapExtensionStream : Stream
	{
		internal Stream innerStream;

		private bool hasWritten;

		private bool streamReady;

		public override bool CanRead
		{
			get
			{
				EnsureStreamReady();
				return innerStream.CanRead;
			}
		}

		public override bool CanSeek
		{
			get
			{
				EnsureStreamReady();
				return innerStream.CanSeek;
			}
		}

		public override bool CanWrite
		{
			get
			{
				EnsureStreamReady();
				return innerStream.CanWrite;
			}
		}

		internal bool HasWritten => hasWritten;

		public override long Length
		{
			get
			{
				EnsureStreamReady();
				return innerStream.Length;
			}
		}

		public override long Position
		{
			get
			{
				EnsureStreamReady();
				return innerStream.Position;
			}
			set
			{
				EnsureStreamReady();
				hasWritten = true;
				innerStream.Position = value;
			}
		}

		internal SoapExtensionStream()
		{
		}

		private bool EnsureStreamReady()
		{
			if (streamReady)
			{
				return true;
			}
			throw new InvalidOperationException(Res.GetString("WebBadStreamState"));
		}

		protected override void Dispose(bool disposing)
		{
			try
			{
				if (disposing)
				{
					EnsureStreamReady();
					hasWritten = true;
					innerStream.Close();
				}
			}
			finally
			{
				base.Dispose(disposing);
			}
		}

		public override void Flush()
		{
			EnsureStreamReady();
			hasWritten = true;
			innerStream.Flush();
		}

		public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
		{
			EnsureStreamReady();
			return innerStream.BeginRead(buffer, offset, count, callback, state);
		}

		public override int EndRead(IAsyncResult asyncResult)
		{
			EnsureStreamReady();
			return innerStream.EndRead(asyncResult);
		}

		public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
		{
			EnsureStreamReady();
			hasWritten = true;
			return innerStream.BeginWrite(buffer, offset, count, callback, state);
		}

		public override void EndWrite(IAsyncResult asyncResult)
		{
			EnsureStreamReady();
			hasWritten = true;
			innerStream.EndWrite(asyncResult);
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			EnsureStreamReady();
			return innerStream.Seek(offset, origin);
		}

		public override void SetLength(long value)
		{
			EnsureStreamReady();
			innerStream.SetLength(value);
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			EnsureStreamReady();
			return innerStream.Read(buffer, offset, count);
		}

		public override int ReadByte()
		{
			EnsureStreamReady();
			return innerStream.ReadByte();
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			EnsureStreamReady();
			hasWritten = true;
			innerStream.Write(buffer, offset, count);
		}

		public override void WriteByte(byte value)
		{
			EnsureStreamReady();
			hasWritten = true;
			innerStream.WriteByte(value);
		}

		internal void SetInnerStream(Stream stream)
		{
			innerStream = stream;
			hasWritten = false;
		}

		internal void SetStreamReady()
		{
			streamReady = true;
		}
	}
	public sealed class Soap12FaultCodes
	{
		public static readonly XmlQualifiedName ReceiverFaultCode = new XmlQualifiedName("Receiver", "http://www.w3.org/2003/05/soap-envelope");

		public static readonly XmlQualifiedName SenderFaultCode = new XmlQualifiedName("Sender", "http://www.w3.org/2003/05/soap-envelope");

		public static readonly XmlQualifiedName VersionMismatchFaultCode = new XmlQualifiedName("VersionMismatch", "http://www.w3.org/2003/05/soap-envelope");

		public static readonly XmlQualifiedName MustUnderstandFaultCode = new XmlQualifiedName("MustUnderstand", "http://www.w3.org/2003/05/soap-envelope");

		public static readonly XmlQualifiedName DataEncodingUnknownFaultCode = new XmlQualifiedName("DataEncodingUnknown", "http://www.w3.org/2003/05/soap-envelope");

		public static readonly XmlQualifiedName RpcProcedureNotPresentFaultCode = new XmlQualifiedName("ProcedureNotPresent", "http://www.w3.org/2003/05/soap-rpc");

		public static readonly XmlQualifiedName RpcBadArgumentsFaultCode = new XmlQualifiedName("BadArguments", "http://www.w3.org/2003/05/soap-rpc");

		public static readonly XmlQualifiedName EncodingMissingIdFaultCode = new XmlQualifiedName("MissingID", "http://www.w3.org/2003/05/soap-encoding");

		public static readonly XmlQualifiedName EncodingUntypedValueFaultCode = new XmlQualifiedName("UntypedValue", "http://www.w3.org/2003/05/soap-encoding");

		internal static readonly XmlQualifiedName UnsupportedMediaTypeFaultCode = new XmlQualifiedName("UnsupportedMediaType", "http://microsoft.com/soap/");

		internal static readonly XmlQualifiedName MethodNotAllowed = new XmlQualifiedName("MethodNotAllowed", "http://microsoft.com/soap/");

		private Soap12FaultCodes()
		{
		}
	}
	[Serializable]
	public class SoapFaultSubCode
	{
		private XmlQualifiedName code;

		private SoapFaultSubCode subCode;

		public XmlQualifiedName Code => code;

		public SoapFaultSubCode SubCode => subCode;

		public SoapFaultSubCode(XmlQualifiedName code)
			: this(code, null)
		{
		}

		public SoapFaultSubCode(XmlQualifiedName code, SoapFaultSubCode subCode)
		{
			this.code = code;
			this.subCode = subCode;
		}
	}
	[SoapType(IncludeInSchema = false)]
	[XmlType(IncludeInSchema = false)]
	public abstract class SoapHeader
	{
		private string actor;

		private bool mustUnderstand;

		private bool didUnderstand;

		private bool relay;

		internal SoapProtocolVersion version;

		[SoapAttribute("mustUnderstand", Namespace = "http://schemas.xmlsoap.org/soap/envelope/")]
		[DefaultValue("0")]
		[XmlAttribute("mustUnderstand", Namespace = "http://schemas.xmlsoap.org/soap/envelope/")]
		public string EncodedMustUnderstand
		{
			get
			{
				if (version == SoapProtocolVersion.Soap12 || !MustUnderstand)
				{
					return "0";
				}
				return "1";
			}
			set
			{
				switch (value)
				{
				case "false":
				case "0":
					MustUnderstand = false;
					break;
				case "true":
				case "1":
					MustUnderstand = true;
					break;
				default:
					throw new ArgumentException(Res.GetString("WebHeaderInvalidMustUnderstand", value));
				}
			}
		}

		[XmlAttribute("mustUnderstand", Namespace = "http://www.w3.org/2003/05/soap-envelope")]
		[SoapAttribute("mustUnderstand", Namespace = "http://www.w3.org/2003/05/soap-envelope")]
		[DefaultValue("0")]
		[ComVisible(false)]
		public string EncodedMustUnderstand12
		{
			get
			{
				if (version == SoapProtocolVersion.Soap11 || !MustUnderstand)
				{
					return "0";
				}
				return "1";
			}
			set
			{
				EncodedMustUnderstand = value;
			}
		}

		[SoapIgnore]
		[XmlIgnore]
		public bool MustUnderstand
		{
			get
			{
				return InternalMustUnderstand;
			}
			set
			{
				InternalMustUnderstand = value;
			}
		}

		internal virtual bool InternalMustUnderstand
		{
			[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
			get
			{
				return mustUnderstand;
			}
			[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
			set
			{
				mustUnderstand = value;
			}
		}

		[XmlAttribute("actor", Namespace = "http://schemas.xmlsoap.org/soap/envelope/")]
		[SoapAttribute("actor", Namespace = "http://schemas.xmlsoap.org/soap/envelope/")]
		[DefaultValue("")]
		public string Actor
		{
			get
			{
				if (version == SoapProtocolVersion.Soap12)
				{
					return "";
				}
				return InternalActor;
			}
			set
			{
				InternalActor = value;
			}
		}

		[ComVisible(false)]
		[XmlAttribute("role", Namespace = "http://www.w3.org/2003/05/soap-envelope")]
		[DefaultValue("")]
		[SoapAttribute("role", Namespace = "http://www.w3.org/2003/05/soap-envelope")]
		public string Role
		{
			get
			{
				if (version == SoapProtocolVersion.Soap11)
				{
					return "";
				}
				return InternalActor;
			}
			set
			{
				InternalActor = value;
			}
		}

		internal virtual string InternalActor
		{
			[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
			get
			{
				if (actor != null)
				{
					return actor;
				}
				return string.Empty;
			}
			[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
			set
			{
				actor = value;
			}
		}

		[XmlIgnore]
		[SoapIgnore]
		public bool DidUnderstand
		{
			get
			{
				return didUnderstand;
			}
			set
			{
				didUnderstand = value;
			}
		}

		[SoapAttribute("relay", Namespace = "http://www.w3.org/2003/05/soap-envelope")]
		[DefaultValue("0")]
		[XmlAttribute("relay", Namespace = "http://www.w3.org/2003/05/soap-envelope")]
		[ComVisible(false)]
		public string EncodedRelay
		{
			get
			{
				if (version == SoapProtocolVersion.Soap11 || !Relay)
				{
					return "0";
				}
				return "1";
			}
			set
			{
				switch (value)
				{
				case "false":
				case "0":
					Relay = false;
					break;
				case "true":
				case "1":
					Relay = true;
					break;
				default:
					throw new ArgumentException(Res.GetString("WebHeaderInvalidRelay", value));
				}
			}
		}

		[ComVisible(false)]
		[XmlIgnore]
		[SoapIgnore]
		public bool Relay
		{
			get
			{
				return InternalRelay;
			}
			set
			{
				InternalRelay = value;
			}
		}

		internal virtual bool InternalRelay
		{
			[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
			get
			{
				return relay;
			}
			[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
			set
			{
				relay = value;
			}
		}
	}
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	public sealed class SoapHeaderMapping
	{
		internal Type headerType;

		internal bool repeats;

		internal bool custom;

		internal SoapHeaderDirection direction;

		internal MemberInfo memberInfo;

		public Type HeaderType => headerType;

		public bool Repeats => repeats;

		public bool Custom => custom;

		public SoapHeaderDirection Direction => direction;

		public MemberInfo MemberInfo => memberInfo;

		internal SoapHeaderMapping()
		{
		}
	}
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	public sealed class SoapHeaderHandling
	{
		private SoapHeaderCollection unknownHeaders;

		private SoapHeaderCollection unreferencedHeaders;

		private int currentThread;

		private string envelopeNS;

		private void OnUnknownElement(object sender, XmlElementEventArgs e)
		{
			if (Thread.CurrentThread.GetHashCode() == currentThread && e.Element != null)
			{
				SoapUnknownHeader soapUnknownHeader = new SoapUnknownHeader();
				soapUnknownHeader.Element = e.Element;
				unknownHeaders.Add(soapUnknownHeader);
			}
		}

		private void OnUnreferencedObject(object sender, UnreferencedObjectEventArgs e)
		{
			if (Thread.CurrentThread.GetHashCode() == currentThread)
			{
				object unreferencedObject = e.UnreferencedObject;
				if (unreferencedObject != null && typeof(SoapHeader).IsAssignableFrom(unreferencedObject.GetType()))
				{
					unreferencedHeaders.Add((SoapHeader)unreferencedObject);
				}
			}
		}

		public string ReadHeaders(XmlReader reader, XmlSerializer serializer, SoapHeaderCollection headers, SoapHeaderMapping[] mappings, SoapHeaderDirection direction, string envelopeNS, string encodingStyle, bool checkRequiredHeaders)
		{
			string text = null;
			reader.MoveToContent();
			if (!reader.IsStartElement("Header", envelopeNS))
			{
				if (checkRequiredHeaders && mappings != null && mappings.Length > 0)
				{
					text = GetHeaderElementName(mappings[0].headerType);
				}
				return text;
			}
			if (reader.IsEmptyElement)
			{
				reader.Skip();
				return text;
			}
			unknownHeaders = new SoapHeaderCollection();
			unreferencedHeaders = new SoapHeaderCollection();
			currentThread = Thread.CurrentThread.GetHashCode();
			this.envelopeNS = envelopeNS;
			int depth = reader.Depth;
			reader.ReadStartElement();
			reader.MoveToContent();
			XmlDeserializationEvents events = default(XmlDeserializationEvents);
			events.OnUnknownElement = OnUnknownElement;
			events.OnUnreferencedObject = OnUnreferencedObject;
			TraceMethod caller = (Tracing.On ? new TraceMethod(this, "ReadHeaders") : null);
			if (Tracing.On)
			{
				Tracing.Enter(Tracing.TraceId("TraceReadHeaders"), caller, new TraceMethod(serializer, "Deserialize", reader, encodingStyle));
			}
			object[] array = (object[])serializer.Deserialize(reader, encodingStyle, events);
			if (Tracing.On)
			{
				Tracing.Exit(Tracing.TraceId("TraceReadHeaders"), caller);
			}
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] != null)
				{
					SoapHeader soapHeader = (SoapHeader)array[i];
					soapHeader.DidUnderstand = true;
					headers.Add(soapHeader);
				}
				else if (checkRequiredHeaders && text == null)
				{
					text = GetHeaderElementName(mappings[i].headerType);
				}
			}
			currentThread = 0;
			this.envelopeNS = null;
			foreach (SoapHeader unreferencedHeader in unreferencedHeaders)
			{
				headers.Add(unreferencedHeader);
			}
			unreferencedHeaders = null;
			foreach (SoapHeader unknownHeader in unknownHeaders)
			{
				headers.Add(unknownHeader);
			}
			unknownHeaders = null;
			while (depth < reader.Depth && reader.Read())
			{
			}
			if (reader.NodeType == XmlNodeType.EndElement)
			{
				reader.Read();
			}
			return text;
		}

		public static void WriteHeaders(XmlWriter writer, XmlSerializer serializer, SoapHeaderCollection headers, SoapHeaderMapping[] mappings, SoapHeaderDirection direction, bool isEncoded, string defaultNS, bool serviceDefaultIsEncoded, string envelopeNS)
		{
			if (headers.Count == 0)
			{
				return;
			}
			writer.WriteStartElement("Header", envelopeNS);
			SoapProtocolVersion version;
			string text;
			if (envelopeNS == "http://www.w3.org/2003/05/soap-envelope")
			{
				version = SoapProtocolVersion.Soap12;
				text = "http://www.w3.org/2003/05/soap-encoding";
			}
			else
			{
				version = SoapProtocolVersion.Soap11;
				text = "http://schemas.xmlsoap.org/soap/encoding/";
			}
			int num = 0;
			ArrayList arrayList = new ArrayList();
			SoapHeader[] array = new SoapHeader[mappings.Length];
			bool[] array2 = new bool[array.Length];
			for (int i = 0; i < headers.Count; i++)
			{
				SoapHeader soapHeader = headers[i];
				if (soapHeader != null)
				{
					soapHeader.version = version;
					int num2;
					if (soapHeader is SoapUnknownHeader)
					{
						arrayList.Add(soapHeader);
						num++;
					}
					else if ((num2 = FindMapping(mappings, soapHeader, direction)) >= 0 && !array2[num2])
					{
						array[num2] = soapHeader;
						array2[num2] = true;
					}
					else
					{
						arrayList.Add(soapHeader);
					}
				}
			}
			int num3 = arrayList.Count - num;
			if (isEncoded && num3 > 0)
			{
				SoapHeader[] array3 = new SoapHeader[mappings.Length + num3];
				array.CopyTo(array3, 0);
				int num4 = mappings.Length;
				for (int j = 0; j < arrayList.Count; j++)
				{
					if (!(arrayList[j] is SoapUnknownHeader))
					{
						array3[num4++] = (SoapHeader)arrayList[j];
					}
				}
				array = array3;
			}
			TraceMethod caller = (Tracing.On ? new TraceMethod(typeof(SoapHeaderHandling), "WriteHeaders") : null);
			if (Tracing.On)
			{
				Tracing.Enter(Tracing.TraceId("TraceWriteHeaders"), caller, new TraceMethod(serializer, "Serialize", writer, array, null, isEncoded ? text : null, "h_"));
			}
			serializer.Serialize(writer, array, null, isEncoded ? text : null, "h_");
			if (Tracing.On)
			{
				Tracing.Exit(Tracing.TraceId("TraceWriteHeaders"), caller);
			}
			foreach (SoapHeader item in arrayList)
			{
				if (item is SoapUnknownHeader)
				{
					SoapUnknownHeader soapUnknownHeader = (SoapUnknownHeader)item;
					if (soapUnknownHeader.Element != null)
					{
						soapUnknownHeader.Element.WriteTo(writer);
					}
				}
				else if (!isEncoded)
				{
					string literalNamespace = SoapReflector.GetLiteralNamespace(defaultNS, serviceDefaultIsEncoded);
					XmlSerializer xmlSerializer = new XmlSerializer(item.GetType(), literalNamespace);
					if (Tracing.On)
					{
						Tracing.Enter(Tracing.TraceId("TraceWriteHeaders"), caller, new TraceMethod(xmlSerializer, "Serialize", writer, item));
					}
					xmlSerializer.Serialize(writer, item);
					if (Tracing.On)
					{
						Tracing.Exit(Tracing.TraceId("TraceWriteHeaders"), caller);
					}
				}
			}
			for (int k = 0; k < headers.Count; k++)
			{
				SoapHeader soapHeader3 = headers[k];
				if (soapHeader3 != null)
				{
					soapHeader3.version = SoapProtocolVersion.Default;
				}
			}
			writer.WriteEndElement();
			writer.Flush();
		}

		public static void WriteUnknownHeaders(XmlWriter writer, SoapHeaderCollection headers, string envelopeNS)
		{
			bool flag = true;
			foreach (SoapHeader header in headers)
			{
				if (header is SoapUnknownHeader soapUnknownHeader)
				{
					if (flag)
					{
						writer.WriteStartElement("Header", envelopeNS);
						flag = false;
					}
					if (soapUnknownHeader.Element != null)
					{
						soapUnknownHeader.Element.WriteTo(writer);
					}
				}
			}
			if (!flag)
			{
				writer.WriteEndElement();
			}
		}

		public static void SetHeaderMembers(SoapHeaderCollection headers, object target, SoapHeaderMapping[] mappings, SoapHeaderDirection direction, bool client)
		{
			bool[] array = new bool[headers.Count];
			if (mappings != null)
			{
				foreach (SoapHeaderMapping soapHeaderMapping in mappings)
				{
					if ((soapHeaderMapping.direction & direction) == 0)
					{
						continue;
					}
					if (soapHeaderMapping.repeats)
					{
						ArrayList arrayList = new ArrayList();
						for (int j = 0; j < headers.Count; j++)
						{
							SoapHeader soapHeader = headers[j];
							if (!array[j] && soapHeaderMapping.headerType.IsAssignableFrom(soapHeader.GetType()))
							{
								arrayList.Add(soapHeader);
								array[j] = true;
							}
						}
						MemberHelper.SetValue(soapHeaderMapping.memberInfo, target, arrayList.ToArray(soapHeaderMapping.headerType));
						continue;
					}
					bool flag = false;
					for (int k = 0; k < headers.Count; k++)
					{
						SoapHeader soapHeader2 = headers[k];
						if (!array[k] && soapHeaderMapping.headerType.IsAssignableFrom(soapHeader2.GetType()))
						{
							if (flag)
							{
								soapHeader2.DidUnderstand = false;
								continue;
							}
							flag = true;
							MemberHelper.SetValue(soapHeaderMapping.memberInfo, target, soapHeader2);
							array[k] = true;
						}
					}
				}
			}
			for (int l = 0; l < array.Length; l++)
			{
				if (!array[l])
				{
					SoapHeader soapHeader3 = headers[l];
					if (soapHeader3.MustUnderstand && !soapHeader3.DidUnderstand)
					{
						throw new SoapHeaderException(Res.GetString("WebCannotUnderstandHeader", GetHeaderElementName(soapHeader3)), new XmlQualifiedName("MustUnderstand", "http://schemas.xmlsoap.org/soap/envelope/"));
					}
				}
			}
		}

		public static void GetHeaderMembers(SoapHeaderCollection headers, object target, SoapHeaderMapping[] mappings, SoapHeaderDirection direction, bool client)
		{
			if (mappings == null || mappings.Length == 0)
			{
				return;
			}
			foreach (SoapHeaderMapping soapHeaderMapping in mappings)
			{
				if ((soapHeaderMapping.direction & direction) == 0)
				{
					continue;
				}
				object value = MemberHelper.GetValue(soapHeaderMapping.memberInfo, target);
				if (soapHeaderMapping.repeats)
				{
					object[] array = (object[])value;
					if (array == null)
					{
						continue;
					}
					for (int j = 0; j < array.Length; j++)
					{
						if (array[j] != null)
						{
							headers.Add((SoapHeader)array[j]);
						}
					}
				}
				else if (value != null)
				{
					headers.Add((SoapHeader)value);
				}
			}
		}

		public static void EnsureHeadersUnderstood(SoapHeaderCollection headers)
		{
			for (int i = 0; i < headers.Count; i++)
			{
				SoapHeader soapHeader = headers[i];
				if (soapHeader.MustUnderstand && !soapHeader.DidUnderstand)
				{
					throw new SoapHeaderException(Res.GetString("WebCannotUnderstandHeader", GetHeaderElementName(soapHeader)), new XmlQualifiedName("MustUnderstand", "http://schemas.xmlsoap.org/soap/envelope/"));
				}
			}
		}

		private static int FindMapping(SoapHeaderMapping[] mappings, SoapHeader header, SoapHeaderDirection direction)
		{
			if (mappings == null || mappings.Length == 0)
			{
				return -1;
			}
			Type type = header.GetType();
			for (int i = 0; i < mappings.Length; i++)
			{
				SoapHeaderMapping soapHeaderMapping = mappings[i];
				if ((soapHeaderMapping.direction & direction) != 0 && soapHeaderMapping.custom && soapHeaderMapping.headerType.IsAssignableFrom(type))
				{
					return i;
				}
			}
			return -1;
		}

		private static string GetHeaderElementName(Type headerType)
		{
			XmlReflectionImporter xmlReflectionImporter = SoapReflector.CreateXmlImporter(null, serviceDefaultIsEncoded: false);
			XmlTypeMapping xmlTypeMapping = xmlReflectionImporter.ImportTypeMapping(headerType);
			return xmlTypeMapping.XsdElementName;
		}

		private static string GetHeaderElementName(SoapHeader header)
		{
			if (header is SoapUnknownHeader)
			{
				return ((SoapUnknownHeader)header).Element.LocalName;
			}
			return GetHeaderElementName(header.GetType());
		}
	}
	[AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
	public sealed class SoapHeaderAttribute : Attribute
	{
		private string memberName;

		private SoapHeaderDirection direction = SoapHeaderDirection.In;

		private bool required = true;

		public string MemberName
		{
			get
			{
				if (memberName != null)
				{
					return memberName;
				}
				return string.Empty;
			}
			set
			{
				memberName = value;
			}
		}

		public SoapHeaderDirection Direction
		{
			get
			{
				return direction;
			}
			set
			{
				direction = value;
			}
		}

		[Obsolete("This property will be removed from a future version. The presence of a particular header in a SOAP message is no longer enforced", false)]
		public bool Required
		{
			get
			{
				return required;
			}
			set
			{
				required = value;
			}
		}

		public SoapHeaderAttribute(string memberName)
		{
			this.memberName = memberName;
		}
	}
	[Flags]
	public enum SoapHeaderDirection
	{
		In = 1,
		Out = 2,
		InOut = 3,
		Fault = 4
	}
	[Serializable]
	public class SoapHeaderException : SoapException
	{
		public SoapHeaderException()
		{
		}

		public SoapHeaderException(string message, XmlQualifiedName code, string actor)
			: base(message, code, actor)
		{
		}

		public SoapHeaderException(string message, XmlQualifiedName code, string actor, Exception innerException)
			: base(message, code, actor, innerException)
		{
		}

		public SoapHeaderException(string message, XmlQualifiedName code)
			: base(message, code)
		{
		}

		public SoapHeaderException(string message, XmlQualifiedName code, Exception innerException)
			: base(message, code, innerException)
		{
		}

		public SoapHeaderException(string message, XmlQualifiedName code, string actor, string role, SoapFaultSubCode subCode, Exception innerException)
			: base(message, code, actor, role, null, null, subCode, innerException)
		{
		}

		public SoapHeaderException(string message, XmlQualifiedName code, string actor, string role, string lang, SoapFaultSubCode subCode, Exception innerException)
			: base(message, code, actor, role, lang, null, subCode, innerException)
		{
		}

		protected SoapHeaderException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}
	}
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	public class SoapHeaderCollection : CollectionBase
	{
		public SoapHeader this[int index]
		{
			get
			{
				return (SoapHeader)base.List[index];
			}
			set
			{
				base.List[index] = value;
			}
		}

		public int Add(SoapHeader header)
		{
			return base.List.Add(header);
		}

		public void Insert(int index, SoapHeader header)
		{
			base.List.Insert(index, header);
		}

		public int IndexOf(SoapHeader header)
		{
			return base.List.IndexOf(header);
		}

		public bool Contains(SoapHeader header)
		{
			return base.List.Contains(header);
		}

		public void Remove(SoapHeader header)
		{
			base.List.Remove(header);
		}

		public void CopyTo(SoapHeader[] array, int index)
		{
			base.List.CopyTo(array, index);
		}
	}
	public enum SoapMessageStage
	{
		BeforeSerialize = 1,
		AfterSerialize = 2,
		BeforeDeserialize = 4,
		AfterDeserialize = 8
	}
	public enum SoapParameterStyle
	{
		Default,
		Bare,
		Wrapped
	}
	public enum SoapProtocolVersion
	{
		Default,
		Soap11,
		Soap12
	}
	internal class SoapReflectedHeader
	{
		internal Type headerType;

		internal MemberInfo memberInfo;

		internal SoapHeaderDirection direction;

		internal bool repeats;

		internal bool custom;
	}
	internal class SoapReflectedExtension : IComparable
	{
		private Type type;

		private SoapExtensionAttribute attribute;

		private int priority;

		internal SoapReflectedExtension(Type type, SoapExtensionAttribute attribute)
			: this(type, attribute, attribute.Priority)
		{
		}

		internal SoapReflectedExtension(Type type, SoapExtensionAttribute attribute, int priority)
		{
			if (priority < 0)
			{
				throw new ArgumentException(Res.GetString("WebConfigInvalidExtensionPriority", priority), "priority");
			}
			this.type = type;
			this.attribute = attribute;
			this.priority = priority;
		}

		internal SoapExtension CreateInstance(object initializer)
		{
			SoapExtension soapExtension = (SoapExtension)Activator.CreateInstance(type);
			soapExtension.Initialize(initializer);
			return soapExtension;
		}

		internal object GetInitializer(LogicalMethodInfo methodInfo)
		{
			SoapExtension soapExtension = (SoapExtension)Activator.CreateInstance(type);
			return soapExtension.GetInitializer(methodInfo, attribute);
		}

		internal object GetInitializer(Type serviceType)
		{
			SoapExtension soapExtension = (SoapExtension)Activator.CreateInstance(type);
			return soapExtension.GetInitializer(serviceType);
		}

		internal static object[] GetInitializers(LogicalMethodInfo methodInfo, SoapReflectedExtension[] extensions)
		{
			object[] array = new object[extensions.Length];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = extensions[i].GetInitializer(methodInfo);
			}
			return array;
		}

		internal static object[] GetInitializers(Type serviceType, SoapReflectedExtension[] extensions)
		{
			object[] array = new object[extensions.Length];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = extensions[i].GetInitializer(serviceType);
			}
			return array;
		}

		public int CompareTo(object o)
		{
			return priority - ((SoapReflectedExtension)o).priority;
		}
	}
	internal class SoapReflectedMethod
	{
		internal LogicalMethodInfo methodInfo;

		internal string action;

		internal string name;

		internal XmlMembersMapping requestMappings;

		internal XmlMembersMapping responseMappings;

		internal XmlMembersMapping inHeaderMappings;

		internal XmlMembersMapping outHeaderMappings;

		internal SoapReflectedHeader[] headers;

		internal SoapReflectedExtension[] extensions;

		internal bool oneWay;

		internal bool rpc;

		internal SoapBindingUse use;

		internal SoapParameterStyle paramStyle;

		internal WebServiceBindingAttribute binding;

		internal XmlQualifiedName requestElementName;

		internal XmlQualifiedName portType;

		internal bool IsClaimsConformance
		{
			get
			{
				if (binding != null)
				{
					return binding.ConformsTo == WsiProfiles.BasicProfile1_1;
				}
				return false;
			}
		}
	}
	internal class SoapHeaderAttributeComparer : IComparer
	{
		public int Compare(object x, object y)
		{
			return string.Compare(((SoapHeaderAttribute)x).MemberName, ((SoapHeaderAttribute)y).MemberName, StringComparison.Ordinal);
		}
	}
	internal static class SoapReflector
	{
		private class SoapParameterInfo
		{
			internal ParameterInfo parameterInfo;

			internal XmlAttributes xmlAttributes;

			internal SoapAttributes soapAttributes;
		}

		private class MethodAttribute
		{
			internal string action;

			internal string binding;

			internal string requestName;

			internal string requestNs;

			internal string responseName;

			internal string responseNs;
		}

		internal static bool ServiceDefaultIsEncoded(Type type)
		{
			return ServiceDefaultIsEncoded(GetSoapServiceAttribute(type));
		}

		internal static bool ServiceDefaultIsEncoded(object soapServiceAttribute)
		{
			if (soapServiceAttribute == null)
			{
				return false;
			}
			if (soapServiceAttribute is SoapDocumentServiceAttribute)
			{
				return ((SoapDocumentServiceAttribute)soapServiceAttribute).Use == SoapBindingUse.Encoded;
			}
			if (soapServiceAttribute is SoapRpcServiceAttribute)
			{
				return ((SoapRpcServiceAttribute)soapServiceAttribute).Use == SoapBindingUse.Encoded;
			}
			return false;
		}

		internal static string GetEncodedNamespace(string ns, bool serviceDefaultIsEncoded)
		{
			if (serviceDefaultIsEncoded)
			{
				return ns;
			}
			if (ns.EndsWith("/", StringComparison.Ordinal))
			{
				return ns + "encodedTypes";
			}
			return ns + "/encodedTypes";
		}

		internal static string GetLiteralNamespace(string ns, bool serviceDefaultIsEncoded)
		{
			if (!serviceDefaultIsEncoded)
			{
				return ns;
			}
			if (ns.EndsWith("/", StringComparison.Ordinal))
			{
				return ns + "literalTypes";
			}
			return ns + "/literalTypes";
		}

		internal static SoapReflectionImporter CreateSoapImporter(string defaultNs, bool serviceDefaultIsEncoded)
		{
			return new SoapReflectionImporter(GetEncodedNamespace(defaultNs, serviceDefaultIsEncoded));
		}

		internal static XmlReflectionImporter CreateXmlImporter(string defaultNs, bool serviceDefaultIsEncoded)
		{
			return new XmlReflectionImporter(GetLiteralNamespace(defaultNs, serviceDefaultIsEncoded));
		}

		internal static void IncludeTypes(LogicalMethodInfo[] methods, SoapReflectionImporter importer)
		{
			foreach (LogicalMethodInfo method in methods)
			{
				IncludeTypes(method, importer);
			}
		}

		internal static void IncludeTypes(LogicalMethodInfo method, SoapReflectionImporter importer)
		{
			if (method.Declaration != null)
			{
				importer.IncludeTypes(method.Declaration.DeclaringType);
				importer.IncludeTypes(method.Declaration);
			}
			importer.IncludeTypes(method.DeclaringType);
			importer.IncludeTypes(method.CustomAttributeProvider);
		}

		internal static object GetSoapMethodAttribute(LogicalMethodInfo methodInfo)
		{
			object[] customAttributes = methodInfo.GetCustomAttributes(typeof(SoapRpcMethodAttribute));
			object[] customAttributes2 = methodInfo.GetCustomAttributes(typeof(SoapDocumentMethodAttribute));
			if (customAttributes.Length > 0)
			{
				if (customAttributes2.Length > 0)
				{
					throw new ArgumentException(Res.GetString("WebBothMethodAttrs"), "methodInfo");
				}
				return customAttributes[0];
			}
			if (customAttributes2.Length > 0)
			{
				return customAttributes2[0];
			}
			return null;
		}

		internal static object GetSoapServiceAttribute(Type type)
		{
			object[] customAttributes = type.GetCustomAttributes(typeof(SoapRpcServiceAttribute), inherit: false);
			object[] customAttributes2 = type.GetCustomAttributes(typeof(SoapDocumentServiceAttribute), inherit: false);
			if (customAttributes.Length > 0)
			{
				if (customAttributes2.Length > 0)
				{
					throw new ArgumentException(Res.GetString("WebBothServiceAttrs"), "methodInfo");
				}
				return customAttributes[0];
			}
			if (customAttributes2.Length > 0)
			{
				return customAttributes2[0];
			}
			return null;
		}

		internal static SoapServiceRoutingStyle GetSoapServiceRoutingStyle(object soapServiceAttribute)
		{
			if (soapServiceAttribute is SoapRpcServiceAttribute)
			{
				return ((SoapRpcServiceAttribute)soapServiceAttribute).RoutingStyle;
			}
			if (soapServiceAttribute is SoapDocumentServiceAttribute)
			{
				return ((SoapDocumentServiceAttribute)soapServiceAttribute).RoutingStyle;
			}
			return SoapServiceRoutingStyle.SoapAction;
		}

		internal static string GetSoapMethodBinding(LogicalMethodInfo method)
		{
			object[] customAttributes = method.GetCustomAttributes(typeof(SoapDocumentMethodAttribute));
			string text;
			if (customAttributes.Length == 0)
			{
				customAttributes = method.GetCustomAttributes(typeof(SoapRpcMethodAttribute));
				text = ((customAttributes.Length != 0) ? ((SoapRpcMethodAttribute)customAttributes[0]).Binding : string.Empty);
			}
			else
			{
				text = ((SoapDocumentMethodAttribute)customAttributes[0]).Binding;
			}
			if (method.Binding != null)
			{
				if (text.Length > 0 && text != method.Binding.Name)
				{
					throw new InvalidOperationException(Res.GetString("WebInvalidBindingName", text, method.Binding.Name));
				}
				return method.Binding.Name;
			}
			return text;
		}

		internal static SoapReflectedMethod ReflectMethod(LogicalMethodInfo methodInfo, bool client, XmlReflectionImporter xmlImporter, SoapReflectionImporter soapImporter, string defaultNs)
		{
			try
			{
				string key = methodInfo.GetKey();
				SoapReflectedMethod soapReflectedMethod = new SoapReflectedMethod();
				MethodAttribute methodAttribute = new MethodAttribute();
				object soapServiceAttribute = GetSoapServiceAttribute(methodInfo.DeclaringType);
				bool serviceDefaultIsEncoded = ServiceDefaultIsEncoded(soapServiceAttribute);
				object obj = GetSoapMethodAttribute(methodInfo);
				if (obj == null)
				{
					if (client)
					{
						return null;
					}
					if (soapServiceAttribute is SoapRpcServiceAttribute)
					{
						SoapRpcMethodAttribute soapRpcMethodAttribute = new SoapRpcMethodAttribute();
						soapRpcMethodAttribute.Use = ((SoapRpcServiceAttribute)soapServiceAttribute).Use;
						obj = soapRpcMethodAttribute;
					}
					else if (soapServiceAttribute is SoapDocumentServiceAttribute)
					{
						SoapDocumentMethodAttribute soapDocumentMethodAttribute = new SoapDocumentMethodAttribute();
						soapDocumentMethodAttribute.Use = ((SoapDocumentServiceAttribute)soapServiceAttribute).Use;
						obj = soapDocumentMethodAttribute;
					}
					else
					{
						obj = new SoapDocumentMethodAttribute();
					}
				}
				if (obj is SoapRpcMethodAttribute)
				{
					SoapRpcMethodAttribute soapRpcMethodAttribute2 = (SoapRpcMethodAttribute)obj;
					soapReflectedMethod.rpc = true;
					soapReflectedMethod.use = soapRpcMethodAttribute2.Use;
					soapReflectedMethod.oneWay = soapRpcMethodAttribute2.OneWay;
					methodAttribute.action = soapRpcMethodAttribute2.Action;
					methodAttribute.binding = soapRpcMethodAttribute2.Binding;
					methodAttribute.requestName = soapRpcMethodAttribute2.RequestElementName;
					methodAttribute.requestNs = soapRpcMethodAttribute2.RequestNamespace;
					methodAttribute.responseName = soapRpcMethodAttribute2.ResponseElementName;
					methodAttribute.responseNs = soapRpcMethodAttribute2.ResponseNamespace;
				}
				else
				{
					SoapDocumentMethodAttribute soapDocumentMethodAttribute2 = (SoapDocumentMethodAttribute)obj;
					soapReflectedMethod.rpc = false;
					soapReflectedMethod.use = soapDocumentMethodAttribute2.Use;
					soapReflectedMethod.paramStyle = soapDocumentMethodAttribute2.ParameterStyle;
					soapReflectedMethod.oneWay = soapDocumentMethodAttribute2.OneWay;
					methodAttribute.action = soapDocumentMethodAttribute2.Action;
					methodAttribute.binding = soapDocumentMethodAttribute2.Binding;
					methodAttribute.requestName = soapDocumentMethodAttribute2.RequestElementName;
					methodAttribute.requestNs = soapDocumentMethodAttribute2.RequestNamespace;
					methodAttribute.responseName = soapDocumentMethodAttribute2.ResponseElementName;
					methodAttribute.responseNs = soapDocumentMethodAttribute2.ResponseNamespace;
					if (soapReflectedMethod.use == SoapBindingUse.Default)
					{
						if (soapServiceAttribute is SoapDocumentServiceAttribute)
						{
							soapReflectedMethod.use = ((SoapDocumentServiceAttribute)soapServiceAttribute).Use;
						}
						if (soapReflectedMethod.use == SoapBindingUse.Default)
						{
							soapReflectedMethod.use = SoapBindingUse.Literal;
						}
					}
					if (soapReflectedMethod.paramStyle == SoapParameterStyle.Default)
					{
						if (soapServiceAttribute is SoapDocumentServiceAttribute)
						{
							soapReflectedMethod.paramStyle = ((SoapDocumentServiceAttribute)soapServiceAttribute).ParameterStyle;
						}
						if (soapReflectedMethod.paramStyle == SoapParameterStyle.Default)
						{
							soapReflectedMethod.paramStyle = SoapParameterStyle.Wrapped;
						}
					}
				}
				if (methodAttribute.binding.Length > 0)
				{
					if (client)
					{
						throw new InvalidOperationException(Res.GetString("WebInvalidBindingPlacement", obj.GetType().Name));
					}
					soapReflectedMethod.binding = WebServiceBindingReflector.GetAttribute(methodInfo, methodAttribute.binding);
				}
				WebMethodAttribute methodAttribute2 = methodInfo.MethodAttribute;
				soapReflectedMethod.name = methodAttribute2.MessageName;
				if (soapReflectedMethod.name.Length == 0)
				{
					soapReflectedMethod.name = methodInfo.Name;
				}
				string text = ((!soapReflectedMethod.rpc) ? ((methodAttribute.requestName.Length == 0) ? soapReflectedMethod.name : methodAttribute.requestName) : ((methodAttribute.requestName.Length == 0 || !client) ? methodInfo.Name : methodAttribute.requestName));
				string text2 = methodAttribute.requestNs;
				if (text2 == null)
				{
					text2 = ((soapReflectedMethod.binding == null || soapReflectedMethod.binding.Namespace == null || soapReflectedMethod.binding.Namespace.Length == 0) ? defaultNs : soapReflectedMethod.binding.Namespace);
				}
				string text3 = ((!soapReflectedMethod.rpc || soapReflectedMethod.use == SoapBindingUse.Encoded) ? ((methodAttribute.responseName.Length == 0) ? (soapReflectedMethod.name + "Response") : methodAttribute.responseName) : (methodInfo.Name + "Response"));
				string text4 = methodAttribute.responseNs;
				if (text4 == null)
				{
					text4 = ((soapReflectedMethod.binding == null || soapReflectedMethod.binding.Namespace == null || soapReflectedMethod.binding.Namespace.Length == 0) ? defaultNs : soapReflectedMethod.binding.Namespace);
				}
				SoapParameterInfo[] array = ReflectParameters(methodInfo.InParameters, text2);
				SoapParameterInfo[] array2 = ReflectParameters(methodInfo.OutParameters, text4);
				soapReflectedMethod.action = methodAttribute.action;
				if (soapReflectedMethod.action == null)
				{
					soapReflectedMethod.action = GetDefaultAction(defaultNs, methodInfo);
				}
				soapReflectedMethod.methodInfo = methodInfo;
				if (soapReflectedMethod.oneWay)
				{
					if (array2.Length > 0)
					{
						throw new ArgumentException(Res.GetString("WebOneWayOutParameters"), "methodInfo");
					}
					if (methodInfo.ReturnType != typeof(void))
					{
						throw new ArgumentException(Res.GetString("WebOneWayReturnValue"), "methodInfo");
					}
				}
				XmlReflectionMember[] array3 = new XmlReflectionMember[array.Length];
				for (int i = 0; i < array3.Length; i++)
				{
					SoapParameterInfo soapParameterInfo = array[i];
					XmlReflectionMember xmlReflectionMember = new XmlReflectionMember();
					xmlReflectionMember.MemberName = soapParameterInfo.parameterInfo.Name;
					xmlReflectionMember.MemberType = soapParameterInfo.parameterInfo.ParameterType;
					if (xmlReflectionMember.MemberType.IsByRef)
					{
						xmlReflectionMember.MemberType = xmlReflectionMember.MemberType.GetElementType();
					}
					xmlReflectionMember.XmlAttributes = soapParameterInfo.xmlAttributes;
					xmlReflectionMember.SoapAttributes = soapParameterInfo.soapAttributes;
					array3[i] = xmlReflectionMember;
				}
				soapReflectedMethod.requestMappings = ImportMembersMapping(xmlImporter, soapImporter, serviceDefaultIsEncoded, soapReflectedMethod.rpc, soapReflectedMethod.use, soapReflectedMethod.paramStyle, text, text2, methodAttribute.requestNs == null, array3, validate: true, openModel: false, key, client);
				if (GetSoapServiceRoutingStyle(soapServiceAttribute) == SoapServiceRoutingStyle.RequestElement && soapReflectedMethod.paramStyle == SoapParameterStyle.Bare && soapReflectedMethod.requestMappings.Count != 1)
				{
					throw new ArgumentException(Res.GetString("WhenUsingAMessageStyleOfParametersAsDocument0"), "methodInfo");
				}
				string name = "";
				string ns = "";
				if (soapReflectedMethod.paramStyle == SoapParameterStyle.Bare)
				{
					if (soapReflectedMethod.requestMappings.Count == 1)
					{
						name = soapReflectedMethod.requestMappings[0].XsdElementName;
						ns = soapReflectedMethod.requestMappings[0].Namespace;
					}
				}
				else
				{
					name = soapReflectedMethod.requestMappings.XsdElementName;
					ns = soapReflectedMethod.requestMappings.Namespace;
				}
				soapReflectedMethod.requestElementName = new XmlQualifiedName(name, ns);
				if (!soapReflectedMethod.oneWay)
				{
					int num = array2.Length;
					int num2 = 0;
					CodeIdentifiers codeIdentifiers = null;
					if (methodInfo.ReturnType != typeof(void))
					{
						num++;
						num2 = 1;
						codeIdentifiers = new CodeIdentifiers();
					}
					array3 = new XmlReflectionMember[num];
					foreach (SoapParameterInfo soapParameterInfo2 in array2)
					{
						XmlReflectionMember xmlReflectionMember2 = new XmlReflectionMember();
						xmlReflectionMember2.MemberName = soapParameterInfo2.parameterInfo.Name;
						xmlReflectionMember2.MemberType = soapParameterInfo2.parameterInfo.ParameterType;
						if (xmlReflectionMember2.MemberType.IsByRef)
						{
							xmlReflectionMember2.MemberType = xmlReflectionMember2.MemberType.GetElementType();
						}
						xmlReflectionMember2.XmlAttributes = soapParameterInfo2.xmlAttributes;
						xmlReflectionMember2.SoapAttributes = soapParameterInfo2.soapAttributes;
						array3[num2++] = xmlReflectionMember2;
						codeIdentifiers?.Add(xmlReflectionMember2.MemberName, null);
					}
					if (methodInfo.ReturnType != typeof(void))
					{
						XmlReflectionMember xmlReflectionMember3 = new XmlReflectionMember();
						xmlReflectionMember3.MemberName = codeIdentifiers.MakeUnique(soapReflectedMethod.name + "Result");
						xmlReflectionMember3.MemberType = methodInfo.ReturnType;
						xmlReflectionMember3.IsReturnValue = true;
						xmlReflectionMember3.XmlAttributes = new XmlAttributes(methodInfo.ReturnTypeCustomAttributeProvider);
						xmlReflectionMember3.XmlAttributes.XmlRoot = null;
						xmlReflectionMember3.SoapAttributes = new SoapAttributes(methodInfo.ReturnTypeCustomAttributeProvider);
						array3[0] = xmlReflectionMember3;
					}
					soapReflectedMethod.responseMappings = ImportMembersMapping(xmlImporter, soapImporter, serviceDefaultIsEncoded, soapReflectedMethod.rpc, soapReflectedMethod.use, soapReflectedMethod.paramStyle, text3, text4, methodAttribute.responseNs == null, array3, validate: false, openModel: false, key + ":Response", !client);
				}
				SoapExtensionAttribute[] array4 = (SoapExtensionAttribute[])methodInfo.GetCustomAttributes(typeof(SoapExtensionAttribute));
				soapReflectedMethod.extensions = new SoapReflectedExtension[array4.Length];
				for (int k = 0; k < array4.Length; k++)
				{
					soapReflectedMethod.extensions[k] = new SoapReflectedExtension(array4[k].ExtensionType, array4[k]);
				}
				Array.Sort(soapReflectedMethod.extensions);
				SoapHeaderAttribute[] array5 = (SoapHeaderAttribute[])methodInfo.GetCustomAttributes(typeof(SoapHeaderAttribute));
				Array.Sort(array5, new SoapHeaderAttributeComparer());
				Hashtable hashtable = new Hashtable();
				soapReflectedMethod.headers = new SoapReflectedHeader[array5.Length];
				int num3 = 0;
				int num4 = soapReflectedMethod.headers.Length;
				ArrayList arrayList = new ArrayList();
				ArrayList arrayList2 = new ArrayList();
				for (int l = 0; l < soapReflectedMethod.headers.Length; l++)
				{
					SoapHeaderAttribute soapHeaderAttribute = array5[l];
					SoapReflectedHeader soapReflectedHeader = new SoapReflectedHeader();
					Type declaringType = methodInfo.DeclaringType;
					if ((soapReflectedHeader.memberInfo = declaringType.GetField(soapHeaderAttribute.MemberName)) != null)
					{
						soapReflectedHeader.headerType = ((FieldInfo)soapReflectedHeader.memberInfo).FieldType;
					}
					else
					{
						if ((soapReflectedHeader.memberInfo = declaringType.GetProperty(soapHeaderAttribute.MemberName)) == null)
						{
							throw HeaderException(soapHeaderAttribute.MemberName, methodInfo.DeclaringType, "WebHeaderMissing");
						}
						soapReflectedHeader.headerType = ((PropertyInfo)soapReflectedHeader.memberInfo).PropertyType;
					}
					if (soapReflectedHeader.headerType.IsArray)
					{
						soapReflectedHeader.headerType = soapReflectedHeader.headerType.GetElementType();
						soapReflectedHeader.repeats = true;
						if (soapReflectedHeader.headerType != typeof(SoapUnknownHeader) && soapReflectedHeader.headerType != typeof(SoapHeader))
						{
							throw HeaderException(soapHeaderAttribute.MemberName, methodInfo.DeclaringType, "WebHeaderType");
						}
					}
					if (MemberHelper.IsStatic(soapReflectedHeader.memberInfo))
					{
						throw HeaderException(soapHeaderAttribute.MemberName, methodInfo.DeclaringType, "WebHeaderStatic");
					}
					if (!MemberHelper.CanRead(soapReflectedHeader.memberInfo))
					{
						throw HeaderException(soapHeaderAttribute.MemberName, methodInfo.DeclaringType, "WebHeaderRead");
					}
					if (!MemberHelper.CanWrite(soapReflectedHeader.memberInfo))
					{
						throw HeaderException(soapHeaderAttribute.MemberName, methodInfo.DeclaringType, "WebHeaderWrite");
					}
					if (!typeof(SoapHeader).IsAssignableFrom(soapReflectedHeader.headerType))
					{
						throw HeaderException(soapHeaderAttribute.MemberName, methodInfo.DeclaringType, "WebHeaderType");
					}
					SoapHeaderDirection direction = soapHeaderAttribute.Direction;
					if (soapReflectedMethod.oneWay && (direction & (SoapHeaderDirection.Out | SoapHeaderDirection.Fault)) != 0)
					{
						throw HeaderException(soapHeaderAttribute.MemberName, methodInfo.DeclaringType, "WebHeaderOneWayOut");
					}
					if (hashtable.Contains(soapReflectedHeader.headerType))
					{
						SoapHeaderDirection soapHeaderDirection = (SoapHeaderDirection)hashtable[soapReflectedHeader.headerType];
						if ((soapHeaderDirection & direction) != 0)
						{
							throw HeaderException(soapHeaderAttribute.MemberName, methodInfo.DeclaringType, "WebMultiplyDeclaredHeaderTypes");
						}
						hashtable[soapReflectedHeader.headerType] = direction | soapHeaderDirection;
					}
					else
					{
						hashtable[soapReflectedHeader.headerType] = direction;
					}
					if (soapReflectedHeader.headerType != typeof(SoapHeader) && soapReflectedHeader.headerType != typeof(SoapUnknownHeader))
					{
						XmlReflectionMember xmlReflectionMember4 = new XmlReflectionMember();
						xmlReflectionMember4.MemberName = soapReflectedHeader.headerType.Name;
						xmlReflectionMember4.MemberType = soapReflectedHeader.headerType;
						XmlAttributes xmlAttributes = new XmlAttributes(soapReflectedHeader.headerType);
						if (xmlAttributes.XmlRoot != null)
						{
							xmlReflectionMember4.XmlAttributes = new XmlAttributes();
							XmlElementAttribute xmlElementAttribute = new XmlElementAttribute();
							xmlElementAttribute.ElementName = xmlAttributes.XmlRoot.ElementName;
							xmlElementAttribute.Namespace = xmlAttributes.XmlRoot.Namespace;
							xmlReflectionMember4.XmlAttributes.XmlElements.Add(xmlElementAttribute);
						}
						xmlReflectionMember4.OverrideIsNullable = true;
						if ((direction & SoapHeaderDirection.In) != 0)
						{
							arrayList.Add(xmlReflectionMember4);
						}
						if ((direction & (SoapHeaderDirection.Out | SoapHeaderDirection.Fault)) != 0)
						{
							arrayList2.Add(xmlReflectionMember4);
						}
						soapReflectedHeader.custom = true;
					}
					soapReflectedHeader.direction = direction;
					if (!soapReflectedHeader.custom)
					{
						soapReflectedMethod.headers[--num4] = soapReflectedHeader;
					}
					else
					{
						soapReflectedMethod.headers[num3++] = soapReflectedHeader;
					}
				}
				soapReflectedMethod.inHeaderMappings = ImportMembersMapping(xmlImporter, soapImporter, serviceDefaultIsEncoded, rpc: false, soapReflectedMethod.use, SoapParameterStyle.Bare, text + "InHeaders", defaultNs, nsIsDefault: true, (XmlReflectionMember[])arrayList.ToArray(typeof(XmlReflectionMember)), validate: false, openModel: true, key + ":InHeaders", client);
				if (!soapReflectedMethod.oneWay)
				{
					soapReflectedMethod.outHeaderMappings = ImportMembersMapping(xmlImporter, soapImporter, serviceDefaultIsEncoded, rpc: false, soapReflectedMethod.use, SoapParameterStyle.Bare, text3 + "OutHeaders", defaultNs, nsIsDefault: true, (XmlReflectionMember[])arrayList2.ToArray(typeof(XmlReflectionMember)), validate: false, openModel: true, key + ":OutHeaders", !client);
				}
				return soapReflectedMethod;
			}
			catch (Exception ex)
			{
				if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
				{
					throw;
				}
				throw new InvalidOperationException(Res.GetString("WebReflectionErrorMethod", methodInfo.DeclaringType.Name, methodInfo.Name), ex);
			}
			catch
			{
				throw new InvalidOperationException(Res.GetString("WebReflectionErrorMethod", methodInfo.DeclaringType.Name, methodInfo.Name), null);
			}
		}

		private static XmlMembersMapping ImportMembersMapping(XmlReflectionImporter xmlImporter, SoapReflectionImporter soapImporter, bool serviceDefaultIsEncoded, bool rpc, SoapBindingUse use, SoapParameterStyle paramStyle, string elementName, string elementNamespace, bool nsIsDefault, XmlReflectionMember[] members, bool validate, bool openModel, string key, bool writeAccess)
		{
			XmlMembersMapping xmlMembersMapping = null;
			if (use == SoapBindingUse.Encoded)
			{
				string ns = ((!rpc && paramStyle != SoapParameterStyle.Bare && nsIsDefault) ? GetEncodedNamespace(elementNamespace, serviceDefaultIsEncoded) : elementNamespace);
				xmlMembersMapping = soapImporter.ImportMembersMapping(elementName, ns, members, rpc || paramStyle != SoapParameterStyle.Bare, rpc, validate, (!writeAccess) ? XmlMappingAccess.Read : XmlMappingAccess.Write);
			}
			else
			{
				string ns2 = (nsIsDefault ? GetLiteralNamespace(elementNamespace, serviceDefaultIsEncoded) : elementNamespace);
				xmlMembersMapping = xmlImporter.ImportMembersMapping(elementName, ns2, members, paramStyle != SoapParameterStyle.Bare, rpc, openModel, (!writeAccess) ? XmlMappingAccess.Read : XmlMappingAccess.Write);
			}
			xmlMembersMapping?.SetKey(key);
			return xmlMembersMapping;
		}

		private static Exception HeaderException(string memberName, Type declaringType, string description)
		{
			return new Exception(Res.GetString(description, declaringType.Name, memberName));
		}

		private static SoapParameterInfo[] ReflectParameters(ParameterInfo[] paramInfos, string ns)
		{
			SoapParameterInfo[] array = new SoapParameterInfo[paramInfos.Length];
			for (int i = 0; i < paramInfos.Length; i++)
			{
				SoapParameterInfo soapParameterInfo = new SoapParameterInfo();
				ParameterInfo parameterInfo = paramInfos[i];
				if (parameterInfo.ParameterType.IsArray && parameterInfo.ParameterType.GetArrayRank() > 1)
				{
					throw new InvalidOperationException(Res.GetString("WebMultiDimArray"));
				}
				soapParameterInfo.xmlAttributes = new XmlAttributes(parameterInfo);
				soapParameterInfo.soapAttributes = new SoapAttributes(parameterInfo);
				soapParameterInfo.parameterInfo = parameterInfo;
				array[i] = soapParameterInfo;
			}
			return array;
		}

		private static string GetDefaultAction(string defaultNs, LogicalMethodInfo methodInfo)
		{
			WebMethodAttribute methodAttribute = methodInfo.MethodAttribute;
			string text = methodAttribute.MessageName;
			if (text.Length == 0)
			{
				text = methodInfo.Name;
			}
			if (defaultNs.EndsWith("/", StringComparison.Ordinal))
			{
				return defaultNs + text;
			}
			return defaultNs + "/" + text;
		}
	}
	[AttributeUsage(AttributeTargets.Method)]
	public sealed class SoapRpcMethodAttribute : Attribute
	{
		private string action;

		private string requestName;

		private string responseName;

		private string requestNamespace;

		private string responseNamespace;

		private bool oneWay;

		private string binding;

		private SoapBindingUse use = SoapBindingUse.Encoded;

		public string Action
		{
			get
			{
				return action;
			}
			set
			{
				action = value;
			}
		}

		public string Binding
		{
			get
			{
				if (binding != null)
				{
					return binding;
				}
				return string.Empty;
			}
			set
			{
				binding = value;
			}
		}

		public bool OneWay
		{
			get
			{
				return oneWay;
			}
			set
			{
				oneWay = value;
			}
		}

		public string RequestNamespace
		{
			get
			{
				return requestNamespace;
			}
			set
			{
				requestNamespace = value;
			}
		}

		public string ResponseNamespace
		{
			get
			{
				return responseNamespace;
			}
			set
			{
				responseNamespace = value;
			}
		}

		public string RequestElementName
		{
			get
			{
				if (requestName != null)
				{
					return requestName;
				}
				return string.Empty;
			}
			set
			{
				requestName = value;
			}
		}

		public string ResponseElementName
		{
			get
			{
				if (responseName != null)
				{
					return responseName;
				}
				return string.Empty;
			}
			set
			{
				responseName = value;
			}
		}

		[ComVisible(false)]
		public SoapBindingUse Use
		{
			get
			{
				return use;
			}
			set
			{
				use = value;
			}
		}

		public SoapRpcMethodAttribute()
		{
		}

		public SoapRpcMethodAttribute(string action)
		{
			this.action = action;
		}
	}
	[AttributeUsage(AttributeTargets.Class)]
	public sealed class SoapRpcServiceAttribute : Attribute
	{
		private SoapServiceRoutingStyle routingStyle;

		private SoapBindingUse use = SoapBindingUse.Encoded;

		public SoapServiceRoutingStyle RoutingStyle
		{
			get
			{
				return routingStyle;
			}
			set
			{
				routingStyle = value;
			}
		}

		[ComVisible(false)]
		public SoapBindingUse Use
		{
			get
			{
				return use;
			}
			set
			{
				use = value;
			}
		}
	}
	public sealed class SoapServerMessage : SoapMessage
	{
		private SoapServerProtocol protocol;

		internal SoapExtension[] highPriConfigExtensions;

		internal SoapExtension[] otherExtensions;

		internal SoapExtension[] allExtensions;

		public override bool OneWay => protocol.ServerMethod.oneWay;

		public override string Url => protocol.Request.Url.GetComponents(UriComponents.AbsoluteUri, UriFormat.UriEscaped).Replace("#", "%23");

		public override string Action => protocol.ServerMethod.action;

		[ComVisible(false)]
		public override SoapProtocolVersion SoapVersion => protocol.Version;

		public object Server
		{
			get
			{
				EnsureStage((SoapMessageStage)9);
				return protocol.Target;
			}
		}

		public override LogicalMethodInfo MethodInfo => protocol.MethodInfo;

		internal SoapServerMessage(SoapServerProtocol protocol)
		{
			this.protocol = protocol;
		}

		protected override void EnsureOutStage()
		{
			EnsureStage(SoapMessageStage.BeforeSerialize);
		}

		protected override void EnsureInStage()
		{
			EnsureStage(SoapMessageStage.AfterDeserialize);
		}
	}
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	public sealed class SoapServerType : ServerType
	{
		private Hashtable methods = new Hashtable();

		private Hashtable duplicateMethods = new Hashtable();

		internal SoapReflectedExtension[] HighPriExtensions;

		internal SoapReflectedExtension[] LowPriExtensions;

		internal object[] HighPriExtensionInitializers;

		internal object[] LowPriExtensionInitializers;

		internal string serviceNamespace;

		internal bool serviceDefaultIsEncoded;

		internal bool routingOnSoapAction;

		internal WebServiceProtocols protocolsSupported;

		public string ServiceNamespace => serviceNamespace;

		public bool ServiceDefaultIsEncoded => serviceDefaultIsEncoded;

		public bool ServiceRoutingOnSoapAction => routingOnSoapAction;

		public SoapServerType(Type type, WebServiceProtocols protocolsSupported)
			: base(type)
		{
			this.protocolsSupported = protocolsSupported;
			bool flag = (protocolsSupported & WebServiceProtocols.HttpSoap) != 0;
			LogicalMethodInfo[] array = WebMethodReflector.GetMethods(type);
			ArrayList arrayList = new ArrayList();
			WebServiceAttribute attribute = WebServiceReflector.GetAttribute(type);
			object soapServiceAttribute = SoapReflector.GetSoapServiceAttribute(type);
			routingOnSoapAction = SoapReflector.GetSoapServiceRoutingStyle(soapServiceAttribute) == SoapServiceRoutingStyle.SoapAction;
			serviceNamespace = attribute.Namespace;
			serviceDefaultIsEncoded = SoapReflector.ServiceDefaultIsEncoded(type);
			SoapReflectionImporter soapReflectionImporter = SoapReflector.CreateSoapImporter(serviceNamespace, serviceDefaultIsEncoded);
			XmlReflectionImporter xmlReflectionImporter = SoapReflector.CreateXmlImporter(serviceNamespace, serviceDefaultIsEncoded);
			SoapReflector.IncludeTypes(array, soapReflectionImporter);
			WebMethodReflector.IncludeTypes(array, xmlReflectionImporter);
			SoapReflectedMethod[] array2 = new SoapReflectedMethod[array.Length];
			SoapExtensionTypeElementCollection soapExtensionTypes = WebServicesSection.Current.SoapExtensionTypes;
			ArrayList arrayList2 = new ArrayList();
			ArrayList arrayList3 = new ArrayList();
			for (int i = 0; i < soapExtensionTypes.Count; i++)
			{
				SoapExtensionTypeElement soapExtensionTypeElement = soapExtensionTypes[i];
				if (soapExtensionTypeElement != null)
				{
					SoapReflectedExtension value = new SoapReflectedExtension(soapExtensionTypeElement.Type, null, soapExtensionTypeElement.Priority);
					if (soapExtensionTypeElement.Group == PriorityGroup.High)
					{
						arrayList2.Add(value);
					}
					else
					{
						arrayList3.Add(value);
					}
				}
			}
			HighPriExtensions = (SoapReflectedExtension[])arrayList2.ToArray(typeof(SoapReflectedExtension));
			LowPriExtensions = (SoapReflectedExtension[])arrayList3.ToArray(typeof(SoapReflectedExtension));
			Array.Sort(HighPriExtensions);
			Array.Sort(LowPriExtensions);
			HighPriExtensionInitializers = SoapReflectedExtension.GetInitializers(type, HighPriExtensions);
			LowPriExtensionInitializers = SoapReflectedExtension.GetInitializers(type, LowPriExtensions);
			for (int j = 0; j < array.Length; j++)
			{
				LogicalMethodInfo methodInfo = array[j];
				SoapReflectedMethod soapReflectedMethod = SoapReflector.ReflectMethod(methodInfo, client: false, xmlReflectionImporter, soapReflectionImporter, attribute.Namespace);
				arrayList.Add(soapReflectedMethod.requestMappings);
				if (soapReflectedMethod.responseMappings != null)
				{
					arrayList.Add(soapReflectedMethod.responseMappings);
				}
				arrayList.Add(soapReflectedMethod.inHeaderMappings);
				if (soapReflectedMethod.outHeaderMappings != null)
				{
					arrayList.Add(soapReflectedMethod.outHeaderMappings);
				}
				array2[j] = soapReflectedMethod;
			}
			XmlMapping[] array3 = (XmlMapping[])arrayList.ToArray(typeof(XmlMapping));
			TraceMethod caller = (Tracing.On ? new TraceMethod(this, ".ctor", type, protocolsSupported) : null);
			if (Tracing.On)
			{
				Tracing.Enter(Tracing.TraceId("TraceCreateSerializer"), caller, new TraceMethod(typeof(XmlSerializer), "FromMappings", array3, base.Evidence));
			}
			XmlSerializer[] array4 = XmlSerializer.FromMappings(array3, base.Evidence);
			if (Tracing.On)
			{
				Tracing.Exit(Tracing.TraceId("TraceCreateSerializer"), caller);
			}
			int num = 0;
			for (int k = 0; k < array2.Length; k++)
			{
				SoapServerMethod soapServerMethod = new SoapServerMethod();
				SoapReflectedMethod soapReflectedMethod2 = array2[k];
				soapServerMethod.parameterSerializer = array4[num++];
				if (soapReflectedMethod2.responseMappings != null)
				{
					soapServerMethod.returnSerializer = array4[num++];
				}
				soapServerMethod.inHeaderSerializer = array4[num++];
				if (soapReflectedMethod2.outHeaderMappings != null)
				{
					soapServerMethod.outHeaderSerializer = array4[num++];
				}
				soapServerMethod.methodInfo = soapReflectedMethod2.methodInfo;
				soapServerMethod.action = soapReflectedMethod2.action;
				soapServerMethod.extensions = soapReflectedMethod2.extensions;
				soapServerMethod.extensionInitializers = SoapReflectedExtension.GetInitializers(soapServerMethod.methodInfo, soapReflectedMethod2.extensions);
				soapServerMethod.oneWay = soapReflectedMethod2.oneWay;
				soapServerMethod.rpc = soapReflectedMethod2.rpc;
				soapServerMethod.use = soapReflectedMethod2.use;
				soapServerMethod.paramStyle = soapReflectedMethod2.paramStyle;
				soapServerMethod.wsiClaims = ((soapReflectedMethod2.binding != null) ? soapReflectedMethod2.binding.ConformsTo : WsiProfiles.None);
				ArrayList arrayList4 = new ArrayList();
				ArrayList arrayList5 = new ArrayList();
				for (int l = 0; l < soapReflectedMethod2.headers.Length; l++)
				{
					SoapHeaderMapping soapHeaderMapping = new SoapHeaderMapping();
					SoapReflectedHeader soapReflectedHeader = soapReflectedMethod2.headers[l];
					soapHeaderMapping.memberInfo = soapReflectedHeader.memberInfo;
					soapHeaderMapping.repeats = soapReflectedHeader.repeats;
					soapHeaderMapping.custom = soapReflectedHeader.custom;
					soapHeaderMapping.direction = soapReflectedHeader.direction;
					soapHeaderMapping.headerType = soapReflectedHeader.headerType;
					if (soapHeaderMapping.direction == SoapHeaderDirection.In)
					{
						arrayList4.Add(soapHeaderMapping);
						continue;
					}
					if (soapHeaderMapping.direction == SoapHeaderDirection.Out)
					{
						arrayList5.Add(soapHeaderMapping);
						continue;
					}
					arrayList4.Add(soapHeaderMapping);
					arrayList5.Add(soapHeaderMapping);
				}
				soapServerMethod.inHeaderMappings = (SoapHeaderMapping[])arrayList4.ToArray(typeof(SoapHeaderMapping));
				if (soapServerMethod.outHeaderSerializer != null)
				{
					soapServerMethod.outHeaderMappings = (SoapHeaderMapping[])arrayList5.ToArray(typeof(SoapHeaderMapping));
				}
				if (flag && !routingOnSoapAction && soapReflectedMethod2.requestElementName.IsEmpty)
				{
					throw new SoapException(Res.GetString("TheMethodDoesNotHaveARequestElementEither1", soapServerMethod.methodInfo.Name), new XmlQualifiedName("Client", "http://schemas.xmlsoap.org/soap/envelope/"));
				}
				if (methods[soapReflectedMethod2.action] == null)
				{
					methods[soapReflectedMethod2.action] = soapServerMethod;
				}
				else
				{
					if (flag && routingOnSoapAction)
					{
						SoapServerMethod soapServerMethod2 = (SoapServerMethod)methods[soapReflectedMethod2.action];
						throw new SoapException(Res.GetString("TheMethodsAndUseTheSameSoapActionWhenTheService3", soapServerMethod.methodInfo.Name, soapServerMethod2.methodInfo.Name, soapReflectedMethod2.action), new XmlQualifiedName("Client", "http://schemas.xmlsoap.org/soap/envelope/"));
					}
					duplicateMethods[soapReflectedMethod2.action] = soapServerMethod;
				}
				if (methods[soapReflectedMethod2.requestElementName] == null)
				{
					methods[soapReflectedMethod2.requestElementName] = soapServerMethod;
					continue;
				}
				if (flag && !routingOnSoapAction)
				{
					SoapServerMethod soapServerMethod3 = (SoapServerMethod)methods[soapReflectedMethod2.requestElementName];
					throw new SoapException(Res.GetString("TheMethodsAndUseTheSameRequestElementXmlns4", soapServerMethod.methodInfo.Name, soapServerMethod3.methodInfo.Name, soapReflectedMethod2.requestElementName.Name, soapReflectedMethod2.requestElementName.Namespace), new XmlQualifiedName("Client", "http://schemas.xmlsoap.org/soap/envelope/"));
				}
				duplicateMethods[soapReflectedMethod2.requestElementName] = soapServerMethod;
			}
		}

		public SoapServerMethod GetMethod(object key)
		{
			return (SoapServerMethod)methods[key];
		}

		public SoapServerMethod GetDuplicateMethod(object key)
		{
			return (SoapServerMethod)duplicateMethods[key];
		}
	}
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	public class SoapServerProtocolFactory : ServerProtocolFactory
	{
		protected override ServerProtocol CreateIfRequestCompatible(HttpRequest request)
		{
			if (request.PathInfo.Length > 0)
			{
				return null;
			}
			if (request.HttpMethod != "POST")
			{
				return new UnsupportedRequestProtocol(405);
			}
			return new SoapServerProtocol();
		}
	}
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	public class SoapServerProtocol : ServerProtocol
	{
		internal class SoapEnvelopeReader : XmlTextReader
		{
			private long readerTimedout;

			internal SoapEnvelopeReader(TextReader input, long timeout)
				: base(input)
			{
				readerTimedout = timeout;
			}

			internal SoapEnvelopeReader(Stream input, long timeout)
				: base(input)
			{
				readerTimedout = timeout;
			}

			public override bool Read()
			{
				CheckTimeout();
				return base.Read();
			}

			public override bool MoveToNextAttribute()
			{
				CheckTimeout();
				return base.MoveToNextAttribute();
			}

			public override XmlNodeType MoveToContent()
			{
				CheckTimeout();
				return base.MoveToContent();
			}

			private void CheckTimeout()
			{
				if (DateTime.UtcNow.Ticks > readerTimedout)
				{
					throw new InvalidOperationException(Res.GetString("WebTimeout"));
				}
			}
		}

		private SoapServerType serverType;

		private SoapServerMethod serverMethod;

		private SoapServerMessage message;

		private bool isOneWay;

		private Exception onewayInitException;

		private SoapProtocolVersion version;

		private WebServiceProtocols protocolsSupported;

		private SoapServerProtocolHelper helper;

		internal override ServerType ServerType => serverType;

		internal override LogicalMethodInfo MethodInfo => serverMethod.methodInfo;

		internal SoapServerMethod ServerMethod => serverMethod;

		internal SoapServerMessage Message => message;

		internal override bool IsOneWay => isOneWay;

		internal override Exception OnewayInitException => onewayInitException;

		internal SoapProtocolVersion Version => version;

		protected internal SoapServerProtocol()
		{
			protocolsSupported = WebServicesSection.Current.EnabledProtocols;
		}

		internal override string GetUrlKeyComponent()
		{
			return string.Empty;
		}

		[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
		protected virtual XmlWriter GetWriterForMessage(SoapServerMessage message, int bufferSize)
		{
			if (bufferSize < 512)
			{
				bufferSize = 512;
			}
			return new XmlTextWriter(new StreamWriter(message.Stream, new UTF8Encoding(encoderShouldEmitUTF8Identifier: false), bufferSize));
		}

		[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
		protected virtual XmlReader GetReaderForMessage(SoapServerMessage message, int bufferSize)
		{
			Encoding encoding = RequestResponseUtils.GetEncoding2(message.ContentType);
			if (bufferSize < 512)
			{
				bufferSize = 512;
			}
			int readTimeout = WebServicesSection.Current.SoapEnvelopeProcessing.ReadTimeout;
			long num = ((readTimeout < 0) ? 0 : ((long)readTimeout * 10000000L));
			long ticks = DateTime.UtcNow.Ticks;
			long num2 = ((long.MaxValue - num <= ticks) ? long.MaxValue : (ticks + num));
			XmlTextReader xmlTextReader = ((encoding != null) ? ((num2 != long.MaxValue) ? new SoapEnvelopeReader(new StreamReader(message.Stream, encoding, detectEncodingFromByteOrderMarks: true, bufferSize), num2) : new XmlTextReader(new StreamReader(message.Stream, encoding, detectEncodingFromByteOrderMarks: true, bufferSize))) : ((num2 != long.MaxValue) ? new SoapEnvelopeReader(message.Stream, num2) : new XmlTextReader(message.Stream)));
			xmlTextReader.ProhibitDtd = true;
			xmlTextReader.Normalization = true;
			xmlTextReader.XmlResolver = null;
			return xmlTextReader;
		}

		internal override bool Initialize()
		{
			GuessVersion();
			message = new SoapServerMessage(this);
			onewayInitException = null;
			serverType = (SoapServerType)GetFromCache(typeof(SoapServerProtocol), base.Type);
			if (serverType == null)
			{
				lock (ServerProtocol.InternalSyncObject)
				{
					serverType = (SoapServerType)GetFromCache(typeof(SoapServerProtocol), base.Type);
					if (serverType == null)
					{
						serverType = new SoapServerType(base.Type, protocolsSupported);
						AddToCache(typeof(SoapServerProtocol), base.Type, serverType);
					}
				}
			}
			Exception ex = null;
			try
			{
				message.highPriConfigExtensions = SoapMessage.InitializeExtensions(serverType.HighPriExtensions, serverType.HighPriExtensionInitializers);
				message.highPriConfigExtensions = ModifyInitializedExtensions(PriorityGroup.High, message.highPriConfigExtensions);
				message.SetStream(base.Request.InputStream);
				message.InitExtensionStreamChain(message.highPriConfigExtensions);
				message.SetStage(SoapMessageStage.BeforeDeserialize);
				message.ContentType = base.Request.ContentType;
				message.ContentEncoding = base.Request.Headers["Content-Encoding"];
				message.RunExtensions(message.highPriConfigExtensions, throwOnException: false);
				ex = message.Exception;
			}
			catch (Exception ex2)
			{
				if (ex2 is ThreadAbortException || ex2 is StackOverflowException || ex2 is OutOfMemoryException)
				{
					throw;
				}
				if (Tracing.On)
				{
					Tracing.ExceptionCatch(TraceEventType.Warning, this, "Initialize", ex2);
				}
				ex = ex2;
			}
			catch
			{
				ex = new Exception(Res.GetString("NonClsCompliantException"));
			}
			message.allExtensions = message.highPriConfigExtensions;
			GuessVersion();
			try
			{
				serverMethod = RouteRequest(message);
				if (serverMethod == null)
				{
					throw new SoapException(Res.GetString("UnableToHandleRequest0"), new XmlQualifiedName("Server", "http://schemas.xmlsoap.org/soap/envelope/"));
				}
			}
			catch (Exception ex3)
			{
				if (ex3 is ThreadAbortException || ex3 is StackOverflowException || ex3 is OutOfMemoryException)
				{
					throw;
				}
				if (helper.RequestNamespace != null)
				{
					SetHelper(SoapServerProtocolHelper.GetHelper(this, helper.RequestNamespace));
				}
				CheckHelperVersion();
				throw;
			}
			catch
			{
				if (helper.RequestNamespace != null)
				{
					SetHelper(SoapServerProtocolHelper.GetHelper(this, helper.RequestNamespace));
				}
				CheckHelperVersion();
				throw;
			}
			isOneWay = serverMethod.oneWay;
			if (ex == null)
			{
				try
				{
					SoapReflectedExtension[] reflectedExtensions = (SoapReflectedExtension[])CombineExtensionsHelper(serverMethod.extensions, serverType.LowPriExtensions, typeof(SoapReflectedExtension));
					object[] extensionInitializers = (object[])CombineExtensionsHelper(serverMethod.extensionInitializers, serverType.LowPriExtensionInitializers, typeof(object));
					message.otherExtensions = SoapMessage.InitializeExtensions(reflectedExtensions, extensionInitializers);
					message.otherExtensions = ModifyInitializedExtensions(PriorityGroup.Low, message.otherExtensions);
					message.allExtensions = (SoapExtension[])CombineExtensionsHelper(message.highPriConfigExtensions, message.otherExtensions, typeof(SoapExtension));
				}
				catch (Exception ex4)
				{
					if (ex4 is ThreadAbortException || ex4 is StackOverflowException || ex4 is OutOfMemoryException)
					{
						throw;
					}
					if (Tracing.On)
					{
						Tracing.ExceptionCatch(TraceEventType.Warning, this, "Initialize", ex4);
					}
					ex = ex4;
				}
				catch
				{
					ex = new Exception(Res.GetString("NonClsCompliantException"));
				}
			}
			if (ex != null)
			{
				if (!isOneWay)
				{
					if (ex is SoapException)
					{
						throw ex;
					}
					throw SoapException.Create(Version, Res.GetString("WebConfigExtensionError"), new XmlQualifiedName("Server", "http://schemas.xmlsoap.org/soap/envelope/"), ex);
				}
				onewayInitException = ex;
			}
			return true;
		}

		protected virtual SoapExtension[] ModifyInitializedExtensions(PriorityGroup group, SoapExtension[] extensions)
		{
			return extensions;
		}

		protected virtual SoapServerMethod RouteRequest(SoapServerMessage message)
		{
			return helper.RouteRequest();
		}

		private void GuessVersion()
		{
			if (IsSupported(WebServiceProtocols.AnyHttpSoap))
			{
				if (base.Request.Headers["SOAPAction"] == null || ContentType.MatchesBase(base.Request.ContentType, "application/soap+xml"))
				{
					SetHelper(new Soap12ServerProtocolHelper(this));
				}
				else
				{
					SetHelper(new Soap11ServerProtocolHelper(this));
				}
			}
			else if (IsSupported(WebServiceProtocols.HttpSoap))
			{
				SetHelper(new Soap11ServerProtocolHelper(this));
			}
			else if (IsSupported(WebServiceProtocols.HttpSoap12))
			{
				SetHelper(new Soap12ServerProtocolHelper(this));
			}
		}

		internal bool IsSupported(WebServiceProtocols protocol)
		{
			return (protocolsSupported & protocol) == protocol;
		}

		internal override void CreateServerInstance()
		{
			base.CreateServerInstance();
			message.SetStage(SoapMessageStage.AfterDeserialize);
			message.RunExtensions(message.allExtensions, throwOnException: true);
			SoapHeaderHandling.SetHeaderMembers(message.Headers, Target, serverMethod.inHeaderMappings, SoapHeaderDirection.In, client: false);
		}

		private void SetHelper(SoapServerProtocolHelper helper)
		{
			this.helper = helper;
			version = helper.Version;
			base.Context.Items[WebService.SoapVersionContextSlot] = helper.Version;
		}

		private static Array CombineExtensionsHelper(Array array1, Array array2, Type elementType)
		{
			if (array1 == null)
			{
				return array2;
			}
			if (array2 == null)
			{
				return array1;
			}
			int num = array1.Length + array2.Length;
			if (num == 0)
			{
				return null;
			}
			Array array3 = null;
			if (elementType == typeof(SoapReflectedExtension))
			{
				array3 = new SoapReflectedExtension[num];
			}
			else if (elementType == typeof(SoapExtension))
			{
				array3 = new SoapExtension[num];
			}
			else
			{
				if (elementType != typeof(object))
				{
					throw new ArgumentException(Res.GetString("ElementTypeMustBeObjectOrSoapExtensionOrSoapReflectedException"), "elementType");
				}
				array3 = new object[num];
			}
			Array.Copy(array1, 0, array3, 0, array1.Length);
			Array.Copy(array2, 0, array3, array1.Length, array2.Length);
			return array3;
		}

		private void CheckHelperVersion()
		{
			if (helper.RequestNamespace == null)
			{
				return;
			}
			if (helper.RequestNamespace != helper.EnvelopeNs)
			{
				string requestNamespace = helper.RequestNamespace;
				if (IsSupported(WebServiceProtocols.HttpSoap))
				{
					SetHelper(new Soap11ServerProtocolHelper(this));
				}
				else
				{
					SetHelper(new Soap12ServerProtocolHelper(this));
				}
				throw new SoapException(Res.GetString("WebInvalidEnvelopeNamespace", requestNamespace, helper.EnvelopeNs), SoapException.VersionMismatchFaultCode);
			}
			if (IsSupported(helper.Protocol))
			{
				return;
			}
			string requestNamespace2 = helper.RequestNamespace;
			string text = (IsSupported(WebServiceProtocols.HttpSoap) ? "http://schemas.xmlsoap.org/soap/envelope/" : "http://www.w3.org/2003/05/soap-envelope");
			SetHelper(new Soap11ServerProtocolHelper(this));
			throw new SoapException(Res.GetString("WebInvalidEnvelopeNamespace", requestNamespace2, text), SoapException.VersionMismatchFaultCode);
		}

		internal override object[] ReadParameters()
		{
			message.InitExtensionStreamChain(message.otherExtensions);
			message.RunExtensions(message.otherExtensions, throwOnException: true);
			if (!ContentType.IsSoap(message.ContentType))
			{
				throw new SoapException(Res.GetString("WebRequestContent", message.ContentType, helper.HttpContentType), new XmlQualifiedName("Client", "http://schemas.xmlsoap.org/soap/envelope/"), new SoapFaultSubCode(Soap12FaultCodes.UnsupportedMediaTypeFaultCode));
			}
			XmlReader xmlReader = null;
			try
			{
				xmlReader = GetXmlReader();
				xmlReader.MoveToContent();
				SetHelper(SoapServerProtocolHelper.GetHelper(this, xmlReader.NamespaceURI));
			}
			catch (XmlException innerException)
			{
				throw new SoapException(Res.GetString("WebRequestUnableToRead"), new XmlQualifiedName("Client", "http://schemas.xmlsoap.org/soap/envelope/"), innerException);
			}
			CheckHelperVersion();
			if (version == SoapProtocolVersion.Soap11 && !ContentType.MatchesBase(message.ContentType, helper.HttpContentType))
			{
				throw new SoapException(Res.GetString("WebRequestContent", message.ContentType, helper.HttpContentType), new XmlQualifiedName("Client", "http://schemas.xmlsoap.org/soap/envelope/"), new SoapFaultSubCode(Soap12FaultCodes.UnsupportedMediaTypeFaultCode));
			}
			if (message.Exception != null)
			{
				throw message.Exception;
			}
			try
			{
				if (!xmlReader.IsStartElement("Envelope", helper.EnvelopeNs))
				{
					throw new InvalidOperationException(Res.GetString("WebMissingEnvelopeElement"));
				}
				if (xmlReader.IsEmptyElement)
				{
					throw new InvalidOperationException(Res.GetString("WebMissingBodyElement"));
				}
				int depth = xmlReader.Depth;
				xmlReader.ReadStartElement("Envelope", helper.EnvelopeNs);
				xmlReader.MoveToContent();
				bool checkRequiredHeaders = (serverMethod.wsiClaims & WsiProfiles.BasicProfile1_1) != 0 && version != SoapProtocolVersion.Soap12;
				string text = new SoapHeaderHandling().ReadHeaders(xmlReader, serverMethod.inHeaderSerializer, message.Headers, serverMethod.inHeaderMappings, SoapHeaderDirection.In, helper.EnvelopeNs, (serverMethod.use == SoapBindingUse.Encoded) ? helper.EncodingNs : null, checkRequiredHeaders);
				if (text != null)
				{
					throw new SoapHeaderException(Res.GetString("WebMissingHeader", text), new XmlQualifiedName("MustUnderstand", "http://schemas.xmlsoap.org/soap/envelope/"));
				}
				if (!xmlReader.IsStartElement("Body", helper.EnvelopeNs))
				{
					throw new InvalidOperationException(Res.GetString("WebMissingBodyElement"));
				}
				xmlReader.ReadStartElement("Body", helper.EnvelopeNs);
				xmlReader.MoveToContent();
				bool flag = serverMethod.use == SoapBindingUse.Encoded;
				TraceMethod caller = (Tracing.On ? new TraceMethod(this, "ReadParameters") : null);
				if (Tracing.On)
				{
					Tracing.Enter(Tracing.TraceId("TraceReadRequest"), caller, new TraceMethod(serverMethod.parameterSerializer, "Deserialize", xmlReader, (serverMethod.use == SoapBindingUse.Encoded) ? helper.EncodingNs : null));
				}
				object[] array;
				if (!flag && (WebServicesSection.Current.SoapEnvelopeProcessing.IsStrict || Tracing.On))
				{
					XmlDeserializationEvents events = (Tracing.On ? Tracing.GetDeserializationEvents() : RuntimeUtils.GetDeserializationEvents());
					array = (object[])serverMethod.parameterSerializer.Deserialize(xmlReader, null, events);
				}
				else
				{
					array = (object[])serverMethod.parameterSerializer.Deserialize(xmlReader, flag ? helper.EncodingNs : null);
				}
				if (Tracing.On)
				{
					Tracing.Exit(Tracing.TraceId("TraceReadRequest"), caller);
				}
				while (depth < xmlReader.Depth && xmlReader.Read())
				{
				}
				if (xmlReader.NodeType == XmlNodeType.EndElement)
				{
					xmlReader.Read();
				}
				message.SetParameterValues(array);
				return array;
			}
			catch (SoapException)
			{
				throw;
			}
			catch (Exception ex2)
			{
				if (ex2 is ThreadAbortException || ex2 is StackOverflowException || ex2 is OutOfMemoryException)
				{
					throw;
				}
				throw new SoapException(Res.GetString("WebRequestUnableToRead"), new XmlQualifiedName("Client", "http://schemas.xmlsoap.org/soap/envelope/"), ex2);
			}
			catch
			{
				throw new SoapException(Res.GetString("WebRequestUnableToRead"), new XmlQualifiedName("Client", "http://schemas.xmlsoap.org/soap/envelope/"), new Exception(Res.GetString("NonClsCompliantException")));
			}
		}

		internal override void WriteReturns(object[] returnValues, Stream outputStream)
		{
			if (!serverMethod.oneWay)
			{
				bool flag = serverMethod.use == SoapBindingUse.Encoded;
				SoapHeaderHandling.EnsureHeadersUnderstood(message.Headers);
				message.Headers.Clear();
				SoapHeaderHandling.GetHeaderMembers(message.Headers, Target, serverMethod.outHeaderMappings, SoapHeaderDirection.Out, client: false);
				if (message.allExtensions != null)
				{
					message.SetExtensionStream(new SoapExtensionStream());
				}
				message.InitExtensionStreamChain(message.allExtensions);
				message.SetStage(SoapMessageStage.BeforeSerialize);
				message.ContentType = ContentType.Compose(helper.HttpContentType, Encoding.UTF8);
				message.SetParameterValues(returnValues);
				message.RunExtensions(message.allExtensions, throwOnException: true);
				message.SetStream(outputStream);
				base.Response.ContentType = message.ContentType;
				if (message.ContentEncoding != null && message.ContentEncoding.Length > 0)
				{
					base.Response.AppendHeader("Content-Encoding", message.ContentEncoding);
				}
				XmlWriter writerForMessage = GetWriterForMessage(message, 1024);
				if (writerForMessage == null)
				{
					throw new InvalidOperationException(Res.GetString("WebNullWriterForMessage"));
				}
				writerForMessage.WriteStartDocument();
				writerForMessage.WriteStartElement("soap", "Envelope", helper.EnvelopeNs);
				writerForMessage.WriteAttributeString("xmlns", "soap", null, helper.EnvelopeNs);
				if (flag)
				{
					writerForMessage.WriteAttributeString("xmlns", "soapenc", null, helper.EncodingNs);
					writerForMessage.WriteAttributeString("xmlns", "tns", null, serverType.serviceNamespace);
					writerForMessage.WriteAttributeString("xmlns", "types", null, SoapReflector.GetEncodedNamespace(serverType.serviceNamespace, serverType.serviceDefaultIsEncoded));
				}
				if (serverMethod.rpc && version == SoapProtocolVersion.Soap12)
				{
					writerForMessage.WriteAttributeString("xmlns", "rpc", null, "http://www.w3.org/2003/05/soap-rpc");
				}
				writerForMessage.WriteAttributeString("xmlns", "xsi", null, "http://www.w3.org/2001/XMLSchema-instance");
				writerForMessage.WriteAttributeString("xmlns", "xsd", null, "http://www.w3.org/2001/XMLSchema");
				SoapHeaderHandling.WriteHeaders(writerForMessage, serverMethod.outHeaderSerializer, message.Headers, serverMethod.outHeaderMappings, SoapHeaderDirection.Out, flag, serverType.serviceNamespace, serverType.serviceDefaultIsEncoded, helper.EnvelopeNs);
				writerForMessage.WriteStartElement("Body", helper.EnvelopeNs);
				if (flag && version != SoapProtocolVersion.Soap12)
				{
					writerForMessage.WriteAttributeString("soap", "encodingStyle", null, helper.EncodingNs);
				}
				TraceMethod caller = (Tracing.On ? new TraceMethod(this, "WriteReturns") : null);
				if (Tracing.On)
				{
					Tracing.Enter(Tracing.TraceId("TraceWriteResponse"), caller, new TraceMethod(serverMethod.returnSerializer, "Serialize", writerForMessage, returnValues, null, flag ? helper.EncodingNs : null));
				}
				serverMethod.returnSerializer.Serialize(writerForMessage, returnValues, null, flag ? helper.EncodingNs : null);
				if (Tracing.On)
				{
					Tracing.Exit(Tracing.TraceId("TraceWriteResponse"), caller);
				}
				writerForMessage.WriteEndElement();
				writerForMessage.WriteEndElement();
				writerForMessage.Flush();
				message.SetStage(SoapMessageStage.AfterSerialize);
				message.RunExtensions(message.allExtensions, throwOnException: true);
			}
		}

		internal override bool WriteException(Exception e, Stream outputStream)
		{
			if (message == null)
			{
				return false;
			}
			message.Headers.Clear();
			if (serverMethod != null && Target != null)
			{
				SoapHeaderHandling.GetHeaderMembers(message.Headers, Target, serverMethod.outHeaderMappings, SoapHeaderDirection.Fault, client: false);
			}
			SoapException ex = ((e is SoapException) ? ((SoapException)e) : ((serverMethod == null || !serverMethod.rpc || helper.Version != SoapProtocolVersion.Soap12 || !(e is ArgumentException)) ? SoapException.Create(Version, Res.GetString("WebRequestUnableToProcess"), new XmlQualifiedName("Server", "http://schemas.xmlsoap.org/soap/envelope/"), e) : SoapException.Create(Version, Res.GetString("WebRequestUnableToProcess"), new XmlQualifiedName("Client", "http://schemas.xmlsoap.org/soap/envelope/"), null, null, null, new SoapFaultSubCode(Soap12FaultCodes.RpcBadArgumentsFaultCode), e)));
			if (SoapException.IsVersionMismatchFaultCode(ex.Code) && IsSupported(WebServiceProtocols.HttpSoap12))
			{
				SoapUnknownHeader soapUnknownHeader = CreateUpgradeHeader();
				if (soapUnknownHeader != null)
				{
					Message.Headers.Add(soapUnknownHeader);
				}
			}
			base.Response.ClearHeaders();
			base.Response.Clear();
			HttpStatusCode statusCode = helper.SetResponseErrorCode(base.Response, ex);
			bool flag = false;
			SoapExtensionStream soapExtensionStream = new SoapExtensionStream();
			if (message.allExtensions != null)
			{
				message.SetExtensionStream(soapExtensionStream);
			}
			try
			{
				message.InitExtensionStreamChain(message.allExtensions);
			}
			catch (Exception ex2)
			{
				if (ex2 is ThreadAbortException || ex2 is StackOverflowException || ex2 is OutOfMemoryException)
				{
					throw;
				}
				if (Tracing.On)
				{
					Tracing.ExceptionCatch(TraceEventType.Warning, this, "WriteException", ex2);
				}
				flag = true;
			}
			catch
			{
				flag = true;
			}
			message.SetStage(SoapMessageStage.BeforeSerialize);
			message.ContentType = ContentType.Compose(helper.HttpContentType, Encoding.UTF8);
			message.Exception = ex;
			if (!flag)
			{
				try
				{
					message.RunExtensions(message.allExtensions, throwOnException: false);
				}
				catch (Exception ex3)
				{
					if (ex3 is ThreadAbortException || ex3 is StackOverflowException || ex3 is OutOfMemoryException)
					{
						throw;
					}
					if (Tracing.On)
					{
						Tracing.ExceptionCatch(TraceEventType.Warning, this, "WriteException", ex3);
					}
					flag = true;
				}
				catch
				{
					flag = true;
				}
			}
			message.SetStream(outputStream);
			base.Response.ContentType = message.ContentType;
			if (message.ContentEncoding != null && message.ContentEncoding.Length > 0)
			{
				base.Response.AppendHeader("Content-Encoding", message.ContentEncoding);
			}
			XmlWriter writerForMessage = GetWriterForMessage(message, 512);
			if (writerForMessage == null)
			{
				throw new InvalidOperationException(Res.GetString("WebNullWriterForMessage"));
			}
			helper.WriteFault(writerForMessage, message.Exception, statusCode);
			if (!flag)
			{
				SoapException ex4 = null;
				try
				{
					message.SetStage(SoapMessageStage.AfterSerialize);
					message.RunExtensions(message.allExtensions, throwOnException: false);
				}
				catch (Exception ex5)
				{
					if (ex5 is ThreadAbortException || ex5 is StackOverflowException || ex5 is OutOfMemoryException)
					{
						throw;
					}
					if (Tracing.On)
					{
						Tracing.ExceptionCatch(TraceEventType.Warning, this, "WriteException", ex5);
					}
					if (!soapExtensionStream.HasWritten)
					{
						ex4 = SoapException.Create(Version, Res.GetString("WebExtensionError"), new XmlQualifiedName("Server", "http://schemas.xmlsoap.org/soap/envelope/"), ex5);
					}
				}
				catch
				{
					if (!soapExtensionStream.HasWritten)
					{
						ex4 = SoapException.Create(Version, Res.GetString("WebExtensionError"), new XmlQualifiedName("Server", "http://schemas.xmlsoap.org/soap/envelope/"), null);
					}
					return false;
				}
				if (ex4 != null)
				{
					base.Response.ContentType = ContentType.Compose("text/plain", Encoding.UTF8);
					StreamWriter streamWriter = new StreamWriter(outputStream, new UTF8Encoding(encoderShouldEmitUTF8Identifier: false));
					streamWriter.WriteLine(GenerateFaultString(message.Exception));
					streamWriter.Flush();
				}
			}
			return true;
		}

		private bool WriteException_TryWriteFault(SoapServerMessage message, Stream outputStream, HttpStatusCode statusCode, bool disableExtensions)
		{
			return true;
		}

		internal SoapUnknownHeader CreateUpgradeHeader()
		{
			XmlDocument xmlDocument = new XmlDocument();
			XmlElement xmlElement = xmlDocument.CreateElement("soap12", "Upgrade", "http://www.w3.org/2003/05/soap-envelope");
			if (IsSupported(WebServiceProtocols.HttpSoap))
			{
				xmlElement.AppendChild(CreateUpgradeEnvelope(xmlDocument, "soap", "http://schemas.xmlsoap.org/soap/envelope/"));
			}
			if (IsSupported(WebServiceProtocols.HttpSoap12))
			{
				xmlElement.AppendChild(CreateUpgradeEnvelope(xmlDocument, "soap12", "http://www.w3.org/2003/05/soap-envelope"));
			}
			SoapUnknownHeader soapUnknownHeader = new SoapUnknownHeader();
			soapUnknownHeader.Element = xmlElement;
			return soapUnknownHeader;
		}

		private static XmlElement CreateUpgradeEnvelope(XmlDocument doc, string prefix, string envelopeNs)
		{
			XmlElement xmlElement = doc.CreateElement("soap12", "SupportedEnvelope", "http://www.w3.org/2003/05/soap-envelope");
			XmlAttribute xmlAttribute = doc.CreateAttribute("xmlns", prefix, "http://www.w3.org/2000/xmlns/");
			xmlAttribute.Value = envelopeNs;
			XmlAttribute xmlAttribute2 = doc.CreateAttribute("qname");
			xmlAttribute2.Value = prefix + ":Envelope";
			xmlElement.Attributes.Append(xmlAttribute2);
			xmlElement.Attributes.Append(xmlAttribute);
			return xmlElement;
		}

		internal XmlReader GetXmlReader()
		{
			Encoding encoding = RequestResponseUtils.GetEncoding2(Message.ContentType);
			if (serverMethod != null && (serverMethod.wsiClaims & WsiProfiles.BasicProfile1_1) != 0 && Version != SoapProtocolVersion.Soap12 && encoding != null && !(encoding is UTF8Encoding) && !(encoding is UnicodeEncoding))
			{
				throw new InvalidOperationException(Res.GetString("WebWsiContentTypeEncoding"));
			}
			XmlReader readerForMessage = GetReaderForMessage(Message, RequestResponseUtils.GetBufferSize(base.Request.ContentLength));
			if (readerForMessage == null)
			{
				throw new InvalidOperationException(Res.GetString("WebNullReaderForMessage"));
			}
			return readerForMessage;
		}
	}
	public enum SoapServiceRoutingStyle
	{
		SoapAction,
		RequestElement
	}
	public sealed class SoapUnknownHeader : SoapHeader
	{
		private XmlElement element;

		[XmlIgnore]
		public XmlElement Element
		{
			get
			{
				if (element == null)
				{
					return null;
				}
				if (version == SoapProtocolVersion.Soap12)
				{
					if (InternalMustUnderstand)
					{
						element.SetAttribute("mustUnderstand", "http://www.w3.org/2003/05/soap-envelope", "1");
					}
					element.RemoveAttribute("mustUnderstand", "http://schemas.xmlsoap.org/soap/envelope/");
					string internalActor = InternalActor;
					if (internalActor != null && internalActor.Length != 0)
					{
						element.SetAttribute("role", "http://www.w3.org/2003/05/soap-envelope", internalActor);
					}
					element.RemoveAttribute("actor", "http://schemas.xmlsoap.org/soap/envelope/");
				}
				else if (version == SoapProtocolVersion.Soap11)
				{
					if (InternalMustUnderstand)
					{
						element.SetAttribute("mustUnderstand", "http://schemas.xmlsoap.org/soap/envelope/", "1");
					}
					element.RemoveAttribute("mustUnderstand", "http://www.w3.org/2003/05/soap-envelope");
					string internalActor2 = InternalActor;
					if (internalActor2 != null && internalActor2.Length != 0)
					{
						element.SetAttribute("actor", "http://schemas.xmlsoap.org/soap/envelope/", internalActor2);
					}
					element.RemoveAttribute("role", "http://www.w3.org/2003/05/soap-envelope");
					element.RemoveAttribute("relay", "http://www.w3.org/2003/05/soap-envelope");
				}
				return element;
			}
			set
			{
				if (value == null && element != null)
				{
					base.InternalMustUnderstand = InternalMustUnderstand;
					base.InternalActor = InternalActor;
				}
				element = value;
			}
		}

		internal override bool InternalMustUnderstand
		{
			get
			{
				if (element == null)
				{
					return base.InternalMustUnderstand;
				}
				string elementAttribute = GetElementAttribute("mustUnderstand", "http://schemas.xmlsoap.org/soap/envelope/", element);
				if (elementAttribute == null)
				{
					elementAttribute = GetElementAttribute("mustUnderstand", "http://www.w3.org/2003/05/soap-envelope", element);
					if (elementAttribute == null)
					{
						return false;
					}
				}
				switch (elementAttribute)
				{
				case "false":
				case "0":
					return false;
				case "true":
				case "1":
					return true;
				default:
					return false;
				}
			}
			set
			{
				base.InternalMustUnderstand = value;
				if (element != null)
				{
					if (value)
					{
						element.SetAttribute("mustUnderstand", "http://schemas.xmlsoap.org/soap/envelope/", "1");
					}
					else
					{
						element.RemoveAttribute("mustUnderstand", "http://schemas.xmlsoap.org/soap/envelope/");
					}
					element.RemoveAttribute("mustUnderstand", "http://www.w3.org/2003/05/soap-envelope");
				}
			}
		}

		internal override string InternalActor
		{
			get
			{
				if (element == null)
				{
					return base.InternalActor;
				}
				string elementAttribute = GetElementAttribute("actor", "http://schemas.xmlsoap.org/soap/envelope/", element);
				if (elementAttribute == null)
				{
					elementAttribute = GetElementAttribute("role", "http://www.w3.org/2003/05/soap-envelope", element);
					if (elementAttribute == null)
					{
						return "";
					}
				}
				return elementAttribute;
			}
			set
			{
				base.InternalActor = value;
				if (element != null)
				{
					if (value == null || value.Length == 0)
					{
						element.RemoveAttribute("actor", "http://schemas.xmlsoap.org/soap/envelope/");
					}
					else
					{
						element.SetAttribute("actor", "http://schemas.xmlsoap.org/soap/envelope/", value);
					}
					element.RemoveAttribute("role", "http://www.w3.org/2003/05/soap-envelope");
				}
			}
		}

		internal override bool InternalRelay
		{
			get
			{
				if (element == null)
				{
					return base.InternalRelay;
				}
				string elementAttribute = GetElementAttribute("relay", "http://www.w3.org/2003/05/soap-envelope", element);
				if (elementAttribute == null)
				{
					return false;
				}
				switch (elementAttribute)
				{
				case "false":
				case "0":
					return false;
				case "true":
				case "1":
					return true;
				default:
					return false;
				}
			}
			set
			{
				base.InternalRelay = value;
				if (element != null)
				{
					if (value)
					{
						element.SetAttribute("relay", "http://www.w3.org/2003/05/soap-envelope", "1");
					}
					else
					{
						element.RemoveAttribute("relay", "http://www.w3.org/2003/05/soap-envelope");
					}
				}
			}
		}

		private string GetElementAttribute(string name, string ns, XmlElement element)
		{
			if (element == null)
			{
				return null;
			}
			if (element.Prefix.Length == 0 && element.NamespaceURI == ns)
			{
				if (element.HasAttribute(name))
				{
					return element.GetAttribute(name);
				}
				return null;
			}
			if (element.HasAttribute(name, ns))
			{
				return element.GetAttribute(name, ns);
			}
			return null;
		}
	}
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	public class TextReturnReader : MimeReturnReader
	{
		private PatternMatcher matcher;

		public override void Initialize(object o)
		{
			matcher = (PatternMatcher)o;
		}

		public override object GetInitializer(LogicalMethodInfo methodInfo)
		{
			return new PatternMatcher(methodInfo.ReturnType);
		}

		public override object Read(WebResponse response, Stream responseStream)
		{
			try
			{
				string text = RequestResponseUtils.ReadResponse(response);
				return matcher.Match(text);
			}
			finally
			{
				response.Close();
			}
		}
	}
	public class UrlParameterReader : ValueCollectionParameterReader
	{
		public override object[] Read(HttpRequest request)
		{
			return Read(request.QueryString);
		}
	}
	public class UrlParameterWriter : UrlEncodedParameterWriter
	{
		public override string GetRequestUrl(string url, object[] parameters)
		{
			if (parameters.Length == 0)
			{
				return url;
			}
			StringBuilder stringBuilder = new StringBuilder(url);
			stringBuilder.Append('?');
			TextWriter textWriter = new StringWriter(stringBuilder, CultureInfo.InvariantCulture);
			Encode(textWriter, parameters);
			textWriter.Flush();
			return stringBuilder.ToString();
		}
	}
	internal class WebServiceHandler
	{
		private ServerProtocol protocol;

		private Exception exception;

		private AsyncCallback asyncCallback;

		private ManualResetEvent asyncBeginComplete;

		private int asyncCallbackCalls;

		private bool wroteException;

		private object[] parameters;

		internal WebServiceHandler(ServerProtocol protocol)
		{
			this.protocol = protocol;
		}

		private static void TraceFlush()
		{
		}

		private void PrepareContext()
		{
			exception = null;
			wroteException = false;
			asyncCallback = null;
			asyncBeginComplete = new ManualResetEvent(initialState: false);
			asyncCallbackCalls = 0;
			if (protocol.IsOneWay)
			{
				return;
			}
			HttpContext context = protocol.Context;
			if (context != null)
			{
				int cacheDuration = protocol.MethodAttribute.CacheDuration;
				if (cacheDuration > 0)
				{
					context.Response.Cache.SetCacheability(HttpCacheability.Server);
					context.Response.Cache.SetExpires(DateTime.Now.AddSeconds(cacheDuration));
					context.Response.Cache.SetSlidingExpiration(slide: false);
					context.Response.Cache.VaryByHeaders["Content-type"] = true;
					context.Response.Cache.VaryByHeaders["SOAPAction"] = true;
					context.Response.Cache.VaryByParams["*"] = true;
				}
				else
				{
					context.Response.Cache.SetNoServerCaching();
					context.Response.Cache.SetMaxAge(TimeSpan.Zero);
				}
				context.Response.BufferOutput = protocol.MethodAttribute.BufferResponse;
				context.Response.ContentType = null;
			}
		}

		private void WriteException(Exception e)
		{
			if (!wroteException)
			{
				_ = System.ComponentModel.CompModSwitches.Remote.TraceVerbose;
				if (e is TargetInvocationException)
				{
					_ = System.ComponentModel.CompModSwitches.Remote.TraceVerbose;
					e = e.InnerException;
				}
				wroteException = protocol.WriteException(e, protocol.Response.OutputStream);
				if (!wroteException)
				{
					throw e;
				}
			}
		}

		private void Invoke()
		{
			PrepareContext();
			protocol.CreateServerInstance();
			RemoteDebugger remoteDebugger = null;
			if (!protocol.IsOneWay && RemoteDebugger.IsServerCallInEnabled(protocol, out var stringBuffer))
			{
				remoteDebugger = new RemoteDebugger();
				remoteDebugger.NotifyServerCallEnter(protocol, stringBuffer);
			}
			try
			{
				TraceMethod caller = (Tracing.On ? new TraceMethod(this, "Invoke") : null);
				TraceMethod callDetails = (Tracing.On ? new TraceMethod(protocol.Target, protocol.MethodInfo.Name, parameters) : null);
				if (Tracing.On)
				{
					Tracing.Enter(protocol.MethodInfo.ToString(), caller, callDetails);
				}
				object[] returnValues = protocol.MethodInfo.Invoke(protocol.Target, parameters);
				if (Tracing.On)
				{
					Tracing.Exit(protocol.MethodInfo.ToString(), caller);
				}
				WriteReturns(returnValues);
			}
			catch (Exception ex)
			{
				if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
				{
					throw;
				}
				if (Tracing.On)
				{
					Tracing.ExceptionCatch(TraceEventType.Error, this, "Invoke", ex);
				}
				if (!protocol.IsOneWay)
				{
					WriteException(ex);
					throw;
				}
			}
			catch
			{
			}
			finally
			{
				protocol.DisposeServerInstance();
				remoteDebugger?.NotifyServerCallExit(protocol.Response);
			}
		}

		private void InvokeTransacted()
		{
			Transactions.InvokeTransacted(Invoke, protocol.MethodAttribute.TransactionOption);
		}

		private void ThrowInitException()
		{
			HandleOneWayException(new Exception(Res.GetString("WebConfigExtensionError"), protocol.OnewayInitException), "ThrowInitException");
		}

		private void HandleOneWayException(Exception e, string method)
		{
			if (Tracing.On)
			{
				Tracing.ExceptionCatch(TraceEventType.Error, this, string.IsNullOrEmpty(method) ? "HandleOneWayException" : method, e);
			}
		}

		protected void CoreProcessRequest()
		{
			try
			{
				bool transactionEnabled = protocol.MethodAttribute.TransactionEnabled;
				if (protocol.IsOneWay)
				{
					WorkItemCallback workItemCallback = null;
					TraceMethod traceMethod = null;
					if (protocol.OnewayInitException != null)
					{
						workItemCallback = ThrowInitException;
						traceMethod = (Tracing.On ? new TraceMethod(this, "ThrowInitException") : null);
					}
					else
					{
						parameters = protocol.ReadParameters();
						workItemCallback = (transactionEnabled ? new WorkItemCallback(OneWayInvokeTransacted) : new WorkItemCallback(OneWayInvoke));
						traceMethod = ((!Tracing.On) ? null : (transactionEnabled ? new TraceMethod(this, "OneWayInvokeTransacted") : new TraceMethod(this, "OneWayInvoke")));
					}
					if (Tracing.On)
					{
						Tracing.Information("TracePostWorkItemIn", traceMethod);
					}
					WorkItem.Post(workItemCallback);
					if (Tracing.On)
					{
						Tracing.Information("TracePostWorkItemOut", traceMethod);
					}
					protocol.WriteOneWayResponse();
				}
				else if (transactionEnabled)
				{
					parameters = protocol.ReadParameters();
					InvokeTransacted();
				}
				else
				{
					parameters = protocol.ReadParameters();
					Invoke();
				}
			}
			catch (Exception ex)
			{
				if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
				{
					throw;
				}
				if (Tracing.On)
				{
					Tracing.ExceptionCatch(TraceEventType.Error, this, "CoreProcessRequest", ex);
				}
				if (!protocol.IsOneWay)
				{
					WriteException(ex);
				}
			}
			catch
			{
				if (!protocol.IsOneWay)
				{
					WriteException(new Exception(Res.GetString("NonClsCompliantException")));
				}
			}
			TraceFlush();
		}

		private HttpContext SwitchContext(HttpContext context)
		{
			HttpContext current = HttpContext.Current;
			HttpContext.Current = context;
			return current;
		}

		private void OneWayInvoke()
		{
			HttpContext httpContext = null;
			if (protocol.Context != null)
			{
				httpContext = SwitchContext(protocol.Context);
			}
			try
			{
				Invoke();
			}
			catch (Exception e)
			{
				HandleOneWayException(e, "OneWayInvoke");
			}
			finally
			{
				if (httpContext != null)
				{
					SwitchContext(httpContext);
				}
			}
		}

		private void OneWayInvokeTransacted()
		{
			HttpContext httpContext = null;
			if (protocol.Context != null)
			{
				httpContext = SwitchContext(protocol.Context);
			}
			try
			{
				InvokeTransacted();
			}
			catch (Exception e)
			{
				HandleOneWayException(e, "OneWayInvokeTransacted");
			}
			finally
			{
				if (httpContext != null)
				{
					SwitchContext(httpContext);
				}
			}
		}

		private void Callback(IAsyncResult result)
		{
			if (!result.CompletedSynchronously)
			{
				asyncBeginComplete.WaitOne();
			}
			DoCallback(result);
		}

		private void DoCallback(IAsyncResult result)
		{
			if (asyncCallback != null && Interlocked.Increment(ref asyncCallbackCalls) == 1)
			{
				asyncCallback(result);
			}
		}

		protected IAsyncResult BeginCoreProcessRequest(AsyncCallback callback, object asyncState)
		{
			if (protocol.MethodAttribute.TransactionEnabled)
			{
				throw new InvalidOperationException(Res.GetString("WebAsyncTransaction"));
			}
			parameters = protocol.ReadParameters();
			IAsyncResult asyncResult;
			if (protocol.IsOneWay)
			{
				TraceMethod traceMethod = (Tracing.On ? new TraceMethod(this, "OneWayAsyncInvoke") : null);
				if (Tracing.On)
				{
					Tracing.Information("TracePostWorkItemIn", traceMethod);
				}
				WorkItem.Post(OneWayAsyncInvoke);
				if (Tracing.On)
				{
					Tracing.Information("TracePostWorkItemOut", traceMethod);
				}
				asyncResult = new CompletedAsyncResult(asyncState, completedSynchronously: true);
				callback?.Invoke(asyncResult);
			}
			else
			{
				asyncResult = BeginInvoke(callback, asyncState);
			}
			return asyncResult;
		}

		private void OneWayAsyncInvoke()
		{
			if (protocol.OnewayInitException != null)
			{
				HandleOneWayException(new Exception(Res.GetString("WebConfigExtensionError"), protocol.OnewayInitException), "OneWayAsyncInvoke");
				return;
			}
			HttpContext httpContext = null;
			if (protocol.Context != null)
			{
				httpContext = SwitchContext(protocol.Context);
			}
			try
			{
				BeginInvoke(OneWayCallback, null);
			}
			catch (Exception e)
			{
				HandleOneWayException(e, "OneWayAsyncInvoke");
			}
			finally
			{
				if (httpContext != null)
				{
					SwitchContext(httpContext);
				}
			}
		}

		private IAsyncResult BeginInvoke(AsyncCallback callback, object asyncState)
		{
			IAsyncResult asyncResult;
			try
			{
				PrepareContext();
				protocol.CreateServerInstance();
				asyncCallback = callback;
				TraceMethod caller = (Tracing.On ? new TraceMethod(this, "BeginInvoke") : null);
				TraceMethod callDetails = (Tracing.On ? new TraceMethod(protocol.Target, protocol.MethodInfo.Name, parameters) : null);
				if (Tracing.On)
				{
					Tracing.Enter(protocol.MethodInfo.ToString(), caller, callDetails);
				}
				asyncResult = protocol.MethodInfo.BeginInvoke(protocol.Target, parameters, Callback, asyncState);
				if (Tracing.On)
				{
					Tracing.Enter(protocol.MethodInfo.ToString(), caller);
				}
				if (asyncResult == null)
				{
					throw new InvalidOperationException(Res.GetString("WebNullAsyncResultInBegin"));
				}
			}
			catch (Exception ex)
			{
				if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
				{
					throw;
				}
				if (Tracing.On)
				{
					Tracing.ExceptionCatch(TraceEventType.Error, this, "BeginInvoke", ex);
				}
				exception = ex;
				asyncResult = new CompletedAsyncResult(asyncState, completedSynchronously: true);
				asyncCallback = callback;
				DoCallback(asyncResult);
			}
			catch
			{
				exception = new Exception(Res.GetString("NonClsCompliantException"));
				asyncResult = new CompletedAsyncResult(asyncState, completedSynchronously: true);
				asyncCallback = callback;
				DoCallback(asyncResult);
			}
			asyncBeginComplete.Set();
			TraceFlush();
			return asyncResult;
		}

		private void OneWayCallback(IAsyncResult asyncResult)
		{
			EndInvoke(asyncResult);
		}

		protected void EndCoreProcessRequest(IAsyncResult asyncResult)
		{
			if (asyncResult != null)
			{
				if (protocol.IsOneWay)
				{
					protocol.WriteOneWayResponse();
				}
				else
				{
					EndInvoke(asyncResult);
				}
			}
		}

		private void EndInvoke(IAsyncResult asyncResult)
		{
			try
			{
				if (exception != null)
				{
					throw exception;
				}
				object[] returnValues = protocol.MethodInfo.EndInvoke(protocol.Target, asyncResult);
				WriteReturns(returnValues);
			}
			catch (Exception ex)
			{
				if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
				{
					throw;
				}
				if (Tracing.On)
				{
					Tracing.ExceptionCatch(TraceEventType.Error, this, "EndInvoke", ex);
				}
				if (!protocol.IsOneWay)
				{
					WriteException(ex);
				}
			}
			catch
			{
				if (!protocol.IsOneWay)
				{
					WriteException(new Exception(Res.GetString("NonClsCompliantException")));
				}
			}
			finally
			{
				protocol.DisposeServerInstance();
			}
			TraceFlush();
		}

		private void WriteReturns(object[] returnValues)
		{
			if (!protocol.IsOneWay)
			{
				bool bufferResponse = protocol.MethodAttribute.BufferResponse;
				Stream stream = protocol.Response.OutputStream;
				if (!bufferResponse)
				{
					stream = new BufferedResponseStream(stream, 16384);
					((BufferedResponseStream)stream).FlushEnabled = false;
				}
				protocol.WriteReturns(returnValues, stream);
				if (!bufferResponse)
				{
					((BufferedResponseStream)stream).FlushEnabled = true;
					stream.Flush();
				}
			}
		}
	}
	internal class SyncSessionlessHandler : WebServiceHandler, IHttpHandler
	{
		public bool IsReusable => false;

		internal SyncSessionlessHandler(ServerProtocol protocol)
			: base(protocol)
		{
		}

		public void ProcessRequest(HttpContext context)
		{
			TraceMethod caller = (Tracing.On ? new TraceMethod(this, "ProcessRequest") : null);
			if (Tracing.On)
			{
				Tracing.Enter("IHttpHandler.ProcessRequest", caller, Tracing.Details(context.Request));
			}
			CoreProcessRequest();
			if (Tracing.On)
			{
				Tracing.Exit("IHttpHandler.ProcessRequest", caller);
			}
		}
	}
	internal class SyncSessionHandler : SyncSessionlessHandler, IRequiresSessionState
	{
		internal SyncSessionHandler(ServerProtocol protocol)
			: base(protocol)
		{
		}
	}
	internal class AsyncSessionlessHandler : SyncSessionlessHandler, IHttpAsyncHandler, IHttpHandler
	{
		internal AsyncSessionlessHandler(ServerProtocol protocol)
			: base(protocol)
		{
		}

		public IAsyncResult BeginProcessRequest(HttpContext context, AsyncCallback callback, object asyncState)
		{
			TraceMethod caller = (Tracing.On ? new TraceMethod(this, "BeginProcessRequest") : null);
			if (Tracing.On)
			{
				Tracing.Enter("IHttpAsyncHandler.BeginProcessRequest", caller, Tracing.Details(context.Request));
			}
			IAsyncResult result = BeginCoreProcessRequest(callback, asyncState);
			if (Tracing.On)
			{
				Tracing.Exit("IHttpAsyncHandler.BeginProcessRequest", caller);
			}
			return result;
		}

		public void EndProcessRequest(IAsyncResult asyncResult)
		{
			TraceMethod caller = (Tracing.On ? new TraceMethod(this, "EndProcessRequest") : null);
			if (Tracing.On)
			{
				Tracing.Enter("IHttpAsyncHandler.EndProcessRequest", caller);
			}
			EndCoreProcessRequest(asyncResult);
			if (Tracing.On)
			{
				Tracing.Exit("IHttpAsyncHandler.EndProcessRequest", caller);
			}
		}
	}
	internal class AsyncSessionHandler : AsyncSessionlessHandler, IRequiresSessionState
	{
		internal AsyncSessionHandler(ServerProtocol protocol)
			: base(protocol)
		{
		}
	}
	internal class CompletedAsyncResult : IAsyncResult
	{
		private object asyncState;

		private bool completedSynchronously;

		public object AsyncState => asyncState;

		public bool CompletedSynchronously => completedSynchronously;

		public bool IsCompleted => true;

		public WaitHandle AsyncWaitHandle => null;

		internal CompletedAsyncResult(object asyncState, bool completedSynchronously)
		{
			this.asyncState = asyncState;
			this.completedSynchronously = completedSynchronously;
		}
	}
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	public class WebServiceHandlerFactory : IHttpHandlerFactory
	{
		public IHttpHandler GetHandler(HttpContext context, string verb, string url, string filePath)
		{
			TraceMethod caller = (Tracing.On ? new TraceMethod(this, "GetHandler") : null);
			if (Tracing.On)
			{
				Tracing.Enter("IHttpHandlerFactory.GetHandler", caller, Tracing.Details(context.Request));
			}
			new AspNetHostingPermission(AspNetHostingPermissionLevel.Minimal).Demand();
			Type compiledType = WebServiceParser.GetCompiledType(url, context);
			IHttpHandler result = CoreGetHandler(compiledType, context, context.Request, context.Response);
			if (Tracing.On)
			{
				Tracing.Exit("IHttpHandlerFactory.GetHandler", caller);
			}
			return result;
		}

		internal IHttpHandler CoreGetHandler(Type type, HttpContext context, HttpRequest request, HttpResponse response)
		{
			TraceMethod method = (Tracing.On ? new TraceMethod(this, "CoreGetHandler") : null);
			ServerProtocolFactory[] serverProtocolFactories = WebServicesSection.Current.ServerProtocolFactories;
			ServerProtocol serverProtocol = null;
			bool abortProcessing = false;
			for (int i = 0; i < serverProtocolFactories.Length; i++)
			{
				try
				{
					serverProtocol = serverProtocolFactories[i].Create(type, context, request, response, out abortProcessing);
					if ((serverProtocol != null && serverProtocol.GetType() != typeof(UnsupportedRequestProtocol)) || abortProcessing)
					{
						break;
					}
					continue;
				}
				catch (Exception ex)
				{
					if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
					{
						throw;
					}
					throw Tracing.ExceptionThrow(method, new InvalidOperationException(Res.GetString("FailedToHandleRequest0"), ex));
				}
				catch
				{
					throw Tracing.ExceptionThrow(method, new InvalidOperationException(Res.GetString("FailedToHandleRequest0"), null));
				}
			}
			if (abortProcessing)
			{
				return new NopHandler();
			}
			if (serverProtocol == null)
			{
				if (request.PathInfo != null && request.PathInfo.Length != 0)
				{
					throw Tracing.ExceptionThrow(method, new InvalidOperationException(Res.GetString("WebUnrecognizedRequestFormatUrl", request.PathInfo)));
				}
				throw Tracing.ExceptionThrow(method, new InvalidOperationException(Res.GetString("WebUnrecognizedRequestFormat")));
			}
			if (serverProtocol is UnsupportedRequestProtocol)
			{
				throw Tracing.ExceptionThrow(method, new HttpException(((UnsupportedRequestProtocol)serverProtocol).HttpCode, Res.GetString("WebUnrecognizedRequestFormat")));
			}
			bool isAsync = serverProtocol.MethodInfo.IsAsync;
			bool enableSession = serverProtocol.MethodAttribute.EnableSession;
			if (isAsync)
			{
				if (enableSession)
				{
					return new AsyncSessionHandler(serverProtocol);
				}
				return new AsyncSessionlessHandler(serverProtocol);
			}
			if (enableSession)
			{
				return new SyncSessionHandler(serverProtocol);
			}
			return new SyncSessionlessHandler(serverProtocol);
		}

		public void ReleaseHandler(IHttpHandler handler)
		{
		}
	}
	internal class UnsupportedRequestProtocol : ServerProtocol
	{
		private int httpCode;

		internal int HttpCode => httpCode;

		internal override bool IsOneWay => false;

		internal override LogicalMethodInfo MethodInfo => null;

		internal override ServerType ServerType => null;

		internal UnsupportedRequestProtocol(int httpCode)
		{
			this.httpCode = httpCode;
		}

		internal override bool Initialize()
		{
			return true;
		}

		internal override object[] ReadParameters()
		{
			return new object[0];
		}

		internal override void WriteReturns(object[] returnValues, Stream outputStream)
		{
		}

		internal override bool WriteException(Exception e, Stream outputStream)
		{
			return false;
		}
	}
	internal class NopHandler : IHttpHandler
	{
		public bool IsReusable => false;

		public void ProcessRequest(HttpContext context)
		{
		}
	}
	internal class XmlReturn
	{
		private XmlReturn()
		{
		}

		internal static object[] GetInitializers(LogicalMethodInfo[] methodInfos)
		{
			if (methodInfos.Length == 0)
			{
				return new object[0];
			}
			WebServiceAttribute attribute = WebServiceReflector.GetAttribute(methodInfos);
			bool serviceDefaultIsEncoded = SoapReflector.ServiceDefaultIsEncoded(WebServiceReflector.GetMostDerivedType(methodInfos));
			XmlReflectionImporter xmlReflectionImporter = SoapReflector.CreateXmlImporter(attribute.Namespace, serviceDefaultIsEncoded);
			WebMethodReflector.IncludeTypes(methodInfos, xmlReflectionImporter);
			ArrayList arrayList = new ArrayList();
			bool[] array = new bool[methodInfos.Length];
			for (int i = 0; i < methodInfos.Length; i++)
			{
				LogicalMethodInfo logicalMethodInfo = methodInfos[i];
				Type returnType = logicalMethodInfo.ReturnType;
				if (IsSupported(returnType) && HttpServerProtocol.AreUrlParametersSupported(logicalMethodInfo))
				{
					XmlAttributes xmlAttributes = new XmlAttributes(logicalMethodInfo.ReturnTypeCustomAttributeProvider);
					XmlTypeMapping xmlTypeMapping = xmlReflectionImporter.ImportTypeMapping(returnType, xmlAttributes.XmlRoot);
					xmlTypeMapping.SetKey(logicalMethodInfo.GetKey() + ":Return");
					arrayList.Add(xmlTypeMapping);
					array[i] = true;
				}
			}
			if (arrayList.Count == 0)
			{
				return new object[0];
			}
			XmlMapping[] array2 = (XmlMapping[])arrayList.ToArray(typeof(XmlMapping));
			Evidence evidence = methodInfos[0].DeclaringType.Assembly.Evidence;
			TraceMethod caller = (Tracing.On ? new TraceMethod(typeof(XmlReturn), "GetInitializers", methodInfos) : null);
			if (Tracing.On)
			{
				Tracing.Enter(Tracing.TraceId("TraceCreateSerializer"), caller, new TraceMethod(typeof(XmlSerializer), "FromMappings", array2, evidence));
			}
			XmlSerializer[] array3 = XmlSerializer.FromMappings(array2, evidence);
			if (Tracing.On)
			{
				Tracing.Exit(Tracing.TraceId("TraceCreateSerializer"), caller);
			}
			object[] array4 = new object[methodInfos.Length];
			int num = 0;
			for (int j = 0; j < array4.Length; j++)
			{
				if (array[j])
				{
					array4[j] = array3[num++];
				}
			}
			return array4;
		}

		private static bool IsSupported(Type returnType)
		{
			return returnType != typeof(void);
		}

		internal static object GetInitializer(LogicalMethodInfo methodInfo)
		{
			return GetInitializers(new LogicalMethodInfo[1] { methodInfo });
		}
	}
	public class XmlReturnReader : MimeReturnReader
	{
		private XmlSerializer xmlSerializer;

		public override void Initialize(object o)
		{
			xmlSerializer = (XmlSerializer)o;
		}

		public override object[] GetInitializers(LogicalMethodInfo[] methodInfos)
		{
			return XmlReturn.GetInitializers(methodInfos);
		}

		public override object GetInitializer(LogicalMethodInfo methodInfo)
		{
			return XmlReturn.GetInitializer(methodInfo);
		}

		public override object Read(WebResponse response, Stream responseStream)
		{
			try
			{
				if (response == null)
				{
					throw new ArgumentNullException("response");
				}
				if (!ContentType.MatchesBase(response.ContentType, "text/xml"))
				{
					throw new InvalidOperationException(Res.GetString("WebResultNotXml"));
				}
				Encoding encoding = RequestResponseUtils.GetEncoding(response.ContentType);
				StreamReader streamReader = new StreamReader(responseStream, encoding, detectEncodingFromByteOrderMarks: true);
				TraceMethod caller = (Tracing.On ? new TraceMethod(this, "Read") : null);
				if (Tracing.On)
				{
					Tracing.Enter(Tracing.TraceId("TraceReadResponse"), caller, new TraceMethod(xmlSerializer, "Deserialize", streamReader));
				}
				object result = xmlSerializer.Deserialize(streamReader);
				if (Tracing.On)
				{
					Tracing.Exit(Tracing.TraceId("TraceReadResponse"), caller);
				}
				return result;
			}
			finally
			{
				response.Close();
			}
		}
	}
	internal class XmlReturnWriter : MimeReturnWriter
	{
		private XmlSerializer xmlSerializer;

		public override void Initialize(object o)
		{
			xmlSerializer = (XmlSerializer)o;
		}

		public override object[] GetInitializers(LogicalMethodInfo[] methodInfos)
		{
			return XmlReturn.GetInitializers(methodInfos);
		}

		public override object GetInitializer(LogicalMethodInfo methodInfo)
		{
			return XmlReturn.GetInitializer(methodInfo);
		}

		internal override void Write(HttpResponse response, Stream outputStream, object returnValue)
		{
			Encoding encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);
			response.ContentType = ContentType.Compose("text/xml", encoding);
			StreamWriter streamWriter = new StreamWriter(outputStream, encoding);
			TraceMethod caller = (Tracing.On ? new TraceMethod(this, "Write") : null);
			if (Tracing.On)
			{
				Tracing.Enter(Tracing.TraceId("TraceWriteResponse"), caller, new TraceMethod(xmlSerializer, "Serialize", streamWriter, returnValue));
			}
			xmlSerializer.Serialize(streamWriter, returnValue);
			if (Tracing.On)
			{
				Tracing.Exit(Tracing.TraceId("TraceWriteResponse"), caller);
			}
		}
	}
}
namespace System.Web.Services.Discovery
{
	public abstract class DiscoveryReference
	{
		private DiscoveryClientProtocol clientProtocol;

		[XmlIgnore]
		public DiscoveryClientProtocol ClientProtocol
		{
			get
			{
				return clientProtocol;
			}
			set
			{
				clientProtocol = value;
			}
		}

		[XmlIgnore]
		public virtual string DefaultFilename => FilenameFromUrl(Url);

		[XmlIgnore]
		public abstract string Url { get; set; }

		public abstract void WriteDocument(object document, Stream stream);

		public abstract object ReadDocument(Stream stream);

		internal virtual void LoadExternals(Hashtable loadedExternals)
		{
		}

		public static string FilenameFromUrl(string url)
		{
			int num = url.LastIndexOf('/', url.Length - 1);
			if (num >= 0)
			{
				url = url.Substring(num + 1);
			}
			int num2 = url.IndexOf('.');
			if (num2 >= 0)
			{
				url = url.Substring(0, num2);
			}
			int num3 = url.IndexOf('?');
			if (num3 >= 0)
			{
				url = url.Substring(0, num3);
			}
			if (url == null || url.Length == 0)
			{
				return "item";
			}
			return MakeValidFilename(url);
		}

		private static bool FindChar(char ch, char[] chars)
		{
			for (int i = 0; i < chars.Length; i++)
			{
				if (ch == chars[i])
				{
					return true;
				}
			}
			return false;
		}

		internal static string MakeValidFilename(string filename)
		{
			if (filename == null)
			{
				return null;
			}
			StringBuilder stringBuilder = new StringBuilder(filename.Length);
			foreach (char c in filename)
			{
				if (!FindChar(c, Path.InvalidPathChars))
				{
					stringBuilder.Append(c);
				}
			}
			string text = stringBuilder.ToString();
			if (text.Length == 0)
			{
				text = "item";
			}
			return Path.GetFileName(text);
		}

		public void Resolve()
		{
			if (ClientProtocol == null)
			{
				throw new InvalidOperationException(Res.GetString("WebResolveMissingClientProtocol"));
			}
			if (ClientProtocol.Documents[Url] != null || ClientProtocol.InlinedSchemas[Url] != null)
			{
				return;
			}
			string url = Url;
			string url2 = Url;
			string contentType = null;
			Stream stream = ClientProtocol.Download(ref url, ref contentType);
			if (ClientProtocol.Documents[url] != null)
			{
				Url = url;
				return;
			}
			try
			{
				Url = url;
				Resolve(contentType, stream);
			}
			catch
			{
				Url = url2;
				throw;
			}
			finally
			{
				stream.Close();
			}
		}

		internal Exception AttemptResolve(string contentType, Stream stream)
		{
			try
			{
				Resolve(contentType, stream);
				return null;
			}
			catch (Exception ex)
			{
				if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
				{
					throw;
				}
				if (Tracing.On)
				{
					Tracing.ExceptionCatch(TraceEventType.Warning, this, "AttemptResolve", ex);
				}
				return ex;
			}
			catch
			{
				return new Exception(Res.GetString("NonClsCompliantException"));
			}
		}

		protected internal abstract void Resolve(string contentType, Stream stream);

		internal static string UriToString(string baseUrl, string relUrl)
		{
			return new Uri(new Uri(baseUrl), relUrl).GetComponents(UriComponents.AbsoluteUri, UriFormat.SafeUnescaped);
		}
	}
	[XmlRoot("contractRef", Namespace = "http://schemas.xmlsoap.org/disco/scl/")]
	public class ContractReference : DiscoveryReference
	{
		public const string Namespace = "http://schemas.xmlsoap.org/disco/scl/";

		private string docRef;

		private string reference;

		[XmlAttribute("ref")]
		public string Ref
		{
			get
			{
				return reference;
			}
			set
			{
				reference = value;
			}
		}

		[XmlAttribute("docRef")]
		public string DocRef
		{
			get
			{
				return docRef;
			}
			set
			{
				docRef = value;
			}
		}

		[XmlIgnore]
		public override string Url
		{
			get
			{
				return Ref;
			}
			set
			{
				Ref = value;
			}
		}

		[XmlIgnore]
		public ServiceDescription Contract
		{
			get
			{
				if (base.ClientProtocol == null)
				{
					throw new InvalidOperationException(Res.GetString("WebMissingClientProtocol"));
				}
				object obj = base.ClientProtocol.Documents[Url];
				if (obj == null)
				{
					Resolve();
					obj = base.ClientProtocol.Documents[Url];
				}
				if (!(obj is ServiceDescription result))
				{
					throw new InvalidOperationException(Res.GetString("WebInvalidDocType", typeof(ServiceDescription).FullName, (obj == null) ? string.Empty : obj.GetType().FullName, Url));
				}
				return result;
			}
		}

		[XmlIgnore]
		public override string DefaultFilename
		{
			get
			{
				string text = DiscoveryReference.MakeValidFilename(Contract.Name);
				if (text == null || text.Length == 0)
				{
					text = DiscoveryReference.FilenameFromUrl(Url);
				}
				return Path.ChangeExtension(text, ".wsdl");
			}
		}

		public ContractReference()
		{
		}

		public ContractReference(string href)
		{
			Ref = href;
		}

		public ContractReference(string href, string docRef)
		{
			Ref = href;
			DocRef = docRef;
		}

		internal override void LoadExternals(Hashtable loadedExternals)
		{
			ServiceDescription serviceDescription = null;
			try
			{
				serviceDescription = Contract;
			}
			catch (Exception ex)
			{
				if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
				{
					throw;
				}
				base.ClientProtocol.Errors[Url] = ex;
				if (Tracing.On)
				{
					Tracing.ExceptionCatch(TraceEventType.Warning, this, "LoadExternals", ex);
				}
			}
			catch
			{
				base.ClientProtocol.Errors[Url] = new Exception(Res.GetString("NonClsCompliantException"));
			}
			if (serviceDescription == null)
			{
				return;
			}
			foreach (XmlSchema schema in Contract.Types.Schemas)
			{
				SchemaReference.LoadExternals(schema, Url, base.ClientProtocol, loadedExternals);
			}
		}

		public override void WriteDocument(object document, Stream stream)
		{
			((ServiceDescription)document).Write(new StreamWriter(stream, new UTF8Encoding(encoderShouldEmitUTF8Identifier: false)));
		}

		public override object ReadDocument(Stream stream)
		{
			return ServiceDescription.Read(stream, validate: true);
		}

		protected internal override void Resolve(string contentType, Stream stream)
		{
			if (ContentType.IsHtml(contentType))
			{
				throw new InvalidContentTypeException(Res.GetString("WebInvalidContentType", contentType), contentType);
			}
			ServiceDescription serviceDescription = base.ClientProtocol.Documents[Url] as ServiceDescription;
			if (serviceDescription == null)
			{
				serviceDescription = ServiceDescription.Read(stream, validate: true);
				serviceDescription.RetrievalUrl = Url;
				base.ClientProtocol.Documents[Url] = serviceDescription;
			}
			base.ClientProtocol.References[Url] = this;
			ArrayList arrayList = new ArrayList();
			foreach (Import import in serviceDescription.Imports)
			{
				if (import.Location != null)
				{
					arrayList.Add(import.Location);
				}
			}
			foreach (XmlSchema schema in serviceDescription.Types.Schemas)
			{
				foreach (XmlSchemaExternal include in schema.Includes)
				{
					if (include.SchemaLocation != null && include.SchemaLocation.Length > 0)
					{
						arrayList.Add(include.SchemaLocation);
					}
				}
			}
			foreach (string item in arrayList)
			{
				string url = DiscoveryReference.UriToString(Url, item);
				if (base.ClientProtocol.Documents[url] != null)
				{
					continue;
				}
				string url2 = url;
				try
				{
					stream = base.ClientProtocol.Download(ref url, ref contentType);
					try
					{
						if (base.ClientProtocol.Documents[url] != null)
						{
							continue;
						}
						XmlTextReader xmlTextReader = new XmlTextReader(new StreamReader(stream, RequestResponseUtils.GetEncoding(contentType)));
						xmlTextReader.WhitespaceHandling = WhitespaceHandling.Significant;
						xmlTextReader.XmlResolver = null;
						xmlTextReader.ProhibitDtd = true;
						if (ServiceDescription.CanRead(xmlTextReader))
						{
							ServiceDescription serviceDescription2 = ServiceDescription.Read(xmlTextReader, validate: true);
							serviceDescription2.RetrievalUrl = url;
							base.ClientProtocol.Documents[url] = serviceDescription2;
							ContractReference contractReference = new ContractReference(url, null);
							contractReference.ClientProtocol = base.ClientProtocol;
							try
							{
								contractReference.Resolve(contentType, stream);
							}
							catch (Exception ex)
							{
								if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
								{
									throw;
								}
								contractReference.Url = url2;
								if (Tracing.On)
								{
									Tracing.ExceptionCatch(TraceEventType.Warning, this, "Resolve", ex);
								}
							}
							catch
							{
								contractReference.Url = url2;
							}
						}
						else
						{
							if (!xmlTextReader.IsStartElement("schema", "http://www.w3.org/2001/XMLSchema"))
							{
								continue;
							}
							base.ClientProtocol.Documents[url] = XmlSchema.Read(xmlTextReader, null);
							SchemaReference schemaReference = new SchemaReference(url);
							schemaReference.ClientProtocol = base.ClientProtocol;
							try
							{
								schemaReference.Resolve(contentType, stream);
							}
							catch (Exception ex2)
							{
								if (ex2 is ThreadAbortException || ex2 is StackOverflowException || ex2 is OutOfMemoryException)
								{
									throw;
								}
								schemaReference.Url = url2;
								if (Tracing.On)
								{
									Tracing.ExceptionCatch(TraceEventType.Warning, this, "Resolve", ex2);
								}
							}
							catch
							{
								schemaReference.Url = url2;
							}
							continue;
						}
					}
					finally
					{
						stream.Close();
					}
				}
				catch (Exception ex3)
				{
					if (ex3 is ThreadAbortException || ex3 is StackOverflowException || ex3 is OutOfMemoryException)
					{
						throw;
					}
					throw new InvalidDocumentContentsException(Res.GetString("TheWSDLDocumentContainsLinksThatCouldNotBeResolved", url), ex3);
				}
				catch
				{
					throw new InvalidDocumentContentsException(Res.GetString("TheWSDLDocumentContainsLinksThatCouldNotBeResolved", url), null);
				}
			}
		}
	}
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	public abstract class DiscoverySearchPattern
	{
		public abstract string Pattern { get; }

		public abstract DiscoveryReference GetDiscoveryReference(string filename);
	}
	public sealed class ContractSearchPattern : DiscoverySearchPattern
	{
		public override string Pattern => "*.asmx";

		public override DiscoveryReference GetDiscoveryReference(string filename)
		{
			return new ContractReference(filename + "?wsdl", filename);
		}
	}
	public sealed class DiscoveryClientDocumentCollection : DictionaryBase
	{
		public object this[string url]
		{
			get
			{
				return base.Dictionary[url];
			}
			set
			{
				base.Dictionary[url] = value;
			}
		}

		public ICollection Keys => base.Dictionary.Keys;

		public ICollection Values => base.Dictionary.Values;

		public void Add(string url, object value)
		{
			base.Dictionary.Add(url, value);
		}

		public bool Contains(string url)
		{
			return base.Dictionary.Contains(url);
		}

		public void Remove(string url)
		{
			base.Dictionary.Remove(url);
		}
	}
	public class DiscoveryClientProtocol : HttpWebClientProtocol
	{
		public sealed class DiscoveryClientResultsFile
		{
			private DiscoveryClientResultCollection results = new DiscoveryClientResultCollection();

			public DiscoveryClientResultCollection Results => results;
		}

		private DiscoveryClientReferenceCollection references = new DiscoveryClientReferenceCollection();

		private DiscoveryClientDocumentCollection documents = new DiscoveryClientDocumentCollection();

		private Hashtable inlinedSchemas = new Hashtable();

		private ArrayList additionalInformation = new ArrayList();

		private DiscoveryExceptionDictionary errors = new DiscoveryExceptionDictionary();

		public IList AdditionalInformation => additionalInformation;

		public DiscoveryClientDocumentCollection Documents => documents;

		public DiscoveryExceptionDictionary Errors => errors;

		public DiscoveryClientReferenceCollection References => references;

		internal Hashtable InlinedSchemas => inlinedSchemas;

		public DiscoveryClientProtocol()
		{
		}

		internal DiscoveryClientProtocol(HttpWebClientProtocol protocol)
			: base(protocol)
		{
		}

		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public DiscoveryDocument Discover(string url)
		{
			if (Documents[url] is DiscoveryDocument result)
			{
				return result;
			}
			DiscoveryDocumentReference discoveryDocumentReference = new DiscoveryDocumentReference(url);
			discoveryDocumentReference.ClientProtocol = this;
			References[url] = discoveryDocumentReference;
			Errors.Clear();
			return discoveryDocumentReference.Document;
		}

		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public DiscoveryDocument DiscoverAny(string url)
		{
			Type[] discoveryReferenceTypes = WebServicesSection.Current.DiscoveryReferenceTypes;
			DiscoveryReference discoveryReference = null;
			string contentType = null;
			Stream stream = Download(ref url, ref contentType);
			Errors.Clear();
			bool flag = true;
			Exception ex = null;
			ArrayList arrayList = new ArrayList();
			Type[] array = discoveryReferenceTypes;
			foreach (Type type in array)
			{
				if (typeof(DiscoveryReference).IsAssignableFrom(type))
				{
					discoveryReference = (DiscoveryReference)Activator.CreateInstance(type);
					discoveryReference.Url = url;
					discoveryReference.ClientProtocol = this;
					stream.Position = 0L;
					Exception ex2 = discoveryReference.AttemptResolve(contentType, stream);
					if (ex2 == null)
					{
						break;
					}
					Errors[type.FullName] = ex2;
					discoveryReference = null;
					if (!(ex2 is InvalidContentTypeException ex3) || !ContentType.MatchesBase(ex3.ContentType, "text/html"))
					{
						flag = false;
					}
					if (ex2 is InvalidDocumentContentsException)
					{
						ex = ex2;
						break;
					}
					if (ex2.InnerException != null && ex2.InnerException.InnerException == null)
					{
						arrayList.Add(ex2.InnerException.Message);
					}
				}
			}
			if (discoveryReference == null)
			{
				if (ex != null)
				{
					StringBuilder stringBuilder = new StringBuilder(Res.GetString("TheDocumentWasUnderstoodButContainsErrors"));
					while (ex != null)
					{
						stringBuilder.Append("\n  - ").Append(ex.Message);
						ex = ex.InnerException;
					}
					throw new InvalidOperationException(stringBuilder.ToString());
				}
				if (flag)
				{
					throw new InvalidOperationException(Res.GetString("TheHTMLDocumentDoesNotContainDiscoveryInformation"));
				}
				bool flag2 = arrayList.Count == Errors.Count && Errors.Count > 0;
				int num = 1;
				while (flag2 && num < arrayList.Count)
				{
					if ((string)arrayList[num - 1] != (string)arrayList[num])
					{
						flag2 = false;
					}
					num++;
				}
				if (flag2)
				{
					throw new InvalidOperationException(Res.GetString("TheDocumentWasNotRecognizedAsAKnownDocumentType", arrayList[0]));
				}
				StringBuilder stringBuilder2 = new StringBuilder(Res.GetString("WebMissingResource", url));
				foreach (DictionaryEntry error in Errors)
				{
					Exception ex5 = (Exception)error.Value;
					string text = (string)error.Key;
					if (string.Compare(text, typeof(ContractReference).FullName, StringComparison.Ordinal) == 0)
					{
						text = Res.GetString("WebContractReferenceName");
					}
					else if (string.Compare(text, typeof(SchemaReference).FullName, StringComparison.Ordinal) == 0)
					{
						text = Res.GetString("WebShemaReferenceName");
					}
					else if (string.Compare(text, typeof(DiscoveryDocumentReference).FullName, StringComparison.Ordinal) == 0)
					{
						text = Res.GetString("WebDiscoveryDocumentReferenceName");
					}
					stringBuilder2.Append("\n- ").Append(Res.GetString("WebDiscoRefReport", text, ex5.Message));
					while (ex5.InnerException != null)
					{
						stringBuilder2.Append("\n  - ").Append(ex5.InnerException.Message);
						ex5 = ex5.InnerException;
					}
				}
				throw new InvalidOperationException(stringBuilder2.ToString());
			}
			if (discoveryReference is DiscoveryDocumentReference)
			{
				return ((DiscoveryDocumentReference)discoveryReference).Document;
			}
			References[discoveryReference.Url] = discoveryReference;
			DiscoveryDocument discoveryDocument = new DiscoveryDocument();
			discoveryDocument.References.Add(discoveryReference);
			return discoveryDocument;
		}

		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public Stream Download(ref string url)
		{
			string contentType = null;
			return Download(ref url, ref contentType);
		}

		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public Stream Download(ref string url, ref string contentType)
		{
			WebRequest webRequest = GetWebRequest(new Uri(url));
			webRequest.Method = "GET";
			WebResponse webResponse = null;
			try
			{
				webResponse = GetWebResponse(webRequest);
			}
			catch (Exception ex)
			{
				if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
				{
					throw;
				}
				throw new WebException(Res.GetString("ThereWasAnErrorDownloading0", url), ex);
			}
			catch
			{
				throw new WebException(Res.GetString("ThereWasAnErrorDownloading0", url), null);
			}
			if (webResponse is HttpWebResponse httpWebResponse && httpWebResponse.StatusCode != HttpStatusCode.OK)
			{
				string message = RequestResponseUtils.CreateResponseExceptionString(httpWebResponse);
				throw new WebException(Res.GetString("ThereWasAnErrorDownloading0", url), new WebException(message, null, WebExceptionStatus.ProtocolError, webResponse));
			}
			Stream responseStream = webResponse.GetResponseStream();
			try
			{
				url = webResponse.ResponseUri.ToString();
				contentType = webResponse.ContentType;
				if (webResponse.ResponseUri.Scheme == Uri.UriSchemeFtp || webResponse.ResponseUri.Scheme == Uri.UriSchemeFile)
				{
					int num = webResponse.ResponseUri.AbsolutePath.LastIndexOf('.');
					if (num != -1)
					{
						switch (webResponse.ResponseUri.AbsolutePath.Substring(num + 1).ToLower(CultureInfo.InvariantCulture))
						{
						case "xml":
						case "wsdl":
						case "xsd":
						case "disco":
							contentType = "text/xml";
							break;
						}
					}
				}
				return RequestResponseUtils.StreamToMemoryStream(responseStream);
			}
			finally
			{
				responseStream.Close();
			}
		}

		[Obsolete("This method will be removed from a future version. The method call is no longer required for resource discovery", false)]
		[ComVisible(false)]
		public void LoadExternals()
		{
		}

		internal void FixupReferences()
		{
			foreach (DiscoveryReference value in References.Values)
			{
				value.LoadExternals(InlinedSchemas);
			}
			foreach (string key in InlinedSchemas.Keys)
			{
				Documents.Remove(key);
			}
		}

		private static bool IsFilenameInUse(Hashtable filenames, string path)
		{
			return filenames[path.ToLower(CultureInfo.InvariantCulture)] != null;
		}

		private static void AddFilename(Hashtable filenames, string path)
		{
			filenames.Add(path.ToLower(CultureInfo.InvariantCulture), path);
		}

		private static string GetUniqueFilename(Hashtable filenames, string path)
		{
			if (IsFilenameInUse(filenames, path))
			{
				string extension = Path.GetExtension(path);
				string text = path.Substring(0, path.Length - extension.Length);
				int num = 0;
				do
				{
					path = text + num.ToString(CultureInfo.InvariantCulture) + extension;
					num++;
				}
				while (IsFilenameInUse(filenames, path));
			}
			AddFilename(filenames, path);
			return path;
		}

		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public DiscoveryClientResultCollection ReadAll(string topLevelFilename)
		{
			XmlSerializer xmlSerializer = new XmlSerializer(typeof(DiscoveryClientResultsFile));
			Stream stream = File.OpenRead(topLevelFilename);
			string directoryName = Path.GetDirectoryName(topLevelFilename);
			DiscoveryClientResultsFile discoveryClientResultsFile = null;
			try
			{
				discoveryClientResultsFile = (DiscoveryClientResultsFile)xmlSerializer.Deserialize(stream);
				for (int i = 0; i < discoveryClientResultsFile.Results.Count; i++)
				{
					if (discoveryClientResultsFile.Results[i] == null)
					{
						throw new InvalidOperationException(Res.GetString("WebNullRef"));
					}
					string referenceTypeName = discoveryClientResultsFile.Results[i].ReferenceTypeName;
					if (referenceTypeName == null || referenceTypeName.Length == 0)
					{
						throw new InvalidOperationException(Res.GetString("WebRefInvalidAttribute", "referenceType"));
					}
					DiscoveryReference discoveryReference = (DiscoveryReference)Activator.CreateInstance(Type.GetType(referenceTypeName));
					discoveryReference.ClientProtocol = this;
					string url = discoveryClientResultsFile.Results[i].Url;
					if (url == null || url.Length == 0)
					{
						throw new InvalidOperationException(Res.GetString("WebRefInvalidAttribute2", discoveryReference.GetType().FullName, "url"));
					}
					discoveryReference.Url = url;
					string filename = discoveryClientResultsFile.Results[i].Filename;
					if (filename == null || filename.Length == 0)
					{
						throw new InvalidOperationException(Res.GetString("WebRefInvalidAttribute2", discoveryReference.GetType().FullName, "filename"));
					}
					Stream stream2 = File.OpenRead(Path.Combine(directoryName, discoveryClientResultsFile.Results[i].Filename));
					try
					{
						Documents[discoveryReference.Url] = discoveryReference.ReadDocument(stream2);
					}
					finally
					{
						stream2.Close();
					}
					References[discoveryReference.Url] = discoveryReference;
				}
				ResolveAll();
			}
			finally
			{
				stream.Close();
			}
			return discoveryClientResultsFile.Results;
		}

		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public void ResolveAll()
		{
			Errors.Clear();
			int count = InlinedSchemas.Keys.Count;
			while (count != References.Count)
			{
				count = References.Count;
				DiscoveryReference[] array = new DiscoveryReference[References.Count];
				References.Values.CopyTo(array, 0);
				foreach (DiscoveryReference discoveryReference in array)
				{
					if (discoveryReference is DiscoveryDocumentReference)
					{
						try
						{
							((DiscoveryDocumentReference)discoveryReference).ResolveAll(throwOnError: true);
						}
						catch (Exception ex)
						{
							if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
							{
								throw;
							}
							Errors[discoveryReference.Url] = ex;
							if (Tracing.On)
							{
								Tracing.ExceptionCatch(TraceEventType.Warning, this, "ResolveAll", ex);
							}
						}
						catch
						{
							Errors[discoveryReference.Url] = new Exception(Res.GetString("NonClsCompliantException"));
						}
						continue;
					}
					try
					{
						discoveryReference.Resolve();
					}
					catch (Exception ex2)
					{
						if (ex2 is ThreadAbortException || ex2 is StackOverflowException || ex2 is OutOfMemoryException)
						{
							throw;
						}
						Errors[discoveryReference.Url] = ex2;
						if (Tracing.On)
						{
							Tracing.ExceptionCatch(TraceEventType.Warning, this, "ResolveAll", ex2);
						}
					}
					catch
					{
						Errors[discoveryReference.Url] = new Exception(Res.GetString("NonClsCompliantException"));
					}
				}
			}
			FixupReferences();
		}

		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public void ResolveOneLevel()
		{
			Errors.Clear();
			DiscoveryReference[] array = new DiscoveryReference[References.Count];
			References.Values.CopyTo(array, 0);
			for (int i = 0; i < array.Length; i++)
			{
				try
				{
					array[i].Resolve();
				}
				catch (Exception ex)
				{
					if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
					{
						throw;
					}
					Errors[array[i].Url] = ex;
					if (Tracing.On)
					{
						Tracing.ExceptionCatch(TraceEventType.Warning, this, "ResolveOneLevel", ex);
					}
				}
				catch
				{
					Errors[array[i].Url] = new Exception(Res.GetString("NonClsCompliantException"));
				}
			}
		}

		private static string GetRelativePath(string fullPath, string relativeTo)
		{
			string text = Path.GetDirectoryName(Path.GetFullPath(relativeTo));
			string text2 = "";
			while (text.Length > 0)
			{
				if (text.Length <= fullPath.Length && string.Compare(text, fullPath.Substring(0, text.Length), StringComparison.OrdinalIgnoreCase) == 0)
				{
					text2 += fullPath.Substring(text.Length);
					if (text2.StartsWith("\\", StringComparison.Ordinal))
					{
						text2 = text2.Substring(1);
					}
					return text2;
				}
				text2 += "..\\";
				if (text.Length < 2)
				{
					break;
				}
				int num = text.LastIndexOf('\\', text.Length - 2);
				text = text.Substring(0, num + 1);
			}
			return fullPath;
		}

		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public DiscoveryClientResultCollection WriteAll(string directory, string topLevelFilename)
		{
			DiscoveryClientResultsFile discoveryClientResultsFile = new DiscoveryClientResultsFile();
			Hashtable filenames = new Hashtable();
			string text = Path.Combine(directory, topLevelFilename);
			DictionaryEntry[] array = new DictionaryEntry[Documents.Count + InlinedSchemas.Keys.Count];
			int num = 0;
			foreach (DictionaryEntry document in Documents)
			{
				array[num++] = document;
			}
			foreach (DictionaryEntry inlinedSchema in InlinedSchemas)
			{
				array[num++] = inlinedSchema;
			}
			DictionaryEntry[] array2 = array;
			for (int i = 0; i < array2.Length; i++)
			{
				DictionaryEntry dictionaryEntry3 = array2[i];
				string url = (string)dictionaryEntry3.Key;
				object value = dictionaryEntry3.Value;
				if (value != null)
				{
					DiscoveryReference discoveryReference = References[url];
					string path = ((discoveryReference == null) ? DiscoveryReference.FilenameFromUrl(base.Url) : discoveryReference.DefaultFilename);
					path = GetUniqueFilename(filenames, Path.GetFullPath(Path.Combine(directory, path)));
					discoveryClientResultsFile.Results.Add(new DiscoveryClientResult(discoveryReference?.GetType(), url, GetRelativePath(path, text)));
					Stream stream = File.Create(path);
					try
					{
						discoveryReference.WriteDocument(value, stream);
					}
					finally
					{
						stream.Close();
					}
				}
			}
			XmlSerializer xmlSerializer = new XmlSerializer(typeof(DiscoveryClientResultsFile));
			Stream stream2 = File.Create(text);
			try
			{
				xmlSerializer.Serialize(new StreamWriter(stream2, new UTF8Encoding(encoderShouldEmitUTF8Identifier: false)), discoveryClientResultsFile);
			}
			finally
			{
				stream2.Close();
			}
			return discoveryClientResultsFile.Results;
		}
	}
	public sealed class DiscoveryClientResultCollection : CollectionBase
	{
		public DiscoveryClientResult this[int i]
		{
			get
			{
				return (DiscoveryClientResult)base.List[i];
			}
			set
			{
				base.List[i] = value;
			}
		}

		public int Add(DiscoveryClientResult value)
		{
			return base.List.Add(value);
		}

		public bool Contains(DiscoveryClientResult value)
		{
			return base.List.Contains(value);
		}

		public void Remove(DiscoveryClientResult value)
		{
			base.List.Remove(value);
		}
	}
	public sealed class DiscoveryClientResult
	{
		private string referenceTypeName;

		private string url;

		private string filename;

		[XmlAttribute("referenceType")]
		public string ReferenceTypeName
		{
			get
			{
				return referenceTypeName;
			}
			set
			{
				referenceTypeName = value;
			}
		}

		[XmlAttribute("url")]
		public string Url
		{
			get
			{
				return url;
			}
			set
			{
				url = value;
			}
		}

		[XmlAttribute("filename")]
		public string Filename
		{
			get
			{
				return filename;
			}
			set
			{
				filename = value;
			}
		}

		public DiscoveryClientResult()
		{
		}

		public DiscoveryClientResult(Type referenceType, string url, string filename)
		{
			referenceTypeName = ((referenceType == null) ? string.Empty : referenceType.FullName);
			this.url = url;
			this.filename = filename;
		}
	}
	public sealed class DiscoveryClientReferenceCollection : DictionaryBase
	{
		public DiscoveryReference this[string url]
		{
			get
			{
				return (DiscoveryReference)base.Dictionary[url];
			}
			set
			{
				base.Dictionary[url] = value;
			}
		}

		public ICollection Keys => base.Dictionary.Keys;

		public ICollection Values => base.Dictionary.Values;

		public void Add(DiscoveryReference value)
		{
			Add(value.Url, value);
		}

		public void Add(string url, DiscoveryReference value)
		{
			base.Dictionary.Add(url, value);
		}

		public bool Contains(string url)
		{
			return base.Dictionary.Contains(url);
		}

		public void Remove(string url)
		{
			base.Dictionary.Remove(url);
		}
	}
	[XmlRoot("discovery", Namespace = "http://schemas.xmlsoap.org/disco/")]
	public sealed class DiscoveryDocument
	{
		public const string Namespace = "http://schemas.xmlsoap.org/disco/";

		private ArrayList references = new ArrayList();

		[XmlIgnore]
		public IList References => references;

		public static DiscoveryDocument Read(Stream stream)
		{
			XmlTextReader xmlTextReader = new XmlTextReader(stream);
			xmlTextReader.WhitespaceHandling = WhitespaceHandling.Significant;
			xmlTextReader.XmlResolver = null;
			xmlTextReader.ProhibitDtd = true;
			return Read(xmlTextReader);
		}

		public static DiscoveryDocument Read(TextReader reader)
		{
			XmlTextReader xmlTextReader = new XmlTextReader(reader);
			xmlTextReader.WhitespaceHandling = WhitespaceHandling.Significant;
			xmlTextReader.XmlResolver = null;
			xmlTextReader.ProhibitDtd = true;
			return Read(xmlTextReader);
		}

		public static DiscoveryDocument Read(XmlReader xmlReader)
		{
			return (DiscoveryDocument)WebServicesSection.Current.DiscoveryDocumentSerializer.Deserialize(xmlReader);
		}

		public static bool CanRead(XmlReader xmlReader)
		{
			return WebServicesSection.Current.DiscoveryDocumentSerializer.CanDeserialize(xmlReader);
		}

		public void Write(TextWriter writer)
		{
			XmlTextWriter xmlTextWriter = new XmlTextWriter(writer);
			xmlTextWriter.Formatting = Formatting.Indented;
			xmlTextWriter.Indentation = 2;
			Write(xmlTextWriter);
		}

		public void Write(Stream stream)
		{
			TextWriter writer = new StreamWriter(stream, new UTF8Encoding(encoderShouldEmitUTF8Identifier: false));
			Write(writer);
		}

		public void Write(XmlWriter writer)
		{
			XmlSerializer discoveryDocumentSerializer = WebServicesSection.Current.DiscoveryDocumentSerializer;
			XmlSerializerNamespaces namespaces = new XmlSerializerNamespaces();
			discoveryDocumentSerializer.Serialize(writer, this, namespaces);
		}
	}
	internal class DiscoveryDocumentSerializer : XmlSerializer
	{
		protected override XmlSerializationReader CreateReader()
		{
			return new DiscoveryDocumentSerializationReader();
		}

		protected override XmlSerializationWriter CreateWriter()
		{
			return new DiscoveryDocumentSerializationWriter();
		}

		public override bool CanDeserialize(XmlReader xmlReader)
		{
			return xmlReader.IsStartElement("discovery", "http://schemas.xmlsoap.org/disco/");
		}

		protected override void Serialize(object objectToSerialize, XmlSerializationWriter writer)
		{
			((DiscoveryDocumentSerializationWriter)writer).Write10_discovery(objectToSerialize);
		}

		protected override object Deserialize(XmlSerializationReader reader)
		{
			return ((DiscoveryDocumentSerializationReader)reader).Read10_discovery();
		}
	}
	public class DiscoveryDocumentLinksPattern : DiscoverySearchPattern
	{
		public override string Pattern => "*.disco";

		public override DiscoveryReference GetDiscoveryReference(string filename)
		{
			return new DiscoveryDocumentReference(filename);
		}
	}
	[XmlRoot("discoveryRef", Namespace = "http://schemas.xmlsoap.org/disco/")]
	public sealed class DiscoveryDocumentReference : DiscoveryReference
	{
		private string reference;

		[XmlAttribute("ref")]
		public string Ref
		{
			get
			{
				if (reference != null)
				{
					return reference;
				}
				return "";
			}
			set
			{
				reference = value;
			}
		}

		[XmlIgnore]
		public override string DefaultFilename
		{
			get
			{
				string path = DiscoveryReference.FilenameFromUrl(Url);
				return Path.ChangeExtension(path, ".disco");
			}
		}

		[XmlIgnore]
		public DiscoveryDocument Document
		{
			get
			{
				if (base.ClientProtocol == null)
				{
					throw new InvalidOperationException(Res.GetString("WebMissingClientProtocol"));
				}
				object obj = base.ClientProtocol.Documents[Url];
				if (obj == null)
				{
					Resolve();
					obj = base.ClientProtocol.Documents[Url];
				}
				if (!(obj is DiscoveryDocument result))
				{
					throw new InvalidOperationException(Res.GetString("WebInvalidDocType", typeof(DiscoveryDocument).FullName, (obj == null) ? string.Empty : obj.GetType().FullName, Url));
				}
				return result;
			}
		}

		[XmlIgnore]
		public override string Url
		{
			get
			{
				return Ref;
			}
			set
			{
				Ref = value;
			}
		}

		public DiscoveryDocumentReference()
		{
		}

		public DiscoveryDocumentReference(string href)
		{
			Ref = href;
		}

		public override void WriteDocument(object document, Stream stream)
		{
			WebServicesSection.Current.DiscoveryDocumentSerializer.Serialize(new StreamWriter(stream, new UTF8Encoding(encoderShouldEmitUTF8Identifier: false)), document);
		}

		public override object ReadDocument(Stream stream)
		{
			return WebServicesSection.Current.DiscoveryDocumentSerializer.Deserialize(stream);
		}

		private static DiscoveryDocument GetDocumentNoParse(ref string url, DiscoveryClientProtocol client)
		{
			DiscoveryDocument discoveryDocument = (DiscoveryDocument)client.Documents[url];
			if (discoveryDocument != null)
			{
				return discoveryDocument;
			}
			string contentType = null;
			Stream stream = client.Download(ref url, ref contentType);
			try
			{
				XmlTextReader xmlTextReader = new XmlTextReader(new StreamReader(stream, RequestResponseUtils.GetEncoding(contentType)));
				xmlTextReader.WhitespaceHandling = WhitespaceHandling.Significant;
				xmlTextReader.XmlResolver = null;
				xmlTextReader.ProhibitDtd = true;
				if (!DiscoveryDocument.CanRead(xmlTextReader))
				{
					ArgumentException innerException = new ArgumentException(Res.GetString("WebInvalidFormat"));
					throw new InvalidOperationException(Res.GetString("WebMissingDocument", url), innerException);
				}
				return DiscoveryDocument.Read(xmlTextReader);
			}
			finally
			{
				stream.Close();
			}
		}

		protected internal override void Resolve(string contentType, Stream stream)
		{
			DiscoveryDocument discoveryDocument = null;
			if (ContentType.IsHtml(contentType))
			{
				string text = LinkGrep.SearchForLink(stream);
				if (text == null)
				{
					throw new InvalidContentTypeException(Res.GetString("WebInvalidContentType", contentType), contentType);
				}
				string url = DiscoveryReference.UriToString(Url, text);
				discoveryDocument = GetDocumentNoParse(ref url, base.ClientProtocol);
				Url = url;
			}
			if (discoveryDocument == null)
			{
				XmlTextReader xmlTextReader = new XmlTextReader(new StreamReader(stream, RequestResponseUtils.GetEncoding(contentType)));
				xmlTextReader.XmlResolver = null;
				xmlTextReader.WhitespaceHandling = WhitespaceHandling.Significant;
				xmlTextReader.ProhibitDtd = true;
				if (DiscoveryDocument.CanRead(xmlTextReader))
				{
					discoveryDocument = DiscoveryDocument.Read(xmlTextReader);
				}
				else
				{
					stream.Position = 0L;
					XmlTextReader xmlTextReader2 = new XmlTextReader(new StreamReader(stream, RequestResponseUtils.GetEncoding(contentType)));
					xmlTextReader2.XmlResolver = null;
					xmlTextReader2.ProhibitDtd = true;
					while (xmlTextReader2.NodeType != XmlNodeType.Element)
					{
						if (xmlTextReader2.NodeType == XmlNodeType.ProcessingInstruction)
						{
							StringBuilder stringBuilder = new StringBuilder("<pi ");
							stringBuilder.Append(xmlTextReader2.Value);
							stringBuilder.Append("/>");
							XmlTextReader xmlTextReader3 = new XmlTextReader(new StringReader(stringBuilder.ToString()));
							xmlTextReader3.XmlResolver = null;
							xmlTextReader3.ProhibitDtd = true;
							xmlTextReader3.Read();
							string text2 = xmlTextReader3["type"];
							string text3 = xmlTextReader3["alternate"];
							string text4 = xmlTextReader3["href"];
							if (text2 != null && ContentType.MatchesBase(text2, "text/xml") && text3 != null && string.Compare(text3, "yes", StringComparison.OrdinalIgnoreCase) == 0 && text4 != null)
							{
								string url2 = DiscoveryReference.UriToString(Url, text4);
								discoveryDocument = GetDocumentNoParse(ref url2, base.ClientProtocol);
								Url = url2;
								break;
							}
						}
						xmlTextReader2.Read();
					}
				}
			}
			if (discoveryDocument == null)
			{
				throw new InvalidOperationException(innerException: (!ContentType.IsXml(contentType)) ? ((Exception)new InvalidContentTypeException(Res.GetString("WebInvalidContentType", contentType), contentType)) : ((Exception)new ArgumentException(Res.GetString("WebInvalidFormat"))), message: Res.GetString("WebMissingDocument", Url));
			}
			base.ClientProtocol.References[Url] = this;
			base.ClientProtocol.Documents[Url] = discoveryDocument;
			foreach (object reference in discoveryDocument.References)
			{
				if (reference is DiscoveryReference)
				{
					DiscoveryReference discoveryReference = (DiscoveryReference)reference;
					if (discoveryReference.Url.Length == 0)
					{
						throw new InvalidOperationException(Res.GetString("WebEmptyRef", discoveryReference.GetType().FullName, Url));
					}
					discoveryReference.Url = DiscoveryReference.UriToString(Url, discoveryReference.Url);
					if (discoveryReference is ContractReference contractReference && contractReference.DocRef != null)
					{
						contractReference.DocRef = DiscoveryReference.UriToString(Url, contractReference.DocRef);
					}
					discoveryReference.ClientProtocol = base.ClientProtocol;
					base.ClientProtocol.References[discoveryReference.Url] = discoveryReference;
				}
				else
				{
					base.ClientProtocol.AdditionalInformation.Add(reference);
				}
			}
		}

		public void ResolveAll()
		{
			ResolveAll(throwOnError: true);
		}

		internal void ResolveAll(bool throwOnError)
		{
			try
			{
				Resolve();
			}
			catch (Exception ex)
			{
				if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
				{
					throw;
				}
				if (throwOnError)
				{
					throw;
				}
				if (Tracing.On)
				{
					Tracing.ExceptionCatch(TraceEventType.Warning, this, "ResolveAll", ex);
				}
				return;
			}
			catch
			{
				if (throwOnError)
				{
					throw;
				}
				return;
			}
			foreach (object reference in Document.References)
			{
				if (reference is DiscoveryDocumentReference discoveryDocumentReference && base.ClientProtocol.Documents[discoveryDocumentReference.Url] == null)
				{
					discoveryDocumentReference.ClientProtocol = base.ClientProtocol;
					discoveryDocumentReference.ResolveAll(throwOnError);
				}
			}
		}
	}
	public sealed class DiscoveryDocumentSearchPattern : DiscoverySearchPattern
	{
		public override string Pattern => "*.vsdisco";

		public override DiscoveryReference GetDiscoveryReference(string filename)
		{
			return new DiscoveryDocumentReference(filename);
		}
	}
	internal class DiscoveryDocumentSerializationWriter : XmlSerializationWriter
	{
		public void Write10_discovery(object o)
		{
			WriteStartDocument();
			if (o == null)
			{
				WriteNullTagLiteral("discovery", "http://schemas.xmlsoap.org/disco/");
				return;
			}
			TopLevelElement();
			Write9_DiscoveryDocument("discovery", "http://schemas.xmlsoap.org/disco/", (DiscoveryDocument)o, isNullable: true, needType: false);
		}

		private void Write9_DiscoveryDocument(string n, string ns, DiscoveryDocument o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(DiscoveryDocument))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, null);
			if (needType)
			{
				WriteXsiType("DiscoveryDocument", "http://schemas.xmlsoap.org/disco/");
			}
			IList list = o.References;
			if (list != null)
			{
				for (int i = 0; i < list.Count; i++)
				{
					object obj = list[i];
					if (obj is SchemaReference)
					{
						Write7_SchemaReference("schemaRef", "http://schemas.xmlsoap.org/disco/schema/", (SchemaReference)obj, isNullable: false, needType: false);
					}
					else if (obj is ContractReference)
					{
						Write5_ContractReference("contractRef", "http://schemas.xmlsoap.org/disco/scl/", (ContractReference)obj, isNullable: false, needType: false);
					}
					else if (obj is DiscoveryDocumentReference)
					{
						Write3_DiscoveryDocumentReference("discoveryRef", "http://schemas.xmlsoap.org/disco/", (DiscoveryDocumentReference)obj, isNullable: false, needType: false);
					}
					else if (obj is SoapBinding)
					{
						Write8_SoapBinding("soap", "http://schemas.xmlsoap.org/disco/soap/", (SoapBinding)obj, isNullable: false, needType: false);
					}
					else if (obj != null)
					{
						throw CreateUnknownTypeException(obj);
					}
				}
			}
			WriteEndElement(o);
		}

		private void Write8_SoapBinding(string n, string ns, SoapBinding o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(SoapBinding))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, null);
			if (needType)
			{
				WriteXsiType("SoapBinding", "http://schemas.xmlsoap.org/disco/soap/");
			}
			WriteAttribute("address", "", o.Address);
			WriteAttribute("binding", "", FromXmlQualifiedName(o.Binding));
			WriteEndElement(o);
		}

		private void Write3_DiscoveryDocumentReference(string n, string ns, DiscoveryDocumentReference o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(DiscoveryDocumentReference))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, null);
			if (needType)
			{
				WriteXsiType("DiscoveryDocumentReference", "http://schemas.xmlsoap.org/disco/");
			}
			WriteAttribute("ref", "", o.Ref);
			WriteEndElement(o);
		}

		private void Write5_ContractReference(string n, string ns, ContractReference o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(ContractReference))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, null);
			if (needType)
			{
				WriteXsiType("ContractReference", "http://schemas.xmlsoap.org/disco/scl/");
			}
			WriteAttribute("ref", "", o.Ref);
			WriteAttribute("docRef", "", o.DocRef);
			WriteEndElement(o);
		}

		private void Write7_SchemaReference(string n, string ns, SchemaReference o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(SchemaReference))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, null);
			if (needType)
			{
				WriteXsiType("SchemaReference", "http://schemas.xmlsoap.org/disco/schema/");
			}
			WriteAttribute("ref", "", o.Ref);
			WriteAttribute("targetNamespace", "", o.TargetNamespace);
			WriteEndElement(o);
		}

		protected override void InitCallbacks()
		{
		}
	}
	internal class DiscoveryDocumentSerializationReader : XmlSerializationReader
	{
		private string id1_discovery;

		private string id4_discoveryRef;

		private string id19_docRef;

		private string id8_Item;

		private string id14_binding;

		private string id20_DiscoveryDocumentReference;

		private string id17_targetNamespace;

		private string id5_contractRef;

		private string id10_Item;

		private string id13_Item;

		private string id7_schemaRef;

		private string id3_DiscoveryDocument;

		private string id9_soap;

		private string id12_address;

		private string id16_ref;

		private string id11_SoapBinding;

		private string id18_ContractReference;

		private string id2_Item;

		private string id15_SchemaReference;

		private string id6_Item;

		public object Read10_discovery()
		{
			object result = null;
			base.Reader.MoveToContent();
			if (base.Reader.NodeType == XmlNodeType.Element)
			{
				if ((object)base.Reader.LocalName != id1_discovery || (object)base.Reader.NamespaceURI != id2_Item)
				{
					throw CreateUnknownNodeException();
				}
				result = Read9_DiscoveryDocument(isNullable: true, checkType: true);
			}
			else
			{
				UnknownNode(null, "http://schemas.xmlsoap.org/disco/:discovery");
			}
			return result;
		}

		private DiscoveryDocument Read9_DiscoveryDocument(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id3_DiscoveryDocument || (object)xmlQualifiedName.Namespace != id2_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			DiscoveryDocument discoveryDocument = new DiscoveryDocument();
			IList references = discoveryDocument.References;
			while (base.Reader.MoveToNextAttribute())
			{
				if (!IsXmlnsAttribute(base.Reader.Name))
				{
					UnknownNode(discoveryDocument);
				}
			}
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				return discoveryDocument;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if ((object)base.Reader.LocalName == id4_discoveryRef && (object)base.Reader.NamespaceURI == id2_Item)
					{
						if (references == null)
						{
							base.Reader.Skip();
						}
						else
						{
							references.Add(Read3_DiscoveryDocumentReference(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id5_contractRef && (object)base.Reader.NamespaceURI == id6_Item)
					{
						if (references == null)
						{
							base.Reader.Skip();
						}
						else
						{
							references.Add(Read5_ContractReference(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id7_schemaRef && (object)base.Reader.NamespaceURI == id8_Item)
					{
						if (references == null)
						{
							base.Reader.Skip();
						}
						else
						{
							references.Add(Read7_SchemaReference(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id9_soap && (object)base.Reader.NamespaceURI == id10_Item)
					{
						if (references == null)
						{
							base.Reader.Skip();
						}
						else
						{
							references.Add(Read8_SoapBinding(isNullable: false, checkType: true));
						}
					}
					else
					{
						UnknownNode(discoveryDocument, "http://schemas.xmlsoap.org/disco/:discoveryRef, http://schemas.xmlsoap.org/disco/scl/:contractRef, http://schemas.xmlsoap.org/disco/schema/:schemaRef, http://schemas.xmlsoap.org/disco/soap/:soap");
					}
				}
				else
				{
					UnknownNode(discoveryDocument, "http://schemas.xmlsoap.org/disco/:discoveryRef, http://schemas.xmlsoap.org/disco/scl/:contractRef, http://schemas.xmlsoap.org/disco/schema/:schemaRef, http://schemas.xmlsoap.org/disco/soap/:soap");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			ReadEndElement();
			return discoveryDocument;
		}

		private SoapBinding Read8_SoapBinding(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id11_SoapBinding || (object)xmlQualifiedName.Namespace != id10_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			SoapBinding soapBinding = new SoapBinding();
			bool[] array = new bool[2];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array[0] && (object)base.Reader.LocalName == id12_address && (object)base.Reader.NamespaceURI == id13_Item)
				{
					soapBinding.Address = base.Reader.Value;
					array[0] = true;
				}
				else if (!array[1] && (object)base.Reader.LocalName == id14_binding && (object)base.Reader.NamespaceURI == id13_Item)
				{
					soapBinding.Binding = ToXmlQualifiedName(base.Reader.Value);
					array[1] = true;
				}
				else if (!IsXmlnsAttribute(base.Reader.Name))
				{
					UnknownNode(soapBinding, ":address, :binding");
				}
			}
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				return soapBinding;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					UnknownNode(soapBinding, "");
				}
				else
				{
					UnknownNode(soapBinding, "");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			ReadEndElement();
			return soapBinding;
		}

		private SchemaReference Read7_SchemaReference(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id15_SchemaReference || (object)xmlQualifiedName.Namespace != id8_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			SchemaReference schemaReference = new SchemaReference();
			bool[] array = new bool[2];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array[0] && (object)base.Reader.LocalName == id16_ref && (object)base.Reader.NamespaceURI == id13_Item)
				{
					schemaReference.Ref = base.Reader.Value;
					array[0] = true;
				}
				else if (!array[1] && (object)base.Reader.LocalName == id17_targetNamespace && (object)base.Reader.NamespaceURI == id13_Item)
				{
					schemaReference.TargetNamespace = base.Reader.Value;
					array[1] = true;
				}
				else if (!IsXmlnsAttribute(base.Reader.Name))
				{
					UnknownNode(schemaReference, ":ref, :targetNamespace");
				}
			}
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				return schemaReference;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					UnknownNode(schemaReference, "");
				}
				else
				{
					UnknownNode(schemaReference, "");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			ReadEndElement();
			return schemaReference;
		}

		private ContractReference Read5_ContractReference(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id18_ContractReference || (object)xmlQualifiedName.Namespace != id6_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			ContractReference contractReference = new ContractReference();
			bool[] array = new bool[2];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array[0] && (object)base.Reader.LocalName == id16_ref && (object)base.Reader.NamespaceURI == id13_Item)
				{
					contractReference.Ref = base.Reader.Value;
					array[0] = true;
				}
				else if (!array[1] && (object)base.Reader.LocalName == id19_docRef && (object)base.Reader.NamespaceURI == id13_Item)
				{
					contractReference.DocRef = base.Reader.Value;
					array[1] = true;
				}
				else if (!IsXmlnsAttribute(base.Reader.Name))
				{
					UnknownNode(contractReference, ":ref, :docRef");
				}
			}
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				return contractReference;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					UnknownNode(contractReference, "");
				}
				else
				{
					UnknownNode(contractReference, "");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			ReadEndElement();
			return contractReference;
		}

		private DiscoveryDocumentReference Read3_DiscoveryDocumentReference(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id20_DiscoveryDocumentReference || (object)xmlQualifiedName.Namespace != id2_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			DiscoveryDocumentReference discoveryDocumentReference = new DiscoveryDocumentReference();
			bool[] array = new bool[1];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array[0] && (object)base.Reader.LocalName == id16_ref && (object)base.Reader.NamespaceURI == id13_Item)
				{
					discoveryDocumentReference.Ref = base.Reader.Value;
					array[0] = true;
				}
				else if (!IsXmlnsAttribute(base.Reader.Name))
				{
					UnknownNode(discoveryDocumentReference, ":ref");
				}
			}
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				return discoveryDocumentReference;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					UnknownNode(discoveryDocumentReference, "");
				}
				else
				{
					UnknownNode(discoveryDocumentReference, "");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			ReadEndElement();
			return discoveryDocumentReference;
		}

		protected override void InitCallbacks()
		{
		}

		protected override void InitIDs()
		{
			id1_discovery = base.Reader.NameTable.Add("discovery");
			id4_discoveryRef = base.Reader.NameTable.Add("discoveryRef");
			id19_docRef = base.Reader.NameTable.Add("docRef");
			id8_Item = base.Reader.NameTable.Add("http://schemas.xmlsoap.org/disco/schema/");
			id14_binding = base.Reader.NameTable.Add("binding");
			id20_DiscoveryDocumentReference = base.Reader.NameTable.Add("DiscoveryDocumentReference");
			id17_targetNamespace = base.Reader.NameTable.Add("targetNamespace");
			id5_contractRef = base.Reader.NameTable.Add("contractRef");
			id10_Item = base.Reader.NameTable.Add("http://schemas.xmlsoap.org/disco/soap/");
			id13_Item = base.Reader.NameTable.Add("");
			id7_schemaRef = base.Reader.NameTable.Add("schemaRef");
			id3_DiscoveryDocument = base.Reader.NameTable.Add("DiscoveryDocument");
			id9_soap = base.Reader.NameTable.Add("soap");
			id12_address = base.Reader.NameTable.Add("address");
			id16_ref = base.Reader.NameTable.Add("ref");
			id11_SoapBinding = base.Reader.NameTable.Add("SoapBinding");
			id18_ContractReference = base.Reader.NameTable.Add("ContractReference");
			id2_Item = base.Reader.NameTable.Add("http://schemas.xmlsoap.org/disco/");
			id15_SchemaReference = base.Reader.NameTable.Add("SchemaReference");
			id6_Item = base.Reader.NameTable.Add("http://schemas.xmlsoap.org/disco/scl/");
		}
	}
	public sealed class DiscoveryExceptionDictionary : DictionaryBase
	{
		public Exception this[string url]
		{
			get
			{
				return (Exception)base.Dictionary[url];
			}
			set
			{
				base.Dictionary[url] = value;
			}
		}

		public ICollection Keys => base.Dictionary.Keys;

		public ICollection Values => base.Dictionary.Values;

		public void Add(string url, Exception value)
		{
			base.Dictionary.Add(url, value);
		}

		public bool Contains(string url)
		{
			return base.Dictionary.Contains(url);
		}

		public void Remove(string url)
		{
			base.Dictionary.Remove(url);
		}
	}
	public sealed class DiscoveryReferenceCollection : CollectionBase
	{
		public DiscoveryReference this[int i]
		{
			get
			{
				return (DiscoveryReference)base.List[i];
			}
			set
			{
				base.List[i] = value;
			}
		}

		public int Add(DiscoveryReference value)
		{
			return base.List.Add(value);
		}

		public bool Contains(DiscoveryReference value)
		{
			return base.List.Contains(value);
		}

		public void Remove(DiscoveryReference value)
		{
			base.List.Remove(value);
		}
	}
	public sealed class DiscoveryRequestHandler : IHttpHandler
	{
		public bool IsReusable => true;

		public void ProcessRequest(HttpContext context)
		{
			TraceMethod caller = (Tracing.On ? new TraceMethod(this, "ProcessRequest") : null);
			if (Tracing.On)
			{
				Tracing.Enter("IHttpHandler.ProcessRequest", caller, Tracing.Details(context.Request));
			}
			new PermissionSet(PermissionState.Unrestricted).Demand();
			string physicalPath = context.Request.PhysicalPath;
			_ = System.ComponentModel.CompModSwitches.DynamicDiscoverySearcher.TraceVerbose;
			if (File.Exists(physicalPath))
			{
				DynamicDiscoveryDocument dynamicDiscoveryDocument = null;
				FileStream fileStream = null;
				try
				{
					fileStream = new FileStream(physicalPath, FileMode.Open, FileAccess.Read);
					XmlTextReader xmlTextReader = new XmlTextReader(fileStream);
					xmlTextReader.WhitespaceHandling = WhitespaceHandling.Significant;
					xmlTextReader.XmlResolver = null;
					xmlTextReader.ProhibitDtd = true;
					if (xmlTextReader.IsStartElement("dynamicDiscovery", "urn:schemas-dynamicdiscovery:disco.2000-03-17"))
					{
						fileStream.Position = 0L;
						dynamicDiscoveryDocument = DynamicDiscoveryDocument.Load(fileStream);
					}
				}
				finally
				{
					fileStream?.Close();
				}
				if (dynamicDiscoveryDocument != null)
				{
					string[] array = new string[dynamicDiscoveryDocument.ExcludePaths.Length];
					string directoryName = Path.GetDirectoryName(physicalPath);
					string fileToSkipAtBegin = Path.GetFileName(physicalPath);
					for (int i = 0; i < array.Length; i++)
					{
						array[i] = dynamicDiscoveryDocument.ExcludePaths[i].Path;
					}
					Uri url = context.Request.Url;
					string str = url.GetComponents(UriComponents.AbsoluteUri, UriFormat.UriEscaped).Replace("#", "%23");
					string dirPartOfPath = GetDirPartOfPath(str);
					string dirPartOfPath2 = GetDirPartOfPath(url.LocalPath);
					DynamicDiscoSearcher dynamicDiscoSearcher;
					if (dirPartOfPath2.Length == 0 || System.ComponentModel.CompModSwitches.DynamicDiscoveryVirtualSearch.Enabled)
					{
						fileToSkipAtBegin = GetFilePartOfPath(str);
						dynamicDiscoSearcher = new DynamicVirtualDiscoSearcher(directoryName, array, dirPartOfPath);
					}
					else
					{
						dynamicDiscoSearcher = new DynamicPhysicalDiscoSearcher(directoryName, array, dirPartOfPath);
					}
					_ = System.ComponentModel.CompModSwitches.DynamicDiscoverySearcher.TraceVerbose;
					dynamicDiscoSearcher.Search(fileToSkipAtBegin);
					DiscoveryDocument discoveryDocument = dynamicDiscoSearcher.DiscoveryDocument;
					MemoryStream memoryStream = new MemoryStream(1024);
					StreamWriter writer = new StreamWriter(memoryStream, new UTF8Encoding(encoderShouldEmitUTF8Identifier: false));
					discoveryDocument.Write(writer);
					memoryStream.Position = 0L;
					byte[] array2 = new byte[(int)memoryStream.Length];
					int count = memoryStream.Read(array2, 0, array2.Length);
					context.Response.ContentType = ContentType.Compose("text/xml", Encoding.UTF8);
					context.Response.OutputStream.Write(array2, 0, count);
				}
				else
				{
					context.Response.ContentType = "text/xml";
					context.Response.WriteFile(physicalPath);
				}
				if (Tracing.On)
				{
					Tracing.Exit("IHttpHandler.ProcessRequest", caller);
				}
				return;
			}
			if (Tracing.On)
			{
				Tracing.Exit("IHttpHandler.ProcessRequest", caller);
			}
			throw new HttpException(404, Res.GetString("WebPathNotFound", context.Request.Path));
		}

		private static string GetDirPartOfPath(string str)
		{
			int num = str.LastIndexOf('/');
			if (num <= 0)
			{
				return "";
			}
			return str.Substring(0, num);
		}

		private static string GetFilePartOfPath(string str)
		{
			int num = str.LastIndexOf('/');
			if (num < 0)
			{
				return str;
			}
			if (num == str.Length - 1)
			{
				return "";
			}
			return str.Substring(num + 1);
		}
	}
	internal abstract class DynamicDiscoSearcher
	{
		protected string origUrl;

		protected string[] excludedUrls;

		protected string fileToSkipFirst;

		protected ArrayList filesFound;

		protected DiscoverySearchPattern[] primarySearchPatterns;

		protected DiscoverySearchPattern[] secondarySearchPatterns;

		protected DiscoveryDocument discoDoc = new DiscoveryDocument();

		protected Hashtable excludedUrlsTable;

		protected int subDirLevel;

		internal DiscoveryDocument DiscoveryDocument => discoDoc;

		internal DiscoverySearchPattern[] PrimarySearchPattern
		{
			get
			{
				if (primarySearchPatterns == null)
				{
					primarySearchPatterns = new DiscoverySearchPattern[1]
					{
						new DiscoveryDocumentSearchPattern()
					};
				}
				return primarySearchPatterns;
			}
		}

		internal DiscoverySearchPattern[] SecondarySearchPattern
		{
			get
			{
				if (secondarySearchPatterns == null)
				{
					secondarySearchPatterns = new DiscoverySearchPattern[2]
					{
						new ContractSearchPattern(),
						new DiscoveryDocumentLinksPattern()
					};
				}
				return secondarySearchPatterns;
			}
		}

		protected abstract bool IsVirtualSearch { get; }

		internal DynamicDiscoSearcher(string[] excludeUrlsList)
		{
			excludedUrls = excludeUrlsList;
			filesFound = new ArrayList();
		}

		internal virtual void SearchInit(string fileToSkipAtBegin)
		{
			subDirLevel = 0;
			fileToSkipFirst = fileToSkipAtBegin;
		}

		protected bool IsExcluded(string url)
		{
			if (excludedUrlsTable == null)
			{
				excludedUrlsTable = new Hashtable();
				string[] array = excludedUrls;
				foreach (string pathRelativ in array)
				{
					excludedUrlsTable.Add(MakeAbsExcludedPath(pathRelativ).ToLower(CultureInfo.InvariantCulture), null);
				}
			}
			return excludedUrlsTable.Contains(url.ToLower(CultureInfo.InvariantCulture));
		}

		protected void ScanDirectory(string directory)
		{
			_ = System.ComponentModel.CompModSwitches.DynamicDiscoverySearcher.TraceVerbose;
			if (!IsExcluded(directory) && !ScanDirByPattern(directory, IsPrimary: true, PrimarySearchPattern))
			{
				if (!IsVirtualSearch)
				{
					ScanDirByPattern(directory, IsPrimary: false, SecondarySearchPattern);
				}
				else if (subDirLevel != 0)
				{
					DiscoverySearchPattern[] patterns = new DiscoverySearchPattern[1]
					{
						new DiscoveryDocumentLinksPattern()
					};
					ScanDirByPattern(directory, IsPrimary: false, patterns);
				}
				if (!IsVirtualSearch || subDirLevel <= 0)
				{
					subDirLevel++;
					fileToSkipFirst = "";
					SearchSubDirectories(directory);
					subDirLevel--;
				}
			}
		}

		protected bool ScanDirByPattern(string dir, bool IsPrimary, DiscoverySearchPattern[] patterns)
		{
			DirectoryInfo physicalDir = GetPhysicalDir(dir);
			if (physicalDir == null)
			{
				return false;
			}
			_ = System.ComponentModel.CompModSwitches.DynamicDiscoverySearcher.TraceVerbose;
			bool result = false;
			for (int i = 0; i < patterns.Length; i++)
			{
				FileInfo[] files = physicalDir.GetFiles(patterns[i].Pattern);
				FileInfo[] array = files;
				foreach (FileInfo fileInfo in array)
				{
					if ((fileInfo.Attributes & FileAttributes.Directory) == 0)
					{
						_ = System.ComponentModel.CompModSwitches.DynamicDiscoverySearcher.TraceVerbose;
						if (string.Compare(fileInfo.Name, fileToSkipFirst, StringComparison.OrdinalIgnoreCase) != 0)
						{
							string text = MakeResultPath(dir, fileInfo.Name);
							filesFound.Add(text);
							discoDoc.References.Add(patterns[i].GetDiscoveryReference(text));
							result = true;
						}
					}
				}
			}
			if (IsPrimary)
			{
				return result;
			}
			return false;
		}

		internal abstract void Search(string fileToSkipAtBegin);

		protected abstract DirectoryInfo GetPhysicalDir(string dir);

		protected abstract void SearchSubDirectories(string directory);

		protected abstract string MakeResultPath(string dirName, string fileName);

		protected abstract string MakeAbsExcludedPath(string pathRelativ);
	}
	[XmlRoot("dynamicDiscovery", Namespace = "urn:schemas-dynamicdiscovery:disco.2000-03-17")]
	public sealed class DynamicDiscoveryDocument
	{
		public const string Namespace = "urn:schemas-dynamicdiscovery:disco.2000-03-17";

		private ExcludePathInfo[] excludePaths = new ExcludePathInfo[0];

		[XmlElement("exclude", typeof(ExcludePathInfo))]
		public ExcludePathInfo[] ExcludePaths
		{
			get
			{
				return excludePaths;
			}
			set
			{
				if (value == null)
				{
					value = new ExcludePathInfo[0];
				}
				excludePaths = value;
			}
		}

		public void Write(Stream stream)
		{
			XmlSerializer xmlSerializer = new XmlSerializer(typeof(DynamicDiscoveryDocument));
			xmlSerializer.Serialize(new StreamWriter(stream, new UTF8Encoding(encoderShouldEmitUTF8Identifier: false)), this);
		}

		public static DynamicDiscoveryDocument Load(Stream stream)
		{
			XmlSerializer xmlSerializer = new XmlSerializer(typeof(DynamicDiscoveryDocument));
			return (DynamicDiscoveryDocument)xmlSerializer.Deserialize(stream);
		}
	}
	internal class DynamicPhysicalDiscoSearcher : DynamicDiscoSearcher
	{
		private string startDir;

		protected override bool IsVirtualSearch => false;

		internal DynamicPhysicalDiscoSearcher(string searchDir, string[] excludedUrls, string startUrl)
			: base(excludedUrls)
		{
			startDir = searchDir;
			origUrl = startUrl;
		}

		internal override void Search(string fileToSkipAtBegin)
		{
			SearchInit(fileToSkipAtBegin);
			ScanDirectory(startDir);
		}

		protected override void SearchSubDirectories(string localDir)
		{
			DirectoryInfo directoryInfo = new DirectoryInfo(localDir);
			if (!directoryInfo.Exists)
			{
				return;
			}
			DirectoryInfo[] directories = directoryInfo.GetDirectories();
			DirectoryInfo[] array = directories;
			foreach (DirectoryInfo directoryInfo2 in array)
			{
				if (!(directoryInfo2.Name == ".") && !(directoryInfo2.Name == ".."))
				{
					ScanDirectory(localDir + '\\' + directoryInfo2.Name);
				}
			}
		}

		protected override DirectoryInfo GetPhysicalDir(string dir)
		{
			if (!Directory.Exists(dir))
			{
				return null;
			}
			DirectoryInfo directoryInfo = new DirectoryInfo(dir);
			if (!directoryInfo.Exists)
			{
				return null;
			}
			if ((directoryInfo.Attributes & (FileAttributes.Hidden | FileAttributes.System | FileAttributes.Temporary)) != 0)
			{
				return null;
			}
			return directoryInfo;
		}

		protected override string MakeResultPath(string dirName, string fileName)
		{
			return origUrl + dirName.Substring(startDir.Length, dirName.Length - startDir.Length).Replace('\\', '/') + '/' + fileName;
		}

		protected override string MakeAbsExcludedPath(string pathRelativ)
		{
			return startDir + '\\' + pathRelativ.Replace('/', '\\');
		}
	}
	internal class DynamicVirtualDiscoSearcher : DynamicDiscoSearcher
	{
		private class AppSettings
		{
			internal readonly bool AccessRead;

			internal readonly string[] Bindings;

			internal readonly string VPath;

			internal AppSettings(DirectoryEntry entry)
			{
				string schemaClassName = entry.SchemaClassName;
				AccessRead = true;
				switch (schemaClassName)
				{
				case "IIsWebVirtualDir":
				case "IIsWebDirectory":
					if (!(bool)entry.Properties["AccessRead"][0])
					{
						AccessRead = false;
					}
					else if (schemaClassName == "IIsWebVirtualDir")
					{
						VPath = (string)entry.Properties["Path"][0];
					}
					break;
				case "IIsWebServer":
				{
					Bindings = new string[entry.Properties["ServerBindings"].Count];
					for (int i = 0; i < Bindings.Length; i++)
					{
						Bindings[i] = (string)entry.Properties["ServerBindings"][i];
					}
					break;
				}
				default:
					AccessRead = false;
					break;
				}
			}
		}

		private string rootPathAsdi;

		private string entryPathPrefix;

		private string startDir;

		private Hashtable webApps = new Hashtable();

		private Hashtable Adsi = new Hashtable();

		protected override bool IsVirtualSearch => true;

		internal DynamicVirtualDiscoSearcher(string startDir, string[] excludedUrls, string rootUrl)
			: base(excludedUrls)
		{
			origUrl = rootUrl;
			entryPathPrefix = GetWebServerForUrl(rootUrl) + "/ROOT";
			this.startDir = startDir;
			string text = new Uri(rootUrl).LocalPath;
			if (text.Equals("/"))
			{
				text = "";
			}
			rootPathAsdi = entryPathPrefix + text;
		}

		internal override void Search(string fileToSkipAtBegin)
		{
			SearchInit(fileToSkipAtBegin);
			ScanDirectory(rootPathAsdi);
			CleanupCache();
		}

		protected override void SearchSubDirectories(string nameAdsiDir)
		{
			_ = System.ComponentModel.CompModSwitches.DynamicDiscoverySearcher.TraceVerbose;
			DirectoryEntry directoryEntry = (DirectoryEntry)Adsi[nameAdsiDir];
			if (directoryEntry == null)
			{
				if (!DirectoryEntry.Exists(nameAdsiDir))
				{
					return;
				}
				directoryEntry = new DirectoryEntry(nameAdsiDir);
				Adsi[nameAdsiDir] = directoryEntry;
			}
			foreach (DirectoryEntry child in directoryEntry.Children)
			{
				DirectoryEntry directoryEntry3 = (DirectoryEntry)Adsi[child.Path];
				if (directoryEntry3 == null)
				{
					directoryEntry3 = child;
					Adsi[child.Path] = child;
				}
				else
				{
					child.Dispose();
				}
				AppSettings appSettings = GetAppSettings(directoryEntry3);
				if (appSettings != null)
				{
					ScanDirectory(directoryEntry3.Path);
				}
			}
		}

		protected override DirectoryInfo GetPhysicalDir(string dir)
		{
			DirectoryEntry directoryEntry = (DirectoryEntry)Adsi[dir];
			if (directoryEntry == null)
			{
				if (!DirectoryEntry.Exists(dir))
				{
					return null;
				}
				directoryEntry = new DirectoryEntry(dir);
				Adsi[dir] = directoryEntry;
			}
			try
			{
				DirectoryInfo directoryInfo = null;
				AppSettings appSettings = GetAppSettings(directoryEntry);
				if (appSettings == null)
				{
					return null;
				}
				if (appSettings.VPath == null)
				{
					if (!dir.StartsWith(rootPathAsdi, StringComparison.Ordinal))
					{
						throw new ArgumentException(Res.GetString("WebVirtualDisoRoot", dir, rootPathAsdi), "dir");
					}
					string text = dir.Substring(rootPathAsdi.Length);
					text = text.Replace('/', '\\');
					directoryInfo = new DirectoryInfo(startDir + text);
				}
				else
				{
					directoryInfo = new DirectoryInfo(appSettings.VPath);
				}
				if (directoryInfo.Exists)
				{
					return directoryInfo;
				}
			}
			catch (Exception ex)
			{
				if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
				{
					throw;
				}
				_ = System.ComponentModel.CompModSwitches.DynamicDiscoverySearcher.TraceVerbose;
				if (Tracing.On)
				{
					Tracing.ExceptionCatch(TraceEventType.Warning, this, "GetPhysicalDir", ex);
				}
				return null;
			}
			catch
			{
				_ = System.ComponentModel.CompModSwitches.DynamicDiscoverySearcher.TraceVerbose;
				return null;
			}
			return null;
		}

		private string GetWebServerForUrl(string url)
		{
			Uri uri = new Uri(url);
			DirectoryEntry directoryEntry = new DirectoryEntry("IIS://" + uri.Host + "/W3SVC");
			foreach (DirectoryEntry child in directoryEntry.Children)
			{
				DirectoryEntry directoryEntry3 = (DirectoryEntry)Adsi[child.Path];
				if (directoryEntry3 == null)
				{
					directoryEntry3 = child;
					Adsi[child.Path] = child;
				}
				else
				{
					child.Dispose();
				}
				AppSettings appSettings = GetAppSettings(directoryEntry3);
				if (appSettings == null || appSettings.Bindings == null)
				{
					continue;
				}
				string[] bindings = appSettings.Bindings;
				foreach (string text in bindings)
				{
					_ = System.ComponentModel.CompModSwitches.DynamicDiscoverySearcher.TraceVerbose;
					string[] array = text.Split(':');
					string text2 = array[0];
					string value = array[1];
					string text3 = array[2];
					if (Convert.ToInt32(value, CultureInfo.InvariantCulture) != uri.Port)
					{
						continue;
					}
					if (uri.HostNameType == UriHostNameType.Dns)
					{
						if (text3.Length == 0 || string.Compare(text3, uri.Host, StringComparison.OrdinalIgnoreCase) == 0)
						{
							return directoryEntry3.Path;
						}
					}
					else if (text2.Length == 0 || string.Compare(text2, uri.Host, StringComparison.OrdinalIgnoreCase) == 0)
					{
						return directoryEntry3.Path;
					}
				}
			}
			return null;
		}

		protected override string MakeResultPath(string dirName, string fileName)
		{
			return origUrl + dirName.Substring(rootPathAsdi.Length, dirName.Length - rootPathAsdi.Length) + '/' + fileName;
		}

		protected override string MakeAbsExcludedPath(string pathRelativ)
		{
			return rootPathAsdi + '/' + pathRelativ.Replace('\\', '/');
		}

		private AppSettings GetAppSettings(DirectoryEntry entry)
		{
			string path = entry.Path;
			AppSettings appSettings = null;
			object obj = webApps[path];
			if (obj == null)
			{
				lock (webApps)
				{
					obj = webApps[path];
					if (obj == null)
					{
						appSettings = new AppSettings(entry);
						webApps[path] = appSettings;
					}
				}
			}
			else
			{
				appSettings = (AppSettings)obj;
			}
			if (!appSettings.AccessRead)
			{
				return null;
			}
			return appSettings;
		}

		private void CleanupCache()
		{
			foreach (DictionaryEntry item in Adsi)
			{
				((DirectoryEntry)item.Value).Dispose();
			}
			rootPathAsdi = null;
			entryPathPrefix = null;
			startDir = null;
			Adsi = null;
			webApps = null;
		}
	}
	public sealed class ExcludePathInfo
	{
		private string path;

		[XmlAttribute("path")]
		public string Path
		{
			get
			{
				return path;
			}
			set
			{
				path = value;
			}
		}

		public ExcludePathInfo()
		{
		}

		public ExcludePathInfo(string path)
		{
			this.path = path;
		}
	}
	internal class InvalidContentTypeException : Exception
	{
		private string contentType;

		internal string ContentType => contentType;

		internal InvalidContentTypeException(string message, string contentType)
			: base(message)
		{
			this.contentType = contentType;
		}
	}
	internal class InvalidDocumentContentsException : Exception
	{
		internal InvalidDocumentContentsException(string message, Exception inner)
			: base(message, inner)
		{
		}
	}
	internal class LinkGrep
	{
		private static readonly Regex tagRegex = new Regex("\\G<(?<prefix>[\\w:.-]+(?=:)|):?(?<tagname>[\\w.-]+)(?:\\s+(?<attrprefix>[\\w:.-]+(?=:)|):?(?<attrname>[\\w.-]+)\\s*=\\s*(?:\"(?<attrval>[^\"]*)\"|'(?<attrval>[^']*)'|(?<attrval>[a-zA-Z0-9\\-._:]+)))*\\s*(?<empty>/)?>");

		private static readonly Regex doctypeDirectiveRegex = new Regex("\\G<!doctype\\b(([\\s\\w]+)|(\".*\"))*>", RegexOptions.IgnoreCase | RegexOptions.Multiline | RegexOptions.IgnorePatternWhitespace);

		private static readonly Regex endtagRegex = new Regex("\\G</(?<prefix>[\\w:-]+(?=:)|):?(?<tagname>[\\w-]+)\\s*>");

		private static readonly Regex commentRegex = new Regex("\\G<!--(?>[^-]*-)+?->");

		private static readonly Regex whitespaceRegex = new Regex("\\G\\s+(?=<|\\Z)");

		private static readonly Regex textRegex = new Regex("\\G[^<]+");

		private LinkGrep()
		{
		}

		private static string ReadEntireStream(TextReader input)
		{
			char[] array = new char[4096];
			int num = 0;
			while (true)
			{
				int num2 = input.Read(array, num, array.Length - num);
				if (num2 == 0)
				{
					break;
				}
				num += num2;
				if (num == array.Length)
				{
					char[] array2 = new char[array.Length * 2];
					Array.Copy(array, 0, array2, 0, array.Length);
					array = array2;
				}
			}
			return new string(array, 0, num);
		}

		internal static string SearchForLink(Stream stream)
		{
			string text = null;
			text = ReadEntireStream(new StreamReader(stream));
			int num = 0;
			Match match;
			if ((match = doctypeDirectiveRegex.Match(text, num)).Success)
			{
				num += match.Length;
			}
			bool flag;
			do
			{
				flag = false;
				if ((match = whitespaceRegex.Match(text, num)).Success)
				{
					flag = true;
				}
				else if ((match = textRegex.Match(text, num)).Success)
				{
					flag = true;
				}
				num += match.Length;
				if (num == text.Length)
				{
					break;
				}
				if ((match = tagRegex.Match(text, num)).Success)
				{
					flag = true;
					string value = match.Groups["tagname"].Value;
					if (string.Compare(value, "link", StringComparison.OrdinalIgnoreCase) == 0)
					{
						CaptureCollection captures = match.Groups["attrname"].Captures;
						CaptureCollection captures2 = match.Groups["attrval"].Captures;
						int count = captures.Count;
						bool flag2 = false;
						bool flag3 = false;
						string text2 = null;
						for (int i = 0; i < count; i++)
						{
							string strA = captures[i].ToString();
							string text3 = captures2[i].ToString();
							if (string.Compare(strA, "type", StringComparison.OrdinalIgnoreCase) == 0 && ContentType.MatchesBase(text3, "text/xml"))
							{
								flag2 = true;
							}
							else if (string.Compare(strA, "rel", StringComparison.OrdinalIgnoreCase) == 0 && string.Compare(text3, "alternate", StringComparison.OrdinalIgnoreCase) == 0)
							{
								flag3 = true;
							}
							else if (string.Compare(strA, "href", StringComparison.OrdinalIgnoreCase) == 0)
							{
								text2 = text3;
							}
							if (flag2 && flag3 && text2 != null)
							{
								return text2;
							}
						}
					}
					else if (value == "body")
					{
						break;
					}
				}
				else if ((match = endtagRegex.Match(text, num)).Success)
				{
					flag = true;
				}
				else if ((match = commentRegex.Match(text, num)).Success)
				{
					flag = true;
				}
				num += match.Length;
			}
			while (num != text.Length && flag);
			return null;
		}
	}
	[XmlRoot("schemaRef", Namespace = "http://schemas.xmlsoap.org/disco/schema/")]
	public sealed class SchemaReference : DiscoveryReference
	{
		public const string Namespace = "http://schemas.xmlsoap.org/disco/schema/";

		private string reference;

		private string targetNamespace;

		[XmlAttribute("ref")]
		public string Ref
		{
			get
			{
				if (reference != null)
				{
					return reference;
				}
				return "";
			}
			set
			{
				reference = value;
			}
		}

		[DefaultValue(null)]
		[XmlAttribute("targetNamespace")]
		public string TargetNamespace
		{
			get
			{
				return targetNamespace;
			}
			set
			{
				targetNamespace = value;
			}
		}

		[XmlIgnore]
		public override string Url
		{
			get
			{
				return Ref;
			}
			set
			{
				Ref = value;
			}
		}

		[XmlIgnore]
		public override string DefaultFilename
		{
			get
			{
				string text = DiscoveryReference.MakeValidFilename(Schema.Id);
				if (text == null || text.Length == 0)
				{
					text = DiscoveryReference.FilenameFromUrl(Url);
				}
				return Path.ChangeExtension(text, ".xsd");
			}
		}

		[XmlIgnore]
		public XmlSchema Schema
		{
			get
			{
				if (base.ClientProtocol == null)
				{
					throw new InvalidOperationException(Res.GetString("WebMissingClientProtocol"));
				}
				object obj = base.ClientProtocol.InlinedSchemas[Url];
				if (obj == null)
				{
					obj = base.ClientProtocol.Documents[Url];
				}
				if (obj == null)
				{
					Resolve();
					obj = base.ClientProtocol.Documents[Url];
				}
				if (!(obj is XmlSchema result))
				{
					throw new InvalidOperationException(Res.GetString("WebInvalidDocType", typeof(XmlSchema).FullName, (obj == null) ? string.Empty : obj.GetType().FullName, Url));
				}
				return result;
			}
		}

		public SchemaReference()
		{
		}

		public SchemaReference(string url)
		{
			Ref = url;
		}

		internal XmlSchema GetSchema()
		{
			try
			{
				return Schema;
			}
			catch (Exception ex)
			{
				if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
				{
					throw;
				}
				base.ClientProtocol.Errors[Url] = ex;
				if (Tracing.On)
				{
					Tracing.ExceptionCatch(TraceEventType.Warning, this, "GetSchema", ex);
				}
			}
			catch
			{
				base.ClientProtocol.Errors[Url] = new Exception(Res.GetString("NonClsCompliantException"));
			}
			return null;
		}

		internal override void LoadExternals(Hashtable loadedExternals)
		{
			LoadExternals(GetSchema(), Url, base.ClientProtocol, loadedExternals);
		}

		internal static void LoadExternals(XmlSchema schema, string url, DiscoveryClientProtocol client, Hashtable loadedExternals)
		{
			if (schema == null)
			{
				return;
			}
			foreach (XmlSchemaExternal include in schema.Includes)
			{
				if (include.SchemaLocation == null || include.SchemaLocation.Length == 0 || include.Schema != null || (!(include is XmlSchemaInclude) && !(include is XmlSchemaRedefine)))
				{
					continue;
				}
				string text = DiscoveryReference.UriToString(url, include.SchemaLocation);
				if (client.References[text] is SchemaReference)
				{
					SchemaReference schemaReference = (SchemaReference)client.References[text];
					include.Schema = schemaReference.GetSchema();
					if (include.Schema != null)
					{
						loadedExternals[text] = include.Schema;
					}
					schemaReference.LoadExternals(loadedExternals);
				}
			}
		}

		public override void WriteDocument(object document, Stream stream)
		{
			((XmlSchema)document).Write(new StreamWriter(stream, new UTF8Encoding(encoderShouldEmitUTF8Identifier: false)));
		}

		public override object ReadDocument(Stream stream)
		{
			XmlTextReader xmlTextReader = new XmlTextReader(Url, stream);
			xmlTextReader.XmlResolver = null;
			return XmlSchema.Read(xmlTextReader, null);
		}

		protected internal override void Resolve(string contentType, Stream stream)
		{
			if (ContentType.IsHtml(contentType))
			{
				base.ClientProtocol.Errors[Url] = new InvalidContentTypeException(Res.GetString("WebInvalidContentType", contentType), contentType);
			}
			XmlSchema xmlSchema = base.ClientProtocol.Documents[Url] as XmlSchema;
			if (xmlSchema == null)
			{
				if (base.ClientProtocol.Errors[Url] != null)
				{
					throw base.ClientProtocol.Errors[Url];
				}
				xmlSchema = (XmlSchema)ReadDocument(stream);
				base.ClientProtocol.Documents[Url] = xmlSchema;
			}
			if (base.ClientProtocol.References[Url] != this)
			{
				base.ClientProtocol.References[Url] = this;
			}
			foreach (XmlSchemaExternal include in xmlSchema.Includes)
			{
				string text = null;
				try
				{
					if (include.SchemaLocation != null && include.SchemaLocation.Length > 0)
					{
						text = DiscoveryReference.UriToString(Url, include.SchemaLocation);
						SchemaReference schemaReference = new SchemaReference(text);
						schemaReference.ClientProtocol = base.ClientProtocol;
						base.ClientProtocol.References[text] = schemaReference;
						schemaReference.Resolve();
					}
				}
				catch (Exception ex)
				{
					if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
					{
						throw;
					}
					throw new InvalidDocumentContentsException(Res.GetString("TheSchemaDocumentContainsLinksThatCouldNotBeResolved", text), ex);
				}
				catch
				{
					throw new InvalidDocumentContentsException(Res.GetString("TheSchemaDocumentContainsLinksThatCouldNotBeResolved", text), null);
				}
			}
		}
	}
	[XmlRoot("soap", Namespace = "http://schemas.xmlsoap.org/disco/soap/")]
	public sealed class SoapBinding
	{
		public const string Namespace = "http://schemas.xmlsoap.org/disco/soap/";

		private XmlQualifiedName binding;

		private string address = "";

		[XmlAttribute("address")]
		public string Address
		{
			get
			{
				return address;
			}
			set
			{
				if (value == null)
				{
					address = "";
				}
				else
				{
					address = value;
				}
			}
		}

		[XmlAttribute("binding")]
		public XmlQualifiedName Binding
		{
			get
			{
				return binding;
			}
			set
			{
				binding = value;
			}
		}
	}
	public sealed class XmlSchemaSearchPattern : DiscoverySearchPattern
	{
		public override string Pattern => "*.xsd";

		public override DiscoveryReference GetDiscoveryReference(string filename)
		{
			return new SchemaReference(filename);
		}
	}
}
namespace System.Web.Services.Description
{
	public abstract class ServiceDescriptionFormatExtension
	{
		private object parent;

		private bool required;

		private bool handled;

		public object Parent => parent;

		[DefaultValue(false)]
		[XmlAttribute("required", Namespace = "http://schemas.xmlsoap.org/wsdl/")]
		public bool Required
		{
			get
			{
				return required;
			}
			set
			{
				required = value;
			}
		}

		[XmlIgnore]
		public bool Handled
		{
			get
			{
				return handled;
			}
			set
			{
				handled = value;
			}
		}

		internal void SetParent(object parent)
		{
			this.parent = parent;
		}
	}
	[XmlFormatExtension("address", "http://schemas.xmlsoap.org/wsdl/http/", typeof(Port))]
	public sealed class HttpAddressBinding : ServiceDescriptionFormatExtension
	{
		private string location;

		[XmlAttribute("location")]
		public string Location
		{
			get
			{
				if (location != null)
				{
					return location;
				}
				return string.Empty;
			}
			set
			{
				location = value;
			}
		}
	}
	[XmlFormatExtensionPrefix("http", "http://schemas.xmlsoap.org/wsdl/http/")]
	[XmlFormatExtension("binding", "http://schemas.xmlsoap.org/wsdl/http/", typeof(Binding))]
	public sealed class HttpBinding : ServiceDescriptionFormatExtension
	{
		public const string Namespace = "http://schemas.xmlsoap.org/wsdl/http/";

		private string verb;

		[XmlAttribute("verb")]
		public string Verb
		{
			get
			{
				return verb;
			}
			set
			{
				verb = value;
			}
		}
	}
	[XmlFormatExtension("operation", "http://schemas.xmlsoap.org/wsdl/http/", typeof(OperationBinding))]
	public sealed class HttpOperationBinding : ServiceDescriptionFormatExtension
	{
		private string location;

		[XmlAttribute("location")]
		public string Location
		{
			get
			{
				if (location != null)
				{
					return location;
				}
				return string.Empty;
			}
			set
			{
				location = value;
			}
		}
	}
	[XmlFormatExtension("urlEncoded", "http://schemas.xmlsoap.org/wsdl/http/", typeof(InputBinding))]
	public sealed class HttpUrlEncodedBinding : ServiceDescriptionFormatExtension
	{
	}
	[XmlFormatExtension("urlReplacement", "http://schemas.xmlsoap.org/wsdl/http/", typeof(InputBinding))]
	public sealed class HttpUrlReplacementBinding : ServiceDescriptionFormatExtension
	{
	}
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	public abstract class ProtocolImporter
	{
		private ServiceDescriptionImporter importer;

		private CodeNamespace codeNamespace;

		private CodeIdentifiers methodNames;

		private CodeTypeDeclaration codeClass;

		private CodeTypeDeclarationCollection classes;

		private ServiceDescriptionImportWarnings warnings;

		private Port port;

		private PortType portType;

		private Binding binding;

		private Operation operation;

		private OperationBinding operationBinding;

		private bool encodedBinding;

		private ImportContext importContext;

		private Hashtable exportContext;

		private Service service;

		private Message inputMessage;

		private Message outputMessage;

		private string className;

		private int bindingCount;

		private bool anyPorts;

		public ServiceDescriptionCollection ServiceDescriptions => importer.ServiceDescriptions;

		public XmlSchemas Schemas => importer.AllSchemas;

		public XmlSchemas AbstractSchemas => importer.AbstractSchemas;

		public XmlSchemas ConcreteSchemas => importer.ConcreteSchemas;

		public CodeNamespace CodeNamespace => codeNamespace;

		public CodeTypeDeclaration CodeTypeDeclaration => codeClass;

		internal CodeTypeDeclarationCollection ExtraCodeClasses
		{
			get
			{
				if (classes == null)
				{
					classes = new CodeTypeDeclarationCollection();
				}
				return classes;
			}
		}

		public ServiceDescriptionImportStyle Style => importer.Style;

		public ServiceDescriptionImportWarnings Warnings
		{
			get
			{
				return warnings;
			}
			set
			{
				warnings = value;
			}
		}

		public CodeIdentifiers ClassNames => importContext.TypeIdentifiers;

		public string MethodName => CodeIdentifier.MakeValid(XmlConvert.DecodeName(Operation.Name));

		public string ClassName => className;

		public Port Port => port;

		public PortType PortType => portType;

		public Binding Binding => binding;

		public Service Service => service;

		internal ServiceDescriptionImporter ServiceImporter => importer;

		public Operation Operation => operation;

		public OperationBinding OperationBinding => operationBinding;

		public Message InputMessage => inputMessage;

		public Message OutputMessage => outputMessage;

		internal ImportContext ImportContext => importContext;

		internal bool IsEncodedBinding
		{
			get
			{
				return encodedBinding;
			}
			set
			{
				encodedBinding = value;
			}
		}

		internal Hashtable ExportContext
		{
			get
			{
				if (exportContext == null)
				{
					exportContext = new Hashtable();
				}
				return exportContext;
			}
		}

		internal CodeIdentifiers MethodNames
		{
			get
			{
				if (methodNames == null)
				{
					methodNames = new CodeIdentifiers();
				}
				return methodNames;
			}
		}

		public abstract string ProtocolName { get; }

		internal void Initialize(ServiceDescriptionImporter importer)
		{
			this.importer = importer;
		}

		internal bool GenerateCode(CodeNamespace codeNamespace, ImportContext importContext, Hashtable exportContext)
		{
			bindingCount = 0;
			anyPorts = false;
			this.codeNamespace = codeNamespace;
			Hashtable hashtable = new Hashtable();
			Hashtable hashtable2 = new Hashtable();
			foreach (ServiceDescription serviceDescription4 in ServiceDescriptions)
			{
				foreach (Service service3 in serviceDescription4.Services)
				{
					foreach (Port port3 in service3.Ports)
					{
						Binding binding = ServiceDescriptions.GetBinding(port3.Binding);
						if (!hashtable.Contains(binding))
						{
							PortType portType = ServiceDescriptions.GetPortType(binding.Type);
							MoveToBinding(service3, port3, binding, portType);
							if (IsBindingSupported())
							{
								bindingCount++;
								anyPorts = true;
								hashtable.Add(binding, binding);
							}
							else if (binding != null)
							{
								hashtable2[binding] = binding;
							}
						}
					}
				}
			}
			if (bindingCount == 0)
			{
				foreach (ServiceDescription serviceDescription5 in ServiceDescriptions)
				{
					foreach (Binding binding5 in serviceDescription5.Bindings)
					{
						if (!hashtable2.Contains(binding5))
						{
							PortType portType2 = ServiceDescriptions.GetPortType(binding5.Type);
							MoveToBinding(binding5, portType2);
							if (IsBindingSupported())
							{
								bindingCount++;
							}
						}
					}
				}
			}
			if (bindingCount == 0)
			{
				return codeNamespace.Comments.Count > 0;
			}
			this.importContext = importContext;
			this.exportContext = exportContext;
			BeginNamespace();
			hashtable.Clear();
			foreach (ServiceDescription serviceDescription6 in ServiceDescriptions)
			{
				if (anyPorts)
				{
					foreach (Service service4 in serviceDescription6.Services)
					{
						foreach (Port port4 in service4.Ports)
						{
							Binding binding3 = ServiceDescriptions.GetBinding(port4.Binding);
							PortType portType3 = ServiceDescriptions.GetPortType(binding3.Type);
							MoveToBinding(service4, port4, binding3, portType3);
							if (IsBindingSupported() && !hashtable.Contains(binding3))
							{
								GenerateClassForBinding();
								hashtable.Add(binding3, binding3);
							}
						}
					}
					continue;
				}
				foreach (Binding binding6 in serviceDescription6.Bindings)
				{
					PortType portType4 = ServiceDescriptions.GetPortType(binding6.Type);
					MoveToBinding(binding6, portType4);
					if (IsBindingSupported())
					{
						GenerateClassForBinding();
					}
				}
			}
			EndNamespace();
			return true;
		}

		private void MoveToBinding(Binding binding, PortType portType)
		{
			MoveToBinding(null, null, binding, portType);
		}

		private void MoveToBinding(Service service, Port port, Binding binding, PortType portType)
		{
			this.service = service;
			this.port = port;
			this.portType = portType;
			this.binding = binding;
			encodedBinding = false;
		}

		private void MoveToOperation(Operation operation)
		{
			this.operation = operation;
			this.operationBinding = null;
			foreach (OperationBinding operation2 in binding.Operations)
			{
				if (operation.IsBoundBy(operation2))
				{
					if (operationBinding != null)
					{
						throw OperationSyntaxException(Res.GetString("DuplicateInputOutputNames0"));
					}
					operationBinding = operation2;
				}
			}
			if (operationBinding == null)
			{
				throw OperationSyntaxException(Res.GetString("MissingBinding0"));
			}
			if (operation.Messages.Input != null && operationBinding.Input == null)
			{
				throw OperationSyntaxException(Res.GetString("MissingInputBinding0"));
			}
			if (operation.Messages.Output != null && operationBinding.Output == null)
			{
				throw OperationSyntaxException(Res.GetString("MissingOutputBinding0"));
			}
			inputMessage = ((operation.Messages.Input == null) ? null : ServiceDescriptions.GetMessage(operation.Messages.Input.Message));
			outputMessage = ((operation.Messages.Output == null) ? null : ServiceDescriptions.GetMessage(operation.Messages.Output.Message));
		}

		private void GenerateClassForBinding()
		{
			try
			{
				if (bindingCount == 1 && service != null && Style != ServiceDescriptionImportStyle.ServerInterface)
				{
					className = XmlConvert.DecodeName(service.Name);
				}
				else
				{
					className = binding.Name;
					if (Style == ServiceDescriptionImportStyle.ServerInterface)
					{
						className = "I" + CodeIdentifier.MakePascal(className);
					}
				}
				className = XmlConvert.DecodeName(className);
				className = ClassNames.AddUnique(CodeIdentifier.MakeValid(className), null);
				codeClass = BeginClass();
				int num = 0;
				for (int i = 0; i < portType.Operations.Count; i++)
				{
					MoveToOperation(portType.Operations[i]);
					if (!IsOperationFlowSupported(operation.Messages.Flow))
					{
						switch (operation.Messages.Flow)
						{
						case OperationFlow.SolicitResponse:
							UnsupportedOperationWarning(Res.GetString("SolicitResponseIsNotSupported0"));
							continue;
						case OperationFlow.RequestResponse:
							UnsupportedOperationWarning(Res.GetString("RequestResponseIsNotSupported0"));
							continue;
						case OperationFlow.OneWay:
							UnsupportedOperationWarning(Res.GetString("OneWayIsNotSupported0"));
							continue;
						case OperationFlow.Notification:
							UnsupportedOperationWarning(Res.GetString("NotificationIsNotSupported0"));
							continue;
						}
					}
					CodeMemberMethod codeMemberMethod;
					try
					{
						codeMemberMethod = GenerateMethod();
					}
					catch (Exception ex)
					{
						if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
						{
							throw;
						}
						throw new InvalidOperationException(Res.GetString("UnableToImportOperation1", operation.Name), ex);
					}
					catch
					{
						throw new InvalidOperationException(Res.GetString("UnableToImportOperation1", operation.Name), null);
					}
					if (codeMemberMethod != null)
					{
						AddExtensionWarningComments(codeClass.Comments, operationBinding.Extensions);
						if (operationBinding.Input != null)
						{
							AddExtensionWarningComments(codeClass.Comments, operationBinding.Input.Extensions);
						}
						if (operationBinding.Output != null)
						{
							AddExtensionWarningComments(codeClass.Comments, operationBinding.Output.Extensions);
						}
						num++;
					}
				}
				if ((ServiceImporter.CodeGenerationOptions & CodeGenerationOptions.GenerateNewAsync) != 0 && ServiceImporter.CodeGenerator.Supports(GeneratorSupport.DeclareEvents) && ServiceImporter.CodeGenerator.Supports(GeneratorSupport.DeclareDelegates) && num > 0 && Style == ServiceDescriptionImportStyle.Client)
				{
					CodeAttributeDeclarationCollection metadata = new CodeAttributeDeclarationCollection();
					string text = "CancelAsync";
					string text2 = MethodNames.AddUnique(text, text);
					CodeMemberMethod codeMemberMethod2 = WebCodeGenerator.AddMethod(CodeTypeDeclaration, text2, new CodeFlags[1], new string[1] { typeof(object).FullName }, new string[1] { "userState" }, typeof(void).FullName, metadata, CodeFlags.IsPublic | ((!(text != text2)) ? CodeFlags.IsNew : ((CodeFlags)0)));
					codeMemberMethod2.Comments.Add(new CodeCommentStatement(Res.GetString("CodeRemarks"), docComment: true));
					CodeMethodInvokeExpression codeMethodInvokeExpression = new CodeMethodInvokeExpression(new CodeBaseReferenceExpression(), text);
					codeMethodInvokeExpression.Parameters.Add(new CodeArgumentReferenceExpression("userState"));
					codeMemberMethod2.Statements.Add(codeMethodInvokeExpression);
				}
				EndClass();
				if (portType.Operations.Count == 0)
				{
					NoMethodsGeneratedWarning();
				}
				AddExtensionWarningComments(codeClass.Comments, binding.Extensions);
				if (port != null)
				{
					AddExtensionWarningComments(codeClass.Comments, port.Extensions);
				}
				codeNamespace.Types.Add(codeClass);
			}
			catch (Exception ex2)
			{
				if (ex2 is ThreadAbortException || ex2 is StackOverflowException || ex2 is OutOfMemoryException)
				{
					throw;
				}
				throw new InvalidOperationException(Res.GetString("UnableToImportBindingFromNamespace2", binding.Name, binding.ServiceDescription.TargetNamespace), ex2);
			}
			catch
			{
				throw new InvalidOperationException(Res.GetString("UnableToImportBindingFromNamespace2", binding.Name, binding.ServiceDescription.TargetNamespace), null);
			}
		}

		public void AddExtensionWarningComments(CodeCommentStatementCollection comments, ServiceDescriptionFormatExtensionCollection extensions)
		{
			foreach (object extension in extensions)
			{
				if (extensions.IsHandled(extension))
				{
					continue;
				}
				string text = null;
				string text2 = null;
				if (extension is XmlElement)
				{
					XmlElement xmlElement = (XmlElement)extension;
					text = xmlElement.LocalName;
					text2 = xmlElement.NamespaceURI;
				}
				else if (extension is ServiceDescriptionFormatExtension)
				{
					XmlFormatExtensionAttribute[] array = (XmlFormatExtensionAttribute[])extension.GetType().GetCustomAttributes(typeof(XmlFormatExtensionAttribute), inherit: false);
					if (array.Length > 0)
					{
						text = array[0].ElementName;
						text2 = array[0].Namespace;
					}
				}
				if (text != null)
				{
					if (extensions.IsRequired(extension))
					{
						warnings |= ServiceDescriptionImportWarnings.RequiredExtensionsIgnored;
						AddWarningComment(comments, Res.GetString("WebServiceDescriptionIgnoredRequired", text, text2));
					}
					else
					{
						warnings |= ServiceDescriptionImportWarnings.OptionalExtensionsIgnored;
						AddWarningComment(comments, Res.GetString("WebServiceDescriptionIgnoredOptional", text, text2));
					}
				}
			}
		}

		public void UnsupportedBindingWarning(string text)
		{
			AddWarningComment((codeClass == null) ? codeNamespace.Comments : codeClass.Comments, Res.GetString("TheBinding0FromNamespace1WasIgnored2", Binding.Name, Binding.ServiceDescription.TargetNamespace, text));
			warnings |= ServiceDescriptionImportWarnings.UnsupportedBindingsIgnored;
		}

		public void UnsupportedOperationWarning(string text)
		{
			AddWarningComment((codeClass == null) ? codeNamespace.Comments : codeClass.Comments, Res.GetString("TheOperation0FromNamespace1WasIgnored2", operation.Name, operation.PortType.ServiceDescription.TargetNamespace, text));
			warnings |= ServiceDescriptionImportWarnings.UnsupportedOperationsIgnored;
		}

		public void UnsupportedOperationBindingWarning(string text)
		{
			AddWarningComment((codeClass == null) ? codeNamespace.Comments : codeClass.Comments, Res.GetString("TheOperationBinding0FromNamespace1WasIgnored", operationBinding.Name, operationBinding.Binding.ServiceDescription.TargetNamespace, text));
			warnings |= ServiceDescriptionImportWarnings.UnsupportedOperationsIgnored;
		}

		private void NoMethodsGeneratedWarning()
		{
			AddWarningComment(codeClass.Comments, Res.GetString("NoMethodsWereFoundInTheWSDLForThisProtocol"));
			warnings |= ServiceDescriptionImportWarnings.NoMethodsGenerated;
		}

		internal static void AddWarningComment(CodeCommentStatementCollection comments, string text)
		{
			comments.Add(new CodeCommentStatement(Res.GetString("CodegenWarningDetails", text)));
		}

		public Exception OperationSyntaxException(string text)
		{
			return new Exception(Res.GetString("TheOperationFromNamespaceHadInvalidSyntax3", operation.Name, operation.PortType.Name, operation.PortType.ServiceDescription.TargetNamespace, text));
		}

		public Exception OperationBindingSyntaxException(string text)
		{
			return new Exception(Res.GetString("TheOperationBindingFromNamespaceHadInvalid3", operationBinding.Name, operationBinding.Binding.ServiceDescription.TargetNamespace, text));
		}

		protected virtual void BeginNamespace()
		{
			MethodNames.Clear();
		}

		protected abstract bool IsBindingSupported();

		protected abstract bool IsOperationFlowSupported(OperationFlow flow);

		protected abstract CodeTypeDeclaration BeginClass();

		protected abstract CodeMemberMethod GenerateMethod();

		protected virtual void EndClass()
		{
		}

		protected virtual void EndNamespace()
		{
			if (classes != null)
			{
				foreach (CodeTypeDeclaration @class in classes)
				{
					codeNamespace.Types.Add(@class);
				}
			}
			CodeGenerator.ValidateIdentifiers(codeNamespace);
		}

		internal static string UniqueName(string baseName, string[] scope)
		{
			CodeIdentifiers codeIdentifiers = new CodeIdentifiers();
			for (int i = 0; i < scope.Length; i++)
			{
				codeIdentifiers.AddUnique(scope[i], scope[i]);
			}
			return codeIdentifiers.AddUnique(baseName, baseName);
		}

		internal static string MethodSignature(string methodName, string returnType, CodeFlags[] parameterFlags, string[] parameterTypes)
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append(returnType);
			stringBuilder.Append(" ");
			stringBuilder.Append(methodName);
			stringBuilder.Append(" (");
			for (int i = 0; i < parameterTypes.Length; i++)
			{
				if ((parameterFlags[i] & CodeFlags.IsByRef) != 0)
				{
					stringBuilder.Append("ref ");
				}
				else if ((parameterFlags[i] & CodeFlags.IsOut) != 0)
				{
					stringBuilder.Append("out ");
				}
				stringBuilder.Append(parameterTypes[i]);
				if (i > 0)
				{
					stringBuilder.Append(",");
				}
			}
			stringBuilder.Append(")");
			return stringBuilder.ToString();
		}
	}
	internal abstract class HttpProtocolImporter : ProtocolImporter
	{
		private MimeImporter[] importers;

		private ArrayList[] importedParameters;

		private ArrayList[] importedReturns;

		private bool hasInputPayload;

		private ArrayList codeClasses = new ArrayList();

		internal abstract Type BaseClass { get; }

		protected HttpProtocolImporter(bool hasInputPayload)
		{
			Type[] mimeImporterTypes = WebServicesSection.Current.MimeImporterTypes;
			importers = new MimeImporter[mimeImporterTypes.Length];
			importedParameters = new ArrayList[mimeImporterTypes.Length];
			importedReturns = new ArrayList[mimeImporterTypes.Length];
			for (int i = 0; i < importers.Length; i++)
			{
				MimeImporter mimeImporter = (MimeImporter)Activator.CreateInstance(mimeImporterTypes[i]);
				mimeImporter.ImportContext = this;
				importedParameters[i] = new ArrayList();
				importedReturns[i] = new ArrayList();
				importers[i] = mimeImporter;
			}
			this.hasInputPayload = hasInputPayload;
		}

		private MimeParameterCollection ImportMimeParameters()
		{
			for (int i = 0; i < importers.Length; i++)
			{
				MimeParameterCollection mimeParameterCollection = importers[i].ImportParameters();
				if (mimeParameterCollection != null)
				{
					importedParameters[i].Add(mimeParameterCollection);
					return mimeParameterCollection;
				}
			}
			return null;
		}

		private MimeReturn ImportMimeReturn()
		{
			if (base.OperationBinding.Output.Extensions.Count == 0)
			{
				MimeReturn mimeReturn = new MimeReturn();
				mimeReturn.TypeName = typeof(void).FullName;
				return mimeReturn;
			}
			for (int i = 0; i < importers.Length; i++)
			{
				MimeReturn mimeReturn = importers[i].ImportReturn();
				if (mimeReturn != null)
				{
					importedReturns[i].Add(mimeReturn);
					return mimeReturn;
				}
			}
			return null;
		}

		private MimeParameterCollection ImportUrlParameters()
		{
			HttpUrlEncodedBinding httpUrlEncodedBinding = (HttpUrlEncodedBinding)base.OperationBinding.Input.Extensions.Find(typeof(HttpUrlEncodedBinding));
			if (httpUrlEncodedBinding == null)
			{
				return new MimeParameterCollection();
			}
			return ImportStringParametersMessage();
		}

		internal MimeParameterCollection ImportStringParametersMessage()
		{
			MimeParameterCollection mimeParameterCollection = new MimeParameterCollection();
			foreach (MessagePart part in base.InputMessage.Parts)
			{
				MimeParameter mimeParameter = ImportUrlParameter(part);
				if (mimeParameter == null)
				{
					return null;
				}
				mimeParameterCollection.Add(mimeParameter);
			}
			return mimeParameterCollection;
		}

		private MimeParameter ImportUrlParameter(MessagePart part)
		{
			MimeParameter mimeParameter = new MimeParameter();
			mimeParameter.Name = CodeIdentifier.MakeValid(XmlConvert.DecodeName(part.Name));
			mimeParameter.TypeName = (IsRepeatingParameter(part) ? typeof(string[]).FullName : typeof(string).FullName);
			return mimeParameter;
		}

		private bool IsRepeatingParameter(MessagePart part)
		{
			XmlSchemaComplexType xmlSchemaComplexType = (XmlSchemaComplexType)base.Schemas.Find(part.Type, typeof(XmlSchemaComplexType));
			if (xmlSchemaComplexType == null)
			{
				return false;
			}
			if (xmlSchemaComplexType.ContentModel == null)
			{
				return false;
			}
			if (xmlSchemaComplexType.ContentModel.Content == null)
			{
				throw new ArgumentException(Res.GetString("Missing2", xmlSchemaComplexType.Name, xmlSchemaComplexType.ContentModel.GetType().Name), "part");
			}
			if (xmlSchemaComplexType.ContentModel.Content is XmlSchemaComplexContentExtension)
			{
				return ((XmlSchemaComplexContentExtension)xmlSchemaComplexType.ContentModel.Content).BaseTypeName == new XmlQualifiedName("Array", "http://schemas.xmlsoap.org/soap/encoding/");
			}
			if (xmlSchemaComplexType.ContentModel.Content is XmlSchemaComplexContentRestriction)
			{
				return ((XmlSchemaComplexContentRestriction)xmlSchemaComplexType.ContentModel.Content).BaseTypeName == new XmlQualifiedName("Array", "http://schemas.xmlsoap.org/soap/encoding/");
			}
			return false;
		}

		private static void AppendMetadata(CodeAttributeDeclarationCollection from, CodeAttributeDeclarationCollection to)
		{
			foreach (CodeAttributeDeclaration item in from)
			{
				to.Add(item);
			}
		}

		private CodeMemberMethod GenerateMethod(HttpMethodInfo method)
		{
			MimeParameterCollection mimeParameterCollection = ((method.MimeParameters != null) ? method.MimeParameters : method.UrlParameters);
			string[] array = new string[mimeParameterCollection.Count];
			string[] array2 = new string[mimeParameterCollection.Count];
			for (int i = 0; i < mimeParameterCollection.Count; i++)
			{
				MimeParameter mimeParameter = mimeParameterCollection[i];
				array2[i] = mimeParameter.Name;
				array[i] = mimeParameter.TypeName;
			}
			CodeAttributeDeclarationCollection metadata = new CodeAttributeDeclarationCollection();
			CodeExpression[] array3 = new CodeExpression[2];
			if (method.MimeReturn.ReaderType == null)
			{
				array3[0] = new CodeTypeOfExpression(typeof(NopReturnReader).FullName);
			}
			else
			{
				array3[0] = new CodeTypeOfExpression(method.MimeReturn.ReaderType.FullName);
			}
			if (method.MimeParameters != null)
			{
				array3[1] = new CodeTypeOfExpression(method.MimeParameters.WriterType.FullName);
			}
			else
			{
				array3[1] = new CodeTypeOfExpression(typeof(UrlParameterWriter).FullName);
			}
			WebCodeGenerator.AddCustomAttribute(metadata, typeof(HttpMethodAttribute), array3, new string[0], new CodeExpression[0]);
			CodeMemberMethod codeMemberMethod = WebCodeGenerator.AddMethod(base.CodeTypeDeclaration, method.Name, new CodeFlags[array.Length], array, array2, method.MimeReturn.TypeName, metadata, CodeFlags.IsPublic | ((base.Style != 0) ? CodeFlags.IsAbstract : ((CodeFlags)0)));
			AppendMetadata(method.MimeReturn.Attributes, codeMemberMethod.ReturnTypeCustomAttributes);
			codeMemberMethod.Comments.Add(new CodeCommentStatement(Res.GetString("CodeRemarks"), docComment: true));
			for (int j = 0; j < mimeParameterCollection.Count; j++)
			{
				AppendMetadata(mimeParameterCollection[j].Attributes, codeMemberMethod.Parameters[j].CustomAttributes);
			}
			if (base.Style == ServiceDescriptionImportStyle.Client)
			{
				bool flag = (base.ServiceImporter.CodeGenerationOptions & CodeGenerationOptions.GenerateOldAsync) != 0;
				bool flag2 = (base.ServiceImporter.CodeGenerationOptions & CodeGenerationOptions.GenerateNewAsync) != 0 && base.ServiceImporter.CodeGenerator.Supports(GeneratorSupport.DeclareEvents) && base.ServiceImporter.CodeGenerator.Supports(GeneratorSupport.DeclareDelegates);
				CodeExpression[] array4 = new CodeExpression[3];
				CreateInvokeParams(array4, method, array2);
				CodeMethodInvokeExpression expression = new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), "Invoke", array4);
				if (method.MimeReturn.ReaderType != null)
				{
					codeMemberMethod.Statements.Add(new CodeMethodReturnStatement(new CodeCastExpression(method.MimeReturn.TypeName, expression)));
				}
				else
				{
					codeMemberMethod.Statements.Add(new CodeExpressionStatement(expression));
				}
				metadata = new CodeAttributeDeclarationCollection();
				string[] array5 = new string[array.Length + 2];
				array.CopyTo(array5, 0);
				array5[array.Length] = typeof(AsyncCallback).FullName;
				array5[array.Length + 1] = typeof(object).FullName;
				string[] array6 = new string[array2.Length + 2];
				array2.CopyTo(array6, 0);
				array6[array2.Length] = "callback";
				array6[array2.Length + 1] = "asyncState";
				if (flag)
				{
					CodeMemberMethod codeMemberMethod2 = WebCodeGenerator.AddMethod(base.CodeTypeDeclaration, "Begin" + method.Name, new CodeFlags[array5.Length], array5, array6, typeof(IAsyncResult).FullName, metadata, CodeFlags.IsPublic);
					codeMemberMethod2.Comments.Add(new CodeCommentStatement(Res.GetString("CodeRemarks"), docComment: true));
					array4 = new CodeExpression[5];
					CreateInvokeParams(array4, method, array2);
					array4[3] = new CodeArgumentReferenceExpression("callback");
					array4[4] = new CodeArgumentReferenceExpression("asyncState");
					expression = new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), "BeginInvoke", array4);
					codeMemberMethod2.Statements.Add(new CodeMethodReturnStatement(expression));
					CodeMemberMethod codeMemberMethod3 = WebCodeGenerator.AddMethod(base.CodeTypeDeclaration, "End" + method.Name, new CodeFlags[1], new string[1] { typeof(IAsyncResult).FullName }, new string[1] { "asyncResult" }, method.MimeReturn.TypeName, metadata, CodeFlags.IsPublic);
					codeMemberMethod3.Comments.Add(new CodeCommentStatement(Res.GetString("CodeRemarks"), docComment: true));
					CodeExpression codeExpression = new CodeArgumentReferenceExpression("asyncResult");
					expression = new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), "EndInvoke", codeExpression);
					if (method.MimeReturn.ReaderType != null)
					{
						codeMemberMethod3.Statements.Add(new CodeMethodReturnStatement(new CodeCastExpression(method.MimeReturn.TypeName, expression)));
					}
					else
					{
						codeMemberMethod3.Statements.Add(new CodeExpressionStatement(expression));
					}
				}
				if (flag2)
				{
					metadata = new CodeAttributeDeclarationCollection();
					string name = method.Name;
					string key = ProtocolImporter.MethodSignature(name, method.MimeReturn.TypeName, new CodeFlags[array.Length], array);
					DelegateInfo delegateInfo = (DelegateInfo)base.ExportContext[key];
					if (delegateInfo == null)
					{
						string handlerType = base.ClassNames.AddUnique(name + "CompletedEventHandler", name);
						string handlerArgs = base.ClassNames.AddUnique(name + "CompletedEventArgs", name);
						delegateInfo = new DelegateInfo(handlerType, handlerArgs);
					}
					string handlerName = base.MethodNames.AddUnique(name + "Completed", name);
					string methodName = base.MethodNames.AddUnique(name + "Async", name);
					string text = base.MethodNames.AddUnique(name + "OperationCompleted", name);
					string callbackName = base.MethodNames.AddUnique("On" + name + "OperationCompleted", name);
					WebCodeGenerator.AddEvent(base.CodeTypeDeclaration.Members, delegateInfo.handlerType, handlerName);
					WebCodeGenerator.AddCallbackDeclaration(base.CodeTypeDeclaration.Members, text);
					string text2 = ProtocolImporter.UniqueName("userState", array2);
					CodeMemberMethod codeMemberMethod4 = WebCodeGenerator.AddAsyncMethod(base.CodeTypeDeclaration, methodName, array, array2, text, callbackName, text2);
					array4 = new CodeExpression[5];
					CreateInvokeParams(array4, method, array2);
					array4[3] = new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), text);
					array4[4] = new CodeArgumentReferenceExpression(text2);
					expression = new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), "InvokeAsync", array4);
					codeMemberMethod4.Statements.Add(expression);
					bool flag3 = method.MimeReturn.ReaderType != null;
					WebCodeGenerator.AddCallbackImplementation(base.CodeTypeDeclaration, callbackName, handlerName, delegateInfo.handlerArgs, flag3);
					if (base.ExportContext[key] == null)
					{
						WebCodeGenerator.AddDelegate(base.ExtraCodeClasses, delegateInfo.handlerType, flag3 ? delegateInfo.handlerArgs : typeof(AsyncCompletedEventArgs).FullName);
						if (flag3)
						{
							base.ExtraCodeClasses.Add(WebCodeGenerator.CreateArgsClass(delegateInfo.handlerArgs, new string[1] { method.MimeReturn.TypeName }, new string[1] { "Result" }, base.ServiceImporter.CodeGenerator.Supports(GeneratorSupport.PartialTypes)));
						}
						base.ExportContext[key] = delegateInfo;
					}
				}
			}
			return codeMemberMethod;
		}

		private void CreateInvokeParams(CodeExpression[] invokeParams, HttpMethodInfo method, string[] parameterNames)
		{
			invokeParams[0] = new CodePrimitiveExpression(method.Name);
			CodeExpression left = new CodePropertyReferenceExpression(new CodeThisReferenceExpression(), "Url");
			CodeExpression right = new CodePrimitiveExpression(method.Href);
			invokeParams[1] = new CodeBinaryOperatorExpression(left, CodeBinaryOperatorType.Add, right);
			CodeExpression[] array = new CodeExpression[parameterNames.Length];
			for (int i = 0; i < parameterNames.Length; i++)
			{
				array[i] = new CodeArgumentReferenceExpression(parameterNames[i]);
			}
			invokeParams[2] = new CodeArrayCreateExpression(typeof(object).FullName, array);
		}

		protected override bool IsOperationFlowSupported(OperationFlow flow)
		{
			return flow == OperationFlow.RequestResponse;
		}

		protected override CodeMemberMethod GenerateMethod()
		{
			HttpOperationBinding httpOperationBinding = (HttpOperationBinding)base.OperationBinding.Extensions.Find(typeof(HttpOperationBinding));
			if (httpOperationBinding == null)
			{
				throw OperationBindingSyntaxException(Res.GetString("MissingHttpOperationElement0"));
			}
			HttpMethodInfo httpMethodInfo = new HttpMethodInfo();
			if (hasInputPayload)
			{
				httpMethodInfo.MimeParameters = ImportMimeParameters();
				if (httpMethodInfo.MimeParameters == null)
				{
					UnsupportedOperationWarning(Res.GetString("NoInputMIMEFormatsWereRecognized0"));
					return null;
				}
			}
			else
			{
				httpMethodInfo.UrlParameters = ImportUrlParameters();
				if (httpMethodInfo.UrlParameters == null)
				{
					UnsupportedOperationWarning(Res.GetString("NoInputHTTPFormatsWereRecognized0"));
					return null;
				}
			}
			httpMethodInfo.MimeReturn = ImportMimeReturn();
			if (httpMethodInfo.MimeReturn == null)
			{
				UnsupportedOperationWarning(Res.GetString("NoOutputMIMEFormatsWereRecognized0"));
				return null;
			}
			httpMethodInfo.Name = base.MethodNames.AddUnique(base.MethodName, httpMethodInfo);
			httpMethodInfo.Href = httpOperationBinding.Location;
			return GenerateMethod(httpMethodInfo);
		}

		protected override CodeTypeDeclaration BeginClass()
		{
			base.MethodNames.Clear();
			base.ExtraCodeClasses.Clear();
			CodeAttributeDeclarationCollection metadata = new CodeAttributeDeclarationCollection();
			if (base.Style == ServiceDescriptionImportStyle.Client)
			{
				WebCodeGenerator.AddCustomAttribute(metadata, typeof(DebuggerStepThroughAttribute), new CodeExpression[0]);
				WebCodeGenerator.AddCustomAttribute(metadata, typeof(DesignerCategoryAttribute), new CodeExpression[1]
				{
					new CodePrimitiveExpression("code")
				});
			}
			Type[] types = new Type[7]
			{
				typeof(SoapDocumentMethodAttribute),
				typeof(XmlAttributeAttribute),
				typeof(WebService),
				typeof(object),
				typeof(DebuggerStepThroughAttribute),
				typeof(DesignerCategoryAttribute),
				typeof(TransactionOption)
			};
			WebCodeGenerator.AddImports(base.CodeNamespace, WebCodeGenerator.GetNamespacesForTypes(types));
			CodeFlags codeFlags = (CodeFlags)0;
			if (base.Style == ServiceDescriptionImportStyle.Server)
			{
				codeFlags = CodeFlags.IsAbstract;
			}
			else if (base.Style == ServiceDescriptionImportStyle.ServerInterface)
			{
				codeFlags = CodeFlags.IsInterface;
			}
			CodeTypeDeclaration codeTypeDeclaration = WebCodeGenerator.CreateClass(base.ClassName, BaseClass.FullName, new string[0], metadata, CodeFlags.IsPublic | codeFlags, base.ServiceImporter.CodeGenerator.Supports(GeneratorSupport.PartialTypes));
			codeTypeDeclaration.Comments.Add(new CodeCommentStatement(Res.GetString("CodeRemarks"), docComment: true));
			CodeConstructor codeConstructor = WebCodeGenerator.AddConstructor(codeTypeDeclaration, new string[0], new string[0], null, CodeFlags.IsPublic);
			codeConstructor.Comments.Add(new CodeCommentStatement(Res.GetString("CodeRemarks"), docComment: true));
			string url = ((base.Port == null) ? null : ((HttpAddressBinding)base.Port.Extensions.Find(typeof(HttpAddressBinding))))?.Location;
			ServiceDescription serviceDescription = base.Binding.ServiceDescription;
			ProtocolImporterUtil.GenerateConstructorStatements(codeConstructor, url, serviceDescription.AppSettingUrlKey, serviceDescription.AppSettingBaseUrl, soap11: false);
			codeClasses.Add(codeTypeDeclaration);
			return codeTypeDeclaration;
		}

		protected override void EndNamespace()
		{
			for (int i = 0; i < importers.Length; i++)
			{
				importers[i].GenerateCode((MimeReturn[])importedReturns[i].ToArray(typeof(MimeReturn)), (MimeParameterCollection[])importedParameters[i].ToArray(typeof(MimeParameterCollection)));
			}
			foreach (CodeTypeDeclaration codeClass in codeClasses)
			{
				if (codeClass.CustomAttributes == null)
				{
					codeClass.CustomAttributes = new CodeAttributeDeclarationCollection();
				}
				for (int j = 0; j < importers.Length; j++)
				{
					importers[j].AddClassMetadata(codeClass);
				}
			}
			foreach (CodeTypeDeclaration extraCodeClass in base.ExtraCodeClasses)
			{
				base.CodeNamespace.Types.Add(extraCodeClass);
			}
			CodeGenerator.ValidateIdentifiers(base.CodeNamespace);
		}
	}
	internal class HttpGetProtocolImporter : HttpProtocolImporter
	{
		public override string ProtocolName => "HttpGet";

		internal override Type BaseClass
		{
			get
			{
				if (base.Style == ServiceDescriptionImportStyle.Client)
				{
					return typeof(HttpGetClientProtocol);
				}
				return typeof(WebService);
			}
		}

		public HttpGetProtocolImporter()
			: base(hasInputPayload: false)
		{
		}

		protected override bool IsBindingSupported()
		{
			HttpBinding httpBinding = (HttpBinding)base.Binding.Extensions.Find(typeof(HttpBinding));
			if (httpBinding == null)
			{
				return false;
			}
			if (httpBinding.Verb != "GET")
			{
				return false;
			}
			return true;
		}
	}
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	public abstract class ProtocolReflector
	{
		private class ReflectedBinding
		{
			public WebServiceBindingAttribute bindingAttr;

			public ArrayList methodList;

			internal ReflectedBinding()
			{
			}

			internal ReflectedBinding(WebServiceBindingAttribute bindingAttr)
			{
				this.bindingAttr = bindingAttr;
			}
		}

		private ServiceDescriptionReflector reflector;

		private LogicalMethodInfo method;

		private Operation operation;

		private OperationBinding operationBinding;

		private Port port;

		private PortType portType;

		private Binding binding;

		private WebMethodAttribute methodAttr;

		private Message inputMessage;

		private Message outputMessage;

		private MessageCollection headerMessages;

		private ServiceDescription bindingServiceDescription;

		private CodeIdentifiers portNames;

		private bool emptyBinding;

		internal bool IsEmptyBinding => emptyBinding;

		public Service Service => reflector.Service;

		public ServiceDescription ServiceDescription => reflector.ServiceDescription;

		public ServiceDescriptionCollection ServiceDescriptions => reflector.ServiceDescriptions;

		public XmlSchemas Schemas => reflector.Schemas;

		public XmlSchemaExporter SchemaExporter => reflector.SchemaExporter;

		public XmlReflectionImporter ReflectionImporter => reflector.ReflectionImporter;

		public string DefaultNamespace => reflector.ServiceAttribute.Namespace;

		public string ServiceUrl => reflector.ServiceUrl;

		public Type ServiceType => reflector.ServiceType;

		public LogicalMethodInfo Method => method;

		public Binding Binding => binding;

		public PortType PortType => portType;

		public Port Port => port;

		public Operation Operation => operation;

		public OperationBinding OperationBinding => operationBinding;

		public WebMethodAttribute MethodAttribute => methodAttr;

		public LogicalMethodInfo[] Methods => reflector.Methods;

		internal Hashtable ReflectionContext => reflector.ReflectionContext;

		public Message InputMessage
		{
			get
			{
				if (inputMessage == null)
				{
					string text = XmlConvert.EncodeLocalName((methodAttr.MessageName.Length == 0) ? Method.Name : methodAttr.MessageName);
					bool flag = text != Method.Name;
					inputMessage = new Message();
					inputMessage.Name = text + ProtocolName + "In";
					OperationInput operationInput = new OperationInput();
					if (flag)
					{
						operationInput.Name = text;
					}
					operationInput.Message = new XmlQualifiedName(inputMessage.Name, bindingServiceDescription.TargetNamespace);
					operation.Messages.Add(operationInput);
					OperationBinding.Input = new InputBinding();
					if (flag)
					{
						OperationBinding.Input.Name = text;
					}
				}
				return inputMessage;
			}
		}

		public Message OutputMessage
		{
			get
			{
				if (outputMessage == null)
				{
					string text = XmlConvert.EncodeLocalName((methodAttr.MessageName.Length == 0) ? Method.Name : methodAttr.MessageName);
					bool flag = text != Method.Name;
					outputMessage = new Message();
					outputMessage.Name = text + ProtocolName + "Out";
					OperationOutput operationOutput = new OperationOutput();
					if (flag)
					{
						operationOutput.Name = text;
					}
					operationOutput.Message = new XmlQualifiedName(outputMessage.Name, bindingServiceDescription.TargetNamespace);
					operation.Messages.Add(operationOutput);
					OperationBinding.Output = new OutputBinding();
					if (flag)
					{
						OperationBinding.Output.Name = text;
					}
				}
				return outputMessage;
			}
		}

		public MessageCollection HeaderMessages
		{
			get
			{
				if (headerMessages == null)
				{
					headerMessages = new MessageCollection(bindingServiceDescription);
				}
				return headerMessages;
			}
		}

		internal virtual WsiProfiles ConformsTo => WsiProfiles.None;

		public abstract string ProtocolName { get; }

		internal void Initialize(ServiceDescriptionReflector reflector)
		{
			this.reflector = reflector;
		}

		private void MoveToMethod(LogicalMethodInfo method)
		{
			this.method = method;
			methodAttr = method.MethodAttribute;
		}

		internal void Reflect()
		{
			emptyBinding = false;
			Hashtable hashtable = new Hashtable();
			Hashtable hashtable2 = new Hashtable();
			for (int i = 0; i < reflector.Methods.Length; i++)
			{
				MoveToMethod(reflector.Methods[i]);
				string text = ReflectMethodBinding();
				if (text == null)
				{
					text = string.Empty;
				}
				ReflectedBinding reflectedBinding = (ReflectedBinding)hashtable2[text];
				if (reflectedBinding == null)
				{
					reflectedBinding = new ReflectedBinding();
					reflectedBinding.bindingAttr = WebServiceBindingReflector.GetAttribute(method, text);
					if (reflectedBinding.bindingAttr == null || (text.Length == 0 && reflectedBinding.bindingAttr.Location.Length > 0))
					{
						reflectedBinding.bindingAttr = new WebServiceBindingAttribute();
					}
					hashtable2.Add(text, reflectedBinding);
				}
				if (reflectedBinding.bindingAttr.Location.Length == 0)
				{
					if (reflectedBinding.methodList == null)
					{
						reflectedBinding.methodList = new ArrayList();
					}
					reflectedBinding.methodList.Add(method);
					hashtable[reflectedBinding.bindingAttr.Name] = method;
				}
				else
				{
					AddImport(reflectedBinding.bindingAttr.Namespace, reflectedBinding.bindingAttr.Location);
				}
			}
			foreach (ReflectedBinding value in hashtable2.Values)
			{
				ReflectBinding(value);
			}
			if (hashtable2.Count == 0)
			{
				emptyBinding = true;
				ReflectedBinding reflectedBinding3 = null;
				object[] customAttributes = ServiceType.GetCustomAttributes(typeof(WebServiceBindingAttribute), inherit: false);
				for (int j = 0; j < customAttributes.Length; j++)
				{
					WebServiceBindingAttribute webServiceBindingAttribute = (WebServiceBindingAttribute)customAttributes[j];
					if (hashtable[webServiceBindingAttribute.Name] == null)
					{
						if (reflectedBinding3 != null)
						{
							reflectedBinding3 = null;
							break;
						}
						reflectedBinding3 = new ReflectedBinding(webServiceBindingAttribute);
					}
				}
				if (reflectedBinding3 != null)
				{
					ReflectBinding(reflectedBinding3);
				}
			}
			Type[] interfaces = ServiceType.GetInterfaces();
			Type[] array = interfaces;
			foreach (Type type in array)
			{
				object[] customAttributes2 = type.GetCustomAttributes(typeof(WebServiceBindingAttribute), inherit: false);
				for (int l = 0; l < customAttributes2.Length; l++)
				{
					WebServiceBindingAttribute webServiceBindingAttribute2 = (WebServiceBindingAttribute)customAttributes2[l];
					if (hashtable[webServiceBindingAttribute2.Name] == null)
					{
						ReflectBinding(new ReflectedBinding(webServiceBindingAttribute2));
					}
				}
			}
			ReflectDescription();
		}

		private void AddImport(string ns, string location)
		{
			foreach (Import import3 in ServiceDescription.Imports)
			{
				if (import3.Namespace == ns && import3.Location == location)
				{
					return;
				}
			}
			Import import2 = new Import();
			import2.Namespace = ns;
			import2.Location = location;
			ServiceDescription.Imports.Add(import2);
		}

		public ServiceDescription GetServiceDescription(string ns)
		{
			ServiceDescription serviceDescription = ServiceDescriptions[ns];
			if (serviceDescription == null)
			{
				serviceDescription = new ServiceDescription();
				serviceDescription.TargetNamespace = ns;
				ServiceDescriptions.Add(serviceDescription);
			}
			return serviceDescription;
		}

		private void ReflectBinding(ReflectedBinding reflectedBinding)
		{
			string text = XmlConvert.EncodeLocalName(reflectedBinding.bindingAttr.Name);
			string text2 = reflectedBinding.bindingAttr.Namespace;
			if (text.Length == 0)
			{
				text = Service.Name + ProtocolName;
			}
			if (text2.Length == 0)
			{
				text2 = ServiceDescription.TargetNamespace;
			}
			WsiProfiles wsiProfiles = WsiProfiles.None;
			if (reflectedBinding.bindingAttr.Location.Length > 0)
			{
				portType = null;
				this.binding = null;
			}
			else
			{
				bindingServiceDescription = GetServiceDescription(text2);
				CodeIdentifiers codeIdentifiers = new CodeIdentifiers();
				foreach (Binding binding in bindingServiceDescription.Bindings)
				{
					codeIdentifiers.AddReserved(binding.Name);
				}
				text = codeIdentifiers.AddUnique(text, this.binding);
				portType = new PortType();
				this.binding = new Binding();
				portType.Name = text;
				this.binding.Name = text;
				this.binding.Type = new XmlQualifiedName(portType.Name, text2);
				wsiProfiles = reflectedBinding.bindingAttr.ConformsTo & ConformsTo;
				if (reflectedBinding.bindingAttr.EmitConformanceClaims && wsiProfiles != 0)
				{
					ServiceDescription.AddConformanceClaims(this.binding.GetDocumentationElement(), wsiProfiles);
				}
				bindingServiceDescription.Bindings.Add(this.binding);
				bindingServiceDescription.PortTypes.Add(portType);
			}
			if (portNames == null)
			{
				portNames = new CodeIdentifiers();
				foreach (Port port in Service.Ports)
				{
					portNames.AddReserved(port.Name);
				}
			}
			this.port = new Port();
			this.port.Binding = new XmlQualifiedName(text, text2);
			this.port.Name = portNames.AddUnique(text, this.port);
			Service.Ports.Add(this.port);
			BeginClass();
			if (reflectedBinding.methodList != null && reflectedBinding.methodList.Count > 0)
			{
				foreach (LogicalMethodInfo method in reflectedBinding.methodList)
				{
					MoveToMethod(method);
					operation = new Operation();
					operation.Name = XmlConvert.EncodeLocalName(method.Name);
					if (methodAttr.Description != null && methodAttr.Description.Length > 0)
					{
						operation.Documentation = methodAttr.Description;
					}
					operationBinding = new OperationBinding();
					operationBinding.Name = operation.Name;
					inputMessage = null;
					outputMessage = null;
					headerMessages = null;
					if (!ReflectMethod())
					{
						continue;
					}
					if (inputMessage != null)
					{
						bindingServiceDescription.Messages.Add(inputMessage);
					}
					if (outputMessage != null)
					{
						bindingServiceDescription.Messages.Add(outputMessage);
					}
					if (headerMessages != null)
					{
						foreach (Message headerMessage in headerMessages)
						{
							bindingServiceDescription.Messages.Add(headerMessage);
						}
					}
					this.binding.Operations.Add(operationBinding);
					portType.Operations.Add(operation);
				}
			}
			if (this.binding != null && wsiProfiles == WsiProfiles.BasicProfile1_1 && ProtocolName == "Soap")
			{
				BasicProfileViolationCollection basicProfileViolationCollection = new BasicProfileViolationCollection();
				WebServicesInteroperability.AnalyzeBinding(this.binding, bindingServiceDescription, ServiceDescriptions, basicProfileViolationCollection);
				if (basicProfileViolationCollection.Count > 0)
				{
					throw new InvalidOperationException(Res.GetString("WebWsiViolation", ServiceType.FullName, basicProfileViolationCollection.ToString()));
				}
			}
			EndClass();
		}

		protected virtual void BeginClass()
		{
		}

		protected abstract bool ReflectMethod();

		protected virtual string ReflectMethodBinding()
		{
			return string.Empty;
		}

		protected virtual void EndClass()
		{
		}

		protected virtual void ReflectDescription()
		{
		}
	}
	internal abstract class HttpProtocolReflector : ProtocolReflector
	{
		private MimeReflector[] reflectors;

		internal string MethodUrl
		{
			get
			{
				WebMethodAttribute methodAttribute = base.Method.MethodAttribute;
				string text = methodAttribute.MessageName;
				if (text.Length == 0)
				{
					text = base.Method.Name;
				}
				return "/" + text;
			}
		}

		protected HttpProtocolReflector()
		{
			Type[] mimeReflectorTypes = WebServicesSection.Current.MimeReflectorTypes;
			reflectors = new MimeReflector[mimeReflectorTypes.Length];
			for (int i = 0; i < reflectors.Length; i++)
			{
				MimeReflector mimeReflector = (MimeReflector)Activator.CreateInstance(mimeReflectorTypes[i]);
				mimeReflector.ReflectionContext = this;
				reflectors[i] = mimeReflector;
			}
		}

		protected bool ReflectMimeParameters()
		{
			bool result = false;
			for (int i = 0; i < reflectors.Length; i++)
			{
				if (reflectors[i].ReflectParameters())
				{
					result = true;
				}
			}
			return result;
		}

		protected bool ReflectMimeReturn()
		{
			if (base.Method.ReturnType == typeof(void))
			{
				_ = base.OutputMessage;
				return true;
			}
			bool result = false;
			for (int i = 0; i < reflectors.Length; i++)
			{
				if (reflectors[i].ReflectReturn())
				{
					result = true;
					break;
				}
			}
			return result;
		}

		protected bool ReflectUrlParameters()
		{
			if (!HttpServerProtocol.AreUrlParametersSupported(base.Method))
			{
				return false;
			}
			ReflectStringParametersMessage();
			base.OperationBinding.Input.Extensions.Add(new HttpUrlEncodedBinding());
			return true;
		}

		internal void ReflectStringParametersMessage()
		{
			Message message = base.InputMessage;
			ParameterInfo[] inParameters = base.Method.InParameters;
			foreach (ParameterInfo parameterInfo in inParameters)
			{
				MessagePart messagePart = new MessagePart();
				messagePart.Name = XmlConvert.EncodeLocalName(parameterInfo.Name);
				if (parameterInfo.ParameterType.IsArray)
				{
					string defaultNamespace = base.DefaultNamespace;
					defaultNamespace = ((!defaultNamespace.EndsWith("/", StringComparison.Ordinal)) ? (defaultNamespace + "/AbstractTypes") : (defaultNamespace + "AbstractTypes"));
					string name = "StringArray";
					if (!base.ServiceDescription.Types.Schemas.Contains(defaultNamespace))
					{
						XmlSchema xmlSchema = new XmlSchema();
						xmlSchema.TargetNamespace = defaultNamespace;
						base.ServiceDescription.Types.Schemas.Add(xmlSchema);
						XmlSchemaElement xmlSchemaElement = new XmlSchemaElement();
						xmlSchemaElement.Name = "String";
						xmlSchemaElement.SchemaTypeName = new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema");
						xmlSchemaElement.MinOccurs = 0m;
						xmlSchemaElement.MaxOccurs = decimal.MaxValue;
						XmlSchemaSequence xmlSchemaSequence = new XmlSchemaSequence();
						xmlSchemaSequence.Items.Add(xmlSchemaElement);
						XmlSchemaComplexContentRestriction xmlSchemaComplexContentRestriction = new XmlSchemaComplexContentRestriction();
						xmlSchemaComplexContentRestriction.BaseTypeName = new XmlQualifiedName("Array", "http://schemas.xmlsoap.org/soap/encoding/");
						xmlSchemaComplexContentRestriction.Particle = xmlSchemaSequence;
						XmlSchemaImport xmlSchemaImport = new XmlSchemaImport();
						xmlSchemaImport.Namespace = xmlSchemaComplexContentRestriction.BaseTypeName.Namespace;
						XmlSchemaComplexContent xmlSchemaComplexContent = new XmlSchemaComplexContent();
						xmlSchemaComplexContent.Content = xmlSchemaComplexContentRestriction;
						XmlSchemaComplexType xmlSchemaComplexType = new XmlSchemaComplexType();
						xmlSchemaComplexType.Name = name;
						xmlSchemaComplexType.ContentModel = xmlSchemaComplexContent;
						xmlSchema.Items.Add(xmlSchemaComplexType);
						xmlSchema.Includes.Add(xmlSchemaImport);
					}
					messagePart.Type = new XmlQualifiedName(name, defaultNamespace);
				}
				else
				{
					messagePart.Type = new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema");
				}
				message.Parts.Add(messagePart);
			}
		}
	}
	internal class HttpGetProtocolReflector : HttpProtocolReflector
	{
		public override string ProtocolName => "HttpGet";

		protected override void BeginClass()
		{
			if (!base.IsEmptyBinding)
			{
				HttpBinding httpBinding = new HttpBinding();
				httpBinding.Verb = "GET";
				base.Binding.Extensions.Add(httpBinding);
				HttpAddressBinding httpAddressBinding = new HttpAddressBinding();
				httpAddressBinding.Location = base.ServiceUrl;
				base.Port.Extensions.Add(httpAddressBinding);
			}
		}

		protected override bool ReflectMethod()
		{
			if (!ReflectUrlParameters())
			{
				return false;
			}
			if (!ReflectMimeReturn())
			{
				return false;
			}
			HttpOperationBinding httpOperationBinding = new HttpOperationBinding();
			httpOperationBinding.Location = base.MethodUrl;
			base.OperationBinding.Extensions.Add(httpOperationBinding);
			return true;
		}
	}
	internal class HttpPostProtocolImporter : HttpProtocolImporter
	{
		public override string ProtocolName => "HttpPost";

		internal override Type BaseClass
		{
			get
			{
				if (base.Style == ServiceDescriptionImportStyle.Client)
				{
					return typeof(HttpPostClientProtocol);
				}
				return typeof(WebService);
			}
		}

		public HttpPostProtocolImporter()
			: base(hasInputPayload: true)
		{
		}

		protected override bool IsBindingSupported()
		{
			HttpBinding httpBinding = (HttpBinding)base.Binding.Extensions.Find(typeof(HttpBinding));
			if (httpBinding == null)
			{
				return false;
			}
			if (httpBinding.Verb != "POST")
			{
				return false;
			}
			return true;
		}
	}
	internal class HttpPostProtocolReflector : HttpProtocolReflector
	{
		public override string ProtocolName => "HttpPost";

		protected override void BeginClass()
		{
			if (!base.IsEmptyBinding)
			{
				HttpBinding httpBinding = new HttpBinding();
				httpBinding.Verb = "POST";
				base.Binding.Extensions.Add(httpBinding);
				HttpAddressBinding httpAddressBinding = new HttpAddressBinding();
				httpAddressBinding.Location = base.ServiceUrl;
				base.Port.Extensions.Add(httpAddressBinding);
			}
		}

		protected override bool ReflectMethod()
		{
			if (!ReflectMimeParameters())
			{
				return false;
			}
			if (!ReflectMimeReturn())
			{
				return false;
			}
			HttpOperationBinding httpOperationBinding = new HttpOperationBinding();
			httpOperationBinding.Location = base.MethodUrl;
			base.OperationBinding.Extensions.Add(httpOperationBinding);
			return true;
		}
	}
	internal class HttpMethodInfo
	{
		internal MimeParameterCollection UrlParameters;

		internal MimeParameterCollection MimeParameters;

		internal MimeReturn MimeReturn;

		internal string Name;

		internal string Href;
	}
	internal abstract class MimeImporter
	{
		private HttpProtocolImporter protocol;

		internal HttpProtocolImporter ImportContext
		{
			get
			{
				return protocol;
			}
			set
			{
				protocol = value;
			}
		}

		internal abstract MimeParameterCollection ImportParameters();

		internal abstract MimeReturn ImportReturn();

		internal virtual void GenerateCode(MimeReturn[] importedReturns, MimeParameterCollection[] importedParameters)
		{
		}

		internal virtual void AddClassMetadata(CodeTypeDeclaration codeClass)
		{
		}
	}
	internal class MimeAnyImporter : MimeImporter
	{
		internal override MimeParameterCollection ImportParameters()
		{
			return null;
		}

		internal override MimeReturn ImportReturn()
		{
			if (base.ImportContext.OperationBinding.Output.Extensions.Count == 0)
			{
				return null;
			}
			MimeReturn mimeReturn = new MimeReturn();
			mimeReturn.TypeName = typeof(Stream).FullName;
			mimeReturn.ReaderType = typeof(AnyReturnReader);
			return mimeReturn;
		}
	}
	[XmlFormatExtension("content", "http://schemas.xmlsoap.org/wsdl/mime/", typeof(MimePart), typeof(InputBinding), typeof(OutputBinding))]
	[XmlFormatExtensionPrefix("mime", "http://schemas.xmlsoap.org/wsdl/mime/")]
	public sealed class MimeContentBinding : ServiceDescriptionFormatExtension
	{
		public const string Namespace = "http://schemas.xmlsoap.org/wsdl/mime/";

		private string type;

		private string part;

		[XmlAttribute("part")]
		public string Part
		{
			get
			{
				return part;
			}
			set
			{
				part = value;
			}
		}

		[XmlAttribute("type")]
		public string Type
		{
			get
			{
				if (type != null)
				{
					return type;
				}
				return string.Empty;
			}
			set
			{
				type = value;
			}
		}
	}
	[XmlFormatExtensionPoint("Extensions")]
	public sealed class MimePart : ServiceDescriptionFormatExtension
	{
		private ServiceDescriptionFormatExtensionCollection extensions;

		[XmlIgnore]
		public ServiceDescriptionFormatExtensionCollection Extensions
		{
			get
			{
				if (extensions == null)
				{
					extensions = new ServiceDescriptionFormatExtensionCollection(this);
				}
				return extensions;
			}
		}
	}
	[XmlFormatExtension("multipartRelated", "http://schemas.xmlsoap.org/wsdl/mime/", typeof(InputBinding), typeof(OutputBinding))]
	public sealed class MimeMultipartRelatedBinding : ServiceDescriptionFormatExtension
	{
		private MimePartCollection parts = new MimePartCollection();

		[XmlElement("part")]
		public MimePartCollection Parts => parts;
	}
	[XmlFormatExtension("mimeXml", "http://schemas.xmlsoap.org/wsdl/mime/", typeof(MimePart), typeof(InputBinding), typeof(OutputBinding))]
	public sealed class MimeXmlBinding : ServiceDescriptionFormatExtension
	{
		private string part;

		[XmlAttribute("part")]
		public string Part
		{
			get
			{
				return part;
			}
			set
			{
				part = value;
			}
		}
	}
	public sealed class MimePartCollection : CollectionBase
	{
		public MimePart this[int index]
		{
			get
			{
				return (MimePart)base.List[index];
			}
			set
			{
				base.List[index] = value;
			}
		}

		public int Add(MimePart mimePart)
		{
			return base.List.Add(mimePart);
		}

		public void Insert(int index, MimePart mimePart)
		{
			base.List.Insert(index, mimePart);
		}

		public int IndexOf(MimePart mimePart)
		{
			return base.List.IndexOf(mimePart);
		}

		public bool Contains(MimePart mimePart)
		{
			return base.List.Contains(mimePart);
		}

		public void Remove(MimePart mimePart)
		{
			base.List.Remove(mimePart);
		}

		public void CopyTo(MimePart[] array, int index)
		{
			base.List.CopyTo(array, index);
		}
	}
	[XmlFormatExtension("text", "http://microsoft.com/wsdl/mime/textMatching/", typeof(InputBinding), typeof(OutputBinding), typeof(MimePart))]
	[XmlFormatExtensionPrefix("tm", "http://microsoft.com/wsdl/mime/textMatching/")]
	public sealed class MimeTextBinding : ServiceDescriptionFormatExtension
	{
		public const string Namespace = "http://microsoft.com/wsdl/mime/textMatching/";

		private MimeTextMatchCollection matches = new MimeTextMatchCollection();

		[XmlElement("match", typeof(MimeTextMatch))]
		public MimeTextMatchCollection Matches => matches;
	}
	public sealed class MimeTextMatch
	{
		private string name;

		private string type;

		private int repeats = 1;

		private string pattern;

		private int group = 1;

		private int capture;

		private bool ignoreCase;

		private MimeTextMatchCollection matches = new MimeTextMatchCollection();

		[XmlAttribute("name")]
		public string Name
		{
			get
			{
				if (name != null)
				{
					return name;
				}
				return string.Empty;
			}
			set
			{
				name = value;
			}
		}

		[XmlAttribute("type")]
		public string Type
		{
			get
			{
				if (type != null)
				{
					return type;
				}
				return string.Empty;
			}
			set
			{
				type = value;
			}
		}

		[DefaultValue(1)]
		[XmlAttribute("group")]
		public int Group
		{
			get
			{
				return group;
			}
			set
			{
				if (value < 0)
				{
					throw new ArgumentException(Res.GetString("WebNegativeValue", "group"));
				}
				group = value;
			}
		}

		[DefaultValue(0)]
		[XmlAttribute("capture")]
		public int Capture
		{
			get
			{
				return capture;
			}
			set
			{
				if (value < 0)
				{
					throw new ArgumentException(Res.GetString("WebNegativeValue", "capture"));
				}
				capture = value;
			}
		}

		[XmlIgnore]
		public int Repeats
		{
			get
			{
				return repeats;
			}
			set
			{
				if (value < 0)
				{
					throw new ArgumentException(Res.GetString("WebNegativeValue", "repeats"));
				}
				repeats = value;
			}
		}

		[XmlAttribute("repeats")]
		[DefaultValue("1")]
		public string RepeatsString
		{
			get
			{
				if (repeats != int.MaxValue)
				{
					return repeats.ToString(CultureInfo.InvariantCulture);
				}
				return "*";
			}
			set
			{
				if (value == "*")
				{
					repeats = int.MaxValue;
				}
				else
				{
					Repeats = int.Parse(value, CultureInfo.InvariantCulture);
				}
			}
		}

		[XmlAttribute("pattern")]
		public string Pattern
		{
			get
			{
				if (pattern != null)
				{
					return pattern;
				}
				return string.Empty;
			}
			set
			{
				pattern = value;
			}
		}

		[XmlAttribute("ignoreCase")]
		public bool IgnoreCase
		{
			get
			{
				return ignoreCase;
			}
			set
			{
				ignoreCase = value;
			}
		}

		[XmlElement("match")]
		public MimeTextMatchCollection Matches => matches;
	}
	public sealed class MimeTextMatchCollection : CollectionBase
	{
		public MimeTextMatch this[int index]
		{
			get
			{
				return (MimeTextMatch)base.List[index];
			}
			set
			{
				base.List[index] = value;
			}
		}

		public int Add(MimeTextMatch match)
		{
			return base.List.Add(match);
		}

		public void Insert(int index, MimeTextMatch match)
		{
			base.List.Insert(index, match);
		}

		public int IndexOf(MimeTextMatch match)
		{
			return base.List.IndexOf(match);
		}

		public bool Contains(MimeTextMatch match)
		{
			return base.List.Contains(match);
		}

		public void Remove(MimeTextMatch match)
		{
			base.List.Remove(match);
		}

		public void CopyTo(MimeTextMatch[] array, int index)
		{
			base.List.CopyTo(array, index);
		}
	}
	internal class MimeFormImporter : MimeImporter
	{
		internal override MimeParameterCollection ImportParameters()
		{
			MimeContentBinding mimeContentBinding = (MimeContentBinding)base.ImportContext.OperationBinding.Input.Extensions.Find(typeof(MimeContentBinding));
			if (mimeContentBinding == null)
			{
				return null;
			}
			if (string.Compare(mimeContentBinding.Type, "application/x-www-form-urlencoded", StringComparison.OrdinalIgnoreCase) != 0)
			{
				return null;
			}
			MimeParameterCollection mimeParameterCollection = base.ImportContext.ImportStringParametersMessage();
			if (mimeParameterCollection == null)
			{
				return null;
			}
			mimeParameterCollection.WriterType = typeof(HtmlFormParameterWriter);
			return mimeParameterCollection;
		}

		internal override MimeReturn ImportReturn()
		{
			return null;
		}
	}
	internal abstract class MimeReflector
	{
		private HttpProtocolReflector protocol;

		internal HttpProtocolReflector ReflectionContext
		{
			get
			{
				return protocol;
			}
			set
			{
				protocol = value;
			}
		}

		internal abstract bool ReflectParameters();

		internal abstract bool ReflectReturn();
	}
	internal class MimeFormReflector : MimeReflector
	{
		internal override bool ReflectParameters()
		{
			if (!ValueCollectionParameterReader.IsSupported(base.ReflectionContext.Method))
			{
				return false;
			}
			base.ReflectionContext.ReflectStringParametersMessage();
			MimeContentBinding mimeContentBinding = new MimeContentBinding();
			mimeContentBinding.Type = "application/x-www-form-urlencoded";
			base.ReflectionContext.OperationBinding.Input.Extensions.Add(mimeContentBinding);
			return true;
		}

		internal override bool ReflectReturn()
		{
			return false;
		}
	}
	internal class MimeParameter
	{
		private string name;

		private string typeName;

		private CodeAttributeDeclarationCollection attrs;

		internal string Name
		{
			get
			{
				if (name != null)
				{
					return name;
				}
				return string.Empty;
			}
			set
			{
				name = value;
			}
		}

		internal string TypeName
		{
			get
			{
				if (typeName != null)
				{
					return typeName;
				}
				return string.Empty;
			}
			set
			{
				typeName = value;
			}
		}

		internal CodeAttributeDeclarationCollection Attributes
		{
			get
			{
				if (attrs == null)
				{
					attrs = new CodeAttributeDeclarationCollection();
				}
				return attrs;
			}
		}
	}
	internal class MimeParameterCollection : CollectionBase
	{
		private Type writerType;

		internal Type WriterType
		{
			get
			{
				return writerType;
			}
			set
			{
				writerType = value;
			}
		}

		internal MimeParameter this[int index]
		{
			get
			{
				return (MimeParameter)base.List[index];
			}
			set
			{
				base.List[index] = value;
			}
		}

		internal int Add(MimeParameter parameter)
		{
			return base.List.Add(parameter);
		}

		internal void Insert(int index, MimeParameter parameter)
		{
			base.List.Insert(index, parameter);
		}

		internal int IndexOf(MimeParameter parameter)
		{
			return base.List.IndexOf(parameter);
		}

		internal bool Contains(MimeParameter parameter)
		{
			return base.List.Contains(parameter);
		}

		internal void Remove(MimeParameter parameter)
		{
			base.List.Remove(parameter);
		}

		internal void CopyTo(MimeParameter[] array, int index)
		{
			base.List.CopyTo(array, index);
		}
	}
	internal class MimeReturn
	{
		private string typeName;

		private Type readerType;

		private CodeAttributeDeclarationCollection attrs;

		internal string TypeName
		{
			get
			{
				if (typeName != null)
				{
					return typeName;
				}
				return string.Empty;
			}
			set
			{
				typeName = value;
			}
		}

		internal Type ReaderType
		{
			get
			{
				return readerType;
			}
			set
			{
				readerType = value;
			}
		}

		internal CodeAttributeDeclarationCollection Attributes
		{
			get
			{
				if (attrs == null)
				{
					attrs = new CodeAttributeDeclarationCollection();
				}
				return attrs;
			}
		}
	}
	internal class MimeTextReturn : MimeReturn
	{
		private MimeTextBinding textBinding;

		internal MimeTextBinding TextBinding
		{
			get
			{
				return textBinding;
			}
			set
			{
				textBinding = value;
			}
		}
	}
	internal class MimeTextImporter : MimeImporter
	{
		private string methodName;

		internal override MimeParameterCollection ImportParameters()
		{
			return null;
		}

		internal override MimeReturn ImportReturn()
		{
			MimeTextBinding mimeTextBinding = (MimeTextBinding)base.ImportContext.OperationBinding.Output.Extensions.Find(typeof(MimeTextBinding));
			if (mimeTextBinding == null)
			{
				return null;
			}
			if (mimeTextBinding.Matches.Count == 0)
			{
				base.ImportContext.UnsupportedOperationBindingWarning(Res.GetString("MissingMatchElement0"));
				return null;
			}
			methodName = CodeIdentifier.MakeValid(base.ImportContext.OperationBinding.Name);
			MimeTextReturn mimeTextReturn = new MimeTextReturn();
			mimeTextReturn.TypeName = base.ImportContext.ClassNames.AddUnique(methodName + "Matches", mimeTextBinding);
			mimeTextReturn.TextBinding = mimeTextBinding;
			mimeTextReturn.ReaderType = typeof(TextReturnReader);
			return mimeTextReturn;
		}

		internal override void GenerateCode(MimeReturn[] importedReturns, MimeParameterCollection[] importedParameters)
		{
			for (int i = 0; i < importedReturns.Length; i++)
			{
				if (importedReturns[i] is MimeTextReturn)
				{
					GenerateCode((MimeTextReturn)importedReturns[i], base.ImportContext.ServiceImporter.CodeGenerationOptions);
				}
			}
		}

		private void GenerateCode(MimeTextReturn importedReturn, CodeGenerationOptions options)
		{
			GenerateCode(importedReturn.TypeName, importedReturn.TextBinding.Matches, options);
		}

		private void GenerateCode(string typeName, MimeTextMatchCollection matches, CodeGenerationOptions options)
		{
			CodeIdentifiers codeIdentifiers = new CodeIdentifiers();
			CodeTypeDeclaration codeClass = WebCodeGenerator.AddClass(base.ImportContext.CodeNamespace, typeName, string.Empty, new string[0], null, CodeFlags.IsPublic, base.ImportContext.ServiceImporter.CodeGenerator.Supports(GeneratorSupport.PartialTypes));
			string[] array = new string[matches.Count];
			for (int i = 0; i < matches.Count; i++)
			{
				MimeTextMatch mimeTextMatch = matches[i];
				string text = codeIdentifiers.AddUnique(CodeIdentifier.MakeValid((mimeTextMatch.Name.Length == 0) ? (methodName + "Match") : mimeTextMatch.Name), mimeTextMatch);
				CodeAttributeDeclarationCollection metadata = new CodeAttributeDeclarationCollection();
				if (mimeTextMatch.Pattern.Length == 0)
				{
					throw new ArgumentException(Res.GetString("WebTextMatchMissingPattern"));
				}
				CodeExpression codeExpression = new CodePrimitiveExpression(mimeTextMatch.Pattern);
				int num = 0;
				if (mimeTextMatch.Group != 1)
				{
					num++;
				}
				if (mimeTextMatch.Capture != 0)
				{
					num++;
				}
				if (mimeTextMatch.IgnoreCase)
				{
					num++;
				}
				if (mimeTextMatch.Repeats != 1 && mimeTextMatch.Repeats != int.MaxValue)
				{
					num++;
				}
				CodeExpression[] array2 = new CodeExpression[num];
				string[] array3 = new string[array2.Length];
				num = 0;
				if (mimeTextMatch.Group != 1)
				{
					array2[num] = new CodePrimitiveExpression(mimeTextMatch.Group);
					array3[num] = "Group";
					num++;
				}
				if (mimeTextMatch.Capture != 0)
				{
					array2[num] = new CodePrimitiveExpression(mimeTextMatch.Capture);
					array3[num] = "Capture";
					num++;
				}
				if (mimeTextMatch.IgnoreCase)
				{
					array2[num] = new CodePrimitiveExpression(mimeTextMatch.IgnoreCase);
					array3[num] = "IgnoreCase";
					num++;
				}
				if (mimeTextMatch.Repeats != 1 && mimeTextMatch.Repeats != int.MaxValue)
				{
					array2[num] = new CodePrimitiveExpression(mimeTextMatch.Repeats);
					array3[num] = "MaxRepeats";
					num++;
				}
				WebCodeGenerator.AddCustomAttribute(metadata, typeof(MatchAttribute), new CodeExpression[1] { codeExpression }, array3, array2);
				string text2 = ((mimeTextMatch.Matches.Count <= 0) ? typeof(string).FullName : (array[i] = base.ImportContext.ClassNames.AddUnique(CodeIdentifier.MakeValid((mimeTextMatch.Type.Length == 0) ? text : mimeTextMatch.Type), mimeTextMatch)));
				if (mimeTextMatch.Repeats != 1)
				{
					text2 += "[]";
				}
				CodeTypeMember codeTypeMember = WebCodeGenerator.AddMember(codeClass, text2, text, null, metadata, CodeFlags.IsPublic, options);
				if (mimeTextMatch.Matches.Count == 0 && mimeTextMatch.Type.Length > 0)
				{
					base.ImportContext.Warnings |= ServiceDescriptionImportWarnings.OptionalExtensionsIgnored;
					ProtocolImporter.AddWarningComment(codeTypeMember.Comments, Res.GetString("WebTextMatchIgnoredTypeWarning"));
				}
			}
			for (int j = 0; j < array.Length; j++)
			{
				string text3 = array[j];
				if (text3 != null)
				{
					GenerateCode(text3, matches[j].Matches, options);
				}
			}
		}
	}
	internal class MimeXmlReturn : MimeReturn
	{
		private XmlTypeMapping mapping;

		internal XmlTypeMapping TypeMapping
		{
			get
			{
				return mapping;
			}
			set
			{
				mapping = value;
			}
		}
	}
	internal class MimeXmlImporter : MimeImporter
	{
		private XmlSchemaImporter importer;

		private XmlCodeExporter exporter;

		private XmlSchemaImporter Importer
		{
			get
			{
				if (importer == null)
				{
					importer = new XmlSchemaImporter(base.ImportContext.ConcreteSchemas, base.ImportContext.ServiceImporter.CodeGenerationOptions, base.ImportContext.ServiceImporter.CodeGenerator, base.ImportContext.ImportContext);
					foreach (Type extension in base.ImportContext.ServiceImporter.Extensions)
					{
						importer.Extensions.Add(extension.FullName, extension);
					}
					importer.Extensions.Add(new TypedDataSetSchemaImporterExtension());
					importer.Extensions.Add(new DataSetSchemaImporterExtension());
				}
				return importer;
			}
		}

		private XmlCodeExporter Exporter
		{
			get
			{
				if (exporter == null)
				{
					exporter = new XmlCodeExporter(base.ImportContext.CodeNamespace, base.ImportContext.ServiceImporter.CodeCompileUnit, base.ImportContext.ServiceImporter.CodeGenerator, base.ImportContext.ServiceImporter.CodeGenerationOptions, base.ImportContext.ExportContext);
				}
				return exporter;
			}
		}

		internal override MimeParameterCollection ImportParameters()
		{
			return null;
		}

		internal override MimeReturn ImportReturn()
		{
			MimeContentBinding mimeContentBinding = (MimeContentBinding)base.ImportContext.OperationBinding.Output.Extensions.Find(typeof(MimeContentBinding));
			if (mimeContentBinding != null)
			{
				if (!ContentType.MatchesBase(mimeContentBinding.Type, "text/xml"))
				{
					return null;
				}
				MimeReturn mimeReturn = new MimeReturn();
				mimeReturn.TypeName = typeof(XmlElement).FullName;
				mimeReturn.ReaderType = typeof(XmlReturnReader);
				return mimeReturn;
			}
			MimeXmlBinding mimeXmlBinding = (MimeXmlBinding)base.ImportContext.OperationBinding.Output.Extensions.Find(typeof(MimeXmlBinding));
			if (mimeXmlBinding != null)
			{
				MimeXmlReturn mimeXmlReturn = new MimeXmlReturn();
				MessagePart messagePart = base.ImportContext.OutputMessage.Parts.Count switch
				{
					0 => throw new InvalidOperationException(Res.GetString("MessageHasNoParts1", base.ImportContext.InputMessage.Name)), 
					1 => (mimeXmlBinding.Part != null && mimeXmlBinding.Part.Length != 0) ? base.ImportContext.OutputMessage.FindPartByName(mimeXmlBinding.Part) : base.ImportContext.OutputMessage.Parts[0], 
					_ => base.ImportContext.OutputMessage.FindPartByName(mimeXmlBinding.Part), 
				};
				mimeXmlReturn.TypeMapping = Importer.ImportTypeMapping(messagePart.Element);
				mimeXmlReturn.TypeName = mimeXmlReturn.TypeMapping.TypeFullName;
				mimeXmlReturn.ReaderType = typeof(XmlReturnReader);
				Exporter.AddMappingMetadata(mimeXmlReturn.Attributes, mimeXmlReturn.TypeMapping, string.Empty);
				return mimeXmlReturn;
			}
			return null;
		}

		internal override void GenerateCode(MimeReturn[] importedReturns, MimeParameterCollection[] importedParameters)
		{
			for (int i = 0; i < importedReturns.Length; i++)
			{
				if (importedReturns[i] is MimeXmlReturn)
				{
					GenerateCode((MimeXmlReturn)importedReturns[i]);
				}
			}
		}

		private void GenerateCode(MimeXmlReturn importedReturn)
		{
			Exporter.ExportTypeMapping(importedReturn.TypeMapping);
		}

		internal override void AddClassMetadata(CodeTypeDeclaration codeClass)
		{
			foreach (CodeAttributeDeclaration includeMetadatum in Exporter.IncludeMetadata)
			{
				codeClass.CustomAttributes.Add(includeMetadatum);
			}
		}
	}
	internal class MimeXmlReflector : MimeReflector
	{
		internal override bool ReflectParameters()
		{
			return false;
		}

		internal override bool ReflectReturn()
		{
			MessagePart messagePart = new MessagePart();
			messagePart.Name = "Body";
			base.ReflectionContext.OutputMessage.Parts.Add(messagePart);
			if (typeof(XmlNode).IsAssignableFrom(base.ReflectionContext.Method.ReturnType))
			{
				MimeContentBinding mimeContentBinding = new MimeContentBinding();
				mimeContentBinding.Type = "text/xml";
				mimeContentBinding.Part = messagePart.Name;
				base.ReflectionContext.OperationBinding.Output.Extensions.Add(mimeContentBinding);
			}
			else
			{
				MimeXmlBinding mimeXmlBinding = new MimeXmlBinding();
				mimeXmlBinding.Part = messagePart.Name;
				LogicalMethodInfo method = base.ReflectionContext.Method;
				XmlAttributes xmlAttributes = new XmlAttributes(method.ReturnTypeCustomAttributeProvider);
				XmlTypeMapping xmlTypeMapping = base.ReflectionContext.ReflectionImporter.ImportTypeMapping(method.ReturnType, xmlAttributes.XmlRoot);
				xmlTypeMapping.SetKey(method.GetKey() + ":Return");
				base.ReflectionContext.SchemaExporter.ExportTypeMapping(xmlTypeMapping);
				messagePart.Element = new XmlQualifiedName(xmlTypeMapping.XsdElementName, xmlTypeMapping.Namespace);
				base.ReflectionContext.OperationBinding.Output.Extensions.Add(mimeXmlBinding);
			}
			return true;
		}
	}
	internal class ProtocolImporterUtil
	{
		private ProtocolImporterUtil()
		{
		}

		internal static void GenerateConstructorStatements(CodeConstructor ctor, string url, string appSettingUrlKey, string appSettingBaseUrl, bool soap11)
		{
			bool flag = url != null && url.Length > 0;
			bool flag2 = appSettingUrlKey != null && appSettingUrlKey.Length > 0;
			CodeAssignStatement codeAssignStatement = null;
			if (!flag && !flag2)
			{
				return;
			}
			CodePropertyReferenceExpression left = new CodePropertyReferenceExpression(new CodeThisReferenceExpression(), "Url");
			if (flag)
			{
				CodeExpression right = new CodePrimitiveExpression(url);
				codeAssignStatement = new CodeAssignStatement(left, right);
			}
			if (flag && !flag2)
			{
				ctor.Statements.Add(codeAssignStatement);
			}
			else
			{
				if (!flag2)
				{
					return;
				}
				CodeVariableReferenceExpression codeVariableReferenceExpression = new CodeVariableReferenceExpression("urlSetting");
				CodeTypeReferenceExpression targetObject = new CodeTypeReferenceExpression(typeof(ConfigurationManager));
				CodePropertyReferenceExpression targetObject2 = new CodePropertyReferenceExpression(targetObject, "AppSettings");
				CodeExpression right = new CodeIndexerExpression(targetObject2, new CodePrimitiveExpression(appSettingUrlKey));
				ctor.Statements.Add(new CodeVariableDeclarationStatement(typeof(string), "urlSetting", right));
				if (appSettingBaseUrl == null || appSettingBaseUrl.Length == 0)
				{
					right = codeVariableReferenceExpression;
				}
				else
				{
					if (url == null || url.Length == 0)
					{
						throw new ArgumentException(Res.GetString("IfAppSettingBaseUrlArgumentIsSpecifiedThen0"));
					}
					string value = new Uri(appSettingBaseUrl).MakeRelative(new Uri(url));
					CodeExpression[] parameters = new CodeExpression[2]
					{
						codeVariableReferenceExpression,
						new CodePrimitiveExpression(value)
					};
					right = new CodeMethodInvokeExpression(new CodeTypeReferenceExpression(typeof(string)), "Concat", parameters);
				}
				CodeStatement[] trueStatements = new CodeStatement[1]
				{
					new CodeAssignStatement(left, right)
				};
				CodeBinaryOperatorExpression condition = new CodeBinaryOperatorExpression(codeVariableReferenceExpression, CodeBinaryOperatorType.IdentityInequality, new CodePrimitiveExpression(null));
				if (flag)
				{
					ctor.Statements.Add(new CodeConditionStatement(condition, trueStatements, new CodeStatement[1] { codeAssignStatement }));
				}
				else
				{
					ctor.Statements.Add(new CodeConditionStatement(condition, trueStatements));
				}
			}
		}
	}
	internal class DelegateInfo
	{
		internal string handlerType;

		internal string handlerArgs;

		internal DelegateInfo(string handlerType, string handlerArgs)
		{
			this.handlerType = handlerType;
			this.handlerArgs = handlerArgs;
		}
	}
	internal class SchemaCompiler
	{
		private static StringCollection warnings;

		internal static StringCollection Warnings
		{
			get
			{
				if (warnings == null)
				{
					warnings = new StringCollection();
				}
				return warnings;
			}
		}

		internal static StringCollection Compile(XmlSchemas schemas)
		{
			AddImports(schemas);
			Warnings.Clear();
			schemas.Compile(ValidationCallbackWithErrorCode, fullCompile: true);
			return Warnings;
		}

		private static void AddImport(XmlSchema schema, string ns)
		{
			if (schema.TargetNamespace == ns)
			{
				return;
			}
			foreach (XmlSchemaExternal include in schema.Includes)
			{
				if (include is XmlSchemaImport xmlSchemaImport && xmlSchemaImport.Namespace == ns)
				{
					return;
				}
			}
			XmlSchemaImport xmlSchemaImport2 = new XmlSchemaImport();
			xmlSchemaImport2.Namespace = ns;
			schema.Includes.Add(xmlSchemaImport2);
		}

		private static void AddImports(XmlSchemas schemas)
		{
			foreach (XmlSchema schema in schemas)
			{
				AddImport(schema, "http://schemas.xmlsoap.org/soap/encoding/");
				AddImport(schema, "http://schemas.xmlsoap.org/wsdl/");
			}
		}

		internal static string WarningDetails(XmlSchemaException exception, string message)
		{
			XmlSchemaObject xmlSchemaObject = exception.SourceSchemaObject;
			if (exception.LineNumber == 0 && exception.LinePosition == 0)
			{
				return GetSchemaItem(xmlSchemaObject, null, message);
			}
			string text = null;
			if (xmlSchemaObject != null)
			{
				while (xmlSchemaObject.Parent != null)
				{
					xmlSchemaObject = xmlSchemaObject.Parent;
				}
				if (xmlSchemaObject is XmlSchema)
				{
					text = ((XmlSchema)xmlSchemaObject).TargetNamespace;
				}
			}
			return Res.GetString("SchemaSyntaxErrorDetails", text, message, exception.LineNumber, exception.LinePosition);
		}

		private static string GetSchemaItem(XmlSchemaObject o, string ns, string details)
		{
			if (o == null)
			{
				return null;
			}
			while (o.Parent != null && !(o.Parent is XmlSchema))
			{
				o = o.Parent;
			}
			if (ns == null || ns.Length == 0)
			{
				XmlSchemaObject xmlSchemaObject = o;
				while (xmlSchemaObject.Parent != null)
				{
					xmlSchemaObject = xmlSchemaObject.Parent;
				}
				if (xmlSchemaObject is XmlSchema)
				{
					ns = ((XmlSchema)xmlSchemaObject).TargetNamespace;
				}
			}
			string text = null;
			if (o is XmlSchemaNotation)
			{
				return Res.GetString("XmlSchemaNamedItem", ns, "notation", ((XmlSchemaNotation)o).Name, details);
			}
			if (o is XmlSchemaGroup)
			{
				return Res.GetString("XmlSchemaNamedItem", ns, "group", ((XmlSchemaGroup)o).Name, details);
			}
			if (o is XmlSchemaElement)
			{
				XmlSchemaElement xmlSchemaElement = (XmlSchemaElement)o;
				if (xmlSchemaElement.Name == null || xmlSchemaElement.Name.Length == 0)
				{
					XmlQualifiedName parentName = GetParentName(o);
					return Res.GetString("XmlSchemaElementReference", xmlSchemaElement.RefName.ToString(), parentName.Name, parentName.Namespace);
				}
				return Res.GetString("XmlSchemaNamedItem", ns, "element", xmlSchemaElement.Name, details);
			}
			if (o is XmlSchemaType)
			{
				return Res.GetString("XmlSchemaNamedItem", ns, (o.GetType() == typeof(XmlSchemaSimpleType)) ? "simpleType" : "complexType", ((XmlSchemaType)o).Name, details);
			}
			if (o is XmlSchemaAttributeGroup)
			{
				return Res.GetString("XmlSchemaNamedItem", ns, "attributeGroup", ((XmlSchemaAttributeGroup)o).Name, details);
			}
			if (o is XmlSchemaAttribute)
			{
				XmlSchemaAttribute xmlSchemaAttribute = (XmlSchemaAttribute)o;
				if (xmlSchemaAttribute.Name == null || xmlSchemaAttribute.Name.Length == 0)
				{
					XmlQualifiedName parentName2 = GetParentName(o);
					return Res.GetString("XmlSchemaAttributeReference", xmlSchemaAttribute.RefName.ToString(), parentName2.Name, parentName2.Namespace);
				}
				return Res.GetString("XmlSchemaNamedItem", ns, "attribute", xmlSchemaAttribute.Name, details);
			}
			if (o is XmlSchemaContent)
			{
				XmlQualifiedName parentName3 = GetParentName(o);
				return Res.GetString("XmlSchemaContentDef", parentName3.Name, parentName3.Namespace, details);
			}
			if (o is XmlSchemaExternal)
			{
				string text2 = ((o is XmlSchemaImport) ? "import" : ((o is XmlSchemaInclude) ? "include" : ((o is XmlSchemaRedefine) ? "redefine" : o.GetType().Name)));
				return Res.GetString("XmlSchemaItem", ns, text2, details);
			}
			if (o is XmlSchema)
			{
				return Res.GetString("XmlSchema", ns, details);
			}
			return Res.GetString("XmlSchemaNamedItem", ns, o.GetType().Name, null, details);
		}

		internal static XmlQualifiedName GetParentName(XmlSchemaObject item)
		{
			while (item.Parent != null)
			{
				if (item.Parent is XmlSchemaType)
				{
					XmlSchemaType xmlSchemaType = (XmlSchemaType)item.Parent;
					if (xmlSchemaType.Name != null && xmlSchemaType.Name.Length != 0)
					{
						return xmlSchemaType.QualifiedName;
					}
				}
				item = item.Parent;
			}
			return XmlQualifiedName.Empty;
		}

		private static void ValidationCallbackWithErrorCode(object sender, ValidationEventArgs args)
		{
			Warnings.Add(Res.GetString((args.Severity == XmlSeverityType.Error) ? "SchemaValidationError" : "SchemaValidationWarning", WarningDetails(args.Exception, args.Message)));
		}
	}
	public abstract class DocumentableItem
	{
		private XmlDocument parent;

		private string documentation;

		private XmlElement documentationElement;

		private XmlAttribute[] anyAttribute;

		private XmlSerializerNamespaces namespaces;

		[XmlIgnore]
		public string Documentation
		{
			get
			{
				if (documentation != null)
				{
					return documentation;
				}
				if (documentationElement == null)
				{
					return string.Empty;
				}
				return documentationElement.InnerXml;
			}
			set
			{
				documentation = value;
				StringWriter stringWriter = new StringWriter(CultureInfo.InvariantCulture);
				XmlTextWriter xmlTextWriter = new XmlTextWriter(stringWriter);
				xmlTextWriter.WriteElementString("wsdl", "documentation", "http://schemas.xmlsoap.org/wsdl/", value);
				Parent.LoadXml(stringWriter.ToString());
				documentationElement = parent.DocumentElement;
				xmlTextWriter.Close();
			}
		}

		[ComVisible(false)]
		[XmlAnyElement("documentation", Namespace = "http://schemas.xmlsoap.org/wsdl/")]
		public XmlElement DocumentationElement
		{
			get
			{
				return documentationElement;
			}
			set
			{
				documentationElement = value;
				documentation = null;
			}
		}

		[XmlAnyAttribute]
		public XmlAttribute[] ExtensibleAttributes
		{
			get
			{
				return anyAttribute;
			}
			set
			{
				anyAttribute = value;
			}
		}

		[XmlNamespaceDeclarations]
		public XmlSerializerNamespaces Namespaces
		{
			get
			{
				if (namespaces == null)
				{
					namespaces = new XmlSerializerNamespaces();
				}
				return namespaces;
			}
			set
			{
				namespaces = value;
			}
		}

		[XmlIgnore]
		public abstract ServiceDescriptionFormatExtensionCollection Extensions { get; }

		internal XmlDocument Parent
		{
			get
			{
				if (parent == null)
				{
					parent = new XmlDocument();
				}
				return parent;
			}
		}

		internal XmlElement GetDocumentationElement()
		{
			if (documentationElement == null)
			{
				documentationElement = Parent.CreateElement("wsdl", "documentation", "http://schemas.xmlsoap.org/wsdl/");
				Parent.InsertBefore(documentationElement, null);
			}
			return documentationElement;
		}
	}
	public abstract class NamedItem : DocumentableItem
	{
		private string name;

		[XmlAttribute("name")]
		public string Name
		{
			get
			{
				return name;
			}
			set
			{
				name = value;
			}
		}
	}
	[XmlRoot("definitions", Namespace = "http://schemas.xmlsoap.org/wsdl/")]
	[XmlFormatExtensionPoint("Extensions")]
	public sealed class ServiceDescription : NamedItem
	{
		internal class ServiceDescriptionSerializer : XmlSerializer
		{
			protected override XmlSerializationReader CreateReader()
			{
				return new ServiceDescriptionSerializationReader();
			}

			protected override XmlSerializationWriter CreateWriter()
			{
				return new ServiceDescriptionSerializationWriter();
			}

			public override bool CanDeserialize(XmlReader xmlReader)
			{
				return xmlReader.IsStartElement("definitions", "http://schemas.xmlsoap.org/wsdl/");
			}

			protected override void Serialize(object objectToSerialize, XmlSerializationWriter writer)
			{
				((ServiceDescriptionSerializationWriter)writer).Write125_definitions(objectToSerialize);
			}

			protected override object Deserialize(XmlSerializationReader reader)
			{
				return ((ServiceDescriptionSerializationReader)reader).Read125_definitions();
			}
		}

		public const string Namespace = "http://schemas.xmlsoap.org/wsdl/";

		internal const string Prefix = "wsdl";

		private const WsiProfiles SupportedClaims = WsiProfiles.BasicProfile1_1;

		private Types types;

		private ImportCollection imports;

		private MessageCollection messages;

		private PortTypeCollection portTypes;

		private BindingCollection bindings;

		private ServiceCollection services;

		private string targetNamespace;

		private ServiceDescriptionFormatExtensionCollection extensions;

		private ServiceDescriptionCollection parent;

		private string appSettingUrlKey;

		private string appSettingBaseUrl;

		private string retrievalUrl;

		private static XmlSerializer serializer;

		private static XmlSerializerNamespaces namespaces;

		private static XmlSchema schema = null;

		private static XmlSchema soapEncodingSchema = null;

		private StringCollection validationWarnings;

		private static StringCollection warnings = new StringCollection();

		private ServiceDescription next;

		[XmlIgnore]
		public string RetrievalUrl
		{
			get
			{
				if (retrievalUrl != null)
				{
					return retrievalUrl;
				}
				return string.Empty;
			}
			set
			{
				retrievalUrl = value;
			}
		}

		[XmlIgnore]
		public ServiceDescriptionCollection ServiceDescriptions => parent;

		[XmlIgnore]
		public override ServiceDescriptionFormatExtensionCollection Extensions
		{
			get
			{
				if (extensions == null)
				{
					extensions = new ServiceDescriptionFormatExtensionCollection(this);
				}
				return extensions;
			}
		}

		[XmlElement("import")]
		public ImportCollection Imports
		{
			get
			{
				if (imports == null)
				{
					imports = new ImportCollection(this);
				}
				return imports;
			}
		}

		[XmlElement("types")]
		public Types Types
		{
			get
			{
				if (types == null)
				{
					types = new Types();
				}
				return types;
			}
			set
			{
				types = value;
			}
		}

		[XmlElement("message")]
		public MessageCollection Messages
		{
			get
			{
				if (messages == null)
				{
					messages = new MessageCollection(this);
				}
				return messages;
			}
		}

		[XmlElement("portType")]
		public PortTypeCollection PortTypes
		{
			get
			{
				if (portTypes == null)
				{
					portTypes = new PortTypeCollection(this);
				}
				return portTypes;
			}
		}

		[XmlElement("binding")]
		public BindingCollection Bindings
		{
			get
			{
				if (bindings == null)
				{
					bindings = new BindingCollection(this);
				}
				return bindings;
			}
		}

		[XmlElement("service")]
		public ServiceCollection Services
		{
			get
			{
				if (services == null)
				{
					services = new ServiceCollection(this);
				}
				return services;
			}
		}

		[XmlAttribute("targetNamespace")]
		public string TargetNamespace
		{
			get
			{
				return targetNamespace;
			}
			set
			{
				targetNamespace = value;
			}
		}

		public static XmlSchema Schema
		{
			get
			{
				if (schema == null)
				{
					schema = XmlSchema.Read(new StringReader("<?xml version='1.0' encoding='UTF-8' ?> \r\n<xs:schema xmlns:xs='http://www.w3.org/2001/XMLSchema'\r\n           xmlns:wsdl='http://schemas.xmlsoap.org/wsdl/'\r\n           targetNamespace='http://schemas.xmlsoap.org/wsdl/'\r\n           elementFormDefault='qualified' >\r\n   \r\n  <xs:complexType mixed='true' name='tDocumentation' >\r\n    <xs:sequence>\r\n      <xs:any minOccurs='0' maxOccurs='unbounded' processContents='lax' />\r\n    </xs:sequence>\r\n  </xs:complexType>\r\n\r\n  <xs:complexType name='tDocumented' >\r\n    <xs:annotation>\r\n      <xs:documentation>\r\n      This type is extended by  component types to allow them to be documented\r\n      </xs:documentation>\r\n    </xs:annotation>\r\n    <xs:sequence>\r\n      <xs:element name='documentation' type='wsdl:tDocumentation' minOccurs='0' />\r\n    </xs:sequence>\r\n  </xs:complexType>\r\n <!-- allow extensibility via elements and attributes on all elements swa124 -->\r\n <xs:complexType name='tExtensibleAttributesDocumented' abstract='true' >\r\n    <xs:complexContent>\r\n      <xs:extension base='wsdl:tDocumented' >\r\n        <xs:annotation>\r\n          <xs:documentation>\r\n          This type is extended by component types to allow attributes from other namespaces to be added.\r\n          </xs:documentation>\r\n        </xs:annotation>\r\n        <xs:sequence>\r\n          <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded' processContents='lax' />\r\n        </xs:sequence>\r\n        <xs:anyAttribute namespace='##other' processContents='lax' />   \r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n  <xs:complexType name='tExtensibleDocumented' abstract='true' >\r\n    <xs:complexContent>\r\n      <xs:extension base='wsdl:tDocumented' >\r\n        <xs:annotation>\r\n          <xs:documentation>\r\n          This type is extended by component types to allow elements from other namespaces to be added.\r\n          </xs:documentation>\r\n        </xs:annotation>\r\n        <xs:sequence>\r\n          <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded' processContents='lax' />\r\n        </xs:sequence>\r\n        <xs:anyAttribute namespace='##other' processContents='lax' />   \r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n  <!-- original wsdl removed as part of swa124 resolution\r\n  <xs:complexType name='tExtensibleAttributesDocumented' abstract='true' >\r\n    <xs:complexContent>\r\n      <xs:extension base='wsdl:tDocumented' >\r\n        <xs:annotation>\r\n          <xs:documentation>\r\n          This type is extended by component types to allow attributes from other namespaces to be added.\r\n          </xs:documentation>\r\n        </xs:annotation>\r\n        <xs:anyAttribute namespace='##other' processContents='lax' />    \r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n\r\n  <xs:complexType name='tExtensibleDocumented' abstract='true' >\r\n    <xs:complexContent>\r\n      <xs:extension base='wsdl:tDocumented' >\r\n        <xs:annotation>\r\n          <xs:documentation>\r\n          This type is extended by component types to allow elements from other namespaces to be added.\r\n          </xs:documentation>\r\n        </xs:annotation>\r\n        <xs:sequence>\r\n          <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded' processContents='lax' />\r\n        </xs:sequence>\r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n -->\r\n  <xs:element name='definitions' type='wsdl:tDefinitions' >\r\n    <xs:key name='message' >\r\n      <xs:selector xpath='wsdl:message' />\r\n      <xs:field xpath='@name' />\r\n    </xs:key>\r\n    <xs:key name='portType' >\r\n      <xs:selector xpath='wsdl:portType' />\r\n      <xs:field xpath='@name' />\r\n    </xs:key>\r\n    <xs:key name='binding' >\r\n      <xs:selector xpath='wsdl:binding' />\r\n      <xs:field xpath='@name' />\r\n    </xs:key>\r\n    <xs:key name='service' >\r\n      <xs:selector xpath='wsdl:service' />\r\n      <xs:field xpath='@name' />\r\n    </xs:key>\r\n    <xs:key name='import' >\r\n      <xs:selector xpath='wsdl:import' />\r\n      <xs:field xpath='@namespace' />\r\n    </xs:key>\r\n  </xs:element>\r\n\r\n  <xs:group name='anyTopLevelOptionalElement' >\r\n    <xs:annotation>\r\n      <xs:documentation>\r\n      Any top level optional element allowed to appear more then once - any child of definitions element except wsdl:types. Any extensibility element is allowed in any place.\r\n      </xs:documentation>\r\n    </xs:annotation>\r\n    <xs:choice>\r\n      <xs:element name='import' type='wsdl:tImport' />\r\n      <xs:element name='types' type='wsdl:tTypes' />                     \r\n      <xs:element name='message'  type='wsdl:tMessage' >\r\n        <xs:unique name='part' >\r\n          <xs:selector xpath='wsdl:part' />\r\n          <xs:field xpath='@name' />\r\n        </xs:unique>\r\n      </xs:element>\r\n      <xs:element name='portType' type='wsdl:tPortType' />\r\n      <xs:element name='binding'  type='wsdl:tBinding' />\r\n      <xs:element name='service'  type='wsdl:tService' >\r\n        <xs:unique name='port' >\r\n          <xs:selector xpath='wsdl:port' />\r\n          <xs:field xpath='@name' />\r\n        </xs:unique>\r\n\t  </xs:element>\r\n    </xs:choice>\r\n  </xs:group>\r\n\r\n  <xs:complexType name='tDefinitions' >\r\n    <xs:complexContent>\r\n      <xs:extension base='wsdl:tExtensibleDocumented' >\r\n        <xs:sequence>\r\n          <xs:group ref='wsdl:anyTopLevelOptionalElement'  minOccurs='0'   maxOccurs='unbounded' />\r\n        </xs:sequence>\r\n        <xs:attribute name='targetNamespace' type='xs:anyURI' use='optional' />\r\n        <xs:attribute name='name' type='xs:NCName' use='optional' />\r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n   \r\n  <xs:complexType name='tImport' >\r\n    <xs:complexContent>\r\n      <xs:extension base='wsdl:tExtensibleAttributesDocumented' >\r\n        <xs:attribute name='namespace' type='xs:anyURI' use='required' />\r\n        <xs:attribute name='location' type='xs:anyURI' use='required' />\r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n   \r\n  <xs:complexType name='tTypes' >\r\n    <xs:complexContent>   \r\n      <xs:extension base='wsdl:tExtensibleDocumented' />\r\n    </xs:complexContent>   \r\n  </xs:complexType>\r\n     \r\n  <xs:complexType name='tMessage' >\r\n    <xs:complexContent>   \r\n      <xs:extension base='wsdl:tExtensibleDocumented' >\r\n        <xs:sequence>\r\n          <xs:element name='part' type='wsdl:tPart' minOccurs='0' maxOccurs='unbounded' />\r\n        </xs:sequence>\r\n        <xs:attribute name='name' type='xs:NCName' use='required' />\r\n      </xs:extension>\r\n    </xs:complexContent>   \r\n  </xs:complexType>\r\n\r\n  <xs:complexType name='tPart' >\r\n    <xs:complexContent>   \r\n      <xs:extension base='wsdl:tExtensibleAttributesDocumented' >\r\n        <xs:attribute name='name' type='xs:NCName' use='required' />\r\n        <xs:attribute name='element' type='xs:QName' use='optional' />\r\n        <xs:attribute name='type' type='xs:QName' use='optional' />    \r\n      </xs:extension>\r\n    </xs:complexContent>   \r\n  </xs:complexType>\r\n\r\n  <xs:complexType name='tPortType' >\r\n    <xs:complexContent>   \r\n      <xs:extension base='wsdl:tExtensibleAttributesDocumented' >\r\n        <xs:sequence>\r\n          <xs:element name='operation' type='wsdl:tOperation' minOccurs='0' maxOccurs='unbounded' />\r\n        </xs:sequence>\r\n        <xs:attribute name='name' type='xs:NCName' use='required' />\r\n      </xs:extension>\r\n    </xs:complexContent>   \r\n  </xs:complexType>\r\n   \r\n  <xs:complexType name='tOperation' >\r\n    <xs:complexContent>   \r\n      <xs:extension base='wsdl:tExtensibleDocumented' >\r\n\t    <xs:sequence>\r\n          <xs:choice>\r\n            <xs:group ref='wsdl:request-response-or-one-way-operation' />\r\n            <xs:group ref='wsdl:solicit-response-or-notification-operation' />\r\n          </xs:choice>\r\n        </xs:sequence>\r\n        <xs:attribute name='name' type='xs:NCName' use='required' />\r\n        <xs:attribute name='parameterOrder' type='xs:NMTOKENS' use='optional' />\r\n      </xs:extension>\r\n    </xs:complexContent>   \r\n  </xs:complexType>\r\n    \r\n  <xs:group name='request-response-or-one-way-operation' >\r\n    <xs:sequence>\r\n      <xs:element name='input' type='wsdl:tParam' />\r\n\t  <xs:sequence minOccurs='0' >\r\n\t    <xs:element name='output' type='wsdl:tParam' />\r\n\t\t<xs:element name='fault' type='wsdl:tFault' minOccurs='0' maxOccurs='unbounded' />\r\n      </xs:sequence>\r\n    </xs:sequence>\r\n  </xs:group>\r\n\r\n  <xs:group name='solicit-response-or-notification-operation' >\r\n    <xs:sequence>\r\n      <xs:element name='output' type='wsdl:tParam' />\r\n\t  <xs:sequence minOccurs='0' >\r\n\t    <xs:element name='input' type='wsdl:tParam' />\r\n\t\t<xs:element name='fault' type='wsdl:tFault' minOccurs='0' maxOccurs='unbounded' />\r\n\t  </xs:sequence>\r\n    </xs:sequence>\r\n  </xs:group>\r\n        \r\n  <xs:complexType name='tParam' >\r\n    <xs:complexContent>\r\n      <xs:extension base='wsdl:tExtensibleAttributesDocumented' >\r\n        <xs:attribute name='name' type='xs:NCName' use='optional' />\r\n        <xs:attribute name='message' type='xs:QName' use='required' />\r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n\r\n  <xs:complexType name='tFault' >\r\n    <xs:complexContent>\r\n      <xs:extension base='wsdl:tExtensibleAttributesDocumented' >\r\n        <xs:attribute name='name' type='xs:NCName'  use='required' />\r\n        <xs:attribute name='message' type='xs:QName' use='required' />\r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n     \r\n  <xs:complexType name='tBinding' >\r\n    <xs:complexContent>\r\n      <xs:extension base='wsdl:tExtensibleDocumented' >\r\n        <xs:sequence>\r\n          <xs:element name='operation' type='wsdl:tBindingOperation' minOccurs='0' maxOccurs='unbounded' />\r\n        </xs:sequence>\r\n        <xs:attribute name='name' type='xs:NCName' use='required' />\r\n        <xs:attribute name='type' type='xs:QName' use='required' />\r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n    \r\n  <xs:complexType name='tBindingOperationMessage' >\r\n    <xs:complexContent>\r\n      <xs:extension base='wsdl:tExtensibleDocumented' >\r\n        <xs:attribute name='name' type='xs:NCName' use='optional' />\r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n  \r\n  <xs:complexType name='tBindingOperationFault' >\r\n    <xs:complexContent>\r\n      <xs:extension base='wsdl:tExtensibleDocumented' >\r\n        <xs:attribute name='name' type='xs:NCName' use='required' />\r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n\r\n  <xs:complexType name='tBindingOperation' >\r\n    <xs:complexContent>\r\n      <xs:extension base='wsdl:tExtensibleDocumented' >\r\n        <xs:sequence>\r\n          <xs:element name='input' type='wsdl:tBindingOperationMessage' minOccurs='0' />\r\n          <xs:element name='output' type='wsdl:tBindingOperationMessage' minOccurs='0' />\r\n          <xs:element name='fault' type='wsdl:tBindingOperationFault' minOccurs='0' maxOccurs='unbounded' />\r\n        </xs:sequence>\r\n        <xs:attribute name='name' type='xs:NCName' use='required' />\r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n     \r\n  <xs:complexType name='tService' >\r\n    <xs:complexContent>\r\n      <xs:extension base='wsdl:tExtensibleDocumented' >\r\n        <xs:sequence>\r\n          <xs:element name='port' type='wsdl:tPort' minOccurs='0' maxOccurs='unbounded' />\r\n        </xs:sequence>\r\n        <xs:attribute name='name' type='xs:NCName' use='required' />\r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n     \r\n  <xs:complexType name='tPort' >\r\n    <xs:complexContent>\r\n      <xs:extension base='wsdl:tExtensibleDocumented' >\r\n        <xs:attribute name='name' type='xs:NCName' use='required' />\r\n        <xs:attribute name='binding' type='xs:QName' use='required' />\r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n\r\n  <xs:attribute name='arrayType' type='xs:string' />\r\n  <xs:attribute name='required' type='xs:boolean' />\r\n  <xs:complexType name='tExtensibilityElement' abstract='true' >\r\n    <xs:attribute ref='wsdl:required' use='optional' />\r\n  </xs:complexType>\r\n\r\n</xs:schema>"), null);
				}
				return schema;
			}
		}

		internal static XmlSchema SoapEncodingSchema
		{
			get
			{
				if (soapEncodingSchema == null)
				{
					soapEncodingSchema = XmlSchema.Read(new StringReader("<?xml version='1.0' encoding='UTF-8' ?>\r\n<xs:schema xmlns:xs='http://www.w3.org/2001/XMLSchema'\r\n           xmlns:tns='http://schemas.xmlsoap.org/soap/encoding/'\r\n           targetNamespace='http://schemas.xmlsoap.org/soap/encoding/' >\r\n        \r\n <xs:attribute name='root' >\r\n   <xs:simpleType>\r\n     <xs:restriction base='xs:boolean'>\r\n\t   <xs:pattern value='0|1' />\r\n\t </xs:restriction>\r\n   </xs:simpleType>\r\n </xs:attribute>\r\n\r\n  <xs:attributeGroup name='commonAttributes' >\r\n    <xs:attribute name='id' type='xs:ID' />\r\n    <xs:attribute name='href' type='xs:anyURI' />\r\n    <xs:anyAttribute namespace='##other' processContents='lax' />\r\n  </xs:attributeGroup>\r\n   \r\n  <xs:simpleType name='arrayCoordinate' >\r\n    <xs:restriction base='xs:string' />\r\n  </xs:simpleType>\r\n          \r\n  <xs:attribute name='arrayType' type='xs:string' />\r\n  <xs:attribute name='offset' type='tns:arrayCoordinate' />\r\n  \r\n  <xs:attributeGroup name='arrayAttributes' >\r\n    <xs:attribute ref='tns:arrayType' />\r\n    <xs:attribute ref='tns:offset' />\r\n  </xs:attributeGroup>    \r\n  \r\n  <xs:attribute name='position' type='tns:arrayCoordinate' /> \r\n  \r\n  <xs:attributeGroup name='arrayMemberAttributes' >\r\n    <xs:attribute ref='tns:position' />\r\n  </xs:attributeGroup>    \r\n\r\n  <xs:group name='Array' >\r\n    <xs:sequence>\r\n      <xs:any namespace='##any' minOccurs='0' maxOccurs='unbounded' processContents='lax' />\r\n\t</xs:sequence>\r\n  </xs:group>\r\n\r\n  <xs:element name='Array' type='tns:Array' />\r\n  <xs:complexType name='Array' >\r\n    <xs:group ref='tns:Array' minOccurs='0' />\r\n    <xs:attributeGroup ref='tns:arrayAttributes' />\r\n    <xs:attributeGroup ref='tns:commonAttributes' />\r\n  </xs:complexType> \r\n  <xs:element name='Struct' type='tns:Struct' />\r\n  <xs:group name='Struct' >\r\n    <xs:sequence>\r\n      <xs:any namespace='##any' minOccurs='0' maxOccurs='unbounded' processContents='lax' />\r\n\t</xs:sequence>\r\n  </xs:group>\r\n\r\n  <xs:complexType name='Struct' >\r\n    <xs:group ref='tns:Struct' minOccurs='0' />\r\n    <xs:attributeGroup ref='tns:commonAttributes'/>\r\n  </xs:complexType> \r\n  \r\n  <xs:simpleType name='base64' >\r\n    <xs:restriction base='xs:base64Binary' />\r\n  </xs:simpleType>\r\n\r\n  <xs:element name='duration' type='tns:duration' />\r\n  <xs:complexType name='duration' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:duration' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='dateTime' type='tns:dateTime' />\r\n  <xs:complexType name='dateTime' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:dateTime' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n\r\n\r\n  <xs:element name='NOTATION' type='tns:NOTATION' />\r\n  <xs:complexType name='NOTATION' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:QName' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n  \r\n\r\n  <xs:element name='time' type='tns:time' />\r\n  <xs:complexType name='time' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:time' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='date' type='tns:date' />\r\n  <xs:complexType name='date' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:date' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='gYearMonth' type='tns:gYearMonth' />\r\n  <xs:complexType name='gYearMonth' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:gYearMonth' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='gYear' type='tns:gYear' />\r\n  <xs:complexType name='gYear' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:gYear' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='gMonthDay' type='tns:gMonthDay' />\r\n  <xs:complexType name='gMonthDay' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:gMonthDay' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='gDay' type='tns:gDay' />\r\n  <xs:complexType name='gDay' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:gDay' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='gMonth' type='tns:gMonth' />\r\n  <xs:complexType name='gMonth' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:gMonth' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n  \r\n  <xs:element name='boolean' type='tns:boolean' />\r\n  <xs:complexType name='boolean' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:boolean' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='base64Binary' type='tns:base64Binary' />\r\n  <xs:complexType name='base64Binary' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:base64Binary' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='hexBinary' type='tns:hexBinary' />\r\n  <xs:complexType name='hexBinary' >\r\n    <xs:simpleContent>\r\n     <xs:extension base='xs:hexBinary' >\r\n       <xs:attributeGroup ref='tns:commonAttributes' />\r\n     </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='float' type='tns:float' />\r\n  <xs:complexType name='float' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:float' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='double' type='tns:double' />\r\n  <xs:complexType name='double' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:double' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='anyURI' type='tns:anyURI' />\r\n  <xs:complexType name='anyURI' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:anyURI' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='QName' type='tns:QName' />\r\n  <xs:complexType name='QName' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:QName' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  \r\n  <xs:element name='string' type='tns:string' />\r\n  <xs:complexType name='string' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:string' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='normalizedString' type='tns:normalizedString' />\r\n  <xs:complexType name='normalizedString' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:normalizedString' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='token' type='tns:token' />\r\n  <xs:complexType name='token' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:token' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='language' type='tns:language' />\r\n  <xs:complexType name='language' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:language' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='Name' type='tns:Name' />\r\n  <xs:complexType name='Name' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:Name' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='NMTOKEN' type='tns:NMTOKEN' />\r\n  <xs:complexType name='NMTOKEN' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:NMTOKEN' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='NCName' type='tns:NCName' />\r\n  <xs:complexType name='NCName' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:NCName' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='NMTOKENS' type='tns:NMTOKENS' />\r\n  <xs:complexType name='NMTOKENS' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:NMTOKENS' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='ID' type='tns:ID' />\r\n  <xs:complexType name='ID' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:ID' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='IDREF' type='tns:IDREF' />\r\n  <xs:complexType name='IDREF' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:IDREF' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='ENTITY' type='tns:ENTITY' />\r\n  <xs:complexType name='ENTITY' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:ENTITY' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='IDREFS' type='tns:IDREFS' />\r\n  <xs:complexType name='IDREFS' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:IDREFS' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='ENTITIES' type='tns:ENTITIES' />\r\n  <xs:complexType name='ENTITIES' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:ENTITIES' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='decimal' type='tns:decimal' />\r\n  <xs:complexType name='decimal' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:decimal' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='integer' type='tns:integer' />\r\n  <xs:complexType name='integer' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:integer' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='nonPositiveInteger' type='tns:nonPositiveInteger' />\r\n  <xs:complexType name='nonPositiveInteger' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:nonPositiveInteger' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='negativeInteger' type='tns:negativeInteger' />\r\n  <xs:complexType name='negativeInteger' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:negativeInteger' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='long' type='tns:long' />\r\n  <xs:complexType name='long' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:long' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='int' type='tns:int' />\r\n  <xs:complexType name='int' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:int' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='short' type='tns:short' />\r\n  <xs:complexType name='short' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:short' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='byte' type='tns:byte' />\r\n  <xs:complexType name='byte' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:byte' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='nonNegativeInteger' type='tns:nonNegativeInteger' />\r\n  <xs:complexType name='nonNegativeInteger' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:nonNegativeInteger' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='unsignedLong' type='tns:unsignedLong' />\r\n  <xs:complexType name='unsignedLong' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:unsignedLong' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='unsignedInt' type='tns:unsignedInt' />\r\n  <xs:complexType name='unsignedInt' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:unsignedInt' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='unsignedShort' type='tns:unsignedShort' />\r\n  <xs:complexType name='unsignedShort' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:unsignedShort' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='unsignedByte' type='tns:unsignedByte' />\r\n  <xs:complexType name='unsignedByte' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:unsignedByte' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='positiveInteger' type='tns:positiveInteger' />\r\n  <xs:complexType name='positiveInteger' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:positiveInteger' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='anyType' />\r\n</xs:schema>"), null);
				}
				return soapEncodingSchema;
			}
		}

		[XmlIgnore]
		public StringCollection ValidationWarnings
		{
			get
			{
				if (validationWarnings == null)
				{
					validationWarnings = new StringCollection();
				}
				return validationWarnings;
			}
		}

		[XmlIgnore]
		public static XmlSerializer Serializer
		{
			get
			{
				if (serializer == null)
				{
					WebServicesSection current = WebServicesSection.Current;
					XmlAttributeOverrides overrides = new XmlAttributeOverrides();
					XmlSerializerNamespaces xmlSerializerNamespaces = new XmlSerializerNamespaces();
					xmlSerializerNamespaces.Add("s", "http://www.w3.org/2001/XMLSchema");
					WebServicesSection.LoadXmlFormatExtensions(current.GetAllFormatExtensionTypes(), overrides, xmlSerializerNamespaces);
					namespaces = xmlSerializerNamespaces;
					if (current.ServiceDescriptionExtended)
					{
						serializer = new XmlSerializer(typeof(ServiceDescription), overrides);
					}
					else
					{
						serializer = new ServiceDescriptionSerializer();
					}
					serializer.UnknownElement += RuntimeUtils.OnUnknownElement;
				}
				return serializer;
			}
		}

		internal string AppSettingBaseUrl
		{
			get
			{
				return appSettingBaseUrl;
			}
			set
			{
				appSettingBaseUrl = value;
			}
		}

		internal string AppSettingUrlKey
		{
			get
			{
				return appSettingUrlKey;
			}
			set
			{
				appSettingUrlKey = value;
			}
		}

		internal ServiceDescription Next
		{
			get
			{
				return next;
			}
			set
			{
				next = value;
			}
		}

		private static void InstanceValidation(object sender, ValidationEventArgs args)
		{
			warnings.Add(Res.GetString("WsdlInstanceValidationDetails", args.Message, args.Exception.LineNumber.ToString(CultureInfo.InvariantCulture), args.Exception.LinePosition.ToString(CultureInfo.InvariantCulture)));
		}

		internal void SetParent(ServiceDescriptionCollection parent)
		{
			this.parent = parent;
		}

		private bool ShouldSerializeTypes()
		{
			return Types.HasItems();
		}

		internal void SetWarnings(StringCollection warnings)
		{
			validationWarnings = warnings;
		}

		public static ServiceDescription Read(TextReader textReader)
		{
			return Read(textReader, validate: false);
		}

		public static ServiceDescription Read(Stream stream)
		{
			return Read(stream, validate: false);
		}

		public static ServiceDescription Read(XmlReader reader)
		{
			return Read(reader, validate: false);
		}

		public static ServiceDescription Read(string fileName)
		{
			return Read(fileName, validate: false);
		}

		public static ServiceDescription Read(TextReader textReader, bool validate)
		{
			XmlTextReader xmlTextReader = new XmlTextReader(textReader);
			xmlTextReader.WhitespaceHandling = WhitespaceHandling.Significant;
			xmlTextReader.XmlResolver = null;
			xmlTextReader.ProhibitDtd = true;
			return Read(xmlTextReader, validate);
		}

		public static ServiceDescription Read(Stream stream, bool validate)
		{
			XmlTextReader xmlTextReader = new XmlTextReader(stream);
			xmlTextReader.WhitespaceHandling = WhitespaceHandling.Significant;
			xmlTextReader.XmlResolver = null;
			xmlTextReader.ProhibitDtd = true;
			return Read(xmlTextReader, validate);
		}

		public static ServiceDescription Read(string fileName, bool validate)
		{
			StreamReader streamReader = new StreamReader(fileName, Encoding.Default, detectEncodingFromByteOrderMarks: true);
			try
			{
				return Read(streamReader, validate);
			}
			finally
			{
				streamReader.Close();
			}
		}

		public static ServiceDescription Read(XmlReader reader, bool validate)
		{
			if (validate)
			{
				XmlReaderSettings xmlReaderSettings = new XmlReaderSettings();
				xmlReaderSettings.ValidationType = ValidationType.Schema;
				xmlReaderSettings.ValidationFlags = XmlSchemaValidationFlags.ProcessIdentityConstraints;
				xmlReaderSettings.Schemas.Add(Schema);
				xmlReaderSettings.Schemas.Add(SoapBinding.Schema);
				xmlReaderSettings.ValidationEventHandler += InstanceValidation;
				warnings.Clear();
				XmlReader xmlReader = XmlReader.Create(reader, xmlReaderSettings);
				if (reader.ReadState != 0)
				{
					xmlReader.Read();
				}
				ServiceDescription serviceDescription = (ServiceDescription)Serializer.Deserialize(xmlReader);
				serviceDescription.SetWarnings(warnings);
				return serviceDescription;
			}
			return (ServiceDescription)Serializer.Deserialize(reader);
		}

		public static bool CanRead(XmlReader reader)
		{
			return Serializer.CanDeserialize(reader);
		}

		public void Write(string fileName)
		{
			StreamWriter streamWriter = new StreamWriter(fileName);
			try
			{
				Write(streamWriter);
			}
			finally
			{
				streamWriter.Close();
			}
		}

		public void Write(TextWriter writer)
		{
			XmlTextWriter xmlTextWriter = new XmlTextWriter(writer);
			xmlTextWriter.Formatting = Formatting.Indented;
			xmlTextWriter.Indentation = 2;
			Write(xmlTextWriter);
		}

		public void Write(Stream stream)
		{
			TextWriter textWriter = new StreamWriter(stream);
			Write(textWriter);
			textWriter.Flush();
		}

		public void Write(XmlWriter writer)
		{
			XmlSerializer xmlSerializer = Serializer;
			XmlSerializerNamespaces xmlSerializerNamespaces;
			if (base.Namespaces == null || base.Namespaces.Count == 0)
			{
				xmlSerializerNamespaces = new XmlSerializerNamespaces(namespaces);
				xmlSerializerNamespaces.Add("wsdl", "http://schemas.xmlsoap.org/wsdl/");
				if (TargetNamespace != null && TargetNamespace.Length != 0)
				{
					xmlSerializerNamespaces.Add("tns", TargetNamespace);
				}
				for (int i = 0; i < Types.Schemas.Count; i++)
				{
					string text = Types.Schemas[i].TargetNamespace;
					if (text != null && text.Length > 0 && text != TargetNamespace && text != "http://schemas.xmlsoap.org/wsdl/")
					{
						xmlSerializerNamespaces.Add("s" + i.ToString(CultureInfo.InvariantCulture), text);
					}
				}
				for (int j = 0; j < Imports.Count; j++)
				{
					Import import = Imports[j];
					if (import.Namespace.Length > 0)
					{
						xmlSerializerNamespaces.Add("i" + j.ToString(CultureInfo.InvariantCulture), import.Namespace);
					}
				}
			}
			else
			{
				xmlSerializerNamespaces = base.Namespaces;
			}
			xmlSerializer.Serialize(writer, this, xmlSerializerNamespaces);
		}

		internal static WsiProfiles GetConformanceClaims(XmlElement documentation)
		{
			if (documentation == null)
			{
				return WsiProfiles.None;
			}
			WsiProfiles wsiProfiles = WsiProfiles.None;
			XmlNode xmlNode = documentation.FirstChild;
			while (xmlNode != null)
			{
				XmlNode nextSibling = xmlNode.NextSibling;
				if (xmlNode is XmlElement)
				{
					XmlElement xmlElement = (XmlElement)xmlNode;
					if (xmlElement.LocalName == "Claim" && xmlElement.NamespaceURI == "http://ws-i.org/schemas/conformanceClaim/" && "http://ws-i.org/profiles/basic/1.1" == xmlElement.GetAttribute("conformsTo"))
					{
						wsiProfiles |= WsiProfiles.BasicProfile1_1;
					}
				}
				xmlNode = nextSibling;
			}
			return wsiProfiles;
		}

		internal static void AddConformanceClaims(XmlElement documentation, WsiProfiles claims)
		{
			claims &= WsiProfiles.BasicProfile1_1;
			if (claims == WsiProfiles.None)
			{
				return;
			}
			WsiProfiles conformanceClaims = GetConformanceClaims(documentation);
			claims &= ~conformanceClaims;
			if (claims != 0)
			{
				XmlDocument ownerDocument = documentation.OwnerDocument;
				if ((claims & WsiProfiles.BasicProfile1_1) != 0)
				{
					XmlElement xmlElement = ownerDocument.CreateElement("wsi", "Claim", "http://ws-i.org/schemas/conformanceClaim/");
					xmlElement.SetAttribute("conformsTo", "http://ws-i.org/profiles/basic/1.1");
					documentation.InsertBefore(xmlElement, null);
				}
			}
		}
	}
	[XmlFormatExtensionPoint("Extensions")]
	public sealed class Import : DocumentableItem
	{
		private string ns;

		private string location;

		private ServiceDescription parent;

		private ServiceDescriptionFormatExtensionCollection extensions;

		[XmlIgnore]
		public override ServiceDescriptionFormatExtensionCollection Extensions
		{
			get
			{
				if (extensions == null)
				{
					extensions = new ServiceDescriptionFormatExtensionCollection(this);
				}
				return extensions;
			}
		}

		public ServiceDescription ServiceDescription => parent;

		[XmlAttribute("namespace")]
		public string Namespace
		{
			get
			{
				if (ns != null)
				{
					return ns;
				}
				return string.Empty;
			}
			set
			{
				ns = value;
			}
		}

		[XmlAttribute("location")]
		public string Location
		{
			get
			{
				if (location != null)
				{
					return location;
				}
				return string.Empty;
			}
			set
			{
				location = value;
			}
		}

		internal void SetParent(ServiceDescription parent)
		{
			this.parent = parent;
		}
	}
	[XmlFormatExtensionPoint("Extensions")]
	public sealed class Port : NamedItem
	{
		private ServiceDescriptionFormatExtensionCollection extensions;

		private XmlQualifiedName binding = XmlQualifiedName.Empty;

		private Service parent;

		public Service Service => parent;

		[XmlIgnore]
		public override ServiceDescriptionFormatExtensionCollection Extensions
		{
			get
			{
				if (extensions == null)
				{
					extensions = new ServiceDescriptionFormatExtensionCollection(this);
				}
				return extensions;
			}
		}

		[XmlAttribute("binding")]
		public XmlQualifiedName Binding
		{
			get
			{
				return binding;
			}
			set
			{
				binding = value;
			}
		}

		internal void SetParent(Service parent)
		{
			this.parent = parent;
		}
	}
	[XmlFormatExtensionPoint("Extensions")]
	public sealed class Service : NamedItem
	{
		private ServiceDescriptionFormatExtensionCollection extensions;

		private PortCollection ports;

		private ServiceDescription parent;

		public ServiceDescription ServiceDescription => parent;

		[XmlIgnore]
		public override ServiceDescriptionFormatExtensionCollection Extensions
		{
			get
			{
				if (extensions == null)
				{
					extensions = new ServiceDescriptionFormatExtensionCollection(this);
				}
				return extensions;
			}
		}

		[XmlElement("port")]
		public PortCollection Ports
		{
			get
			{
				if (ports == null)
				{
					ports = new PortCollection(this);
				}
				return ports;
			}
		}

		internal void SetParent(ServiceDescription parent)
		{
			this.parent = parent;
		}
	}
	public abstract class MessageBinding : NamedItem
	{
		private OperationBinding parent;

		public OperationBinding OperationBinding => parent;

		internal void SetParent(OperationBinding parent)
		{
			this.parent = parent;
		}
	}
	[XmlFormatExtensionPoint("Extensions")]
	public sealed class FaultBinding : MessageBinding
	{
		private ServiceDescriptionFormatExtensionCollection extensions;

		[XmlIgnore]
		public override ServiceDescriptionFormatExtensionCollection Extensions
		{
			get
			{
				if (extensions == null)
				{
					extensions = new ServiceDescriptionFormatExtensionCollection(this);
				}
				return extensions;
			}
		}
	}
	[XmlFormatExtensionPoint("Extensions")]
	public sealed class InputBinding : MessageBinding
	{
		private ServiceDescriptionFormatExtensionCollection extensions;

		[XmlIgnore]
		public override ServiceDescriptionFormatExtensionCollection Extensions
		{
			get
			{
				if (extensions == null)
				{
					extensions = new ServiceDescriptionFormatExtensionCollection(this);
				}
				return extensions;
			}
		}
	}
	[XmlFormatExtensionPoint("Extensions")]
	public sealed class OutputBinding : MessageBinding
	{
		private ServiceDescriptionFormatExtensionCollection extensions;

		[XmlIgnore]
		public override ServiceDescriptionFormatExtensionCollection Extensions
		{
			get
			{
				if (extensions == null)
				{
					extensions = new ServiceDescriptionFormatExtensionCollection(this);
				}
				return extensions;
			}
		}
	}
	[XmlFormatExtensionPoint("Extensions")]
	public sealed class OperationBinding : NamedItem
	{
		private ServiceDescriptionFormatExtensionCollection extensions;

		private FaultBindingCollection faults;

		private InputBinding input;

		private OutputBinding output;

		private Binding parent;

		public Binding Binding => parent;

		[XmlIgnore]
		public override ServiceDescriptionFormatExtensionCollection Extensions
		{
			get
			{
				if (extensions == null)
				{
					extensions = new ServiceDescriptionFormatExtensionCollection(this);
				}
				return extensions;
			}
		}

		[XmlElement("input")]
		public InputBinding Input
		{
			get
			{
				return input;
			}
			set
			{
				if (input != null)
				{
					input.SetParent(null);
				}
				input = value;
				if (input != null)
				{
					input.SetParent(this);
				}
			}
		}

		[XmlElement("output")]
		public OutputBinding Output
		{
			get
			{
				return output;
			}
			set
			{
				if (output != null)
				{
					output.SetParent(null);
				}
				output = value;
				if (output != null)
				{
					output.SetParent(this);
				}
			}
		}

		[XmlElement("fault")]
		public FaultBindingCollection Faults
		{
			get
			{
				if (faults == null)
				{
					faults = new FaultBindingCollection(this);
				}
				return faults;
			}
		}

		internal void SetParent(Binding parent)
		{
			this.parent = parent;
		}
	}
	[XmlFormatExtensionPoint("Extensions")]
	public sealed class Binding : NamedItem
	{
		private ServiceDescriptionFormatExtensionCollection extensions;

		private OperationBindingCollection operations;

		private XmlQualifiedName type = XmlQualifiedName.Empty;

		private ServiceDescription parent;

		public ServiceDescription ServiceDescription => parent;

		[XmlIgnore]
		public override ServiceDescriptionFormatExtensionCollection Extensions
		{
			get
			{
				if (extensions == null)
				{
					extensions = new ServiceDescriptionFormatExtensionCollection(this);
				}
				return extensions;
			}
		}

		[XmlElement("operation")]
		public OperationBindingCollection Operations
		{
			get
			{
				if (operations == null)
				{
					operations = new OperationBindingCollection(this);
				}
				return operations;
			}
		}

		[XmlAttribute("type")]
		public XmlQualifiedName Type
		{
			get
			{
				if ((object)type == null)
				{
					return XmlQualifiedName.Empty;
				}
				return type;
			}
			set
			{
				type = value;
			}
		}

		internal void SetParent(ServiceDescription parent)
		{
			this.parent = parent;
		}
	}
	public abstract class OperationMessage : NamedItem
	{
		private XmlQualifiedName message = XmlQualifiedName.Empty;

		private Operation parent;

		public Operation Operation => parent;

		[XmlAttribute("message")]
		public XmlQualifiedName Message
		{
			get
			{
				return message;
			}
			set
			{
				message = value;
			}
		}

		internal void SetParent(Operation parent)
		{
			this.parent = parent;
		}
	}
	[XmlFormatExtensionPoint("Extensions")]
	public sealed class OperationFault : OperationMessage
	{
		private ServiceDescriptionFormatExtensionCollection extensions;

		[XmlIgnore]
		public override ServiceDescriptionFormatExtensionCollection Extensions
		{
			get
			{
				if (extensions == null)
				{
					extensions = new ServiceDescriptionFormatExtensionCollection(this);
				}
				return extensions;
			}
		}
	}
	[XmlFormatExtensionPoint("Extensions")]
	public sealed class OperationInput : OperationMessage
	{
		private ServiceDescriptionFormatExtensionCollection extensions;

		[XmlIgnore]
		public override ServiceDescriptionFormatExtensionCollection Extensions
		{
			get
			{
				if (extensions == null)
				{
					extensions = new ServiceDescriptionFormatExtensionCollection(this);
				}
				return extensions;
			}
		}
	}
	[XmlFormatExtensionPoint("Extensions")]
	public sealed class OperationOutput : OperationMessage
	{
		private ServiceDescriptionFormatExtensionCollection extensions;

		[XmlIgnore]
		public override ServiceDescriptionFormatExtensionCollection Extensions
		{
			get
			{
				if (extensions == null)
				{
					extensions = new ServiceDescriptionFormatExtensionCollection(this);
				}
				return extensions;
			}
		}
	}
	[XmlFormatExtensionPoint("Extensions")]
	public sealed class Operation : NamedItem
	{
		private string[] parameters;

		private OperationMessageCollection messages;

		private OperationFaultCollection faults;

		private PortType parent;

		private ServiceDescriptionFormatExtensionCollection extensions;

		[XmlIgnore]
		public override ServiceDescriptionFormatExtensionCollection Extensions
		{
			get
			{
				if (extensions == null)
				{
					extensions = new ServiceDescriptionFormatExtensionCollection(this);
				}
				return extensions;
			}
		}

		public PortType PortType => parent;

		[XmlAttribute("parameterOrder")]
		[DefaultValue("")]
		public string ParameterOrderString
		{
			get
			{
				if (parameters == null)
				{
					return string.Empty;
				}
				StringBuilder stringBuilder = new StringBuilder();
				for (int i = 0; i < parameters.Length; i++)
				{
					if (i > 0)
					{
						stringBuilder.Append(' ');
					}
					stringBuilder.Append(parameters[i]);
				}
				return stringBuilder.ToString();
			}
			set
			{
				if (value == null)
				{
					parameters = null;
					return;
				}
				parameters = value.Split(' ');
			}
		}

		[XmlIgnore]
		public string[] ParameterOrder
		{
			get
			{
				return parameters;
			}
			set
			{
				parameters = value;
			}
		}

		[XmlElement("input", typeof(OperationInput))]
		[XmlElement("output", typeof(OperationOutput))]
		public OperationMessageCollection Messages
		{
			get
			{
				if (messages == null)
				{
					messages = new OperationMessageCollection(this);
				}
				return messages;
			}
		}

		[XmlElement("fault")]
		public OperationFaultCollection Faults
		{
			get
			{
				if (faults == null)
				{
					faults = new OperationFaultCollection(this);
				}
				return faults;
			}
		}

		internal void SetParent(PortType parent)
		{
			this.parent = parent;
		}

		public bool IsBoundBy(OperationBinding operationBinding)
		{
			if (operationBinding.Name != base.Name)
			{
				return false;
			}
			OperationMessage input = Messages.Input;
			if (input != null)
			{
				if (operationBinding.Input == null)
				{
					return false;
				}
				string messageName = GetMessageName(base.Name, input.Name, isInput: true);
				string messageName2 = GetMessageName(operationBinding.Name, operationBinding.Input.Name, isInput: true);
				if (messageName2 != messageName)
				{
					return false;
				}
			}
			else if (operationBinding.Input != null)
			{
				return false;
			}
			OperationMessage output = Messages.Output;
			if (output != null)
			{
				if (operationBinding.Output == null)
				{
					return false;
				}
				string messageName3 = GetMessageName(base.Name, output.Name, isInput: false);
				string messageName4 = GetMessageName(operationBinding.Name, operationBinding.Output.Name, isInput: false);
				if (messageName4 != messageName3)
				{
					return false;
				}
			}
			else if (operationBinding.Output != null)
			{
				return false;
			}
			return true;
		}

		private string GetMessageName(string operationName, string messageName, bool isInput)
		{
			if (messageName != null && messageName.Length > 0)
			{
				return messageName;
			}
			switch (Messages.Flow)
			{
			case OperationFlow.RequestResponse:
				if (isInput)
				{
					return operationName + "Request";
				}
				return operationName + "Response";
			case OperationFlow.OneWay:
				if (isInput)
				{
					return operationName;
				}
				return null;
			default:
				return null;
			}
		}
	}
	[XmlFormatExtensionPoint("Extensions")]
	public sealed class PortType : NamedItem
	{
		private OperationCollection operations;

		private ServiceDescription parent;

		private ServiceDescriptionFormatExtensionCollection extensions;

		[XmlIgnore]
		public override ServiceDescriptionFormatExtensionCollection Extensions
		{
			get
			{
				if (extensions == null)
				{
					extensions = new ServiceDescriptionFormatExtensionCollection(this);
				}
				return extensions;
			}
		}

		public ServiceDescription ServiceDescription => parent;

		[XmlElement("operation")]
		public OperationCollection Operations
		{
			get
			{
				if (operations == null)
				{
					operations = new OperationCollection(this);
				}
				return operations;
			}
		}

		internal void SetParent(ServiceDescription parent)
		{
			this.parent = parent;
		}
	}
	[XmlFormatExtensionPoint("Extensions")]
	public sealed class Message : NamedItem
	{
		private MessagePartCollection parts;

		private ServiceDescription parent;

		private ServiceDescriptionFormatExtensionCollection extensions;

		[XmlIgnore]
		public override ServiceDescriptionFormatExtensionCollection Extensions
		{
			get
			{
				if (extensions == null)
				{
					extensions = new ServiceDescriptionFormatExtensionCollection(this);
				}
				return extensions;
			}
		}

		public ServiceDescription ServiceDescription => parent;

		[XmlElement("part")]
		public MessagePartCollection Parts
		{
			get
			{
				if (parts == null)
				{
					parts = new MessagePartCollection(this);
				}
				return parts;
			}
		}

		internal void SetParent(ServiceDescription parent)
		{
			this.parent = parent;
		}

		public MessagePart[] FindPartsByName(string[] partNames)
		{
			MessagePart[] array = new MessagePart[partNames.Length];
			for (int i = 0; i < partNames.Length; i++)
			{
				array[i] = FindPartByName(partNames[i]);
			}
			return array;
		}

		public MessagePart FindPartByName(string partName)
		{
			for (int i = 0; i < parts.Count; i++)
			{
				MessagePart messagePart = parts[i];
				if (messagePart.Name == partName)
				{
					return messagePart;
				}
			}
			throw new ArgumentException(Res.GetString("MissingMessagePartForMessageFromNamespace3", partName, base.Name, ServiceDescription.TargetNamespace), "partName");
		}
	}
	[XmlFormatExtensionPoint("Extensions")]
	public sealed class MessagePart : NamedItem
	{
		private XmlQualifiedName type = XmlQualifiedName.Empty;

		private XmlQualifiedName element = XmlQualifiedName.Empty;

		private Message parent;

		private ServiceDescriptionFormatExtensionCollection extensions;

		[XmlIgnore]
		public override ServiceDescriptionFormatExtensionCollection Extensions
		{
			get
			{
				if (extensions == null)
				{
					extensions = new ServiceDescriptionFormatExtensionCollection(this);
				}
				return extensions;
			}
		}

		public Message Message => parent;

		[XmlAttribute("element")]
		public XmlQualifiedName Element
		{
			get
			{
				return element;
			}
			set
			{
				element = value;
			}
		}

		[XmlAttribute("type")]
		public XmlQualifiedName Type
		{
			get
			{
				if ((object)type == null)
				{
					return XmlQualifiedName.Empty;
				}
				return type;
			}
			set
			{
				type = value;
			}
		}

		internal void SetParent(Message parent)
		{
			this.parent = parent;
		}
	}
	[XmlFormatExtensionPoint("Extensions")]
	public sealed class Types : DocumentableItem
	{
		private XmlSchemas schemas;

		private ServiceDescriptionFormatExtensionCollection extensions;

		[XmlIgnore]
		public override ServiceDescriptionFormatExtensionCollection Extensions
		{
			get
			{
				if (extensions == null)
				{
					extensions = new ServiceDescriptionFormatExtensionCollection(this);
				}
				return extensions;
			}
		}

		[XmlElement("schema", typeof(XmlSchema), Namespace = "http://www.w3.org/2001/XMLSchema")]
		public XmlSchemas Schemas
		{
			get
			{
				if (schemas == null)
				{
					schemas = new XmlSchemas();
				}
				return schemas;
			}
		}

		internal bool HasItems()
		{
			if (schemas == null || schemas.Count <= 0)
			{
				if (extensions != null)
				{
					return extensions.Count > 0;
				}
				return false;
			}
			return true;
		}
	}
	public abstract class ServiceDescriptionBaseCollection : CollectionBase
	{
		private Hashtable table;

		private object parent;

		protected virtual IDictionary Table
		{
			get
			{
				if (table == null)
				{
					table = new Hashtable();
				}
				return table;
			}
		}

		internal ServiceDescriptionBaseCollection(object parent)
		{
			this.parent = parent;
		}

		protected virtual string GetKey(object value)
		{
			return null;
		}

		protected virtual void SetParent(object value, object parent)
		{
		}

		protected override void OnInsertComplete(int index, object value)
		{
			AddValue(value);
		}

		protected override void OnRemove(int index, object value)
		{
			RemoveValue(value);
		}

		protected override void OnClear()
		{
			for (int i = 0; i < base.List.Count; i++)
			{
				RemoveValue(base.List[i]);
			}
		}

		protected override void OnSet(int index, object oldValue, object newValue)
		{
			RemoveValue(oldValue);
			AddValue(newValue);
		}

		private void AddValue(object value)
		{
			string key = GetKey(value);
			if (key != null)
			{
				try
				{
					Table.Add(key, value);
				}
				catch (Exception ex)
				{
					if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
					{
						throw;
					}
					if (Table[key] != null)
					{
						throw new ArgumentException(GetDuplicateMessage(value.GetType(), key), ex.InnerException);
					}
					throw ex;
				}
				catch
				{
					if (Table[key] != null)
					{
						throw new ArgumentException(GetDuplicateMessage(value.GetType(), key), (Exception)null);
					}
					throw;
				}
			}
			SetParent(value, parent);
		}

		private void RemoveValue(object value)
		{
			string key = GetKey(value);
			if (key != null)
			{
				Table.Remove(key);
			}
			SetParent(value, null);
		}

		private static string GetDuplicateMessage(Type type, string elemName)
		{
			string text = null;
			if (type == typeof(ServiceDescriptionFormatExtension))
			{
				return Res.GetString("WebDuplicateFormatExtension", elemName);
			}
			if (type == typeof(OperationMessage))
			{
				return Res.GetString("WebDuplicateOperationMessage", elemName);
			}
			if (type == typeof(Import))
			{
				return Res.GetString("WebDuplicateImport", elemName);
			}
			if (type == typeof(Message))
			{
				return Res.GetString("WebDuplicateMessage", elemName);
			}
			if (type == typeof(Port))
			{
				return Res.GetString("WebDuplicatePort", elemName);
			}
			if (type == typeof(PortType))
			{
				return Res.GetString("WebDuplicatePortType", elemName);
			}
			if (type == typeof(Binding))
			{
				return Res.GetString("WebDuplicateBinding", elemName);
			}
			if (type == typeof(Service))
			{
				return Res.GetString("WebDuplicateService", elemName);
			}
			if (type == typeof(MessagePart))
			{
				return Res.GetString("WebDuplicateMessagePart", elemName);
			}
			if (type == typeof(OperationBinding))
			{
				return Res.GetString("WebDuplicateOperationBinding", elemName);
			}
			if (type == typeof(FaultBinding))
			{
				return Res.GetString("WebDuplicateFaultBinding", elemName);
			}
			if (type == typeof(Operation))
			{
				return Res.GetString("WebDuplicateOperation", elemName);
			}
			if (type == typeof(OperationFault))
			{
				return Res.GetString("WebDuplicateOperationFault", elemName);
			}
			return Res.GetString("WebDuplicateUnknownElement", type, elemName);
		}
	}
	public sealed class ServiceDescriptionFormatExtensionCollection : ServiceDescriptionBaseCollection
	{
		private ArrayList handledElements;

		public object this[int index]
		{
			get
			{
				return base.List[index];
			}
			set
			{
				base.List[index] = value;
			}
		}

		public ServiceDescriptionFormatExtensionCollection(object parent)
			: base(parent)
		{
		}

		public int Add(object extension)
		{
			return base.List.Add(extension);
		}

		public void Insert(int index, object extension)
		{
			base.List.Insert(index, extension);
		}

		public int IndexOf(object extension)
		{
			return base.List.IndexOf(extension);
		}

		public bool Contains(object extension)
		{
			return base.List.Contains(extension);
		}

		public void Remove(object extension)
		{
			base.List.Remove(extension);
		}

		public void CopyTo(object[] array, int index)
		{
			base.List.CopyTo(array, index);
		}

		public object Find(Type type)
		{
			for (int i = 0; i < base.List.Count; i++)
			{
				object obj = base.List[i];
				if (type.IsAssignableFrom(obj.GetType()))
				{
					((ServiceDescriptionFormatExtension)obj).Handled = true;
					return obj;
				}
			}
			return null;
		}

		public object[] FindAll(Type type)
		{
			ArrayList arrayList = new ArrayList();
			for (int i = 0; i < base.List.Count; i++)
			{
				object obj = base.List[i];
				if (type.IsAssignableFrom(obj.GetType()))
				{
					((ServiceDescriptionFormatExtension)obj).Handled = true;
					arrayList.Add(obj);
				}
			}
			return (object[])arrayList.ToArray(type);
		}

		public XmlElement Find(string name, string ns)
		{
			for (int i = 0; i < base.List.Count; i++)
			{
				if (base.List[i] is XmlElement xmlElement && xmlElement.LocalName == name && xmlElement.NamespaceURI == ns)
				{
					SetHandled(xmlElement);
					return xmlElement;
				}
			}
			return null;
		}

		public XmlElement[] FindAll(string name, string ns)
		{
			ArrayList arrayList = new ArrayList();
			for (int i = 0; i < base.List.Count; i++)
			{
				if (base.List[i] is XmlElement xmlElement && xmlElement.LocalName == name && xmlElement.NamespaceURI == ns)
				{
					SetHandled(xmlElement);
					arrayList.Add(xmlElement);
				}
			}
			return (XmlElement[])arrayList.ToArray(typeof(XmlElement));
		}

		private void SetHandled(XmlElement element)
		{
			if (handledElements == null)
			{
				handledElements = new ArrayList();
			}
			if (!handledElements.Contains(element))
			{
				handledElements.Add(element);
			}
		}

		public bool IsHandled(object item)
		{
			if (item is XmlElement)
			{
				return IsHandled((XmlElement)item);
			}
			return ((ServiceDescriptionFormatExtension)item).Handled;
		}

		public bool IsRequired(object item)
		{
			if (item is XmlElement)
			{
				return IsRequired((XmlElement)item);
			}
			return ((ServiceDescriptionFormatExtension)item).Required;
		}

		private bool IsHandled(XmlElement element)
		{
			if (handledElements == null)
			{
				return false;
			}
			return handledElements.Contains(element);
		}

		private bool IsRequired(XmlElement element)
		{
			XmlAttribute xmlAttribute = element.Attributes["required", "http://schemas.xmlsoap.org/wsdl/"];
			if (xmlAttribute == null || xmlAttribute.Value == null)
			{
				xmlAttribute = element.Attributes["required"];
				if (xmlAttribute == null || xmlAttribute.Value == null)
				{
					return false;
				}
			}
			return XmlConvert.ToBoolean(xmlAttribute.Value);
		}

		protected override void SetParent(object value, object parent)
		{
			if (value is ServiceDescriptionFormatExtension)
			{
				((ServiceDescriptionFormatExtension)value).SetParent(parent);
			}
		}

		protected override void OnValidate(object value)
		{
			if (!(value is XmlElement) && !(value is ServiceDescriptionFormatExtension))
			{
				throw new ArgumentException(Res.GetString("OnlyXmlElementsOrTypesDerivingFromServiceDescriptionFormatExtension0"), "value");
			}
			base.OnValidate(value);
		}
	}
	public enum OperationFlow
	{
		None,
		OneWay,
		Notification,
		RequestResponse,
		SolicitResponse
	}
	public sealed class OperationMessageCollection : ServiceDescriptionBaseCollection
	{
		public OperationMessage this[int index]
		{
			get
			{
				return (OperationMessage)base.List[index];
			}
			set
			{
				base.List[index] = value;
			}
		}

		public OperationInput Input
		{
			get
			{
				for (int i = 0; i < base.List.Count; i++)
				{
					if (base.List[i] is OperationInput result)
					{
						return result;
					}
				}
				return null;
			}
		}

		public OperationOutput Output
		{
			get
			{
				for (int i = 0; i < base.List.Count; i++)
				{
					if (base.List[i] is OperationOutput result)
					{
						return result;
					}
				}
				return null;
			}
		}

		public OperationFlow Flow
		{
			get
			{
				if (base.List.Count == 0)
				{
					return OperationFlow.None;
				}
				if (base.List.Count == 1)
				{
					if (base.List[0] is OperationInput)
					{
						return OperationFlow.OneWay;
					}
					return OperationFlow.Notification;
				}
				if (base.List[0] is OperationInput)
				{
					return OperationFlow.RequestResponse;
				}
				return OperationFlow.SolicitResponse;
			}
		}

		internal OperationMessageCollection(Operation operation)
			: base(operation)
		{
		}

		public int Add(OperationMessage operationMessage)
		{
			return base.List.Add(operationMessage);
		}

		public void Insert(int index, OperationMessage operationMessage)
		{
			base.List.Insert(index, operationMessage);
		}

		public int IndexOf(OperationMessage operationMessage)
		{
			return base.List.IndexOf(operationMessage);
		}

		public bool Contains(OperationMessage operationMessage)
		{
			return base.List.Contains(operationMessage);
		}

		public void Remove(OperationMessage operationMessage)
		{
			base.List.Remove(operationMessage);
		}

		public void CopyTo(OperationMessage[] array, int index)
		{
			base.List.CopyTo(array, index);
		}

		protected override void SetParent(object value, object parent)
		{
			((OperationMessage)value).SetParent((Operation)parent);
		}

		protected override void OnInsert(int index, object value)
		{
			if (base.Count > 1 || (base.Count == 1 && value.GetType() == base.List[0].GetType()))
			{
				throw new InvalidOperationException(Res.GetString("WebDescriptionTooManyMessages"));
			}
			base.OnInsert(index, value);
		}

		protected override void OnSet(int index, object oldValue, object newValue)
		{
			if (oldValue.GetType() != newValue.GetType())
			{
				throw new InvalidOperationException(Res.GetString("WebDescriptionTooManyMessages"));
			}
			base.OnSet(index, oldValue, newValue);
		}

		protected override void OnValidate(object value)
		{
			if (!(value is OperationInput) && !(value is OperationOutput))
			{
				throw new ArgumentException(Res.GetString("OnlyOperationInputOrOperationOutputTypes"), "value");
			}
			base.OnValidate(value);
		}
	}
	public sealed class ImportCollection : ServiceDescriptionBaseCollection
	{
		public Import this[int index]
		{
			get
			{
				return (Import)base.List[index];
			}
			set
			{
				base.List[index] = value;
			}
		}

		internal ImportCollection(ServiceDescription serviceDescription)
			: base(serviceDescription)
		{
		}

		public int Add(Import import)
		{
			return base.List.Add(import);
		}

		public void Insert(int index, Import import)
		{
			base.List.Insert(index, import);
		}

		public int IndexOf(Import import)
		{
			return base.List.IndexOf(import);
		}

		public bool Contains(Import import)
		{
			return base.List.Contains(import);
		}

		public void Remove(Import import)
		{
			base.List.Remove(import);
		}

		public void CopyTo(Import[] array, int index)
		{
			base.List.CopyTo(array, index);
		}

		protected override void SetParent(object value, object parent)
		{
			((Import)value).SetParent((ServiceDescription)parent);
		}
	}
	public sealed class MessageCollection : ServiceDescriptionBaseCollection
	{
		public Message this[int index]
		{
			get
			{
				return (Message)base.List[index];
			}
			set
			{
				base.List[index] = value;
			}
		}

		public Message this[string name] => (Message)Table[name];

		internal MessageCollection(ServiceDescription serviceDescription)
			: base(serviceDescription)
		{
		}

		public int Add(Message message)
		{
			return base.List.Add(message);
		}

		public void Insert(int index, Message message)
		{
			base.List.Insert(index, message);
		}

		public int IndexOf(Message message)
		{
			return base.List.IndexOf(message);
		}

		public bool Contains(Message message)
		{
			return base.List.Contains(message);
		}

		public void Remove(Message message)
		{
			base.List.Remove(message);
		}

		public void CopyTo(Message[] array, int index)
		{
			base.List.CopyTo(array, index);
		}

		protected override string GetKey(object value)
		{
			return ((Message)value).Name;
		}

		protected override void SetParent(object value, object parent)
		{
			((Message)value).SetParent((ServiceDescription)parent);
		}
	}
	public sealed class PortCollection : ServiceDescriptionBaseCollection
	{
		public Port this[int index]
		{
			get
			{
				return (Port)base.List[index];
			}
			set
			{
				base.List[index] = value;
			}
		}

		public Port this[string name] => (Port)Table[name];

		internal PortCollection(Service service)
			: base(service)
		{
		}

		public int Add(Port port)
		{
			return base.List.Add(port);
		}

		public void Insert(int index, Port port)
		{
			base.List.Insert(index, port);
		}

		public int IndexOf(Port port)
		{
			return base.List.IndexOf(port);
		}

		public bool Contains(Port port)
		{
			return base.List.Contains(port);
		}

		public void Remove(Port port)
		{
			base.List.Remove(port);
		}

		public void CopyTo(Port[] array, int index)
		{
			base.List.CopyTo(array, index);
		}

		protected override string GetKey(object value)
		{
			return ((Port)value).Name;
		}

		protected override void SetParent(object value, object parent)
		{
			((Port)value).SetParent((Service)parent);
		}
	}
	public sealed class PortTypeCollection : ServiceDescriptionBaseCollection
	{
		public PortType this[int index]
		{
			get
			{
				return (PortType)base.List[index];
			}
			set
			{
				base.List[index] = value;
			}
		}

		public PortType this[string name] => (PortType)Table[name];

		internal PortTypeCollection(ServiceDescription serviceDescription)
			: base(serviceDescription)
		{
		}

		public int Add(PortType portType)
		{
			return base.List.Add(portType);
		}

		public void Insert(int index, PortType portType)
		{
			base.List.Insert(index, portType);
		}

		public int IndexOf(PortType portType)
		{
			return base.List.IndexOf(portType);
		}

		public bool Contains(PortType portType)
		{
			return base.List.Contains(portType);
		}

		public void Remove(PortType portType)
		{
			base.List.Remove(portType);
		}

		public void CopyTo(PortType[] array, int index)
		{
			base.List.CopyTo(array, index);
		}

		protected override string GetKey(object value)
		{
			return ((PortType)value).Name;
		}

		protected override void SetParent(object value, object parent)
		{
			((PortType)value).SetParent((ServiceDescription)parent);
		}
	}
	public sealed class BindingCollection : ServiceDescriptionBaseCollection
	{
		public Binding this[int index]
		{
			get
			{
				return (Binding)base.List[index];
			}
			set
			{
				base.List[index] = value;
			}
		}

		public Binding this[string name] => (Binding)Table[name];

		internal BindingCollection(ServiceDescription serviceDescription)
			: base(serviceDescription)
		{
		}

		public int Add(Binding binding)
		{
			return base.List.Add(binding);
		}

		public void Insert(int index, Binding binding)
		{
			base.List.Insert(index, binding);
		}

		public int IndexOf(Binding binding)
		{
			return base.List.IndexOf(binding);
		}

		public bool Contains(Binding binding)
		{
			return base.List.Contains(binding);
		}

		public void Remove(Binding binding)
		{
			base.List.Remove(binding);
		}

		public void CopyTo(Binding[] array, int index)
		{
			base.List.CopyTo(array, index);
		}

		protected override string GetKey(object value)
		{
			return ((Binding)value).Name;
		}

		protected override void SetParent(object value, object parent)
		{
			((Binding)value).SetParent((ServiceDescription)parent);
		}
	}
	public sealed class ServiceCollection : ServiceDescriptionBaseCollection
	{
		public Service this[int index]
		{
			get
			{
				return (Service)base.List[index];
			}
			set
			{
				base.List[index] = value;
			}
		}

		public Service this[string name] => (Service)Table[name];

		internal ServiceCollection(ServiceDescription serviceDescription)
			: base(serviceDescription)
		{
		}

		public int Add(Service service)
		{
			return base.List.Add(service);
		}

		public void Insert(int index, Service service)
		{
			base.List.Insert(index, service);
		}

		public int IndexOf(Service service)
		{
			return base.List.IndexOf(service);
		}

		public bool Contains(Service service)
		{
			return base.List.Contains(service);
		}

		public void Remove(Service service)
		{
			base.List.Remove(service);
		}

		public void CopyTo(Service[] array, int index)
		{
			base.List.CopyTo(array, index);
		}

		protected override string GetKey(object value)
		{
			return ((Service)value).Name;
		}

		protected override void SetParent(object value, object parent)
		{
			((Service)value).SetParent((ServiceDescription)parent);
		}
	}
	public sealed class MessagePartCollection : ServiceDescriptionBaseCollection
	{
		public MessagePart this[int index]
		{
			get
			{
				return (MessagePart)base.List[index];
			}
			set
			{
				base.List[index] = value;
			}
		}

		public MessagePart this[string name] => (MessagePart)Table[name];

		internal MessagePartCollection(Message message)
			: base(message)
		{
		}

		public int Add(MessagePart messagePart)
		{
			return base.List.Add(messagePart);
		}

		public void Insert(int index, MessagePart messagePart)
		{
			base.List.Insert(index, messagePart);
		}

		public int IndexOf(MessagePart messagePart)
		{
			return base.List.IndexOf(messagePart);
		}

		public bool Contains(MessagePart messagePart)
		{
			return base.List.Contains(messagePart);
		}

		public void Remove(MessagePart messagePart)
		{
			base.List.Remove(messagePart);
		}

		public void CopyTo(MessagePart[] array, int index)
		{
			base.List.CopyTo(array, index);
		}

		protected override string GetKey(object value)
		{
			return ((MessagePart)value).Name;
		}

		protected override void SetParent(object value, object parent)
		{
			((MessagePart)value).SetParent((Message)parent);
		}
	}
	public sealed class OperationBindingCollection : ServiceDescriptionBaseCollection
	{
		public OperationBinding this[int index]
		{
			get
			{
				return (OperationBinding)base.List[index];
			}
			set
			{
				base.List[index] = value;
			}
		}

		internal OperationBindingCollection(Binding binding)
			: base(binding)
		{
		}

		public int Add(OperationBinding bindingOperation)
		{
			return base.List.Add(bindingOperation);
		}

		public void Insert(int index, OperationBinding bindingOperation)
		{
			base.List.Insert(index, bindingOperation);
		}

		public int IndexOf(OperationBinding bindingOperation)
		{
			return base.List.IndexOf(bindingOperation);
		}

		public bool Contains(OperationBinding bindingOperation)
		{
			return base.List.Contains(bindingOperation);
		}

		public void Remove(OperationBinding bindingOperation)
		{
			base.List.Remove(bindingOperation);
		}

		public void CopyTo(OperationBinding[] array, int index)
		{
			base.List.CopyTo(array, index);
		}

		protected override void SetParent(object value, object parent)
		{
			((OperationBinding)value).SetParent((Binding)parent);
		}
	}
	public sealed class FaultBindingCollection : ServiceDescriptionBaseCollection
	{
		public FaultBinding this[int index]
		{
			get
			{
				return (FaultBinding)base.List[index];
			}
			set
			{
				base.List[index] = value;
			}
		}

		public FaultBinding this[string name] => (FaultBinding)Table[name];

		internal FaultBindingCollection(OperationBinding operationBinding)
			: base(operationBinding)
		{
		}

		public int Add(FaultBinding bindingOperationFault)
		{
			return base.List.Add(bindingOperationFault);
		}

		public void Insert(int index, FaultBinding bindingOperationFault)
		{
			base.List.Insert(index, bindingOperationFault);
		}

		public int IndexOf(FaultBinding bindingOperationFault)
		{
			return base.List.IndexOf(bindingOperationFault);
		}

		public bool Contains(FaultBinding bindingOperationFault)
		{
			return base.List.Contains(bindingOperationFault);
		}

		public void Remove(FaultBinding bindingOperationFault)
		{
			base.List.Remove(bindingOperationFault);
		}

		public void CopyTo(FaultBinding[] array, int index)
		{
			base.List.CopyTo(array, index);
		}

		protected override string GetKey(object value)
		{
			return ((FaultBinding)value).Name;
		}

		protected override void SetParent(object value, object parent)
		{
			((FaultBinding)value).SetParent((OperationBinding)parent);
		}
	}
	public sealed class OperationCollection : ServiceDescriptionBaseCollection
	{
		public Operation this[int index]
		{
			get
			{
				return (Operation)base.List[index];
			}
			set
			{
				base.List[index] = value;
			}
		}

		internal OperationCollection(PortType portType)
			: base(portType)
		{
		}

		public int Add(Operation operation)
		{
			return base.List.Add(operation);
		}

		public void Insert(int index, Operation operation)
		{
			base.List.Insert(index, operation);
		}

		public int IndexOf(Operation operation)
		{
			return base.List.IndexOf(operation);
		}

		public bool Contains(Operation operation)
		{
			return base.List.Contains(operation);
		}

		public void Remove(Operation operation)
		{
			base.List.Remove(operation);
		}

		public void CopyTo(Operation[] array, int index)
		{
			base.List.CopyTo(array, index);
		}

		protected override void SetParent(object value, object parent)
		{
			((Operation)value).SetParent((PortType)parent);
		}
	}
	public sealed class OperationFaultCollection : ServiceDescriptionBaseCollection
	{
		public OperationFault this[int index]
		{
			get
			{
				return (OperationFault)base.List[index];
			}
			set
			{
				base.List[index] = value;
			}
		}

		public OperationFault this[string name] => (OperationFault)Table[name];

		internal OperationFaultCollection(Operation operation)
			: base(operation)
		{
		}

		public int Add(OperationFault operationFaultMessage)
		{
			return base.List.Add(operationFaultMessage);
		}

		public void Insert(int index, OperationFault operationFaultMessage)
		{
			base.List.Insert(index, operationFaultMessage);
		}

		public int IndexOf(OperationFault operationFaultMessage)
		{
			return base.List.IndexOf(operationFaultMessage);
		}

		public bool Contains(OperationFault operationFaultMessage)
		{
			return base.List.Contains(operationFaultMessage);
		}

		public void Remove(OperationFault operationFaultMessage)
		{
			base.List.Remove(operationFaultMessage);
		}

		public void CopyTo(OperationFault[] array, int index)
		{
			base.List.CopyTo(array, index);
		}

		protected override string GetKey(object value)
		{
			return ((OperationFault)value).Name;
		}

		protected override void SetParent(object value, object parent)
		{
			((OperationFault)value).SetParent((Operation)parent);
		}
	}
	internal class Schemas
	{
		internal const string Wsdl = "<?xml version='1.0' encoding='UTF-8' ?> \r\n<xs:schema xmlns:xs='http://www.w3.org/2001/XMLSchema'\r\n           xmlns:wsdl='http://schemas.xmlsoap.org/wsdl/'\r\n           targetNamespace='http://schemas.xmlsoap.org/wsdl/'\r\n           elementFormDefault='qualified' >\r\n   \r\n  <xs:complexType mixed='true' name='tDocumentation' >\r\n    <xs:sequence>\r\n      <xs:any minOccurs='0' maxOccurs='unbounded' processContents='lax' />\r\n    </xs:sequence>\r\n  </xs:complexType>\r\n\r\n  <xs:complexType name='tDocumented' >\r\n    <xs:annotation>\r\n      <xs:documentation>\r\n      This type is extended by  component types to allow them to be documented\r\n      </xs:documentation>\r\n    </xs:annotation>\r\n    <xs:sequence>\r\n      <xs:element name='documentation' type='wsdl:tDocumentation' minOccurs='0' />\r\n    </xs:sequence>\r\n  </xs:complexType>\r\n <!-- allow extensibility via elements and attributes on all elements swa124 -->\r\n <xs:complexType name='tExtensibleAttributesDocumented' abstract='true' >\r\n    <xs:complexContent>\r\n      <xs:extension base='wsdl:tDocumented' >\r\n        <xs:annotation>\r\n          <xs:documentation>\r\n          This type is extended by component types to allow attributes from other namespaces to be added.\r\n          </xs:documentation>\r\n        </xs:annotation>\r\n        <xs:sequence>\r\n          <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded' processContents='lax' />\r\n        </xs:sequence>\r\n        <xs:anyAttribute namespace='##other' processContents='lax' />   \r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n  <xs:complexType name='tExtensibleDocumented' abstract='true' >\r\n    <xs:complexContent>\r\n      <xs:extension base='wsdl:tDocumented' >\r\n        <xs:annotation>\r\n          <xs:documentation>\r\n          This type is extended by component types to allow elements from other namespaces to be added.\r\n          </xs:documentation>\r\n        </xs:annotation>\r\n        <xs:sequence>\r\n          <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded' processContents='lax' />\r\n        </xs:sequence>\r\n        <xs:anyAttribute namespace='##other' processContents='lax' />   \r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n  <!-- original wsdl removed as part of swa124 resolution\r\n  <xs:complexType name='tExtensibleAttributesDocumented' abstract='true' >\r\n    <xs:complexContent>\r\n      <xs:extension base='wsdl:tDocumented' >\r\n        <xs:annotation>\r\n          <xs:documentation>\r\n          This type is extended by component types to allow attributes from other namespaces to be added.\r\n          </xs:documentation>\r\n        </xs:annotation>\r\n        <xs:anyAttribute namespace='##other' processContents='lax' />    \r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n\r\n  <xs:complexType name='tExtensibleDocumented' abstract='true' >\r\n    <xs:complexContent>\r\n      <xs:extension base='wsdl:tDocumented' >\r\n        <xs:annotation>\r\n          <xs:documentation>\r\n          This type is extended by component types to allow elements from other namespaces to be added.\r\n          </xs:documentation>\r\n        </xs:annotation>\r\n        <xs:sequence>\r\n          <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded' processContents='lax' />\r\n        </xs:sequence>\r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n -->\r\n  <xs:element name='definitions' type='wsdl:tDefinitions' >\r\n    <xs:key name='message' >\r\n      <xs:selector xpath='wsdl:message' />\r\n      <xs:field xpath='@name' />\r\n    </xs:key>\r\n    <xs:key name='portType' >\r\n      <xs:selector xpath='wsdl:portType' />\r\n      <xs:field xpath='@name' />\r\n    </xs:key>\r\n    <xs:key name='binding' >\r\n      <xs:selector xpath='wsdl:binding' />\r\n      <xs:field xpath='@name' />\r\n    </xs:key>\r\n    <xs:key name='service' >\r\n      <xs:selector xpath='wsdl:service' />\r\n      <xs:field xpath='@name' />\r\n    </xs:key>\r\n    <xs:key name='import' >\r\n      <xs:selector xpath='wsdl:import' />\r\n      <xs:field xpath='@namespace' />\r\n    </xs:key>\r\n  </xs:element>\r\n\r\n  <xs:group name='anyTopLevelOptionalElement' >\r\n    <xs:annotation>\r\n      <xs:documentation>\r\n      Any top level optional element allowed to appear more then once - any child of definitions element except wsdl:types. Any extensibility element is allowed in any place.\r\n      </xs:documentation>\r\n    </xs:annotation>\r\n    <xs:choice>\r\n      <xs:element name='import' type='wsdl:tImport' />\r\n      <xs:element name='types' type='wsdl:tTypes' />                     \r\n      <xs:element name='message'  type='wsdl:tMessage' >\r\n        <xs:unique name='part' >\r\n          <xs:selector xpath='wsdl:part' />\r\n          <xs:field xpath='@name' />\r\n        </xs:unique>\r\n      </xs:element>\r\n      <xs:element name='portType' type='wsdl:tPortType' />\r\n      <xs:element name='binding'  type='wsdl:tBinding' />\r\n      <xs:element name='service'  type='wsdl:tService' >\r\n        <xs:unique name='port' >\r\n          <xs:selector xpath='wsdl:port' />\r\n          <xs:field xpath='@name' />\r\n        </xs:unique>\r\n\t  </xs:element>\r\n    </xs:choice>\r\n  </xs:group>\r\n\r\n  <xs:complexType name='tDefinitions' >\r\n    <xs:complexContent>\r\n      <xs:extension base='wsdl:tExtensibleDocumented' >\r\n        <xs:sequence>\r\n          <xs:group ref='wsdl:anyTopLevelOptionalElement'  minOccurs='0'   maxOccurs='unbounded' />\r\n        </xs:sequence>\r\n        <xs:attribute name='targetNamespace' type='xs:anyURI' use='optional' />\r\n        <xs:attribute name='name' type='xs:NCName' use='optional' />\r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n   \r\n  <xs:complexType name='tImport' >\r\n    <xs:complexContent>\r\n      <xs:extension base='wsdl:tExtensibleAttributesDocumented' >\r\n        <xs:attribute name='namespace' type='xs:anyURI' use='required' />\r\n        <xs:attribute name='location' type='xs:anyURI' use='required' />\r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n   \r\n  <xs:complexType name='tTypes' >\r\n    <xs:complexContent>   \r\n      <xs:extension base='wsdl:tExtensibleDocumented' />\r\n    </xs:complexContent>   \r\n  </xs:complexType>\r\n     \r\n  <xs:complexType name='tMessage' >\r\n    <xs:complexContent>   \r\n      <xs:extension base='wsdl:tExtensibleDocumented' >\r\n        <xs:sequence>\r\n          <xs:element name='part' type='wsdl:tPart' minOccurs='0' maxOccurs='unbounded' />\r\n        </xs:sequence>\r\n        <xs:attribute name='name' type='xs:NCName' use='required' />\r\n      </xs:extension>\r\n    </xs:complexContent>   \r\n  </xs:complexType>\r\n\r\n  <xs:complexType name='tPart' >\r\n    <xs:complexContent>   \r\n      <xs:extension base='wsdl:tExtensibleAttributesDocumented' >\r\n        <xs:attribute name='name' type='xs:NCName' use='required' />\r\n        <xs:attribute name='element' type='xs:QName' use='optional' />\r\n        <xs:attribute name='type' type='xs:QName' use='optional' />    \r\n      </xs:extension>\r\n    </xs:complexContent>   \r\n  </xs:complexType>\r\n\r\n  <xs:complexType name='tPortType' >\r\n    <xs:complexContent>   \r\n      <xs:extension base='wsdl:tExtensibleAttributesDocumented' >\r\n        <xs:sequence>\r\n          <xs:element name='operation' type='wsdl:tOperation' minOccurs='0' maxOccurs='unbounded' />\r\n        </xs:sequence>\r\n        <xs:attribute name='name' type='xs:NCName' use='required' />\r\n      </xs:extension>\r\n    </xs:complexContent>   \r\n  </xs:complexType>\r\n   \r\n  <xs:complexType name='tOperation' >\r\n    <xs:complexContent>   \r\n      <xs:extension base='wsdl:tExtensibleDocumented' >\r\n\t    <xs:sequence>\r\n          <xs:choice>\r\n            <xs:group ref='wsdl:request-response-or-one-way-operation' />\r\n            <xs:group ref='wsdl:solicit-response-or-notification-operation' />\r\n          </xs:choice>\r\n        </xs:sequence>\r\n        <xs:attribute name='name' type='xs:NCName' use='required' />\r\n        <xs:attribute name='parameterOrder' type='xs:NMTOKENS' use='optional' />\r\n      </xs:extension>\r\n    </xs:complexContent>   \r\n  </xs:complexType>\r\n    \r\n  <xs:group name='request-response-or-one-way-operation' >\r\n    <xs:sequence>\r\n      <xs:element name='input' type='wsdl:tParam' />\r\n\t  <xs:sequence minOccurs='0' >\r\n\t    <xs:element name='output' type='wsdl:tParam' />\r\n\t\t<xs:element name='fault' type='wsdl:tFault' minOccurs='0' maxOccurs='unbounded' />\r\n      </xs:sequence>\r\n    </xs:sequence>\r\n  </xs:group>\r\n\r\n  <xs:group name='solicit-response-or-notification-operation' >\r\n    <xs:sequence>\r\n      <xs:element name='output' type='wsdl:tParam' />\r\n\t  <xs:sequence minOccurs='0' >\r\n\t    <xs:element name='input' type='wsdl:tParam' />\r\n\t\t<xs:element name='fault' type='wsdl:tFault' minOccurs='0' maxOccurs='unbounded' />\r\n\t  </xs:sequence>\r\n    </xs:sequence>\r\n  </xs:group>\r\n        \r\n  <xs:complexType name='tParam' >\r\n    <xs:complexContent>\r\n      <xs:extension base='wsdl:tExtensibleAttributesDocumented' >\r\n        <xs:attribute name='name' type='xs:NCName' use='optional' />\r\n        <xs:attribute name='message' type='xs:QName' use='required' />\r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n\r\n  <xs:complexType name='tFault' >\r\n    <xs:complexContent>\r\n      <xs:extension base='wsdl:tExtensibleAttributesDocumented' >\r\n        <xs:attribute name='name' type='xs:NCName'  use='required' />\r\n        <xs:attribute name='message' type='xs:QName' use='required' />\r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n     \r\n  <xs:complexType name='tBinding' >\r\n    <xs:complexContent>\r\n      <xs:extension base='wsdl:tExtensibleDocumented' >\r\n        <xs:sequence>\r\n          <xs:element name='operation' type='wsdl:tBindingOperation' minOccurs='0' maxOccurs='unbounded' />\r\n        </xs:sequence>\r\n        <xs:attribute name='name' type='xs:NCName' use='required' />\r\n        <xs:attribute name='type' type='xs:QName' use='required' />\r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n    \r\n  <xs:complexType name='tBindingOperationMessage' >\r\n    <xs:complexContent>\r\n      <xs:extension base='wsdl:tExtensibleDocumented' >\r\n        <xs:attribute name='name' type='xs:NCName' use='optional' />\r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n  \r\n  <xs:complexType name='tBindingOperationFault' >\r\n    <xs:complexContent>\r\n      <xs:extension base='wsdl:tExtensibleDocumented' >\r\n        <xs:attribute name='name' type='xs:NCName' use='required' />\r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n\r\n  <xs:complexType name='tBindingOperation' >\r\n    <xs:complexContent>\r\n      <xs:extension base='wsdl:tExtensibleDocumented' >\r\n        <xs:sequence>\r\n          <xs:element name='input' type='wsdl:tBindingOperationMessage' minOccurs='0' />\r\n          <xs:element name='output' type='wsdl:tBindingOperationMessage' minOccurs='0' />\r\n          <xs:element name='fault' type='wsdl:tBindingOperationFault' minOccurs='0' maxOccurs='unbounded' />\r\n        </xs:sequence>\r\n        <xs:attribute name='name' type='xs:NCName' use='required' />\r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n     \r\n  <xs:complexType name='tService' >\r\n    <xs:complexContent>\r\n      <xs:extension base='wsdl:tExtensibleDocumented' >\r\n        <xs:sequence>\r\n          <xs:element name='port' type='wsdl:tPort' minOccurs='0' maxOccurs='unbounded' />\r\n        </xs:sequence>\r\n        <xs:attribute name='name' type='xs:NCName' use='required' />\r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n     \r\n  <xs:complexType name='tPort' >\r\n    <xs:complexContent>\r\n      <xs:extension base='wsdl:tExtensibleDocumented' >\r\n        <xs:attribute name='name' type='xs:NCName' use='required' />\r\n        <xs:attribute name='binding' type='xs:QName' use='required' />\r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n\r\n  <xs:attribute name='arrayType' type='xs:string' />\r\n  <xs:attribute name='required' type='xs:boolean' />\r\n  <xs:complexType name='tExtensibilityElement' abstract='true' >\r\n    <xs:attribute ref='wsdl:required' use='optional' />\r\n  </xs:complexType>\r\n\r\n</xs:schema>";

		internal const string Soap = "<?xml version='1.0' encoding='UTF-8' ?> \r\n<xs:schema xmlns:soap='http://schemas.xmlsoap.org/wsdl/soap/' xmlns:wsdl='http://schemas.xmlsoap.org/wsdl/' targetNamespace='http://schemas.xmlsoap.org/wsdl/soap/' xmlns:xs='http://www.w3.org/2001/XMLSchema'>\r\n  <xs:import namespace='http://schemas.xmlsoap.org/wsdl/' />\r\n  <xs:simpleType name='encodingStyle'>\r\n    <xs:annotation>\r\n      <xs:documentation>\r\n      'encodingStyle' indicates any canonicalization conventions followed in the contents of the containing element.  For example, the value 'http://schemas.xmlsoap.org/soap/encoding/' indicates the pattern described in SOAP specification\r\n      </xs:documentation>\r\n    </xs:annotation>\r\n    <xs:list itemType='xs:anyURI' />\r\n  </xs:simpleType>\r\n  <xs:element name='binding' type='soap:tBinding' />\r\n  <xs:complexType name='tBinding'>\r\n    <xs:complexContent mixed='false'>\r\n      <xs:extension base='wsdl:tExtensibilityElement'>\r\n        <xs:attribute name='transport' type='xs:anyURI' use='required' />\r\n        <xs:attribute name='style' type='soap:tStyleChoice' use='optional' />\r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n  <xs:simpleType name='tStyleChoice'>\r\n    <xs:restriction base='xs:string'>\r\n      <xs:enumeration value='rpc' />\r\n      <xs:enumeration value='document' />\r\n    </xs:restriction>\r\n  </xs:simpleType>\r\n  <xs:element name='operation' type='soap:tOperation' />\r\n  <xs:complexType name='tOperation'>\r\n    <xs:complexContent mixed='false'>\r\n      <xs:extension base='wsdl:tExtensibilityElement'>\r\n        <xs:attribute name='soapAction' type='xs:anyURI' use='optional' />\r\n        <xs:attribute name='style' type='soap:tStyleChoice' use='optional' />\r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n  <xs:element name='body' type='soap:tBody' />\r\n  <xs:attributeGroup name='tBodyAttributes'>\r\n    <xs:attribute name='encodingStyle' type='soap:encodingStyle' use='optional' />\r\n    <xs:attribute name='use' type='soap:useChoice' use='optional' />\r\n    <xs:attribute name='namespace' type='xs:anyURI' use='optional' />\r\n  </xs:attributeGroup>\r\n  <xs:complexType name='tBody'>\r\n    <xs:complexContent mixed='false'>\r\n      <xs:extension base='wsdl:tExtensibilityElement'>\r\n        <xs:attribute name='parts' type='xs:NMTOKENS' use='optional' />\r\n        <xs:attributeGroup ref='soap:tBodyAttributes' />\r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n  <xs:simpleType name='useChoice'>\r\n    <xs:restriction base='xs:string'>\r\n      <xs:enumeration value='literal' />\r\n      <xs:enumeration value='encoded' />\r\n    </xs:restriction>\r\n  </xs:simpleType>\r\n  <xs:element name='fault' type='soap:tFault' />\r\n  <xs:complexType name='tFaultRes' abstract='true'>\r\n    <xs:complexContent mixed='false'>\r\n      <xs:restriction base='soap:tBody'>\r\n        <xs:attribute ref='wsdl:required' use='optional' />\r\n        <xs:attribute name='parts' type='xs:NMTOKENS' use='prohibited' />\r\n        <xs:attributeGroup ref='soap:tBodyAttributes' />\r\n      </xs:restriction>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n  <xs:complexType name='tFault'>\r\n    <xs:complexContent mixed='false'>\r\n      <xs:extension base='soap:tFaultRes'>\r\n        <xs:attribute name='name' type='xs:NCName' use='required' />\r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n  <xs:element name='header' type='soap:tHeader' />\r\n  <xs:attributeGroup name='tHeaderAttributes'>\r\n    <xs:attribute name='message' type='xs:QName' use='required' />\r\n    <xs:attribute name='part' type='xs:NMTOKEN' use='required' />\r\n    <xs:attribute name='use' type='soap:useChoice' use='required' />\r\n    <xs:attribute name='encodingStyle' type='soap:encodingStyle' use='optional' />\r\n    <xs:attribute name='namespace' type='xs:anyURI' use='optional' />\r\n  </xs:attributeGroup>\r\n  <xs:complexType name='tHeader'>\r\n    <xs:complexContent mixed='false'>\r\n      <xs:extension base='wsdl:tExtensibilityElement'>\r\n        <xs:sequence>\r\n          <xs:element minOccurs='0' maxOccurs='unbounded' ref='soap:headerfault' />\r\n        </xs:sequence>\r\n        <xs:attributeGroup ref='soap:tHeaderAttributes' />\r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n  <xs:element name='headerfault' type='soap:tHeaderFault' />\r\n  <xs:complexType name='tHeaderFault'>\r\n    <xs:attributeGroup ref='soap:tHeaderAttributes' />\r\n  </xs:complexType>\r\n  <xs:element name='address' type='soap:tAddress' />\r\n  <xs:complexType name='tAddress'>\r\n    <xs:complexContent mixed='false'>\r\n      <xs:extension base='wsdl:tExtensibilityElement'>\r\n        <xs:attribute name='location' type='xs:anyURI' use='required' />\r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n</xs:schema>";

		internal const string WebRef = "<?xml version='1.0' encoding='UTF-8' ?>\r\n<xs:schema xmlns:tns='http://microsoft.com/webReference/' elementFormDefault='qualified' targetNamespace='http://microsoft.com/webReference/' xmlns:xs='http://www.w3.org/2001/XMLSchema'>\r\n  <xs:simpleType name='options'>\r\n    <xs:list>\r\n      <xs:simpleType>\r\n        <xs:restriction base='xs:string'>\r\n          <xs:enumeration value='properties' />\r\n          <xs:enumeration value='newAsync' />\r\n          <xs:enumeration value='oldAsync' />\r\n          <xs:enumeration value='order' />\r\n          <xs:enumeration value='enableDataBinding' />\r\n        </xs:restriction>\r\n      </xs:simpleType>\r\n    </xs:list>\r\n  </xs:simpleType>\r\n  <xs:simpleType name='style'>\r\n    <xs:restriction base='xs:string'>\r\n      <xs:enumeration value='client' />\r\n      <xs:enumeration value='server' />\r\n      <xs:enumeration value='serverInterface' />\r\n    </xs:restriction>\r\n  </xs:simpleType>\r\n  <xs:complexType name='webReferenceOptions'>\r\n    <xs:all>\r\n      <xs:element minOccurs='0' default='oldAsync' name='codeGenerationOptions' type='tns:options' />\r\n      <xs:element minOccurs='0' default='client' name='style' type='tns:style' />\r\n      <xs:element minOccurs='0' default='false' name='verbose' type='xs:boolean' />\r\n      <xs:element minOccurs='0' name='schemaImporterExtensions'>\r\n        <xs:complexType>\r\n          <xs:sequence>\r\n            <xs:element minOccurs='0' maxOccurs='unbounded' name='type' type='xs:string' />\r\n          </xs:sequence>\r\n        </xs:complexType>\r\n      </xs:element>\r\n    </xs:all>\r\n  </xs:complexType>\r\n  <xs:element name='webReferenceOptions' type='tns:webReferenceOptions' />\r\n  <xs:complexType name='wsdlParameters'>\r\n    <xs:all>\r\n      <xs:element minOccurs='0' name='appSettingBaseUrl' type='xs:string' />\r\n      <xs:element minOccurs='0' name='appSettingUrlKey' type='xs:string' />\r\n      <xs:element minOccurs='0' name='domain' type='xs:string' />\r\n      <xs:element minOccurs='0' name='out' type='xs:string' />\r\n      <xs:element minOccurs='0' name='password' type='xs:string' />\r\n      <xs:element minOccurs='0' name='proxy' type='xs:string' />\r\n      <xs:element minOccurs='0' name='proxydomain' type='xs:string' />\r\n      <xs:element minOccurs='0' name='proxypassword' type='xs:string' />\r\n      <xs:element minOccurs='0' name='proxyusername' type='xs:string' />\r\n      <xs:element minOccurs='0' name='username' type='xs:string' />\r\n      <xs:element minOccurs='0' name='namespace' type='xs:string' />\r\n      <xs:element minOccurs='0' name='language' type='xs:string' />\r\n      <xs:element minOccurs='0' name='protocol' type='xs:string' />\r\n      <xs:element minOccurs='0' name='nologo' type='xs:boolean' />\r\n      <xs:element minOccurs='0' name='parsableerrors' type='xs:boolean' />\r\n      <xs:element minOccurs='0' name='sharetypes' type='xs:boolean' />\r\n      <xs:element minOccurs='0' name='webReferenceOptions' type='tns:webReferenceOptions' />\r\n      <xs:element minOccurs='0' name='documents'>\r\n        <xs:complexType>\r\n          <xs:sequence>\r\n            <xs:element minOccurs='0' maxOccurs='unbounded' name='document' type='xs:string' />\r\n          </xs:sequence>\r\n        </xs:complexType>\r\n      </xs:element>\r\n    </xs:all>\r\n  </xs:complexType>\r\n  <xs:element name='wsdlParameters' type='tns:wsdlParameters' />\r\n</xs:schema>";

		internal const string SoapEncoding = "<?xml version='1.0' encoding='UTF-8' ?>\r\n<xs:schema xmlns:xs='http://www.w3.org/2001/XMLSchema'\r\n           xmlns:tns='http://schemas.xmlsoap.org/soap/encoding/'\r\n           targetNamespace='http://schemas.xmlsoap.org/soap/encoding/' >\r\n        \r\n <xs:attribute name='root' >\r\n   <xs:simpleType>\r\n     <xs:restriction base='xs:boolean'>\r\n\t   <xs:pattern value='0|1' />\r\n\t </xs:restriction>\r\n   </xs:simpleType>\r\n </xs:attribute>\r\n\r\n  <xs:attributeGroup name='commonAttributes' >\r\n    <xs:attribute name='id' type='xs:ID' />\r\n    <xs:attribute name='href' type='xs:anyURI' />\r\n    <xs:anyAttribute namespace='##other' processContents='lax' />\r\n  </xs:attributeGroup>\r\n   \r\n  <xs:simpleType name='arrayCoordinate' >\r\n    <xs:restriction base='xs:string' />\r\n  </xs:simpleType>\r\n          \r\n  <xs:attribute name='arrayType' type='xs:string' />\r\n  <xs:attribute name='offset' type='tns:arrayCoordinate' />\r\n  \r\n  <xs:attributeGroup name='arrayAttributes' >\r\n    <xs:attribute ref='tns:arrayType' />\r\n    <xs:attribute ref='tns:offset' />\r\n  </xs:attributeGroup>    \r\n  \r\n  <xs:attribute name='position' type='tns:arrayCoordinate' /> \r\n  \r\n  <xs:attributeGroup name='arrayMemberAttributes' >\r\n    <xs:attribute ref='tns:position' />\r\n  </xs:attributeGroup>    \r\n\r\n  <xs:group name='Array' >\r\n    <xs:sequence>\r\n      <xs:any namespace='##any' minOccurs='0' maxOccurs='unbounded' processContents='lax' />\r\n\t</xs:sequence>\r\n  </xs:group>\r\n\r\n  <xs:element name='Array' type='tns:Array' />\r\n  <xs:complexType name='Array' >\r\n    <xs:group ref='tns:Array' minOccurs='0' />\r\n    <xs:attributeGroup ref='tns:arrayAttributes' />\r\n    <xs:attributeGroup ref='tns:commonAttributes' />\r\n  </xs:complexType> \r\n  <xs:element name='Struct' type='tns:Struct' />\r\n  <xs:group name='Struct' >\r\n    <xs:sequence>\r\n      <xs:any namespace='##any' minOccurs='0' maxOccurs='unbounded' processContents='lax' />\r\n\t</xs:sequence>\r\n  </xs:group>\r\n\r\n  <xs:complexType name='Struct' >\r\n    <xs:group ref='tns:Struct' minOccurs='0' />\r\n    <xs:attributeGroup ref='tns:commonAttributes'/>\r\n  </xs:complexType> \r\n  \r\n  <xs:simpleType name='base64' >\r\n    <xs:restriction base='xs:base64Binary' />\r\n  </xs:simpleType>\r\n\r\n  <xs:element name='duration' type='tns:duration' />\r\n  <xs:complexType name='duration' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:duration' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='dateTime' type='tns:dateTime' />\r\n  <xs:complexType name='dateTime' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:dateTime' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n\r\n\r\n  <xs:element name='NOTATION' type='tns:NOTATION' />\r\n  <xs:complexType name='NOTATION' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:QName' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n  \r\n\r\n  <xs:element name='time' type='tns:time' />\r\n  <xs:complexType name='time' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:time' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='date' type='tns:date' />\r\n  <xs:complexType name='date' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:date' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='gYearMonth' type='tns:gYearMonth' />\r\n  <xs:complexType name='gYearMonth' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:gYearMonth' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='gYear' type='tns:gYear' />\r\n  <xs:complexType name='gYear' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:gYear' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='gMonthDay' type='tns:gMonthDay' />\r\n  <xs:complexType name='gMonthDay' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:gMonthDay' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='gDay' type='tns:gDay' />\r\n  <xs:complexType name='gDay' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:gDay' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='gMonth' type='tns:gMonth' />\r\n  <xs:complexType name='gMonth' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:gMonth' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n  \r\n  <xs:element name='boolean' type='tns:boolean' />\r\n  <xs:complexType name='boolean' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:boolean' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='base64Binary' type='tns:base64Binary' />\r\n  <xs:complexType name='base64Binary' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:base64Binary' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='hexBinary' type='tns:hexBinary' />\r\n  <xs:complexType name='hexBinary' >\r\n    <xs:simpleContent>\r\n     <xs:extension base='xs:hexBinary' >\r\n       <xs:attributeGroup ref='tns:commonAttributes' />\r\n     </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='float' type='tns:float' />\r\n  <xs:complexType name='float' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:float' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='double' type='tns:double' />\r\n  <xs:complexType name='double' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:double' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='anyURI' type='tns:anyURI' />\r\n  <xs:complexType name='anyURI' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:anyURI' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='QName' type='tns:QName' />\r\n  <xs:complexType name='QName' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:QName' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  \r\n  <xs:element name='string' type='tns:string' />\r\n  <xs:complexType name='string' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:string' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='normalizedString' type='tns:normalizedString' />\r\n  <xs:complexType name='normalizedString' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:normalizedString' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='token' type='tns:token' />\r\n  <xs:complexType name='token' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:token' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='language' type='tns:language' />\r\n  <xs:complexType name='language' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:language' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='Name' type='tns:Name' />\r\n  <xs:complexType name='Name' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:Name' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='NMTOKEN' type='tns:NMTOKEN' />\r\n  <xs:complexType name='NMTOKEN' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:NMTOKEN' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='NCName' type='tns:NCName' />\r\n  <xs:complexType name='NCName' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:NCName' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='NMTOKENS' type='tns:NMTOKENS' />\r\n  <xs:complexType name='NMTOKENS' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:NMTOKENS' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='ID' type='tns:ID' />\r\n  <xs:complexType name='ID' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:ID' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='IDREF' type='tns:IDREF' />\r\n  <xs:complexType name='IDREF' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:IDREF' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='ENTITY' type='tns:ENTITY' />\r\n  <xs:complexType name='ENTITY' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:ENTITY' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='IDREFS' type='tns:IDREFS' />\r\n  <xs:complexType name='IDREFS' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:IDREFS' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='ENTITIES' type='tns:ENTITIES' />\r\n  <xs:complexType name='ENTITIES' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:ENTITIES' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='decimal' type='tns:decimal' />\r\n  <xs:complexType name='decimal' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:decimal' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='integer' type='tns:integer' />\r\n  <xs:complexType name='integer' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:integer' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='nonPositiveInteger' type='tns:nonPositiveInteger' />\r\n  <xs:complexType name='nonPositiveInteger' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:nonPositiveInteger' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='negativeInteger' type='tns:negativeInteger' />\r\n  <xs:complexType name='negativeInteger' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:negativeInteger' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='long' type='tns:long' />\r\n  <xs:complexType name='long' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:long' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='int' type='tns:int' />\r\n  <xs:complexType name='int' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:int' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='short' type='tns:short' />\r\n  <xs:complexType name='short' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:short' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='byte' type='tns:byte' />\r\n  <xs:complexType name='byte' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:byte' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='nonNegativeInteger' type='tns:nonNegativeInteger' />\r\n  <xs:complexType name='nonNegativeInteger' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:nonNegativeInteger' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='unsignedLong' type='tns:unsignedLong' />\r\n  <xs:complexType name='unsignedLong' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:unsignedLong' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='unsignedInt' type='tns:unsignedInt' />\r\n  <xs:complexType name='unsignedInt' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:unsignedInt' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='unsignedShort' type='tns:unsignedShort' />\r\n  <xs:complexType name='unsignedShort' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:unsignedShort' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='unsignedByte' type='tns:unsignedByte' />\r\n  <xs:complexType name='unsignedByte' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:unsignedByte' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='positiveInteger' type='tns:positiveInteger' />\r\n  <xs:complexType name='positiveInteger' >\r\n    <xs:simpleContent>\r\n      <xs:extension base='xs:positiveInteger' >\r\n        <xs:attributeGroup ref='tns:commonAttributes' />\r\n      </xs:extension>\r\n    </xs:simpleContent>\r\n  </xs:complexType>\r\n\r\n  <xs:element name='anyType' />\r\n</xs:schema>";

		private Schemas()
		{
		}
	}
	[Flags]
	public enum ServiceDescriptionImportWarnings
	{
		NoCodeGenerated = 1,
		OptionalExtensionsIgnored = 2,
		RequiredExtensionsIgnored = 4,
		UnsupportedOperationsIgnored = 8,
		UnsupportedBindingsIgnored = 0x10,
		NoMethodsGenerated = 0x20,
		SchemaValidation = 0x40,
		WsiConformance = 0x80
	}
	public enum ServiceDescriptionImportStyle
	{
		[XmlEnum("client")]
		Client,
		[XmlEnum("server")]
		Server,
		[XmlEnum("serverInterface")]
		ServerInterface
	}
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	public class ServiceDescriptionImporter
	{
		private ServiceDescriptionImportStyle style;

		private ServiceDescriptionCollection serviceDescriptions = new ServiceDescriptionCollection();

		private XmlSchemas schemas = new XmlSchemas();

		private XmlSchemas allSchemas = new XmlSchemas();

		private string protocolName;

		private CodeGenerationOptions options = CodeGenerationOptions.GenerateOldAsync;

		private CodeCompileUnit codeCompileUnit;

		private CodeDomProvider codeProvider;

		private ProtocolImporter[] importers;

		private XmlSchemas abstractSchemas = new XmlSchemas();

		private XmlSchemas concreteSchemas = new XmlSchemas();

		private List<Type> extensions;

		public ServiceDescriptionCollection ServiceDescriptions => serviceDescriptions;

		public XmlSchemas Schemas => schemas;

		public ServiceDescriptionImportStyle Style
		{
			get
			{
				return style;
			}
			set
			{
				style = value;
			}
		}

		[ComVisible(false)]
		public CodeGenerationOptions CodeGenerationOptions
		{
			get
			{
				return options;
			}
			set
			{
				options = value;
			}
		}

		internal CodeCompileUnit CodeCompileUnit => codeCompileUnit;

		[ComVisible(false)]
		public CodeDomProvider CodeGenerator
		{
			get
			{
				if (codeProvider == null)
				{
					codeProvider = new CSharpCodeProvider();
				}
				return codeProvider;
			}
			set
			{
				codeProvider = value;
			}
		}

		internal List<Type> Extensions
		{
			get
			{
				if (extensions == null)
				{
					extensions = new List<Type>();
				}
				return extensions;
			}
		}

		public string ProtocolName
		{
			get
			{
				if (protocolName != null)
				{
					return protocolName;
				}
				return string.Empty;
			}
			set
			{
				protocolName = value;
			}
		}

		internal XmlSchemas AllSchemas => allSchemas;

		internal XmlSchemas AbstractSchemas => abstractSchemas;

		internal XmlSchemas ConcreteSchemas => concreteSchemas;

		public ServiceDescriptionImporter()
		{
			Type[] protocolImporterTypes = WebServicesSection.Current.ProtocolImporterTypes;
			importers = new ProtocolImporter[protocolImporterTypes.Length];
			for (int i = 0; i < importers.Length; i++)
			{
				importers[i] = (ProtocolImporter)Activator.CreateInstance(protocolImporterTypes[i]);
				importers[i].Initialize(this);
			}
		}

		internal ServiceDescriptionImporter(CodeCompileUnit codeCompileUnit)
			: this()
		{
			this.codeCompileUnit = codeCompileUnit;
		}

		private ProtocolImporter FindImporterByName(string protocolName)
		{
			for (int i = 0; i < importers.Length; i++)
			{
				ProtocolImporter protocolImporter = importers[i];
				if (string.Compare(ProtocolName, protocolImporter.ProtocolName, StringComparison.OrdinalIgnoreCase) == 0)
				{
					return protocolImporter;
				}
			}
			throw new ArgumentException(Res.GetString("ProtocolWithNameIsNotRecognized1", protocolName), "protocolName");
		}

		public void AddServiceDescription(ServiceDescription serviceDescription, string appSettingUrlKey, string appSettingBaseUrl)
		{
			if (serviceDescription == null)
			{
				throw new ArgumentNullException("serviceDescription");
			}
			serviceDescription.AppSettingUrlKey = appSettingUrlKey;
			serviceDescription.AppSettingBaseUrl = appSettingBaseUrl;
			ServiceDescriptions.Add(serviceDescription);
		}

		public ServiceDescriptionImportWarnings Import(CodeNamespace codeNamespace, CodeCompileUnit codeCompileUnit)
		{
			if (codeCompileUnit != null)
			{
				codeCompileUnit.ReferencedAssemblies.Add("System.dll");
				codeCompileUnit.ReferencedAssemblies.Add("System.Xml.dll");
				codeCompileUnit.ReferencedAssemblies.Add("System.Web.Services.dll");
				codeCompileUnit.ReferencedAssemblies.Add("System.EnterpriseServices.dll");
			}
			return Import(codeNamespace, new ImportContext(new CodeIdentifiers(), shareTypes: false), new Hashtable(), new StringCollection());
		}

		public static StringCollection GenerateWebReferences(WebReferenceCollection webReferences, CodeDomProvider codeProvider, CodeCompileUnit codeCompileUnit, WebReferenceOptions options)
		{
			if (codeCompileUnit != null)
			{
				codeCompileUnit.ReferencedAssemblies.Add("System.dll");
				codeCompileUnit.ReferencedAssemblies.Add("System.Xml.dll");
				codeCompileUnit.ReferencedAssemblies.Add("System.Web.Services.dll");
				codeCompileUnit.ReferencedAssemblies.Add("System.EnterpriseServices.dll");
			}
			Hashtable hashtable = new Hashtable();
			Hashtable exportContext = new Hashtable();
			foreach (WebReference webReference in webReferences)
			{
				ServiceDescriptionImporter serviceDescriptionImporter = new ServiceDescriptionImporter(codeCompileUnit);
				XmlSchemas xmlSchemas = new XmlSchemas();
				ServiceDescriptionCollection serviceDescriptionCollection = new ServiceDescriptionCollection();
				foreach (DictionaryEntry document in webReference.Documents)
				{
					AddDocument((string)document.Key, document.Value, xmlSchemas, serviceDescriptionCollection, webReference.ValidationWarnings);
				}
				serviceDescriptionImporter.Schemas.Add(xmlSchemas);
				foreach (ServiceDescription item in serviceDescriptionCollection)
				{
					serviceDescriptionImporter.AddServiceDescription(item, webReference.AppSettingUrlKey, webReference.AppSettingBaseUrl);
				}
				serviceDescriptionImporter.CodeGenerator = codeProvider;
				serviceDescriptionImporter.ProtocolName = webReference.ProtocolName;
				serviceDescriptionImporter.Style = options.Style;
				serviceDescriptionImporter.CodeGenerationOptions = options.CodeGenerationOptions;
				StringEnumerator enumerator3 = options.SchemaImporterExtensions.GetEnumerator();
				try
				{
					while (enumerator3.MoveNext())
					{
						string current = enumerator3.Current;
						serviceDescriptionImporter.Extensions.Add(Type.GetType(current, throwOnError: true));
					}
				}
				finally
				{
					if (enumerator3 is IDisposable disposable)
					{
						disposable.Dispose();
					}
				}
				ImportContext importContext = Context(webReference.ProxyCode, hashtable, options.Verbose);
				webReference.Warnings = serviceDescriptionImporter.Import(webReference.ProxyCode, importContext, exportContext, webReference.ValidationWarnings);
				if (webReference.ValidationWarnings.Count != 0)
				{
					webReference.Warnings |= ServiceDescriptionImportWarnings.SchemaValidation;
				}
			}
			StringCollection stringCollection = new StringCollection();
			if (options.Verbose)
			{
				foreach (ImportContext value in hashtable.Values)
				{
					StringEnumerator enumerator5 = value.Warnings.GetEnumerator();
					try
					{
						while (enumerator5.MoveNext())
						{
							string current2 = enumerator5.Current;
							stringCollection.Add(current2);
						}
					}
					finally
					{
						if (enumerator5 is IDisposable disposable2)
						{
							disposable2.Dispose();
						}
					}
				}
				return stringCollection;
			}
			return stringCollection;
		}

		internal static ImportContext Context(CodeNamespace ns, Hashtable namespaces, bool verbose)
		{
			if (namespaces[ns.Name] == null)
			{
				namespaces[ns.Name] = new ImportContext(new CodeIdentifiers(), shareTypes: true);
			}
			return (ImportContext)namespaces[ns.Name];
		}

		internal static void AddDocument(string path, object document, XmlSchemas schemas, ServiceDescriptionCollection descriptions, StringCollection warnings)
		{
			if (document is ServiceDescription serviceDescription)
			{
				descriptions.Add(serviceDescription);
			}
			else if (document is XmlSchema schema)
			{
				schemas.Add(schema);
			}
		}

		private void FindUse(MessagePart part, out bool isEncoded, out bool isLiteral)
		{
			isEncoded = false;
			isLiteral = false;
			string name = part.Message.Name;
			Operation operation = null;
			ServiceDescription serviceDescription = part.Message.ServiceDescription;
			foreach (PortType portType in serviceDescription.PortTypes)
			{
				foreach (Operation operation2 in portType.Operations)
				{
					foreach (OperationMessage message in operation2.Messages)
					{
						if (message.Message.Equals(new XmlQualifiedName(part.Message.Name, serviceDescription.TargetNamespace)))
						{
							operation = operation2;
							FindUse(operation, serviceDescription, name, ref isEncoded, ref isLiteral);
						}
					}
				}
			}
			if (operation == null)
			{
				FindUse(null, serviceDescription, name, ref isEncoded, ref isLiteral);
			}
		}

		private void FindUse(Operation operation, ServiceDescription description, string messageName, ref bool isEncoded, ref bool isLiteral)
		{
			string targetNamespace = description.TargetNamespace;
			foreach (Binding binding in description.Bindings)
			{
				if (operation != null && !new XmlQualifiedName(operation.PortType.Name, targetNamespace).Equals(binding.Type))
				{
					continue;
				}
				foreach (OperationBinding operation2 in binding.Operations)
				{
					if (operation2.Input != null)
					{
						foreach (object extension in operation2.Input.Extensions)
						{
							if (operation != null)
							{
								if (extension is SoapBodyBinding soapBodyBinding && operation.IsBoundBy(operation2))
								{
									if (soapBodyBinding.Use == SoapBindingUse.Encoded)
									{
										isEncoded = true;
									}
									else if (soapBodyBinding.Use == SoapBindingUse.Literal)
									{
										isLiteral = true;
									}
								}
							}
							else if (extension is SoapHeaderBinding soapHeaderBinding && soapHeaderBinding.Message.Name == messageName)
							{
								if (soapHeaderBinding.Use == SoapBindingUse.Encoded)
								{
									isEncoded = true;
								}
								else if (soapHeaderBinding.Use == SoapBindingUse.Literal)
								{
									isLiteral = true;
								}
							}
						}
					}
					if (operation2.Output == null)
					{
						continue;
					}
					foreach (object extension2 in operation2.Output.Extensions)
					{
						if (operation != null)
						{
							if (!operation.IsBoundBy(operation2))
							{
								continue;
							}
							if (extension2 is SoapBodyBinding soapBodyBinding2)
							{
								if (soapBodyBinding2.Use == SoapBindingUse.Encoded)
								{
									isEncoded = true;
								}
								else if (soapBodyBinding2.Use == SoapBindingUse.Literal)
								{
									isLiteral = true;
								}
							}
							else if (extension2 is MimeXmlBinding)
							{
								isLiteral = true;
							}
						}
						else if (extension2 is SoapHeaderBinding soapHeaderBinding2 && soapHeaderBinding2.Message.Name == messageName)
						{
							if (soapHeaderBinding2.Use == SoapBindingUse.Encoded)
							{
								isEncoded = true;
							}
							else if (soapHeaderBinding2.Use == SoapBindingUse.Literal)
							{
								isLiteral = true;
							}
						}
					}
				}
			}
		}

		private void AddImport(XmlSchema schema, Hashtable imports)
		{
			if (schema == null || imports[schema] != null)
			{
				return;
			}
			imports.Add(schema, schema);
			foreach (XmlSchemaExternal include in schema.Includes)
			{
				if (!(include is XmlSchemaImport))
				{
					continue;
				}
				XmlSchemaImport xmlSchemaImport = (XmlSchemaImport)include;
				foreach (XmlSchema schema2 in allSchemas.GetSchemas(xmlSchemaImport.Namespace))
				{
					AddImport(schema2, imports);
				}
			}
		}

		private ServiceDescriptionImportWarnings Import(CodeNamespace codeNamespace, ImportContext importContext, Hashtable exportContext, StringCollection warnings)
		{
			allSchemas = new XmlSchemas();
			foreach (XmlSchema schema7 in schemas)
			{
				allSchemas.Add(schema7);
			}
			foreach (ServiceDescription serviceDescription3 in serviceDescriptions)
			{
				foreach (XmlSchema schema8 in serviceDescription3.Types.Schemas)
				{
					allSchemas.Add(schema8);
				}
			}
			Hashtable hashtable = new Hashtable();
			if (!allSchemas.Contains("http://schemas.xmlsoap.org/wsdl/"))
			{
				allSchemas.AddReference(ServiceDescription.Schema);
				hashtable[ServiceDescription.Schema] = ServiceDescription.Schema;
			}
			if (!allSchemas.Contains("http://schemas.xmlsoap.org/soap/encoding/"))
			{
				allSchemas.AddReference(ServiceDescription.SoapEncodingSchema);
				hashtable[ServiceDescription.SoapEncodingSchema] = ServiceDescription.SoapEncodingSchema;
			}
			allSchemas.Compile(null, fullCompile: false);
			foreach (ServiceDescription serviceDescription4 in serviceDescriptions)
			{
				foreach (Message message in serviceDescription4.Messages)
				{
					foreach (MessagePart part in message.Parts)
					{
						FindUse(part, out var isEncoded, out var isLiteral);
						if (part.Element != null && !part.Element.IsEmpty)
						{
							if (isEncoded)
							{
								throw new InvalidOperationException(Res.GetString("CanTSpecifyElementOnEncodedMessagePartsPart", part.Name, message.Name));
							}
							XmlSchemaElement xmlSchemaElement = (XmlSchemaElement)allSchemas.Find(part.Element, typeof(XmlSchemaElement));
							if (xmlSchemaElement != null)
							{
								AddSchema(xmlSchemaElement.Parent as XmlSchema, isEncoded, isLiteral, abstractSchemas, concreteSchemas, hashtable);
								if (xmlSchemaElement.SchemaTypeName != null && !xmlSchemaElement.SchemaTypeName.IsEmpty)
								{
									XmlSchemaType xmlSchemaType = (XmlSchemaType)allSchemas.Find(xmlSchemaElement.SchemaTypeName, typeof(XmlSchemaType));
									if (xmlSchemaType != null)
									{
										AddSchema(xmlSchemaType.Parent as XmlSchema, isEncoded, isLiteral, abstractSchemas, concreteSchemas, hashtable);
									}
								}
							}
						}
						if (part.Type != null && !part.Type.IsEmpty)
						{
							XmlSchemaType xmlSchemaType2 = (XmlSchemaType)allSchemas.Find(part.Type, typeof(XmlSchemaType));
							if (xmlSchemaType2 != null)
							{
								AddSchema(xmlSchemaType2.Parent as XmlSchema, isEncoded, isLiteral, abstractSchemas, concreteSchemas, hashtable);
							}
						}
					}
				}
			}
			XmlSchemas[] array = new XmlSchemas[2] { abstractSchemas, concreteSchemas };
			Hashtable hashtable2;
			foreach (XmlSchemas xmlSchemas in array)
			{
				hashtable2 = new Hashtable();
				foreach (XmlSchema item in xmlSchemas)
				{
					AddImport(item, hashtable2);
				}
				foreach (XmlSchema key in hashtable2.Keys)
				{
					if (hashtable[key] == null && !xmlSchemas.Contains(key))
					{
						xmlSchemas.Add(key);
					}
				}
			}
			hashtable2 = new Hashtable();
			foreach (XmlSchema allSchema in allSchemas)
			{
				if (!abstractSchemas.Contains(allSchema) && !concreteSchemas.Contains(allSchema))
				{
					AddImport(allSchema, hashtable2);
				}
			}
			foreach (XmlSchema key2 in hashtable2.Keys)
			{
				if (hashtable[key2] == null)
				{
					if (!abstractSchemas.Contains(key2))
					{
						abstractSchemas.Add(key2);
					}
					if (!concreteSchemas.Contains(key2))
					{
						concreteSchemas.Add(key2);
					}
				}
			}
			if (abstractSchemas.Count > 0)
			{
				foreach (XmlSchema value in hashtable.Values)
				{
					abstractSchemas.AddReference(value);
				}
				StringCollection stringCollection = SchemaCompiler.Compile(abstractSchemas);
				StringEnumerator enumerator12 = stringCollection.GetEnumerator();
				try
				{
					while (enumerator12.MoveNext())
					{
						string current = enumerator12.Current;
						warnings.Add(current);
					}
				}
				finally
				{
					if (enumerator12 is IDisposable disposable)
					{
						disposable.Dispose();
					}
				}
			}
			if (concreteSchemas.Count > 0)
			{
				foreach (XmlSchema value2 in hashtable.Values)
				{
					concreteSchemas.AddReference(value2);
				}
				StringCollection stringCollection2 = SchemaCompiler.Compile(concreteSchemas);
				StringEnumerator enumerator14 = stringCollection2.GetEnumerator();
				try
				{
					while (enumerator14.MoveNext())
					{
						string current2 = enumerator14.Current;
						warnings.Add(current2);
					}
				}
				finally
				{
					if (enumerator14 is IDisposable disposable2)
					{
						disposable2.Dispose();
					}
				}
			}
			if (ProtocolName.Length > 0)
			{
				ProtocolImporter protocolImporter = FindImporterByName(ProtocolName);
				if (protocolImporter.GenerateCode(codeNamespace, importContext, exportContext))
				{
					return protocolImporter.Warnings;
				}
			}
			else
			{
				for (int j = 0; j < importers.Length; j++)
				{
					ProtocolImporter protocolImporter2 = importers[j];
					if (protocolImporter2.GenerateCode(codeNamespace, importContext, exportContext))
					{
						return protocolImporter2.Warnings;
					}
				}
			}
			return ServiceDescriptionImportWarnings.NoCodeGenerated;
		}

		private static void AddSchema(XmlSchema schema, bool isEncoded, bool isLiteral, XmlSchemas abstractSchemas, XmlSchemas concreteSchemas, Hashtable references)
		{
			if (schema == null)
			{
				return;
			}
			if (isEncoded && !abstractSchemas.Contains(schema))
			{
				if (references.Contains(schema))
				{
					abstractSchemas.AddReference(schema);
				}
				else
				{
					abstractSchemas.Add(schema);
				}
			}
			if (isLiteral && !concreteSchemas.Contains(schema))
			{
				if (references.Contains(schema))
				{
					concreteSchemas.AddReference(schema);
				}
				else
				{
					concreteSchemas.Add(schema);
				}
			}
		}
	}
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	public class ServiceDescriptionReflector
	{
		private ProtocolReflector[] reflectors;

		private ProtocolReflector[] reflectorsWithPost;

		private ServiceDescriptionCollection descriptions = new ServiceDescriptionCollection();

		private XmlSchemas schemas = new XmlSchemas();

		private ServiceDescriptionCollection descriptionsWithPost;

		private XmlSchemas schemasWithPost;

		private WebServiceAttribute serviceAttr;

		private ServiceDescription description;

		private Service service;

		private LogicalMethodInfo[] methods;

		private XmlSchemaExporter exporter;

		private XmlReflectionImporter importer;

		private Type serviceType;

		private string serviceUrl;

		private Hashtable reflectionContext;

		public ServiceDescriptionCollection ServiceDescriptions => descriptions;

		public XmlSchemas Schemas => schemas;

		internal ServiceDescriptionCollection ServiceDescriptionsWithPost => descriptionsWithPost;

		internal XmlSchemas SchemasWithPost => schemasWithPost;

		internal ServiceDescription ServiceDescription => description;

		internal Service Service => service;

		internal Type ServiceType => serviceType;

		internal LogicalMethodInfo[] Methods => methods;

		internal string ServiceUrl => serviceUrl;

		internal XmlSchemaExporter SchemaExporter => exporter;

		internal XmlReflectionImporter ReflectionImporter => importer;

		internal WebServiceAttribute ServiceAttribute => serviceAttr;

		internal Hashtable ReflectionContext
		{
			get
			{
				if (reflectionContext == null)
				{
					reflectionContext = new Hashtable();
				}
				return reflectionContext;
			}
		}

		public ServiceDescriptionReflector()
		{
			Type[] protocolReflectorTypes = WebServicesSection.Current.ProtocolReflectorTypes;
			reflectors = new ProtocolReflector[protocolReflectorTypes.Length];
			for (int i = 0; i < reflectors.Length; i++)
			{
				ProtocolReflector protocolReflector = (ProtocolReflector)Activator.CreateInstance(protocolReflectorTypes[i]);
				protocolReflector.Initialize(this);
				reflectors[i] = protocolReflector;
			}
			WebServiceProtocols enabledProtocols = WebServicesSection.Current.EnabledProtocols;
			if ((enabledProtocols & WebServiceProtocols.HttpPost) == 0 && (enabledProtocols & WebServiceProtocols.HttpPostLocalhost) != 0)
			{
				reflectorsWithPost = new ProtocolReflector[reflectors.Length + 1];
				for (int j = 0; j < reflectorsWithPost.Length - 1; j++)
				{
					ProtocolReflector protocolReflector2 = (ProtocolReflector)Activator.CreateInstance(protocolReflectorTypes[j]);
					protocolReflector2.Initialize(this);
					reflectorsWithPost[j] = protocolReflector2;
				}
				ProtocolReflector protocolReflector3 = new HttpPostProtocolReflector();
				protocolReflector3.Initialize(this);
				reflectorsWithPost[reflectorsWithPost.Length - 1] = protocolReflector3;
			}
		}

		private void ReflectInternal(ProtocolReflector[] reflectors)
		{
			description = new ServiceDescription();
			description.TargetNamespace = serviceAttr.Namespace;
			ServiceDescriptions.Add(description);
			service = new Service();
			string name = serviceAttr.Name;
			if (name == null || name.Length == 0)
			{
				name = serviceType.Name;
			}
			service.Name = XmlConvert.EncodeLocalName(name);
			if (serviceAttr.Description != null && serviceAttr.Description.Length > 0)
			{
				service.Documentation = serviceAttr.Description;
			}
			description.Services.Add(service);
			reflectionContext = new Hashtable();
			exporter = new XmlSchemaExporter(description.Types.Schemas);
			importer = SoapReflector.CreateXmlImporter(serviceAttr.Namespace, SoapReflector.ServiceDefaultIsEncoded(serviceType));
			WebMethodReflector.IncludeTypes(methods, importer);
			for (int i = 0; i < reflectors.Length; i++)
			{
				reflectors[i].Reflect();
			}
		}

		public void Reflect(Type type, string url)
		{
			serviceType = type;
			serviceUrl = url;
			serviceAttr = WebServiceReflector.GetAttribute(type);
			methods = WebMethodReflector.GetMethods(type);
			CheckForDuplicateMethods(methods);
			descriptionsWithPost = descriptions;
			schemasWithPost = schemas;
			if (reflectorsWithPost != null)
			{
				ReflectInternal(reflectorsWithPost);
				descriptions = new ServiceDescriptionCollection();
				schemas = new XmlSchemas();
			}
			ReflectInternal(reflectors);
			if (serviceAttr.Description != null && serviceAttr.Description.Length > 0)
			{
				ServiceDescription.Documentation = serviceAttr.Description;
			}
			ServiceDescription.Types.Schemas.Compile(null, fullCompile: false);
			if (ServiceDescriptions.Count > 1)
			{
				Schemas.Add(ServiceDescription.Types.Schemas);
				ServiceDescription.Types.Schemas.Clear();
			}
			else
			{
				if (ServiceDescription.Types.Schemas.Count <= 0)
				{
					return;
				}
				XmlSchema[] array = new XmlSchema[ServiceDescription.Types.Schemas.Count];
				ServiceDescription.Types.Schemas.CopyTo(array, 0);
				XmlSchema[] array2 = array;
				foreach (XmlSchema schema in array2)
				{
					if (XmlSchemas.IsDataSet(schema))
					{
						ServiceDescription.Types.Schemas.Remove(schema);
						Schemas.Add(schema);
					}
				}
			}
		}

		private void CheckForDuplicateMethods(LogicalMethodInfo[] methods)
		{
			Hashtable hashtable = new Hashtable();
			foreach (LogicalMethodInfo logicalMethodInfo in methods)
			{
				WebMethodAttribute methodAttribute = logicalMethodInfo.MethodAttribute;
				string text = methodAttribute.MessageName;
				if (text.Length == 0)
				{
					text = logicalMethodInfo.Name;
				}
				string key = ((logicalMethodInfo.Binding == null) ? text : (logicalMethodInfo.Binding.Name + "." + text));
				LogicalMethodInfo logicalMethodInfo2 = (LogicalMethodInfo)hashtable[key];
				if (logicalMethodInfo2 != null)
				{
					throw new InvalidOperationException(Res.GetString("BothAndUseTheMessageNameUseTheMessageName3", logicalMethodInfo, logicalMethodInfo2, XmlConvert.EncodeLocalName(text)));
				}
				hashtable.Add(key, logicalMethodInfo);
			}
		}
	}
	public sealed class ServiceDescriptionCollection : ServiceDescriptionBaseCollection
	{
		public ServiceDescription this[int index]
		{
			get
			{
				return (ServiceDescription)base.List[index];
			}
			set
			{
				base.List[index] = value;
			}
		}

		public ServiceDescription this[string ns] => (ServiceDescription)Table[ns];

		public ServiceDescriptionCollection()
			: base(null)
		{
		}

		public int Add(ServiceDescription serviceDescription)
		{
			return base.List.Add(serviceDescription);
		}

		public void Insert(int index, ServiceDescription serviceDescription)
		{
			base.List.Insert(index, serviceDescription);
		}

		public int IndexOf(ServiceDescription serviceDescription)
		{
			return base.List.IndexOf(serviceDescription);
		}

		public bool Contains(ServiceDescription serviceDescription)
		{
			return base.List.Contains(serviceDescription);
		}

		public void Remove(ServiceDescription serviceDescription)
		{
			base.List.Remove(serviceDescription);
		}

		public void CopyTo(ServiceDescription[] array, int index)
		{
			base.List.CopyTo(array, index);
		}

		protected override string GetKey(object value)
		{
			string targetNamespace = ((ServiceDescription)value).TargetNamespace;
			if (targetNamespace == null)
			{
				return string.Empty;
			}
			return targetNamespace;
		}

		private Exception ItemNotFound(XmlQualifiedName name, string type)
		{
			return new Exception(Res.GetString("WebDescriptionMissingItem", type, name.Name, name.Namespace));
		}

		public Message GetMessage(XmlQualifiedName name)
		{
			ServiceDescription serviceDescription = GetServiceDescription(name);
			Message message = null;
			while (message == null && serviceDescription != null)
			{
				message = serviceDescription.Messages[name.Name];
				serviceDescription = serviceDescription.Next;
			}
			if (message == null)
			{
				throw ItemNotFound(name, "message");
			}
			return message;
		}

		public PortType GetPortType(XmlQualifiedName name)
		{
			ServiceDescription serviceDescription = GetServiceDescription(name);
			PortType portType = null;
			while (portType == null && serviceDescription != null)
			{
				portType = serviceDescription.PortTypes[name.Name];
				serviceDescription = serviceDescription.Next;
			}
			if (portType == null)
			{
				throw ItemNotFound(name, "message");
			}
			return portType;
		}

		public Service GetService(XmlQualifiedName name)
		{
			ServiceDescription serviceDescription = GetServiceDescription(name);
			Service service = null;
			while (service == null && serviceDescription != null)
			{
				service = serviceDescription.Services[name.Name];
				serviceDescription = serviceDescription.Next;
			}
			if (service == null)
			{
				throw ItemNotFound(name, "service");
			}
			return service;
		}

		public Binding GetBinding(XmlQualifiedName name)
		{
			ServiceDescription serviceDescription = GetServiceDescription(name);
			Binding binding = null;
			while (binding == null && serviceDescription != null)
			{
				binding = serviceDescription.Bindings[name.Name];
				serviceDescription = serviceDescription.Next;
			}
			if (binding == null)
			{
				throw ItemNotFound(name, "binding");
			}
			return binding;
		}

		private ServiceDescription GetServiceDescription(XmlQualifiedName name)
		{
			ServiceDescription serviceDescription = this[name.Namespace];
			if (serviceDescription == null)
			{
				throw new ArgumentException(Res.GetString("WebDescriptionMissing", name.ToString(), name.Namespace), "name");
			}
			return serviceDescription;
		}

		protected override void SetParent(object value, object parent)
		{
			((ServiceDescription)value).SetParent((ServiceDescriptionCollection)parent);
		}

		protected override void OnInsertComplete(int index, object value)
		{
			string key = GetKey(value);
			if (key != null)
			{
				_ = (ServiceDescription)Table[key];
				((ServiceDescription)value).Next = (ServiceDescription)Table[key];
				Table[key] = value;
			}
			SetParent(value, this);
		}
	}
	internal class ServiceDescriptionSerializationWriter : XmlSerializationWriter
	{
		public void Write125_definitions(object o)
		{
			WriteStartDocument();
			if (o == null)
			{
				WriteNullTagLiteral("definitions", "http://schemas.xmlsoap.org/wsdl/");
				return;
			}
			TopLevelElement();
			Write124_ServiceDescription("definitions", "http://schemas.xmlsoap.org/wsdl/", (ServiceDescription)o, isNullable: true, needType: false);
		}

		private void Write124_ServiceDescription(string n, string ns, ServiceDescription o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(ServiceDescription))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("ServiceDescription", "http://schemas.xmlsoap.org/wsdl/");
			}
			XmlAttribute[] extensibleAttributes = o.ExtensibleAttributes;
			if (extensibleAttributes != null)
			{
				foreach (XmlAttribute node in extensibleAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("name", "", o.Name);
			WriteAttribute("targetNamespace", "", o.TargetNamespace);
			if (o.DocumentationElement != null || o.DocumentationElement == null)
			{
				WriteElementLiteral(o.DocumentationElement, "documentation", "http://schemas.xmlsoap.org/wsdl/", isNullable: false, any: true);
				ServiceDescriptionFormatExtensionCollection extensions = o.Extensions;
				if (extensions != null)
				{
					for (int j = 0; j < ((ICollection)extensions).Count; j++)
					{
						if (extensions[j] is XmlNode || extensions[j] == null)
						{
							WriteElementLiteral((XmlNode)extensions[j], "", null, isNullable: false, any: true);
							continue;
						}
						throw CreateInvalidAnyTypeException(extensions[j]);
					}
				}
				ImportCollection imports = o.Imports;
				if (imports != null)
				{
					for (int k = 0; k < ((ICollection)imports).Count; k++)
					{
						Write4_Import("import", "http://schemas.xmlsoap.org/wsdl/", imports[k], isNullable: false, needType: false);
					}
				}
				Write67_Types("types", "http://schemas.xmlsoap.org/wsdl/", o.Types, isNullable: false, needType: false);
				MessageCollection messages = o.Messages;
				if (messages != null)
				{
					for (int l = 0; l < ((ICollection)messages).Count; l++)
					{
						Write69_Message("message", "http://schemas.xmlsoap.org/wsdl/", messages[l], isNullable: false, needType: false);
					}
				}
				PortTypeCollection portTypes = o.PortTypes;
				if (portTypes != null)
				{
					for (int m = 0; m < ((ICollection)portTypes).Count; m++)
					{
						Write75_PortType("portType", "http://schemas.xmlsoap.org/wsdl/", portTypes[m], isNullable: false, needType: false);
					}
				}
				BindingCollection bindings = o.Bindings;
				if (bindings != null)
				{
					for (int num = 0; num < ((ICollection)bindings).Count; num++)
					{
						Write117_Binding("binding", "http://schemas.xmlsoap.org/wsdl/", bindings[num], isNullable: false, needType: false);
					}
				}
				ServiceCollection services = o.Services;
				if (services != null)
				{
					for (int num2 = 0; num2 < ((ICollection)services).Count; num2++)
					{
						Write123_Service("service", "http://schemas.xmlsoap.org/wsdl/", services[num2], isNullable: false, needType: false);
					}
				}
				WriteEndElement(o);
				return;
			}
			throw CreateInvalidAnyTypeException(o.DocumentationElement);
		}

		private void Write123_Service(string n, string ns, Service o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(Service))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("Service", "http://schemas.xmlsoap.org/wsdl/");
			}
			XmlAttribute[] extensibleAttributes = o.ExtensibleAttributes;
			if (extensibleAttributes != null)
			{
				foreach (XmlAttribute node in extensibleAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("name", "", o.Name);
			if (o.DocumentationElement != null || o.DocumentationElement == null)
			{
				WriteElementLiteral(o.DocumentationElement, "documentation", "http://schemas.xmlsoap.org/wsdl/", isNullable: false, any: true);
				ServiceDescriptionFormatExtensionCollection extensions = o.Extensions;
				if (extensions != null)
				{
					for (int j = 0; j < ((ICollection)extensions).Count; j++)
					{
						if (extensions[j] is XmlNode || extensions[j] == null)
						{
							WriteElementLiteral((XmlNode)extensions[j], "", null, isNullable: false, any: true);
							continue;
						}
						throw CreateInvalidAnyTypeException(extensions[j]);
					}
				}
				PortCollection ports = o.Ports;
				if (ports != null)
				{
					for (int k = 0; k < ((ICollection)ports).Count; k++)
					{
						Write122_Port("port", "http://schemas.xmlsoap.org/wsdl/", ports[k], isNullable: false, needType: false);
					}
				}
				WriteEndElement(o);
				return;
			}
			throw CreateInvalidAnyTypeException(o.DocumentationElement);
		}

		private void Write122_Port(string n, string ns, Port o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(Port))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("Port", "http://schemas.xmlsoap.org/wsdl/");
			}
			XmlAttribute[] extensibleAttributes = o.ExtensibleAttributes;
			if (extensibleAttributes != null)
			{
				foreach (XmlAttribute node in extensibleAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("name", "", o.Name);
			WriteAttribute("binding", "", FromXmlQualifiedName(o.Binding));
			if (o.DocumentationElement != null || o.DocumentationElement == null)
			{
				WriteElementLiteral(o.DocumentationElement, "documentation", "http://schemas.xmlsoap.org/wsdl/", isNullable: false, any: true);
				ServiceDescriptionFormatExtensionCollection extensions = o.Extensions;
				if (extensions != null)
				{
					for (int j = 0; j < ((ICollection)extensions).Count; j++)
					{
						object obj = extensions[j];
						if (obj is Soap12AddressBinding)
						{
							Write121_Soap12AddressBinding("address", "http://schemas.xmlsoap.org/wsdl/soap12/", (Soap12AddressBinding)obj, isNullable: false, needType: false);
						}
						else if (obj is HttpAddressBinding)
						{
							Write118_HttpAddressBinding("address", "http://schemas.xmlsoap.org/wsdl/http/", (HttpAddressBinding)obj, isNullable: false, needType: false);
						}
						else if (obj is SoapAddressBinding)
						{
							Write119_SoapAddressBinding("address", "http://schemas.xmlsoap.org/wsdl/soap/", (SoapAddressBinding)obj, isNullable: false, needType: false);
						}
						else if (obj is XmlElement)
						{
							XmlElement xmlElement = (XmlElement)obj;
							if (xmlElement == null && xmlElement != null)
							{
								throw CreateInvalidAnyTypeException(xmlElement);
							}
							WriteElementLiteral(xmlElement, "", null, isNullable: false, any: true);
						}
						else if (obj != null)
						{
							throw CreateUnknownTypeException(obj);
						}
					}
				}
				WriteEndElement(o);
				return;
			}
			throw CreateInvalidAnyTypeException(o.DocumentationElement);
		}

		private void Write119_SoapAddressBinding(string n, string ns, SoapAddressBinding o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(SoapAddressBinding))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, null);
			if (needType)
			{
				WriteXsiType("SoapAddressBinding", "http://schemas.xmlsoap.org/wsdl/soap/");
			}
			if (o.Required)
			{
				WriteAttribute("required", "http://schemas.xmlsoap.org/wsdl/", XmlConvert.ToString(o.Required));
			}
			WriteAttribute("location", "", o.Location);
			WriteEndElement(o);
		}

		private void Write118_HttpAddressBinding(string n, string ns, HttpAddressBinding o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(HttpAddressBinding))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, null);
			if (needType)
			{
				WriteXsiType("HttpAddressBinding", "http://schemas.xmlsoap.org/wsdl/http/");
			}
			if (o.Required)
			{
				WriteAttribute("required", "http://schemas.xmlsoap.org/wsdl/", XmlConvert.ToString(o.Required));
			}
			WriteAttribute("location", "", o.Location);
			WriteEndElement(o);
		}

		private void Write121_Soap12AddressBinding(string n, string ns, Soap12AddressBinding o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(Soap12AddressBinding))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, null);
			if (needType)
			{
				WriteXsiType("Soap12AddressBinding", "http://schemas.xmlsoap.org/wsdl/soap12/");
			}
			if (o.Required)
			{
				WriteAttribute("required", "http://schemas.xmlsoap.org/wsdl/", XmlConvert.ToString(o.Required));
			}
			WriteAttribute("location", "", o.Location);
			WriteEndElement(o);
		}

		private void Write117_Binding(string n, string ns, Binding o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(Binding))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("Binding", "http://schemas.xmlsoap.org/wsdl/");
			}
			XmlAttribute[] extensibleAttributes = o.ExtensibleAttributes;
			if (extensibleAttributes != null)
			{
				foreach (XmlAttribute node in extensibleAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("name", "", o.Name);
			WriteAttribute("type", "", FromXmlQualifiedName(o.Type));
			if (o.DocumentationElement != null || o.DocumentationElement == null)
			{
				WriteElementLiteral(o.DocumentationElement, "documentation", "http://schemas.xmlsoap.org/wsdl/", isNullable: false, any: true);
				ServiceDescriptionFormatExtensionCollection extensions = o.Extensions;
				if (extensions != null)
				{
					for (int j = 0; j < ((ICollection)extensions).Count; j++)
					{
						object obj = extensions[j];
						if (obj is Soap12Binding)
						{
							Write84_Soap12Binding("binding", "http://schemas.xmlsoap.org/wsdl/soap12/", (Soap12Binding)obj, isNullable: false, needType: false);
						}
						else if (obj is HttpBinding)
						{
							Write77_HttpBinding("binding", "http://schemas.xmlsoap.org/wsdl/http/", (HttpBinding)obj, isNullable: false, needType: false);
						}
						else if (obj is SoapBinding)
						{
							Write80_SoapBinding("binding", "http://schemas.xmlsoap.org/wsdl/soap/", (SoapBinding)obj, isNullable: false, needType: false);
						}
						else if (obj is XmlElement)
						{
							XmlElement xmlElement = (XmlElement)obj;
							if (xmlElement == null && xmlElement != null)
							{
								throw CreateInvalidAnyTypeException(xmlElement);
							}
							WriteElementLiteral(xmlElement, "", null, isNullable: false, any: true);
						}
						else if (obj != null)
						{
							throw CreateUnknownTypeException(obj);
						}
					}
				}
				OperationBindingCollection operations = o.Operations;
				if (operations != null)
				{
					for (int k = 0; k < ((ICollection)operations).Count; k++)
					{
						Write116_OperationBinding("operation", "http://schemas.xmlsoap.org/wsdl/", operations[k], isNullable: false, needType: false);
					}
				}
				WriteEndElement(o);
				return;
			}
			throw CreateInvalidAnyTypeException(o.DocumentationElement);
		}

		private void Write116_OperationBinding(string n, string ns, OperationBinding o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(OperationBinding))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("OperationBinding", "http://schemas.xmlsoap.org/wsdl/");
			}
			XmlAttribute[] extensibleAttributes = o.ExtensibleAttributes;
			if (extensibleAttributes != null)
			{
				foreach (XmlAttribute node in extensibleAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("name", "", o.Name);
			if (o.DocumentationElement != null || o.DocumentationElement == null)
			{
				WriteElementLiteral(o.DocumentationElement, "documentation", "http://schemas.xmlsoap.org/wsdl/", isNullable: false, any: true);
				ServiceDescriptionFormatExtensionCollection extensions = o.Extensions;
				if (extensions != null)
				{
					for (int j = 0; j < ((ICollection)extensions).Count; j++)
					{
						object obj = extensions[j];
						if (obj is Soap12OperationBinding)
						{
							Write88_Soap12OperationBinding("operation", "http://schemas.xmlsoap.org/wsdl/soap12/", (Soap12OperationBinding)obj, isNullable: false, needType: false);
						}
						else if (obj is HttpOperationBinding)
						{
							Write85_HttpOperationBinding("operation", "http://schemas.xmlsoap.org/wsdl/http/", (HttpOperationBinding)obj, isNullable: false, needType: false);
						}
						else if (obj is SoapOperationBinding)
						{
							Write86_SoapOperationBinding("operation", "http://schemas.xmlsoap.org/wsdl/soap/", (SoapOperationBinding)obj, isNullable: false, needType: false);
						}
						else if (obj is XmlElement)
						{
							XmlElement xmlElement = (XmlElement)obj;
							if (xmlElement == null && xmlElement != null)
							{
								throw CreateInvalidAnyTypeException(xmlElement);
							}
							WriteElementLiteral(xmlElement, "", null, isNullable: false, any: true);
						}
						else if (obj != null)
						{
							throw CreateUnknownTypeException(obj);
						}
					}
				}
				Write110_InputBinding("input", "http://schemas.xmlsoap.org/wsdl/", o.Input, isNullable: false, needType: false);
				Write111_OutputBinding("output", "http://schemas.xmlsoap.org/wsdl/", o.Output, isNullable: false, needType: false);
				FaultBindingCollection faults = o.Faults;
				if (faults != null)
				{
					for (int k = 0; k < ((ICollection)faults).Count; k++)
					{
						Write115_FaultBinding("fault", "http://schemas.xmlsoap.org/wsdl/", faults[k], isNullable: false, needType: false);
					}
				}
				WriteEndElement(o);
				return;
			}
			throw CreateInvalidAnyTypeException(o.DocumentationElement);
		}

		private void Write115_FaultBinding(string n, string ns, FaultBinding o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(FaultBinding))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("FaultBinding", "http://schemas.xmlsoap.org/wsdl/");
			}
			XmlAttribute[] extensibleAttributes = o.ExtensibleAttributes;
			if (extensibleAttributes != null)
			{
				foreach (XmlAttribute node in extensibleAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("name", "", o.Name);
			if (o.DocumentationElement != null || o.DocumentationElement == null)
			{
				WriteElementLiteral(o.DocumentationElement, "documentation", "http://schemas.xmlsoap.org/wsdl/", isNullable: false, any: true);
				ServiceDescriptionFormatExtensionCollection extensions = o.Extensions;
				if (extensions != null)
				{
					for (int j = 0; j < ((ICollection)extensions).Count; j++)
					{
						object obj = extensions[j];
						if (obj is Soap12FaultBinding)
						{
							Write114_Soap12FaultBinding("fault", "http://schemas.xmlsoap.org/wsdl/soap12/", (Soap12FaultBinding)obj, isNullable: false, needType: false);
						}
						else if (obj is SoapFaultBinding)
						{
							Write112_SoapFaultBinding("fault", "http://schemas.xmlsoap.org/wsdl/soap/", (SoapFaultBinding)obj, isNullable: false, needType: false);
						}
						else if (obj is XmlElement)
						{
							XmlElement xmlElement = (XmlElement)obj;
							if (xmlElement == null && xmlElement != null)
							{
								throw CreateInvalidAnyTypeException(xmlElement);
							}
							WriteElementLiteral(xmlElement, "", null, isNullable: false, any: true);
						}
						else if (obj != null)
						{
							throw CreateUnknownTypeException(obj);
						}
					}
				}
				WriteEndElement(o);
				return;
			}
			throw CreateInvalidAnyTypeException(o.DocumentationElement);
		}

		private void Write112_SoapFaultBinding(string n, string ns, SoapFaultBinding o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(SoapFaultBinding))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, null);
			if (needType)
			{
				WriteXsiType("SoapFaultBinding", "http://schemas.xmlsoap.org/wsdl/soap/");
			}
			if (o.Required)
			{
				WriteAttribute("required", "http://schemas.xmlsoap.org/wsdl/", XmlConvert.ToString(o.Required));
			}
			if (o.Use != 0)
			{
				WriteAttribute("use", "", Write98_SoapBindingUse(o.Use));
			}
			WriteAttribute("name", "", o.Name);
			WriteAttribute("namespace", "", o.Namespace);
			if (o.Encoding != null && o.Encoding.Length != 0)
			{
				WriteAttribute("encodingStyle", "", o.Encoding);
			}
			WriteEndElement(o);
		}

		private string Write98_SoapBindingUse(SoapBindingUse v)
		{
			string text = null;
			return v switch
			{
				SoapBindingUse.Encoded => "encoded", 
				SoapBindingUse.Literal => "literal", 
				_ => throw CreateInvalidEnumValueException(((long)v).ToString(CultureInfo.InvariantCulture), "System.Web.Services.Description.SoapBindingUse"), 
			};
		}

		private void Write114_Soap12FaultBinding(string n, string ns, Soap12FaultBinding o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(Soap12FaultBinding))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, null);
			if (needType)
			{
				WriteXsiType("Soap12FaultBinding", "http://schemas.xmlsoap.org/wsdl/soap12/");
			}
			if (o.Required)
			{
				WriteAttribute("required", "http://schemas.xmlsoap.org/wsdl/", XmlConvert.ToString(o.Required));
			}
			if (o.Use != 0)
			{
				WriteAttribute("use", "", Write100_SoapBindingUse(o.Use));
			}
			WriteAttribute("name", "", o.Name);
			WriteAttribute("namespace", "", o.Namespace);
			if (o.Encoding != null && o.Encoding.Length != 0)
			{
				WriteAttribute("encodingStyle", "", o.Encoding);
			}
			WriteEndElement(o);
		}

		private string Write100_SoapBindingUse(SoapBindingUse v)
		{
			string text = null;
			return v switch
			{
				SoapBindingUse.Encoded => "encoded", 
				SoapBindingUse.Literal => "literal", 
				_ => throw CreateInvalidEnumValueException(((long)v).ToString(CultureInfo.InvariantCulture), "System.Web.Services.Description.SoapBindingUse"), 
			};
		}

		private void Write111_OutputBinding(string n, string ns, OutputBinding o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(OutputBinding))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("OutputBinding", "http://schemas.xmlsoap.org/wsdl/");
			}
			XmlAttribute[] extensibleAttributes = o.ExtensibleAttributes;
			if (extensibleAttributes != null)
			{
				foreach (XmlAttribute node in extensibleAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("name", "", o.Name);
			if (o.DocumentationElement != null || o.DocumentationElement == null)
			{
				WriteElementLiteral(o.DocumentationElement, "documentation", "http://schemas.xmlsoap.org/wsdl/", isNullable: false, any: true);
				ServiceDescriptionFormatExtensionCollection extensions = o.Extensions;
				if (extensions != null)
				{
					for (int j = 0; j < ((ICollection)extensions).Count; j++)
					{
						object obj = extensions[j];
						if (obj is Soap12BodyBinding)
						{
							Write102_Soap12BodyBinding("body", "http://schemas.xmlsoap.org/wsdl/soap12/", (Soap12BodyBinding)obj, isNullable: false, needType: false);
						}
						else if (obj is Soap12HeaderBinding)
						{
							Write109_Soap12HeaderBinding("header", "http://schemas.xmlsoap.org/wsdl/soap12/", (Soap12HeaderBinding)obj, isNullable: false, needType: false);
						}
						else if (obj is SoapHeaderBinding)
						{
							Write106_SoapHeaderBinding("header", "http://schemas.xmlsoap.org/wsdl/soap/", (SoapHeaderBinding)obj, isNullable: false, needType: false);
						}
						else if (obj is SoapBodyBinding)
						{
							Write99_SoapBodyBinding("body", "http://schemas.xmlsoap.org/wsdl/soap/", (SoapBodyBinding)obj, isNullable: false, needType: false);
						}
						else if (obj is MimeXmlBinding)
						{
							Write94_MimeXmlBinding("mimeXml", "http://schemas.xmlsoap.org/wsdl/mime/", (MimeXmlBinding)obj, isNullable: false, needType: false);
						}
						else if (obj is MimeContentBinding)
						{
							Write93_MimeContentBinding("content", "http://schemas.xmlsoap.org/wsdl/mime/", (MimeContentBinding)obj, isNullable: false, needType: false);
						}
						else if (obj is MimeTextBinding)
						{
							Write97_MimeTextBinding("text", "http://microsoft.com/wsdl/mime/textMatching/", (MimeTextBinding)obj, isNullable: false, needType: false);
						}
						else if (obj is MimeMultipartRelatedBinding)
						{
							Write104_MimeMultipartRelatedBinding("multipartRelated", "http://schemas.xmlsoap.org/wsdl/mime/", (MimeMultipartRelatedBinding)obj, isNullable: false, needType: false);
						}
						else if (obj is XmlElement)
						{
							XmlElement xmlElement = (XmlElement)obj;
							if (xmlElement == null && xmlElement != null)
							{
								throw CreateInvalidAnyTypeException(xmlElement);
							}
							WriteElementLiteral(xmlElement, "", null, isNullable: false, any: true);
						}
						else if (obj != null)
						{
							throw CreateUnknownTypeException(obj);
						}
					}
				}
				WriteEndElement(o);
				return;
			}
			throw CreateInvalidAnyTypeException(o.DocumentationElement);
		}

		private void Write104_MimeMultipartRelatedBinding(string n, string ns, MimeMultipartRelatedBinding o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(MimeMultipartRelatedBinding))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, null);
			if (needType)
			{
				WriteXsiType("MimeMultipartRelatedBinding", "http://schemas.xmlsoap.org/wsdl/mime/");
			}
			if (o.Required)
			{
				WriteAttribute("required", "http://schemas.xmlsoap.org/wsdl/", XmlConvert.ToString(o.Required));
			}
			MimePartCollection parts = o.Parts;
			if (parts != null)
			{
				for (int i = 0; i < ((ICollection)parts).Count; i++)
				{
					Write103_MimePart("part", "http://schemas.xmlsoap.org/wsdl/mime/", parts[i], isNullable: false, needType: false);
				}
			}
			WriteEndElement(o);
		}

		private void Write103_MimePart(string n, string ns, MimePart o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(MimePart))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, null);
			if (needType)
			{
				WriteXsiType("MimePart", "http://schemas.xmlsoap.org/wsdl/mime/");
			}
			if (o.Required)
			{
				WriteAttribute("required", "http://schemas.xmlsoap.org/wsdl/", XmlConvert.ToString(o.Required));
			}
			ServiceDescriptionFormatExtensionCollection extensions = o.Extensions;
			if (extensions != null)
			{
				for (int i = 0; i < ((ICollection)extensions).Count; i++)
				{
					object obj = extensions[i];
					if (obj is Soap12BodyBinding)
					{
						Write102_Soap12BodyBinding("body", "http://schemas.xmlsoap.org/wsdl/soap12/", (Soap12BodyBinding)obj, isNullable: false, needType: false);
					}
					else if (obj is SoapBodyBinding)
					{
						Write99_SoapBodyBinding("body", "http://schemas.xmlsoap.org/wsdl/soap/", (SoapBodyBinding)obj, isNullable: false, needType: false);
					}
					else if (obj is MimeContentBinding)
					{
						Write93_MimeContentBinding("content", "http://schemas.xmlsoap.org/wsdl/mime/", (MimeContentBinding)obj, isNullable: false, needType: false);
					}
					else if (obj is MimeXmlBinding)
					{
						Write94_MimeXmlBinding("mimeXml", "http://schemas.xmlsoap.org/wsdl/mime/", (MimeXmlBinding)obj, isNullable: false, needType: false);
					}
					else if (obj is MimeTextBinding)
					{
						Write97_MimeTextBinding("text", "http://microsoft.com/wsdl/mime/textMatching/", (MimeTextBinding)obj, isNullable: false, needType: false);
					}
					else if (obj is XmlElement)
					{
						XmlElement xmlElement = (XmlElement)obj;
						if (xmlElement == null && xmlElement != null)
						{
							throw CreateInvalidAnyTypeException(xmlElement);
						}
						WriteElementLiteral(xmlElement, "", null, isNullable: false, any: true);
					}
					else if (obj != null)
					{
						throw CreateUnknownTypeException(obj);
					}
				}
			}
			WriteEndElement(o);
		}

		private void Write97_MimeTextBinding(string n, string ns, MimeTextBinding o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(MimeTextBinding))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, null);
			if (needType)
			{
				WriteXsiType("MimeTextBinding", "http://microsoft.com/wsdl/mime/textMatching/");
			}
			if (o.Required)
			{
				WriteAttribute("required", "http://schemas.xmlsoap.org/wsdl/", XmlConvert.ToString(o.Required));
			}
			MimeTextMatchCollection matches = o.Matches;
			if (matches != null)
			{
				for (int i = 0; i < ((ICollection)matches).Count; i++)
				{
					Write96_MimeTextMatch("match", "http://microsoft.com/wsdl/mime/textMatching/", matches[i], isNullable: false, needType: false);
				}
			}
			WriteEndElement(o);
		}

		private void Write96_MimeTextMatch(string n, string ns, MimeTextMatch o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(MimeTextMatch))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, null);
			if (needType)
			{
				WriteXsiType("MimeTextMatch", "http://microsoft.com/wsdl/mime/textMatching/");
			}
			WriteAttribute("name", "", o.Name);
			WriteAttribute("type", "", o.Type);
			if (o.Group != 1)
			{
				WriteAttribute("group", "", XmlConvert.ToString(o.Group));
			}
			if (o.Capture != 0)
			{
				WriteAttribute("capture", "", XmlConvert.ToString(o.Capture));
			}
			if (o.RepeatsString != "1")
			{
				WriteAttribute("repeats", "", o.RepeatsString);
			}
			WriteAttribute("pattern", "", o.Pattern);
			WriteAttribute("ignoreCase", "", XmlConvert.ToString(o.IgnoreCase));
			MimeTextMatchCollection matches = o.Matches;
			if (matches != null)
			{
				for (int i = 0; i < ((ICollection)matches).Count; i++)
				{
					Write96_MimeTextMatch("match", "http://microsoft.com/wsdl/mime/textMatching/", matches[i], isNullable: false, needType: false);
				}
			}
			WriteEndElement(o);
		}

		private void Write94_MimeXmlBinding(string n, string ns, MimeXmlBinding o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(MimeXmlBinding))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, null);
			if (needType)
			{
				WriteXsiType("MimeXmlBinding", "http://schemas.xmlsoap.org/wsdl/mime/");
			}
			if (o.Required)
			{
				WriteAttribute("required", "http://schemas.xmlsoap.org/wsdl/", XmlConvert.ToString(o.Required));
			}
			WriteAttribute("part", "", o.Part);
			WriteEndElement(o);
		}

		private void Write93_MimeContentBinding(string n, string ns, MimeContentBinding o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(MimeContentBinding))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, null);
			if (needType)
			{
				WriteXsiType("MimeContentBinding", "http://schemas.xmlsoap.org/wsdl/mime/");
			}
			if (o.Required)
			{
				WriteAttribute("required", "http://schemas.xmlsoap.org/wsdl/", XmlConvert.ToString(o.Required));
			}
			WriteAttribute("part", "", o.Part);
			WriteAttribute("type", "", o.Type);
			WriteEndElement(o);
		}

		private void Write99_SoapBodyBinding(string n, string ns, SoapBodyBinding o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(SoapBodyBinding))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, null);
			if (needType)
			{
				WriteXsiType("SoapBodyBinding", "http://schemas.xmlsoap.org/wsdl/soap/");
			}
			if (o.Required)
			{
				WriteAttribute("required", "http://schemas.xmlsoap.org/wsdl/", XmlConvert.ToString(o.Required));
			}
			if (o.Use != 0)
			{
				WriteAttribute("use", "", Write98_SoapBindingUse(o.Use));
			}
			if (o.Namespace != null && o.Namespace.Length != 0)
			{
				WriteAttribute("namespace", "", o.Namespace);
			}
			if (o.Encoding != null && o.Encoding.Length != 0)
			{
				WriteAttribute("encodingStyle", "", o.Encoding);
			}
			WriteAttribute("parts", "", o.PartsString);
			WriteEndElement(o);
		}

		private void Write102_Soap12BodyBinding(string n, string ns, Soap12BodyBinding o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(Soap12BodyBinding))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, null);
			if (needType)
			{
				WriteXsiType("Soap12BodyBinding", "http://schemas.xmlsoap.org/wsdl/soap12/");
			}
			if (o.Required)
			{
				WriteAttribute("required", "http://schemas.xmlsoap.org/wsdl/", XmlConvert.ToString(o.Required));
			}
			if (o.Use != 0)
			{
				WriteAttribute("use", "", Write100_SoapBindingUse(o.Use));
			}
			if (o.Namespace != null && o.Namespace.Length != 0)
			{
				WriteAttribute("namespace", "", o.Namespace);
			}
			if (o.Encoding != null && o.Encoding.Length != 0)
			{
				WriteAttribute("encodingStyle", "", o.Encoding);
			}
			WriteAttribute("parts", "", o.PartsString);
			WriteEndElement(o);
		}

		private void Write106_SoapHeaderBinding(string n, string ns, SoapHeaderBinding o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(SoapHeaderBinding))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, null);
			if (needType)
			{
				WriteXsiType("SoapHeaderBinding", "http://schemas.xmlsoap.org/wsdl/soap/");
			}
			if (o.Required)
			{
				WriteAttribute("required", "http://schemas.xmlsoap.org/wsdl/", XmlConvert.ToString(o.Required));
			}
			WriteAttribute("message", "", FromXmlQualifiedName(o.Message));
			WriteAttribute("part", "", o.Part);
			if (o.Use != 0)
			{
				WriteAttribute("use", "", Write98_SoapBindingUse(o.Use));
			}
			if (o.Encoding != null && o.Encoding.Length != 0)
			{
				WriteAttribute("encodingStyle", "", o.Encoding);
			}
			if (o.Namespace != null && o.Namespace.Length != 0)
			{
				WriteAttribute("namespace", "", o.Namespace);
			}
			Write105_SoapHeaderFaultBinding("headerfault", "http://schemas.xmlsoap.org/wsdl/soap/", o.Fault, isNullable: false, needType: false);
			WriteEndElement(o);
		}

		private void Write105_SoapHeaderFaultBinding(string n, string ns, SoapHeaderFaultBinding o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(SoapHeaderFaultBinding))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, null);
			if (needType)
			{
				WriteXsiType("SoapHeaderFaultBinding", "http://schemas.xmlsoap.org/wsdl/soap/");
			}
			if (o.Required)
			{
				WriteAttribute("required", "http://schemas.xmlsoap.org/wsdl/", XmlConvert.ToString(o.Required));
			}
			WriteAttribute("message", "", FromXmlQualifiedName(o.Message));
			WriteAttribute("part", "", o.Part);
			if (o.Use != 0)
			{
				WriteAttribute("use", "", Write98_SoapBindingUse(o.Use));
			}
			if (o.Encoding != null && o.Encoding.Length != 0)
			{
				WriteAttribute("encodingStyle", "", o.Encoding);
			}
			if (o.Namespace != null && o.Namespace.Length != 0)
			{
				WriteAttribute("namespace", "", o.Namespace);
			}
			WriteEndElement(o);
		}

		private void Write109_Soap12HeaderBinding(string n, string ns, Soap12HeaderBinding o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(Soap12HeaderBinding))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, null);
			if (needType)
			{
				WriteXsiType("Soap12HeaderBinding", "http://schemas.xmlsoap.org/wsdl/soap12/");
			}
			if (o.Required)
			{
				WriteAttribute("required", "http://schemas.xmlsoap.org/wsdl/", XmlConvert.ToString(o.Required));
			}
			WriteAttribute("message", "", FromXmlQualifiedName(o.Message));
			WriteAttribute("part", "", o.Part);
			if (o.Use != 0)
			{
				WriteAttribute("use", "", Write100_SoapBindingUse(o.Use));
			}
			if (o.Encoding != null && o.Encoding.Length != 0)
			{
				WriteAttribute("encodingStyle", "", o.Encoding);
			}
			if (o.Namespace != null && o.Namespace.Length != 0)
			{
				WriteAttribute("namespace", "", o.Namespace);
			}
			Write107_SoapHeaderFaultBinding("headerfault", "http://schemas.xmlsoap.org/wsdl/soap12/", o.Fault, isNullable: false, needType: false);
			WriteEndElement(o);
		}

		private void Write107_SoapHeaderFaultBinding(string n, string ns, SoapHeaderFaultBinding o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(SoapHeaderFaultBinding))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, null);
			if (needType)
			{
				WriteXsiType("SoapHeaderFaultBinding", "http://schemas.xmlsoap.org/wsdl/soap12/");
			}
			if (o.Required)
			{
				WriteAttribute("required", "http://schemas.xmlsoap.org/wsdl/", XmlConvert.ToString(o.Required));
			}
			WriteAttribute("message", "", FromXmlQualifiedName(o.Message));
			WriteAttribute("part", "", o.Part);
			if (o.Use != 0)
			{
				WriteAttribute("use", "", Write100_SoapBindingUse(o.Use));
			}
			if (o.Encoding != null && o.Encoding.Length != 0)
			{
				WriteAttribute("encodingStyle", "", o.Encoding);
			}
			if (o.Namespace != null && o.Namespace.Length != 0)
			{
				WriteAttribute("namespace", "", o.Namespace);
			}
			WriteEndElement(o);
		}

		private void Write110_InputBinding(string n, string ns, InputBinding o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(InputBinding))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("InputBinding", "http://schemas.xmlsoap.org/wsdl/");
			}
			XmlAttribute[] extensibleAttributes = o.ExtensibleAttributes;
			if (extensibleAttributes != null)
			{
				foreach (XmlAttribute node in extensibleAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("name", "", o.Name);
			if (o.DocumentationElement != null || o.DocumentationElement == null)
			{
				WriteElementLiteral(o.DocumentationElement, "documentation", "http://schemas.xmlsoap.org/wsdl/", isNullable: false, any: true);
				ServiceDescriptionFormatExtensionCollection extensions = o.Extensions;
				if (extensions != null)
				{
					for (int j = 0; j < ((ICollection)extensions).Count; j++)
					{
						object obj = extensions[j];
						if (obj is Soap12BodyBinding)
						{
							Write102_Soap12BodyBinding("body", "http://schemas.xmlsoap.org/wsdl/soap12/", (Soap12BodyBinding)obj, isNullable: false, needType: false);
						}
						else if (obj is Soap12HeaderBinding)
						{
							Write109_Soap12HeaderBinding("header", "http://schemas.xmlsoap.org/wsdl/soap12/", (Soap12HeaderBinding)obj, isNullable: false, needType: false);
						}
						else if (obj is SoapBodyBinding)
						{
							Write99_SoapBodyBinding("body", "http://schemas.xmlsoap.org/wsdl/soap/", (SoapBodyBinding)obj, isNullable: false, needType: false);
						}
						else if (obj is SoapHeaderBinding)
						{
							Write106_SoapHeaderBinding("header", "http://schemas.xmlsoap.org/wsdl/soap/", (SoapHeaderBinding)obj, isNullable: false, needType: false);
						}
						else if (obj is MimeTextBinding)
						{
							Write97_MimeTextBinding("text", "http://microsoft.com/wsdl/mime/textMatching/", (MimeTextBinding)obj, isNullable: false, needType: false);
						}
						else if (obj is HttpUrlReplacementBinding)
						{
							Write91_HttpUrlReplacementBinding("urlReplacement", "http://schemas.xmlsoap.org/wsdl/http/", (HttpUrlReplacementBinding)obj, isNullable: false, needType: false);
						}
						else if (obj is HttpUrlEncodedBinding)
						{
							Write90_HttpUrlEncodedBinding("urlEncoded", "http://schemas.xmlsoap.org/wsdl/http/", (HttpUrlEncodedBinding)obj, isNullable: false, needType: false);
						}
						else if (obj is MimeContentBinding)
						{
							Write93_MimeContentBinding("content", "http://schemas.xmlsoap.org/wsdl/mime/", (MimeContentBinding)obj, isNullable: false, needType: false);
						}
						else if (obj is MimeMultipartRelatedBinding)
						{
							Write104_MimeMultipartRelatedBinding("multipartRelated", "http://schemas.xmlsoap.org/wsdl/mime/", (MimeMultipartRelatedBinding)obj, isNullable: false, needType: false);
						}
						else if (obj is MimeXmlBinding)
						{
							Write94_MimeXmlBinding("mimeXml", "http://schemas.xmlsoap.org/wsdl/mime/", (MimeXmlBinding)obj, isNullable: false, needType: false);
						}
						else if (obj is XmlElement)
						{
							XmlElement xmlElement = (XmlElement)obj;
							if (xmlElement == null && xmlElement != null)
							{
								throw CreateInvalidAnyTypeException(xmlElement);
							}
							WriteElementLiteral(xmlElement, "", null, isNullable: false, any: true);
						}
						else if (obj != null)
						{
							throw CreateUnknownTypeException(obj);
						}
					}
				}
				WriteEndElement(o);
				return;
			}
			throw CreateInvalidAnyTypeException(o.DocumentationElement);
		}

		private void Write90_HttpUrlEncodedBinding(string n, string ns, HttpUrlEncodedBinding o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(HttpUrlEncodedBinding))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, null);
			if (needType)
			{
				WriteXsiType("HttpUrlEncodedBinding", "http://schemas.xmlsoap.org/wsdl/http/");
			}
			if (o.Required)
			{
				WriteAttribute("required", "http://schemas.xmlsoap.org/wsdl/", XmlConvert.ToString(o.Required));
			}
			WriteEndElement(o);
		}

		private void Write91_HttpUrlReplacementBinding(string n, string ns, HttpUrlReplacementBinding o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(HttpUrlReplacementBinding))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, null);
			if (needType)
			{
				WriteXsiType("HttpUrlReplacementBinding", "http://schemas.xmlsoap.org/wsdl/http/");
			}
			if (o.Required)
			{
				WriteAttribute("required", "http://schemas.xmlsoap.org/wsdl/", XmlConvert.ToString(o.Required));
			}
			WriteEndElement(o);
		}

		private void Write86_SoapOperationBinding(string n, string ns, SoapOperationBinding o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(SoapOperationBinding))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, null);
			if (needType)
			{
				WriteXsiType("SoapOperationBinding", "http://schemas.xmlsoap.org/wsdl/soap/");
			}
			if (o.Required)
			{
				WriteAttribute("required", "http://schemas.xmlsoap.org/wsdl/", XmlConvert.ToString(o.Required));
			}
			WriteAttribute("soapAction", "", o.SoapAction);
			if (o.Style != 0)
			{
				WriteAttribute("style", "", Write79_SoapBindingStyle(o.Style));
			}
			WriteEndElement(o);
		}

		private string Write79_SoapBindingStyle(SoapBindingStyle v)
		{
			string text = null;
			return v switch
			{
				SoapBindingStyle.Document => "document", 
				SoapBindingStyle.Rpc => "rpc", 
				_ => throw CreateInvalidEnumValueException(((long)v).ToString(CultureInfo.InvariantCulture), "System.Web.Services.Description.SoapBindingStyle"), 
			};
		}

		private void Write85_HttpOperationBinding(string n, string ns, HttpOperationBinding o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(HttpOperationBinding))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, null);
			if (needType)
			{
				WriteXsiType("HttpOperationBinding", "http://schemas.xmlsoap.org/wsdl/http/");
			}
			if (o.Required)
			{
				WriteAttribute("required", "http://schemas.xmlsoap.org/wsdl/", XmlConvert.ToString(o.Required));
			}
			WriteAttribute("location", "", o.Location);
			WriteEndElement(o);
		}

		private void Write88_Soap12OperationBinding(string n, string ns, Soap12OperationBinding o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(Soap12OperationBinding))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, null);
			if (needType)
			{
				WriteXsiType("Soap12OperationBinding", "http://schemas.xmlsoap.org/wsdl/soap12/");
			}
			if (o.Required)
			{
				WriteAttribute("required", "http://schemas.xmlsoap.org/wsdl/", XmlConvert.ToString(o.Required));
			}
			WriteAttribute("soapAction", "", o.SoapAction);
			if (o.Style != 0)
			{
				WriteAttribute("style", "", Write82_SoapBindingStyle(o.Style));
			}
			if (o.SoapActionRequired)
			{
				WriteAttribute("soapActionRequired", "", XmlConvert.ToString(o.SoapActionRequired));
			}
			WriteEndElement(o);
		}

		private string Write82_SoapBindingStyle(SoapBindingStyle v)
		{
			string text = null;
			return v switch
			{
				SoapBindingStyle.Document => "document", 
				SoapBindingStyle.Rpc => "rpc", 
				_ => throw CreateInvalidEnumValueException(((long)v).ToString(CultureInfo.InvariantCulture), "System.Web.Services.Description.SoapBindingStyle"), 
			};
		}

		private void Write80_SoapBinding(string n, string ns, SoapBinding o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(SoapBinding))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, null);
			if (needType)
			{
				WriteXsiType("SoapBinding", "http://schemas.xmlsoap.org/wsdl/soap/");
			}
			if (o.Required)
			{
				WriteAttribute("required", "http://schemas.xmlsoap.org/wsdl/", XmlConvert.ToString(o.Required));
			}
			WriteAttribute("transport", "", o.Transport);
			if (o.Style != SoapBindingStyle.Document)
			{
				WriteAttribute("style", "", Write79_SoapBindingStyle(o.Style));
			}
			WriteEndElement(o);
		}

		private void Write77_HttpBinding(string n, string ns, HttpBinding o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(HttpBinding))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, null);
			if (needType)
			{
				WriteXsiType("HttpBinding", "http://schemas.xmlsoap.org/wsdl/http/");
			}
			if (o.Required)
			{
				WriteAttribute("required", "http://schemas.xmlsoap.org/wsdl/", XmlConvert.ToString(o.Required));
			}
			WriteAttribute("verb", "", o.Verb);
			WriteEndElement(o);
		}

		private void Write84_Soap12Binding(string n, string ns, Soap12Binding o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(Soap12Binding))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, null);
			if (needType)
			{
				WriteXsiType("Soap12Binding", "http://schemas.xmlsoap.org/wsdl/soap12/");
			}
			if (o.Required)
			{
				WriteAttribute("required", "http://schemas.xmlsoap.org/wsdl/", XmlConvert.ToString(o.Required));
			}
			WriteAttribute("transport", "", o.Transport);
			if (o.Style != SoapBindingStyle.Document)
			{
				WriteAttribute("style", "", Write82_SoapBindingStyle(o.Style));
			}
			WriteEndElement(o);
		}

		private void Write75_PortType(string n, string ns, PortType o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(PortType))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("PortType", "http://schemas.xmlsoap.org/wsdl/");
			}
			XmlAttribute[] extensibleAttributes = o.ExtensibleAttributes;
			if (extensibleAttributes != null)
			{
				foreach (XmlAttribute node in extensibleAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("name", "", o.Name);
			if (o.DocumentationElement != null || o.DocumentationElement == null)
			{
				WriteElementLiteral(o.DocumentationElement, "documentation", "http://schemas.xmlsoap.org/wsdl/", isNullable: false, any: true);
				ServiceDescriptionFormatExtensionCollection extensions = o.Extensions;
				if (extensions != null)
				{
					for (int j = 0; j < ((ICollection)extensions).Count; j++)
					{
						if (extensions[j] is XmlNode || extensions[j] == null)
						{
							WriteElementLiteral((XmlNode)extensions[j], "", null, isNullable: false, any: true);
							continue;
						}
						throw CreateInvalidAnyTypeException(extensions[j]);
					}
				}
				OperationCollection operations = o.Operations;
				if (operations != null)
				{
					for (int k = 0; k < ((ICollection)operations).Count; k++)
					{
						Write74_Operation("operation", "http://schemas.xmlsoap.org/wsdl/", operations[k], isNullable: false, needType: false);
					}
				}
				WriteEndElement(o);
				return;
			}
			throw CreateInvalidAnyTypeException(o.DocumentationElement);
		}

		private void Write74_Operation(string n, string ns, Operation o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(Operation))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("Operation", "http://schemas.xmlsoap.org/wsdl/");
			}
			XmlAttribute[] extensibleAttributes = o.ExtensibleAttributes;
			if (extensibleAttributes != null)
			{
				foreach (XmlAttribute node in extensibleAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("name", "", o.Name);
			if (o.ParameterOrderString != null && o.ParameterOrderString.Length != 0)
			{
				WriteAttribute("parameterOrder", "", o.ParameterOrderString);
			}
			if (o.DocumentationElement != null || o.DocumentationElement == null)
			{
				WriteElementLiteral(o.DocumentationElement, "documentation", "http://schemas.xmlsoap.org/wsdl/", isNullable: false, any: true);
				ServiceDescriptionFormatExtensionCollection extensions = o.Extensions;
				if (extensions != null)
				{
					for (int j = 0; j < ((ICollection)extensions).Count; j++)
					{
						if (extensions[j] is XmlNode || extensions[j] == null)
						{
							WriteElementLiteral((XmlNode)extensions[j], "", null, isNullable: false, any: true);
							continue;
						}
						throw CreateInvalidAnyTypeException(extensions[j]);
					}
				}
				OperationMessageCollection messages = o.Messages;
				if (messages != null)
				{
					for (int k = 0; k < ((ICollection)messages).Count; k++)
					{
						OperationMessage operationMessage = messages[k];
						if (operationMessage is OperationOutput)
						{
							Write72_OperationOutput("output", "http://schemas.xmlsoap.org/wsdl/", (OperationOutput)operationMessage, isNullable: false, needType: false);
						}
						else if (operationMessage is OperationInput)
						{
							Write71_OperationInput("input", "http://schemas.xmlsoap.org/wsdl/", (OperationInput)operationMessage, isNullable: false, needType: false);
						}
						else if (operationMessage != null)
						{
							throw CreateUnknownTypeException(operationMessage);
						}
					}
				}
				OperationFaultCollection faults = o.Faults;
				if (faults != null)
				{
					for (int l = 0; l < ((ICollection)faults).Count; l++)
					{
						Write73_OperationFault("fault", "http://schemas.xmlsoap.org/wsdl/", faults[l], isNullable: false, needType: false);
					}
				}
				WriteEndElement(o);
				return;
			}
			throw CreateInvalidAnyTypeException(o.DocumentationElement);
		}

		private void Write73_OperationFault(string n, string ns, OperationFault o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(OperationFault))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("OperationFault", "http://schemas.xmlsoap.org/wsdl/");
			}
			XmlAttribute[] extensibleAttributes = o.ExtensibleAttributes;
			if (extensibleAttributes != null)
			{
				foreach (XmlAttribute node in extensibleAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("name", "", o.Name);
			WriteAttribute("message", "", FromXmlQualifiedName(o.Message));
			if (o.DocumentationElement != null || o.DocumentationElement == null)
			{
				WriteElementLiteral(o.DocumentationElement, "documentation", "http://schemas.xmlsoap.org/wsdl/", isNullable: false, any: true);
				ServiceDescriptionFormatExtensionCollection extensions = o.Extensions;
				if (extensions != null)
				{
					for (int j = 0; j < ((ICollection)extensions).Count; j++)
					{
						if (extensions[j] is XmlNode || extensions[j] == null)
						{
							WriteElementLiteral((XmlNode)extensions[j], "", null, isNullable: false, any: true);
							continue;
						}
						throw CreateInvalidAnyTypeException(extensions[j]);
					}
				}
				WriteEndElement(o);
				return;
			}
			throw CreateInvalidAnyTypeException(o.DocumentationElement);
		}

		private void Write71_OperationInput(string n, string ns, OperationInput o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(OperationInput))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("OperationInput", "http://schemas.xmlsoap.org/wsdl/");
			}
			XmlAttribute[] extensibleAttributes = o.ExtensibleAttributes;
			if (extensibleAttributes != null)
			{
				foreach (XmlAttribute node in extensibleAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("name", "", o.Name);
			WriteAttribute("message", "", FromXmlQualifiedName(o.Message));
			if (o.DocumentationElement != null || o.DocumentationElement == null)
			{
				WriteElementLiteral(o.DocumentationElement, "documentation", "http://schemas.xmlsoap.org/wsdl/", isNullable: false, any: true);
				ServiceDescriptionFormatExtensionCollection extensions = o.Extensions;
				if (extensions != null)
				{
					for (int j = 0; j < ((ICollection)extensions).Count; j++)
					{
						if (extensions[j] is XmlNode || extensions[j] == null)
						{
							WriteElementLiteral((XmlNode)extensions[j], "", null, isNullable: false, any: true);
							continue;
						}
						throw CreateInvalidAnyTypeException(extensions[j]);
					}
				}
				WriteEndElement(o);
				return;
			}
			throw CreateInvalidAnyTypeException(o.DocumentationElement);
		}

		private void Write72_OperationOutput(string n, string ns, OperationOutput o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(OperationOutput))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("OperationOutput", "http://schemas.xmlsoap.org/wsdl/");
			}
			XmlAttribute[] extensibleAttributes = o.ExtensibleAttributes;
			if (extensibleAttributes != null)
			{
				foreach (XmlAttribute node in extensibleAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("name", "", o.Name);
			WriteAttribute("message", "", FromXmlQualifiedName(o.Message));
			if (o.DocumentationElement != null || o.DocumentationElement == null)
			{
				WriteElementLiteral(o.DocumentationElement, "documentation", "http://schemas.xmlsoap.org/wsdl/", isNullable: false, any: true);
				ServiceDescriptionFormatExtensionCollection extensions = o.Extensions;
				if (extensions != null)
				{
					for (int j = 0; j < ((ICollection)extensions).Count; j++)
					{
						if (extensions[j] is XmlNode || extensions[j] == null)
						{
							WriteElementLiteral((XmlNode)extensions[j], "", null, isNullable: false, any: true);
							continue;
						}
						throw CreateInvalidAnyTypeException(extensions[j]);
					}
				}
				WriteEndElement(o);
				return;
			}
			throw CreateInvalidAnyTypeException(o.DocumentationElement);
		}

		private void Write69_Message(string n, string ns, Message o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(Message))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("Message", "http://schemas.xmlsoap.org/wsdl/");
			}
			XmlAttribute[] extensibleAttributes = o.ExtensibleAttributes;
			if (extensibleAttributes != null)
			{
				foreach (XmlAttribute node in extensibleAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("name", "", o.Name);
			if (o.DocumentationElement != null || o.DocumentationElement == null)
			{
				WriteElementLiteral(o.DocumentationElement, "documentation", "http://schemas.xmlsoap.org/wsdl/", isNullable: false, any: true);
				ServiceDescriptionFormatExtensionCollection extensions = o.Extensions;
				if (extensions != null)
				{
					for (int j = 0; j < ((ICollection)extensions).Count; j++)
					{
						if (extensions[j] is XmlNode || extensions[j] == null)
						{
							WriteElementLiteral((XmlNode)extensions[j], "", null, isNullable: false, any: true);
							continue;
						}
						throw CreateInvalidAnyTypeException(extensions[j]);
					}
				}
				MessagePartCollection parts = o.Parts;
				if (parts != null)
				{
					for (int k = 0; k < ((ICollection)parts).Count; k++)
					{
						Write68_MessagePart("part", "http://schemas.xmlsoap.org/wsdl/", parts[k], isNullable: false, needType: false);
					}
				}
				WriteEndElement(o);
				return;
			}
			throw CreateInvalidAnyTypeException(o.DocumentationElement);
		}

		private void Write68_MessagePart(string n, string ns, MessagePart o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(MessagePart))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("MessagePart", "http://schemas.xmlsoap.org/wsdl/");
			}
			XmlAttribute[] extensibleAttributes = o.ExtensibleAttributes;
			if (extensibleAttributes != null)
			{
				foreach (XmlAttribute node in extensibleAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("name", "", o.Name);
			WriteAttribute("element", "", FromXmlQualifiedName(o.Element));
			WriteAttribute("type", "", FromXmlQualifiedName(o.Type));
			if (o.DocumentationElement != null || o.DocumentationElement == null)
			{
				WriteElementLiteral(o.DocumentationElement, "documentation", "http://schemas.xmlsoap.org/wsdl/", isNullable: false, any: true);
				ServiceDescriptionFormatExtensionCollection extensions = o.Extensions;
				if (extensions != null)
				{
					for (int j = 0; j < ((ICollection)extensions).Count; j++)
					{
						if (extensions[j] is XmlNode || extensions[j] == null)
						{
							WriteElementLiteral((XmlNode)extensions[j], "", null, isNullable: false, any: true);
							continue;
						}
						throw CreateInvalidAnyTypeException(extensions[j]);
					}
				}
				WriteEndElement(o);
				return;
			}
			throw CreateInvalidAnyTypeException(o.DocumentationElement);
		}

		private void Write67_Types(string n, string ns, Types o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(Types))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("Types", "http://schemas.xmlsoap.org/wsdl/");
			}
			XmlAttribute[] extensibleAttributes = o.ExtensibleAttributes;
			if (extensibleAttributes != null)
			{
				foreach (XmlAttribute node in extensibleAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			if (o.DocumentationElement != null || o.DocumentationElement == null)
			{
				WriteElementLiteral(o.DocumentationElement, "documentation", "http://schemas.xmlsoap.org/wsdl/", isNullable: false, any: true);
				ServiceDescriptionFormatExtensionCollection extensions = o.Extensions;
				if (extensions != null)
				{
					for (int j = 0; j < ((ICollection)extensions).Count; j++)
					{
						if (extensions[j] is XmlNode || extensions[j] == null)
						{
							WriteElementLiteral((XmlNode)extensions[j], "", null, isNullable: false, any: true);
							continue;
						}
						throw CreateInvalidAnyTypeException(extensions[j]);
					}
				}
				XmlSchemas schemas = o.Schemas;
				if (schemas != null)
				{
					for (int k = 0; k < ((ICollection)schemas).Count; k++)
					{
						Write66_XmlSchema("schema", "http://www.w3.org/2001/XMLSchema", schemas[k], isNullable: false, needType: false);
					}
				}
				WriteEndElement(o);
				return;
			}
			throw CreateInvalidAnyTypeException(o.DocumentationElement);
		}

		private void Write66_XmlSchema(string n, string ns, XmlSchema o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchema))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchema", "http://www.w3.org/2001/XMLSchema");
			}
			if (o.AttributeFormDefault != 0)
			{
				WriteAttribute("attributeFormDefault", "", Write6_XmlSchemaForm(o.AttributeFormDefault));
			}
			if (o.BlockDefault != XmlSchemaDerivationMethod.None)
			{
				WriteAttribute("blockDefault", "", Write7_XmlSchemaDerivationMethod(o.BlockDefault));
			}
			if (o.FinalDefault != XmlSchemaDerivationMethod.None)
			{
				WriteAttribute("finalDefault", "", Write7_XmlSchemaDerivationMethod(o.FinalDefault));
			}
			if (o.ElementFormDefault != 0)
			{
				WriteAttribute("elementFormDefault", "", Write6_XmlSchemaForm(o.ElementFormDefault));
			}
			WriteAttribute("targetNamespace", "", o.TargetNamespace);
			WriteAttribute("version", "", o.Version);
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			XmlSchemaObjectCollection includes = o.Includes;
			if (includes != null)
			{
				for (int j = 0; j < ((ICollection)includes).Count; j++)
				{
					XmlSchemaObject xmlSchemaObject = includes[j];
					if (xmlSchemaObject is XmlSchemaRedefine)
					{
						Write64_XmlSchemaRedefine("redefine", "http://www.w3.org/2001/XMLSchema", (XmlSchemaRedefine)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaImport)
					{
						Write13_XmlSchemaImport("import", "http://www.w3.org/2001/XMLSchema", (XmlSchemaImport)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaInclude)
					{
						Write12_XmlSchemaInclude("include", "http://www.w3.org/2001/XMLSchema", (XmlSchemaInclude)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject != null)
					{
						throw CreateUnknownTypeException(xmlSchemaObject);
					}
				}
			}
			XmlSchemaObjectCollection items = o.Items;
			if (items != null)
			{
				for (int k = 0; k < ((ICollection)items).Count; k++)
				{
					XmlSchemaObject xmlSchemaObject2 = items[k];
					if (xmlSchemaObject2 is XmlSchemaElement)
					{
						Write52_XmlSchemaElement("element", "http://www.w3.org/2001/XMLSchema", (XmlSchemaElement)xmlSchemaObject2, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject2 is XmlSchemaComplexType)
					{
						Write62_XmlSchemaComplexType("complexType", "http://www.w3.org/2001/XMLSchema", (XmlSchemaComplexType)xmlSchemaObject2, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject2 is XmlSchemaSimpleType)
					{
						Write34_XmlSchemaSimpleType("simpleType", "http://www.w3.org/2001/XMLSchema", (XmlSchemaSimpleType)xmlSchemaObject2, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject2 is XmlSchemaAttribute)
					{
						Write36_XmlSchemaAttribute("attribute", "http://www.w3.org/2001/XMLSchema", (XmlSchemaAttribute)xmlSchemaObject2, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject2 is XmlSchemaAttributeGroup)
					{
						Write40_XmlSchemaAttributeGroup("attributeGroup", "http://www.w3.org/2001/XMLSchema", (XmlSchemaAttributeGroup)xmlSchemaObject2, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject2 is XmlSchemaNotation)
					{
						Write65_XmlSchemaNotation("notation", "http://www.w3.org/2001/XMLSchema", (XmlSchemaNotation)xmlSchemaObject2, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject2 is XmlSchemaGroup)
					{
						Write63_XmlSchemaGroup("group", "http://www.w3.org/2001/XMLSchema", (XmlSchemaGroup)xmlSchemaObject2, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject2 is XmlSchemaAnnotation)
					{
						Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", (XmlSchemaAnnotation)xmlSchemaObject2, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject2 != null)
					{
						throw CreateUnknownTypeException(xmlSchemaObject2);
					}
				}
			}
			WriteEndElement(o);
		}

		private void Write11_XmlSchemaAnnotation(string n, string ns, XmlSchemaAnnotation o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaAnnotation))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaAnnotation", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			XmlSchemaObjectCollection items = o.Items;
			if (items != null)
			{
				for (int j = 0; j < ((ICollection)items).Count; j++)
				{
					XmlSchemaObject xmlSchemaObject = items[j];
					if (xmlSchemaObject is XmlSchemaAppInfo)
					{
						Write10_XmlSchemaAppInfo("appinfo", "http://www.w3.org/2001/XMLSchema", (XmlSchemaAppInfo)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaDocumentation)
					{
						Write9_XmlSchemaDocumentation("documentation", "http://www.w3.org/2001/XMLSchema", (XmlSchemaDocumentation)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject != null)
					{
						throw CreateUnknownTypeException(xmlSchemaObject);
					}
				}
			}
			WriteEndElement(o);
		}

		private void Write9_XmlSchemaDocumentation(string n, string ns, XmlSchemaDocumentation o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaDocumentation))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaDocumentation", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("source", "", o.Source);
			WriteAttribute("lang", "http://www.w3.org/XML/1998/namespace", o.Language);
			XmlNode[] markup = o.Markup;
			if (markup != null)
			{
				foreach (XmlNode xmlNode in markup)
				{
					if (xmlNode is XmlElement)
					{
						XmlElement xmlElement = (XmlElement)xmlNode;
						if (xmlElement == null && xmlElement != null)
						{
							throw CreateInvalidAnyTypeException(xmlElement);
						}
						WriteElementLiteral(xmlElement, "", null, isNullable: false, any: true);
					}
					else if (xmlNode != null)
					{
						xmlNode.WriteTo(base.Writer);
					}
					else if (xmlNode != null)
					{
						throw CreateUnknownTypeException(xmlNode);
					}
				}
			}
			WriteEndElement(o);
		}

		private void Write10_XmlSchemaAppInfo(string n, string ns, XmlSchemaAppInfo o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaAppInfo))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaAppInfo", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("source", "", o.Source);
			XmlNode[] markup = o.Markup;
			if (markup != null)
			{
				foreach (XmlNode xmlNode in markup)
				{
					if (xmlNode is XmlElement)
					{
						XmlElement xmlElement = (XmlElement)xmlNode;
						if (xmlElement == null && xmlElement != null)
						{
							throw CreateInvalidAnyTypeException(xmlElement);
						}
						WriteElementLiteral(xmlElement, "", null, isNullable: false, any: true);
					}
					else if (xmlNode != null)
					{
						xmlNode.WriteTo(base.Writer);
					}
					else if (xmlNode != null)
					{
						throw CreateUnknownTypeException(xmlNode);
					}
				}
			}
			WriteEndElement(o);
		}

		private void Write63_XmlSchemaGroup(string n, string ns, XmlSchemaGroup o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaGroup))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaGroup", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("name", "", o.Name);
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			if (o.Particle is XmlSchemaAll)
			{
				Write55_XmlSchemaAll("all", "http://www.w3.org/2001/XMLSchema", (XmlSchemaAll)o.Particle, isNullable: false, needType: false);
			}
			else if (o.Particle is XmlSchemaChoice)
			{
				Write54_XmlSchemaChoice("choice", "http://www.w3.org/2001/XMLSchema", (XmlSchemaChoice)o.Particle, isNullable: false, needType: false);
			}
			else if (o.Particle is XmlSchemaSequence)
			{
				Write53_XmlSchemaSequence("sequence", "http://www.w3.org/2001/XMLSchema", (XmlSchemaSequence)o.Particle, isNullable: false, needType: false);
			}
			else if (o.Particle != null)
			{
				throw CreateUnknownTypeException(o.Particle);
			}
			WriteEndElement(o);
		}

		private void Write53_XmlSchemaSequence(string n, string ns, XmlSchemaSequence o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaSequence))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaSequence", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("minOccurs", "", o.MinOccursString);
			WriteAttribute("maxOccurs", "", o.MaxOccursString);
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			XmlSchemaObjectCollection items = o.Items;
			if (items != null)
			{
				for (int j = 0; j < ((ICollection)items).Count; j++)
				{
					XmlSchemaObject xmlSchemaObject = items[j];
					if (xmlSchemaObject is XmlSchemaChoice)
					{
						Write54_XmlSchemaChoice("choice", "http://www.w3.org/2001/XMLSchema", (XmlSchemaChoice)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaSequence)
					{
						Write53_XmlSchemaSequence("sequence", "http://www.w3.org/2001/XMLSchema", (XmlSchemaSequence)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaGroupRef)
					{
						Write44_XmlSchemaGroupRef("group", "http://www.w3.org/2001/XMLSchema", (XmlSchemaGroupRef)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaElement)
					{
						Write52_XmlSchemaElement("element", "http://www.w3.org/2001/XMLSchema", (XmlSchemaElement)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaAny)
					{
						Write46_XmlSchemaAny("any", "http://www.w3.org/2001/XMLSchema", (XmlSchemaAny)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject != null)
					{
						throw CreateUnknownTypeException(xmlSchemaObject);
					}
				}
			}
			WriteEndElement(o);
		}

		private void Write46_XmlSchemaAny(string n, string ns, XmlSchemaAny o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaAny))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaAny", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("minOccurs", "", o.MinOccursString);
			WriteAttribute("maxOccurs", "", o.MaxOccursString);
			WriteAttribute("namespace", "", o.Namespace);
			if (o.ProcessContents != 0)
			{
				WriteAttribute("processContents", "", Write38_XmlSchemaContentProcessing(o.ProcessContents));
			}
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			WriteEndElement(o);
		}

		private string Write38_XmlSchemaContentProcessing(XmlSchemaContentProcessing v)
		{
			string text = null;
			return v switch
			{
				XmlSchemaContentProcessing.Skip => "skip", 
				XmlSchemaContentProcessing.Lax => "lax", 
				XmlSchemaContentProcessing.Strict => "strict", 
				_ => throw CreateInvalidEnumValueException(((long)v).ToString(CultureInfo.InvariantCulture), "System.Xml.Schema.XmlSchemaContentProcessing"), 
			};
		}

		private void Write52_XmlSchemaElement(string n, string ns, XmlSchemaElement o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaElement))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaElement", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("minOccurs", "", o.MinOccursString);
			WriteAttribute("maxOccurs", "", o.MaxOccursString);
			if (o.IsAbstract)
			{
				WriteAttribute("abstract", "", XmlConvert.ToString(o.IsAbstract));
			}
			if (o.Block != XmlSchemaDerivationMethod.None)
			{
				WriteAttribute("block", "", Write7_XmlSchemaDerivationMethod(o.Block));
			}
			WriteAttribute("default", "", o.DefaultValue);
			if (o.Final != XmlSchemaDerivationMethod.None)
			{
				WriteAttribute("final", "", Write7_XmlSchemaDerivationMethod(o.Final));
			}
			WriteAttribute("fixed", "", o.FixedValue);
			if (o.Form != 0)
			{
				WriteAttribute("form", "", Write6_XmlSchemaForm(o.Form));
			}
			if (o.Name != null && o.Name.Length != 0)
			{
				WriteAttribute("name", "", o.Name);
			}
			if (o.IsNillable)
			{
				WriteAttribute("nillable", "", XmlConvert.ToString(o.IsNillable));
			}
			WriteAttribute("ref", "", FromXmlQualifiedName(o.RefName));
			WriteAttribute("substitutionGroup", "", FromXmlQualifiedName(o.SubstitutionGroup));
			WriteAttribute("type", "", FromXmlQualifiedName(o.SchemaTypeName));
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			if (o.SchemaType is XmlSchemaComplexType)
			{
				Write62_XmlSchemaComplexType("complexType", "http://www.w3.org/2001/XMLSchema", (XmlSchemaComplexType)o.SchemaType, isNullable: false, needType: false);
			}
			else if (o.SchemaType is XmlSchemaSimpleType)
			{
				Write34_XmlSchemaSimpleType("simpleType", "http://www.w3.org/2001/XMLSchema", (XmlSchemaSimpleType)o.SchemaType, isNullable: false, needType: false);
			}
			else if (o.SchemaType != null)
			{
				throw CreateUnknownTypeException(o.SchemaType);
			}
			XmlSchemaObjectCollection constraints = o.Constraints;
			if (constraints != null)
			{
				for (int j = 0; j < ((ICollection)constraints).Count; j++)
				{
					XmlSchemaObject xmlSchemaObject = constraints[j];
					if (xmlSchemaObject is XmlSchemaKeyref)
					{
						Write51_XmlSchemaKeyref("keyref", "http://www.w3.org/2001/XMLSchema", (XmlSchemaKeyref)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaUnique)
					{
						Write50_XmlSchemaUnique("unique", "http://www.w3.org/2001/XMLSchema", (XmlSchemaUnique)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaKey)
					{
						Write49_XmlSchemaKey("key", "http://www.w3.org/2001/XMLSchema", (XmlSchemaKey)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject != null)
					{
						throw CreateUnknownTypeException(xmlSchemaObject);
					}
				}
			}
			WriteEndElement(o);
		}

		private void Write49_XmlSchemaKey(string n, string ns, XmlSchemaKey o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaKey))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaKey", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("name", "", o.Name);
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			Write47_XmlSchemaXPath("selector", "http://www.w3.org/2001/XMLSchema", o.Selector, isNullable: false, needType: false);
			XmlSchemaObjectCollection fields = o.Fields;
			if (fields != null)
			{
				for (int j = 0; j < ((ICollection)fields).Count; j++)
				{
					Write47_XmlSchemaXPath("field", "http://www.w3.org/2001/XMLSchema", (XmlSchemaXPath)fields[j], isNullable: false, needType: false);
				}
			}
			WriteEndElement(o);
		}

		private void Write47_XmlSchemaXPath(string n, string ns, XmlSchemaXPath o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaXPath))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaXPath", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			if (o.XPath != null && o.XPath.Length != 0)
			{
				WriteAttribute("xpath", "", o.XPath);
			}
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			WriteEndElement(o);
		}

		private void Write50_XmlSchemaUnique(string n, string ns, XmlSchemaUnique o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaUnique))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaUnique", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("name", "", o.Name);
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			Write47_XmlSchemaXPath("selector", "http://www.w3.org/2001/XMLSchema", o.Selector, isNullable: false, needType: false);
			XmlSchemaObjectCollection fields = o.Fields;
			if (fields != null)
			{
				for (int j = 0; j < ((ICollection)fields).Count; j++)
				{
					Write47_XmlSchemaXPath("field", "http://www.w3.org/2001/XMLSchema", (XmlSchemaXPath)fields[j], isNullable: false, needType: false);
				}
			}
			WriteEndElement(o);
		}

		private void Write51_XmlSchemaKeyref(string n, string ns, XmlSchemaKeyref o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaKeyref))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaKeyref", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("name", "", o.Name);
			WriteAttribute("refer", "", FromXmlQualifiedName(o.Refer));
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			Write47_XmlSchemaXPath("selector", "http://www.w3.org/2001/XMLSchema", o.Selector, isNullable: false, needType: false);
			XmlSchemaObjectCollection fields = o.Fields;
			if (fields != null)
			{
				for (int j = 0; j < ((ICollection)fields).Count; j++)
				{
					Write47_XmlSchemaXPath("field", "http://www.w3.org/2001/XMLSchema", (XmlSchemaXPath)fields[j], isNullable: false, needType: false);
				}
			}
			WriteEndElement(o);
		}

		private void Write34_XmlSchemaSimpleType(string n, string ns, XmlSchemaSimpleType o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaSimpleType))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaSimpleType", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("name", "", o.Name);
			if (o.Final != XmlSchemaDerivationMethod.None)
			{
				WriteAttribute("final", "", Write7_XmlSchemaDerivationMethod(o.Final));
			}
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			if (o.Content is XmlSchemaSimpleTypeUnion)
			{
				Write33_XmlSchemaSimpleTypeUnion("union", "http://www.w3.org/2001/XMLSchema", (XmlSchemaSimpleTypeUnion)o.Content, isNullable: false, needType: false);
			}
			else if (o.Content is XmlSchemaSimpleTypeRestriction)
			{
				Write32_XmlSchemaSimpleTypeRestriction("restriction", "http://www.w3.org/2001/XMLSchema", (XmlSchemaSimpleTypeRestriction)o.Content, isNullable: false, needType: false);
			}
			else if (o.Content is XmlSchemaSimpleTypeList)
			{
				Write17_XmlSchemaSimpleTypeList("list", "http://www.w3.org/2001/XMLSchema", (XmlSchemaSimpleTypeList)o.Content, isNullable: false, needType: false);
			}
			else if (o.Content != null)
			{
				throw CreateUnknownTypeException(o.Content);
			}
			WriteEndElement(o);
		}

		private void Write17_XmlSchemaSimpleTypeList(string n, string ns, XmlSchemaSimpleTypeList o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaSimpleTypeList))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaSimpleTypeList", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("itemType", "", FromXmlQualifiedName(o.ItemTypeName));
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			Write34_XmlSchemaSimpleType("simpleType", "http://www.w3.org/2001/XMLSchema", o.ItemType, isNullable: false, needType: false);
			WriteEndElement(o);
		}

		private void Write32_XmlSchemaSimpleTypeRestriction(string n, string ns, XmlSchemaSimpleTypeRestriction o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaSimpleTypeRestriction))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaSimpleTypeRestriction", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("base", "", FromXmlQualifiedName(o.BaseTypeName));
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			Write34_XmlSchemaSimpleType("simpleType", "http://www.w3.org/2001/XMLSchema", o.BaseType, isNullable: false, needType: false);
			XmlSchemaObjectCollection facets = o.Facets;
			if (facets != null)
			{
				for (int j = 0; j < ((ICollection)facets).Count; j++)
				{
					XmlSchemaObject xmlSchemaObject = facets[j];
					if (xmlSchemaObject is XmlSchemaLengthFacet)
					{
						Write23_XmlSchemaLengthFacet("length", "http://www.w3.org/2001/XMLSchema", (XmlSchemaLengthFacet)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaTotalDigitsFacet)
					{
						Write24_XmlSchemaTotalDigitsFacet("totalDigits", "http://www.w3.org/2001/XMLSchema", (XmlSchemaTotalDigitsFacet)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaMaxLengthFacet)
					{
						Write22_XmlSchemaMaxLengthFacet("maxLength", "http://www.w3.org/2001/XMLSchema", (XmlSchemaMaxLengthFacet)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaFractionDigitsFacet)
					{
						Write20_XmlSchemaFractionDigitsFacet("fractionDigits", "http://www.w3.org/2001/XMLSchema", (XmlSchemaFractionDigitsFacet)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaMinLengthFacet)
					{
						Write31_XmlSchemaMinLengthFacet("minLength", "http://www.w3.org/2001/XMLSchema", (XmlSchemaMinLengthFacet)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaMaxExclusiveFacet)
					{
						Write28_XmlSchemaMaxExclusiveFacet("maxExclusive", "http://www.w3.org/2001/XMLSchema", (XmlSchemaMaxExclusiveFacet)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaWhiteSpaceFacet)
					{
						Write29_XmlSchemaWhiteSpaceFacet("whiteSpace", "http://www.w3.org/2001/XMLSchema", (XmlSchemaWhiteSpaceFacet)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaMinExclusiveFacet)
					{
						Write30_XmlSchemaMinExclusiveFacet("minExclusive", "http://www.w3.org/2001/XMLSchema", (XmlSchemaMinExclusiveFacet)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaPatternFacet)
					{
						Write25_XmlSchemaPatternFacet("pattern", "http://www.w3.org/2001/XMLSchema", (XmlSchemaPatternFacet)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaMinInclusiveFacet)
					{
						Write21_XmlSchemaMinInclusiveFacet("minInclusive", "http://www.w3.org/2001/XMLSchema", (XmlSchemaMinInclusiveFacet)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaMaxInclusiveFacet)
					{
						Write27_XmlSchemaMaxInclusiveFacet("maxInclusive", "http://www.w3.org/2001/XMLSchema", (XmlSchemaMaxInclusiveFacet)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaEnumerationFacet)
					{
						Write26_XmlSchemaEnumerationFacet("enumeration", "http://www.w3.org/2001/XMLSchema", (XmlSchemaEnumerationFacet)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject != null)
					{
						throw CreateUnknownTypeException(xmlSchemaObject);
					}
				}
			}
			WriteEndElement(o);
		}

		private void Write26_XmlSchemaEnumerationFacet(string n, string ns, XmlSchemaEnumerationFacet o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaEnumerationFacet))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaEnumerationFacet", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("value", "", o.Value);
			if (o.IsFixed)
			{
				WriteAttribute("fixed", "", XmlConvert.ToString(o.IsFixed));
			}
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			WriteEndElement(o);
		}

		private void Write27_XmlSchemaMaxInclusiveFacet(string n, string ns, XmlSchemaMaxInclusiveFacet o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaMaxInclusiveFacet))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaMaxInclusiveFacet", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("value", "", o.Value);
			if (o.IsFixed)
			{
				WriteAttribute("fixed", "", XmlConvert.ToString(o.IsFixed));
			}
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			WriteEndElement(o);
		}

		private void Write21_XmlSchemaMinInclusiveFacet(string n, string ns, XmlSchemaMinInclusiveFacet o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaMinInclusiveFacet))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaMinInclusiveFacet", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("value", "", o.Value);
			if (o.IsFixed)
			{
				WriteAttribute("fixed", "", XmlConvert.ToString(o.IsFixed));
			}
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			WriteEndElement(o);
		}

		private void Write25_XmlSchemaPatternFacet(string n, string ns, XmlSchemaPatternFacet o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaPatternFacet))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaPatternFacet", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("value", "", o.Value);
			if (o.IsFixed)
			{
				WriteAttribute("fixed", "", XmlConvert.ToString(o.IsFixed));
			}
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			WriteEndElement(o);
		}

		private void Write30_XmlSchemaMinExclusiveFacet(string n, string ns, XmlSchemaMinExclusiveFacet o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaMinExclusiveFacet))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaMinExclusiveFacet", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("value", "", o.Value);
			if (o.IsFixed)
			{
				WriteAttribute("fixed", "", XmlConvert.ToString(o.IsFixed));
			}
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			WriteEndElement(o);
		}

		private void Write29_XmlSchemaWhiteSpaceFacet(string n, string ns, XmlSchemaWhiteSpaceFacet o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaWhiteSpaceFacet))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaWhiteSpaceFacet", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("value", "", o.Value);
			if (o.IsFixed)
			{
				WriteAttribute("fixed", "", XmlConvert.ToString(o.IsFixed));
			}
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			WriteEndElement(o);
		}

		private void Write28_XmlSchemaMaxExclusiveFacet(string n, string ns, XmlSchemaMaxExclusiveFacet o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaMaxExclusiveFacet))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaMaxExclusiveFacet", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("value", "", o.Value);
			if (o.IsFixed)
			{
				WriteAttribute("fixed", "", XmlConvert.ToString(o.IsFixed));
			}
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			WriteEndElement(o);
		}

		private void Write31_XmlSchemaMinLengthFacet(string n, string ns, XmlSchemaMinLengthFacet o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaMinLengthFacet))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaMinLengthFacet", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("value", "", o.Value);
			if (o.IsFixed)
			{
				WriteAttribute("fixed", "", XmlConvert.ToString(o.IsFixed));
			}
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			WriteEndElement(o);
		}

		private void Write20_XmlSchemaFractionDigitsFacet(string n, string ns, XmlSchemaFractionDigitsFacet o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaFractionDigitsFacet))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaFractionDigitsFacet", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("value", "", o.Value);
			if (o.IsFixed)
			{
				WriteAttribute("fixed", "", XmlConvert.ToString(o.IsFixed));
			}
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			WriteEndElement(o);
		}

		private void Write22_XmlSchemaMaxLengthFacet(string n, string ns, XmlSchemaMaxLengthFacet o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaMaxLengthFacet))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaMaxLengthFacet", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("value", "", o.Value);
			if (o.IsFixed)
			{
				WriteAttribute("fixed", "", XmlConvert.ToString(o.IsFixed));
			}
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			WriteEndElement(o);
		}

		private void Write24_XmlSchemaTotalDigitsFacet(string n, string ns, XmlSchemaTotalDigitsFacet o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaTotalDigitsFacet))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaTotalDigitsFacet", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("value", "", o.Value);
			if (o.IsFixed)
			{
				WriteAttribute("fixed", "", XmlConvert.ToString(o.IsFixed));
			}
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			WriteEndElement(o);
		}

		private void Write23_XmlSchemaLengthFacet(string n, string ns, XmlSchemaLengthFacet o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaLengthFacet))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaLengthFacet", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("value", "", o.Value);
			if (o.IsFixed)
			{
				WriteAttribute("fixed", "", XmlConvert.ToString(o.IsFixed));
			}
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			WriteEndElement(o);
		}

		private void Write33_XmlSchemaSimpleTypeUnion(string n, string ns, XmlSchemaSimpleTypeUnion o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaSimpleTypeUnion))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaSimpleTypeUnion", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			XmlQualifiedName[] memberTypes = o.MemberTypes;
			if (memberTypes != null)
			{
				StringBuilder stringBuilder = new StringBuilder();
				for (int j = 0; j < memberTypes.Length; j++)
				{
					XmlQualifiedName xmlQualifiedName = memberTypes[j];
					if (j != 0)
					{
						stringBuilder.Append(" ");
					}
					stringBuilder.Append(FromXmlQualifiedName(xmlQualifiedName));
				}
				if (stringBuilder.Length != 0)
				{
					WriteAttribute("memberTypes", "", stringBuilder.ToString());
				}
			}
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			XmlSchemaObjectCollection baseTypes = o.BaseTypes;
			if (baseTypes != null)
			{
				for (int k = 0; k < ((ICollection)baseTypes).Count; k++)
				{
					Write34_XmlSchemaSimpleType("simpleType", "http://www.w3.org/2001/XMLSchema", (XmlSchemaSimpleType)baseTypes[k], isNullable: false, needType: false);
				}
			}
			WriteEndElement(o);
		}

		private string Write7_XmlSchemaDerivationMethod(XmlSchemaDerivationMethod v)
		{
			string text = null;
			return v switch
			{
				XmlSchemaDerivationMethod.Empty => "", 
				XmlSchemaDerivationMethod.Substitution => "substitution", 
				XmlSchemaDerivationMethod.Extension => "extension", 
				XmlSchemaDerivationMethod.Restriction => "restriction", 
				XmlSchemaDerivationMethod.List => "list", 
				XmlSchemaDerivationMethod.Union => "union", 
				XmlSchemaDerivationMethod.All => "#all", 
				_ => XmlSerializationWriter.FromEnum((long)v, new string[7] { "", "substitution", "extension", "restriction", "list", "union", "#all" }, new long[7] { 0L, 1L, 2L, 4L, 8L, 16L, 255L }, "System.Xml.Schema.XmlSchemaDerivationMethod"), 
			};
		}

		private void Write62_XmlSchemaComplexType(string n, string ns, XmlSchemaComplexType o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaComplexType))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaComplexType", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("name", "", o.Name);
			if (o.Final != XmlSchemaDerivationMethod.None)
			{
				WriteAttribute("final", "", Write7_XmlSchemaDerivationMethod(o.Final));
			}
			if (o.IsAbstract)
			{
				WriteAttribute("abstract", "", XmlConvert.ToString(o.IsAbstract));
			}
			if (o.Block != XmlSchemaDerivationMethod.None)
			{
				WriteAttribute("block", "", Write7_XmlSchemaDerivationMethod(o.Block));
			}
			if (o.IsMixed)
			{
				WriteAttribute("mixed", "", XmlConvert.ToString(o.IsMixed));
			}
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			if (o.ContentModel is XmlSchemaSimpleContent)
			{
				Write61_XmlSchemaSimpleContent("simpleContent", "http://www.w3.org/2001/XMLSchema", (XmlSchemaSimpleContent)o.ContentModel, isNullable: false, needType: false);
			}
			else if (o.ContentModel is XmlSchemaComplexContent)
			{
				Write58_XmlSchemaComplexContent("complexContent", "http://www.w3.org/2001/XMLSchema", (XmlSchemaComplexContent)o.ContentModel, isNullable: false, needType: false);
			}
			else if (o.ContentModel != null)
			{
				throw CreateUnknownTypeException(o.ContentModel);
			}
			if (o.Particle is XmlSchemaChoice)
			{
				Write54_XmlSchemaChoice("choice", "http://www.w3.org/2001/XMLSchema", (XmlSchemaChoice)o.Particle, isNullable: false, needType: false);
			}
			else if (o.Particle is XmlSchemaAll)
			{
				Write55_XmlSchemaAll("all", "http://www.w3.org/2001/XMLSchema", (XmlSchemaAll)o.Particle, isNullable: false, needType: false);
			}
			else if (o.Particle is XmlSchemaSequence)
			{
				Write53_XmlSchemaSequence("sequence", "http://www.w3.org/2001/XMLSchema", (XmlSchemaSequence)o.Particle, isNullable: false, needType: false);
			}
			else if (o.Particle is XmlSchemaGroupRef)
			{
				Write44_XmlSchemaGroupRef("group", "http://www.w3.org/2001/XMLSchema", (XmlSchemaGroupRef)o.Particle, isNullable: false, needType: false);
			}
			else if (o.Particle != null)
			{
				throw CreateUnknownTypeException(o.Particle);
			}
			XmlSchemaObjectCollection attributes = o.Attributes;
			if (attributes != null)
			{
				for (int j = 0; j < ((ICollection)attributes).Count; j++)
				{
					XmlSchemaObject xmlSchemaObject = attributes[j];
					if (xmlSchemaObject is XmlSchemaAttributeGroupRef)
					{
						Write37_XmlSchemaAttributeGroupRef("attributeGroup", "http://www.w3.org/2001/XMLSchema", (XmlSchemaAttributeGroupRef)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaAttribute)
					{
						Write36_XmlSchemaAttribute("attribute", "http://www.w3.org/2001/XMLSchema", (XmlSchemaAttribute)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject != null)
					{
						throw CreateUnknownTypeException(xmlSchemaObject);
					}
				}
			}
			Write39_XmlSchemaAnyAttribute("anyAttribute", "http://www.w3.org/2001/XMLSchema", o.AnyAttribute, isNullable: false, needType: false);
			WriteEndElement(o);
		}

		private void Write39_XmlSchemaAnyAttribute(string n, string ns, XmlSchemaAnyAttribute o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaAnyAttribute))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaAnyAttribute", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("namespace", "", o.Namespace);
			if (o.ProcessContents != 0)
			{
				WriteAttribute("processContents", "", Write38_XmlSchemaContentProcessing(o.ProcessContents));
			}
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			WriteEndElement(o);
		}

		private void Write36_XmlSchemaAttribute(string n, string ns, XmlSchemaAttribute o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaAttribute))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaAttribute", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("default", "", o.DefaultValue);
			WriteAttribute("fixed", "", o.FixedValue);
			if (o.Form != 0)
			{
				WriteAttribute("form", "", Write6_XmlSchemaForm(o.Form));
			}
			WriteAttribute("name", "", o.Name);
			WriteAttribute("ref", "", FromXmlQualifiedName(o.RefName));
			WriteAttribute("type", "", FromXmlQualifiedName(o.SchemaTypeName));
			if (o.Use != 0)
			{
				WriteAttribute("use", "", Write35_XmlSchemaUse(o.Use));
			}
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			Write34_XmlSchemaSimpleType("simpleType", "http://www.w3.org/2001/XMLSchema", o.SchemaType, isNullable: false, needType: false);
			WriteEndElement(o);
		}

		private string Write35_XmlSchemaUse(XmlSchemaUse v)
		{
			string text = null;
			return v switch
			{
				XmlSchemaUse.Optional => "optional", 
				XmlSchemaUse.Prohibited => "prohibited", 
				XmlSchemaUse.Required => "required", 
				_ => throw CreateInvalidEnumValueException(((long)v).ToString(CultureInfo.InvariantCulture), "System.Xml.Schema.XmlSchemaUse"), 
			};
		}

		private string Write6_XmlSchemaForm(XmlSchemaForm v)
		{
			string text = null;
			return v switch
			{
				XmlSchemaForm.Qualified => "qualified", 
				XmlSchemaForm.Unqualified => "unqualified", 
				_ => throw CreateInvalidEnumValueException(((long)v).ToString(CultureInfo.InvariantCulture), "System.Xml.Schema.XmlSchemaForm"), 
			};
		}

		private void Write37_XmlSchemaAttributeGroupRef(string n, string ns, XmlSchemaAttributeGroupRef o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaAttributeGroupRef))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaAttributeGroupRef", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("ref", "", FromXmlQualifiedName(o.RefName));
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			WriteEndElement(o);
		}

		private void Write44_XmlSchemaGroupRef(string n, string ns, XmlSchemaGroupRef o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaGroupRef))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaGroupRef", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("minOccurs", "", o.MinOccursString);
			WriteAttribute("maxOccurs", "", o.MaxOccursString);
			WriteAttribute("ref", "", FromXmlQualifiedName(o.RefName));
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			WriteEndElement(o);
		}

		private void Write55_XmlSchemaAll(string n, string ns, XmlSchemaAll o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaAll))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaAll", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("minOccurs", "", o.MinOccursString);
			WriteAttribute("maxOccurs", "", o.MaxOccursString);
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			XmlSchemaObjectCollection items = o.Items;
			if (items != null)
			{
				for (int j = 0; j < ((ICollection)items).Count; j++)
				{
					Write52_XmlSchemaElement("element", "http://www.w3.org/2001/XMLSchema", (XmlSchemaElement)items[j], isNullable: false, needType: false);
				}
			}
			WriteEndElement(o);
		}

		private void Write54_XmlSchemaChoice(string n, string ns, XmlSchemaChoice o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaChoice))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaChoice", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("minOccurs", "", o.MinOccursString);
			WriteAttribute("maxOccurs", "", o.MaxOccursString);
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			XmlSchemaObjectCollection items = o.Items;
			if (items != null)
			{
				for (int j = 0; j < ((ICollection)items).Count; j++)
				{
					XmlSchemaObject xmlSchemaObject = items[j];
					if (xmlSchemaObject is XmlSchemaSequence)
					{
						Write53_XmlSchemaSequence("sequence", "http://www.w3.org/2001/XMLSchema", (XmlSchemaSequence)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaChoice)
					{
						Write54_XmlSchemaChoice("choice", "http://www.w3.org/2001/XMLSchema", (XmlSchemaChoice)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaGroupRef)
					{
						Write44_XmlSchemaGroupRef("group", "http://www.w3.org/2001/XMLSchema", (XmlSchemaGroupRef)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaElement)
					{
						Write52_XmlSchemaElement("element", "http://www.w3.org/2001/XMLSchema", (XmlSchemaElement)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaAny)
					{
						Write46_XmlSchemaAny("any", "http://www.w3.org/2001/XMLSchema", (XmlSchemaAny)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject != null)
					{
						throw CreateUnknownTypeException(xmlSchemaObject);
					}
				}
			}
			WriteEndElement(o);
		}

		private void Write58_XmlSchemaComplexContent(string n, string ns, XmlSchemaComplexContent o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaComplexContent))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaComplexContent", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("mixed", "", XmlConvert.ToString(o.IsMixed));
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			if (o.Content is XmlSchemaComplexContentRestriction)
			{
				Write57_Item("restriction", "http://www.w3.org/2001/XMLSchema", (XmlSchemaComplexContentRestriction)o.Content, isNullable: false, needType: false);
			}
			else if (o.Content is XmlSchemaComplexContentExtension)
			{
				Write56_Item("extension", "http://www.w3.org/2001/XMLSchema", (XmlSchemaComplexContentExtension)o.Content, isNullable: false, needType: false);
			}
			else if (o.Content != null)
			{
				throw CreateUnknownTypeException(o.Content);
			}
			WriteEndElement(o);
		}

		private void Write56_Item(string n, string ns, XmlSchemaComplexContentExtension o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaComplexContentExtension))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaComplexContentExtension", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("base", "", FromXmlQualifiedName(o.BaseTypeName));
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			if (o.Particle is XmlSchemaAll)
			{
				Write55_XmlSchemaAll("all", "http://www.w3.org/2001/XMLSchema", (XmlSchemaAll)o.Particle, isNullable: false, needType: false);
			}
			else if (o.Particle is XmlSchemaSequence)
			{
				Write53_XmlSchemaSequence("sequence", "http://www.w3.org/2001/XMLSchema", (XmlSchemaSequence)o.Particle, isNullable: false, needType: false);
			}
			else if (o.Particle is XmlSchemaChoice)
			{
				Write54_XmlSchemaChoice("choice", "http://www.w3.org/2001/XMLSchema", (XmlSchemaChoice)o.Particle, isNullable: false, needType: false);
			}
			else if (o.Particle is XmlSchemaGroupRef)
			{
				Write44_XmlSchemaGroupRef("group", "http://www.w3.org/2001/XMLSchema", (XmlSchemaGroupRef)o.Particle, isNullable: false, needType: false);
			}
			else if (o.Particle != null)
			{
				throw CreateUnknownTypeException(o.Particle);
			}
			XmlSchemaObjectCollection attributes = o.Attributes;
			if (attributes != null)
			{
				for (int j = 0; j < ((ICollection)attributes).Count; j++)
				{
					XmlSchemaObject xmlSchemaObject = attributes[j];
					if (xmlSchemaObject is XmlSchemaAttribute)
					{
						Write36_XmlSchemaAttribute("attribute", "http://www.w3.org/2001/XMLSchema", (XmlSchemaAttribute)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaAttributeGroupRef)
					{
						Write37_XmlSchemaAttributeGroupRef("attributeGroup", "http://www.w3.org/2001/XMLSchema", (XmlSchemaAttributeGroupRef)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject != null)
					{
						throw CreateUnknownTypeException(xmlSchemaObject);
					}
				}
			}
			Write39_XmlSchemaAnyAttribute("anyAttribute", "http://www.w3.org/2001/XMLSchema", o.AnyAttribute, isNullable: false, needType: false);
			WriteEndElement(o);
		}

		private void Write57_Item(string n, string ns, XmlSchemaComplexContentRestriction o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaComplexContentRestriction))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaComplexContentRestriction", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("base", "", FromXmlQualifiedName(o.BaseTypeName));
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			if (o.Particle is XmlSchemaAll)
			{
				Write55_XmlSchemaAll("all", "http://www.w3.org/2001/XMLSchema", (XmlSchemaAll)o.Particle, isNullable: false, needType: false);
			}
			else if (o.Particle is XmlSchemaSequence)
			{
				Write53_XmlSchemaSequence("sequence", "http://www.w3.org/2001/XMLSchema", (XmlSchemaSequence)o.Particle, isNullable: false, needType: false);
			}
			else if (o.Particle is XmlSchemaChoice)
			{
				Write54_XmlSchemaChoice("choice", "http://www.w3.org/2001/XMLSchema", (XmlSchemaChoice)o.Particle, isNullable: false, needType: false);
			}
			else if (o.Particle is XmlSchemaGroupRef)
			{
				Write44_XmlSchemaGroupRef("group", "http://www.w3.org/2001/XMLSchema", (XmlSchemaGroupRef)o.Particle, isNullable: false, needType: false);
			}
			else if (o.Particle != null)
			{
				throw CreateUnknownTypeException(o.Particle);
			}
			XmlSchemaObjectCollection attributes = o.Attributes;
			if (attributes != null)
			{
				for (int j = 0; j < ((ICollection)attributes).Count; j++)
				{
					XmlSchemaObject xmlSchemaObject = attributes[j];
					if (xmlSchemaObject is XmlSchemaAttribute)
					{
						Write36_XmlSchemaAttribute("attribute", "http://www.w3.org/2001/XMLSchema", (XmlSchemaAttribute)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaAttributeGroupRef)
					{
						Write37_XmlSchemaAttributeGroupRef("attributeGroup", "http://www.w3.org/2001/XMLSchema", (XmlSchemaAttributeGroupRef)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject != null)
					{
						throw CreateUnknownTypeException(xmlSchemaObject);
					}
				}
			}
			Write39_XmlSchemaAnyAttribute("anyAttribute", "http://www.w3.org/2001/XMLSchema", o.AnyAttribute, isNullable: false, needType: false);
			WriteEndElement(o);
		}

		private void Write61_XmlSchemaSimpleContent(string n, string ns, XmlSchemaSimpleContent o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaSimpleContent))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaSimpleContent", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			if (o.Content is XmlSchemaSimpleContentExtension)
			{
				Write60_Item("extension", "http://www.w3.org/2001/XMLSchema", (XmlSchemaSimpleContentExtension)o.Content, isNullable: false, needType: false);
			}
			else if (o.Content is XmlSchemaSimpleContentRestriction)
			{
				Write59_Item("restriction", "http://www.w3.org/2001/XMLSchema", (XmlSchemaSimpleContentRestriction)o.Content, isNullable: false, needType: false);
			}
			else if (o.Content != null)
			{
				throw CreateUnknownTypeException(o.Content);
			}
			WriteEndElement(o);
		}

		private void Write59_Item(string n, string ns, XmlSchemaSimpleContentRestriction o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaSimpleContentRestriction))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaSimpleContentRestriction", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("base", "", FromXmlQualifiedName(o.BaseTypeName));
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			Write34_XmlSchemaSimpleType("simpleType", "http://www.w3.org/2001/XMLSchema", o.BaseType, isNullable: false, needType: false);
			XmlSchemaObjectCollection facets = o.Facets;
			if (facets != null)
			{
				for (int j = 0; j < ((ICollection)facets).Count; j++)
				{
					XmlSchemaObject xmlSchemaObject = facets[j];
					if (xmlSchemaObject is XmlSchemaMinLengthFacet)
					{
						Write31_XmlSchemaMinLengthFacet("minLength", "http://www.w3.org/2001/XMLSchema", (XmlSchemaMinLengthFacet)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaMaxLengthFacet)
					{
						Write22_XmlSchemaMaxLengthFacet("maxLength", "http://www.w3.org/2001/XMLSchema", (XmlSchemaMaxLengthFacet)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaLengthFacet)
					{
						Write23_XmlSchemaLengthFacet("length", "http://www.w3.org/2001/XMLSchema", (XmlSchemaLengthFacet)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaFractionDigitsFacet)
					{
						Write20_XmlSchemaFractionDigitsFacet("fractionDigits", "http://www.w3.org/2001/XMLSchema", (XmlSchemaFractionDigitsFacet)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaTotalDigitsFacet)
					{
						Write24_XmlSchemaTotalDigitsFacet("totalDigits", "http://www.w3.org/2001/XMLSchema", (XmlSchemaTotalDigitsFacet)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaMinExclusiveFacet)
					{
						Write30_XmlSchemaMinExclusiveFacet("minExclusive", "http://www.w3.org/2001/XMLSchema", (XmlSchemaMinExclusiveFacet)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaMaxInclusiveFacet)
					{
						Write27_XmlSchemaMaxInclusiveFacet("maxInclusive", "http://www.w3.org/2001/XMLSchema", (XmlSchemaMaxInclusiveFacet)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaMaxExclusiveFacet)
					{
						Write28_XmlSchemaMaxExclusiveFacet("maxExclusive", "http://www.w3.org/2001/XMLSchema", (XmlSchemaMaxExclusiveFacet)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaMinInclusiveFacet)
					{
						Write21_XmlSchemaMinInclusiveFacet("minInclusive", "http://www.w3.org/2001/XMLSchema", (XmlSchemaMinInclusiveFacet)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaWhiteSpaceFacet)
					{
						Write29_XmlSchemaWhiteSpaceFacet("whiteSpace", "http://www.w3.org/2001/XMLSchema", (XmlSchemaWhiteSpaceFacet)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaEnumerationFacet)
					{
						Write26_XmlSchemaEnumerationFacet("enumeration", "http://www.w3.org/2001/XMLSchema", (XmlSchemaEnumerationFacet)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaPatternFacet)
					{
						Write25_XmlSchemaPatternFacet("pattern", "http://www.w3.org/2001/XMLSchema", (XmlSchemaPatternFacet)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject != null)
					{
						throw CreateUnknownTypeException(xmlSchemaObject);
					}
				}
			}
			XmlSchemaObjectCollection attributes = o.Attributes;
			if (attributes != null)
			{
				for (int k = 0; k < ((ICollection)attributes).Count; k++)
				{
					XmlSchemaObject xmlSchemaObject2 = attributes[k];
					if (xmlSchemaObject2 is XmlSchemaAttribute)
					{
						Write36_XmlSchemaAttribute("attribute", "http://www.w3.org/2001/XMLSchema", (XmlSchemaAttribute)xmlSchemaObject2, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject2 is XmlSchemaAttributeGroupRef)
					{
						Write37_XmlSchemaAttributeGroupRef("attributeGroup", "http://www.w3.org/2001/XMLSchema", (XmlSchemaAttributeGroupRef)xmlSchemaObject2, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject2 != null)
					{
						throw CreateUnknownTypeException(xmlSchemaObject2);
					}
				}
			}
			Write39_XmlSchemaAnyAttribute("anyAttribute", "http://www.w3.org/2001/XMLSchema", o.AnyAttribute, isNullable: false, needType: false);
			WriteEndElement(o);
		}

		private void Write60_Item(string n, string ns, XmlSchemaSimpleContentExtension o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaSimpleContentExtension))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaSimpleContentExtension", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("base", "", FromXmlQualifiedName(o.BaseTypeName));
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			XmlSchemaObjectCollection attributes = o.Attributes;
			if (attributes != null)
			{
				for (int j = 0; j < ((ICollection)attributes).Count; j++)
				{
					XmlSchemaObject xmlSchemaObject = attributes[j];
					if (xmlSchemaObject is XmlSchemaAttribute)
					{
						Write36_XmlSchemaAttribute("attribute", "http://www.w3.org/2001/XMLSchema", (XmlSchemaAttribute)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaAttributeGroupRef)
					{
						Write37_XmlSchemaAttributeGroupRef("attributeGroup", "http://www.w3.org/2001/XMLSchema", (XmlSchemaAttributeGroupRef)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject != null)
					{
						throw CreateUnknownTypeException(xmlSchemaObject);
					}
				}
			}
			Write39_XmlSchemaAnyAttribute("anyAttribute", "http://www.w3.org/2001/XMLSchema", o.AnyAttribute, isNullable: false, needType: false);
			WriteEndElement(o);
		}

		private void Write65_XmlSchemaNotation(string n, string ns, XmlSchemaNotation o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaNotation))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaNotation", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("name", "", o.Name);
			WriteAttribute("public", "", o.Public);
			WriteAttribute("system", "", o.System);
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			WriteEndElement(o);
		}

		private void Write40_XmlSchemaAttributeGroup(string n, string ns, XmlSchemaAttributeGroup o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaAttributeGroup))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaAttributeGroup", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("name", "", o.Name);
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			XmlSchemaObjectCollection attributes = o.Attributes;
			if (attributes != null)
			{
				for (int j = 0; j < ((ICollection)attributes).Count; j++)
				{
					XmlSchemaObject xmlSchemaObject = attributes[j];
					if (xmlSchemaObject is XmlSchemaAttributeGroupRef)
					{
						Write37_XmlSchemaAttributeGroupRef("attributeGroup", "http://www.w3.org/2001/XMLSchema", (XmlSchemaAttributeGroupRef)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaAttribute)
					{
						Write36_XmlSchemaAttribute("attribute", "http://www.w3.org/2001/XMLSchema", (XmlSchemaAttribute)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject != null)
					{
						throw CreateUnknownTypeException(xmlSchemaObject);
					}
				}
			}
			Write39_XmlSchemaAnyAttribute("anyAttribute", "http://www.w3.org/2001/XMLSchema", o.AnyAttribute, isNullable: false, needType: false);
			WriteEndElement(o);
		}

		private void Write12_XmlSchemaInclude(string n, string ns, XmlSchemaInclude o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaInclude))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaInclude", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("schemaLocation", "", o.SchemaLocation);
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			WriteEndElement(o);
		}

		private void Write13_XmlSchemaImport(string n, string ns, XmlSchemaImport o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaImport))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaImport", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("schemaLocation", "", o.SchemaLocation);
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("namespace", "", o.Namespace);
			Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", o.Annotation, isNullable: false, needType: false);
			WriteEndElement(o);
		}

		private void Write64_XmlSchemaRedefine(string n, string ns, XmlSchemaRedefine o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(XmlSchemaRedefine))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("XmlSchemaRedefine", "http://www.w3.org/2001/XMLSchema");
			}
			WriteAttribute("schemaLocation", "", o.SchemaLocation);
			WriteAttribute("id", "", o.Id);
			XmlAttribute[] unhandledAttributes = o.UnhandledAttributes;
			if (unhandledAttributes != null)
			{
				foreach (XmlAttribute node in unhandledAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			XmlSchemaObjectCollection items = o.Items;
			if (items != null)
			{
				for (int j = 0; j < ((ICollection)items).Count; j++)
				{
					XmlSchemaObject xmlSchemaObject = items[j];
					if (xmlSchemaObject is XmlSchemaSimpleType)
					{
						Write34_XmlSchemaSimpleType("simpleType", "http://www.w3.org/2001/XMLSchema", (XmlSchemaSimpleType)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaComplexType)
					{
						Write62_XmlSchemaComplexType("complexType", "http://www.w3.org/2001/XMLSchema", (XmlSchemaComplexType)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaGroup)
					{
						Write63_XmlSchemaGroup("group", "http://www.w3.org/2001/XMLSchema", (XmlSchemaGroup)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaAttributeGroup)
					{
						Write40_XmlSchemaAttributeGroup("attributeGroup", "http://www.w3.org/2001/XMLSchema", (XmlSchemaAttributeGroup)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject is XmlSchemaAnnotation)
					{
						Write11_XmlSchemaAnnotation("annotation", "http://www.w3.org/2001/XMLSchema", (XmlSchemaAnnotation)xmlSchemaObject, isNullable: false, needType: false);
					}
					else if (xmlSchemaObject != null)
					{
						throw CreateUnknownTypeException(xmlSchemaObject);
					}
				}
			}
			WriteEndElement(o);
		}

		private void Write4_Import(string n, string ns, Import o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(Import))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			WriteStartElement(n, ns, o, writePrefixed: false, o.Namespaces);
			if (needType)
			{
				WriteXsiType("Import", "http://schemas.xmlsoap.org/wsdl/");
			}
			XmlAttribute[] extensibleAttributes = o.ExtensibleAttributes;
			if (extensibleAttributes != null)
			{
				foreach (XmlAttribute node in extensibleAttributes)
				{
					WriteXmlAttribute(node, o);
				}
			}
			WriteAttribute("namespace", "", o.Namespace);
			WriteAttribute("location", "", o.Location);
			if (o.DocumentationElement != null || o.DocumentationElement == null)
			{
				WriteElementLiteral(o.DocumentationElement, "documentation", "http://schemas.xmlsoap.org/wsdl/", isNullable: false, any: true);
				ServiceDescriptionFormatExtensionCollection extensions = o.Extensions;
				if (extensions != null)
				{
					for (int j = 0; j < ((ICollection)extensions).Count; j++)
					{
						if (extensions[j] is XmlNode || extensions[j] == null)
						{
							WriteElementLiteral((XmlNode)extensions[j], "", null, isNullable: false, any: true);
							continue;
						}
						throw CreateInvalidAnyTypeException(extensions[j]);
					}
				}
				WriteEndElement(o);
				return;
			}
			throw CreateInvalidAnyTypeException(o.DocumentationElement);
		}

		protected override void InitCallbacks()
		{
		}
	}
	internal class ServiceDescriptionSerializationReader : XmlSerializationReader
	{
		private Hashtable _XmlSchemaDerivationMethodValues;

		private string id133_XmlSchemaSimpleTypeUnion;

		private string id143_maxInclusive;

		private string id46_body;

		private string id190_any;

		private string id88_OperationOutput;

		private string id6_targetNamespace;

		private string id158_XmlSchemaMaxLengthFacet;

		private string id11_portType;

		private string id182_mixed;

		private string id172_keyref;

		private string id187_all;

		private string id162_itemType;

		private string id68_InputBinding;

		private string id25_HttpAddressBinding;

		private string id82_HttpBinding;

		private string id17_address;

		private string id3_ServiceDescription;

		private string id38_SoapFaultBinding;

		private string id123_ref;

		private string id198_XmlSchemaComplexContent;

		private string id53_parts;

		private string id35_use;

		private string id157_XmlSchemaLengthFacet;

		private string id207_XmlSchemaImport;

		private string id44_text;

		private string id117_XmlSchemaAppInfo;

		private string id203_public;

		private string id69_urlEncoded;

		private string id7_documentation;

		private string id19_Item;

		private string id129_final;

		private string id163_XmlSchemaElement;

		private string id60_capture;

		private string id37_encodingStyle;

		private string id185_sequence;

		private string id166_abstract;

		private string id23_location;

		private string id111_XmlSchemaAttributeGroup;

		private string id192_XmlSchemaSequence;

		private string id33_FaultBinding;

		private string id153_XmlSchemaMaxInclusiveFacet;

		private string id201_XmlSchemaGroup;

		private string id43_multipartRelated;

		private string id168_nillable;

		private string id149_value;

		private string id64_MimeMultipartRelatedBinding;

		private string id193_XmlSchemaAny;

		private string id191_XmlSchemaGroupRef;

		private string id74_soapAction;

		private string id63_ignoreCase;

		private string id101_version;

		private string id47_header;

		private string id195_extension;

		private string id48_Soap12HeaderBinding;

		private string id134_memberTypes;

		private string id121_Item;

		private string id146_minExclusive;

		private string id84_PortType;

		private string id42_mimeXml;

		private string id138_minInclusive;

		private string id118_source;

		private string id73_Soap12OperationBinding;

		private string id131_restriction;

		private string id152_XmlSchemaMaxExclusiveFacet;

		private string id135_XmlSchemaSimpleTypeRestriction;

		private string id188_XmlSchemaAll;

		private string id116_appinfo;

		private string id86_parameterOrder;

		private string id147_minLength;

		private string id78_HttpOperationBinding;

		private string id161_XmlSchemaSimpleTypeList;

		private string id205_XmlSchemaRedefine;

		private string id194_XmlSchemaSimpleContent;

		private string id91_MessagePart;

		private string id92_element;

		private string id114_processContents;

		private string id18_Item;

		private string id50_headerfault;

		private string id154_XmlSchemaEnumerationFacet;

		private string id96_XmlSchema;

		private string id127_form;

		private string id176_field;

		private string id49_part;

		private string id5_Item;

		private string id57_match;

		private string id52_Soap12BodyBinding;

		private string id104_redefine;

		private string id20_Item;

		private string id21_Soap12AddressBinding;

		private string id142_enumeration;

		private string id24_SoapAddressBinding;

		private string id103_include;

		private string id139_maxLength;

		private string id165_maxOccurs;

		private string id65_MimePart;

		private string id102_id;

		private string id196_Item;

		private string id140_length;

		private string id27_type;

		private string id106_complexType;

		private string id31_output;

		private string id1_definitions;

		private string id4_name;

		private string id132_union;

		private string id29_OperationBinding;

		private string id170_key;

		private string id45_Item;

		private string id95_Item;

		private string id169_substitutionGroup;

		private string id178_xpath;

		private string id9_types;

		private string id97_attributeFormDefault;

		private string id62_pattern;

		private string id58_MimeTextMatch;

		private string id180_XmlSchemaKey;

		private string id10_message;

		private string id8_import;

		private string id148_XmlSchemaMinLengthFacet;

		private string id105_simpleType;

		private string id181_XmlSchemaComplexType;

		private string id164_minOccurs;

		private string id144_maxExclusive;

		private string id160_XmlSchemaFractionDigitsFacet;

		private string id124_XmlSchemaAttribute;

		private string id209_Import;

		private string id206_schemaLocation;

		private string id179_XmlSchemaUnique;

		private string id75_style;

		private string id119_XmlSchemaDocumentation;

		private string id136_base;

		private string id66_MimeXmlBinding;

		private string id30_input;

		private string id40_content;

		private string id93_Types;

		private string id94_schema;

		private string id200_Item;

		private string id67_MimeContentBinding;

		private string id59_group;

		private string id32_fault;

		private string id80_transport;

		private string id98_blockDefault;

		private string id13_service;

		private string id54_SoapHeaderBinding;

		private string id204_system;

		private string id16_Port;

		private string id108_notation;

		private string id186_choice;

		private string id110_attributeGroup;

		private string id79_Soap12Binding;

		private string id77_SoapOperationBinding;

		private string id115_XmlSchemaAnnotation;

		private string id83_verb;

		private string id72_HttpUrlEncodedBinding;

		private string id39_OutputBinding;

		private string id183_complexContent;

		private string id202_XmlSchemaNotation;

		private string id81_SoapBinding;

		private string id199_Item;

		private string id28_operation;

		private string id122_XmlSchemaAttributeGroupRef;

		private string id155_XmlSchemaPatternFacet;

		private string id76_soapActionRequired;

		private string id90_Message;

		private string id159_XmlSchemaMinInclusiveFacet;

		private string id208_XmlSchemaInclude;

		private string id85_Operation;

		private string id130_list;

		private string id14_Service;

		private string id22_required;

		private string id174_refer;

		private string id71_HttpUrlReplacementBinding;

		private string id56_MimeTextBinding;

		private string id87_OperationFault;

		private string id125_default;

		private string id15_port;

		private string id51_SoapHeaderFaultBinding;

		private string id128_XmlSchemaSimpleType;

		private string id36_namespace;

		private string id175_selector;

		private string id150_XmlSchemaMinExclusiveFacet;

		private string id100_elementFormDefault;

		private string id26_Binding;

		private string id197_Item;

		private string id126_fixed;

		private string id107_annotation;

		private string id99_finalDefault;

		private string id137_fractionDigits;

		private string id70_urlReplacement;

		private string id189_XmlSchemaChoice;

		private string id2_Item;

		private string id112_anyAttribute;

		private string id89_OperationInput;

		private string id141_totalDigits;

		private string id61_repeats;

		private string id184_simpleContent;

		private string id55_SoapBodyBinding;

		private string id145_whiteSpace;

		private string id167_block;

		private string id151_XmlSchemaWhiteSpaceFacet;

		private string id12_binding;

		private string id109_attribute;

		private string id171_unique;

		private string id120_lang;

		private string id173_XmlSchemaKeyref;

		private string id177_XmlSchemaXPath;

		private string id34_Soap12FaultBinding;

		private string id41_Item;

		private string id156_XmlSchemaTotalDigitsFacet;

		private string id113_XmlSchemaAnyAttribute;

		internal Hashtable XmlSchemaDerivationMethodValues
		{
			get
			{
				if (_XmlSchemaDerivationMethodValues == null)
				{
					Hashtable hashtable = new Hashtable();
					hashtable.Add("", 0L);
					hashtable.Add("substitution", 1L);
					hashtable.Add("extension", 2L);
					hashtable.Add("restriction", 4L);
					hashtable.Add("list", 8L);
					hashtable.Add("union", 16L);
					hashtable.Add("#all", 255L);
					_XmlSchemaDerivationMethodValues = hashtable;
				}
				return _XmlSchemaDerivationMethodValues;
			}
		}

		public object Read125_definitions()
		{
			object result = null;
			base.Reader.MoveToContent();
			if (base.Reader.NodeType == XmlNodeType.Element)
			{
				if ((object)base.Reader.LocalName != id1_definitions || (object)base.Reader.NamespaceURI != id2_Item)
				{
					throw CreateUnknownNodeException();
				}
				result = Read124_ServiceDescription(isNullable: true, checkType: true);
			}
			else
			{
				UnknownNode(null, "http://schemas.xmlsoap.org/wsdl/:definitions");
			}
			return result;
		}

		private ServiceDescription Read124_ServiceDescription(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id3_ServiceDescription || (object)xmlQualifiedName.Namespace != id2_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			ServiceDescription serviceDescription = new ServiceDescription();
			XmlAttribute[] array = null;
			int num = 0;
			ServiceDescriptionFormatExtensionCollection extensions = serviceDescription.Extensions;
			ImportCollection imports = serviceDescription.Imports;
			MessageCollection messages = serviceDescription.Messages;
			PortTypeCollection portTypes = serviceDescription.PortTypes;
			BindingCollection bindings = serviceDescription.Bindings;
			ServiceCollection services = serviceDescription.Services;
			bool[] array2 = new bool[12];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[3] && (object)base.Reader.LocalName == id4_name && (object)base.Reader.NamespaceURI == id5_Item)
				{
					serviceDescription.Name = base.Reader.Value;
					array2[3] = true;
				}
				else if (!array2[11] && (object)base.Reader.LocalName == id6_targetNamespace && (object)base.Reader.NamespaceURI == id5_Item)
				{
					serviceDescription.TargetNamespace = base.Reader.Value;
					array2[11] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (serviceDescription.Namespaces == null)
					{
						serviceDescription.Namespaces = new XmlSerializerNamespaces();
					}
					serviceDescription.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			serviceDescription.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				serviceDescription.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return serviceDescription;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[0] && (object)base.Reader.LocalName == id7_documentation && (object)base.Reader.NamespaceURI == id2_Item)
					{
						serviceDescription.DocumentationElement = (XmlElement)ReadXmlNode(wrapped: false);
						array2[0] = true;
					}
					else if ((object)base.Reader.LocalName == id8_import && (object)base.Reader.NamespaceURI == id2_Item)
					{
						if (imports == null)
						{
							base.Reader.Skip();
						}
						else
						{
							imports.Add(Read4_Import(isNullable: false, checkType: true));
						}
					}
					else if (!array2[6] && (object)base.Reader.LocalName == id9_types && (object)base.Reader.NamespaceURI == id2_Item)
					{
						serviceDescription.Types = Read67_Types(isNullable: false, checkType: true);
						array2[6] = true;
					}
					else if ((object)base.Reader.LocalName == id10_message && (object)base.Reader.NamespaceURI == id2_Item)
					{
						if (messages == null)
						{
							base.Reader.Skip();
						}
						else
						{
							messages.Add(Read69_Message(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id11_portType && (object)base.Reader.NamespaceURI == id2_Item)
					{
						if (portTypes == null)
						{
							base.Reader.Skip();
						}
						else
						{
							portTypes.Add(Read75_PortType(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id12_binding && (object)base.Reader.NamespaceURI == id2_Item)
					{
						if (bindings == null)
						{
							base.Reader.Skip();
						}
						else
						{
							bindings.Add(Read117_Binding(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id13_service && (object)base.Reader.NamespaceURI == id2_Item)
					{
						if (services == null)
						{
							base.Reader.Skip();
						}
						else
						{
							services.Add(Read123_Service(isNullable: false, checkType: true));
						}
					}
					else
					{
						extensions.Add((XmlElement)ReadXmlNode(wrapped: false));
					}
				}
				else
				{
					UnknownNode(serviceDescription, "http://schemas.xmlsoap.org/wsdl/:documentation, http://schemas.xmlsoap.org/wsdl/:import, http://schemas.xmlsoap.org/wsdl/:types, http://schemas.xmlsoap.org/wsdl/:message, http://schemas.xmlsoap.org/wsdl/:portType, http://schemas.xmlsoap.org/wsdl/:binding, http://schemas.xmlsoap.org/wsdl/:service");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			serviceDescription.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return serviceDescription;
		}

		private Service Read123_Service(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id14_Service || (object)xmlQualifiedName.Namespace != id2_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			Service service = new Service();
			XmlAttribute[] array = null;
			int num = 0;
			ServiceDescriptionFormatExtensionCollection extensions = service.Extensions;
			PortCollection ports = service.Ports;
			bool[] array2 = new bool[6];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[3] && (object)base.Reader.LocalName == id4_name && (object)base.Reader.NamespaceURI == id5_Item)
				{
					service.Name = base.Reader.Value;
					array2[3] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (service.Namespaces == null)
					{
						service.Namespaces = new XmlSerializerNamespaces();
					}
					service.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			service.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				service.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return service;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[0] && (object)base.Reader.LocalName == id7_documentation && (object)base.Reader.NamespaceURI == id2_Item)
					{
						service.DocumentationElement = (XmlElement)ReadXmlNode(wrapped: false);
						array2[0] = true;
					}
					else if ((object)base.Reader.LocalName == id15_port && (object)base.Reader.NamespaceURI == id2_Item)
					{
						if (ports == null)
						{
							base.Reader.Skip();
						}
						else
						{
							ports.Add(Read122_Port(isNullable: false, checkType: true));
						}
					}
					else
					{
						extensions.Add((XmlElement)ReadXmlNode(wrapped: false));
					}
				}
				else
				{
					UnknownNode(service, "http://schemas.xmlsoap.org/wsdl/:documentation, http://schemas.xmlsoap.org/wsdl/:port");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			service.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return service;
		}

		private Port Read122_Port(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id16_Port || (object)xmlQualifiedName.Namespace != id2_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			Port port = new Port();
			XmlAttribute[] array = null;
			int num = 0;
			ServiceDescriptionFormatExtensionCollection extensions = port.Extensions;
			bool[] array2 = new bool[6];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[3] && (object)base.Reader.LocalName == id4_name && (object)base.Reader.NamespaceURI == id5_Item)
				{
					port.Name = base.Reader.Value;
					array2[3] = true;
				}
				else if (!array2[5] && (object)base.Reader.LocalName == id12_binding && (object)base.Reader.NamespaceURI == id5_Item)
				{
					port.Binding = ToXmlQualifiedName(base.Reader.Value);
					array2[5] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (port.Namespaces == null)
					{
						port.Namespaces = new XmlSerializerNamespaces();
					}
					port.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			port.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				port.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return port;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[0] && (object)base.Reader.LocalName == id7_documentation && (object)base.Reader.NamespaceURI == id2_Item)
					{
						port.DocumentationElement = (XmlElement)ReadXmlNode(wrapped: false);
						array2[0] = true;
					}
					else if ((object)base.Reader.LocalName == id17_address && (object)base.Reader.NamespaceURI == id18_Item)
					{
						if (extensions == null)
						{
							base.Reader.Skip();
						}
						else
						{
							extensions.Add(Read118_HttpAddressBinding(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id17_address && (object)base.Reader.NamespaceURI == id19_Item)
					{
						if (extensions == null)
						{
							base.Reader.Skip();
						}
						else
						{
							extensions.Add(Read119_SoapAddressBinding(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id17_address && (object)base.Reader.NamespaceURI == id20_Item)
					{
						if (extensions == null)
						{
							base.Reader.Skip();
						}
						else
						{
							extensions.Add(Read121_Soap12AddressBinding(isNullable: false, checkType: true));
						}
					}
					else
					{
						extensions.Add((XmlElement)ReadXmlNode(wrapped: false));
					}
				}
				else
				{
					UnknownNode(port, "http://schemas.xmlsoap.org/wsdl/:documentation, http://schemas.xmlsoap.org/wsdl/http/:address, http://schemas.xmlsoap.org/wsdl/soap/:address, http://schemas.xmlsoap.org/wsdl/soap12/:address");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			port.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return port;
		}

		private Soap12AddressBinding Read121_Soap12AddressBinding(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id21_Soap12AddressBinding || (object)xmlQualifiedName.Namespace != id20_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			Soap12AddressBinding soap12AddressBinding = new Soap12AddressBinding();
			bool[] array = new bool[2];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array[0] && (object)base.Reader.LocalName == id22_required && (object)base.Reader.NamespaceURI == id2_Item)
				{
					soap12AddressBinding.Required = XmlConvert.ToBoolean(base.Reader.Value);
					array[0] = true;
				}
				else if (!array[1] && (object)base.Reader.LocalName == id23_location && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soap12AddressBinding.Location = base.Reader.Value;
					array[1] = true;
				}
				else if (!IsXmlnsAttribute(base.Reader.Name))
				{
					UnknownNode(soap12AddressBinding, "http://schemas.xmlsoap.org/wsdl/:required, :location");
				}
			}
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				return soap12AddressBinding;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					UnknownNode(soap12AddressBinding, "");
				}
				else
				{
					UnknownNode(soap12AddressBinding, "");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			ReadEndElement();
			return soap12AddressBinding;
		}

		private SoapAddressBinding Read119_SoapAddressBinding(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id24_SoapAddressBinding || (object)xmlQualifiedName.Namespace != id19_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			SoapAddressBinding soapAddressBinding = new SoapAddressBinding();
			bool[] array = new bool[2];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array[0] && (object)base.Reader.LocalName == id22_required && (object)base.Reader.NamespaceURI == id2_Item)
				{
					soapAddressBinding.Required = XmlConvert.ToBoolean(base.Reader.Value);
					array[0] = true;
				}
				else if (!array[1] && (object)base.Reader.LocalName == id23_location && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soapAddressBinding.Location = base.Reader.Value;
					array[1] = true;
				}
				else if (!IsXmlnsAttribute(base.Reader.Name))
				{
					UnknownNode(soapAddressBinding, "http://schemas.xmlsoap.org/wsdl/:required, :location");
				}
			}
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				return soapAddressBinding;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					UnknownNode(soapAddressBinding, "");
				}
				else
				{
					UnknownNode(soapAddressBinding, "");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			ReadEndElement();
			return soapAddressBinding;
		}

		private HttpAddressBinding Read118_HttpAddressBinding(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id25_HttpAddressBinding || (object)xmlQualifiedName.Namespace != id18_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			HttpAddressBinding httpAddressBinding = new HttpAddressBinding();
			bool[] array = new bool[2];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array[0] && (object)base.Reader.LocalName == id22_required && (object)base.Reader.NamespaceURI == id2_Item)
				{
					httpAddressBinding.Required = XmlConvert.ToBoolean(base.Reader.Value);
					array[0] = true;
				}
				else if (!array[1] && (object)base.Reader.LocalName == id23_location && (object)base.Reader.NamespaceURI == id5_Item)
				{
					httpAddressBinding.Location = base.Reader.Value;
					array[1] = true;
				}
				else if (!IsXmlnsAttribute(base.Reader.Name))
				{
					UnknownNode(httpAddressBinding, "http://schemas.xmlsoap.org/wsdl/:required, :location");
				}
			}
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				return httpAddressBinding;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					UnknownNode(httpAddressBinding, "");
				}
				else
				{
					UnknownNode(httpAddressBinding, "");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			ReadEndElement();
			return httpAddressBinding;
		}

		private Binding Read117_Binding(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id26_Binding || (object)xmlQualifiedName.Namespace != id2_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			Binding binding = new Binding();
			XmlAttribute[] array = null;
			int num = 0;
			ServiceDescriptionFormatExtensionCollection extensions = binding.Extensions;
			OperationBindingCollection operations = binding.Operations;
			bool[] array2 = new bool[7];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[3] && (object)base.Reader.LocalName == id4_name && (object)base.Reader.NamespaceURI == id5_Item)
				{
					binding.Name = base.Reader.Value;
					array2[3] = true;
				}
				else if (!array2[6] && (object)base.Reader.LocalName == id27_type && (object)base.Reader.NamespaceURI == id5_Item)
				{
					binding.Type = ToXmlQualifiedName(base.Reader.Value);
					array2[6] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (binding.Namespaces == null)
					{
						binding.Namespaces = new XmlSerializerNamespaces();
					}
					binding.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			binding.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				binding.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return binding;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[0] && (object)base.Reader.LocalName == id7_documentation && (object)base.Reader.NamespaceURI == id2_Item)
					{
						binding.DocumentationElement = (XmlElement)ReadXmlNode(wrapped: false);
						array2[0] = true;
					}
					else if ((object)base.Reader.LocalName == id12_binding && (object)base.Reader.NamespaceURI == id18_Item)
					{
						if (extensions == null)
						{
							base.Reader.Skip();
						}
						else
						{
							extensions.Add(Read77_HttpBinding(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id12_binding && (object)base.Reader.NamespaceURI == id19_Item)
					{
						if (extensions == null)
						{
							base.Reader.Skip();
						}
						else
						{
							extensions.Add(Read80_SoapBinding(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id12_binding && (object)base.Reader.NamespaceURI == id20_Item)
					{
						if (extensions == null)
						{
							base.Reader.Skip();
						}
						else
						{
							extensions.Add(Read84_Soap12Binding(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id28_operation && (object)base.Reader.NamespaceURI == id2_Item)
					{
						if (operations == null)
						{
							base.Reader.Skip();
						}
						else
						{
							operations.Add(Read116_OperationBinding(isNullable: false, checkType: true));
						}
					}
					else
					{
						extensions.Add((XmlElement)ReadXmlNode(wrapped: false));
					}
				}
				else
				{
					UnknownNode(binding, "http://schemas.xmlsoap.org/wsdl/:documentation, http://schemas.xmlsoap.org/wsdl/http/:binding, http://schemas.xmlsoap.org/wsdl/soap/:binding, http://schemas.xmlsoap.org/wsdl/soap12/:binding, http://schemas.xmlsoap.org/wsdl/:operation");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			binding.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return binding;
		}

		private OperationBinding Read116_OperationBinding(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id29_OperationBinding || (object)xmlQualifiedName.Namespace != id2_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			OperationBinding operationBinding = new OperationBinding();
			XmlAttribute[] array = null;
			int num = 0;
			ServiceDescriptionFormatExtensionCollection extensions = operationBinding.Extensions;
			FaultBindingCollection faults = operationBinding.Faults;
			bool[] array2 = new bool[8];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[3] && (object)base.Reader.LocalName == id4_name && (object)base.Reader.NamespaceURI == id5_Item)
				{
					operationBinding.Name = base.Reader.Value;
					array2[3] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (operationBinding.Namespaces == null)
					{
						operationBinding.Namespaces = new XmlSerializerNamespaces();
					}
					operationBinding.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			operationBinding.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				operationBinding.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return operationBinding;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[0] && (object)base.Reader.LocalName == id7_documentation && (object)base.Reader.NamespaceURI == id2_Item)
					{
						operationBinding.DocumentationElement = (XmlElement)ReadXmlNode(wrapped: false);
						array2[0] = true;
					}
					else if ((object)base.Reader.LocalName == id28_operation && (object)base.Reader.NamespaceURI == id18_Item)
					{
						if (extensions == null)
						{
							base.Reader.Skip();
						}
						else
						{
							extensions.Add(Read85_HttpOperationBinding(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id28_operation && (object)base.Reader.NamespaceURI == id19_Item)
					{
						if (extensions == null)
						{
							base.Reader.Skip();
						}
						else
						{
							extensions.Add(Read86_SoapOperationBinding(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id28_operation && (object)base.Reader.NamespaceURI == id20_Item)
					{
						if (extensions == null)
						{
							base.Reader.Skip();
						}
						else
						{
							extensions.Add(Read88_Soap12OperationBinding(isNullable: false, checkType: true));
						}
					}
					else if (!array2[5] && (object)base.Reader.LocalName == id30_input && (object)base.Reader.NamespaceURI == id2_Item)
					{
						operationBinding.Input = Read110_InputBinding(isNullable: false, checkType: true);
						array2[5] = true;
					}
					else if (!array2[6] && (object)base.Reader.LocalName == id31_output && (object)base.Reader.NamespaceURI == id2_Item)
					{
						operationBinding.Output = Read111_OutputBinding(isNullable: false, checkType: true);
						array2[6] = true;
					}
					else if ((object)base.Reader.LocalName == id32_fault && (object)base.Reader.NamespaceURI == id2_Item)
					{
						if (faults == null)
						{
							base.Reader.Skip();
						}
						else
						{
							faults.Add(Read115_FaultBinding(isNullable: false, checkType: true));
						}
					}
					else
					{
						extensions.Add((XmlElement)ReadXmlNode(wrapped: false));
					}
				}
				else
				{
					UnknownNode(operationBinding, "http://schemas.xmlsoap.org/wsdl/:documentation, http://schemas.xmlsoap.org/wsdl/http/:operation, http://schemas.xmlsoap.org/wsdl/soap/:operation, http://schemas.xmlsoap.org/wsdl/soap12/:operation, http://schemas.xmlsoap.org/wsdl/:input, http://schemas.xmlsoap.org/wsdl/:output, http://schemas.xmlsoap.org/wsdl/:fault");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			operationBinding.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return operationBinding;
		}

		private FaultBinding Read115_FaultBinding(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id33_FaultBinding || (object)xmlQualifiedName.Namespace != id2_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			FaultBinding faultBinding = new FaultBinding();
			XmlAttribute[] array = null;
			int num = 0;
			ServiceDescriptionFormatExtensionCollection extensions = faultBinding.Extensions;
			bool[] array2 = new bool[5];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[3] && (object)base.Reader.LocalName == id4_name && (object)base.Reader.NamespaceURI == id5_Item)
				{
					faultBinding.Name = base.Reader.Value;
					array2[3] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (faultBinding.Namespaces == null)
					{
						faultBinding.Namespaces = new XmlSerializerNamespaces();
					}
					faultBinding.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			faultBinding.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				faultBinding.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return faultBinding;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[0] && (object)base.Reader.LocalName == id7_documentation && (object)base.Reader.NamespaceURI == id2_Item)
					{
						faultBinding.DocumentationElement = (XmlElement)ReadXmlNode(wrapped: false);
						array2[0] = true;
					}
					else if ((object)base.Reader.LocalName == id32_fault && (object)base.Reader.NamespaceURI == id19_Item)
					{
						if (extensions == null)
						{
							base.Reader.Skip();
						}
						else
						{
							extensions.Add(Read112_SoapFaultBinding(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id32_fault && (object)base.Reader.NamespaceURI == id20_Item)
					{
						if (extensions == null)
						{
							base.Reader.Skip();
						}
						else
						{
							extensions.Add(Read114_Soap12FaultBinding(isNullable: false, checkType: true));
						}
					}
					else
					{
						extensions.Add((XmlElement)ReadXmlNode(wrapped: false));
					}
				}
				else
				{
					UnknownNode(faultBinding, "http://schemas.xmlsoap.org/wsdl/:documentation, http://schemas.xmlsoap.org/wsdl/soap/:fault, http://schemas.xmlsoap.org/wsdl/soap12/:fault");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			faultBinding.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return faultBinding;
		}

		private Soap12FaultBinding Read114_Soap12FaultBinding(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id34_Soap12FaultBinding || (object)xmlQualifiedName.Namespace != id20_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			Soap12FaultBinding soap12FaultBinding = new Soap12FaultBinding();
			bool[] array = new bool[5];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array[0] && (object)base.Reader.LocalName == id22_required && (object)base.Reader.NamespaceURI == id2_Item)
				{
					soap12FaultBinding.Required = XmlConvert.ToBoolean(base.Reader.Value);
					array[0] = true;
				}
				else if (!array[1] && (object)base.Reader.LocalName == id35_use && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soap12FaultBinding.Use = Read100_SoapBindingUse(base.Reader.Value);
					array[1] = true;
				}
				else if (!array[2] && (object)base.Reader.LocalName == id4_name && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soap12FaultBinding.Name = base.Reader.Value;
					array[2] = true;
				}
				else if (!array[3] && (object)base.Reader.LocalName == id36_namespace && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soap12FaultBinding.Namespace = base.Reader.Value;
					array[3] = true;
				}
				else if (!array[4] && (object)base.Reader.LocalName == id37_encodingStyle && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soap12FaultBinding.Encoding = base.Reader.Value;
					array[4] = true;
				}
				else if (!IsXmlnsAttribute(base.Reader.Name))
				{
					UnknownNode(soap12FaultBinding, "http://schemas.xmlsoap.org/wsdl/:required, :use, :name, :namespace, :encodingStyle");
				}
			}
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				return soap12FaultBinding;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					UnknownNode(soap12FaultBinding, "");
				}
				else
				{
					UnknownNode(soap12FaultBinding, "");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			ReadEndElement();
			return soap12FaultBinding;
		}

		private SoapBindingUse Read100_SoapBindingUse(string s)
		{
			return s switch
			{
				"encoded" => SoapBindingUse.Encoded, 
				"literal" => SoapBindingUse.Literal, 
				_ => throw CreateUnknownConstantException(s, typeof(SoapBindingUse)), 
			};
		}

		private SoapFaultBinding Read112_SoapFaultBinding(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id38_SoapFaultBinding || (object)xmlQualifiedName.Namespace != id19_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			SoapFaultBinding soapFaultBinding = new SoapFaultBinding();
			bool[] array = new bool[5];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array[0] && (object)base.Reader.LocalName == id22_required && (object)base.Reader.NamespaceURI == id2_Item)
				{
					soapFaultBinding.Required = XmlConvert.ToBoolean(base.Reader.Value);
					array[0] = true;
				}
				else if (!array[1] && (object)base.Reader.LocalName == id35_use && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soapFaultBinding.Use = Read98_SoapBindingUse(base.Reader.Value);
					array[1] = true;
				}
				else if (!array[2] && (object)base.Reader.LocalName == id4_name && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soapFaultBinding.Name = base.Reader.Value;
					array[2] = true;
				}
				else if (!array[3] && (object)base.Reader.LocalName == id36_namespace && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soapFaultBinding.Namespace = base.Reader.Value;
					array[3] = true;
				}
				else if (!array[4] && (object)base.Reader.LocalName == id37_encodingStyle && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soapFaultBinding.Encoding = base.Reader.Value;
					array[4] = true;
				}
				else if (!IsXmlnsAttribute(base.Reader.Name))
				{
					UnknownNode(soapFaultBinding, "http://schemas.xmlsoap.org/wsdl/:required, :use, :name, :namespace, :encodingStyle");
				}
			}
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				return soapFaultBinding;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					UnknownNode(soapFaultBinding, "");
				}
				else
				{
					UnknownNode(soapFaultBinding, "");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			ReadEndElement();
			return soapFaultBinding;
		}

		private SoapBindingUse Read98_SoapBindingUse(string s)
		{
			return s switch
			{
				"encoded" => SoapBindingUse.Encoded, 
				"literal" => SoapBindingUse.Literal, 
				_ => throw CreateUnknownConstantException(s, typeof(SoapBindingUse)), 
			};
		}

		private OutputBinding Read111_OutputBinding(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id39_OutputBinding || (object)xmlQualifiedName.Namespace != id2_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			OutputBinding outputBinding = new OutputBinding();
			XmlAttribute[] array = null;
			int num = 0;
			ServiceDescriptionFormatExtensionCollection extensions = outputBinding.Extensions;
			bool[] array2 = new bool[5];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[3] && (object)base.Reader.LocalName == id4_name && (object)base.Reader.NamespaceURI == id5_Item)
				{
					outputBinding.Name = base.Reader.Value;
					array2[3] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (outputBinding.Namespaces == null)
					{
						outputBinding.Namespaces = new XmlSerializerNamespaces();
					}
					outputBinding.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			outputBinding.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				outputBinding.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return outputBinding;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[0] && (object)base.Reader.LocalName == id7_documentation && (object)base.Reader.NamespaceURI == id2_Item)
					{
						outputBinding.DocumentationElement = (XmlElement)ReadXmlNode(wrapped: false);
						array2[0] = true;
					}
					else if ((object)base.Reader.LocalName == id40_content && (object)base.Reader.NamespaceURI == id41_Item)
					{
						if (extensions == null)
						{
							base.Reader.Skip();
						}
						else
						{
							extensions.Add(Read93_MimeContentBinding(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id42_mimeXml && (object)base.Reader.NamespaceURI == id41_Item)
					{
						if (extensions == null)
						{
							base.Reader.Skip();
						}
						else
						{
							extensions.Add(Read94_MimeXmlBinding(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id43_multipartRelated && (object)base.Reader.NamespaceURI == id41_Item)
					{
						if (extensions == null)
						{
							base.Reader.Skip();
						}
						else
						{
							extensions.Add(Read104_MimeMultipartRelatedBinding(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id44_text && (object)base.Reader.NamespaceURI == id45_Item)
					{
						if (extensions == null)
						{
							base.Reader.Skip();
						}
						else
						{
							extensions.Add(Read97_MimeTextBinding(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id46_body && (object)base.Reader.NamespaceURI == id19_Item)
					{
						if (extensions == null)
						{
							base.Reader.Skip();
						}
						else
						{
							extensions.Add(Read99_SoapBodyBinding(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id47_header && (object)base.Reader.NamespaceURI == id19_Item)
					{
						if (extensions == null)
						{
							base.Reader.Skip();
						}
						else
						{
							extensions.Add(Read106_SoapHeaderBinding(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id46_body && (object)base.Reader.NamespaceURI == id20_Item)
					{
						if (extensions == null)
						{
							base.Reader.Skip();
						}
						else
						{
							extensions.Add(Read102_Soap12BodyBinding(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id47_header && (object)base.Reader.NamespaceURI == id20_Item)
					{
						if (extensions == null)
						{
							base.Reader.Skip();
						}
						else
						{
							extensions.Add(Read109_Soap12HeaderBinding(isNullable: false, checkType: true));
						}
					}
					else
					{
						extensions.Add((XmlElement)ReadXmlNode(wrapped: false));
					}
				}
				else
				{
					UnknownNode(outputBinding, "http://schemas.xmlsoap.org/wsdl/:documentation, http://schemas.xmlsoap.org/wsdl/mime/:content, http://schemas.xmlsoap.org/wsdl/mime/:mimeXml, http://schemas.xmlsoap.org/wsdl/mime/:multipartRelated, http://microsoft.com/wsdl/mime/textMatching/:text, http://schemas.xmlsoap.org/wsdl/soap/:body, http://schemas.xmlsoap.org/wsdl/soap/:header, http://schemas.xmlsoap.org/wsdl/soap12/:body, http://schemas.xmlsoap.org/wsdl/soap12/:header");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			outputBinding.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return outputBinding;
		}

		private Soap12HeaderBinding Read109_Soap12HeaderBinding(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id48_Soap12HeaderBinding || (object)xmlQualifiedName.Namespace != id20_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			Soap12HeaderBinding soap12HeaderBinding = new Soap12HeaderBinding();
			bool[] array = new bool[7];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array[0] && (object)base.Reader.LocalName == id22_required && (object)base.Reader.NamespaceURI == id2_Item)
				{
					soap12HeaderBinding.Required = XmlConvert.ToBoolean(base.Reader.Value);
					array[0] = true;
				}
				else if (!array[1] && (object)base.Reader.LocalName == id10_message && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soap12HeaderBinding.Message = ToXmlQualifiedName(base.Reader.Value);
					array[1] = true;
				}
				else if (!array[2] && (object)base.Reader.LocalName == id49_part && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soap12HeaderBinding.Part = base.Reader.Value;
					array[2] = true;
				}
				else if (!array[3] && (object)base.Reader.LocalName == id35_use && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soap12HeaderBinding.Use = Read100_SoapBindingUse(base.Reader.Value);
					array[3] = true;
				}
				else if (!array[4] && (object)base.Reader.LocalName == id37_encodingStyle && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soap12HeaderBinding.Encoding = base.Reader.Value;
					array[4] = true;
				}
				else if (!array[5] && (object)base.Reader.LocalName == id36_namespace && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soap12HeaderBinding.Namespace = base.Reader.Value;
					array[5] = true;
				}
				else if (!IsXmlnsAttribute(base.Reader.Name))
				{
					UnknownNode(soap12HeaderBinding, "http://schemas.xmlsoap.org/wsdl/:required, :message, :part, :use, :encodingStyle, :namespace");
				}
			}
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				return soap12HeaderBinding;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array[6] && (object)base.Reader.LocalName == id50_headerfault && (object)base.Reader.NamespaceURI == id20_Item)
					{
						soap12HeaderBinding.Fault = Read107_SoapHeaderFaultBinding(isNullable: false, checkType: true);
						array[6] = true;
					}
					else
					{
						UnknownNode(soap12HeaderBinding, "http://schemas.xmlsoap.org/wsdl/soap12/:headerfault");
					}
				}
				else
				{
					UnknownNode(soap12HeaderBinding, "http://schemas.xmlsoap.org/wsdl/soap12/:headerfault");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			ReadEndElement();
			return soap12HeaderBinding;
		}

		private SoapHeaderFaultBinding Read107_SoapHeaderFaultBinding(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id51_SoapHeaderFaultBinding || (object)xmlQualifiedName.Namespace != id20_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			SoapHeaderFaultBinding soapHeaderFaultBinding = new SoapHeaderFaultBinding();
			bool[] array = new bool[6];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array[0] && (object)base.Reader.LocalName == id22_required && (object)base.Reader.NamespaceURI == id2_Item)
				{
					soapHeaderFaultBinding.Required = XmlConvert.ToBoolean(base.Reader.Value);
					array[0] = true;
				}
				else if (!array[1] && (object)base.Reader.LocalName == id10_message && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soapHeaderFaultBinding.Message = ToXmlQualifiedName(base.Reader.Value);
					array[1] = true;
				}
				else if (!array[2] && (object)base.Reader.LocalName == id49_part && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soapHeaderFaultBinding.Part = base.Reader.Value;
					array[2] = true;
				}
				else if (!array[3] && (object)base.Reader.LocalName == id35_use && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soapHeaderFaultBinding.Use = Read100_SoapBindingUse(base.Reader.Value);
					array[3] = true;
				}
				else if (!array[4] && (object)base.Reader.LocalName == id37_encodingStyle && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soapHeaderFaultBinding.Encoding = base.Reader.Value;
					array[4] = true;
				}
				else if (!array[5] && (object)base.Reader.LocalName == id36_namespace && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soapHeaderFaultBinding.Namespace = base.Reader.Value;
					array[5] = true;
				}
				else if (!IsXmlnsAttribute(base.Reader.Name))
				{
					UnknownNode(soapHeaderFaultBinding, "http://schemas.xmlsoap.org/wsdl/:required, :message, :part, :use, :encodingStyle, :namespace");
				}
			}
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				return soapHeaderFaultBinding;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					UnknownNode(soapHeaderFaultBinding, "");
				}
				else
				{
					UnknownNode(soapHeaderFaultBinding, "");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			ReadEndElement();
			return soapHeaderFaultBinding;
		}

		private Soap12BodyBinding Read102_Soap12BodyBinding(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id52_Soap12BodyBinding || (object)xmlQualifiedName.Namespace != id20_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			Soap12BodyBinding soap12BodyBinding = new Soap12BodyBinding();
			bool[] array = new bool[5];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array[0] && (object)base.Reader.LocalName == id22_required && (object)base.Reader.NamespaceURI == id2_Item)
				{
					soap12BodyBinding.Required = XmlConvert.ToBoolean(base.Reader.Value);
					array[0] = true;
				}
				else if (!array[1] && (object)base.Reader.LocalName == id35_use && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soap12BodyBinding.Use = Read100_SoapBindingUse(base.Reader.Value);
					array[1] = true;
				}
				else if (!array[2] && (object)base.Reader.LocalName == id36_namespace && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soap12BodyBinding.Namespace = base.Reader.Value;
					array[2] = true;
				}
				else if (!array[3] && (object)base.Reader.LocalName == id37_encodingStyle && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soap12BodyBinding.Encoding = base.Reader.Value;
					array[3] = true;
				}
				else if (!array[4] && (object)base.Reader.LocalName == id53_parts && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soap12BodyBinding.PartsString = base.Reader.Value;
					array[4] = true;
				}
				else if (!IsXmlnsAttribute(base.Reader.Name))
				{
					UnknownNode(soap12BodyBinding, "http://schemas.xmlsoap.org/wsdl/:required, :use, :namespace, :encodingStyle, :parts");
				}
			}
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				return soap12BodyBinding;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					UnknownNode(soap12BodyBinding, "");
				}
				else
				{
					UnknownNode(soap12BodyBinding, "");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			ReadEndElement();
			return soap12BodyBinding;
		}

		private SoapHeaderBinding Read106_SoapHeaderBinding(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id54_SoapHeaderBinding || (object)xmlQualifiedName.Namespace != id19_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			SoapHeaderBinding soapHeaderBinding = new SoapHeaderBinding();
			bool[] array = new bool[7];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array[0] && (object)base.Reader.LocalName == id22_required && (object)base.Reader.NamespaceURI == id2_Item)
				{
					soapHeaderBinding.Required = XmlConvert.ToBoolean(base.Reader.Value);
					array[0] = true;
				}
				else if (!array[1] && (object)base.Reader.LocalName == id10_message && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soapHeaderBinding.Message = ToXmlQualifiedName(base.Reader.Value);
					array[1] = true;
				}
				else if (!array[2] && (object)base.Reader.LocalName == id49_part && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soapHeaderBinding.Part = base.Reader.Value;
					array[2] = true;
				}
				else if (!array[3] && (object)base.Reader.LocalName == id35_use && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soapHeaderBinding.Use = Read98_SoapBindingUse(base.Reader.Value);
					array[3] = true;
				}
				else if (!array[4] && (object)base.Reader.LocalName == id37_encodingStyle && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soapHeaderBinding.Encoding = base.Reader.Value;
					array[4] = true;
				}
				else if (!array[5] && (object)base.Reader.LocalName == id36_namespace && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soapHeaderBinding.Namespace = base.Reader.Value;
					array[5] = true;
				}
				else if (!IsXmlnsAttribute(base.Reader.Name))
				{
					UnknownNode(soapHeaderBinding, "http://schemas.xmlsoap.org/wsdl/:required, :message, :part, :use, :encodingStyle, :namespace");
				}
			}
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				return soapHeaderBinding;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array[6] && (object)base.Reader.LocalName == id50_headerfault && (object)base.Reader.NamespaceURI == id19_Item)
					{
						soapHeaderBinding.Fault = Read105_SoapHeaderFaultBinding(isNullable: false, checkType: true);
						array[6] = true;
					}
					else
					{
						UnknownNode(soapHeaderBinding, "http://schemas.xmlsoap.org/wsdl/soap/:headerfault");
					}
				}
				else
				{
					UnknownNode(soapHeaderBinding, "http://schemas.xmlsoap.org/wsdl/soap/:headerfault");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			ReadEndElement();
			return soapHeaderBinding;
		}

		private SoapHeaderFaultBinding Read105_SoapHeaderFaultBinding(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id51_SoapHeaderFaultBinding || (object)xmlQualifiedName.Namespace != id19_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			SoapHeaderFaultBinding soapHeaderFaultBinding = new SoapHeaderFaultBinding();
			bool[] array = new bool[6];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array[0] && (object)base.Reader.LocalName == id22_required && (object)base.Reader.NamespaceURI == id2_Item)
				{
					soapHeaderFaultBinding.Required = XmlConvert.ToBoolean(base.Reader.Value);
					array[0] = true;
				}
				else if (!array[1] && (object)base.Reader.LocalName == id10_message && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soapHeaderFaultBinding.Message = ToXmlQualifiedName(base.Reader.Value);
					array[1] = true;
				}
				else if (!array[2] && (object)base.Reader.LocalName == id49_part && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soapHeaderFaultBinding.Part = base.Reader.Value;
					array[2] = true;
				}
				else if (!array[3] && (object)base.Reader.LocalName == id35_use && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soapHeaderFaultBinding.Use = Read98_SoapBindingUse(base.Reader.Value);
					array[3] = true;
				}
				else if (!array[4] && (object)base.Reader.LocalName == id37_encodingStyle && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soapHeaderFaultBinding.Encoding = base.Reader.Value;
					array[4] = true;
				}
				else if (!array[5] && (object)base.Reader.LocalName == id36_namespace && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soapHeaderFaultBinding.Namespace = base.Reader.Value;
					array[5] = true;
				}
				else if (!IsXmlnsAttribute(base.Reader.Name))
				{
					UnknownNode(soapHeaderFaultBinding, "http://schemas.xmlsoap.org/wsdl/:required, :message, :part, :use, :encodingStyle, :namespace");
				}
			}
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				return soapHeaderFaultBinding;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					UnknownNode(soapHeaderFaultBinding, "");
				}
				else
				{
					UnknownNode(soapHeaderFaultBinding, "");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			ReadEndElement();
			return soapHeaderFaultBinding;
		}

		private SoapBodyBinding Read99_SoapBodyBinding(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id55_SoapBodyBinding || (object)xmlQualifiedName.Namespace != id19_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			SoapBodyBinding soapBodyBinding = new SoapBodyBinding();
			bool[] array = new bool[5];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array[0] && (object)base.Reader.LocalName == id22_required && (object)base.Reader.NamespaceURI == id2_Item)
				{
					soapBodyBinding.Required = XmlConvert.ToBoolean(base.Reader.Value);
					array[0] = true;
				}
				else if (!array[1] && (object)base.Reader.LocalName == id35_use && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soapBodyBinding.Use = Read98_SoapBindingUse(base.Reader.Value);
					array[1] = true;
				}
				else if (!array[2] && (object)base.Reader.LocalName == id36_namespace && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soapBodyBinding.Namespace = base.Reader.Value;
					array[2] = true;
				}
				else if (!array[3] && (object)base.Reader.LocalName == id37_encodingStyle && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soapBodyBinding.Encoding = base.Reader.Value;
					array[3] = true;
				}
				else if (!array[4] && (object)base.Reader.LocalName == id53_parts && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soapBodyBinding.PartsString = base.Reader.Value;
					array[4] = true;
				}
				else if (!IsXmlnsAttribute(base.Reader.Name))
				{
					UnknownNode(soapBodyBinding, "http://schemas.xmlsoap.org/wsdl/:required, :use, :namespace, :encodingStyle, :parts");
				}
			}
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				return soapBodyBinding;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					UnknownNode(soapBodyBinding, "");
				}
				else
				{
					UnknownNode(soapBodyBinding, "");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			ReadEndElement();
			return soapBodyBinding;
		}

		private MimeTextBinding Read97_MimeTextBinding(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id56_MimeTextBinding || (object)xmlQualifiedName.Namespace != id45_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			MimeTextBinding mimeTextBinding = new MimeTextBinding();
			MimeTextMatchCollection matches = mimeTextBinding.Matches;
			bool[] array = new bool[2];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array[0] && (object)base.Reader.LocalName == id22_required && (object)base.Reader.NamespaceURI == id2_Item)
				{
					mimeTextBinding.Required = XmlConvert.ToBoolean(base.Reader.Value);
					array[0] = true;
				}
				else if (!IsXmlnsAttribute(base.Reader.Name))
				{
					UnknownNode(mimeTextBinding, "http://schemas.xmlsoap.org/wsdl/:required");
				}
			}
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				return mimeTextBinding;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if ((object)base.Reader.LocalName == id57_match && (object)base.Reader.NamespaceURI == id45_Item)
					{
						if (matches == null)
						{
							base.Reader.Skip();
						}
						else
						{
							matches.Add(Read96_MimeTextMatch(isNullable: false, checkType: true));
						}
					}
					else
					{
						UnknownNode(mimeTextBinding, "http://microsoft.com/wsdl/mime/textMatching/:match");
					}
				}
				else
				{
					UnknownNode(mimeTextBinding, "http://microsoft.com/wsdl/mime/textMatching/:match");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			ReadEndElement();
			return mimeTextBinding;
		}

		private MimeTextMatch Read96_MimeTextMatch(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id58_MimeTextMatch || (object)xmlQualifiedName.Namespace != id45_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			MimeTextMatch mimeTextMatch = new MimeTextMatch();
			MimeTextMatchCollection matches = mimeTextMatch.Matches;
			bool[] array = new bool[8];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array[0] && (object)base.Reader.LocalName == id4_name && (object)base.Reader.NamespaceURI == id5_Item)
				{
					mimeTextMatch.Name = base.Reader.Value;
					array[0] = true;
				}
				else if (!array[1] && (object)base.Reader.LocalName == id27_type && (object)base.Reader.NamespaceURI == id5_Item)
				{
					mimeTextMatch.Type = base.Reader.Value;
					array[1] = true;
				}
				else if (!array[2] && (object)base.Reader.LocalName == id59_group && (object)base.Reader.NamespaceURI == id5_Item)
				{
					mimeTextMatch.Group = XmlConvert.ToInt32(base.Reader.Value);
					array[2] = true;
				}
				else if (!array[3] && (object)base.Reader.LocalName == id60_capture && (object)base.Reader.NamespaceURI == id5_Item)
				{
					mimeTextMatch.Capture = XmlConvert.ToInt32(base.Reader.Value);
					array[3] = true;
				}
				else if (!array[4] && (object)base.Reader.LocalName == id61_repeats && (object)base.Reader.NamespaceURI == id5_Item)
				{
					mimeTextMatch.RepeatsString = base.Reader.Value;
					array[4] = true;
				}
				else if (!array[5] && (object)base.Reader.LocalName == id62_pattern && (object)base.Reader.NamespaceURI == id5_Item)
				{
					mimeTextMatch.Pattern = base.Reader.Value;
					array[5] = true;
				}
				else if (!array[6] && (object)base.Reader.LocalName == id63_ignoreCase && (object)base.Reader.NamespaceURI == id5_Item)
				{
					mimeTextMatch.IgnoreCase = XmlConvert.ToBoolean(base.Reader.Value);
					array[6] = true;
				}
				else if (!IsXmlnsAttribute(base.Reader.Name))
				{
					UnknownNode(mimeTextMatch, ":name, :type, :group, :capture, :repeats, :pattern, :ignoreCase");
				}
			}
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				return mimeTextMatch;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if ((object)base.Reader.LocalName == id57_match && (object)base.Reader.NamespaceURI == id45_Item)
					{
						if (matches == null)
						{
							base.Reader.Skip();
						}
						else
						{
							matches.Add(Read96_MimeTextMatch(isNullable: false, checkType: true));
						}
					}
					else
					{
						UnknownNode(mimeTextMatch, "http://microsoft.com/wsdl/mime/textMatching/:match");
					}
				}
				else
				{
					UnknownNode(mimeTextMatch, "http://microsoft.com/wsdl/mime/textMatching/:match");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			ReadEndElement();
			return mimeTextMatch;
		}

		private MimeMultipartRelatedBinding Read104_MimeMultipartRelatedBinding(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id64_MimeMultipartRelatedBinding || (object)xmlQualifiedName.Namespace != id41_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			MimeMultipartRelatedBinding mimeMultipartRelatedBinding = new MimeMultipartRelatedBinding();
			MimePartCollection parts = mimeMultipartRelatedBinding.Parts;
			bool[] array = new bool[2];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array[0] && (object)base.Reader.LocalName == id22_required && (object)base.Reader.NamespaceURI == id2_Item)
				{
					mimeMultipartRelatedBinding.Required = XmlConvert.ToBoolean(base.Reader.Value);
					array[0] = true;
				}
				else if (!IsXmlnsAttribute(base.Reader.Name))
				{
					UnknownNode(mimeMultipartRelatedBinding, "http://schemas.xmlsoap.org/wsdl/:required");
				}
			}
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				return mimeMultipartRelatedBinding;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if ((object)base.Reader.LocalName == id49_part && (object)base.Reader.NamespaceURI == id41_Item)
					{
						if (parts == null)
						{
							base.Reader.Skip();
						}
						else
						{
							parts.Add(Read103_MimePart(isNullable: false, checkType: true));
						}
					}
					else
					{
						UnknownNode(mimeMultipartRelatedBinding, "http://schemas.xmlsoap.org/wsdl/mime/:part");
					}
				}
				else
				{
					UnknownNode(mimeMultipartRelatedBinding, "http://schemas.xmlsoap.org/wsdl/mime/:part");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			ReadEndElement();
			return mimeMultipartRelatedBinding;
		}

		private MimePart Read103_MimePart(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id65_MimePart || (object)xmlQualifiedName.Namespace != id41_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			MimePart mimePart = new MimePart();
			ServiceDescriptionFormatExtensionCollection extensions = mimePart.Extensions;
			bool[] array = new bool[2];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array[0] && (object)base.Reader.LocalName == id22_required && (object)base.Reader.NamespaceURI == id2_Item)
				{
					mimePart.Required = XmlConvert.ToBoolean(base.Reader.Value);
					array[0] = true;
				}
				else if (!IsXmlnsAttribute(base.Reader.Name))
				{
					UnknownNode(mimePart, "http://schemas.xmlsoap.org/wsdl/:required");
				}
			}
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				return mimePart;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if ((object)base.Reader.LocalName == id40_content && (object)base.Reader.NamespaceURI == id41_Item)
					{
						if (extensions == null)
						{
							base.Reader.Skip();
						}
						else
						{
							extensions.Add(Read93_MimeContentBinding(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id42_mimeXml && (object)base.Reader.NamespaceURI == id41_Item)
					{
						if (extensions == null)
						{
							base.Reader.Skip();
						}
						else
						{
							extensions.Add(Read94_MimeXmlBinding(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id44_text && (object)base.Reader.NamespaceURI == id45_Item)
					{
						if (extensions == null)
						{
							base.Reader.Skip();
						}
						else
						{
							extensions.Add(Read97_MimeTextBinding(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id46_body && (object)base.Reader.NamespaceURI == id19_Item)
					{
						if (extensions == null)
						{
							base.Reader.Skip();
						}
						else
						{
							extensions.Add(Read99_SoapBodyBinding(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id46_body && (object)base.Reader.NamespaceURI == id20_Item)
					{
						if (extensions == null)
						{
							base.Reader.Skip();
						}
						else
						{
							extensions.Add(Read102_Soap12BodyBinding(isNullable: false, checkType: true));
						}
					}
					else
					{
						extensions.Add((XmlElement)ReadXmlNode(wrapped: false));
					}
				}
				else
				{
					UnknownNode(mimePart, "http://schemas.xmlsoap.org/wsdl/mime/:content, http://schemas.xmlsoap.org/wsdl/mime/:mimeXml, http://microsoft.com/wsdl/mime/textMatching/:text, http://schemas.xmlsoap.org/wsdl/soap/:body, http://schemas.xmlsoap.org/wsdl/soap12/:body");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			ReadEndElement();
			return mimePart;
		}

		private MimeXmlBinding Read94_MimeXmlBinding(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id66_MimeXmlBinding || (object)xmlQualifiedName.Namespace != id41_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			MimeXmlBinding mimeXmlBinding = new MimeXmlBinding();
			bool[] array = new bool[2];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array[0] && (object)base.Reader.LocalName == id22_required && (object)base.Reader.NamespaceURI == id2_Item)
				{
					mimeXmlBinding.Required = XmlConvert.ToBoolean(base.Reader.Value);
					array[0] = true;
				}
				else if (!array[1] && (object)base.Reader.LocalName == id49_part && (object)base.Reader.NamespaceURI == id5_Item)
				{
					mimeXmlBinding.Part = base.Reader.Value;
					array[1] = true;
				}
				else if (!IsXmlnsAttribute(base.Reader.Name))
				{
					UnknownNode(mimeXmlBinding, "http://schemas.xmlsoap.org/wsdl/:required, :part");
				}
			}
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				return mimeXmlBinding;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					UnknownNode(mimeXmlBinding, "");
				}
				else
				{
					UnknownNode(mimeXmlBinding, "");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			ReadEndElement();
			return mimeXmlBinding;
		}

		private MimeContentBinding Read93_MimeContentBinding(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id67_MimeContentBinding || (object)xmlQualifiedName.Namespace != id41_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			MimeContentBinding mimeContentBinding = new MimeContentBinding();
			bool[] array = new bool[3];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array[0] && (object)base.Reader.LocalName == id22_required && (object)base.Reader.NamespaceURI == id2_Item)
				{
					mimeContentBinding.Required = XmlConvert.ToBoolean(base.Reader.Value);
					array[0] = true;
				}
				else if (!array[1] && (object)base.Reader.LocalName == id49_part && (object)base.Reader.NamespaceURI == id5_Item)
				{
					mimeContentBinding.Part = base.Reader.Value;
					array[1] = true;
				}
				else if (!array[2] && (object)base.Reader.LocalName == id27_type && (object)base.Reader.NamespaceURI == id5_Item)
				{
					mimeContentBinding.Type = base.Reader.Value;
					array[2] = true;
				}
				else if (!IsXmlnsAttribute(base.Reader.Name))
				{
					UnknownNode(mimeContentBinding, "http://schemas.xmlsoap.org/wsdl/:required, :part, :type");
				}
			}
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				return mimeContentBinding;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					UnknownNode(mimeContentBinding, "");
				}
				else
				{
					UnknownNode(mimeContentBinding, "");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			ReadEndElement();
			return mimeContentBinding;
		}

		private InputBinding Read110_InputBinding(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id68_InputBinding || (object)xmlQualifiedName.Namespace != id2_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			InputBinding inputBinding = new InputBinding();
			XmlAttribute[] array = null;
			int num = 0;
			ServiceDescriptionFormatExtensionCollection extensions = inputBinding.Extensions;
			bool[] array2 = new bool[5];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[3] && (object)base.Reader.LocalName == id4_name && (object)base.Reader.NamespaceURI == id5_Item)
				{
					inputBinding.Name = base.Reader.Value;
					array2[3] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (inputBinding.Namespaces == null)
					{
						inputBinding.Namespaces = new XmlSerializerNamespaces();
					}
					inputBinding.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			inputBinding.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				inputBinding.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return inputBinding;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[0] && (object)base.Reader.LocalName == id7_documentation && (object)base.Reader.NamespaceURI == id2_Item)
					{
						inputBinding.DocumentationElement = (XmlElement)ReadXmlNode(wrapped: false);
						array2[0] = true;
					}
					else if ((object)base.Reader.LocalName == id69_urlEncoded && (object)base.Reader.NamespaceURI == id18_Item)
					{
						if (extensions == null)
						{
							base.Reader.Skip();
						}
						else
						{
							extensions.Add(Read90_HttpUrlEncodedBinding(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id70_urlReplacement && (object)base.Reader.NamespaceURI == id18_Item)
					{
						if (extensions == null)
						{
							base.Reader.Skip();
						}
						else
						{
							extensions.Add(Read91_HttpUrlReplacementBinding(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id40_content && (object)base.Reader.NamespaceURI == id41_Item)
					{
						if (extensions == null)
						{
							base.Reader.Skip();
						}
						else
						{
							extensions.Add(Read93_MimeContentBinding(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id42_mimeXml && (object)base.Reader.NamespaceURI == id41_Item)
					{
						if (extensions == null)
						{
							base.Reader.Skip();
						}
						else
						{
							extensions.Add(Read94_MimeXmlBinding(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id43_multipartRelated && (object)base.Reader.NamespaceURI == id41_Item)
					{
						if (extensions == null)
						{
							base.Reader.Skip();
						}
						else
						{
							extensions.Add(Read104_MimeMultipartRelatedBinding(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id44_text && (object)base.Reader.NamespaceURI == id45_Item)
					{
						if (extensions == null)
						{
							base.Reader.Skip();
						}
						else
						{
							extensions.Add(Read97_MimeTextBinding(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id46_body && (object)base.Reader.NamespaceURI == id19_Item)
					{
						if (extensions == null)
						{
							base.Reader.Skip();
						}
						else
						{
							extensions.Add(Read99_SoapBodyBinding(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id47_header && (object)base.Reader.NamespaceURI == id19_Item)
					{
						if (extensions == null)
						{
							base.Reader.Skip();
						}
						else
						{
							extensions.Add(Read106_SoapHeaderBinding(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id46_body && (object)base.Reader.NamespaceURI == id20_Item)
					{
						if (extensions == null)
						{
							base.Reader.Skip();
						}
						else
						{
							extensions.Add(Read102_Soap12BodyBinding(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id47_header && (object)base.Reader.NamespaceURI == id20_Item)
					{
						if (extensions == null)
						{
							base.Reader.Skip();
						}
						else
						{
							extensions.Add(Read109_Soap12HeaderBinding(isNullable: false, checkType: true));
						}
					}
					else
					{
						extensions.Add((XmlElement)ReadXmlNode(wrapped: false));
					}
				}
				else
				{
					UnknownNode(inputBinding, "http://schemas.xmlsoap.org/wsdl/:documentation, http://schemas.xmlsoap.org/wsdl/http/:urlEncoded, http://schemas.xmlsoap.org/wsdl/http/:urlReplacement, http://schemas.xmlsoap.org/wsdl/mime/:content, http://schemas.xmlsoap.org/wsdl/mime/:mimeXml, http://schemas.xmlsoap.org/wsdl/mime/:multipartRelated, http://microsoft.com/wsdl/mime/textMatching/:text, http://schemas.xmlsoap.org/wsdl/soap/:body, http://schemas.xmlsoap.org/wsdl/soap/:header, http://schemas.xmlsoap.org/wsdl/soap12/:body, http://schemas.xmlsoap.org/wsdl/soap12/:header");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			inputBinding.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return inputBinding;
		}

		private HttpUrlReplacementBinding Read91_HttpUrlReplacementBinding(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id71_HttpUrlReplacementBinding || (object)xmlQualifiedName.Namespace != id18_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			HttpUrlReplacementBinding httpUrlReplacementBinding = new HttpUrlReplacementBinding();
			bool[] array = new bool[1];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array[0] && (object)base.Reader.LocalName == id22_required && (object)base.Reader.NamespaceURI == id2_Item)
				{
					httpUrlReplacementBinding.Required = XmlConvert.ToBoolean(base.Reader.Value);
					array[0] = true;
				}
				else if (!IsXmlnsAttribute(base.Reader.Name))
				{
					UnknownNode(httpUrlReplacementBinding, "http://schemas.xmlsoap.org/wsdl/:required");
				}
			}
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				return httpUrlReplacementBinding;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					UnknownNode(httpUrlReplacementBinding, "");
				}
				else
				{
					UnknownNode(httpUrlReplacementBinding, "");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			ReadEndElement();
			return httpUrlReplacementBinding;
		}

		private HttpUrlEncodedBinding Read90_HttpUrlEncodedBinding(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id72_HttpUrlEncodedBinding || (object)xmlQualifiedName.Namespace != id18_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			HttpUrlEncodedBinding httpUrlEncodedBinding = new HttpUrlEncodedBinding();
			bool[] array = new bool[1];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array[0] && (object)base.Reader.LocalName == id22_required && (object)base.Reader.NamespaceURI == id2_Item)
				{
					httpUrlEncodedBinding.Required = XmlConvert.ToBoolean(base.Reader.Value);
					array[0] = true;
				}
				else if (!IsXmlnsAttribute(base.Reader.Name))
				{
					UnknownNode(httpUrlEncodedBinding, "http://schemas.xmlsoap.org/wsdl/:required");
				}
			}
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				return httpUrlEncodedBinding;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					UnknownNode(httpUrlEncodedBinding, "");
				}
				else
				{
					UnknownNode(httpUrlEncodedBinding, "");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			ReadEndElement();
			return httpUrlEncodedBinding;
		}

		private Soap12OperationBinding Read88_Soap12OperationBinding(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id73_Soap12OperationBinding || (object)xmlQualifiedName.Namespace != id20_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			Soap12OperationBinding soap12OperationBinding = new Soap12OperationBinding();
			bool[] array = new bool[4];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array[0] && (object)base.Reader.LocalName == id22_required && (object)base.Reader.NamespaceURI == id2_Item)
				{
					soap12OperationBinding.Required = XmlConvert.ToBoolean(base.Reader.Value);
					array[0] = true;
				}
				else if (!array[1] && (object)base.Reader.LocalName == id74_soapAction && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soap12OperationBinding.SoapAction = base.Reader.Value;
					array[1] = true;
				}
				else if (!array[2] && (object)base.Reader.LocalName == id75_style && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soap12OperationBinding.Style = Read82_SoapBindingStyle(base.Reader.Value);
					array[2] = true;
				}
				else if (!array[3] && (object)base.Reader.LocalName == id76_soapActionRequired && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soap12OperationBinding.SoapActionRequired = XmlConvert.ToBoolean(base.Reader.Value);
					array[3] = true;
				}
				else if (!IsXmlnsAttribute(base.Reader.Name))
				{
					UnknownNode(soap12OperationBinding, "http://schemas.xmlsoap.org/wsdl/:required, :soapAction, :style, :soapActionRequired");
				}
			}
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				return soap12OperationBinding;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					UnknownNode(soap12OperationBinding, "");
				}
				else
				{
					UnknownNode(soap12OperationBinding, "");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			ReadEndElement();
			return soap12OperationBinding;
		}

		private SoapBindingStyle Read82_SoapBindingStyle(string s)
		{
			return s switch
			{
				"document" => SoapBindingStyle.Document, 
				"rpc" => SoapBindingStyle.Rpc, 
				_ => throw CreateUnknownConstantException(s, typeof(SoapBindingStyle)), 
			};
		}

		private SoapOperationBinding Read86_SoapOperationBinding(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id77_SoapOperationBinding || (object)xmlQualifiedName.Namespace != id19_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			SoapOperationBinding soapOperationBinding = new SoapOperationBinding();
			bool[] array = new bool[3];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array[0] && (object)base.Reader.LocalName == id22_required && (object)base.Reader.NamespaceURI == id2_Item)
				{
					soapOperationBinding.Required = XmlConvert.ToBoolean(base.Reader.Value);
					array[0] = true;
				}
				else if (!array[1] && (object)base.Reader.LocalName == id74_soapAction && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soapOperationBinding.SoapAction = base.Reader.Value;
					array[1] = true;
				}
				else if (!array[2] && (object)base.Reader.LocalName == id75_style && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soapOperationBinding.Style = Read79_SoapBindingStyle(base.Reader.Value);
					array[2] = true;
				}
				else if (!IsXmlnsAttribute(base.Reader.Name))
				{
					UnknownNode(soapOperationBinding, "http://schemas.xmlsoap.org/wsdl/:required, :soapAction, :style");
				}
			}
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				return soapOperationBinding;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					UnknownNode(soapOperationBinding, "");
				}
				else
				{
					UnknownNode(soapOperationBinding, "");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			ReadEndElement();
			return soapOperationBinding;
		}

		private SoapBindingStyle Read79_SoapBindingStyle(string s)
		{
			return s switch
			{
				"document" => SoapBindingStyle.Document, 
				"rpc" => SoapBindingStyle.Rpc, 
				_ => throw CreateUnknownConstantException(s, typeof(SoapBindingStyle)), 
			};
		}

		private HttpOperationBinding Read85_HttpOperationBinding(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id78_HttpOperationBinding || (object)xmlQualifiedName.Namespace != id18_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			HttpOperationBinding httpOperationBinding = new HttpOperationBinding();
			bool[] array = new bool[2];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array[0] && (object)base.Reader.LocalName == id22_required && (object)base.Reader.NamespaceURI == id2_Item)
				{
					httpOperationBinding.Required = XmlConvert.ToBoolean(base.Reader.Value);
					array[0] = true;
				}
				else if (!array[1] && (object)base.Reader.LocalName == id23_location && (object)base.Reader.NamespaceURI == id5_Item)
				{
					httpOperationBinding.Location = base.Reader.Value;
					array[1] = true;
				}
				else if (!IsXmlnsAttribute(base.Reader.Name))
				{
					UnknownNode(httpOperationBinding, "http://schemas.xmlsoap.org/wsdl/:required, :location");
				}
			}
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				return httpOperationBinding;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					UnknownNode(httpOperationBinding, "");
				}
				else
				{
					UnknownNode(httpOperationBinding, "");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			ReadEndElement();
			return httpOperationBinding;
		}

		private Soap12Binding Read84_Soap12Binding(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id79_Soap12Binding || (object)xmlQualifiedName.Namespace != id20_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			Soap12Binding soap12Binding = new Soap12Binding();
			bool[] array = new bool[3];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array[0] && (object)base.Reader.LocalName == id22_required && (object)base.Reader.NamespaceURI == id2_Item)
				{
					soap12Binding.Required = XmlConvert.ToBoolean(base.Reader.Value);
					array[0] = true;
				}
				else if (!array[1] && (object)base.Reader.LocalName == id80_transport && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soap12Binding.Transport = base.Reader.Value;
					array[1] = true;
				}
				else if (!array[2] && (object)base.Reader.LocalName == id75_style && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soap12Binding.Style = Read82_SoapBindingStyle(base.Reader.Value);
					array[2] = true;
				}
				else if (!IsXmlnsAttribute(base.Reader.Name))
				{
					UnknownNode(soap12Binding, "http://schemas.xmlsoap.org/wsdl/:required, :transport, :style");
				}
			}
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				return soap12Binding;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					UnknownNode(soap12Binding, "");
				}
				else
				{
					UnknownNode(soap12Binding, "");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			ReadEndElement();
			return soap12Binding;
		}

		private SoapBinding Read80_SoapBinding(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id81_SoapBinding || (object)xmlQualifiedName.Namespace != id19_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			SoapBinding soapBinding = new SoapBinding();
			bool[] array = new bool[3];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array[0] && (object)base.Reader.LocalName == id22_required && (object)base.Reader.NamespaceURI == id2_Item)
				{
					soapBinding.Required = XmlConvert.ToBoolean(base.Reader.Value);
					array[0] = true;
				}
				else if (!array[1] && (object)base.Reader.LocalName == id80_transport && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soapBinding.Transport = base.Reader.Value;
					array[1] = true;
				}
				else if (!array[2] && (object)base.Reader.LocalName == id75_style && (object)base.Reader.NamespaceURI == id5_Item)
				{
					soapBinding.Style = Read79_SoapBindingStyle(base.Reader.Value);
					array[2] = true;
				}
				else if (!IsXmlnsAttribute(base.Reader.Name))
				{
					UnknownNode(soapBinding, "http://schemas.xmlsoap.org/wsdl/:required, :transport, :style");
				}
			}
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				return soapBinding;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					UnknownNode(soapBinding, "");
				}
				else
				{
					UnknownNode(soapBinding, "");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			ReadEndElement();
			return soapBinding;
		}

		private HttpBinding Read77_HttpBinding(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id82_HttpBinding || (object)xmlQualifiedName.Namespace != id18_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			HttpBinding httpBinding = new HttpBinding();
			bool[] array = new bool[2];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array[0] && (object)base.Reader.LocalName == id22_required && (object)base.Reader.NamespaceURI == id2_Item)
				{
					httpBinding.Required = XmlConvert.ToBoolean(base.Reader.Value);
					array[0] = true;
				}
				else if (!array[1] && (object)base.Reader.LocalName == id83_verb && (object)base.Reader.NamespaceURI == id5_Item)
				{
					httpBinding.Verb = base.Reader.Value;
					array[1] = true;
				}
				else if (!IsXmlnsAttribute(base.Reader.Name))
				{
					UnknownNode(httpBinding, "http://schemas.xmlsoap.org/wsdl/:required, :verb");
				}
			}
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				return httpBinding;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					UnknownNode(httpBinding, "");
				}
				else
				{
					UnknownNode(httpBinding, "");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			ReadEndElement();
			return httpBinding;
		}

		private PortType Read75_PortType(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id84_PortType || (object)xmlQualifiedName.Namespace != id2_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			PortType portType = new PortType();
			XmlAttribute[] array = null;
			int num = 0;
			ServiceDescriptionFormatExtensionCollection extensions = portType.Extensions;
			OperationCollection operations = portType.Operations;
			bool[] array2 = new bool[6];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[3] && (object)base.Reader.LocalName == id4_name && (object)base.Reader.NamespaceURI == id5_Item)
				{
					portType.Name = base.Reader.Value;
					array2[3] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (portType.Namespaces == null)
					{
						portType.Namespaces = new XmlSerializerNamespaces();
					}
					portType.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			portType.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				portType.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return portType;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[0] && (object)base.Reader.LocalName == id7_documentation && (object)base.Reader.NamespaceURI == id2_Item)
					{
						portType.DocumentationElement = (XmlElement)ReadXmlNode(wrapped: false);
						array2[0] = true;
					}
					else if ((object)base.Reader.LocalName == id28_operation && (object)base.Reader.NamespaceURI == id2_Item)
					{
						if (operations == null)
						{
							base.Reader.Skip();
						}
						else
						{
							operations.Add(Read74_Operation(isNullable: false, checkType: true));
						}
					}
					else
					{
						extensions.Add((XmlElement)ReadXmlNode(wrapped: false));
					}
				}
				else
				{
					UnknownNode(portType, "http://schemas.xmlsoap.org/wsdl/:documentation, http://schemas.xmlsoap.org/wsdl/:operation");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			portType.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return portType;
		}

		private Operation Read74_Operation(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id85_Operation || (object)xmlQualifiedName.Namespace != id2_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			Operation operation = new Operation();
			XmlAttribute[] array = null;
			int num = 0;
			ServiceDescriptionFormatExtensionCollection extensions = operation.Extensions;
			OperationMessageCollection messages = operation.Messages;
			OperationFaultCollection faults = operation.Faults;
			bool[] array2 = new bool[8];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[3] && (object)base.Reader.LocalName == id4_name && (object)base.Reader.NamespaceURI == id5_Item)
				{
					operation.Name = base.Reader.Value;
					array2[3] = true;
				}
				else if (!array2[5] && (object)base.Reader.LocalName == id86_parameterOrder && (object)base.Reader.NamespaceURI == id5_Item)
				{
					operation.ParameterOrderString = base.Reader.Value;
					array2[5] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (operation.Namespaces == null)
					{
						operation.Namespaces = new XmlSerializerNamespaces();
					}
					operation.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			operation.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				operation.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return operation;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[0] && (object)base.Reader.LocalName == id7_documentation && (object)base.Reader.NamespaceURI == id2_Item)
					{
						operation.DocumentationElement = (XmlElement)ReadXmlNode(wrapped: false);
						array2[0] = true;
					}
					else if ((object)base.Reader.LocalName == id30_input && (object)base.Reader.NamespaceURI == id2_Item)
					{
						if (messages == null)
						{
							base.Reader.Skip();
						}
						else
						{
							messages.Add(Read71_OperationInput(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id31_output && (object)base.Reader.NamespaceURI == id2_Item)
					{
						if (messages == null)
						{
							base.Reader.Skip();
						}
						else
						{
							messages.Add(Read72_OperationOutput(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id32_fault && (object)base.Reader.NamespaceURI == id2_Item)
					{
						if (faults == null)
						{
							base.Reader.Skip();
						}
						else
						{
							faults.Add(Read73_OperationFault(isNullable: false, checkType: true));
						}
					}
					else
					{
						extensions.Add((XmlElement)ReadXmlNode(wrapped: false));
					}
				}
				else
				{
					UnknownNode(operation, "http://schemas.xmlsoap.org/wsdl/:documentation, http://schemas.xmlsoap.org/wsdl/:input, http://schemas.xmlsoap.org/wsdl/:output, http://schemas.xmlsoap.org/wsdl/:fault");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			operation.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return operation;
		}

		private OperationFault Read73_OperationFault(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id87_OperationFault || (object)xmlQualifiedName.Namespace != id2_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			OperationFault operationFault = new OperationFault();
			XmlAttribute[] array = null;
			int num = 0;
			ServiceDescriptionFormatExtensionCollection extensions = operationFault.Extensions;
			bool[] array2 = new bool[6];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[3] && (object)base.Reader.LocalName == id4_name && (object)base.Reader.NamespaceURI == id5_Item)
				{
					operationFault.Name = base.Reader.Value;
					array2[3] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id10_message && (object)base.Reader.NamespaceURI == id5_Item)
				{
					operationFault.Message = ToXmlQualifiedName(base.Reader.Value);
					array2[4] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (operationFault.Namespaces == null)
					{
						operationFault.Namespaces = new XmlSerializerNamespaces();
					}
					operationFault.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			operationFault.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				operationFault.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return operationFault;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[0] && (object)base.Reader.LocalName == id7_documentation && (object)base.Reader.NamespaceURI == id2_Item)
					{
						operationFault.DocumentationElement = (XmlElement)ReadXmlNode(wrapped: false);
						array2[0] = true;
					}
					else
					{
						extensions.Add((XmlElement)ReadXmlNode(wrapped: false));
					}
				}
				else
				{
					UnknownNode(operationFault, "http://schemas.xmlsoap.org/wsdl/:documentation");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			operationFault.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return operationFault;
		}

		private OperationOutput Read72_OperationOutput(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id88_OperationOutput || (object)xmlQualifiedName.Namespace != id2_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			OperationOutput operationOutput = new OperationOutput();
			XmlAttribute[] array = null;
			int num = 0;
			ServiceDescriptionFormatExtensionCollection extensions = operationOutput.Extensions;
			bool[] array2 = new bool[6];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[3] && (object)base.Reader.LocalName == id4_name && (object)base.Reader.NamespaceURI == id5_Item)
				{
					operationOutput.Name = base.Reader.Value;
					array2[3] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id10_message && (object)base.Reader.NamespaceURI == id5_Item)
				{
					operationOutput.Message = ToXmlQualifiedName(base.Reader.Value);
					array2[4] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (operationOutput.Namespaces == null)
					{
						operationOutput.Namespaces = new XmlSerializerNamespaces();
					}
					operationOutput.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			operationOutput.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				operationOutput.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return operationOutput;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[0] && (object)base.Reader.LocalName == id7_documentation && (object)base.Reader.NamespaceURI == id2_Item)
					{
						operationOutput.DocumentationElement = (XmlElement)ReadXmlNode(wrapped: false);
						array2[0] = true;
					}
					else
					{
						extensions.Add((XmlElement)ReadXmlNode(wrapped: false));
					}
				}
				else
				{
					UnknownNode(operationOutput, "http://schemas.xmlsoap.org/wsdl/:documentation");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			operationOutput.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return operationOutput;
		}

		private OperationInput Read71_OperationInput(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id89_OperationInput || (object)xmlQualifiedName.Namespace != id2_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			OperationInput operationInput = new OperationInput();
			XmlAttribute[] array = null;
			int num = 0;
			ServiceDescriptionFormatExtensionCollection extensions = operationInput.Extensions;
			bool[] array2 = new bool[6];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[3] && (object)base.Reader.LocalName == id4_name && (object)base.Reader.NamespaceURI == id5_Item)
				{
					operationInput.Name = base.Reader.Value;
					array2[3] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id10_message && (object)base.Reader.NamespaceURI == id5_Item)
				{
					operationInput.Message = ToXmlQualifiedName(base.Reader.Value);
					array2[4] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (operationInput.Namespaces == null)
					{
						operationInput.Namespaces = new XmlSerializerNamespaces();
					}
					operationInput.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			operationInput.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				operationInput.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return operationInput;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[0] && (object)base.Reader.LocalName == id7_documentation && (object)base.Reader.NamespaceURI == id2_Item)
					{
						operationInput.DocumentationElement = (XmlElement)ReadXmlNode(wrapped: false);
						array2[0] = true;
					}
					else
					{
						extensions.Add((XmlElement)ReadXmlNode(wrapped: false));
					}
				}
				else
				{
					UnknownNode(operationInput, "http://schemas.xmlsoap.org/wsdl/:documentation");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			operationInput.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return operationInput;
		}

		private Message Read69_Message(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id90_Message || (object)xmlQualifiedName.Namespace != id2_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			Message message = new Message();
			XmlAttribute[] array = null;
			int num = 0;
			ServiceDescriptionFormatExtensionCollection extensions = message.Extensions;
			MessagePartCollection parts = message.Parts;
			bool[] array2 = new bool[6];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[3] && (object)base.Reader.LocalName == id4_name && (object)base.Reader.NamespaceURI == id5_Item)
				{
					message.Name = base.Reader.Value;
					array2[3] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (message.Namespaces == null)
					{
						message.Namespaces = new XmlSerializerNamespaces();
					}
					message.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			message.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				message.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return message;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[0] && (object)base.Reader.LocalName == id7_documentation && (object)base.Reader.NamespaceURI == id2_Item)
					{
						message.DocumentationElement = (XmlElement)ReadXmlNode(wrapped: false);
						array2[0] = true;
					}
					else if ((object)base.Reader.LocalName == id49_part && (object)base.Reader.NamespaceURI == id2_Item)
					{
						if (parts == null)
						{
							base.Reader.Skip();
						}
						else
						{
							parts.Add(Read68_MessagePart(isNullable: false, checkType: true));
						}
					}
					else
					{
						extensions.Add((XmlElement)ReadXmlNode(wrapped: false));
					}
				}
				else
				{
					UnknownNode(message, "http://schemas.xmlsoap.org/wsdl/:documentation, http://schemas.xmlsoap.org/wsdl/:part");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			message.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return message;
		}

		private MessagePart Read68_MessagePart(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id91_MessagePart || (object)xmlQualifiedName.Namespace != id2_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			MessagePart messagePart = new MessagePart();
			XmlAttribute[] array = null;
			int num = 0;
			ServiceDescriptionFormatExtensionCollection extensions = messagePart.Extensions;
			bool[] array2 = new bool[7];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[3] && (object)base.Reader.LocalName == id4_name && (object)base.Reader.NamespaceURI == id5_Item)
				{
					messagePart.Name = base.Reader.Value;
					array2[3] = true;
				}
				else if (!array2[5] && (object)base.Reader.LocalName == id92_element && (object)base.Reader.NamespaceURI == id5_Item)
				{
					messagePart.Element = ToXmlQualifiedName(base.Reader.Value);
					array2[5] = true;
				}
				else if (!array2[6] && (object)base.Reader.LocalName == id27_type && (object)base.Reader.NamespaceURI == id5_Item)
				{
					messagePart.Type = ToXmlQualifiedName(base.Reader.Value);
					array2[6] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (messagePart.Namespaces == null)
					{
						messagePart.Namespaces = new XmlSerializerNamespaces();
					}
					messagePart.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			messagePart.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				messagePart.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return messagePart;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[0] && (object)base.Reader.LocalName == id7_documentation && (object)base.Reader.NamespaceURI == id2_Item)
					{
						messagePart.DocumentationElement = (XmlElement)ReadXmlNode(wrapped: false);
						array2[0] = true;
					}
					else
					{
						extensions.Add((XmlElement)ReadXmlNode(wrapped: false));
					}
				}
				else
				{
					UnknownNode(messagePart, "http://schemas.xmlsoap.org/wsdl/:documentation");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			messagePart.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return messagePart;
		}

		private Types Read67_Types(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id93_Types || (object)xmlQualifiedName.Namespace != id2_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			Types types = new Types();
			XmlAttribute[] array = null;
			int num = 0;
			ServiceDescriptionFormatExtensionCollection extensions = types.Extensions;
			XmlSchemas schemas = types.Schemas;
			bool[] array2 = new bool[5];
			while (base.Reader.MoveToNextAttribute())
			{
				if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (types.Namespaces == null)
					{
						types.Namespaces = new XmlSerializerNamespaces();
					}
					types.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			types.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				types.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return types;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[0] && (object)base.Reader.LocalName == id7_documentation && (object)base.Reader.NamespaceURI == id2_Item)
					{
						types.DocumentationElement = (XmlElement)ReadXmlNode(wrapped: false);
						array2[0] = true;
					}
					else if ((object)base.Reader.LocalName == id94_schema && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (schemas == null)
						{
							base.Reader.Skip();
						}
						else
						{
							schemas.Add(Read66_XmlSchema(isNullable: false, checkType: true));
						}
					}
					else
					{
						extensions.Add((XmlElement)ReadXmlNode(wrapped: false));
					}
				}
				else
				{
					UnknownNode(types, "http://schemas.xmlsoap.org/wsdl/:documentation, http://www.w3.org/2001/XMLSchema:schema");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			types.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return types;
		}

		private XmlSchema Read66_XmlSchema(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id96_XmlSchema || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchema xmlSchema = new XmlSchema();
			XmlSchemaObjectCollection includes = xmlSchema.Includes;
			XmlSchemaObjectCollection items = xmlSchema.Items;
			XmlAttribute[] array = null;
			int num = 0;
			bool[] array2 = new bool[11];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id97_attributeFormDefault && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchema.AttributeFormDefault = Read6_XmlSchemaForm(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[2] && (object)base.Reader.LocalName == id98_blockDefault && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchema.BlockDefault = Read7_XmlSchemaDerivationMethod(base.Reader.Value);
					array2[2] = true;
				}
				else if (!array2[3] && (object)base.Reader.LocalName == id99_finalDefault && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchema.FinalDefault = Read7_XmlSchemaDerivationMethod(base.Reader.Value);
					array2[3] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id100_elementFormDefault && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchema.ElementFormDefault = Read6_XmlSchemaForm(base.Reader.Value);
					array2[4] = true;
				}
				else if (!array2[5] && (object)base.Reader.LocalName == id6_targetNamespace && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchema.TargetNamespace = CollapseWhitespace(base.Reader.Value);
					array2[5] = true;
				}
				else if (!array2[6] && (object)base.Reader.LocalName == id101_version && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchema.Version = CollapseWhitespace(base.Reader.Value);
					array2[6] = true;
				}
				else if (!array2[9] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchema.Id = CollapseWhitespace(base.Reader.Value);
					array2[9] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchema.Namespaces == null)
					{
						xmlSchema.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchema.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchema.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchema.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchema;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if ((object)base.Reader.LocalName == id103_include && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (includes == null)
						{
							base.Reader.Skip();
						}
						else
						{
							includes.Add(Read12_XmlSchemaInclude(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id8_import && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (includes == null)
						{
							base.Reader.Skip();
						}
						else
						{
							includes.Add(Read13_XmlSchemaImport(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id104_redefine && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (includes == null)
						{
							base.Reader.Skip();
						}
						else
						{
							includes.Add(Read64_XmlSchemaRedefine(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id105_simpleType && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (items == null)
						{
							base.Reader.Skip();
						}
						else
						{
							items.Add(Read34_XmlSchemaSimpleType(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id106_complexType && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (items == null)
						{
							base.Reader.Skip();
						}
						else
						{
							items.Add(Read62_XmlSchemaComplexType(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (items == null)
						{
							base.Reader.Skip();
						}
						else
						{
							items.Add(Read11_XmlSchemaAnnotation(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id108_notation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (items == null)
						{
							base.Reader.Skip();
						}
						else
						{
							items.Add(Read65_XmlSchemaNotation(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id59_group && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (items == null)
						{
							base.Reader.Skip();
						}
						else
						{
							items.Add(Read63_XmlSchemaGroup(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id92_element && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (items == null)
						{
							base.Reader.Skip();
						}
						else
						{
							items.Add(Read52_XmlSchemaElement(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id109_attribute && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (items == null)
						{
							base.Reader.Skip();
						}
						else
						{
							items.Add(Read36_XmlSchemaAttribute(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id110_attributeGroup && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (items == null)
						{
							base.Reader.Skip();
						}
						else
						{
							items.Add(Read40_XmlSchemaAttributeGroup(isNullable: false, checkType: true));
						}
					}
					else
					{
						UnknownNode(xmlSchema, "http://www.w3.org/2001/XMLSchema:include, http://www.w3.org/2001/XMLSchema:import, http://www.w3.org/2001/XMLSchema:redefine, http://www.w3.org/2001/XMLSchema:simpleType, http://www.w3.org/2001/XMLSchema:complexType, http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:notation, http://www.w3.org/2001/XMLSchema:group, http://www.w3.org/2001/XMLSchema:element, http://www.w3.org/2001/XMLSchema:attribute, http://www.w3.org/2001/XMLSchema:attributeGroup");
					}
				}
				else
				{
					UnknownNode(xmlSchema, "http://www.w3.org/2001/XMLSchema:include, http://www.w3.org/2001/XMLSchema:import, http://www.w3.org/2001/XMLSchema:redefine, http://www.w3.org/2001/XMLSchema:simpleType, http://www.w3.org/2001/XMLSchema:complexType, http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:notation, http://www.w3.org/2001/XMLSchema:group, http://www.w3.org/2001/XMLSchema:element, http://www.w3.org/2001/XMLSchema:attribute, http://www.w3.org/2001/XMLSchema:attributeGroup");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchema.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchema;
		}

		private XmlSchemaAttributeGroup Read40_XmlSchemaAttributeGroup(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id111_XmlSchemaAttributeGroup || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaAttributeGroup xmlSchemaAttributeGroup = new XmlSchemaAttributeGroup();
			XmlAttribute[] array = null;
			int num = 0;
			XmlSchemaObjectCollection attributes = xmlSchemaAttributeGroup.Attributes;
			bool[] array2 = new bool[7];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaAttributeGroup.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id4_name && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaAttributeGroup.Name = base.Reader.Value;
					array2[4] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaAttributeGroup.Namespaces == null)
					{
						xmlSchemaAttributeGroup.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaAttributeGroup.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaAttributeGroup.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaAttributeGroup.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaAttributeGroup;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaAttributeGroup.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[2] = true;
					}
					else if ((object)base.Reader.LocalName == id109_attribute && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (attributes == null)
						{
							base.Reader.Skip();
						}
						else
						{
							attributes.Add(Read36_XmlSchemaAttribute(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id110_attributeGroup && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (attributes == null)
						{
							base.Reader.Skip();
						}
						else
						{
							attributes.Add(Read37_XmlSchemaAttributeGroupRef(isNullable: false, checkType: true));
						}
					}
					else if (!array2[6] && (object)base.Reader.LocalName == id112_anyAttribute && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaAttributeGroup.AnyAttribute = Read39_XmlSchemaAnyAttribute(isNullable: false, checkType: true);
						array2[6] = true;
					}
					else
					{
						UnknownNode(xmlSchemaAttributeGroup, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:attribute, http://www.w3.org/2001/XMLSchema:attributeGroup, http://www.w3.org/2001/XMLSchema:anyAttribute");
					}
				}
				else
				{
					UnknownNode(xmlSchemaAttributeGroup, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:attribute, http://www.w3.org/2001/XMLSchema:attributeGroup, http://www.w3.org/2001/XMLSchema:anyAttribute");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaAttributeGroup.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaAttributeGroup;
		}

		private XmlSchemaAnyAttribute Read39_XmlSchemaAnyAttribute(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id113_XmlSchemaAnyAttribute || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaAnyAttribute xmlSchemaAnyAttribute = new XmlSchemaAnyAttribute();
			XmlAttribute[] array = null;
			int num = 0;
			bool[] array2 = new bool[6];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaAnyAttribute.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id36_namespace && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaAnyAttribute.Namespace = base.Reader.Value;
					array2[4] = true;
				}
				else if (!array2[5] && (object)base.Reader.LocalName == id114_processContents && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaAnyAttribute.ProcessContents = Read38_XmlSchemaContentProcessing(base.Reader.Value);
					array2[5] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaAnyAttribute.Namespaces == null)
					{
						xmlSchemaAnyAttribute.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaAnyAttribute.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaAnyAttribute.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaAnyAttribute.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaAnyAttribute;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaAnyAttribute.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[2] = true;
					}
					else
					{
						UnknownNode(xmlSchemaAnyAttribute, "http://www.w3.org/2001/XMLSchema:annotation");
					}
				}
				else
				{
					UnknownNode(xmlSchemaAnyAttribute, "http://www.w3.org/2001/XMLSchema:annotation");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaAnyAttribute.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaAnyAttribute;
		}

		private XmlSchemaAnnotation Read11_XmlSchemaAnnotation(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id115_XmlSchemaAnnotation || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaAnnotation xmlSchemaAnnotation = new XmlSchemaAnnotation();
			XmlSchemaObjectCollection items = xmlSchemaAnnotation.Items;
			XmlAttribute[] array = null;
			int num = 0;
			bool[] array2 = new bool[4];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaAnnotation.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaAnnotation.Namespaces == null)
					{
						xmlSchemaAnnotation.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaAnnotation.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaAnnotation.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaAnnotation.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaAnnotation;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if ((object)base.Reader.LocalName == id7_documentation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (items == null)
						{
							base.Reader.Skip();
						}
						else
						{
							items.Add(Read9_XmlSchemaDocumentation(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id116_appinfo && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (items == null)
						{
							base.Reader.Skip();
						}
						else
						{
							items.Add(Read10_XmlSchemaAppInfo(isNullable: false, checkType: true));
						}
					}
					else
					{
						UnknownNode(xmlSchemaAnnotation, "http://www.w3.org/2001/XMLSchema:documentation, http://www.w3.org/2001/XMLSchema:appinfo");
					}
				}
				else
				{
					UnknownNode(xmlSchemaAnnotation, "http://www.w3.org/2001/XMLSchema:documentation, http://www.w3.org/2001/XMLSchema:appinfo");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaAnnotation.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaAnnotation;
		}

		private XmlSchemaAppInfo Read10_XmlSchemaAppInfo(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id117_XmlSchemaAppInfo || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaAppInfo xmlSchemaAppInfo = new XmlSchemaAppInfo();
			XmlNode[] array = null;
			int num = 0;
			bool[] array2 = new bool[3];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id118_source && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaAppInfo.Source = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaAppInfo.Namespaces == null)
					{
						xmlSchemaAppInfo.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaAppInfo.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					UnknownNode(xmlSchemaAppInfo, ":source");
				}
			}
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaAppInfo.Markup = (XmlNode[])ShrinkArray(array, num, typeof(XmlNode), isNullable: true);
				return xmlSchemaAppInfo;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					array = (XmlNode[])EnsureArrayIndex(array, num, typeof(XmlNode));
					array[num++] = ReadXmlNode(wrapped: false);
				}
				else if (base.Reader.NodeType == XmlNodeType.Text || base.Reader.NodeType == XmlNodeType.CDATA || base.Reader.NodeType == XmlNodeType.Whitespace || base.Reader.NodeType == XmlNodeType.SignificantWhitespace)
				{
					array = (XmlNode[])EnsureArrayIndex(array, num, typeof(XmlNode));
					array[num++] = base.Document.CreateTextNode(base.Reader.ReadString());
				}
				else
				{
					UnknownNode(xmlSchemaAppInfo, "");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaAppInfo.Markup = (XmlNode[])ShrinkArray(array, num, typeof(XmlNode), isNullable: true);
			ReadEndElement();
			return xmlSchemaAppInfo;
		}

		private XmlSchemaDocumentation Read9_XmlSchemaDocumentation(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id119_XmlSchemaDocumentation || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaDocumentation xmlSchemaDocumentation = new XmlSchemaDocumentation();
			XmlNode[] array = null;
			int num = 0;
			bool[] array2 = new bool[4];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id118_source && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaDocumentation.Source = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[2] && (object)base.Reader.LocalName == id120_lang && (object)base.Reader.NamespaceURI == id121_Item)
				{
					xmlSchemaDocumentation.Language = base.Reader.Value;
					array2[2] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaDocumentation.Namespaces == null)
					{
						xmlSchemaDocumentation.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaDocumentation.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					UnknownNode(xmlSchemaDocumentation, ":source, http://www.w3.org/XML/1998/namespace");
				}
			}
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaDocumentation.Markup = (XmlNode[])ShrinkArray(array, num, typeof(XmlNode), isNullable: true);
				return xmlSchemaDocumentation;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					array = (XmlNode[])EnsureArrayIndex(array, num, typeof(XmlNode));
					array[num++] = ReadXmlNode(wrapped: false);
				}
				else if (base.Reader.NodeType == XmlNodeType.Text || base.Reader.NodeType == XmlNodeType.CDATA || base.Reader.NodeType == XmlNodeType.Whitespace || base.Reader.NodeType == XmlNodeType.SignificantWhitespace)
				{
					array = (XmlNode[])EnsureArrayIndex(array, num, typeof(XmlNode));
					array[num++] = base.Document.CreateTextNode(base.Reader.ReadString());
				}
				else
				{
					UnknownNode(xmlSchemaDocumentation, "");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaDocumentation.Markup = (XmlNode[])ShrinkArray(array, num, typeof(XmlNode), isNullable: true);
			ReadEndElement();
			return xmlSchemaDocumentation;
		}

		private XmlSchemaContentProcessing Read38_XmlSchemaContentProcessing(string s)
		{
			return s switch
			{
				"skip" => XmlSchemaContentProcessing.Skip, 
				"lax" => XmlSchemaContentProcessing.Lax, 
				"strict" => XmlSchemaContentProcessing.Strict, 
				_ => throw CreateUnknownConstantException(s, typeof(XmlSchemaContentProcessing)), 
			};
		}

		private XmlSchemaAttributeGroupRef Read37_XmlSchemaAttributeGroupRef(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id122_XmlSchemaAttributeGroupRef || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaAttributeGroupRef xmlSchemaAttributeGroupRef = new XmlSchemaAttributeGroupRef();
			XmlAttribute[] array = null;
			int num = 0;
			bool[] array2 = new bool[5];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaAttributeGroupRef.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id123_ref && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaAttributeGroupRef.RefName = ToXmlQualifiedName(base.Reader.Value);
					array2[4] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaAttributeGroupRef.Namespaces == null)
					{
						xmlSchemaAttributeGroupRef.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaAttributeGroupRef.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaAttributeGroupRef.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaAttributeGroupRef.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaAttributeGroupRef;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaAttributeGroupRef.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[2] = true;
					}
					else
					{
						UnknownNode(xmlSchemaAttributeGroupRef, "http://www.w3.org/2001/XMLSchema:annotation");
					}
				}
				else
				{
					UnknownNode(xmlSchemaAttributeGroupRef, "http://www.w3.org/2001/XMLSchema:annotation");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaAttributeGroupRef.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaAttributeGroupRef;
		}

		private XmlSchemaAttribute Read36_XmlSchemaAttribute(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id124_XmlSchemaAttribute || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaAttribute xmlSchemaAttribute = new XmlSchemaAttribute();
			XmlAttribute[] array = null;
			int num = 0;
			bool[] array2 = new bool[12];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaAttribute.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id125_default && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaAttribute.DefaultValue = base.Reader.Value;
					array2[4] = true;
				}
				else if (!array2[5] && (object)base.Reader.LocalName == id126_fixed && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaAttribute.FixedValue = base.Reader.Value;
					array2[5] = true;
				}
				else if (!array2[6] && (object)base.Reader.LocalName == id127_form && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaAttribute.Form = Read6_XmlSchemaForm(base.Reader.Value);
					array2[6] = true;
				}
				else if (!array2[7] && (object)base.Reader.LocalName == id4_name && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaAttribute.Name = base.Reader.Value;
					array2[7] = true;
				}
				else if (!array2[8] && (object)base.Reader.LocalName == id123_ref && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaAttribute.RefName = ToXmlQualifiedName(base.Reader.Value);
					array2[8] = true;
				}
				else if (!array2[9] && (object)base.Reader.LocalName == id27_type && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaAttribute.SchemaTypeName = ToXmlQualifiedName(base.Reader.Value);
					array2[9] = true;
				}
				else if (!array2[11] && (object)base.Reader.LocalName == id35_use && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaAttribute.Use = Read35_XmlSchemaUse(base.Reader.Value);
					array2[11] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaAttribute.Namespaces == null)
					{
						xmlSchemaAttribute.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaAttribute.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaAttribute.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaAttribute.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaAttribute;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaAttribute.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[2] = true;
					}
					else if (!array2[10] && (object)base.Reader.LocalName == id105_simpleType && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaAttribute.SchemaType = Read34_XmlSchemaSimpleType(isNullable: false, checkType: true);
						array2[10] = true;
					}
					else
					{
						UnknownNode(xmlSchemaAttribute, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:simpleType");
					}
				}
				else
				{
					UnknownNode(xmlSchemaAttribute, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:simpleType");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaAttribute.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaAttribute;
		}

		private XmlSchemaSimpleType Read34_XmlSchemaSimpleType(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id128_XmlSchemaSimpleType || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaSimpleType xmlSchemaSimpleType = new XmlSchemaSimpleType();
			XmlAttribute[] array = null;
			int num = 0;
			bool[] array2 = new bool[7];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaSimpleType.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id4_name && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaSimpleType.Name = base.Reader.Value;
					array2[4] = true;
				}
				else if (!array2[5] && (object)base.Reader.LocalName == id129_final && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaSimpleType.Final = Read7_XmlSchemaDerivationMethod(base.Reader.Value);
					array2[5] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaSimpleType.Namespaces == null)
					{
						xmlSchemaSimpleType.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaSimpleType.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaSimpleType.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaSimpleType.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaSimpleType;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaSimpleType.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[2] = true;
					}
					else if (!array2[6] && (object)base.Reader.LocalName == id130_list && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaSimpleType.Content = Read17_XmlSchemaSimpleTypeList(isNullable: false, checkType: true);
						array2[6] = true;
					}
					else if (!array2[6] && (object)base.Reader.LocalName == id131_restriction && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaSimpleType.Content = Read32_XmlSchemaSimpleTypeRestriction(isNullable: false, checkType: true);
						array2[6] = true;
					}
					else if (!array2[6] && (object)base.Reader.LocalName == id132_union && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaSimpleType.Content = Read33_XmlSchemaSimpleTypeUnion(isNullable: false, checkType: true);
						array2[6] = true;
					}
					else
					{
						UnknownNode(xmlSchemaSimpleType, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:list, http://www.w3.org/2001/XMLSchema:restriction, http://www.w3.org/2001/XMLSchema:union");
					}
				}
				else
				{
					UnknownNode(xmlSchemaSimpleType, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:list, http://www.w3.org/2001/XMLSchema:restriction, http://www.w3.org/2001/XMLSchema:union");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaSimpleType.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaSimpleType;
		}

		private XmlSchemaSimpleTypeUnion Read33_XmlSchemaSimpleTypeUnion(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id133_XmlSchemaSimpleTypeUnion || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaSimpleTypeUnion xmlSchemaSimpleTypeUnion = new XmlSchemaSimpleTypeUnion();
			XmlAttribute[] array = null;
			int num = 0;
			XmlSchemaObjectCollection baseTypes = xmlSchemaSimpleTypeUnion.BaseTypes;
			XmlQualifiedName[] array2 = null;
			int num2 = 0;
			bool[] array3 = new bool[6];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array3[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaSimpleTypeUnion.Id = CollapseWhitespace(base.Reader.Value);
					array3[1] = true;
				}
				else if ((object)base.Reader.LocalName == id134_memberTypes && (object)base.Reader.NamespaceURI == id5_Item)
				{
					string value = base.Reader.Value;
					string[] array4 = value.Split(null);
					for (int i = 0; i < array4.Length; i++)
					{
						array2 = (XmlQualifiedName[])EnsureArrayIndex(array2, num2, typeof(XmlQualifiedName));
						array2[num2++] = ToXmlQualifiedName(array4[i]);
					}
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaSimpleTypeUnion.Namespaces == null)
					{
						xmlSchemaSimpleTypeUnion.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaSimpleTypeUnion.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaSimpleTypeUnion.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			xmlSchemaSimpleTypeUnion.MemberTypes = (XmlQualifiedName[])ShrinkArray(array2, num2, typeof(XmlQualifiedName), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaSimpleTypeUnion.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				xmlSchemaSimpleTypeUnion.MemberTypes = (XmlQualifiedName[])ShrinkArray(array2, num2, typeof(XmlQualifiedName), isNullable: true);
				return xmlSchemaSimpleTypeUnion;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array3[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaSimpleTypeUnion.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array3[2] = true;
					}
					else if ((object)base.Reader.LocalName == id105_simpleType && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (baseTypes == null)
						{
							base.Reader.Skip();
						}
						else
						{
							baseTypes.Add(Read34_XmlSchemaSimpleType(isNullable: false, checkType: true));
						}
					}
					else
					{
						UnknownNode(xmlSchemaSimpleTypeUnion, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:simpleType");
					}
				}
				else
				{
					UnknownNode(xmlSchemaSimpleTypeUnion, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:simpleType");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaSimpleTypeUnion.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			xmlSchemaSimpleTypeUnion.MemberTypes = (XmlQualifiedName[])ShrinkArray(array2, num2, typeof(XmlQualifiedName), isNullable: true);
			ReadEndElement();
			return xmlSchemaSimpleTypeUnion;
		}

		private XmlSchemaSimpleTypeRestriction Read32_XmlSchemaSimpleTypeRestriction(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id135_XmlSchemaSimpleTypeRestriction || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaSimpleTypeRestriction xmlSchemaSimpleTypeRestriction = new XmlSchemaSimpleTypeRestriction();
			XmlAttribute[] array = null;
			int num = 0;
			XmlSchemaObjectCollection facets = xmlSchemaSimpleTypeRestriction.Facets;
			bool[] array2 = new bool[7];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaSimpleTypeRestriction.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id136_base && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaSimpleTypeRestriction.BaseTypeName = ToXmlQualifiedName(base.Reader.Value);
					array2[4] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaSimpleTypeRestriction.Namespaces == null)
					{
						xmlSchemaSimpleTypeRestriction.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaSimpleTypeRestriction.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaSimpleTypeRestriction.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaSimpleTypeRestriction.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaSimpleTypeRestriction;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaSimpleTypeRestriction.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[2] = true;
					}
					else if (!array2[5] && (object)base.Reader.LocalName == id105_simpleType && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaSimpleTypeRestriction.BaseType = Read34_XmlSchemaSimpleType(isNullable: false, checkType: true);
						array2[5] = true;
					}
					else if ((object)base.Reader.LocalName == id137_fractionDigits && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (facets == null)
						{
							base.Reader.Skip();
						}
						else
						{
							facets.Add(Read20_XmlSchemaFractionDigitsFacet(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id138_minInclusive && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (facets == null)
						{
							base.Reader.Skip();
						}
						else
						{
							facets.Add(Read21_XmlSchemaMinInclusiveFacet(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id139_maxLength && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (facets == null)
						{
							base.Reader.Skip();
						}
						else
						{
							facets.Add(Read22_XmlSchemaMaxLengthFacet(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id140_length && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (facets == null)
						{
							base.Reader.Skip();
						}
						else
						{
							facets.Add(Read23_XmlSchemaLengthFacet(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id141_totalDigits && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (facets == null)
						{
							base.Reader.Skip();
						}
						else
						{
							facets.Add(Read24_XmlSchemaTotalDigitsFacet(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id62_pattern && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (facets == null)
						{
							base.Reader.Skip();
						}
						else
						{
							facets.Add(Read25_XmlSchemaPatternFacet(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id142_enumeration && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (facets == null)
						{
							base.Reader.Skip();
						}
						else
						{
							facets.Add(Read26_XmlSchemaEnumerationFacet(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id143_maxInclusive && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (facets == null)
						{
							base.Reader.Skip();
						}
						else
						{
							facets.Add(Read27_XmlSchemaMaxInclusiveFacet(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id144_maxExclusive && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (facets == null)
						{
							base.Reader.Skip();
						}
						else
						{
							facets.Add(Read28_XmlSchemaMaxExclusiveFacet(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id145_whiteSpace && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (facets == null)
						{
							base.Reader.Skip();
						}
						else
						{
							facets.Add(Read29_XmlSchemaWhiteSpaceFacet(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id146_minExclusive && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (facets == null)
						{
							base.Reader.Skip();
						}
						else
						{
							facets.Add(Read30_XmlSchemaMinExclusiveFacet(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id147_minLength && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (facets == null)
						{
							base.Reader.Skip();
						}
						else
						{
							facets.Add(Read31_XmlSchemaMinLengthFacet(isNullable: false, checkType: true));
						}
					}
					else
					{
						UnknownNode(xmlSchemaSimpleTypeRestriction, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:simpleType, http://www.w3.org/2001/XMLSchema:fractionDigits, http://www.w3.org/2001/XMLSchema:minInclusive, http://www.w3.org/2001/XMLSchema:maxLength, http://www.w3.org/2001/XMLSchema:length, http://www.w3.org/2001/XMLSchema:totalDigits, http://www.w3.org/2001/XMLSchema:pattern, http://www.w3.org/2001/XMLSchema:enumeration, http://www.w3.org/2001/XMLSchema:maxInclusive, http://www.w3.org/2001/XMLSchema:maxExclusive, http://www.w3.org/2001/XMLSchema:whiteSpace, http://www.w3.org/2001/XMLSchema:minExclusive, http://www.w3.org/2001/XMLSchema:minLength");
					}
				}
				else
				{
					UnknownNode(xmlSchemaSimpleTypeRestriction, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:simpleType, http://www.w3.org/2001/XMLSchema:fractionDigits, http://www.w3.org/2001/XMLSchema:minInclusive, http://www.w3.org/2001/XMLSchema:maxLength, http://www.w3.org/2001/XMLSchema:length, http://www.w3.org/2001/XMLSchema:totalDigits, http://www.w3.org/2001/XMLSchema:pattern, http://www.w3.org/2001/XMLSchema:enumeration, http://www.w3.org/2001/XMLSchema:maxInclusive, http://www.w3.org/2001/XMLSchema:maxExclusive, http://www.w3.org/2001/XMLSchema:whiteSpace, http://www.w3.org/2001/XMLSchema:minExclusive, http://www.w3.org/2001/XMLSchema:minLength");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaSimpleTypeRestriction.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaSimpleTypeRestriction;
		}

		private XmlSchemaMinLengthFacet Read31_XmlSchemaMinLengthFacet(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id148_XmlSchemaMinLengthFacet || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaMinLengthFacet xmlSchemaMinLengthFacet = new XmlSchemaMinLengthFacet();
			XmlAttribute[] array = null;
			int num = 0;
			bool[] array2 = new bool[6];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaMinLengthFacet.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id149_value && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaMinLengthFacet.Value = base.Reader.Value;
					array2[4] = true;
				}
				else if (!array2[5] && (object)base.Reader.LocalName == id126_fixed && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaMinLengthFacet.IsFixed = XmlConvert.ToBoolean(base.Reader.Value);
					array2[5] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaMinLengthFacet.Namespaces == null)
					{
						xmlSchemaMinLengthFacet.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaMinLengthFacet.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaMinLengthFacet.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaMinLengthFacet.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaMinLengthFacet;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaMinLengthFacet.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[2] = true;
					}
					else
					{
						UnknownNode(xmlSchemaMinLengthFacet, "http://www.w3.org/2001/XMLSchema:annotation");
					}
				}
				else
				{
					UnknownNode(xmlSchemaMinLengthFacet, "http://www.w3.org/2001/XMLSchema:annotation");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaMinLengthFacet.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaMinLengthFacet;
		}

		private XmlSchemaMinExclusiveFacet Read30_XmlSchemaMinExclusiveFacet(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id150_XmlSchemaMinExclusiveFacet || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaMinExclusiveFacet xmlSchemaMinExclusiveFacet = new XmlSchemaMinExclusiveFacet();
			XmlAttribute[] array = null;
			int num = 0;
			bool[] array2 = new bool[6];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaMinExclusiveFacet.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id149_value && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaMinExclusiveFacet.Value = base.Reader.Value;
					array2[4] = true;
				}
				else if (!array2[5] && (object)base.Reader.LocalName == id126_fixed && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaMinExclusiveFacet.IsFixed = XmlConvert.ToBoolean(base.Reader.Value);
					array2[5] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaMinExclusiveFacet.Namespaces == null)
					{
						xmlSchemaMinExclusiveFacet.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaMinExclusiveFacet.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaMinExclusiveFacet.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaMinExclusiveFacet.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaMinExclusiveFacet;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaMinExclusiveFacet.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[2] = true;
					}
					else
					{
						UnknownNode(xmlSchemaMinExclusiveFacet, "http://www.w3.org/2001/XMLSchema:annotation");
					}
				}
				else
				{
					UnknownNode(xmlSchemaMinExclusiveFacet, "http://www.w3.org/2001/XMLSchema:annotation");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaMinExclusiveFacet.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaMinExclusiveFacet;
		}

		private XmlSchemaWhiteSpaceFacet Read29_XmlSchemaWhiteSpaceFacet(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id151_XmlSchemaWhiteSpaceFacet || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaWhiteSpaceFacet xmlSchemaWhiteSpaceFacet = new XmlSchemaWhiteSpaceFacet();
			XmlAttribute[] array = null;
			int num = 0;
			bool[] array2 = new bool[6];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaWhiteSpaceFacet.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id149_value && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaWhiteSpaceFacet.Value = base.Reader.Value;
					array2[4] = true;
				}
				else if (!array2[5] && (object)base.Reader.LocalName == id126_fixed && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaWhiteSpaceFacet.IsFixed = XmlConvert.ToBoolean(base.Reader.Value);
					array2[5] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaWhiteSpaceFacet.Namespaces == null)
					{
						xmlSchemaWhiteSpaceFacet.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaWhiteSpaceFacet.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaWhiteSpaceFacet.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaWhiteSpaceFacet.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaWhiteSpaceFacet;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaWhiteSpaceFacet.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[2] = true;
					}
					else
					{
						UnknownNode(xmlSchemaWhiteSpaceFacet, "http://www.w3.org/2001/XMLSchema:annotation");
					}
				}
				else
				{
					UnknownNode(xmlSchemaWhiteSpaceFacet, "http://www.w3.org/2001/XMLSchema:annotation");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaWhiteSpaceFacet.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaWhiteSpaceFacet;
		}

		private XmlSchemaMaxExclusiveFacet Read28_XmlSchemaMaxExclusiveFacet(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id152_XmlSchemaMaxExclusiveFacet || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaMaxExclusiveFacet xmlSchemaMaxExclusiveFacet = new XmlSchemaMaxExclusiveFacet();
			XmlAttribute[] array = null;
			int num = 0;
			bool[] array2 = new bool[6];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaMaxExclusiveFacet.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id149_value && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaMaxExclusiveFacet.Value = base.Reader.Value;
					array2[4] = true;
				}
				else if (!array2[5] && (object)base.Reader.LocalName == id126_fixed && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaMaxExclusiveFacet.IsFixed = XmlConvert.ToBoolean(base.Reader.Value);
					array2[5] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaMaxExclusiveFacet.Namespaces == null)
					{
						xmlSchemaMaxExclusiveFacet.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaMaxExclusiveFacet.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaMaxExclusiveFacet.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaMaxExclusiveFacet.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaMaxExclusiveFacet;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaMaxExclusiveFacet.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[2] = true;
					}
					else
					{
						UnknownNode(xmlSchemaMaxExclusiveFacet, "http://www.w3.org/2001/XMLSchema:annotation");
					}
				}
				else
				{
					UnknownNode(xmlSchemaMaxExclusiveFacet, "http://www.w3.org/2001/XMLSchema:annotation");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaMaxExclusiveFacet.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaMaxExclusiveFacet;
		}

		private XmlSchemaMaxInclusiveFacet Read27_XmlSchemaMaxInclusiveFacet(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id153_XmlSchemaMaxInclusiveFacet || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaMaxInclusiveFacet xmlSchemaMaxInclusiveFacet = new XmlSchemaMaxInclusiveFacet();
			XmlAttribute[] array = null;
			int num = 0;
			bool[] array2 = new bool[6];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaMaxInclusiveFacet.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id149_value && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaMaxInclusiveFacet.Value = base.Reader.Value;
					array2[4] = true;
				}
				else if (!array2[5] && (object)base.Reader.LocalName == id126_fixed && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaMaxInclusiveFacet.IsFixed = XmlConvert.ToBoolean(base.Reader.Value);
					array2[5] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaMaxInclusiveFacet.Namespaces == null)
					{
						xmlSchemaMaxInclusiveFacet.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaMaxInclusiveFacet.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaMaxInclusiveFacet.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaMaxInclusiveFacet.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaMaxInclusiveFacet;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaMaxInclusiveFacet.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[2] = true;
					}
					else
					{
						UnknownNode(xmlSchemaMaxInclusiveFacet, "http://www.w3.org/2001/XMLSchema:annotation");
					}
				}
				else
				{
					UnknownNode(xmlSchemaMaxInclusiveFacet, "http://www.w3.org/2001/XMLSchema:annotation");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaMaxInclusiveFacet.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaMaxInclusiveFacet;
		}

		private XmlSchemaEnumerationFacet Read26_XmlSchemaEnumerationFacet(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id154_XmlSchemaEnumerationFacet || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaEnumerationFacet xmlSchemaEnumerationFacet = new XmlSchemaEnumerationFacet();
			XmlAttribute[] array = null;
			int num = 0;
			bool[] array2 = new bool[6];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaEnumerationFacet.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id149_value && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaEnumerationFacet.Value = base.Reader.Value;
					array2[4] = true;
				}
				else if (!array2[5] && (object)base.Reader.LocalName == id126_fixed && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaEnumerationFacet.IsFixed = XmlConvert.ToBoolean(base.Reader.Value);
					array2[5] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaEnumerationFacet.Namespaces == null)
					{
						xmlSchemaEnumerationFacet.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaEnumerationFacet.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaEnumerationFacet.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaEnumerationFacet.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaEnumerationFacet;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaEnumerationFacet.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[2] = true;
					}
					else
					{
						UnknownNode(xmlSchemaEnumerationFacet, "http://www.w3.org/2001/XMLSchema:annotation");
					}
				}
				else
				{
					UnknownNode(xmlSchemaEnumerationFacet, "http://www.w3.org/2001/XMLSchema:annotation");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaEnumerationFacet.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaEnumerationFacet;
		}

		private XmlSchemaPatternFacet Read25_XmlSchemaPatternFacet(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id155_XmlSchemaPatternFacet || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaPatternFacet xmlSchemaPatternFacet = new XmlSchemaPatternFacet();
			XmlAttribute[] array = null;
			int num = 0;
			bool[] array2 = new bool[6];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaPatternFacet.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id149_value && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaPatternFacet.Value = base.Reader.Value;
					array2[4] = true;
				}
				else if (!array2[5] && (object)base.Reader.LocalName == id126_fixed && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaPatternFacet.IsFixed = XmlConvert.ToBoolean(base.Reader.Value);
					array2[5] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaPatternFacet.Namespaces == null)
					{
						xmlSchemaPatternFacet.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaPatternFacet.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaPatternFacet.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaPatternFacet.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaPatternFacet;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaPatternFacet.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[2] = true;
					}
					else
					{
						UnknownNode(xmlSchemaPatternFacet, "http://www.w3.org/2001/XMLSchema:annotation");
					}
				}
				else
				{
					UnknownNode(xmlSchemaPatternFacet, "http://www.w3.org/2001/XMLSchema:annotation");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaPatternFacet.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaPatternFacet;
		}

		private XmlSchemaTotalDigitsFacet Read24_XmlSchemaTotalDigitsFacet(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id156_XmlSchemaTotalDigitsFacet || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaTotalDigitsFacet xmlSchemaTotalDigitsFacet = new XmlSchemaTotalDigitsFacet();
			XmlAttribute[] array = null;
			int num = 0;
			bool[] array2 = new bool[6];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaTotalDigitsFacet.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id149_value && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaTotalDigitsFacet.Value = base.Reader.Value;
					array2[4] = true;
				}
				else if (!array2[5] && (object)base.Reader.LocalName == id126_fixed && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaTotalDigitsFacet.IsFixed = XmlConvert.ToBoolean(base.Reader.Value);
					array2[5] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaTotalDigitsFacet.Namespaces == null)
					{
						xmlSchemaTotalDigitsFacet.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaTotalDigitsFacet.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaTotalDigitsFacet.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaTotalDigitsFacet.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaTotalDigitsFacet;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaTotalDigitsFacet.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[2] = true;
					}
					else
					{
						UnknownNode(xmlSchemaTotalDigitsFacet, "http://www.w3.org/2001/XMLSchema:annotation");
					}
				}
				else
				{
					UnknownNode(xmlSchemaTotalDigitsFacet, "http://www.w3.org/2001/XMLSchema:annotation");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaTotalDigitsFacet.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaTotalDigitsFacet;
		}

		private XmlSchemaLengthFacet Read23_XmlSchemaLengthFacet(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id157_XmlSchemaLengthFacet || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaLengthFacet xmlSchemaLengthFacet = new XmlSchemaLengthFacet();
			XmlAttribute[] array = null;
			int num = 0;
			bool[] array2 = new bool[6];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaLengthFacet.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id149_value && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaLengthFacet.Value = base.Reader.Value;
					array2[4] = true;
				}
				else if (!array2[5] && (object)base.Reader.LocalName == id126_fixed && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaLengthFacet.IsFixed = XmlConvert.ToBoolean(base.Reader.Value);
					array2[5] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaLengthFacet.Namespaces == null)
					{
						xmlSchemaLengthFacet.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaLengthFacet.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaLengthFacet.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaLengthFacet.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaLengthFacet;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaLengthFacet.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[2] = true;
					}
					else
					{
						UnknownNode(xmlSchemaLengthFacet, "http://www.w3.org/2001/XMLSchema:annotation");
					}
				}
				else
				{
					UnknownNode(xmlSchemaLengthFacet, "http://www.w3.org/2001/XMLSchema:annotation");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaLengthFacet.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaLengthFacet;
		}

		private XmlSchemaMaxLengthFacet Read22_XmlSchemaMaxLengthFacet(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id158_XmlSchemaMaxLengthFacet || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaMaxLengthFacet xmlSchemaMaxLengthFacet = new XmlSchemaMaxLengthFacet();
			XmlAttribute[] array = null;
			int num = 0;
			bool[] array2 = new bool[6];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaMaxLengthFacet.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id149_value && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaMaxLengthFacet.Value = base.Reader.Value;
					array2[4] = true;
				}
				else if (!array2[5] && (object)base.Reader.LocalName == id126_fixed && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaMaxLengthFacet.IsFixed = XmlConvert.ToBoolean(base.Reader.Value);
					array2[5] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaMaxLengthFacet.Namespaces == null)
					{
						xmlSchemaMaxLengthFacet.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaMaxLengthFacet.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaMaxLengthFacet.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaMaxLengthFacet.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaMaxLengthFacet;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaMaxLengthFacet.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[2] = true;
					}
					else
					{
						UnknownNode(xmlSchemaMaxLengthFacet, "http://www.w3.org/2001/XMLSchema:annotation");
					}
				}
				else
				{
					UnknownNode(xmlSchemaMaxLengthFacet, "http://www.w3.org/2001/XMLSchema:annotation");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaMaxLengthFacet.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaMaxLengthFacet;
		}

		private XmlSchemaMinInclusiveFacet Read21_XmlSchemaMinInclusiveFacet(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id159_XmlSchemaMinInclusiveFacet || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaMinInclusiveFacet xmlSchemaMinInclusiveFacet = new XmlSchemaMinInclusiveFacet();
			XmlAttribute[] array = null;
			int num = 0;
			bool[] array2 = new bool[6];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaMinInclusiveFacet.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id149_value && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaMinInclusiveFacet.Value = base.Reader.Value;
					array2[4] = true;
				}
				else if (!array2[5] && (object)base.Reader.LocalName == id126_fixed && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaMinInclusiveFacet.IsFixed = XmlConvert.ToBoolean(base.Reader.Value);
					array2[5] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaMinInclusiveFacet.Namespaces == null)
					{
						xmlSchemaMinInclusiveFacet.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaMinInclusiveFacet.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaMinInclusiveFacet.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaMinInclusiveFacet.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaMinInclusiveFacet;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaMinInclusiveFacet.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[2] = true;
					}
					else
					{
						UnknownNode(xmlSchemaMinInclusiveFacet, "http://www.w3.org/2001/XMLSchema:annotation");
					}
				}
				else
				{
					UnknownNode(xmlSchemaMinInclusiveFacet, "http://www.w3.org/2001/XMLSchema:annotation");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaMinInclusiveFacet.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaMinInclusiveFacet;
		}

		private XmlSchemaFractionDigitsFacet Read20_XmlSchemaFractionDigitsFacet(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id160_XmlSchemaFractionDigitsFacet || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaFractionDigitsFacet xmlSchemaFractionDigitsFacet = new XmlSchemaFractionDigitsFacet();
			XmlAttribute[] array = null;
			int num = 0;
			bool[] array2 = new bool[6];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaFractionDigitsFacet.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id149_value && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaFractionDigitsFacet.Value = base.Reader.Value;
					array2[4] = true;
				}
				else if (!array2[5] && (object)base.Reader.LocalName == id126_fixed && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaFractionDigitsFacet.IsFixed = XmlConvert.ToBoolean(base.Reader.Value);
					array2[5] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaFractionDigitsFacet.Namespaces == null)
					{
						xmlSchemaFractionDigitsFacet.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaFractionDigitsFacet.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaFractionDigitsFacet.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaFractionDigitsFacet.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaFractionDigitsFacet;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaFractionDigitsFacet.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[2] = true;
					}
					else
					{
						UnknownNode(xmlSchemaFractionDigitsFacet, "http://www.w3.org/2001/XMLSchema:annotation");
					}
				}
				else
				{
					UnknownNode(xmlSchemaFractionDigitsFacet, "http://www.w3.org/2001/XMLSchema:annotation");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaFractionDigitsFacet.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaFractionDigitsFacet;
		}

		private XmlSchemaSimpleTypeList Read17_XmlSchemaSimpleTypeList(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id161_XmlSchemaSimpleTypeList || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaSimpleTypeList xmlSchemaSimpleTypeList = new XmlSchemaSimpleTypeList();
			XmlAttribute[] array = null;
			int num = 0;
			bool[] array2 = new bool[6];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaSimpleTypeList.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id162_itemType && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaSimpleTypeList.ItemTypeName = ToXmlQualifiedName(base.Reader.Value);
					array2[4] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaSimpleTypeList.Namespaces == null)
					{
						xmlSchemaSimpleTypeList.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaSimpleTypeList.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaSimpleTypeList.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaSimpleTypeList.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaSimpleTypeList;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaSimpleTypeList.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[2] = true;
					}
					else if (!array2[5] && (object)base.Reader.LocalName == id105_simpleType && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaSimpleTypeList.ItemType = Read34_XmlSchemaSimpleType(isNullable: false, checkType: true);
						array2[5] = true;
					}
					else
					{
						UnknownNode(xmlSchemaSimpleTypeList, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:simpleType");
					}
				}
				else
				{
					UnknownNode(xmlSchemaSimpleTypeList, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:simpleType");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaSimpleTypeList.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaSimpleTypeList;
		}

		private XmlSchemaDerivationMethod Read7_XmlSchemaDerivationMethod(string s)
		{
			return (XmlSchemaDerivationMethod)XmlSerializationReader.ToEnum(s, XmlSchemaDerivationMethodValues, "global::System.Xml.Schema.XmlSchemaDerivationMethod");
		}

		private XmlSchemaUse Read35_XmlSchemaUse(string s)
		{
			return s switch
			{
				"optional" => XmlSchemaUse.Optional, 
				"prohibited" => XmlSchemaUse.Prohibited, 
				"required" => XmlSchemaUse.Required, 
				_ => throw CreateUnknownConstantException(s, typeof(XmlSchemaUse)), 
			};
		}

		private XmlSchemaForm Read6_XmlSchemaForm(string s)
		{
			return s switch
			{
				"qualified" => XmlSchemaForm.Qualified, 
				"unqualified" => XmlSchemaForm.Unqualified, 
				_ => throw CreateUnknownConstantException(s, typeof(XmlSchemaForm)), 
			};
		}

		private XmlSchemaElement Read52_XmlSchemaElement(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id163_XmlSchemaElement || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaElement xmlSchemaElement = new XmlSchemaElement();
			XmlAttribute[] array = null;
			int num = 0;
			XmlSchemaObjectCollection constraints = xmlSchemaElement.Constraints;
			bool[] array2 = new bool[19];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaElement.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id164_minOccurs && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaElement.MinOccursString = base.Reader.Value;
					array2[4] = true;
				}
				else if (!array2[5] && (object)base.Reader.LocalName == id165_maxOccurs && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaElement.MaxOccursString = base.Reader.Value;
					array2[5] = true;
				}
				else if (!array2[6] && (object)base.Reader.LocalName == id166_abstract && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaElement.IsAbstract = XmlConvert.ToBoolean(base.Reader.Value);
					array2[6] = true;
				}
				else if (!array2[7] && (object)base.Reader.LocalName == id167_block && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaElement.Block = Read7_XmlSchemaDerivationMethod(base.Reader.Value);
					array2[7] = true;
				}
				else if (!array2[8] && (object)base.Reader.LocalName == id125_default && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaElement.DefaultValue = base.Reader.Value;
					array2[8] = true;
				}
				else if (!array2[9] && (object)base.Reader.LocalName == id129_final && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaElement.Final = Read7_XmlSchemaDerivationMethod(base.Reader.Value);
					array2[9] = true;
				}
				else if (!array2[10] && (object)base.Reader.LocalName == id126_fixed && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaElement.FixedValue = base.Reader.Value;
					array2[10] = true;
				}
				else if (!array2[11] && (object)base.Reader.LocalName == id127_form && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaElement.Form = Read6_XmlSchemaForm(base.Reader.Value);
					array2[11] = true;
				}
				else if (!array2[12] && (object)base.Reader.LocalName == id4_name && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaElement.Name = base.Reader.Value;
					array2[12] = true;
				}
				else if (!array2[13] && (object)base.Reader.LocalName == id168_nillable && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaElement.IsNillable = XmlConvert.ToBoolean(base.Reader.Value);
					array2[13] = true;
				}
				else if (!array2[14] && (object)base.Reader.LocalName == id123_ref && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaElement.RefName = ToXmlQualifiedName(base.Reader.Value);
					array2[14] = true;
				}
				else if (!array2[15] && (object)base.Reader.LocalName == id169_substitutionGroup && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaElement.SubstitutionGroup = ToXmlQualifiedName(base.Reader.Value);
					array2[15] = true;
				}
				else if (!array2[16] && (object)base.Reader.LocalName == id27_type && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaElement.SchemaTypeName = ToXmlQualifiedName(base.Reader.Value);
					array2[16] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaElement.Namespaces == null)
					{
						xmlSchemaElement.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaElement.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaElement.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaElement.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaElement;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaElement.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[2] = true;
					}
					else if (!array2[17] && (object)base.Reader.LocalName == id105_simpleType && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaElement.SchemaType = Read34_XmlSchemaSimpleType(isNullable: false, checkType: true);
						array2[17] = true;
					}
					else if (!array2[17] && (object)base.Reader.LocalName == id106_complexType && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaElement.SchemaType = Read62_XmlSchemaComplexType(isNullable: false, checkType: true);
						array2[17] = true;
					}
					else if ((object)base.Reader.LocalName == id170_key && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (constraints == null)
						{
							base.Reader.Skip();
						}
						else
						{
							constraints.Add(Read49_XmlSchemaKey(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id171_unique && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (constraints == null)
						{
							base.Reader.Skip();
						}
						else
						{
							constraints.Add(Read50_XmlSchemaUnique(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id172_keyref && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (constraints == null)
						{
							base.Reader.Skip();
						}
						else
						{
							constraints.Add(Read51_XmlSchemaKeyref(isNullable: false, checkType: true));
						}
					}
					else
					{
						UnknownNode(xmlSchemaElement, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:simpleType, http://www.w3.org/2001/XMLSchema:complexType, http://www.w3.org/2001/XMLSchema:key, http://www.w3.org/2001/XMLSchema:unique, http://www.w3.org/2001/XMLSchema:keyref");
					}
				}
				else
				{
					UnknownNode(xmlSchemaElement, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:simpleType, http://www.w3.org/2001/XMLSchema:complexType, http://www.w3.org/2001/XMLSchema:key, http://www.w3.org/2001/XMLSchema:unique, http://www.w3.org/2001/XMLSchema:keyref");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaElement.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaElement;
		}

		private XmlSchemaKeyref Read51_XmlSchemaKeyref(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id173_XmlSchemaKeyref || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaKeyref xmlSchemaKeyref = new XmlSchemaKeyref();
			XmlAttribute[] array = null;
			int num = 0;
			XmlSchemaObjectCollection fields = xmlSchemaKeyref.Fields;
			bool[] array2 = new bool[8];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaKeyref.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id4_name && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaKeyref.Name = base.Reader.Value;
					array2[4] = true;
				}
				else if (!array2[7] && (object)base.Reader.LocalName == id174_refer && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaKeyref.Refer = ToXmlQualifiedName(base.Reader.Value);
					array2[7] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaKeyref.Namespaces == null)
					{
						xmlSchemaKeyref.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaKeyref.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaKeyref.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaKeyref.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaKeyref;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaKeyref.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[2] = true;
					}
					else if (!array2[5] && (object)base.Reader.LocalName == id175_selector && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaKeyref.Selector = Read47_XmlSchemaXPath(isNullable: false, checkType: true);
						array2[5] = true;
					}
					else if ((object)base.Reader.LocalName == id176_field && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (fields == null)
						{
							base.Reader.Skip();
						}
						else
						{
							fields.Add(Read47_XmlSchemaXPath(isNullable: false, checkType: true));
						}
					}
					else
					{
						UnknownNode(xmlSchemaKeyref, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:selector, http://www.w3.org/2001/XMLSchema:field");
					}
				}
				else
				{
					UnknownNode(xmlSchemaKeyref, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:selector, http://www.w3.org/2001/XMLSchema:field");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaKeyref.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaKeyref;
		}

		private XmlSchemaXPath Read47_XmlSchemaXPath(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id177_XmlSchemaXPath || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaXPath xmlSchemaXPath = new XmlSchemaXPath();
			XmlAttribute[] array = null;
			int num = 0;
			bool[] array2 = new bool[5];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaXPath.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id178_xpath && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaXPath.XPath = base.Reader.Value;
					array2[4] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaXPath.Namespaces == null)
					{
						xmlSchemaXPath.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaXPath.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaXPath.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaXPath.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaXPath;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaXPath.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[2] = true;
					}
					else
					{
						UnknownNode(xmlSchemaXPath, "http://www.w3.org/2001/XMLSchema:annotation");
					}
				}
				else
				{
					UnknownNode(xmlSchemaXPath, "http://www.w3.org/2001/XMLSchema:annotation");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaXPath.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaXPath;
		}

		private XmlSchemaUnique Read50_XmlSchemaUnique(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id179_XmlSchemaUnique || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaUnique xmlSchemaUnique = new XmlSchemaUnique();
			XmlAttribute[] array = null;
			int num = 0;
			XmlSchemaObjectCollection fields = xmlSchemaUnique.Fields;
			bool[] array2 = new bool[7];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaUnique.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id4_name && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaUnique.Name = base.Reader.Value;
					array2[4] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaUnique.Namespaces == null)
					{
						xmlSchemaUnique.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaUnique.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaUnique.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaUnique.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaUnique;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaUnique.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[2] = true;
					}
					else if (!array2[5] && (object)base.Reader.LocalName == id175_selector && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaUnique.Selector = Read47_XmlSchemaXPath(isNullable: false, checkType: true);
						array2[5] = true;
					}
					else if ((object)base.Reader.LocalName == id176_field && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (fields == null)
						{
							base.Reader.Skip();
						}
						else
						{
							fields.Add(Read47_XmlSchemaXPath(isNullable: false, checkType: true));
						}
					}
					else
					{
						UnknownNode(xmlSchemaUnique, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:selector, http://www.w3.org/2001/XMLSchema:field");
					}
				}
				else
				{
					UnknownNode(xmlSchemaUnique, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:selector, http://www.w3.org/2001/XMLSchema:field");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaUnique.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaUnique;
		}

		private XmlSchemaKey Read49_XmlSchemaKey(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id180_XmlSchemaKey || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaKey xmlSchemaKey = new XmlSchemaKey();
			XmlAttribute[] array = null;
			int num = 0;
			XmlSchemaObjectCollection fields = xmlSchemaKey.Fields;
			bool[] array2 = new bool[7];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaKey.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id4_name && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaKey.Name = base.Reader.Value;
					array2[4] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaKey.Namespaces == null)
					{
						xmlSchemaKey.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaKey.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaKey.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaKey.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaKey;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaKey.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[2] = true;
					}
					else if (!array2[5] && (object)base.Reader.LocalName == id175_selector && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaKey.Selector = Read47_XmlSchemaXPath(isNullable: false, checkType: true);
						array2[5] = true;
					}
					else if ((object)base.Reader.LocalName == id176_field && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (fields == null)
						{
							base.Reader.Skip();
						}
						else
						{
							fields.Add(Read47_XmlSchemaXPath(isNullable: false, checkType: true));
						}
					}
					else
					{
						UnknownNode(xmlSchemaKey, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:selector, http://www.w3.org/2001/XMLSchema:field");
					}
				}
				else
				{
					UnknownNode(xmlSchemaKey, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:selector, http://www.w3.org/2001/XMLSchema:field");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaKey.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaKey;
		}

		private XmlSchemaComplexType Read62_XmlSchemaComplexType(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id181_XmlSchemaComplexType || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaComplexType xmlSchemaComplexType = new XmlSchemaComplexType();
			XmlAttribute[] array = null;
			int num = 0;
			XmlSchemaObjectCollection attributes = xmlSchemaComplexType.Attributes;
			bool[] array2 = new bool[13];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaComplexType.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id4_name && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaComplexType.Name = base.Reader.Value;
					array2[4] = true;
				}
				else if (!array2[5] && (object)base.Reader.LocalName == id129_final && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaComplexType.Final = Read7_XmlSchemaDerivationMethod(base.Reader.Value);
					array2[5] = true;
				}
				else if (!array2[6] && (object)base.Reader.LocalName == id166_abstract && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaComplexType.IsAbstract = XmlConvert.ToBoolean(base.Reader.Value);
					array2[6] = true;
				}
				else if (!array2[7] && (object)base.Reader.LocalName == id167_block && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaComplexType.Block = Read7_XmlSchemaDerivationMethod(base.Reader.Value);
					array2[7] = true;
				}
				else if (!array2[8] && (object)base.Reader.LocalName == id182_mixed && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaComplexType.IsMixed = XmlConvert.ToBoolean(base.Reader.Value);
					array2[8] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaComplexType.Namespaces == null)
					{
						xmlSchemaComplexType.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaComplexType.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaComplexType.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaComplexType.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaComplexType;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaComplexType.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[2] = true;
					}
					else if (!array2[9] && (object)base.Reader.LocalName == id183_complexContent && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaComplexType.ContentModel = Read58_XmlSchemaComplexContent(isNullable: false, checkType: true);
						array2[9] = true;
					}
					else if (!array2[9] && (object)base.Reader.LocalName == id184_simpleContent && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaComplexType.ContentModel = Read61_XmlSchemaSimpleContent(isNullable: false, checkType: true);
						array2[9] = true;
					}
					else if (!array2[10] && (object)base.Reader.LocalName == id59_group && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaComplexType.Particle = Read44_XmlSchemaGroupRef(isNullable: false, checkType: true);
						array2[10] = true;
					}
					else if (!array2[10] && (object)base.Reader.LocalName == id185_sequence && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaComplexType.Particle = Read53_XmlSchemaSequence(isNullable: false, checkType: true);
						array2[10] = true;
					}
					else if (!array2[10] && (object)base.Reader.LocalName == id186_choice && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaComplexType.Particle = Read54_XmlSchemaChoice(isNullable: false, checkType: true);
						array2[10] = true;
					}
					else if (!array2[10] && (object)base.Reader.LocalName == id187_all && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaComplexType.Particle = Read55_XmlSchemaAll(isNullable: false, checkType: true);
						array2[10] = true;
					}
					else if ((object)base.Reader.LocalName == id109_attribute && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (attributes == null)
						{
							base.Reader.Skip();
						}
						else
						{
							attributes.Add(Read36_XmlSchemaAttribute(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id110_attributeGroup && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (attributes == null)
						{
							base.Reader.Skip();
						}
						else
						{
							attributes.Add(Read37_XmlSchemaAttributeGroupRef(isNullable: false, checkType: true));
						}
					}
					else if (!array2[12] && (object)base.Reader.LocalName == id112_anyAttribute && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaComplexType.AnyAttribute = Read39_XmlSchemaAnyAttribute(isNullable: false, checkType: true);
						array2[12] = true;
					}
					else
					{
						UnknownNode(xmlSchemaComplexType, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:complexContent, http://www.w3.org/2001/XMLSchema:simpleContent, http://www.w3.org/2001/XMLSchema:group, http://www.w3.org/2001/XMLSchema:sequence, http://www.w3.org/2001/XMLSchema:choice, http://www.w3.org/2001/XMLSchema:all, http://www.w3.org/2001/XMLSchema:attribute, http://www.w3.org/2001/XMLSchema:attributeGroup, http://www.w3.org/2001/XMLSchema:anyAttribute");
					}
				}
				else
				{
					UnknownNode(xmlSchemaComplexType, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:complexContent, http://www.w3.org/2001/XMLSchema:simpleContent, http://www.w3.org/2001/XMLSchema:group, http://www.w3.org/2001/XMLSchema:sequence, http://www.w3.org/2001/XMLSchema:choice, http://www.w3.org/2001/XMLSchema:all, http://www.w3.org/2001/XMLSchema:attribute, http://www.w3.org/2001/XMLSchema:attributeGroup, http://www.w3.org/2001/XMLSchema:anyAttribute");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaComplexType.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaComplexType;
		}

		private XmlSchemaAll Read55_XmlSchemaAll(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id188_XmlSchemaAll || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaAll xmlSchemaAll = new XmlSchemaAll();
			XmlAttribute[] array = null;
			int num = 0;
			XmlSchemaObjectCollection items = xmlSchemaAll.Items;
			bool[] array2 = new bool[7];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaAll.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id164_minOccurs && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaAll.MinOccursString = base.Reader.Value;
					array2[4] = true;
				}
				else if (!array2[5] && (object)base.Reader.LocalName == id165_maxOccurs && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaAll.MaxOccursString = base.Reader.Value;
					array2[5] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaAll.Namespaces == null)
					{
						xmlSchemaAll.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaAll.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaAll.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaAll.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaAll;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaAll.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[2] = true;
					}
					else if ((object)base.Reader.LocalName == id92_element && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (items == null)
						{
							base.Reader.Skip();
						}
						else
						{
							items.Add(Read52_XmlSchemaElement(isNullable: false, checkType: true));
						}
					}
					else
					{
						UnknownNode(xmlSchemaAll, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:element");
					}
				}
				else
				{
					UnknownNode(xmlSchemaAll, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:element");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaAll.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaAll;
		}

		private XmlSchemaChoice Read54_XmlSchemaChoice(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id189_XmlSchemaChoice || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaChoice xmlSchemaChoice = new XmlSchemaChoice();
			XmlAttribute[] array = null;
			int num = 0;
			XmlSchemaObjectCollection items = xmlSchemaChoice.Items;
			bool[] array2 = new bool[7];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaChoice.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id164_minOccurs && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaChoice.MinOccursString = base.Reader.Value;
					array2[4] = true;
				}
				else if (!array2[5] && (object)base.Reader.LocalName == id165_maxOccurs && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaChoice.MaxOccursString = base.Reader.Value;
					array2[5] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaChoice.Namespaces == null)
					{
						xmlSchemaChoice.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaChoice.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaChoice.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaChoice.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaChoice;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaChoice.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[2] = true;
					}
					else if ((object)base.Reader.LocalName == id190_any && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (items == null)
						{
							base.Reader.Skip();
						}
						else
						{
							items.Add(Read46_XmlSchemaAny(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id186_choice && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (items == null)
						{
							base.Reader.Skip();
						}
						else
						{
							items.Add(Read54_XmlSchemaChoice(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id185_sequence && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (items == null)
						{
							base.Reader.Skip();
						}
						else
						{
							items.Add(Read53_XmlSchemaSequence(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id92_element && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (items == null)
						{
							base.Reader.Skip();
						}
						else
						{
							items.Add(Read52_XmlSchemaElement(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id59_group && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (items == null)
						{
							base.Reader.Skip();
						}
						else
						{
							items.Add(Read44_XmlSchemaGroupRef(isNullable: false, checkType: true));
						}
					}
					else
					{
						UnknownNode(xmlSchemaChoice, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:any, http://www.w3.org/2001/XMLSchema:choice, http://www.w3.org/2001/XMLSchema:sequence, http://www.w3.org/2001/XMLSchema:element, http://www.w3.org/2001/XMLSchema:group");
					}
				}
				else
				{
					UnknownNode(xmlSchemaChoice, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:any, http://www.w3.org/2001/XMLSchema:choice, http://www.w3.org/2001/XMLSchema:sequence, http://www.w3.org/2001/XMLSchema:element, http://www.w3.org/2001/XMLSchema:group");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaChoice.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaChoice;
		}

		private XmlSchemaGroupRef Read44_XmlSchemaGroupRef(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id191_XmlSchemaGroupRef || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaGroupRef xmlSchemaGroupRef = new XmlSchemaGroupRef();
			XmlAttribute[] array = null;
			int num = 0;
			bool[] array2 = new bool[7];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaGroupRef.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id164_minOccurs && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaGroupRef.MinOccursString = base.Reader.Value;
					array2[4] = true;
				}
				else if (!array2[5] && (object)base.Reader.LocalName == id165_maxOccurs && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaGroupRef.MaxOccursString = base.Reader.Value;
					array2[5] = true;
				}
				else if (!array2[6] && (object)base.Reader.LocalName == id123_ref && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaGroupRef.RefName = ToXmlQualifiedName(base.Reader.Value);
					array2[6] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaGroupRef.Namespaces == null)
					{
						xmlSchemaGroupRef.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaGroupRef.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaGroupRef.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaGroupRef.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaGroupRef;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaGroupRef.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[2] = true;
					}
					else
					{
						UnknownNode(xmlSchemaGroupRef, "http://www.w3.org/2001/XMLSchema:annotation");
					}
				}
				else
				{
					UnknownNode(xmlSchemaGroupRef, "http://www.w3.org/2001/XMLSchema:annotation");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaGroupRef.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaGroupRef;
		}

		private XmlSchemaSequence Read53_XmlSchemaSequence(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id192_XmlSchemaSequence || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaSequence xmlSchemaSequence = new XmlSchemaSequence();
			XmlAttribute[] array = null;
			int num = 0;
			XmlSchemaObjectCollection items = xmlSchemaSequence.Items;
			bool[] array2 = new bool[7];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaSequence.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id164_minOccurs && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaSequence.MinOccursString = base.Reader.Value;
					array2[4] = true;
				}
				else if (!array2[5] && (object)base.Reader.LocalName == id165_maxOccurs && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaSequence.MaxOccursString = base.Reader.Value;
					array2[5] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaSequence.Namespaces == null)
					{
						xmlSchemaSequence.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaSequence.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaSequence.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaSequence.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaSequence;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaSequence.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[2] = true;
					}
					else if ((object)base.Reader.LocalName == id92_element && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (items == null)
						{
							base.Reader.Skip();
						}
						else
						{
							items.Add(Read52_XmlSchemaElement(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id185_sequence && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (items == null)
						{
							base.Reader.Skip();
						}
						else
						{
							items.Add(Read53_XmlSchemaSequence(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id190_any && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (items == null)
						{
							base.Reader.Skip();
						}
						else
						{
							items.Add(Read46_XmlSchemaAny(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id186_choice && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (items == null)
						{
							base.Reader.Skip();
						}
						else
						{
							items.Add(Read54_XmlSchemaChoice(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id59_group && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (items == null)
						{
							base.Reader.Skip();
						}
						else
						{
							items.Add(Read44_XmlSchemaGroupRef(isNullable: false, checkType: true));
						}
					}
					else
					{
						UnknownNode(xmlSchemaSequence, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:element, http://www.w3.org/2001/XMLSchema:sequence, http://www.w3.org/2001/XMLSchema:any, http://www.w3.org/2001/XMLSchema:choice, http://www.w3.org/2001/XMLSchema:group");
					}
				}
				else
				{
					UnknownNode(xmlSchemaSequence, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:element, http://www.w3.org/2001/XMLSchema:sequence, http://www.w3.org/2001/XMLSchema:any, http://www.w3.org/2001/XMLSchema:choice, http://www.w3.org/2001/XMLSchema:group");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaSequence.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaSequence;
		}

		private XmlSchemaAny Read46_XmlSchemaAny(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id193_XmlSchemaAny || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaAny xmlSchemaAny = new XmlSchemaAny();
			XmlAttribute[] array = null;
			int num = 0;
			bool[] array2 = new bool[8];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaAny.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id164_minOccurs && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaAny.MinOccursString = base.Reader.Value;
					array2[4] = true;
				}
				else if (!array2[5] && (object)base.Reader.LocalName == id165_maxOccurs && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaAny.MaxOccursString = base.Reader.Value;
					array2[5] = true;
				}
				else if (!array2[6] && (object)base.Reader.LocalName == id36_namespace && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaAny.Namespace = base.Reader.Value;
					array2[6] = true;
				}
				else if (!array2[7] && (object)base.Reader.LocalName == id114_processContents && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaAny.ProcessContents = Read38_XmlSchemaContentProcessing(base.Reader.Value);
					array2[7] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaAny.Namespaces == null)
					{
						xmlSchemaAny.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaAny.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaAny.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaAny.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaAny;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaAny.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[2] = true;
					}
					else
					{
						UnknownNode(xmlSchemaAny, "http://www.w3.org/2001/XMLSchema:annotation");
					}
				}
				else
				{
					UnknownNode(xmlSchemaAny, "http://www.w3.org/2001/XMLSchema:annotation");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaAny.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaAny;
		}

		private XmlSchemaSimpleContent Read61_XmlSchemaSimpleContent(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id194_XmlSchemaSimpleContent || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaSimpleContent xmlSchemaSimpleContent = new XmlSchemaSimpleContent();
			XmlAttribute[] array = null;
			int num = 0;
			bool[] array2 = new bool[5];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaSimpleContent.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaSimpleContent.Namespaces == null)
					{
						xmlSchemaSimpleContent.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaSimpleContent.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaSimpleContent.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaSimpleContent.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaSimpleContent;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaSimpleContent.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[2] = true;
					}
					else if (!array2[4] && (object)base.Reader.LocalName == id131_restriction && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaSimpleContent.Content = Read59_Item(isNullable: false, checkType: true);
						array2[4] = true;
					}
					else if (!array2[4] && (object)base.Reader.LocalName == id195_extension && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaSimpleContent.Content = Read60_Item(isNullable: false, checkType: true);
						array2[4] = true;
					}
					else
					{
						UnknownNode(xmlSchemaSimpleContent, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:restriction, http://www.w3.org/2001/XMLSchema:extension");
					}
				}
				else
				{
					UnknownNode(xmlSchemaSimpleContent, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:restriction, http://www.w3.org/2001/XMLSchema:extension");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaSimpleContent.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaSimpleContent;
		}

		private XmlSchemaSimpleContentExtension Read60_Item(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id196_Item || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaSimpleContentExtension xmlSchemaSimpleContentExtension = new XmlSchemaSimpleContentExtension();
			XmlAttribute[] array = null;
			int num = 0;
			XmlSchemaObjectCollection attributes = xmlSchemaSimpleContentExtension.Attributes;
			bool[] array2 = new bool[7];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaSimpleContentExtension.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id136_base && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaSimpleContentExtension.BaseTypeName = ToXmlQualifiedName(base.Reader.Value);
					array2[4] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaSimpleContentExtension.Namespaces == null)
					{
						xmlSchemaSimpleContentExtension.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaSimpleContentExtension.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaSimpleContentExtension.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaSimpleContentExtension.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaSimpleContentExtension;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaSimpleContentExtension.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[2] = true;
					}
					else if ((object)base.Reader.LocalName == id110_attributeGroup && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (attributes == null)
						{
							base.Reader.Skip();
						}
						else
						{
							attributes.Add(Read37_XmlSchemaAttributeGroupRef(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id109_attribute && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (attributes == null)
						{
							base.Reader.Skip();
						}
						else
						{
							attributes.Add(Read36_XmlSchemaAttribute(isNullable: false, checkType: true));
						}
					}
					else if (!array2[6] && (object)base.Reader.LocalName == id112_anyAttribute && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaSimpleContentExtension.AnyAttribute = Read39_XmlSchemaAnyAttribute(isNullable: false, checkType: true);
						array2[6] = true;
					}
					else
					{
						UnknownNode(xmlSchemaSimpleContentExtension, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:attributeGroup, http://www.w3.org/2001/XMLSchema:attribute, http://www.w3.org/2001/XMLSchema:anyAttribute");
					}
				}
				else
				{
					UnknownNode(xmlSchemaSimpleContentExtension, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:attributeGroup, http://www.w3.org/2001/XMLSchema:attribute, http://www.w3.org/2001/XMLSchema:anyAttribute");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaSimpleContentExtension.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaSimpleContentExtension;
		}

		private XmlSchemaSimpleContentRestriction Read59_Item(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id197_Item || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaSimpleContentRestriction xmlSchemaSimpleContentRestriction = new XmlSchemaSimpleContentRestriction();
			XmlAttribute[] array = null;
			int num = 0;
			XmlSchemaObjectCollection facets = xmlSchemaSimpleContentRestriction.Facets;
			XmlSchemaObjectCollection attributes = xmlSchemaSimpleContentRestriction.Attributes;
			bool[] array2 = new bool[9];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaSimpleContentRestriction.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id136_base && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaSimpleContentRestriction.BaseTypeName = ToXmlQualifiedName(base.Reader.Value);
					array2[4] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaSimpleContentRestriction.Namespaces == null)
					{
						xmlSchemaSimpleContentRestriction.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaSimpleContentRestriction.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaSimpleContentRestriction.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaSimpleContentRestriction.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaSimpleContentRestriction;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaSimpleContentRestriction.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[2] = true;
					}
					else if (!array2[5] && (object)base.Reader.LocalName == id105_simpleType && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaSimpleContentRestriction.BaseType = Read34_XmlSchemaSimpleType(isNullable: false, checkType: true);
						array2[5] = true;
					}
					else if ((object)base.Reader.LocalName == id138_minInclusive && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (facets == null)
						{
							base.Reader.Skip();
						}
						else
						{
							facets.Add(Read21_XmlSchemaMinInclusiveFacet(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id144_maxExclusive && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (facets == null)
						{
							base.Reader.Skip();
						}
						else
						{
							facets.Add(Read28_XmlSchemaMaxExclusiveFacet(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id145_whiteSpace && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (facets == null)
						{
							base.Reader.Skip();
						}
						else
						{
							facets.Add(Read29_XmlSchemaWhiteSpaceFacet(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id147_minLength && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (facets == null)
						{
							base.Reader.Skip();
						}
						else
						{
							facets.Add(Read31_XmlSchemaMinLengthFacet(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id62_pattern && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (facets == null)
						{
							base.Reader.Skip();
						}
						else
						{
							facets.Add(Read25_XmlSchemaPatternFacet(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id142_enumeration && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (facets == null)
						{
							base.Reader.Skip();
						}
						else
						{
							facets.Add(Read26_XmlSchemaEnumerationFacet(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id143_maxInclusive && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (facets == null)
						{
							base.Reader.Skip();
						}
						else
						{
							facets.Add(Read27_XmlSchemaMaxInclusiveFacet(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id140_length && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (facets == null)
						{
							base.Reader.Skip();
						}
						else
						{
							facets.Add(Read23_XmlSchemaLengthFacet(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id139_maxLength && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (facets == null)
						{
							base.Reader.Skip();
						}
						else
						{
							facets.Add(Read22_XmlSchemaMaxLengthFacet(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id146_minExclusive && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (facets == null)
						{
							base.Reader.Skip();
						}
						else
						{
							facets.Add(Read30_XmlSchemaMinExclusiveFacet(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id141_totalDigits && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (facets == null)
						{
							base.Reader.Skip();
						}
						else
						{
							facets.Add(Read24_XmlSchemaTotalDigitsFacet(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id137_fractionDigits && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (facets == null)
						{
							base.Reader.Skip();
						}
						else
						{
							facets.Add(Read20_XmlSchemaFractionDigitsFacet(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id110_attributeGroup && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (attributes == null)
						{
							base.Reader.Skip();
						}
						else
						{
							attributes.Add(Read37_XmlSchemaAttributeGroupRef(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id109_attribute && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (attributes == null)
						{
							base.Reader.Skip();
						}
						else
						{
							attributes.Add(Read36_XmlSchemaAttribute(isNullable: false, checkType: true));
						}
					}
					else if (!array2[8] && (object)base.Reader.LocalName == id112_anyAttribute && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaSimpleContentRestriction.AnyAttribute = Read39_XmlSchemaAnyAttribute(isNullable: false, checkType: true);
						array2[8] = true;
					}
					else
					{
						UnknownNode(xmlSchemaSimpleContentRestriction, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:simpleType, http://www.w3.org/2001/XMLSchema:minInclusive, http://www.w3.org/2001/XMLSchema:maxExclusive, http://www.w3.org/2001/XMLSchema:whiteSpace, http://www.w3.org/2001/XMLSchema:minLength, http://www.w3.org/2001/XMLSchema:pattern, http://www.w3.org/2001/XMLSchema:enumeration, http://www.w3.org/2001/XMLSchema:maxInclusive, http://www.w3.org/2001/XMLSchema:length, http://www.w3.org/2001/XMLSchema:maxLength, http://www.w3.org/2001/XMLSchema:minExclusive, http://www.w3.org/2001/XMLSchema:totalDigits, http://www.w3.org/2001/XMLSchema:fractionDigits, http://www.w3.org/2001/XMLSchema:attributeGroup, http://www.w3.org/2001/XMLSchema:attribute, http://www.w3.org/2001/XMLSchema:anyAttribute");
					}
				}
				else
				{
					UnknownNode(xmlSchemaSimpleContentRestriction, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:simpleType, http://www.w3.org/2001/XMLSchema:minInclusive, http://www.w3.org/2001/XMLSchema:maxExclusive, http://www.w3.org/2001/XMLSchema:whiteSpace, http://www.w3.org/2001/XMLSchema:minLength, http://www.w3.org/2001/XMLSchema:pattern, http://www.w3.org/2001/XMLSchema:enumeration, http://www.w3.org/2001/XMLSchema:maxInclusive, http://www.w3.org/2001/XMLSchema:length, http://www.w3.org/2001/XMLSchema:maxLength, http://www.w3.org/2001/XMLSchema:minExclusive, http://www.w3.org/2001/XMLSchema:totalDigits, http://www.w3.org/2001/XMLSchema:fractionDigits, http://www.w3.org/2001/XMLSchema:attributeGroup, http://www.w3.org/2001/XMLSchema:attribute, http://www.w3.org/2001/XMLSchema:anyAttribute");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaSimpleContentRestriction.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaSimpleContentRestriction;
		}

		private XmlSchemaComplexContent Read58_XmlSchemaComplexContent(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id198_XmlSchemaComplexContent || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaComplexContent xmlSchemaComplexContent = new XmlSchemaComplexContent();
			XmlAttribute[] array = null;
			int num = 0;
			bool[] array2 = new bool[6];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaComplexContent.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id182_mixed && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaComplexContent.IsMixed = XmlConvert.ToBoolean(base.Reader.Value);
					array2[4] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaComplexContent.Namespaces == null)
					{
						xmlSchemaComplexContent.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaComplexContent.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaComplexContent.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaComplexContent.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaComplexContent;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaComplexContent.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[2] = true;
					}
					else if (!array2[5] && (object)base.Reader.LocalName == id195_extension && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaComplexContent.Content = Read56_Item(isNullable: false, checkType: true);
						array2[5] = true;
					}
					else if (!array2[5] && (object)base.Reader.LocalName == id131_restriction && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaComplexContent.Content = Read57_Item(isNullable: false, checkType: true);
						array2[5] = true;
					}
					else
					{
						UnknownNode(xmlSchemaComplexContent, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:extension, http://www.w3.org/2001/XMLSchema:restriction");
					}
				}
				else
				{
					UnknownNode(xmlSchemaComplexContent, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:extension, http://www.w3.org/2001/XMLSchema:restriction");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaComplexContent.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaComplexContent;
		}

		private XmlSchemaComplexContentRestriction Read57_Item(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id199_Item || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaComplexContentRestriction xmlSchemaComplexContentRestriction = new XmlSchemaComplexContentRestriction();
			XmlAttribute[] array = null;
			int num = 0;
			XmlSchemaObjectCollection attributes = xmlSchemaComplexContentRestriction.Attributes;
			bool[] array2 = new bool[8];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaComplexContentRestriction.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id136_base && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaComplexContentRestriction.BaseTypeName = ToXmlQualifiedName(base.Reader.Value);
					array2[4] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaComplexContentRestriction.Namespaces == null)
					{
						xmlSchemaComplexContentRestriction.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaComplexContentRestriction.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaComplexContentRestriction.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaComplexContentRestriction.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaComplexContentRestriction;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaComplexContentRestriction.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[2] = true;
					}
					else if (!array2[5] && (object)base.Reader.LocalName == id186_choice && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaComplexContentRestriction.Particle = Read54_XmlSchemaChoice(isNullable: false, checkType: true);
						array2[5] = true;
					}
					else if (!array2[5] && (object)base.Reader.LocalName == id59_group && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaComplexContentRestriction.Particle = Read44_XmlSchemaGroupRef(isNullable: false, checkType: true);
						array2[5] = true;
					}
					else if (!array2[5] && (object)base.Reader.LocalName == id187_all && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaComplexContentRestriction.Particle = Read55_XmlSchemaAll(isNullable: false, checkType: true);
						array2[5] = true;
					}
					else if (!array2[5] && (object)base.Reader.LocalName == id185_sequence && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaComplexContentRestriction.Particle = Read53_XmlSchemaSequence(isNullable: false, checkType: true);
						array2[5] = true;
					}
					else if ((object)base.Reader.LocalName == id110_attributeGroup && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (attributes == null)
						{
							base.Reader.Skip();
						}
						else
						{
							attributes.Add(Read37_XmlSchemaAttributeGroupRef(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id109_attribute && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (attributes == null)
						{
							base.Reader.Skip();
						}
						else
						{
							attributes.Add(Read36_XmlSchemaAttribute(isNullable: false, checkType: true));
						}
					}
					else if (!array2[7] && (object)base.Reader.LocalName == id112_anyAttribute && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaComplexContentRestriction.AnyAttribute = Read39_XmlSchemaAnyAttribute(isNullable: false, checkType: true);
						array2[7] = true;
					}
					else
					{
						UnknownNode(xmlSchemaComplexContentRestriction, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:choice, http://www.w3.org/2001/XMLSchema:group, http://www.w3.org/2001/XMLSchema:all, http://www.w3.org/2001/XMLSchema:sequence, http://www.w3.org/2001/XMLSchema:attributeGroup, http://www.w3.org/2001/XMLSchema:attribute, http://www.w3.org/2001/XMLSchema:anyAttribute");
					}
				}
				else
				{
					UnknownNode(xmlSchemaComplexContentRestriction, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:choice, http://www.w3.org/2001/XMLSchema:group, http://www.w3.org/2001/XMLSchema:all, http://www.w3.org/2001/XMLSchema:sequence, http://www.w3.org/2001/XMLSchema:attributeGroup, http://www.w3.org/2001/XMLSchema:attribute, http://www.w3.org/2001/XMLSchema:anyAttribute");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaComplexContentRestriction.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaComplexContentRestriction;
		}

		private XmlSchemaComplexContentExtension Read56_Item(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id200_Item || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaComplexContentExtension xmlSchemaComplexContentExtension = new XmlSchemaComplexContentExtension();
			XmlAttribute[] array = null;
			int num = 0;
			XmlSchemaObjectCollection attributes = xmlSchemaComplexContentExtension.Attributes;
			bool[] array2 = new bool[8];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaComplexContentExtension.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id136_base && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaComplexContentExtension.BaseTypeName = ToXmlQualifiedName(base.Reader.Value);
					array2[4] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaComplexContentExtension.Namespaces == null)
					{
						xmlSchemaComplexContentExtension.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaComplexContentExtension.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaComplexContentExtension.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaComplexContentExtension.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaComplexContentExtension;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaComplexContentExtension.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[2] = true;
					}
					else if (!array2[5] && (object)base.Reader.LocalName == id59_group && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaComplexContentExtension.Particle = Read44_XmlSchemaGroupRef(isNullable: false, checkType: true);
						array2[5] = true;
					}
					else if (!array2[5] && (object)base.Reader.LocalName == id186_choice && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaComplexContentExtension.Particle = Read54_XmlSchemaChoice(isNullable: false, checkType: true);
						array2[5] = true;
					}
					else if (!array2[5] && (object)base.Reader.LocalName == id187_all && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaComplexContentExtension.Particle = Read55_XmlSchemaAll(isNullable: false, checkType: true);
						array2[5] = true;
					}
					else if (!array2[5] && (object)base.Reader.LocalName == id185_sequence && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaComplexContentExtension.Particle = Read53_XmlSchemaSequence(isNullable: false, checkType: true);
						array2[5] = true;
					}
					else if ((object)base.Reader.LocalName == id110_attributeGroup && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (attributes == null)
						{
							base.Reader.Skip();
						}
						else
						{
							attributes.Add(Read37_XmlSchemaAttributeGroupRef(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id109_attribute && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (attributes == null)
						{
							base.Reader.Skip();
						}
						else
						{
							attributes.Add(Read36_XmlSchemaAttribute(isNullable: false, checkType: true));
						}
					}
					else if (!array2[7] && (object)base.Reader.LocalName == id112_anyAttribute && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaComplexContentExtension.AnyAttribute = Read39_XmlSchemaAnyAttribute(isNullable: false, checkType: true);
						array2[7] = true;
					}
					else
					{
						UnknownNode(xmlSchemaComplexContentExtension, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:group, http://www.w3.org/2001/XMLSchema:choice, http://www.w3.org/2001/XMLSchema:all, http://www.w3.org/2001/XMLSchema:sequence, http://www.w3.org/2001/XMLSchema:attributeGroup, http://www.w3.org/2001/XMLSchema:attribute, http://www.w3.org/2001/XMLSchema:anyAttribute");
					}
				}
				else
				{
					UnknownNode(xmlSchemaComplexContentExtension, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:group, http://www.w3.org/2001/XMLSchema:choice, http://www.w3.org/2001/XMLSchema:all, http://www.w3.org/2001/XMLSchema:sequence, http://www.w3.org/2001/XMLSchema:attributeGroup, http://www.w3.org/2001/XMLSchema:attribute, http://www.w3.org/2001/XMLSchema:anyAttribute");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaComplexContentExtension.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaComplexContentExtension;
		}

		private XmlSchemaGroup Read63_XmlSchemaGroup(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id201_XmlSchemaGroup || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaGroup xmlSchemaGroup = new XmlSchemaGroup();
			XmlAttribute[] array = null;
			int num = 0;
			bool[] array2 = new bool[6];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaGroup.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id4_name && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaGroup.Name = base.Reader.Value;
					array2[4] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaGroup.Namespaces == null)
					{
						xmlSchemaGroup.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaGroup.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaGroup.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaGroup.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaGroup;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaGroup.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[2] = true;
					}
					else if (!array2[5] && (object)base.Reader.LocalName == id185_sequence && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaGroup.Particle = Read53_XmlSchemaSequence(isNullable: false, checkType: true);
						array2[5] = true;
					}
					else if (!array2[5] && (object)base.Reader.LocalName == id186_choice && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaGroup.Particle = Read54_XmlSchemaChoice(isNullable: false, checkType: true);
						array2[5] = true;
					}
					else if (!array2[5] && (object)base.Reader.LocalName == id187_all && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaGroup.Particle = Read55_XmlSchemaAll(isNullable: false, checkType: true);
						array2[5] = true;
					}
					else
					{
						UnknownNode(xmlSchemaGroup, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:sequence, http://www.w3.org/2001/XMLSchema:choice, http://www.w3.org/2001/XMLSchema:all");
					}
				}
				else
				{
					UnknownNode(xmlSchemaGroup, "http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:sequence, http://www.w3.org/2001/XMLSchema:choice, http://www.w3.org/2001/XMLSchema:all");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaGroup.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaGroup;
		}

		private XmlSchemaNotation Read65_XmlSchemaNotation(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id202_XmlSchemaNotation || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaNotation xmlSchemaNotation = new XmlSchemaNotation();
			XmlAttribute[] array = null;
			int num = 0;
			bool[] array2 = new bool[7];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaNotation.Id = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id4_name && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaNotation.Name = base.Reader.Value;
					array2[4] = true;
				}
				else if (!array2[5] && (object)base.Reader.LocalName == id203_public && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaNotation.Public = base.Reader.Value;
					array2[5] = true;
				}
				else if (!array2[6] && (object)base.Reader.LocalName == id204_system && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaNotation.System = base.Reader.Value;
					array2[6] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaNotation.Namespaces == null)
					{
						xmlSchemaNotation.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaNotation.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaNotation.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaNotation.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaNotation;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[2] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaNotation.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[2] = true;
					}
					else
					{
						UnknownNode(xmlSchemaNotation, "http://www.w3.org/2001/XMLSchema:annotation");
					}
				}
				else
				{
					UnknownNode(xmlSchemaNotation, "http://www.w3.org/2001/XMLSchema:annotation");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaNotation.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaNotation;
		}

		private XmlSchemaRedefine Read64_XmlSchemaRedefine(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id205_XmlSchemaRedefine || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaRedefine xmlSchemaRedefine = new XmlSchemaRedefine();
			XmlAttribute[] array = null;
			int num = 0;
			XmlSchemaObjectCollection items = xmlSchemaRedefine.Items;
			bool[] array2 = new bool[5];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id206_schemaLocation && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaRedefine.SchemaLocation = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[2] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaRedefine.Id = CollapseWhitespace(base.Reader.Value);
					array2[2] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaRedefine.Namespaces == null)
					{
						xmlSchemaRedefine.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaRedefine.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaRedefine.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaRedefine.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaRedefine;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if ((object)base.Reader.LocalName == id110_attributeGroup && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (items == null)
						{
							base.Reader.Skip();
						}
						else
						{
							items.Add(Read40_XmlSchemaAttributeGroup(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id106_complexType && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (items == null)
						{
							base.Reader.Skip();
						}
						else
						{
							items.Add(Read62_XmlSchemaComplexType(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id105_simpleType && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (items == null)
						{
							base.Reader.Skip();
						}
						else
						{
							items.Add(Read34_XmlSchemaSimpleType(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (items == null)
						{
							base.Reader.Skip();
						}
						else
						{
							items.Add(Read11_XmlSchemaAnnotation(isNullable: false, checkType: true));
						}
					}
					else if ((object)base.Reader.LocalName == id59_group && (object)base.Reader.NamespaceURI == id95_Item)
					{
						if (items == null)
						{
							base.Reader.Skip();
						}
						else
						{
							items.Add(Read63_XmlSchemaGroup(isNullable: false, checkType: true));
						}
					}
					else
					{
						UnknownNode(xmlSchemaRedefine, "http://www.w3.org/2001/XMLSchema:attributeGroup, http://www.w3.org/2001/XMLSchema:complexType, http://www.w3.org/2001/XMLSchema:simpleType, http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:group");
					}
				}
				else
				{
					UnknownNode(xmlSchemaRedefine, "http://www.w3.org/2001/XMLSchema:attributeGroup, http://www.w3.org/2001/XMLSchema:complexType, http://www.w3.org/2001/XMLSchema:simpleType, http://www.w3.org/2001/XMLSchema:annotation, http://www.w3.org/2001/XMLSchema:group");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaRedefine.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaRedefine;
		}

		private XmlSchemaImport Read13_XmlSchemaImport(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id207_XmlSchemaImport || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaImport xmlSchemaImport = new XmlSchemaImport();
			XmlAttribute[] array = null;
			int num = 0;
			bool[] array2 = new bool[6];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id206_schemaLocation && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaImport.SchemaLocation = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[2] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaImport.Id = CollapseWhitespace(base.Reader.Value);
					array2[2] = true;
				}
				else if (!array2[4] && (object)base.Reader.LocalName == id36_namespace && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaImport.Namespace = CollapseWhitespace(base.Reader.Value);
					array2[4] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaImport.Namespaces == null)
					{
						xmlSchemaImport.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaImport.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaImport.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaImport.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaImport;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[5] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaImport.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[5] = true;
					}
					else
					{
						UnknownNode(xmlSchemaImport, "http://www.w3.org/2001/XMLSchema:annotation");
					}
				}
				else
				{
					UnknownNode(xmlSchemaImport, "http://www.w3.org/2001/XMLSchema:annotation");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaImport.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaImport;
		}

		private XmlSchemaInclude Read12_XmlSchemaInclude(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id208_XmlSchemaInclude || (object)xmlQualifiedName.Namespace != id95_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			base.DecodeName = false;
			XmlSchemaInclude xmlSchemaInclude = new XmlSchemaInclude();
			XmlAttribute[] array = null;
			int num = 0;
			bool[] array2 = new bool[5];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[1] && (object)base.Reader.LocalName == id206_schemaLocation && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaInclude.SchemaLocation = CollapseWhitespace(base.Reader.Value);
					array2[1] = true;
				}
				else if (!array2[2] && (object)base.Reader.LocalName == id102_id && (object)base.Reader.NamespaceURI == id5_Item)
				{
					xmlSchemaInclude.Id = CollapseWhitespace(base.Reader.Value);
					array2[2] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (xmlSchemaInclude.Namespaces == null)
					{
						xmlSchemaInclude.Namespaces = new XmlSerializerNamespaces();
					}
					xmlSchemaInclude.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			xmlSchemaInclude.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				xmlSchemaInclude.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return xmlSchemaInclude;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[4] && (object)base.Reader.LocalName == id107_annotation && (object)base.Reader.NamespaceURI == id95_Item)
					{
						xmlSchemaInclude.Annotation = Read11_XmlSchemaAnnotation(isNullable: false, checkType: true);
						array2[4] = true;
					}
					else
					{
						UnknownNode(xmlSchemaInclude, "http://www.w3.org/2001/XMLSchema:annotation");
					}
				}
				else
				{
					UnknownNode(xmlSchemaInclude, "http://www.w3.org/2001/XMLSchema:annotation");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			xmlSchemaInclude.UnhandledAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return xmlSchemaInclude;
		}

		private Import Read4_Import(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id209_Import || (object)xmlQualifiedName.Namespace != id2_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			Import import = new Import();
			XmlAttribute[] array = null;
			int num = 0;
			ServiceDescriptionFormatExtensionCollection extensions = import.Extensions;
			bool[] array2 = new bool[6];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!array2[4] && (object)base.Reader.LocalName == id36_namespace && (object)base.Reader.NamespaceURI == id5_Item)
				{
					import.Namespace = base.Reader.Value;
					array2[4] = true;
				}
				else if (!array2[5] && (object)base.Reader.LocalName == id23_location && (object)base.Reader.NamespaceURI == id5_Item)
				{
					import.Location = base.Reader.Value;
					array2[5] = true;
				}
				else if (IsXmlnsAttribute(base.Reader.Name))
				{
					if (import.Namespaces == null)
					{
						import.Namespaces = new XmlSerializerNamespaces();
					}
					import.Namespaces.Add((base.Reader.Name.Length == 5) ? "" : base.Reader.LocalName, base.Reader.Value);
				}
				else
				{
					XmlAttribute xmlAttribute = (XmlAttribute)base.Document.ReadNode(base.Reader);
					ParseWsdlArrayType(xmlAttribute);
					array = (XmlAttribute[])EnsureArrayIndex(array, num, typeof(XmlAttribute));
					array[num++] = xmlAttribute;
				}
			}
			import.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				import.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
				return import;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array2[0] && (object)base.Reader.LocalName == id7_documentation && (object)base.Reader.NamespaceURI == id2_Item)
					{
						import.DocumentationElement = (XmlElement)ReadXmlNode(wrapped: false);
						array2[0] = true;
					}
					else
					{
						extensions.Add((XmlElement)ReadXmlNode(wrapped: false));
					}
				}
				else
				{
					UnknownNode(import, "http://schemas.xmlsoap.org/wsdl/:documentation");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			import.ExtensibleAttributes = (XmlAttribute[])ShrinkArray(array, num, typeof(XmlAttribute), isNullable: true);
			ReadEndElement();
			return import;
		}

		protected override void InitCallbacks()
		{
		}

		protected override void InitIDs()
		{
			id133_XmlSchemaSimpleTypeUnion = base.Reader.NameTable.Add("XmlSchemaSimpleTypeUnion");
			id143_maxInclusive = base.Reader.NameTable.Add("maxInclusive");
			id46_body = base.Reader.NameTable.Add("body");
			id190_any = base.Reader.NameTable.Add("any");
			id88_OperationOutput = base.Reader.NameTable.Add("OperationOutput");
			id6_targetNamespace = base.Reader.NameTable.Add("targetNamespace");
			id158_XmlSchemaMaxLengthFacet = base.Reader.NameTable.Add("XmlSchemaMaxLengthFacet");
			id11_portType = base.Reader.NameTable.Add("portType");
			id182_mixed = base.Reader.NameTable.Add("mixed");
			id172_keyref = base.Reader.NameTable.Add("keyref");
			id187_all = base.Reader.NameTable.Add("all");
			id162_itemType = base.Reader.NameTable.Add("itemType");
			id68_InputBinding = base.Reader.NameTable.Add("InputBinding");
			id25_HttpAddressBinding = base.Reader.NameTable.Add("HttpAddressBinding");
			id82_HttpBinding = base.Reader.NameTable.Add("HttpBinding");
			id17_address = base.Reader.NameTable.Add("address");
			id3_ServiceDescription = base.Reader.NameTable.Add("ServiceDescription");
			id38_SoapFaultBinding = base.Reader.NameTable.Add("SoapFaultBinding");
			id123_ref = base.Reader.NameTable.Add("ref");
			id198_XmlSchemaComplexContent = base.Reader.NameTable.Add("XmlSchemaComplexContent");
			id53_parts = base.Reader.NameTable.Add("parts");
			id35_use = base.Reader.NameTable.Add("use");
			id157_XmlSchemaLengthFacet = base.Reader.NameTable.Add("XmlSchemaLengthFacet");
			id207_XmlSchemaImport = base.Reader.NameTable.Add("XmlSchemaImport");
			id44_text = base.Reader.NameTable.Add("text");
			id117_XmlSchemaAppInfo = base.Reader.NameTable.Add("XmlSchemaAppInfo");
			id203_public = base.Reader.NameTable.Add("public");
			id69_urlEncoded = base.Reader.NameTable.Add("urlEncoded");
			id7_documentation = base.Reader.NameTable.Add("documentation");
			id19_Item = base.Reader.NameTable.Add("http://schemas.xmlsoap.org/wsdl/soap/");
			id129_final = base.Reader.NameTable.Add("final");
			id163_XmlSchemaElement = base.Reader.NameTable.Add("XmlSchemaElement");
			id60_capture = base.Reader.NameTable.Add("capture");
			id37_encodingStyle = base.Reader.NameTable.Add("encodingStyle");
			id185_sequence = base.Reader.NameTable.Add("sequence");
			id166_abstract = base.Reader.NameTable.Add("abstract");
			id23_location = base.Reader.NameTable.Add("location");
			id111_XmlSchemaAttributeGroup = base.Reader.NameTable.Add("XmlSchemaAttributeGroup");
			id192_XmlSchemaSequence = base.Reader.NameTable.Add("XmlSchemaSequence");
			id33_FaultBinding = base.Reader.NameTable.Add("FaultBinding");
			id153_XmlSchemaMaxInclusiveFacet = base.Reader.NameTable.Add("XmlSchemaMaxInclusiveFacet");
			id201_XmlSchemaGroup = base.Reader.NameTable.Add("XmlSchemaGroup");
			id43_multipartRelated = base.Reader.NameTable.Add("multipartRelated");
			id168_nillable = base.Reader.NameTable.Add("nillable");
			id149_value = base.Reader.NameTable.Add("value");
			id64_MimeMultipartRelatedBinding = base.Reader.NameTable.Add("MimeMultipartRelatedBinding");
			id193_XmlSchemaAny = base.Reader.NameTable.Add("XmlSchemaAny");
			id191_XmlSchemaGroupRef = base.Reader.NameTable.Add("XmlSchemaGroupRef");
			id74_soapAction = base.Reader.NameTable.Add("soapAction");
			id63_ignoreCase = base.Reader.NameTable.Add("ignoreCase");
			id101_version = base.Reader.NameTable.Add("version");
			id47_header = base.Reader.NameTable.Add("header");
			id195_extension = base.Reader.NameTable.Add("extension");
			id48_Soap12HeaderBinding = base.Reader.NameTable.Add("Soap12HeaderBinding");
			id134_memberTypes = base.Reader.NameTable.Add("memberTypes");
			id121_Item = base.Reader.NameTable.Add("http://www.w3.org/XML/1998/namespace");
			id146_minExclusive = base.Reader.NameTable.Add("minExclusive");
			id84_PortType = base.Reader.NameTable.Add("PortType");
			id42_mimeXml = base.Reader.NameTable.Add("mimeXml");
			id138_minInclusive = base.Reader.NameTable.Add("minInclusive");
			id118_source = base.Reader.NameTable.Add("source");
			id73_Soap12OperationBinding = base.Reader.NameTable.Add("Soap12OperationBinding");
			id131_restriction = base.Reader.NameTable.Add("restriction");
			id152_XmlSchemaMaxExclusiveFacet = base.Reader.NameTable.Add("XmlSchemaMaxExclusiveFacet");
			id135_XmlSchemaSimpleTypeRestriction = base.Reader.NameTable.Add("XmlSchemaSimpleTypeRestriction");
			id188_XmlSchemaAll = base.Reader.NameTable.Add("XmlSchemaAll");
			id116_appinfo = base.Reader.NameTable.Add("appinfo");
			id86_parameterOrder = base.Reader.NameTable.Add("parameterOrder");
			id147_minLength = base.Reader.NameTable.Add("minLength");
			id78_HttpOperationBinding = base.Reader.NameTable.Add("HttpOperationBinding");
			id161_XmlSchemaSimpleTypeList = base.Reader.NameTable.Add("XmlSchemaSimpleTypeList");
			id205_XmlSchemaRedefine = base.Reader.NameTable.Add("XmlSchemaRedefine");
			id194_XmlSchemaSimpleContent = base.Reader.NameTable.Add("XmlSchemaSimpleContent");
			id91_MessagePart = base.Reader.NameTable.Add("MessagePart");
			id92_element = base.Reader.NameTable.Add("element");
			id114_processContents = base.Reader.NameTable.Add("processContents");
			id18_Item = base.Reader.NameTable.Add("http://schemas.xmlsoap.org/wsdl/http/");
			id50_headerfault = base.Reader.NameTable.Add("headerfault");
			id154_XmlSchemaEnumerationFacet = base.Reader.NameTable.Add("XmlSchemaEnumerationFacet");
			id96_XmlSchema = base.Reader.NameTable.Add("XmlSchema");
			id127_form = base.Reader.NameTable.Add("form");
			id176_field = base.Reader.NameTable.Add("field");
			id49_part = base.Reader.NameTable.Add("part");
			id5_Item = base.Reader.NameTable.Add("");
			id57_match = base.Reader.NameTable.Add("match");
			id52_Soap12BodyBinding = base.Reader.NameTable.Add("Soap12BodyBinding");
			id104_redefine = base.Reader.NameTable.Add("redefine");
			id20_Item = base.Reader.NameTable.Add("http://schemas.xmlsoap.org/wsdl/soap12/");
			id21_Soap12AddressBinding = base.Reader.NameTable.Add("Soap12AddressBinding");
			id142_enumeration = base.Reader.NameTable.Add("enumeration");
			id24_SoapAddressBinding = base.Reader.NameTable.Add("SoapAddressBinding");
			id103_include = base.Reader.NameTable.Add("include");
			id139_maxLength = base.Reader.NameTable.Add("maxLength");
			id165_maxOccurs = base.Reader.NameTable.Add("maxOccurs");
			id65_MimePart = base.Reader.NameTable.Add("MimePart");
			id102_id = base.Reader.NameTable.Add("id");
			id196_Item = base.Reader.NameTable.Add("XmlSchemaSimpleContentExtension");
			id140_length = base.Reader.NameTable.Add("length");
			id27_type = base.Reader.NameTable.Add("type");
			id106_complexType = base.Reader.NameTable.Add("complexType");
			id31_output = base.Reader.NameTable.Add("output");
			id1_definitions = base.Reader.NameTable.Add("definitions");
			id4_name = base.Reader.NameTable.Add("name");
			id132_union = base.Reader.NameTable.Add("union");
			id29_OperationBinding = base.Reader.NameTable.Add("OperationBinding");
			id170_key = base.Reader.NameTable.Add("key");
			id45_Item = base.Reader.NameTable.Add("http://microsoft.com/wsdl/mime/textMatching/");
			id95_Item = base.Reader.NameTable.Add("http://www.w3.org/2001/XMLSchema");
			id169_substitutionGroup = base.Reader.NameTable.Add("substitutionGroup");
			id178_xpath = base.Reader.NameTable.Add("xpath");
			id9_types = base.Reader.NameTable.Add("types");
			id97_attributeFormDefault = base.Reader.NameTable.Add("attributeFormDefault");
			id62_pattern = base.Reader.NameTable.Add("pattern");
			id58_MimeTextMatch = base.Reader.NameTable.Add("MimeTextMatch");
			id180_XmlSchemaKey = base.Reader.NameTable.Add("XmlSchemaKey");
			id10_message = base.Reader.NameTable.Add("message");
			id8_import = base.Reader.NameTable.Add("import");
			id148_XmlSchemaMinLengthFacet = base.Reader.NameTable.Add("XmlSchemaMinLengthFacet");
			id105_simpleType = base.Reader.NameTable.Add("simpleType");
			id181_XmlSchemaComplexType = base.Reader.NameTable.Add("XmlSchemaComplexType");
			id164_minOccurs = base.Reader.NameTable.Add("minOccurs");
			id144_maxExclusive = base.Reader.NameTable.Add("maxExclusive");
			id160_XmlSchemaFractionDigitsFacet = base.Reader.NameTable.Add("XmlSchemaFractionDigitsFacet");
			id124_XmlSchemaAttribute = base.Reader.NameTable.Add("XmlSchemaAttribute");
			id209_Import = base.Reader.NameTable.Add("Import");
			id206_schemaLocation = base.Reader.NameTable.Add("schemaLocation");
			id179_XmlSchemaUnique = base.Reader.NameTable.Add("XmlSchemaUnique");
			id75_style = base.Reader.NameTable.Add("style");
			id119_XmlSchemaDocumentation = base.Reader.NameTable.Add("XmlSchemaDocumentation");
			id136_base = base.Reader.NameTable.Add("base");
			id66_MimeXmlBinding = base.Reader.NameTable.Add("MimeXmlBinding");
			id30_input = base.Reader.NameTable.Add("input");
			id40_content = base.Reader.NameTable.Add("content");
			id93_Types = base.Reader.NameTable.Add("Types");
			id94_schema = base.Reader.NameTable.Add("schema");
			id200_Item = base.Reader.NameTable.Add("XmlSchemaComplexContentExtension");
			id67_MimeContentBinding = base.Reader.NameTable.Add("MimeContentBinding");
			id59_group = base.Reader.NameTable.Add("group");
			id32_fault = base.Reader.NameTable.Add("fault");
			id80_transport = base.Reader.NameTable.Add("transport");
			id98_blockDefault = base.Reader.NameTable.Add("blockDefault");
			id13_service = base.Reader.NameTable.Add("service");
			id54_SoapHeaderBinding = base.Reader.NameTable.Add("SoapHeaderBinding");
			id204_system = base.Reader.NameTable.Add("system");
			id16_Port = base.Reader.NameTable.Add("Port");
			id108_notation = base.Reader.NameTable.Add("notation");
			id186_choice = base.Reader.NameTable.Add("choice");
			id110_attributeGroup = base.Reader.NameTable.Add("attributeGroup");
			id79_Soap12Binding = base.Reader.NameTable.Add("Soap12Binding");
			id77_SoapOperationBinding = base.Reader.NameTable.Add("SoapOperationBinding");
			id115_XmlSchemaAnnotation = base.Reader.NameTable.Add("XmlSchemaAnnotation");
			id83_verb = base.Reader.NameTable.Add("verb");
			id72_HttpUrlEncodedBinding = base.Reader.NameTable.Add("HttpUrlEncodedBinding");
			id39_OutputBinding = base.Reader.NameTable.Add("OutputBinding");
			id183_complexContent = base.Reader.NameTable.Add("complexContent");
			id202_XmlSchemaNotation = base.Reader.NameTable.Add("XmlSchemaNotation");
			id81_SoapBinding = base.Reader.NameTable.Add("SoapBinding");
			id199_Item = base.Reader.NameTable.Add("XmlSchemaComplexContentRestriction");
			id28_operation = base.Reader.NameTable.Add("operation");
			id122_XmlSchemaAttributeGroupRef = base.Reader.NameTable.Add("XmlSchemaAttributeGroupRef");
			id155_XmlSchemaPatternFacet = base.Reader.NameTable.Add("XmlSchemaPatternFacet");
			id76_soapActionRequired = base.Reader.NameTable.Add("soapActionRequired");
			id90_Message = base.Reader.NameTable.Add("Message");
			id159_XmlSchemaMinInclusiveFacet = base.Reader.NameTable.Add("XmlSchemaMinInclusiveFacet");
			id208_XmlSchemaInclude = base.Reader.NameTable.Add("XmlSchemaInclude");
			id85_Operation = base.Reader.NameTable.Add("Operation");
			id130_list = base.Reader.NameTable.Add("list");
			id14_Service = base.Reader.NameTable.Add("Service");
			id22_required = base.Reader.NameTable.Add("required");
			id174_refer = base.Reader.NameTable.Add("refer");
			id71_HttpUrlReplacementBinding = base.Reader.NameTable.Add("HttpUrlReplacementBinding");
			id56_MimeTextBinding = base.Reader.NameTable.Add("MimeTextBinding");
			id87_OperationFault = base.Reader.NameTable.Add("OperationFault");
			id125_default = base.Reader.NameTable.Add("default");
			id15_port = base.Reader.NameTable.Add("port");
			id51_SoapHeaderFaultBinding = base.Reader.NameTable.Add("SoapHeaderFaultBinding");
			id128_XmlSchemaSimpleType = base.Reader.NameTable.Add("XmlSchemaSimpleType");
			id36_namespace = base.Reader.NameTable.Add("namespace");
			id175_selector = base.Reader.NameTable.Add("selector");
			id150_XmlSchemaMinExclusiveFacet = base.Reader.NameTable.Add("XmlSchemaMinExclusiveFacet");
			id100_elementFormDefault = base.Reader.NameTable.Add("elementFormDefault");
			id26_Binding = base.Reader.NameTable.Add("Binding");
			id197_Item = base.Reader.NameTable.Add("XmlSchemaSimpleContentRestriction");
			id126_fixed = base.Reader.NameTable.Add("fixed");
			id107_annotation = base.Reader.NameTable.Add("annotation");
			id99_finalDefault = base.Reader.NameTable.Add("finalDefault");
			id137_fractionDigits = base.Reader.NameTable.Add("fractionDigits");
			id70_urlReplacement = base.Reader.NameTable.Add("urlReplacement");
			id189_XmlSchemaChoice = base.Reader.NameTable.Add("XmlSchemaChoice");
			id2_Item = base.Reader.NameTable.Add("http://schemas.xmlsoap.org/wsdl/");
			id112_anyAttribute = base.Reader.NameTable.Add("anyAttribute");
			id89_OperationInput = base.Reader.NameTable.Add("OperationInput");
			id141_totalDigits = base.Reader.NameTable.Add("totalDigits");
			id61_repeats = base.Reader.NameTable.Add("repeats");
			id184_simpleContent = base.Reader.NameTable.Add("simpleContent");
			id55_SoapBodyBinding = base.Reader.NameTable.Add("SoapBodyBinding");
			id145_whiteSpace = base.Reader.NameTable.Add("whiteSpace");
			id167_block = base.Reader.NameTable.Add("block");
			id151_XmlSchemaWhiteSpaceFacet = base.Reader.NameTable.Add("XmlSchemaWhiteSpaceFacet");
			id12_binding = base.Reader.NameTable.Add("binding");
			id109_attribute = base.Reader.NameTable.Add("attribute");
			id171_unique = base.Reader.NameTable.Add("unique");
			id120_lang = base.Reader.NameTable.Add("lang");
			id173_XmlSchemaKeyref = base.Reader.NameTable.Add("XmlSchemaKeyref");
			id177_XmlSchemaXPath = base.Reader.NameTable.Add("XmlSchemaXPath");
			id34_Soap12FaultBinding = base.Reader.NameTable.Add("Soap12FaultBinding");
			id41_Item = base.Reader.NameTable.Add("http://schemas.xmlsoap.org/wsdl/mime/");
			id156_XmlSchemaTotalDigitsFacet = base.Reader.NameTable.Add("XmlSchemaTotalDigitsFacet");
			id113_XmlSchemaAnyAttribute = base.Reader.NameTable.Add("XmlSchemaAnyAttribute");
		}
	}
	[XmlFormatExtension("binding", "http://schemas.xmlsoap.org/wsdl/soap/", typeof(Binding))]
	[XmlFormatExtensionPrefix("soapenc", "http://schemas.xmlsoap.org/soap/encoding/")]
	[XmlFormatExtensionPrefix("soap", "http://schemas.xmlsoap.org/wsdl/soap/")]
	public class SoapBinding : ServiceDescriptionFormatExtension
	{
		public const string Namespace = "http://schemas.xmlsoap.org/wsdl/soap/";

		public const string HttpTransport = "http://schemas.xmlsoap.org/soap/http";

		private SoapBindingStyle style = SoapBindingStyle.Document;

		private string transport;

		private static XmlSchema schema;

		[XmlAttribute("transport")]
		public string Transport
		{
			get
			{
				if (transport != null)
				{
					return transport;
				}
				return string.Empty;
			}
			set
			{
				transport = value;
			}
		}

		[DefaultValue(SoapBindingStyle.Document)]
		[XmlAttribute("style")]
		public SoapBindingStyle Style
		{
			get
			{
				return style;
			}
			set
			{
				style = value;
			}
		}

		public static XmlSchema Schema
		{
			get
			{
				if (schema == null)
				{
					schema = XmlSchema.Read(new StringReader("<?xml version='1.0' encoding='UTF-8' ?> \r\n<xs:schema xmlns:soap='http://schemas.xmlsoap.org/wsdl/soap/' xmlns:wsdl='http://schemas.xmlsoap.org/wsdl/' targetNamespace='http://schemas.xmlsoap.org/wsdl/soap/' xmlns:xs='http://www.w3.org/2001/XMLSchema'>\r\n  <xs:import namespace='http://schemas.xmlsoap.org/wsdl/' />\r\n  <xs:simpleType name='encodingStyle'>\r\n    <xs:annotation>\r\n      <xs:documentation>\r\n      'encodingStyle' indicates any canonicalization conventions followed in the contents of the containing element.  For example, the value 'http://schemas.xmlsoap.org/soap/encoding/' indicates the pattern described in SOAP specification\r\n      </xs:documentation>\r\n    </xs:annotation>\r\n    <xs:list itemType='xs:anyURI' />\r\n  </xs:simpleType>\r\n  <xs:element name='binding' type='soap:tBinding' />\r\n  <xs:complexType name='tBinding'>\r\n    <xs:complexContent mixed='false'>\r\n      <xs:extension base='wsdl:tExtensibilityElement'>\r\n        <xs:attribute name='transport' type='xs:anyURI' use='required' />\r\n        <xs:attribute name='style' type='soap:tStyleChoice' use='optional' />\r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n  <xs:simpleType name='tStyleChoice'>\r\n    <xs:restriction base='xs:string'>\r\n      <xs:enumeration value='rpc' />\r\n      <xs:enumeration value='document' />\r\n    </xs:restriction>\r\n  </xs:simpleType>\r\n  <xs:element name='operation' type='soap:tOperation' />\r\n  <xs:complexType name='tOperation'>\r\n    <xs:complexContent mixed='false'>\r\n      <xs:extension base='wsdl:tExtensibilityElement'>\r\n        <xs:attribute name='soapAction' type='xs:anyURI' use='optional' />\r\n        <xs:attribute name='style' type='soap:tStyleChoice' use='optional' />\r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n  <xs:element name='body' type='soap:tBody' />\r\n  <xs:attributeGroup name='tBodyAttributes'>\r\n    <xs:attribute name='encodingStyle' type='soap:encodingStyle' use='optional' />\r\n    <xs:attribute name='use' type='soap:useChoice' use='optional' />\r\n    <xs:attribute name='namespace' type='xs:anyURI' use='optional' />\r\n  </xs:attributeGroup>\r\n  <xs:complexType name='tBody'>\r\n    <xs:complexContent mixed='false'>\r\n      <xs:extension base='wsdl:tExtensibilityElement'>\r\n        <xs:attribute name='parts' type='xs:NMTOKENS' use='optional' />\r\n        <xs:attributeGroup ref='soap:tBodyAttributes' />\r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n  <xs:simpleType name='useChoice'>\r\n    <xs:restriction base='xs:string'>\r\n      <xs:enumeration value='literal' />\r\n      <xs:enumeration value='encoded' />\r\n    </xs:restriction>\r\n  </xs:simpleType>\r\n  <xs:element name='fault' type='soap:tFault' />\r\n  <xs:complexType name='tFaultRes' abstract='true'>\r\n    <xs:complexContent mixed='false'>\r\n      <xs:restriction base='soap:tBody'>\r\n        <xs:attribute ref='wsdl:required' use='optional' />\r\n        <xs:attribute name='parts' type='xs:NMTOKENS' use='prohibited' />\r\n        <xs:attributeGroup ref='soap:tBodyAttributes' />\r\n      </xs:restriction>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n  <xs:complexType name='tFault'>\r\n    <xs:complexContent mixed='false'>\r\n      <xs:extension base='soap:tFaultRes'>\r\n        <xs:attribute name='name' type='xs:NCName' use='required' />\r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n  <xs:element name='header' type='soap:tHeader' />\r\n  <xs:attributeGroup name='tHeaderAttributes'>\r\n    <xs:attribute name='message' type='xs:QName' use='required' />\r\n    <xs:attribute name='part' type='xs:NMTOKEN' use='required' />\r\n    <xs:attribute name='use' type='soap:useChoice' use='required' />\r\n    <xs:attribute name='encodingStyle' type='soap:encodingStyle' use='optional' />\r\n    <xs:attribute name='namespace' type='xs:anyURI' use='optional' />\r\n  </xs:attributeGroup>\r\n  <xs:complexType name='tHeader'>\r\n    <xs:complexContent mixed='false'>\r\n      <xs:extension base='wsdl:tExtensibilityElement'>\r\n        <xs:sequence>\r\n          <xs:element minOccurs='0' maxOccurs='unbounded' ref='soap:headerfault' />\r\n        </xs:sequence>\r\n        <xs:attributeGroup ref='soap:tHeaderAttributes' />\r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n  <xs:element name='headerfault' type='soap:tHeaderFault' />\r\n  <xs:complexType name='tHeaderFault'>\r\n    <xs:attributeGroup ref='soap:tHeaderAttributes' />\r\n  </xs:complexType>\r\n  <xs:element name='address' type='soap:tAddress' />\r\n  <xs:complexType name='tAddress'>\r\n    <xs:complexContent mixed='false'>\r\n      <xs:extension base='wsdl:tExtensibilityElement'>\r\n        <xs:attribute name='location' type='xs:anyURI' use='required' />\r\n      </xs:extension>\r\n    </xs:complexContent>\r\n  </xs:complexType>\r\n</xs:schema>"), null);
				}
				return schema;
			}
		}
	}
	[XmlFormatExtension("binding", "http://schemas.xmlsoap.org/wsdl/soap12/", typeof(Binding))]
	[XmlFormatExtensionPrefix("soap12", "http://schemas.xmlsoap.org/wsdl/soap12/")]
	public sealed class Soap12Binding : SoapBinding
	{
		public new const string Namespace = "http://schemas.xmlsoap.org/wsdl/soap12/";

		public new const string HttpTransport = "http://schemas.xmlsoap.org/soap/http";
	}
	[XmlFormatExtension("operation", "http://schemas.xmlsoap.org/wsdl/soap/", typeof(OperationBinding))]
	public class SoapOperationBinding : ServiceDescriptionFormatExtension
	{
		private string soapAction;

		private SoapBindingStyle style;

		[XmlAttribute("soapAction")]
		public string SoapAction
		{
			get
			{
				if (soapAction != null)
				{
					return soapAction;
				}
				return string.Empty;
			}
			set
			{
				soapAction = value;
			}
		}

		[DefaultValue(SoapBindingStyle.Default)]
		[XmlAttribute("style")]
		public SoapBindingStyle Style
		{
			get
			{
				return style;
			}
			set
			{
				style = value;
			}
		}
	}
	[XmlFormatExtension("operation", "http://schemas.xmlsoap.org/wsdl/soap12/", typeof(OperationBinding))]
	public sealed class Soap12OperationBinding : SoapOperationBinding
	{
		private bool soapActionRequired;

		private Soap12OperationBinding duplicateBySoapAction;

		private Soap12OperationBinding duplicateByRequestElement;

		private SoapReflectedMethod method;

		[DefaultValue(false)]
		[XmlAttribute("soapActionRequired")]
		public bool SoapActionRequired
		{
			get
			{
				return soapActionRequired;
			}
			set
			{
				soapActionRequired = value;
			}
		}

		internal SoapReflectedMethod Method
		{
			get
			{
				return method;
			}
			set
			{
				method = value;
			}
		}

		internal Soap12OperationBinding DuplicateBySoapAction
		{
			get
			{
				return duplicateBySoapAction;
			}
			set
			{
				duplicateBySoapAction = value;
			}
		}

		internal Soap12OperationBinding DuplicateByRequestElement
		{
			get
			{
				return duplicateByRequestElement;
			}
			set
			{
				duplicateByRequestElement = value;
			}
		}
	}
	[XmlFormatExtension("body", "http://schemas.xmlsoap.org/wsdl/soap/", typeof(InputBinding), typeof(OutputBinding), typeof(MimePart))]
	public class SoapBodyBinding : ServiceDescriptionFormatExtension
	{
		private SoapBindingUse use;

		private string ns;

		private string encoding;

		private string[] parts;

		[XmlAttribute("use")]
		[DefaultValue(SoapBindingUse.Default)]
		public SoapBindingUse Use
		{
			get
			{
				return use;
			}
			set
			{
				use = value;
			}
		}

		[XmlAttribute("namespace")]
		[DefaultValue("")]
		public string Namespace
		{
			get
			{
				if (ns != null)
				{
					return ns;
				}
				return string.Empty;
			}
			set
			{
				ns = value;
			}
		}

		[DefaultValue("")]
		[XmlAttribute("encodingStyle")]
		public string Encoding
		{
			get
			{
				if (encoding != null)
				{
					return encoding;
				}
				return string.Empty;
			}
			set
			{
				encoding = value;
			}
		}

		[XmlAttribute("parts")]
		public string PartsString
		{
			get
			{
				if (parts == null)
				{
					return null;
				}
				StringBuilder stringBuilder = new StringBuilder();
				for (int i = 0; i < parts.Length; i++)
				{
					if (i > 0)
					{
						stringBuilder.Append(' ');
					}
					stringBuilder.Append(parts[i]);
				}
				return stringBuilder.ToString();
			}
			set
			{
				if (value == null)
				{
					parts = null;
					return;
				}
				parts = value.Split(' ');
			}
		}

		[XmlIgnore]
		public string[] Parts
		{
			get
			{
				return parts;
			}
			set
			{
				parts = value;
			}
		}
	}
	[XmlFormatExtension("body", "http://schemas.xmlsoap.org/wsdl/soap12/", typeof(InputBinding), typeof(OutputBinding), typeof(MimePart))]
	public sealed class Soap12BodyBinding : SoapBodyBinding
	{
	}
	[XmlFormatExtension("fault", "http://schemas.xmlsoap.org/wsdl/soap/", typeof(FaultBinding))]
	public class SoapFaultBinding : ServiceDescriptionFormatExtension
	{
		private SoapBindingUse use;

		private string ns;

		private string encoding;

		private string name;

		[XmlAttribute("use")]
		[DefaultValue(SoapBindingUse.Default)]
		public SoapBindingUse Use
		{
			get
			{
				return use;
			}
			set
			{
				use = value;
			}
		}

		[XmlAttribute("name")]
		public string Name
		{
			get
			{
				return name;
			}
			set
			{
				name = value;
			}
		}

		[XmlAttribute("namespace")]
		public string Namespace
		{
			get
			{
				if (ns != null)
				{
					return ns;
				}
				return string.Empty;
			}
			set
			{
				ns = value;
			}
		}

		[DefaultValue("")]
		[XmlAttribute("encodingStyle")]
		public string Encoding
		{
			get
			{
				if (encoding != null)
				{
					return encoding;
				}
				return string.Empty;
			}
			set
			{
				encoding = value;
			}
		}
	}
	[XmlFormatExtension("fault", "http://schemas.xmlsoap.org/wsdl/soap12/", typeof(FaultBinding))]
	public sealed class Soap12FaultBinding : SoapFaultBinding
	{
	}
	[XmlFormatExtension("header", "http://schemas.xmlsoap.org/wsdl/soap/", typeof(InputBinding), typeof(OutputBinding))]
	public class SoapHeaderBinding : ServiceDescriptionFormatExtension
	{
		private XmlQualifiedName message = XmlQualifiedName.Empty;

		private string part;

		private SoapBindingUse use;

		private string encoding;

		private string ns;

		private bool mapToProperty;

		private SoapHeaderFaultBinding fault;

		[XmlIgnore]
		public bool MapToProperty
		{
			get
			{
				return mapToProperty;
			}
			set
			{
				mapToProperty = value;
			}
		}

		[XmlAttribute("message")]
		public XmlQualifiedName Message
		{
			get
			{
				return message;
			}
			set
			{
				message = value;
			}
		}

		[XmlAttribute("part")]
		public string Part
		{
			get
			{
				return part;
			}
			set
			{
				part = value;
			}
		}

		[XmlAttribute("use")]
		[DefaultValue(SoapBindingUse.Default)]
		public SoapBindingUse Use
		{
			get
			{
				return use;
			}
			set
			{
				use = value;
			}
		}

		[DefaultValue("")]
		[XmlAttribute("encodingStyle")]
		public string Encoding
		{
			get
			{
				if (encoding != null)
				{
					return encoding;
				}
				return string.Empty;
			}
			set
			{
				encoding = value;
			}
		}

		[XmlAttribute("namespace")]
		[DefaultValue("")]
		public string Namespace
		{
			get
			{
				if (ns != null)
				{
					return ns;
				}
				return string.Empty;
			}
			set
			{
				ns = value;
			}
		}

		[XmlElement("headerfault")]
		public SoapHeaderFaultBinding Fault
		{
			get
			{
				return fault;
			}
			set
			{
				fault = value;
			}
		}
	}
	[XmlFormatExtension("header", "http://schemas.xmlsoap.org/wsdl/soap12/", typeof(InputBinding), typeof(OutputBinding))]
	public sealed class Soap12HeaderBinding : SoapHeaderBinding
	{
	}
	[XmlFormatExtension("address", "http://schemas.xmlsoap.org/wsdl/soap/", typeof(Port))]
	public class SoapAddressBinding : ServiceDescriptionFormatExtension
	{
		private string location;

		[XmlAttribute("location")]
		public string Location
		{
			get
			{
				if (location != null)
				{
					return location;
				}
				return string.Empty;
			}
			set
			{
				location = value;
			}
		}
	}
	[XmlFormatExtension("address", "http://schemas.xmlsoap.org/wsdl/soap12/", typeof(Port))]
	public sealed class Soap12AddressBinding : SoapAddressBinding
	{
	}
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	public class SoapProtocolImporter : ProtocolImporter
	{
		private XmlSchemaImporter xmlImporter;

		private XmlCodeExporter xmlExporter;

		private SoapSchemaImporter soapImporter;

		private SoapCodeExporter soapExporter;

		private ArrayList xmlMembers = new ArrayList();

		private ArrayList soapMembers = new ArrayList();

		private Hashtable headers = new Hashtable();

		private Hashtable classHeaders = new Hashtable();

		private ArrayList propertyNames = new ArrayList();

		private ArrayList propertyValues = new ArrayList();

		private SoapExtensionImporter[] extensions;

		private SoapTransportImporter transport;

		private SoapBinding soapBinding;

		private ArrayList codeClasses = new ArrayList();

		private static TypedDataSetSchemaImporterExtension typedDataSetSchemaImporterExtension;

		public override string ProtocolName => "Soap";

		public SoapBinding SoapBinding => soapBinding;

		public SoapSchemaImporter SoapImporter => soapImporter;

		public XmlSchemaImporter XmlImporter => xmlImporter;

		public XmlCodeExporter XmlExporter => xmlExporter;

		public SoapCodeExporter SoapExporter => soapExporter;

		private static TypedDataSetSchemaImporterExtension TypedDataSetSchemaImporterExtension
		{
			get
			{
				if (typedDataSetSchemaImporterExtension == null)
				{
					typedDataSetSchemaImporterExtension = new TypedDataSetSchemaImporterExtension();
				}
				return typedDataSetSchemaImporterExtension;
			}
		}

		private bool MetadataPropertiesAdded => propertyNames.Count > 0;

		protected override void BeginNamespace()
		{
			try
			{
				base.MethodNames.Clear();
				base.ExtraCodeClasses.Clear();
				soapImporter = new SoapSchemaImporter(base.AbstractSchemas, base.ServiceImporter.CodeGenerationOptions, base.ImportContext);
				xmlImporter = new XmlSchemaImporter(base.ConcreteSchemas, base.ServiceImporter.CodeGenerationOptions, base.ServiceImporter.CodeGenerator, base.ImportContext);
				foreach (Type extension in base.ServiceImporter.Extensions)
				{
					xmlImporter.Extensions.Add(extension.FullName, extension);
				}
				xmlImporter.Extensions.Add(TypedDataSetSchemaImporterExtension);
				xmlImporter.Extensions.Add(new DataSetSchemaImporterExtension());
				xmlExporter = new XmlCodeExporter(base.CodeNamespace, base.ServiceImporter.CodeCompileUnit, base.ServiceImporter.CodeGenerator, base.ServiceImporter.CodeGenerationOptions, base.ExportContext);
				soapExporter = new SoapCodeExporter(base.CodeNamespace, null, base.ServiceImporter.CodeGenerator, base.ServiceImporter.CodeGenerationOptions, base.ExportContext);
			}
			catch (Exception ex)
			{
				if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
				{
					throw;
				}
				throw new InvalidOperationException(Res.GetString("InitFailed"), ex);
			}
			catch
			{
				throw new InvalidOperationException(Res.GetString("InitFailed"), null);
			}
		}

		protected override void EndNamespace()
		{
			base.ConcreteSchemas.Compile(null, fullCompile: false);
			foreach (GlobalSoapHeader value4 in headers.Values)
			{
				if (value4.isEncoded)
				{
					soapExporter.ExportTypeMapping(value4.mapping);
				}
				else
				{
					xmlExporter.ExportTypeMapping(value4.mapping);
				}
			}
			foreach (XmlMembersMapping xmlMember in xmlMembers)
			{
				xmlExporter.ExportMembersMapping(xmlMember);
			}
			foreach (XmlMembersMapping soapMember in soapMembers)
			{
				soapExporter.ExportMembersMapping(soapMember);
			}
			foreach (CodeTypeDeclaration codeClass in codeClasses)
			{
				foreach (CodeAttributeDeclaration includeMetadatum in xmlExporter.IncludeMetadata)
				{
					codeClass.CustomAttributes.Add(includeMetadatum);
				}
				foreach (CodeAttributeDeclaration includeMetadatum2 in soapExporter.IncludeMetadata)
				{
					codeClass.CustomAttributes.Add(includeMetadatum2);
				}
			}
			foreach (CodeTypeDeclaration extraCodeClass in base.ExtraCodeClasses)
			{
				base.CodeNamespace.Types.Add(extraCodeClass);
			}
			CodeGenerator.ValidateIdentifiers(base.CodeNamespace);
		}

		protected override bool IsBindingSupported()
		{
			SoapBinding soapBinding = (SoapBinding)base.Binding.Extensions.Find(typeof(SoapBinding));
			if (soapBinding == null || soapBinding.GetType() != typeof(SoapBinding))
			{
				return false;
			}
			if (GetTransport(soapBinding.Transport) == null)
			{
				UnsupportedBindingWarning(Res.GetString("ThereIsNoSoapTransportImporterThatUnderstands1", soapBinding.Transport));
				return false;
			}
			return true;
		}

		internal SoapTransportImporter GetTransport(string transport)
		{
			Type[] soapTransportImporters = WebServicesSection.Current.SoapTransportImporters;
			foreach (Type type in soapTransportImporters)
			{
				SoapTransportImporter soapTransportImporter = (SoapTransportImporter)Activator.CreateInstance(type);
				soapTransportImporter.ImportContext = this;
				if (soapTransportImporter.IsSupportedTransport(transport))
				{
					return soapTransportImporter;
				}
			}
			return null;
		}

		protected override CodeTypeDeclaration BeginClass()
		{
			base.MethodNames.Clear();
			soapBinding = (SoapBinding)base.Binding.Extensions.Find(typeof(SoapBinding));
			transport = GetTransport(soapBinding.Transport);
			Type[] types = new Type[6]
			{
				typeof(SoapDocumentMethodAttribute),
				typeof(XmlAttributeAttribute),
				typeof(WebService),
				typeof(object),
				typeof(DebuggerStepThroughAttribute),
				typeof(DesignerCategoryAttribute)
			};
			WebCodeGenerator.AddImports(base.CodeNamespace, WebCodeGenerator.GetNamespacesForTypes(types));
			CodeFlags codeFlags = (CodeFlags)0;
			if (base.Style == ServiceDescriptionImportStyle.Server)
			{
				codeFlags = CodeFlags.IsAbstract;
			}
			else if (base.Style == ServiceDescriptionImportStyle.ServerInterface)
			{
				codeFlags = CodeFlags.IsInterface;
			}
			CodeTypeDeclaration codeTypeDeclaration = WebCodeGenerator.CreateClass(base.ClassName, null, new string[0], null, CodeFlags.IsPublic | codeFlags, base.ServiceImporter.CodeGenerator.Supports(GeneratorSupport.PartialTypes));
			codeTypeDeclaration.Comments.Add(new CodeCommentStatement(Res.GetString("CodeRemarks"), docComment: true));
			if (base.Style == ServiceDescriptionImportStyle.Client)
			{
				codeTypeDeclaration.CustomAttributes.Add(new CodeAttributeDeclaration(typeof(DebuggerStepThroughAttribute).FullName));
				codeTypeDeclaration.CustomAttributes.Add(new CodeAttributeDeclaration(typeof(DesignerCategoryAttribute).FullName, new CodeAttributeArgument(new CodePrimitiveExpression("code"))));
			}
			else if (base.Style == ServiceDescriptionImportStyle.Server)
			{
				CodeAttributeDeclaration codeAttributeDeclaration = new CodeAttributeDeclaration(typeof(WebServiceAttribute).FullName);
				string value = ((base.Service != null) ? base.Service.ServiceDescription.TargetNamespace : base.Binding.ServiceDescription.TargetNamespace);
				codeAttributeDeclaration.Arguments.Add(new CodeAttributeArgument("Namespace", new CodePrimitiveExpression(value)));
				codeTypeDeclaration.CustomAttributes.Add(codeAttributeDeclaration);
			}
			CodeAttributeDeclaration codeAttributeDeclaration2 = new CodeAttributeDeclaration(typeof(WebServiceBindingAttribute).FullName);
			codeAttributeDeclaration2.Arguments.Add(new CodeAttributeArgument("Name", new CodePrimitiveExpression(XmlConvert.DecodeName(base.Binding.Name))));
			codeAttributeDeclaration2.Arguments.Add(new CodeAttributeArgument("Namespace", new CodePrimitiveExpression(base.Binding.ServiceDescription.TargetNamespace)));
			codeTypeDeclaration.CustomAttributes.Add(codeAttributeDeclaration2);
			codeClasses.Add(codeTypeDeclaration);
			classHeaders.Clear();
			return codeTypeDeclaration;
		}

		protected override void EndClass()
		{
			if (transport != null)
			{
				transport.ImportClass();
			}
			soapBinding = null;
		}

		protected override bool IsOperationFlowSupported(OperationFlow flow)
		{
			if (flow != OperationFlow.OneWay)
			{
				return flow == OperationFlow.RequestResponse;
			}
			return true;
		}

		private void BeginMetadata()
		{
			propertyNames.Clear();
			propertyValues.Clear();
		}

		private void AddMetadataProperty(string name, object value)
		{
			AddMetadataProperty(name, new CodePrimitiveExpression(value));
		}

		private void AddMetadataProperty(string name, CodeExpression expr)
		{
			propertyNames.Add(name);
			propertyValues.Add(expr);
		}

		private void EndMetadata(CodeAttributeDeclarationCollection metadata, Type attributeType, string parameter)
		{
			CodeExpression[] parameters = ((parameter != null) ? new CodeExpression[1]
			{
				new CodePrimitiveExpression(parameter)
			} : new CodeExpression[0]);
			WebCodeGenerator.AddCustomAttribute(metadata, attributeType, parameters, (string[])propertyNames.ToArray(typeof(string)), (CodeExpression[])propertyValues.ToArray(typeof(CodeExpression)));
		}

		private void GenerateExtensionMetadata(CodeAttributeDeclarationCollection metadata)
		{
			if (extensions == null)
			{
				TypeElementCollection soapExtensionImporterTypes = WebServicesSection.Current.SoapExtensionImporterTypes;
				extensions = new SoapExtensionImporter[soapExtensionImporterTypes.Count];
				for (int i = 0; i < extensions.Length; i++)
				{
					SoapExtensionImporter soapExtensionImporter = (SoapExtensionImporter)Activator.CreateInstance(soapExtensionImporterTypes[i].Type);
					soapExtensionImporter.ImportContext = this;
					extensions[i] = soapExtensionImporter;
				}
			}
			SoapExtensionImporter[] array = extensions;
			foreach (SoapExtensionImporter soapExtensionImporter2 in array)
			{
				soapExtensionImporter2.ImportMethod(metadata);
			}
		}

		private void PrepareHeaders(MessageBinding messageBinding)
		{
			SoapHeaderBinding[] array = (SoapHeaderBinding[])messageBinding.Extensions.FindAll(typeof(SoapHeaderBinding));
			SoapHeaderBinding[] array2 = array;
			foreach (SoapHeaderBinding soapHeaderBinding in array2)
			{
				soapHeaderBinding.MapToProperty = true;
			}
		}

		private void GenerateHeaders(CodeAttributeDeclarationCollection metadata, SoapBindingUse use, bool rpc, MessageBinding requestMessage, MessageBinding responseMessage)
		{
			Hashtable hashtable = new Hashtable();
			for (int i = 0; i < 2; i++)
			{
				MessageBinding messageBinding;
				SoapHeaderDirection soapHeaderDirection;
				if (i == 0)
				{
					messageBinding = requestMessage;
					soapHeaderDirection = SoapHeaderDirection.In;
				}
				else
				{
					if (responseMessage == null)
					{
						continue;
					}
					messageBinding = responseMessage;
					soapHeaderDirection = SoapHeaderDirection.Out;
				}
				SoapHeaderBinding[] array = (SoapHeaderBinding[])messageBinding.Extensions.FindAll(typeof(SoapHeaderBinding));
				SoapHeaderBinding[] array2 = array;
				foreach (SoapHeaderBinding soapHeaderBinding in array2)
				{
					if (!soapHeaderBinding.MapToProperty)
					{
						continue;
					}
					if (use != soapHeaderBinding.Use)
					{
						throw new InvalidOperationException(Res.GetString("WebDescriptionHeaderAndBodyUseMismatch"));
					}
					if (use == SoapBindingUse.Encoded && !IsSoapEncodingPresent(soapHeaderBinding.Encoding))
					{
						throw new InvalidOperationException(Res.GetString("WebUnknownEncodingStyle", soapHeaderBinding.Encoding));
					}
					Message message = base.ServiceDescriptions.GetMessage(soapHeaderBinding.Message);
					if (message == null)
					{
						throw new InvalidOperationException(Res.GetString("MissingMessage2", soapHeaderBinding.Message.Name, soapHeaderBinding.Message.Namespace));
					}
					MessagePart messagePart = message.FindPartByName(soapHeaderBinding.Part);
					if (messagePart == null)
					{
						throw new InvalidOperationException(Res.GetString("MissingMessagePartForMessageFromNamespace3", messagePart.Name, soapHeaderBinding.Message.Name, soapHeaderBinding.Message.Namespace));
					}
					XmlTypeMapping xmlTypeMapping;
					string key;
					if (use == SoapBindingUse.Encoded)
					{
						if (messagePart.Type.IsEmpty)
						{
							throw new InvalidOperationException(Res.GetString("WebDescriptionPartTypeRequired", messagePart.Name, soapHeaderBinding.Message.Name, soapHeaderBinding.Message.Namespace));
						}
						if (!messagePart.Element.IsEmpty)
						{
							UnsupportedOperationBindingWarning(Res.GetString("WebDescriptionPartElementWarning", messagePart.Name, soapHeaderBinding.Message.Name, soapHeaderBinding.Message.Namespace));
						}
						xmlTypeMapping = soapImporter.ImportDerivedTypeMapping(messagePart.Type, typeof(SoapHeader), baseTypeCanBeIndirect: true);
						key = "type=" + messagePart.Type.ToString();
					}
					else
					{
						if (messagePart.Element.IsEmpty)
						{
							throw new InvalidOperationException(Res.GetString("WebDescriptionPartElementRequired", messagePart.Name, soapHeaderBinding.Message.Name, soapHeaderBinding.Message.Namespace));
						}
						if (!messagePart.Type.IsEmpty)
						{
							UnsupportedOperationBindingWarning(Res.GetString("WebDescriptionPartTypeWarning", messagePart.Name, soapHeaderBinding.Message.Name, soapHeaderBinding.Message.Namespace));
						}
						xmlTypeMapping = xmlImporter.ImportDerivedTypeMapping(messagePart.Element, typeof(SoapHeader), baseTypeCanBeIndirect: true);
						key = "element=" + messagePart.Element.ToString();
					}
					LocalSoapHeader localSoapHeader = (LocalSoapHeader)hashtable[key];
					if (localSoapHeader == null)
					{
						GlobalSoapHeader globalSoapHeader = (GlobalSoapHeader)classHeaders[key];
						if (globalSoapHeader == null)
						{
							globalSoapHeader = new GlobalSoapHeader();
							globalSoapHeader.isEncoded = use == SoapBindingUse.Encoded;
							string text = CodeIdentifier.MakeValid(xmlTypeMapping.ElementName);
							if (text == xmlTypeMapping.TypeName)
							{
								text += "Value";
							}
							text = (globalSoapHeader.fieldName = base.MethodNames.AddUnique(text, xmlTypeMapping));
							WebCodeGenerator.AddMember(base.CodeTypeDeclaration, xmlTypeMapping.TypeFullName, globalSoapHeader.fieldName, null, null, CodeFlags.IsPublic, base.ServiceImporter.CodeGenerationOptions);
							globalSoapHeader.mapping = xmlTypeMapping;
							classHeaders.Add(key, globalSoapHeader);
							if (headers[key] == null)
							{
								headers.Add(key, globalSoapHeader);
							}
						}
						localSoapHeader = new LocalSoapHeader();
						localSoapHeader.fieldName = globalSoapHeader.fieldName;
						localSoapHeader.direction = soapHeaderDirection;
						hashtable.Add(key, localSoapHeader);
					}
					else if (localSoapHeader.direction != soapHeaderDirection)
					{
						localSoapHeader.direction = SoapHeaderDirection.InOut;
					}
				}
			}
			foreach (LocalSoapHeader value in hashtable.Values)
			{
				BeginMetadata();
				if (value.direction == SoapHeaderDirection.Out)
				{
					AddMetadataProperty("Direction", new CodeFieldReferenceExpression(new CodeTypeReferenceExpression(typeof(SoapHeaderDirection).FullName), SoapHeaderDirection.Out.ToString()));
				}
				else if (value.direction == SoapHeaderDirection.InOut)
				{
					AddMetadataProperty("Direction", new CodeFieldReferenceExpression(new CodeTypeReferenceExpression(typeof(SoapHeaderDirection).FullName), SoapHeaderDirection.InOut.ToString()));
				}
				EndMetadata(metadata, typeof(SoapHeaderAttribute), value.fieldName);
			}
		}

		protected override CodeMemberMethod GenerateMethod()
		{
			SoapOperationBinding soapOperationBinding = (SoapOperationBinding)base.OperationBinding.Extensions.Find(typeof(SoapOperationBinding));
			if (soapOperationBinding == null)
			{
				throw OperationBindingSyntaxException(Res.GetString("MissingSoapOperationBinding0"));
			}
			SoapBindingStyle soapBindingStyle = soapOperationBinding.Style;
			if (soapBindingStyle == SoapBindingStyle.Default)
			{
				soapBindingStyle = SoapBinding.Style;
			}
			if (soapBindingStyle == SoapBindingStyle.Default)
			{
				soapBindingStyle = SoapBindingStyle.Document;
			}
			string[] parameterOrder = base.Operation.ParameterOrder;
			Message message = base.InputMessage;
			MessageBinding input = base.OperationBinding.Input;
			SoapBodyBinding soapBodyBinding = (SoapBodyBinding)base.OperationBinding.Input.Extensions.Find(typeof(SoapBodyBinding));
			if (soapBodyBinding == null)
			{
				UnsupportedOperationBindingWarning(Res.GetString("MissingSoapBodyInputBinding0"));
				return null;
			}
			Message message2;
			MessageBinding messageBinding;
			SoapBodyBinding soapBodyBinding2;
			if (base.Operation.Messages.Output != null)
			{
				message2 = base.OutputMessage;
				messageBinding = base.OperationBinding.Output;
				soapBodyBinding2 = (SoapBodyBinding)base.OperationBinding.Output.Extensions.Find(typeof(SoapBodyBinding));
				if (soapBodyBinding2 == null)
				{
					UnsupportedOperationBindingWarning(Res.GetString("MissingSoapBodyOutputBinding0"));
					return null;
				}
			}
			else
			{
				message2 = null;
				messageBinding = null;
				soapBodyBinding2 = null;
			}
			CodeAttributeDeclarationCollection metadata = new CodeAttributeDeclarationCollection();
			PrepareHeaders(input);
			if (messageBinding != null)
			{
				PrepareHeaders(messageBinding);
			}
			string messageName = null;
			string name = ((!string.IsNullOrEmpty(input.Name) && soapBindingStyle != SoapBindingStyle.Rpc) ? input.Name : base.Operation.Name);
			name = XmlConvert.DecodeName(name);
			if (messageBinding != null)
			{
				messageName = ((!string.IsNullOrEmpty(messageBinding.Name) && soapBindingStyle != SoapBindingStyle.Rpc) ? messageBinding.Name : (base.Operation.Name + "Response"));
				messageName = XmlConvert.DecodeName(messageName);
			}
			GenerateExtensionMetadata(metadata);
			GenerateHeaders(metadata, soapBodyBinding.Use, soapBindingStyle == SoapBindingStyle.Rpc, input, messageBinding);
			MessagePart[] messageParts = GetMessageParts(message, soapBodyBinding);
			if (!CheckMessageStyles(base.MethodName, messageParts, soapBodyBinding, soapBindingStyle, out var hasWrapper))
			{
				return null;
			}
			MessagePart[] parts = null;
			if (message2 != null)
			{
				parts = GetMessageParts(message2, soapBodyBinding2);
				if (!CheckMessageStyles(base.MethodName, parts, soapBodyBinding2, soapBindingStyle, out var hasWrapper2))
				{
					return null;
				}
				if (hasWrapper != hasWrapper2)
				{
					hasWrapper = false;
				}
			}
			bool flag = (soapBindingStyle != SoapBindingStyle.Rpc && hasWrapper) || (soapBodyBinding.Use == SoapBindingUse.Literal && soapBindingStyle == SoapBindingStyle.Rpc);
			XmlMembersMapping xmlMembersMapping = ImportMessage(name, messageParts, soapBodyBinding, soapBindingStyle, hasWrapper);
			if (xmlMembersMapping == null)
			{
				return null;
			}
			XmlMembersMapping xmlMembersMapping2 = null;
			if (message2 != null)
			{
				xmlMembersMapping2 = ImportMessage(messageName, parts, soapBodyBinding2, soapBindingStyle, hasWrapper);
				if (xmlMembersMapping2 == null)
				{
					return null;
				}
			}
			string text = CodeIdentifier.MakeValid(XmlConvert.DecodeName(base.Operation.Name));
			if (base.ClassName == text)
			{
				text = "Call" + text;
			}
			string text2 = base.MethodNames.AddUnique(CodeIdentifier.MakeValid(XmlConvert.DecodeName(text)), base.Operation);
			bool flag2 = text != text2;
			CodeIdentifiers codeIdentifiers = new CodeIdentifiers(caseSensitive: false);
			codeIdentifiers.AddReserved(text2);
			SoapParameters soapParameters = new SoapParameters(xmlMembersMapping, xmlMembersMapping2, parameterOrder, base.MethodNames);
			foreach (SoapParameter parameter in soapParameters.Parameters)
			{
				if ((parameter.IsOut || parameter.IsByRef) && !base.ServiceImporter.CodeGenerator.Supports(GeneratorSupport.ReferenceParameters))
				{
					UnsupportedOperationWarning(Res.GetString("CodeGenSupportReferenceParameters", base.ServiceImporter.CodeGenerator.GetType().Name));
					return null;
				}
				parameter.name = codeIdentifiers.AddUnique(parameter.name, null);
				if (parameter.mapping.CheckSpecified)
				{
					parameter.specifiedName = codeIdentifiers.AddUnique(parameter.name + "Specified", null);
				}
			}
			if (base.Style != 0 || flag2)
			{
				BeginMetadata();
				if (flag2)
				{
					AddMetadataProperty("MessageName", text2);
				}
				EndMetadata(metadata, typeof(WebMethodAttribute), null);
			}
			BeginMetadata();
			if (flag && xmlMembersMapping.ElementName.Length > 0 && xmlMembersMapping.ElementName != text2)
			{
				AddMetadataProperty("RequestElementName", xmlMembersMapping.ElementName);
			}
			if (xmlMembersMapping.Namespace != null)
			{
				AddMetadataProperty("RequestNamespace", xmlMembersMapping.Namespace);
			}
			if (xmlMembersMapping2 == null)
			{
				AddMetadataProperty("OneWay", true);
			}
			else
			{
				if (flag && xmlMembersMapping2.ElementName.Length > 0 && xmlMembersMapping2.ElementName != text2 + "Response")
				{
					AddMetadataProperty("ResponseElementName", xmlMembersMapping2.ElementName);
				}
				if (xmlMembersMapping2.Namespace != null)
				{
					AddMetadataProperty("ResponseNamespace", xmlMembersMapping2.Namespace);
				}
			}
			if (soapBindingStyle == SoapBindingStyle.Rpc)
			{
				if (soapBodyBinding.Use != SoapBindingUse.Encoded)
				{
					AddMetadataProperty("Use", new CodeFieldReferenceExpression(new CodeTypeReferenceExpression(typeof(SoapBindingUse).FullName), Enum.Format(typeof(SoapBindingUse), soapBodyBinding.Use, "G")));
				}
				EndMetadata(metadata, typeof(SoapRpcMethodAttribute), soapOperationBinding.SoapAction);
			}
			else
			{
				AddMetadataProperty("Use", new CodeFieldReferenceExpression(new CodeTypeReferenceExpression(typeof(SoapBindingUse).FullName), Enum.Format(typeof(SoapBindingUse), soapBodyBinding.Use, "G")));
				AddMetadataProperty("ParameterStyle", new CodeFieldReferenceExpression(new CodeTypeReferenceExpression(typeof(SoapParameterStyle).FullName), Enum.Format(typeof(SoapParameterStyle), (!hasWrapper) ? SoapParameterStyle.Bare : SoapParameterStyle.Wrapped, "G")));
				EndMetadata(metadata, typeof(SoapDocumentMethodAttribute), soapOperationBinding.SoapAction);
			}
			base.IsEncodedBinding = base.IsEncodedBinding || soapBodyBinding.Use == SoapBindingUse.Encoded;
			CodeAttributeDeclarationCollection[] array = new CodeAttributeDeclarationCollection[soapParameters.Parameters.Count + soapParameters.CheckSpecifiedCount];
			int num = 0;
			CodeAttributeDeclaration value = new CodeAttributeDeclaration(typeof(XmlIgnoreAttribute).FullName);
			foreach (SoapParameter parameter2 in soapParameters.Parameters)
			{
				array[num] = new CodeAttributeDeclarationCollection();
				if (soapBodyBinding.Use == SoapBindingUse.Encoded)
				{
					soapExporter.AddMappingMetadata(array[num], parameter2.mapping, parameter2.name != parameter2.mapping.MemberName);
				}
				else
				{
					string ns = ((soapBindingStyle == SoapBindingStyle.Rpc) ? parameter2.mapping.Namespace : (parameter2.IsOut ? xmlMembersMapping2.Namespace : xmlMembersMapping.Namespace));
					bool forceUseMemberName = parameter2.name != parameter2.mapping.MemberName;
					xmlExporter.AddMappingMetadata(array[num], parameter2.mapping, ns, forceUseMemberName);
					if (parameter2.mapping.CheckSpecified)
					{
						num++;
						array[num] = new CodeAttributeDeclarationCollection();
						xmlExporter.AddMappingMetadata(array[num], parameter2.mapping, ns, parameter2.specifiedName != parameter2.mapping.MemberName + "Specified");
						array[num].Add(value);
					}
				}
				if (array[num].Count > 0 && !base.ServiceImporter.CodeGenerator.Supports(GeneratorSupport.ParameterAttributes))
				{
					UnsupportedOperationWarning(Res.GetString("CodeGenSupportParameterAttributes", base.ServiceImporter.CodeGenerator.GetType().Name));
					return null;
				}
				num++;
			}
			CodeFlags[] codeFlags = SoapParameter.GetCodeFlags(soapParameters.Parameters, soapParameters.CheckSpecifiedCount);
			string[] typeFullNames = SoapParameter.GetTypeFullNames(soapParameters.Parameters, soapParameters.CheckSpecifiedCount, base.ServiceImporter.CodeGenerator);
			string text3 = ((soapParameters.Return == null) ? typeof(void).FullName : WebCodeGenerator.FullTypeName(soapParameters.Return, base.ServiceImporter.CodeGenerator));
			CodeMemberMethod codeMemberMethod = WebCodeGenerator.AddMethod(base.CodeTypeDeclaration, text, codeFlags, typeFullNames, SoapParameter.GetNames(soapParameters.Parameters, soapParameters.CheckSpecifiedCount), array, text3, metadata, CodeFlags.IsPublic | ((base.Style != 0) ? CodeFlags.IsAbstract : ((CodeFlags)0)));
			codeMemberMethod.Comments.Add(new CodeCommentStatement(Res.GetString("CodeRemarks"), docComment: true));
			if (soapParameters.Return != null)
			{
				if (soapBodyBinding.Use == SoapBindingUse.Encoded)
				{
					soapExporter.AddMappingMetadata(codeMemberMethod.ReturnTypeCustomAttributes, soapParameters.Return, soapParameters.Return.ElementName != text2 + "Result");
				}
				else
				{
					xmlExporter.AddMappingMetadata(codeMemberMethod.ReturnTypeCustomAttributes, soapParameters.Return, xmlMembersMapping2.Namespace, soapParameters.Return.ElementName != text2 + "Result");
				}
				if (codeMemberMethod.ReturnTypeCustomAttributes.Count != 0 && !base.ServiceImporter.CodeGenerator.Supports(GeneratorSupport.ReturnTypeAttributes))
				{
					UnsupportedOperationWarning(Res.GetString("CodeGenSupportReturnTypeAttributes", base.ServiceImporter.CodeGenerator.GetType().Name));
					return null;
				}
			}
			string resultsName = codeIdentifiers.MakeUnique("results");
			if (base.Style == ServiceDescriptionImportStyle.Client)
			{
				bool flag3 = (base.ServiceImporter.CodeGenerationOptions & CodeGenerationOptions.GenerateOldAsync) != 0;
				bool flag4 = (base.ServiceImporter.CodeGenerationOptions & CodeGenerationOptions.GenerateNewAsync) != 0 && base.ServiceImporter.CodeGenerator.Supports(GeneratorSupport.DeclareEvents) && base.ServiceImporter.CodeGenerator.Supports(GeneratorSupport.DeclareDelegates);
				CodeExpression[] array2 = new CodeExpression[2];
				CreateInvokeParams(array2, text2, soapParameters.InParameters, soapParameters.InCheckSpecifiedCount);
				CodeMethodInvokeExpression invoke = new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), "Invoke", array2);
				WriteReturnMappings(codeMemberMethod, invoke, soapParameters, resultsName);
				if (flag3)
				{
					int num2 = soapParameters.InParameters.Count + soapParameters.InCheckSpecifiedCount;
					string[] array3 = new string[num2 + 2];
					SoapParameter.GetTypeFullNames(soapParameters.InParameters, array3, 0, soapParameters.InCheckSpecifiedCount, base.ServiceImporter.CodeGenerator);
					array3[num2] = typeof(AsyncCallback).FullName;
					array3[num2 + 1] = typeof(object).FullName;
					string[] array4 = new string[num2 + 2];
					SoapParameter.GetNames(soapParameters.InParameters, array4, 0, soapParameters.InCheckSpecifiedCount);
					array4[num2] = "callback";
					array4[num2 + 1] = "asyncState";
					CodeFlags[] parameterFlags = new CodeFlags[num2 + 2];
					CodeMemberMethod codeMemberMethod2 = WebCodeGenerator.AddMethod(base.CodeTypeDeclaration, "Begin" + text2, parameterFlags, array3, array4, typeof(IAsyncResult).FullName, null, CodeFlags.IsPublic);
					codeMemberMethod2.Comments.Add(new CodeCommentStatement(Res.GetString("CodeRemarks"), docComment: true));
					array2 = new CodeExpression[4];
					CreateInvokeParams(array2, text2, soapParameters.InParameters, soapParameters.InCheckSpecifiedCount);
					array2[2] = new CodeArgumentReferenceExpression("callback");
					array2[3] = new CodeArgumentReferenceExpression("asyncState");
					invoke = new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), "BeginInvoke", array2);
					codeMemberMethod2.Statements.Add(new CodeMethodReturnStatement(invoke));
					int num3 = soapParameters.OutParameters.Count + soapParameters.OutCheckSpecifiedCount;
					string[] array5 = new string[num3 + 1];
					SoapParameter.GetTypeFullNames(soapParameters.OutParameters, array5, 1, soapParameters.OutCheckSpecifiedCount, base.ServiceImporter.CodeGenerator);
					array5[0] = typeof(IAsyncResult).FullName;
					string[] array6 = new string[num3 + 1];
					SoapParameter.GetNames(soapParameters.OutParameters, array6, 1, soapParameters.OutCheckSpecifiedCount);
					array6[0] = "asyncResult";
					CodeFlags[] array7 = new CodeFlags[num3 + 1];
					for (int i = 0; i < num3; i++)
					{
						array7[i + 1] = CodeFlags.IsOut;
					}
					CodeMemberMethod codeMemberMethod3 = WebCodeGenerator.AddMethod(base.CodeTypeDeclaration, "End" + text2, array7, array5, array6, (soapParameters.Return == null) ? typeof(void).FullName : WebCodeGenerator.FullTypeName(soapParameters.Return, base.ServiceImporter.CodeGenerator), null, CodeFlags.IsPublic);
					codeMemberMethod3.Comments.Add(new CodeCommentStatement(Res.GetString("CodeRemarks"), docComment: true));
					CodeExpression codeExpression = new CodeArgumentReferenceExpression("asyncResult");
					invoke = new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), "EndInvoke", codeExpression);
					WriteReturnMappings(codeMemberMethod3, invoke, soapParameters, resultsName);
				}
				if (flag4)
				{
					string key = ProtocolImporter.MethodSignature(text2, text3, codeFlags, typeFullNames);
					DelegateInfo delegateInfo = (DelegateInfo)base.ExportContext[key];
					if (delegateInfo == null)
					{
						string handlerType = base.ClassNames.AddUnique(text2 + "CompletedEventHandler", text2);
						string handlerArgs = base.ClassNames.AddUnique(text2 + "CompletedEventArgs", text2);
						delegateInfo = new DelegateInfo(handlerType, handlerArgs);
					}
					string handlerName = base.MethodNames.AddUnique(text2 + "Completed", text2);
					string methodName = base.MethodNames.AddUnique(text2 + "Async", text2);
					string text4 = base.MethodNames.AddUnique(text2 + "OperationCompleted", text2);
					string callbackName = base.MethodNames.AddUnique("On" + text2 + "OperationCompleted", text2);
					WebCodeGenerator.AddEvent(base.CodeTypeDeclaration.Members, delegateInfo.handlerType, handlerName);
					WebCodeGenerator.AddCallbackDeclaration(base.CodeTypeDeclaration.Members, text4);
					string[] names = SoapParameter.GetNames(soapParameters.InParameters, soapParameters.InCheckSpecifiedCount);
					string text5 = ProtocolImporter.UniqueName("userState", names);
					CodeMemberMethod codeMemberMethod4 = WebCodeGenerator.AddAsyncMethod(base.CodeTypeDeclaration, methodName, SoapParameter.GetTypeFullNames(soapParameters.InParameters, soapParameters.InCheckSpecifiedCount, base.ServiceImporter.CodeGenerator), names, text4, callbackName, text5);
					array2 = new CodeExpression[4];
					CreateInvokeParams(array2, text2, soapParameters.InParameters, soapParameters.InCheckSpecifiedCount);
					array2[2] = new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), text4);
					array2[3] = new CodeArgumentReferenceExpression(text5);
					invoke = new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), "InvokeAsync", array2);
					codeMemberMethod4.Statements.Add(invoke);
					bool flag5 = soapParameters.Return != null || soapParameters.OutParameters.Count > 0;
					WebCodeGenerator.AddCallbackImplementation(base.CodeTypeDeclaration, callbackName, handlerName, delegateInfo.handlerArgs, flag5);
					if (base.ExportContext[key] == null)
					{
						WebCodeGenerator.AddDelegate(base.ExtraCodeClasses, delegateInfo.handlerType, flag5 ? delegateInfo.handlerArgs : typeof(AsyncCompletedEventArgs).FullName);
						if (flag5)
						{
							int num4 = soapParameters.OutParameters.Count + soapParameters.OutCheckSpecifiedCount;
							string[] array8 = new string[num4 + 1];
							SoapParameter.GetTypeFullNames(soapParameters.OutParameters, array8, 1, soapParameters.OutCheckSpecifiedCount, base.ServiceImporter.CodeGenerator);
							array8[0] = ((soapParameters.Return == null) ? null : WebCodeGenerator.FullTypeName(soapParameters.Return, base.ServiceImporter.CodeGenerator));
							string[] array9 = new string[num4 + 1];
							SoapParameter.GetNames(soapParameters.OutParameters, array9, 1, soapParameters.OutCheckSpecifiedCount);
							array9[0] = ((soapParameters.Return == null) ? null : "Result");
							base.ExtraCodeClasses.Add(WebCodeGenerator.CreateArgsClass(delegateInfo.handlerArgs, array8, array9, base.ServiceImporter.CodeGenerator.Supports(GeneratorSupport.PartialTypes)));
						}
						base.ExportContext[key] = delegateInfo;
					}
				}
			}
			return codeMemberMethod;
		}

		private void WriteReturnMappings(CodeMemberMethod codeMethod, CodeExpression invoke, SoapParameters parameters, string resultsName)
		{
			if (parameters.Return == null && parameters.OutParameters.Count == 0)
			{
				codeMethod.Statements.Add(new CodeExpressionStatement(invoke));
				return;
			}
			codeMethod.Statements.Add(new CodeVariableDeclarationStatement(typeof(object[]), resultsName, invoke));
			int num = ((parameters.Return != null) ? 1 : 0);
			for (int i = 0; i < parameters.OutParameters.Count; i++)
			{
				SoapParameter soapParameter = (SoapParameter)parameters.OutParameters[i];
				CodeExpression left = new CodeArgumentReferenceExpression(soapParameter.name);
				CodeExpression codeExpression = new CodeArrayIndexerExpression();
				((CodeArrayIndexerExpression)codeExpression).TargetObject = new CodeVariableReferenceExpression(resultsName);
				((CodeArrayIndexerExpression)codeExpression).Indices.Add(new CodePrimitiveExpression(num++));
				codeExpression = new CodeCastExpression(WebCodeGenerator.FullTypeName(soapParameter.mapping, base.ServiceImporter.CodeGenerator), codeExpression);
				codeMethod.Statements.Add(new CodeAssignStatement(left, codeExpression));
				if (soapParameter.mapping.CheckSpecified)
				{
					left = new CodeArgumentReferenceExpression(soapParameter.name + "Specified");
					codeExpression = new CodeArrayIndexerExpression();
					((CodeArrayIndexerExpression)codeExpression).TargetObject = new CodeVariableReferenceExpression(resultsName);
					((CodeArrayIndexerExpression)codeExpression).Indices.Add(new CodePrimitiveExpression(num++));
					codeExpression = new CodeCastExpression(typeof(bool).FullName, codeExpression);
					codeMethod.Statements.Add(new CodeAssignStatement(left, codeExpression));
				}
			}
			if (parameters.Return != null)
			{
				CodeExpression codeExpression2 = new CodeArrayIndexerExpression();
				((CodeArrayIndexerExpression)codeExpression2).TargetObject = new CodeVariableReferenceExpression(resultsName);
				((CodeArrayIndexerExpression)codeExpression2).Indices.Add(new CodePrimitiveExpression(0));
				codeExpression2 = new CodeCastExpression(WebCodeGenerator.FullTypeName(parameters.Return, base.ServiceImporter.CodeGenerator), codeExpression2);
				codeMethod.Statements.Add(new CodeMethodReturnStatement(codeExpression2));
			}
		}

		private void CreateInvokeParams(CodeExpression[] invokeParams, string methodName, IList parameters, int checkSpecifiedCount)
		{
			invokeParams[0] = new CodePrimitiveExpression(methodName);
			CodeExpression[] array = new CodeExpression[parameters.Count + checkSpecifiedCount];
			int num = 0;
			for (int i = 0; i < parameters.Count; i++)
			{
				SoapParameter soapParameter = (SoapParameter)parameters[i];
				array[num++] = new CodeArgumentReferenceExpression(soapParameter.name);
				if (soapParameter.mapping.CheckSpecified)
				{
					array[num++] = new CodeArgumentReferenceExpression(soapParameter.specifiedName);
				}
			}
			invokeParams[1] = new CodeArrayCreateExpression(typeof(object).FullName, array);
		}

		private bool CheckMessageStyles(string messageName, MessagePart[] parts, SoapBodyBinding soapBodyBinding, SoapBindingStyle soapBindingStyle, out bool hasWrapper)
		{
			hasWrapper = false;
			if (soapBodyBinding.Use == SoapBindingUse.Default)
			{
				soapBodyBinding.Use = SoapBindingUse.Literal;
			}
			if (soapBodyBinding.Use == SoapBindingUse.Literal)
			{
				if (soapBindingStyle == SoapBindingStyle.Rpc)
				{
					foreach (MessagePart messagePart in parts)
					{
						if (!messagePart.Element.IsEmpty)
						{
							UnsupportedOperationBindingWarning(Res.GetString("EachMessagePartInRpcUseLiteralMessageMustSpecify0"));
							return false;
						}
					}
					return true;
				}
				if (parts.Length == 1 && !parts[0].Type.IsEmpty)
				{
					if (!parts[0].Element.IsEmpty)
					{
						UnsupportedOperationBindingWarning(Res.GetString("SpecifyingATypeForUseLiteralMessagesIs0"));
						return false;
					}
					XmlMembersMapping xmlMembersMapping = xmlImporter.ImportAnyType(parts[0].Type, parts[0].Name);
					if (xmlMembersMapping == null)
					{
						UnsupportedOperationBindingWarning(Res.GetString("SpecifyingATypeForUseLiteralMessagesIsAny", parts[0].Type.Name, parts[0].Type.Namespace));
						return false;
					}
					return true;
				}
				foreach (MessagePart messagePart2 in parts)
				{
					if (!messagePart2.Type.IsEmpty)
					{
						UnsupportedOperationBindingWarning(Res.GetString("SpecifyingATypeForUseLiteralMessagesIs0"));
						return false;
					}
					if (messagePart2.Element.IsEmpty)
					{
						UnsupportedOperationBindingWarning(Res.GetString("EachMessagePartInAUseLiteralMessageMustSpecify0"));
						return false;
					}
				}
			}
			else if (soapBodyBinding.Use == SoapBindingUse.Encoded)
			{
				if (!IsSoapEncodingPresent(soapBodyBinding.Encoding))
				{
					UnsupportedOperationBindingWarning(Res.GetString("TheEncodingIsNotSupported1", soapBodyBinding.Encoding));
					return false;
				}
				foreach (MessagePart messagePart3 in parts)
				{
					if (!messagePart3.Element.IsEmpty)
					{
						UnsupportedOperationBindingWarning(Res.GetString("SpecifyingAnElementForUseEncodedMessageParts0"));
						return false;
					}
					if (messagePart3.Type.IsEmpty)
					{
						UnsupportedOperationBindingWarning(Res.GetString("EachMessagePartInAnUseEncodedMessageMustSpecify0"));
						return false;
					}
				}
			}
			switch (soapBindingStyle)
			{
			case SoapBindingStyle.Rpc:
				return true;
			case SoapBindingStyle.Document:
				hasWrapper = parts.Length == 1 && string.Compare(parts[0].Name, "parameters", StringComparison.Ordinal) == 0;
				return true;
			default:
				return false;
			}
		}

		protected virtual bool IsSoapEncodingPresent(string uriList)
		{
			int num = 0;
			do
			{
				num = uriList.IndexOf("http://schemas.xmlsoap.org/soap/encoding/", num, StringComparison.Ordinal);
				if (num < 0)
				{
					return false;
				}
				int num2 = num + "http://schemas.xmlsoap.org/soap/encoding/".Length;
				if ((num == 0 || uriList[num - 1] == ' ') && (num2 == uriList.Length || uriList[num2] == ' '))
				{
					return true;
				}
				num = num2;
			}
			while (num < uriList.Length);
			return false;
		}

		private MessagePart[] GetMessageParts(Message message, SoapBodyBinding soapBodyBinding)
		{
			MessagePart[] array;
			if (soapBodyBinding.Parts == null)
			{
				array = new MessagePart[message.Parts.Count];
				message.Parts.CopyTo(array, 0);
			}
			else
			{
				array = message.FindPartsByName(soapBodyBinding.Parts);
			}
			return array;
		}

		private XmlMembersMapping ImportMessage(string messageName, MessagePart[] parts, SoapBodyBinding soapBodyBinding, SoapBindingStyle soapBindingStyle, bool wrapped)
		{
			if (soapBodyBinding.Use == SoapBindingUse.Encoded)
			{
				return ImportEncodedMessage(messageName, parts, soapBodyBinding, wrapped);
			}
			return ImportLiteralMessage(messageName, parts, soapBodyBinding, soapBindingStyle, wrapped);
		}

		private XmlMembersMapping ImportEncodedMessage(string messageName, MessagePart[] parts, SoapBodyBinding soapBodyBinding, bool wrapped)
		{
			XmlMembersMapping xmlMembersMapping;
			if (wrapped)
			{
				SoapSchemaMember soapSchemaMember = new SoapSchemaMember();
				soapSchemaMember.MemberName = parts[0].Name;
				soapSchemaMember.MemberType = parts[0].Type;
				xmlMembersMapping = soapImporter.ImportMembersMapping(messageName, soapBodyBinding.Namespace, soapSchemaMember);
			}
			else
			{
				SoapSchemaMember[] array = new SoapSchemaMember[parts.Length];
				for (int i = 0; i < array.Length; i++)
				{
					MessagePart messagePart = parts[i];
					SoapSchemaMember soapSchemaMember2 = new SoapSchemaMember();
					soapSchemaMember2.MemberName = messagePart.Name;
					soapSchemaMember2.MemberType = messagePart.Type;
					array[i] = soapSchemaMember2;
				}
				xmlMembersMapping = soapImporter.ImportMembersMapping(messageName, soapBodyBinding.Namespace, array);
			}
			soapMembers.Add(xmlMembersMapping);
			return xmlMembersMapping;
		}

		private XmlMembersMapping ImportLiteralMessage(string messageName, MessagePart[] parts, SoapBodyBinding soapBodyBinding, SoapBindingStyle soapBindingStyle, bool wrapped)
		{
			XmlMembersMapping xmlMembersMapping;
			if (soapBindingStyle == SoapBindingStyle.Rpc)
			{
				SoapSchemaMember[] array = new SoapSchemaMember[parts.Length];
				for (int i = 0; i < array.Length; i++)
				{
					MessagePart messagePart = parts[i];
					SoapSchemaMember soapSchemaMember = new SoapSchemaMember();
					soapSchemaMember.MemberName = messagePart.Name;
					soapSchemaMember.MemberType = messagePart.Type;
					array[i] = soapSchemaMember;
				}
				xmlMembersMapping = xmlImporter.ImportMembersMapping(messageName, soapBodyBinding.Namespace, array);
			}
			else if (wrapped)
			{
				xmlMembersMapping = xmlImporter.ImportMembersMapping(parts[0].Element);
			}
			else
			{
				if (parts.Length == 1 && !parts[0].Type.IsEmpty)
				{
					xmlMembersMapping = xmlImporter.ImportAnyType(parts[0].Type, parts[0].Name);
					xmlMembers.Add(xmlMembersMapping);
					return xmlMembersMapping;
				}
				XmlQualifiedName[] array2 = new XmlQualifiedName[parts.Length];
				for (int j = 0; j < parts.Length; j++)
				{
					array2[j] = parts[j].Element;
				}
				xmlMembersMapping = xmlImporter.ImportMembersMapping(array2);
			}
			xmlMembers.Add(xmlMembersMapping);
			return xmlMembersMapping;
		}
	}
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	internal class Soap12ProtocolImporter : SoapProtocolImporter
	{
		public override string ProtocolName => "Soap12";

		protected override bool IsBindingSupported()
		{
			Soap12Binding soap12Binding = (Soap12Binding)base.Binding.Extensions.Find(typeof(Soap12Binding));
			if (soap12Binding == null)
			{
				return false;
			}
			if (GetTransport(soap12Binding.Transport) == null)
			{
				UnsupportedBindingWarning(Res.GetString("ThereIsNoSoapTransportImporterThatUnderstands1", soap12Binding.Transport));
				return false;
			}
			return true;
		}

		protected override bool IsSoapEncodingPresent(string uriList)
		{
			int num = 0;
			do
			{
				num = uriList.IndexOf("http://www.w3.org/2003/05/soap-encoding", num, StringComparison.Ordinal);
				if (num < 0)
				{
					break;
				}
				int num2 = num + "http://www.w3.org/2003/05/soap-encoding".Length;
				if ((num == 0 || uriList[num - 1] == ' ') && (num2 == uriList.Length || uriList[num2] == ' '))
				{
					return true;
				}
				num = num2;
			}
			while (num < uriList.Length);
			if (base.IsSoapEncodingPresent(uriList))
			{
				UnsupportedOperationBindingWarning(Res.GetString("WebSoap11EncodingStyleNotSupported1", "http://www.w3.org/2003/05/soap-encoding"));
			}
			return false;
		}
	}
	internal class SoapProtocolReflector : ProtocolReflector
	{
		private ArrayList mappings = new ArrayList();

		private SoapExtensionReflector[] extensions;

		private SoapReflectedMethod soapMethod;

		internal override WsiProfiles ConformsTo => WsiProfiles.BasicProfile1_1;

		public override string ProtocolName => "Soap";

		internal SoapReflectedMethod SoapMethod => soapMethod;

		internal SoapReflectionImporter SoapImporter
		{
			get
			{
				SoapReflectionImporter soapReflectionImporter = base.ReflectionContext[typeof(SoapReflectionImporter)] as SoapReflectionImporter;
				if (soapReflectionImporter == null)
				{
					soapReflectionImporter = SoapReflector.CreateSoapImporter(base.DefaultNamespace, SoapReflector.ServiceDefaultIsEncoded(base.ServiceType));
					base.ReflectionContext[typeof(SoapReflectionImporter)] = soapReflectionImporter;
				}
				return soapReflectionImporter;
			}
		}

		internal SoapSchemaExporter SoapExporter
		{
			get
			{
				SoapSchemaExporter soapSchemaExporter = base.ReflectionContext[typeof(SoapSchemaExporter)] as SoapSchemaExporter;
				if (soapSchemaExporter == null)
				{
					soapSchemaExporter = new SoapSchemaExporter(base.ServiceDescription.Types.Schemas);
					base.ReflectionContext[typeof(SoapSchemaExporter)] = soapSchemaExporter;
				}
				return soapSchemaExporter;
			}
		}

		protected override bool ReflectMethod()
		{
			soapMethod = base.ReflectionContext[base.Method] as SoapReflectedMethod;
			if (soapMethod == null)
			{
				soapMethod = SoapReflector.ReflectMethod(base.Method, client: false, base.ReflectionImporter, SoapImporter, base.DefaultNamespace);
				base.ReflectionContext[base.Method] = soapMethod;
				soapMethod.portType = ((base.Binding != null) ? base.Binding.Type : null);
			}
			_ = base.Method.MethodAttribute;
			base.OperationBinding.Extensions.Add(CreateSoapOperationBinding((!soapMethod.rpc) ? SoapBindingStyle.Document : SoapBindingStyle.Rpc, soapMethod.action));
			CreateMessage(soapMethod.rpc, soapMethod.use, soapMethod.paramStyle, base.InputMessage, base.OperationBinding.Input, soapMethod.requestMappings);
			if (!soapMethod.oneWay)
			{
				CreateMessage(soapMethod.rpc, soapMethod.use, soapMethod.paramStyle, base.OutputMessage, base.OperationBinding.Output, soapMethod.responseMappings);
			}
			CreateHeaderMessages(soapMethod.name, soapMethod.use, soapMethod.inHeaderMappings, soapMethod.outHeaderMappings, soapMethod.headers, soapMethod.rpc);
			if (soapMethod.rpc && soapMethod.use == SoapBindingUse.Encoded && soapMethod.methodInfo.OutParameters.Length > 0)
			{
				base.Operation.ParameterOrder = GetParameterOrder(soapMethod.methodInfo);
			}
			AllowExtensionsToReflectMethod();
			return true;
		}

		protected override void ReflectDescription()
		{
			AllowExtensionsToReflectDescription();
		}

		private void CreateHeaderMessages(string methodName, SoapBindingUse use, XmlMembersMapping inHeaderMappings, XmlMembersMapping outHeaderMappings, SoapReflectedHeader[] headers, bool rpc)
		{
			if (use == SoapBindingUse.Encoded)
			{
				SoapExporter.ExportMembersMapping(inHeaderMappings, exportEnclosingType: false);
				if (outHeaderMappings != null)
				{
					SoapExporter.ExportMembersMapping(outHeaderMappings, exportEnclosingType: false);
				}
			}
			else
			{
				base.SchemaExporter.ExportMembersMapping(inHeaderMappings);
				if (outHeaderMappings != null)
				{
					base.SchemaExporter.ExportMembersMapping(outHeaderMappings);
				}
			}
			CodeIdentifiers codeIdentifiers = new CodeIdentifiers();
			int num = 0;
			int num2 = 0;
			foreach (SoapReflectedHeader soapReflectedHeader in headers)
			{
				if (!soapReflectedHeader.custom)
				{
					continue;
				}
				XmlMemberMapping xmlMemberMapping;
				if ((soapReflectedHeader.direction & SoapHeaderDirection.In) != 0)
				{
					xmlMemberMapping = inHeaderMappings[num++];
					if (soapReflectedHeader.direction != SoapHeaderDirection.In)
					{
						num2++;
					}
				}
				else
				{
					xmlMemberMapping = outHeaderMappings[num2++];
				}
				MessagePart messagePart = new MessagePart();
				messagePart.Name = xmlMemberMapping.XsdElementName;
				if (use == SoapBindingUse.Encoded)
				{
					messagePart.Type = new XmlQualifiedName(xmlMemberMapping.TypeName, xmlMemberMapping.TypeNamespace);
				}
				else
				{
					messagePart.Element = new XmlQualifiedName(xmlMemberMapping.XsdElementName, xmlMemberMapping.Namespace);
				}
				Message message = new Message();
				message.Name = codeIdentifiers.AddUnique(methodName + messagePart.Name, message);
				message.Parts.Add(messagePart);
				base.HeaderMessages.Add(message);
				ServiceDescriptionFormatExtension extension = CreateSoapHeaderBinding(new XmlQualifiedName(message.Name, base.Binding.ServiceDescription.TargetNamespace), messagePart.Name, rpc ? xmlMemberMapping.Namespace : null, use);
				if ((soapReflectedHeader.direction & SoapHeaderDirection.In) != 0)
				{
					base.OperationBinding.Input.Extensions.Add(extension);
				}
				if ((soapReflectedHeader.direction & SoapHeaderDirection.Out) != 0)
				{
					base.OperationBinding.Output.Extensions.Add(extension);
				}
				if ((soapReflectedHeader.direction & SoapHeaderDirection.Fault) != 0)
				{
					if (soapMethod.IsClaimsConformance)
					{
						throw new InvalidOperationException(Res.GetString("BPConformanceHeaderFault", soapMethod.methodInfo.ToString(), soapMethod.methodInfo.DeclaringType.FullName, "Direction", typeof(SoapHeaderDirection).Name, SoapHeaderDirection.Fault.ToString()));
					}
					base.OperationBinding.Output.Extensions.Add(extension);
				}
			}
		}

		private void CreateMessage(bool rpc, SoapBindingUse use, SoapParameterStyle paramStyle, Message message, MessageBinding messageBinding, XmlMembersMapping members)
		{
			bool flag = paramStyle != SoapParameterStyle.Bare;
			if (use == SoapBindingUse.Encoded)
			{
				CreateEncodedMessage(message, messageBinding, members, flag && !rpc);
			}
			else
			{
				CreateLiteralMessage(message, messageBinding, members, flag && !rpc, rpc);
			}
		}

		private void CreateEncodedMessage(Message message, MessageBinding messageBinding, XmlMembersMapping members, bool wrapped)
		{
			SoapExporter.ExportMembersMapping(members, wrapped);
			if (wrapped)
			{
				MessagePart messagePart = new MessagePart();
				messagePart.Name = "parameters";
				messagePart.Type = new XmlQualifiedName(members.TypeName, members.TypeNamespace);
				message.Parts.Add(messagePart);
			}
			else
			{
				for (int i = 0; i < members.Count; i++)
				{
					XmlMemberMapping xmlMemberMapping = members[i];
					MessagePart messagePart2 = new MessagePart();
					messagePart2.Name = xmlMemberMapping.XsdElementName;
					messagePart2.Type = new XmlQualifiedName(xmlMemberMapping.TypeName, xmlMemberMapping.TypeNamespace);
					message.Parts.Add(messagePart2);
				}
			}
			messageBinding.Extensions.Add(CreateSoapBodyBinding(SoapBindingUse.Encoded, members.Namespace));
		}

		private void CreateLiteralMessage(Message message, MessageBinding messageBinding, XmlMembersMapping members, bool wrapped, bool rpc)
		{
			if (members.Count == 1 && members[0].Any && members[0].ElementName.Length == 0 && !wrapped)
			{
				string name = base.SchemaExporter.ExportAnyType(members[0].Namespace);
				MessagePart messagePart = new MessagePart();
				messagePart.Name = members[0].MemberName;
				messagePart.Type = new XmlQualifiedName(name, members[0].Namespace);
				message.Parts.Add(messagePart);
			}
			else
			{
				base.SchemaExporter.ExportMembersMapping(members, !rpc);
				if (wrapped)
				{
					MessagePart messagePart2 = new MessagePart();
					messagePart2.Name = "parameters";
					messagePart2.Element = new XmlQualifiedName(members.XsdElementName, members.Namespace);
					message.Parts.Add(messagePart2);
				}
				else
				{
					for (int i = 0; i < members.Count; i++)
					{
						XmlMemberMapping xmlMemberMapping = members[i];
						MessagePart messagePart3 = new MessagePart();
						if (rpc)
						{
							if (xmlMemberMapping.TypeName == null || xmlMemberMapping.TypeName.Length == 0)
							{
								throw new InvalidOperationException(Res.GetString("WsdlGenRpcLitAnonimousType", base.Method.DeclaringType.Name, base.Method.Name, xmlMemberMapping.MemberName));
							}
							messagePart3.Name = xmlMemberMapping.XsdElementName;
							messagePart3.Type = new XmlQualifiedName(xmlMemberMapping.TypeName, xmlMemberMapping.TypeNamespace);
						}
						else
						{
							messagePart3.Name = XmlConvert.EncodeLocalName(xmlMemberMapping.MemberName);
							messagePart3.Element = new XmlQualifiedName(xmlMemberMapping.XsdElementName, xmlMemberMapping.Namespace);
						}
						message.Parts.Add(messagePart3);
					}
				}
			}
			messageBinding.Extensions.Add(CreateSoapBodyBinding(SoapBindingUse.Literal, rpc ? members.Namespace : null));
		}

		private static string[] GetParameterOrder(LogicalMethodInfo methodInfo)
		{
			ParameterInfo[] parameters = methodInfo.Parameters;
			string[] array = new string[parameters.Length];
			for (int i = 0; i < parameters.Length; i++)
			{
				array[i] = parameters[i].Name;
			}
			return array;
		}

		protected override string ReflectMethodBinding()
		{
			return SoapReflector.GetSoapMethodBinding(base.Method);
		}

		protected override void BeginClass()
		{
			if (base.Binding != null)
			{
				SoapBindingStyle style = ((!(SoapReflector.GetSoapServiceAttribute(base.ServiceType) is SoapRpcServiceAttribute)) ? SoapBindingStyle.Document : SoapBindingStyle.Rpc);
				base.Binding.Extensions.Add(CreateSoapBinding(style));
				SoapReflector.IncludeTypes(base.Methods, SoapImporter);
			}
			base.Port.Extensions.Add(CreateSoapAddressBinding(base.ServiceUrl));
		}

		private void AllowExtensionsToReflectMethod()
		{
			if (extensions == null)
			{
				TypeElementCollection soapExtensionReflectorTypes = WebServicesSection.Current.SoapExtensionReflectorTypes;
				extensions = new SoapExtensionReflector[soapExtensionReflectorTypes.Count];
				for (int i = 0; i < extensions.Length; i++)
				{
					SoapExtensionReflector soapExtensionReflector = (SoapExtensionReflector)Activator.CreateInstance(soapExtensionReflectorTypes[i].Type);
					soapExtensionReflector.ReflectionContext = this;
					extensions[i] = soapExtensionReflector;
				}
			}
			SoapExtensionReflector[] array = extensions;
			foreach (SoapExtensionReflector soapExtensionReflector2 in array)
			{
				soapExtensionReflector2.ReflectMethod();
			}
		}

		private void AllowExtensionsToReflectDescription()
		{
			if (extensions == null)
			{
				TypeElementCollection soapExtensionReflectorTypes = WebServicesSection.Current.SoapExtensionReflectorTypes;
				extensions = new SoapExtensionReflector[soapExtensionReflectorTypes.Count];
				for (int i = 0; i < extensions.Length; i++)
				{
					SoapExtensionReflector soapExtensionReflector = (SoapExtensionReflector)Activator.CreateInstance(soapExtensionReflectorTypes[i].Type);
					soapExtensionReflector.ReflectionContext = this;
					extensions[i] = soapExtensionReflector;
				}
			}
			SoapExtensionReflector[] array = extensions;
			foreach (SoapExtensionReflector soapExtensionReflector2 in array)
			{
				soapExtensionReflector2.ReflectDescription();
			}
		}

		protected virtual SoapBinding CreateSoapBinding(SoapBindingStyle style)
		{
			SoapBinding soapBinding = new SoapBinding();
			soapBinding.Transport = "http://schemas.xmlsoap.org/soap/http";
			soapBinding.Style = style;
			return soapBinding;
		}

		protected virtual SoapAddressBinding CreateSoapAddressBinding(string serviceUrl)
		{
			SoapAddressBinding soapAddressBinding = new SoapAddressBinding();
			soapAddressBinding.Location = serviceUrl;
			return soapAddressBinding;
		}

		protected virtual SoapOperationBinding CreateSoapOperationBinding(SoapBindingStyle style, string action)
		{
			SoapOperationBinding soapOperationBinding = new SoapOperationBinding();
			soapOperationBinding.SoapAction = action;
			soapOperationBinding.Style = style;
			return soapOperationBinding;
		}

		protected virtual SoapBodyBinding CreateSoapBodyBinding(SoapBindingUse use, string ns)
		{
			SoapBodyBinding soapBodyBinding = new SoapBodyBinding();
			soapBodyBinding.Use = use;
			if (use == SoapBindingUse.Encoded)
			{
				soapBodyBinding.Encoding = "http://schemas.xmlsoap.org/soap/encoding/";
			}
			soapBodyBinding.Namespace = ns;
			return soapBodyBinding;
		}

		protected virtual SoapHeaderBinding CreateSoapHeaderBinding(XmlQualifiedName message, string partName, SoapBindingUse use)
		{
			return CreateSoapHeaderBinding(message, partName, null, use);
		}

		protected virtual SoapHeaderBinding CreateSoapHeaderBinding(XmlQualifiedName message, string partName, string ns, SoapBindingUse use)
		{
			SoapHeaderBinding soapHeaderBinding = new SoapHeaderBinding();
			soapHeaderBinding.Message = message;
			soapHeaderBinding.Part = partName;
			soapHeaderBinding.Use = use;
			if (use == SoapBindingUse.Encoded)
			{
				soapHeaderBinding.Encoding = "http://schemas.xmlsoap.org/soap/encoding/";
				soapHeaderBinding.Namespace = ns;
			}
			return soapHeaderBinding;
		}
	}
	internal class Soap12ProtocolReflector : SoapProtocolReflector
	{
		private Hashtable requestElements;

		private Hashtable actions;

		private XmlQualifiedName soap11PortType;

		internal override WsiProfiles ConformsTo => WsiProfiles.None;

		public override string ProtocolName => "Soap12";

		protected override void BeginClass()
		{
			requestElements = new Hashtable();
			actions = new Hashtable();
			soap11PortType = null;
			base.BeginClass();
		}

		protected override bool ReflectMethod()
		{
			if (base.ReflectMethod())
			{
				if (base.Binding != null)
				{
					soap11PortType = base.SoapMethod.portType;
					if (soap11PortType != base.Binding.Type)
					{
						base.HeaderMessages.Clear();
					}
				}
				return true;
			}
			return false;
		}

		protected override void EndClass()
		{
			if (base.PortType == null || base.Binding == null || !(soap11PortType != null) || !(soap11PortType != base.Binding.Type))
			{
				return;
			}
			foreach (Operation operation in base.PortType.Operations)
			{
				foreach (OperationMessage message2 in operation.Messages)
				{
					ServiceDescription serviceDescription = GetServiceDescription(message2.Message.Namespace);
					if (serviceDescription != null)
					{
						Message message = serviceDescription.Messages[message2.Message.Name];
						if (message != null)
						{
							serviceDescription.Messages.Remove(message);
						}
					}
				}
			}
			base.Binding.Type = soap11PortType;
			base.PortType.ServiceDescription.PortTypes.Remove(base.PortType);
		}

		protected override SoapBinding CreateSoapBinding(SoapBindingStyle style)
		{
			Soap12Binding soap12Binding = new Soap12Binding();
			soap12Binding.Transport = "http://schemas.xmlsoap.org/soap/http";
			soap12Binding.Style = style;
			return soap12Binding;
		}

		protected override SoapAddressBinding CreateSoapAddressBinding(string serviceUrl)
		{
			Soap12AddressBinding soap12AddressBinding = new Soap12AddressBinding();
			soap12AddressBinding.Location = serviceUrl;
			return soap12AddressBinding;
		}

		protected override SoapOperationBinding CreateSoapOperationBinding(SoapBindingStyle style, string action)
		{
			Soap12OperationBinding soap12OperationBinding = new Soap12OperationBinding();
			soap12OperationBinding.SoapAction = action;
			soap12OperationBinding.Style = style;
			soap12OperationBinding.Method = base.SoapMethod;
			DealWithAmbiguity(action, base.SoapMethod.requestElementName.ToString(), soap12OperationBinding);
			return soap12OperationBinding;
		}

		protected override SoapBodyBinding CreateSoapBodyBinding(SoapBindingUse use, string ns)
		{
			Soap12BodyBinding soap12BodyBinding = new Soap12BodyBinding();
			soap12BodyBinding.Use = use;
			if (use == SoapBindingUse.Encoded)
			{
				soap12BodyBinding.Encoding = "http://www.w3.org/2003/05/soap-encoding";
			}
			soap12BodyBinding.Namespace = ns;
			return soap12BodyBinding;
		}

		protected override SoapHeaderBinding CreateSoapHeaderBinding(XmlQualifiedName message, string partName, SoapBindingUse use)
		{
			return CreateSoapHeaderBinding(message, partName, null, use);
		}

		protected override SoapHeaderBinding CreateSoapHeaderBinding(XmlQualifiedName message, string partName, string ns, SoapBindingUse use)
		{
			Soap12HeaderBinding soap12HeaderBinding = new Soap12HeaderBinding();
			soap12HeaderBinding.Message = message;
			soap12HeaderBinding.Part = partName;
			soap12HeaderBinding.Namespace = ns;
			soap12HeaderBinding.Use = use;
			if (use == SoapBindingUse.Encoded)
			{
				soap12HeaderBinding.Encoding = "http://www.w3.org/2003/05/soap-encoding";
			}
			return soap12HeaderBinding;
		}

		private void DealWithAmbiguity(string action, string requestElement, Soap12OperationBinding operation)
		{
			Soap12OperationBinding soap12OperationBinding = (Soap12OperationBinding)actions[action];
			if (soap12OperationBinding != null)
			{
				operation.DuplicateBySoapAction = soap12OperationBinding;
				soap12OperationBinding.DuplicateBySoapAction = operation;
				CheckOperationDuplicates(soap12OperationBinding);
			}
			else
			{
				actions[action] = operation;
			}
			Soap12OperationBinding soap12OperationBinding2 = (Soap12OperationBinding)requestElements[requestElement];
			if (soap12OperationBinding2 != null)
			{
				operation.DuplicateByRequestElement = soap12OperationBinding2;
				soap12OperationBinding2.DuplicateByRequestElement = operation;
				CheckOperationDuplicates(soap12OperationBinding2);
			}
			else
			{
				requestElements[requestElement] = operation;
			}
			CheckOperationDuplicates(operation);
		}

		private void CheckOperationDuplicates(Soap12OperationBinding operation)
		{
			if (operation.DuplicateByRequestElement != null)
			{
				if (operation.DuplicateBySoapAction != null)
				{
					throw new InvalidOperationException(Res.GetString("TheMethodsAndUseTheSameRequestElementAndSoapActionXmlns6", operation.Method.name, operation.DuplicateByRequestElement.Method.name, operation.Method.requestElementName.Name, operation.Method.requestElementName.Namespace, operation.DuplicateBySoapAction.Method.name, operation.Method.action));
				}
				operation.SoapActionRequired = true;
			}
			else
			{
				operation.SoapActionRequired = false;
			}
		}
	}
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	public abstract class SoapExtensionImporter
	{
		private SoapProtocolImporter protocolImporter;

		public SoapProtocolImporter ImportContext
		{
			get
			{
				return protocolImporter;
			}
			set
			{
				protocolImporter = value;
			}
		}

		public abstract void ImportMethod(CodeAttributeDeclarationCollection metadata);
	}
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	public abstract class SoapExtensionReflector
	{
		private ProtocolReflector protocolReflector;

		public ProtocolReflector ReflectionContext
		{
			get
			{
				return protocolReflector;
			}
			set
			{
				protocolReflector = value;
			}
		}

		public abstract void ReflectMethod();

		public virtual void ReflectDescription()
		{
		}
	}
	public enum SoapBindingStyle
	{
		[XmlIgnore]
		Default,
		[XmlEnum("document")]
		Document,
		[XmlEnum("rpc")]
		Rpc
	}
	public enum SoapBindingUse
	{
		[XmlIgnore]
		Default,
		[XmlEnum("encoded")]
		Encoded,
		[XmlEnum("literal")]
		Literal
	}
	public class SoapHeaderFaultBinding : ServiceDescriptionFormatExtension
	{
		private XmlQualifiedName message = XmlQualifiedName.Empty;

		private string part;

		private SoapBindingUse use;

		private string encoding;

		private string ns;

		[XmlAttribute("message")]
		public XmlQualifiedName Message
		{
			get
			{
				return message;
			}
			set
			{
				message = value;
			}
		}

		[XmlAttribute("part")]
		public string Part
		{
			get
			{
				return part;
			}
			set
			{
				part = value;
			}
		}

		[XmlAttribute("use")]
		[DefaultValue(SoapBindingUse.Default)]
		public SoapBindingUse Use
		{
			get
			{
				return use;
			}
			set
			{
				use = value;
			}
		}

		[DefaultValue("")]
		[XmlAttribute("encodingStyle")]
		public string Encoding
		{
			get
			{
				if (encoding != null)
				{
					return encoding;
				}
				return string.Empty;
			}
			set
			{
				encoding = value;
			}
		}

		[DefaultValue("")]
		[XmlAttribute("namespace")]
		public string Namespace
		{
			get
			{
				if (ns != null)
				{
					return ns;
				}
				return string.Empty;
			}
			set
			{
				ns = value;
			}
		}
	}
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	public abstract class SoapTransportImporter
	{
		private SoapProtocolImporter protocolImporter;

		public SoapProtocolImporter ImportContext
		{
			get
			{
				return protocolImporter;
			}
			set
			{
				protocolImporter = value;
			}
		}

		public abstract bool IsSupportedTransport(string transport);

		public abstract void ImportClass();
	}
	internal class SoapHttpTransportImporter : SoapTransportImporter
	{
		public override bool IsSupportedTransport(string transport)
		{
			return transport == "http://schemas.xmlsoap.org/soap/http";
		}

		public override void ImportClass()
		{
			SoapAddressBinding soapAddressBinding = ((base.ImportContext.Port == null) ? null : ((SoapAddressBinding)base.ImportContext.Port.Extensions.Find(typeof(SoapAddressBinding))));
			if (base.ImportContext.Style == ServiceDescriptionImportStyle.Client)
			{
				base.ImportContext.CodeTypeDeclaration.BaseTypes.Add(typeof(SoapHttpClientProtocol).FullName);
				CodeConstructor codeConstructor = WebCodeGenerator.AddConstructor(base.ImportContext.CodeTypeDeclaration, new string[0], new string[0], null, CodeFlags.IsPublic);
				codeConstructor.Comments.Add(new CodeCommentStatement(Res.GetString("CodeRemarks"), docComment: true));
				bool flag = true;
				if (base.ImportContext is Soap12ProtocolImporter)
				{
					flag = false;
					CodeTypeReferenceExpression targetObject = new CodeTypeReferenceExpression(typeof(SoapProtocolVersion));
					CodeFieldReferenceExpression right = new CodeFieldReferenceExpression(targetObject, Enum.Format(typeof(SoapProtocolVersion), SoapProtocolVersion.Soap12, "G"));
					CodePropertyReferenceExpression left = new CodePropertyReferenceExpression(new CodeThisReferenceExpression(), "SoapVersion");
					CodeAssignStatement value = new CodeAssignStatement(left, right);
					codeConstructor.Statements.Add(value);
				}
				ServiceDescription serviceDescription = base.ImportContext.Binding.ServiceDescription;
				string url = soapAddressBinding?.Location;
				string appSettingUrlKey = serviceDescription.AppSettingUrlKey;
				string appSettingBaseUrl = serviceDescription.AppSettingBaseUrl;
				ProtocolImporterUtil.GenerateConstructorStatements(codeConstructor, url, appSettingUrlKey, appSettingBaseUrl, flag && !base.ImportContext.IsEncodedBinding);
			}
			else if (base.ImportContext.Style == ServiceDescriptionImportStyle.Server)
			{
				base.ImportContext.CodeTypeDeclaration.BaseTypes.Add(typeof(WebService).FullName);
			}
		}
	}
	internal class SoapParameters
	{
		private XmlMemberMapping ret;

		private ArrayList parameters = new ArrayList();

		private ArrayList inParameters = new ArrayList();

		private ArrayList outParameters = new ArrayList();

		private int checkSpecifiedCount;

		private int inCheckSpecifiedCount;

		private int outCheckSpecifiedCount;

		internal XmlMemberMapping Return => ret;

		internal IList Parameters => parameters;

		internal IList InParameters => inParameters;

		internal IList OutParameters => outParameters;

		internal int CheckSpecifiedCount => checkSpecifiedCount;

		internal int InCheckSpecifiedCount => inCheckSpecifiedCount;

		internal int OutCheckSpecifiedCount => outCheckSpecifiedCount;

		internal SoapParameters(XmlMembersMapping request, XmlMembersMapping response, string[] parameterOrder, CodeIdentifiers identifiers)
		{
			ArrayList arrayList = new ArrayList();
			ArrayList arrayList2 = new ArrayList();
			AddMappings(arrayList, request);
			if (response != null)
			{
				AddMappings(arrayList2, response);
			}
			if (parameterOrder != null)
			{
				foreach (string elementName in parameterOrder)
				{
					XmlMemberMapping xmlMemberMapping = FindMapping(arrayList, elementName);
					SoapParameter soapParameter = new SoapParameter();
					if (xmlMemberMapping != null)
					{
						if (RemoveByRefMapping(arrayList2, xmlMemberMapping))
						{
							soapParameter.codeFlags = CodeFlags.IsByRef;
						}
						soapParameter.mapping = xmlMemberMapping;
						arrayList.Remove(xmlMemberMapping);
						AddParameter(soapParameter);
						continue;
					}
					XmlMemberMapping xmlMemberMapping2 = FindMapping(arrayList2, elementName);
					if (xmlMemberMapping2 != null)
					{
						soapParameter.codeFlags = CodeFlags.IsOut;
						soapParameter.mapping = xmlMemberMapping2;
						arrayList2.Remove(xmlMemberMapping2);
						AddParameter(soapParameter);
					}
				}
			}
			foreach (XmlMemberMapping item in arrayList)
			{
				SoapParameter soapParameter2 = new SoapParameter();
				if (RemoveByRefMapping(arrayList2, item))
				{
					soapParameter2.codeFlags = CodeFlags.IsByRef;
				}
				soapParameter2.mapping = item;
				AddParameter(soapParameter2);
			}
			if (arrayList2.Count > 0)
			{
				if (!((XmlMemberMapping)arrayList2[0]).CheckSpecified)
				{
					ret = (XmlMemberMapping)arrayList2[0];
					arrayList2.RemoveAt(0);
				}
				foreach (XmlMemberMapping item2 in arrayList2)
				{
					AddParameter(new SoapParameter
					{
						mapping = item2,
						codeFlags = CodeFlags.IsOut
					});
				}
			}
			foreach (SoapParameter parameter in parameters)
			{
				parameter.name = identifiers.MakeUnique(CodeIdentifier.MakeValid(parameter.mapping.MemberName));
			}
		}

		private void AddParameter(SoapParameter parameter)
		{
			parameters.Add(parameter);
			if (parameter.mapping.CheckSpecified)
			{
				checkSpecifiedCount++;
			}
			if (parameter.IsByRef)
			{
				inParameters.Add(parameter);
				outParameters.Add(parameter);
				if (parameter.mapping.CheckSpecified)
				{
					inCheckSpecifiedCount++;
					outCheckSpecifiedCount++;
				}
			}
			else if (parameter.IsOut)
			{
				outParameters.Add(parameter);
				if (parameter.mapping.CheckSpecified)
				{
					outCheckSpecifiedCount++;
				}
			}
			else
			{
				inParameters.Add(parameter);
				if (parameter.mapping.CheckSpecified)
				{
					inCheckSpecifiedCount++;
				}
			}
		}

		private static bool RemoveByRefMapping(ArrayList responseList, XmlMemberMapping requestMapping)
		{
			XmlMemberMapping xmlMemberMapping = FindMapping(responseList, requestMapping.ElementName);
			if (xmlMemberMapping == null)
			{
				return false;
			}
			if (requestMapping.TypeFullName != xmlMemberMapping.TypeFullName)
			{
				return false;
			}
			if (requestMapping.Namespace != xmlMemberMapping.Namespace)
			{
				return false;
			}
			if (requestMapping.MemberName != xmlMemberMapping.MemberName)
			{
				return false;
			}
			responseList.Remove(xmlMemberMapping);
			return true;
		}

		private static void AddMappings(ArrayList mappingsList, XmlMembersMapping mappings)
		{
			for (int i = 0; i < mappings.Count; i++)
			{
				mappingsList.Add(mappings[i]);
			}
		}

		private static XmlMemberMapping FindMapping(ArrayList mappingsList, string elementName)
		{
			foreach (XmlMemberMapping mappings in mappingsList)
			{
				if (mappings.ElementName == elementName)
				{
					return mappings;
				}
			}
			return null;
		}
	}
	internal class SoapParameter
	{
		internal CodeFlags codeFlags;

		internal string name;

		internal XmlMemberMapping mapping;

		internal string specifiedName;

		internal bool IsOut => (codeFlags & CodeFlags.IsOut) != 0;

		internal bool IsByRef => (codeFlags & CodeFlags.IsByRef) != 0;

		internal static string[] GetTypeFullNames(IList parameters, int specifiedCount, CodeDomProvider codeProvider)
		{
			string[] array = new string[parameters.Count + specifiedCount];
			GetTypeFullNames(parameters, array, 0, specifiedCount, codeProvider);
			return array;
		}

		internal static void GetTypeFullNames(IList parameters, string[] typeFullNames, int start, int specifiedCount, CodeDomProvider codeProvider)
		{
			int num = 0;
			for (int i = 0; i < parameters.Count; i++)
			{
				typeFullNames[i + start + num] = WebCodeGenerator.FullTypeName(((SoapParameter)parameters[i]).mapping, codeProvider);
				if (((SoapParameter)parameters[i]).mapping.CheckSpecified)
				{
					num++;
					typeFullNames[i + start + num] = typeof(bool).FullName;
				}
			}
		}

		internal static string[] GetNames(IList parameters, int specifiedCount)
		{
			string[] array = new string[parameters.Count + specifiedCount];
			GetNames(parameters, array, 0, specifiedCount);
			return array;
		}

		internal static void GetNames(IList parameters, string[] names, int start, int specifiedCount)
		{
			int num = 0;
			for (int i = 0; i < parameters.Count; i++)
			{
				names[i + start + num] = ((SoapParameter)parameters[i]).name;
				if (((SoapParameter)parameters[i]).mapping.CheckSpecified)
				{
					num++;
					names[i + start + num] = ((SoapParameter)parameters[i]).specifiedName;
				}
			}
		}

		internal static CodeFlags[] GetCodeFlags(IList parameters, int specifiedCount)
		{
			CodeFlags[] result = new CodeFlags[parameters.Count + specifiedCount];
			GetCodeFlags(parameters, result, 0, specifiedCount);
			return result;
		}

		internal static void GetCodeFlags(IList parameters, CodeFlags[] codeFlags, int start, int specifiedCount)
		{
			int num = 0;
			for (int i = 0; i < parameters.Count; i++)
			{
				codeFlags[i + start + num] = ((SoapParameter)parameters[i]).codeFlags;
				if (((SoapParameter)parameters[i]).mapping.CheckSpecified)
				{
					num++;
					codeFlags[i + start + num] = ((SoapParameter)parameters[i]).codeFlags;
				}
			}
		}
	}
	internal class GlobalSoapHeader
	{
		internal string fieldName;

		internal XmlTypeMapping mapping;

		internal bool isEncoded;
	}
	internal class LocalSoapHeader
	{
		internal SoapHeaderDirection direction;

		internal string fieldName;
	}
	internal enum CodeFlags
	{
		IsPublic = 1,
		IsAbstract = 2,
		IsStruct = 4,
		IsNew = 8,
		IsByRef = 0x10,
		IsOut = 0x20,
		IsInterface = 0x40
	}
	internal class WebCodeGenerator
	{
		private static CodeAttributeDeclaration generatedCodeAttribute;

		internal static CodeAttributeDeclaration GeneratedCodeAttribute
		{
			get
			{
				if (generatedCodeAttribute == null)
				{
					CodeAttributeDeclaration codeAttributeDeclaration = new CodeAttributeDeclaration(typeof(GeneratedCodeAttribute).FullName);
					Assembly assembly = Assembly.GetEntryAssembly();
					if (assembly == null)
					{
						assembly = Assembly.GetExecutingAssembly();
						if (assembly == null)
						{
							assembly = typeof(WebCodeGenerator).Assembly;
						}
					}
					AssemblyName name = assembly.GetName();
					codeAttributeDeclaration.Arguments.Add(new CodeAttributeArgument(new CodePrimitiveExpression(name.Name)));
					string productVersion = GetProductVersion(assembly);
					codeAttributeDeclaration.Arguments.Add(new CodeAttributeArgument(new CodePrimitiveExpression((productVersion == null) ? name.Version.ToString() : productVersion)));
					generatedCodeAttribute = codeAttributeDeclaration;
				}
				return generatedCodeAttribute;
			}
		}

		private WebCodeGenerator()
		{
		}

		private static string GetProductVersion(Assembly assembly)
		{
			object[] customAttributes = assembly.GetCustomAttributes(inherit: true);
			for (int i = 0; i < customAttributes.Length; i++)
			{
				if (customAttributes[i] is AssemblyInformationalVersionAttribute)
				{
					AssemblyInformationalVersionAttribute assemblyInformationalVersionAttribute = (AssemblyInformationalVersionAttribute)customAttributes[i];
					return assemblyInformationalVersionAttribute.InformationalVersion;
				}
			}
			return null;
		}

		internal static string[] GetNamespacesForTypes(Type[] types)
		{
			Hashtable hashtable = new Hashtable();
			for (int i = 0; i < types.Length; i++)
			{
				string fullName = types[i].FullName;
				int num = fullName.LastIndexOf('.');
				if (num > 0)
				{
					hashtable[fullName.Substring(0, num)] = types[i];
				}
			}
			string[] array = new string[hashtable.Keys.Count];
			hashtable.Keys.CopyTo(array, 0);
			return array;
		}

		internal static void AddImports(CodeNamespace codeNamespace, string[] namespaces)
		{
			foreach (string nameSpace in namespaces)
			{
				codeNamespace.Imports.Add(new CodeNamespaceImport(nameSpace));
			}
		}

		private static CodeMemberProperty CreatePropertyDeclaration(CodeMemberField field, string name, string typeName)
		{
			CodeMemberProperty codeMemberProperty = new CodeMemberProperty();
			codeMemberProperty.Type = new CodeTypeReference(typeName);
			codeMemberProperty.Name = name;
			CodeMethodReturnStatement codeMethodReturnStatement = new CodeMethodReturnStatement();
			codeMethodReturnStatement.Expression = new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), field.Name);
			codeMemberProperty.GetStatements.Add(codeMethodReturnStatement);
			CodeExpression left = new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), field.Name);
			CodeExpression right = new CodeArgumentReferenceExpression("value");
			codeMemberProperty.SetStatements.Add(new CodeAssignStatement(left, right));
			return codeMemberProperty;
		}

		internal static CodeTypeMember AddMember(CodeTypeDeclaration codeClass, string typeName, string memberName, CodeExpression initializer, CodeAttributeDeclarationCollection metadata, CodeFlags flags, CodeGenerationOptions options)
		{
			bool flag = (options & CodeGenerationOptions.GenerateProperties) != 0;
			string name = (flag ? MakeFieldName(memberName) : memberName);
			CodeMemberField codeMemberField = new CodeMemberField(typeName, name);
			codeMemberField.InitExpression = initializer;
			CodeTypeMember codeTypeMember;
			if (flag)
			{
				codeClass.Members.Add(codeMemberField);
				codeTypeMember = CreatePropertyDeclaration(codeMemberField, memberName, typeName);
			}
			else
			{
				codeTypeMember = codeMemberField;
			}
			codeTypeMember.CustomAttributes = metadata;
			if ((flags & CodeFlags.IsPublic) != 0)
			{
				codeTypeMember.Attributes = (codeMemberField.Attributes & (MemberAttributes)(-61441)) | MemberAttributes.Public;
			}
			codeClass.Members.Add(codeTypeMember);
			return codeTypeMember;
		}

		internal static string FullTypeName(XmlMemberMapping mapping, CodeDomProvider codeProvider)
		{
			return mapping.GenerateTypeName(codeProvider);
		}

		private static string MakeFieldName(string name)
		{
			return CodeIdentifier.MakeCamel(name) + "Field";
		}

		internal static CodeConstructor AddConstructor(CodeTypeDeclaration codeClass, string[] parameterTypeNames, string[] parameterNames, CodeAttributeDeclarationCollection metadata, CodeFlags flags)
		{
			CodeConstructor codeConstructor = new CodeConstructor();
			if ((flags & CodeFlags.IsPublic) != 0)
			{
				codeConstructor.Attributes = (codeConstructor.Attributes & (MemberAttributes)(-61441)) | MemberAttributes.Public;
			}
			if ((flags & CodeFlags.IsAbstract) != 0)
			{
				codeConstructor.Attributes |= MemberAttributes.Abstract;
			}
			codeConstructor.CustomAttributes = metadata;
			for (int i = 0; i < parameterTypeNames.Length; i++)
			{
				CodeParameterDeclarationExpression value = new CodeParameterDeclarationExpression(parameterTypeNames[i], parameterNames[i]);
				codeConstructor.Parameters.Add(value);
			}
			codeClass.Members.Add(codeConstructor);
			return codeConstructor;
		}

		internal static CodeMemberMethod AddMethod(CodeTypeDeclaration codeClass, string methodName, CodeFlags[] parameterFlags, string[] parameterTypeNames, string[] parameterNames, string returnTypeName, CodeAttributeDeclarationCollection metadata, CodeFlags flags)
		{
			return AddMethod(codeClass, methodName, parameterFlags, parameterTypeNames, parameterNames, new CodeAttributeDeclarationCollection[0], returnTypeName, metadata, flags);
		}

		internal static CodeMemberMethod AddMethod(CodeTypeDeclaration codeClass, string methodName, CodeFlags[] parameterFlags, string[] parameterTypeNames, string[] parameterNames, CodeAttributeDeclarationCollection[] parameterAttributes, string returnTypeName, CodeAttributeDeclarationCollection metadata, CodeFlags flags)
		{
			CodeMemberMethod codeMemberMethod = new CodeMemberMethod();
			codeMemberMethod.Name = methodName;
			codeMemberMethod.ReturnType = new CodeTypeReference(returnTypeName);
			codeMemberMethod.CustomAttributes = metadata;
			if ((flags & CodeFlags.IsPublic) != 0)
			{
				codeMemberMethod.Attributes = (codeMemberMethod.Attributes & (MemberAttributes)(-61441)) | MemberAttributes.Public;
			}
			if ((flags & CodeFlags.IsAbstract) != 0)
			{
				codeMemberMethod.Attributes = (codeMemberMethod.Attributes & (MemberAttributes)(-16)) | MemberAttributes.Abstract;
			}
			if ((flags & CodeFlags.IsNew) != 0)
			{
				codeMemberMethod.Attributes = (codeMemberMethod.Attributes & (MemberAttributes)(-241)) | MemberAttributes.New;
			}
			for (int i = 0; i < parameterNames.Length; i++)
			{
				CodeParameterDeclarationExpression codeParameterDeclarationExpression = new CodeParameterDeclarationExpression(parameterTypeNames[i], parameterNames[i]);
				if ((parameterFlags[i] & CodeFlags.IsByRef) != 0)
				{
					codeParameterDeclarationExpression.Direction = FieldDirection.Ref;
				}
				else if ((parameterFlags[i] & CodeFlags.IsOut) != 0)
				{
					codeParameterDeclarationExpression.Direction = FieldDirection.Out;
				}
				if (i < parameterAttributes.Length)
				{
					codeParameterDeclarationExpression.CustomAttributes = parameterAttributes[i];
				}
				codeMemberMethod.Parameters.Add(codeParameterDeclarationExpression);
			}
			codeClass.Members.Add(codeMemberMethod);
			return codeMemberMethod;
		}

		internal static CodeTypeDeclaration AddClass(CodeNamespace codeNamespace, string className, string baseClassName, string[] implementedInterfaceNames, CodeAttributeDeclarationCollection metadata, CodeFlags flags, bool isPartial)
		{
			CodeTypeDeclaration codeTypeDeclaration = CreateClass(className, baseClassName, implementedInterfaceNames, metadata, flags, isPartial);
			codeNamespace.Types.Add(codeTypeDeclaration);
			return codeTypeDeclaration;
		}

		internal static CodeTypeDeclaration CreateClass(string className, string baseClassName, string[] implementedInterfaceNames, CodeAttributeDeclarationCollection metadata, CodeFlags flags, bool isPartial)
		{
			CodeTypeDeclaration codeTypeDeclaration = new CodeTypeDeclaration(className);
			if (baseClassName != null && baseClassName.Length > 0)
			{
				codeTypeDeclaration.BaseTypes.Add(baseClassName);
			}
			foreach (string value in implementedInterfaceNames)
			{
				codeTypeDeclaration.BaseTypes.Add(value);
			}
			codeTypeDeclaration.IsStruct = (flags & CodeFlags.IsStruct) != 0;
			if ((flags & CodeFlags.IsPublic) != 0)
			{
				codeTypeDeclaration.TypeAttributes |= TypeAttributes.Public;
			}
			else
			{
				codeTypeDeclaration.TypeAttributes &= ~TypeAttributes.Public;
			}
			if ((flags & CodeFlags.IsAbstract) != 0)
			{
				codeTypeDeclaration.TypeAttributes |= TypeAttributes.Abstract;
			}
			else
			{
				codeTypeDeclaration.TypeAttributes &= ~TypeAttributes.Abstract;
			}
			if ((flags & CodeFlags.IsInterface) != 0)
			{
				codeTypeDeclaration.IsInterface = true;
			}
			else
			{
				codeTypeDeclaration.IsPartial = isPartial;
			}
			codeTypeDeclaration.CustomAttributes = metadata;
			codeTypeDeclaration.CustomAttributes.Add(GeneratedCodeAttribute);
			return codeTypeDeclaration;
		}

		internal static CodeAttributeDeclarationCollection AddCustomAttribute(CodeAttributeDeclarationCollection metadata, Type type, CodeAttributeArgument[] arguments)
		{
			if (metadata == null)
			{
				metadata = new CodeAttributeDeclarationCollection();
			}
			CodeAttributeDeclaration value = new CodeAttributeDeclaration(type.FullName, arguments);
			metadata.Add(value);
			return metadata;
		}

		internal static CodeAttributeDeclarationCollection AddCustomAttribute(CodeAttributeDeclarationCollection metadata, Type type, CodeExpression[] arguments)
		{
			return AddCustomAttribute(metadata, type, arguments, new string[0], new CodeExpression[0]);
		}

		internal static CodeAttributeDeclarationCollection AddCustomAttribute(CodeAttributeDeclarationCollection metadata, Type type, CodeExpression[] parameters, string[] propNames, CodeExpression[] propValues)
		{
			int num = ((parameters != null) ? parameters.Length : 0) + ((propNames != null) ? propNames.Length : 0);
			CodeAttributeArgument[] array = new CodeAttributeArgument[num];
			for (int i = 0; i < parameters.Length; i++)
			{
				array[i] = new CodeAttributeArgument(null, parameters[i]);
			}
			for (int j = 0; j < propNames.Length; j++)
			{
				array[parameters.Length + j] = new CodeAttributeArgument(propNames[j], propValues[j]);
			}
			return AddCustomAttribute(metadata, type, array);
		}

		internal static void AddEvent(CodeTypeMemberCollection members, string handlerType, string handlerName)
		{
			CodeMemberEvent codeMemberEvent = new CodeMemberEvent();
			codeMemberEvent.Type = new CodeTypeReference(handlerType);
			codeMemberEvent.Name = handlerName;
			codeMemberEvent.Attributes = (codeMemberEvent.Attributes & (MemberAttributes)(-61441)) | MemberAttributes.Public;
			codeMemberEvent.Comments.Add(new CodeCommentStatement(Res.GetString("CodeRemarks"), docComment: true));
			members.Add(codeMemberEvent);
		}

		internal static void AddDelegate(CodeTypeDeclarationCollection codeClasses, string handlerType, string handlerArgs)
		{
			CodeTypeDelegate codeTypeDelegate = new CodeTypeDelegate(handlerType);
			codeTypeDelegate.CustomAttributes.Add(GeneratedCodeAttribute);
			codeTypeDelegate.Parameters.Add(new CodeParameterDeclarationExpression(typeof(object), "sender"));
			codeTypeDelegate.Parameters.Add(new CodeParameterDeclarationExpression(handlerArgs, "e"));
			codeTypeDelegate.Comments.Add(new CodeCommentStatement(Res.GetString("CodeRemarks"), docComment: true));
			codeClasses.Add(codeTypeDelegate);
		}

		internal static void AddCallbackDeclaration(CodeTypeMemberCollection members, string callbackMember)
		{
			CodeMemberField codeMemberField = new CodeMemberField();
			codeMemberField.Type = new CodeTypeReference(typeof(SendOrPostCallback));
			codeMemberField.Name = callbackMember;
			members.Add(codeMemberField);
		}

		internal static void AddCallbackImplementation(CodeTypeDeclaration codeClass, string callbackName, string handlerName, string handlerArgs, bool methodHasOutParameters)
		{
			CodeFlags[] parameterFlags = new CodeFlags[1];
			CodeMemberMethod codeMemberMethod = AddMethod(codeClass, callbackName, parameterFlags, new string[1] { typeof(object).FullName }, new string[1] { "arg" }, typeof(void).FullName, null, (CodeFlags)0);
			CodeEventReferenceExpression left = new CodeEventReferenceExpression(new CodeThisReferenceExpression(), handlerName);
			CodeBinaryOperatorExpression condition = new CodeBinaryOperatorExpression(left, CodeBinaryOperatorType.IdentityInequality, new CodePrimitiveExpression(null));
			CodeStatement[] array = new CodeStatement[2]
			{
				new CodeVariableDeclarationStatement(typeof(InvokeCompletedEventArgs), "invokeArgs", new CodeCastExpression(typeof(InvokeCompletedEventArgs), new CodeArgumentReferenceExpression("arg"))),
				null
			};
			CodeVariableReferenceExpression targetObject = new CodeVariableReferenceExpression("invokeArgs");
			CodeObjectCreateExpression codeObjectCreateExpression = new CodeObjectCreateExpression();
			if (methodHasOutParameters)
			{
				codeObjectCreateExpression.CreateType = new CodeTypeReference(handlerArgs);
				codeObjectCreateExpression.Parameters.Add(new CodePropertyReferenceExpression(targetObject, "Results"));
			}
			else
			{
				codeObjectCreateExpression.CreateType = new CodeTypeReference(typeof(AsyncCompletedEventArgs));
			}
			codeObjectCreateExpression.Parameters.Add(new CodePropertyReferenceExpression(targetObject, "Error"));
			codeObjectCreateExpression.Parameters.Add(new CodePropertyReferenceExpression(targetObject, "Cancelled"));
			codeObjectCreateExpression.Parameters.Add(new CodePropertyReferenceExpression(targetObject, "UserState"));
			array[1] = new CodeExpressionStatement(new CodeDelegateInvokeExpression(new CodeEventReferenceExpression(new CodeThisReferenceExpression(), handlerName), new CodeThisReferenceExpression(), codeObjectCreateExpression));
			codeMemberMethod.Statements.Add(new CodeConditionStatement(condition, array, new CodeStatement[0]));
		}

		internal static CodeMemberMethod AddAsyncMethod(CodeTypeDeclaration codeClass, string methodName, string[] parameterTypeNames, string[] parameterNames, string callbackMember, string callbackName, string userState)
		{
			CodeMemberMethod codeMemberMethod = AddMethod(codeClass, methodName, new CodeFlags[parameterNames.Length], parameterTypeNames, parameterNames, typeof(void).FullName, null, CodeFlags.IsPublic);
			codeMemberMethod.Comments.Add(new CodeCommentStatement(Res.GetString("CodeRemarks"), docComment: true));
			CodeMethodInvokeExpression codeMethodInvokeExpression = new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), methodName);
			for (int i = 0; i < parameterNames.Length; i++)
			{
				codeMethodInvokeExpression.Parameters.Add(new CodeArgumentReferenceExpression(parameterNames[i]));
			}
			codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression(null));
			codeMemberMethod.Statements.Add(codeMethodInvokeExpression);
			codeMemberMethod = AddMethod(codeClass, methodName, new CodeFlags[parameterNames.Length], parameterTypeNames, parameterNames, typeof(void).FullName, null, CodeFlags.IsPublic);
			codeMemberMethod.Comments.Add(new CodeCommentStatement(Res.GetString("CodeRemarks"), docComment: true));
			codeMemberMethod.Parameters.Add(new CodeParameterDeclarationExpression(typeof(object), userState));
			CodeFieldReferenceExpression left = new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), callbackMember);
			CodeBinaryOperatorExpression condition = new CodeBinaryOperatorExpression(left, CodeBinaryOperatorType.IdentityEquality, new CodePrimitiveExpression(null));
			CodeDelegateCreateExpression codeDelegateCreateExpression = new CodeDelegateCreateExpression();
			codeDelegateCreateExpression.DelegateType = new CodeTypeReference(typeof(SendOrPostCallback));
			codeDelegateCreateExpression.TargetObject = new CodeThisReferenceExpression();
			codeDelegateCreateExpression.MethodName = callbackName;
			CodeStatement[] trueStatements = new CodeStatement[1]
			{
				new CodeAssignStatement(left, codeDelegateCreateExpression)
			};
			codeMemberMethod.Statements.Add(new CodeConditionStatement(condition, trueStatements, new CodeStatement[0]));
			return codeMemberMethod;
		}

		internal static CodeTypeDeclaration CreateArgsClass(string name, string[] paramTypes, string[] paramNames, bool isPartial)
		{
			CodeTypeDeclaration codeTypeDeclaration = new CodeTypeDeclaration(name);
			codeTypeDeclaration.CustomAttributes.Add(GeneratedCodeAttribute);
			codeTypeDeclaration.CustomAttributes.Add(new CodeAttributeDeclaration(typeof(DebuggerStepThroughAttribute).FullName));
			codeTypeDeclaration.CustomAttributes.Add(new CodeAttributeDeclaration(typeof(DesignerCategoryAttribute).FullName, new CodeAttributeArgument(new CodePrimitiveExpression("code"))));
			codeTypeDeclaration.IsPartial = isPartial;
			codeTypeDeclaration.BaseTypes.Add(new CodeTypeReference(typeof(AsyncCompletedEventArgs)));
			CodeIdentifiers codeIdentifiers = new CodeIdentifiers();
			codeIdentifiers.AddUnique("Error", "Error");
			codeIdentifiers.AddUnique("Cancelled", "Cancelled");
			codeIdentifiers.AddUnique("UserState", "UserState");
			for (int i = 0; i < paramNames.Length; i++)
			{
				if (paramNames[i] != null)
				{
					codeIdentifiers.AddUnique(paramNames[i], paramNames[i]);
				}
			}
			string text = codeIdentifiers.AddUnique("results", "results");
			CodeMemberField codeMemberField = new CodeMemberField(typeof(object[]), text);
			codeTypeDeclaration.Members.Add(codeMemberField);
			CodeConstructor codeConstructor = new CodeConstructor();
			codeConstructor.Attributes = (codeConstructor.Attributes & (MemberAttributes)(-61441)) | MemberAttributes.Assembly;
			CodeParameterDeclarationExpression value = new CodeParameterDeclarationExpression(typeof(object[]), text);
			codeConstructor.Parameters.Add(value);
			codeConstructor.Parameters.Add(new CodeParameterDeclarationExpression(typeof(Exception), "exception"));
			codeConstructor.Parameters.Add(new CodeParameterDeclarationExpression(typeof(bool), "cancelled"));
			codeConstructor.Parameters.Add(new CodeParameterDeclarationExpression(typeof(object), "userState"));
			codeConstructor.BaseConstructorArgs.Add(new CodeArgumentReferenceExpression("exception"));
			codeConstructor.BaseConstructorArgs.Add(new CodeArgumentReferenceExpression("cancelled"));
			codeConstructor.BaseConstructorArgs.Add(new CodeArgumentReferenceExpression("userState"));
			codeConstructor.Statements.Add(new CodeAssignStatement(new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), codeMemberField.Name), new CodeArgumentReferenceExpression(text)));
			codeTypeDeclaration.Members.Add(codeConstructor);
			int num = 0;
			for (int j = 0; j < paramNames.Length; j++)
			{
				if (paramNames[j] != null)
				{
					codeTypeDeclaration.Members.Add(CreatePropertyDeclaration(codeMemberField, paramNames[j], paramTypes[j], num++));
				}
			}
			codeTypeDeclaration.Comments.Add(new CodeCommentStatement(Res.GetString("CodeRemarks"), docComment: true));
			return codeTypeDeclaration;
		}

		private static CodeMemberProperty CreatePropertyDeclaration(CodeMemberField field, string name, string typeName, int index)
		{
			CodeMemberProperty codeMemberProperty = new CodeMemberProperty();
			codeMemberProperty.Type = new CodeTypeReference(typeName);
			codeMemberProperty.Name = name;
			codeMemberProperty.Attributes = (codeMemberProperty.Attributes & (MemberAttributes)(-61441)) | MemberAttributes.Public;
			codeMemberProperty.GetStatements.Add(new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), "RaiseExceptionIfNecessary"));
			CodeArrayIndexerExpression codeArrayIndexerExpression = new CodeArrayIndexerExpression();
			codeArrayIndexerExpression.TargetObject = new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), field.Name);
			codeArrayIndexerExpression.Indices.Add(new CodePrimitiveExpression(index));
			CodeMethodReturnStatement codeMethodReturnStatement = new CodeMethodReturnStatement();
			codeMethodReturnStatement.Expression = new CodeCastExpression(typeName, codeArrayIndexerExpression);
			codeMemberProperty.GetStatements.Add(codeMethodReturnStatement);
			codeMemberProperty.Comments.Add(new CodeCommentStatement(Res.GetString("CodeRemarks"), docComment: true));
			return codeMemberProperty;
		}
	}
	public sealed class WebReference
	{
		private CodeNamespace proxyCode;

		private DiscoveryClientDocumentCollection documents;

		private string appSettingUrlKey;

		private string appSettingBaseUrl;

		private string protocolName;

		private ServiceDescriptionImportWarnings warnings;

		private StringCollection validationWarnings;

		public string AppSettingBaseUrl => appSettingBaseUrl;

		public string AppSettingUrlKey => appSettingUrlKey;

		public DiscoveryClientDocumentCollection Documents => documents;

		public CodeNamespace ProxyCode => proxyCode;

		public StringCollection ValidationWarnings
		{
			get
			{
				if (validationWarnings == null)
				{
					validationWarnings = new StringCollection();
				}
				return validationWarnings;
			}
		}

		public ServiceDescriptionImportWarnings Warnings
		{
			get
			{
				return warnings;
			}
			set
			{
				warnings = value;
			}
		}

		public string ProtocolName
		{
			get
			{
				if (protocolName != null)
				{
					return protocolName;
				}
				return string.Empty;
			}
			set
			{
				protocolName = value;
			}
		}

		public WebReference(DiscoveryClientDocumentCollection documents, CodeNamespace proxyCode, string protocolName, string appSettingUrlKey, string appSettingBaseUrl)
		{
			if (documents == null)
			{
				throw new ArgumentNullException("documents");
			}
			if (proxyCode == null)
			{
				throw new ArgumentNullException("proxyCode");
			}
			if (appSettingBaseUrl != null && appSettingUrlKey == null)
			{
				throw new ArgumentNullException("appSettingUrlKey");
			}
			this.protocolName = protocolName;
			this.appSettingUrlKey = appSettingUrlKey;
			this.appSettingBaseUrl = appSettingBaseUrl;
			this.documents = documents;
			this.proxyCode = proxyCode;
		}

		public WebReference(DiscoveryClientDocumentCollection documents, CodeNamespace proxyCode)
			: this(documents, proxyCode, null, null, null)
		{
		}

		public WebReference(DiscoveryClientDocumentCollection documents, CodeNamespace proxyCode, string appSettingUrlKey, string appSettingBaseUrl)
			: this(documents, proxyCode, null, appSettingUrlKey, appSettingBaseUrl)
		{
		}
	}
	public sealed class WebReferenceCollection : CollectionBase
	{
		public WebReference this[int index]
		{
			get
			{
				return (WebReference)base.List[index];
			}
			set
			{
				base.List[index] = value;
			}
		}

		public int Add(WebReference webReference)
		{
			return base.List.Add(webReference);
		}

		public void Insert(int index, WebReference webReference)
		{
			base.List.Insert(index, webReference);
		}

		public int IndexOf(WebReference webReference)
		{
			return base.List.IndexOf(webReference);
		}

		public bool Contains(WebReference webReference)
		{
			return base.List.Contains(webReference);
		}

		public void Remove(WebReference webReference)
		{
			base.List.Remove(webReference);
		}

		public void CopyTo(WebReference[] array, int index)
		{
			base.List.CopyTo(array, index);
		}
	}
	[XmlType("webReferenceOptions", Namespace = "http://microsoft.com/webReference/")]
	[XmlRoot("webReferenceOptions", Namespace = "http://microsoft.com/webReference/")]
	public class WebReferenceOptions
	{
		public const string TargetNamespace = "http://microsoft.com/webReference/";

		private static XmlSchema schema;

		private CodeGenerationOptions codeGenerationOptions = CodeGenerationOptions.GenerateOldAsync;

		private ServiceDescriptionImportStyle style;

		private StringCollection schemaImporterExtensions;

		private bool verbose;

		[DefaultValue(CodeGenerationOptions.GenerateOldAsync)]
		[XmlElement("codeGenerationOptions")]
		public CodeGenerationOptions CodeGenerationOptions
		{
			get
			{
				return codeGenerationOptions;
			}
			set
			{
				codeGenerationOptions = value;
			}
		}

		[XmlArray("schemaImporterExtensions")]
		[XmlArrayItem("type")]
		public StringCollection SchemaImporterExtensions
		{
			get
			{
				if (schemaImporterExtensions == null)
				{
					schemaImporterExtensions = new StringCollection();
				}
				return schemaImporterExtensions;
			}
		}

		[DefaultValue(ServiceDescriptionImportStyle.Client)]
		[XmlElement("style")]
		public ServiceDescriptionImportStyle Style
		{
			get
			{
				return style;
			}
			set
			{
				style = value;
			}
		}

		[XmlElement("verbose")]
		public bool Verbose
		{
			get
			{
				return verbose;
			}
			set
			{
				verbose = value;
			}
		}

		public static XmlSchema Schema
		{
			get
			{
				if (schema == null)
				{
					schema = XmlSchema.Read(new StringReader("<?xml version='1.0' encoding='UTF-8' ?>\r\n<xs:schema xmlns:tns='http://microsoft.com/webReference/' elementFormDefault='qualified' targetNamespace='http://microsoft.com/webReference/' xmlns:xs='http://www.w3.org/2001/XMLSchema'>\r\n  <xs:simpleType name='options'>\r\n    <xs:list>\r\n      <xs:simpleType>\r\n        <xs:restriction base='xs:string'>\r\n          <xs:enumeration value='properties' />\r\n          <xs:enumeration value='newAsync' />\r\n          <xs:enumeration value='oldAsync' />\r\n          <xs:enumeration value='order' />\r\n          <xs:enumeration value='enableDataBinding' />\r\n        </xs:restriction>\r\n      </xs:simpleType>\r\n    </xs:list>\r\n  </xs:simpleType>\r\n  <xs:simpleType name='style'>\r\n    <xs:restriction base='xs:string'>\r\n      <xs:enumeration value='client' />\r\n      <xs:enumeration value='server' />\r\n      <xs:enumeration value='serverInterface' />\r\n    </xs:restriction>\r\n  </xs:simpleType>\r\n  <xs:complexType name='webReferenceOptions'>\r\n    <xs:all>\r\n      <xs:element minOccurs='0' default='oldAsync' name='codeGenerationOptions' type='tns:options' />\r\n      <xs:element minOccurs='0' default='client' name='style' type='tns:style' />\r\n      <xs:element minOccurs='0' default='false' name='verbose' type='xs:boolean' />\r\n      <xs:element minOccurs='0' name='schemaImporterExtensions'>\r\n        <xs:complexType>\r\n          <xs:sequence>\r\n            <xs:element minOccurs='0' maxOccurs='unbounded' name='type' type='xs:string' />\r\n          </xs:sequence>\r\n        </xs:complexType>\r\n      </xs:element>\r\n    </xs:all>\r\n  </xs:complexType>\r\n  <xs:element name='webReferenceOptions' type='tns:webReferenceOptions' />\r\n  <xs:complexType name='wsdlParameters'>\r\n    <xs:all>\r\n      <xs:element minOccurs='0' name='appSettingBaseUrl' type='xs:string' />\r\n      <xs:element minOccurs='0' name='appSettingUrlKey' type='xs:string' />\r\n      <xs:element minOccurs='0' name='domain' type='xs:string' />\r\n      <xs:element minOccurs='0' name='out' type='xs:string' />\r\n      <xs:element minOccurs='0' name='password' type='xs:string' />\r\n      <xs:element minOccurs='0' name='proxy' type='xs:string' />\r\n      <xs:element minOccurs='0' name='proxydomain' type='xs:string' />\r\n      <xs:element minOccurs='0' name='proxypassword' type='xs:string' />\r\n      <xs:element minOccurs='0' name='proxyusername' type='xs:string' />\r\n      <xs:element minOccurs='0' name='username' type='xs:string' />\r\n      <xs:element minOccurs='0' name='namespace' type='xs:string' />\r\n      <xs:element minOccurs='0' name='language' type='xs:string' />\r\n      <xs:element minOccurs='0' name='protocol' type='xs:string' />\r\n      <xs:element minOccurs='0' name='nologo' type='xs:boolean' />\r\n      <xs:element minOccurs='0' name='parsableerrors' type='xs:boolean' />\r\n      <xs:element minOccurs='0' name='sharetypes' type='xs:boolean' />\r\n      <xs:element minOccurs='0' name='webReferenceOptions' type='tns:webReferenceOptions' />\r\n      <xs:element minOccurs='0' name='documents'>\r\n        <xs:complexType>\r\n          <xs:sequence>\r\n            <xs:element minOccurs='0' maxOccurs='unbounded' name='document' type='xs:string' />\r\n          </xs:sequence>\r\n        </xs:complexType>\r\n      </xs:element>\r\n    </xs:all>\r\n  </xs:complexType>\r\n  <xs:element name='wsdlParameters' type='tns:wsdlParameters' />\r\n</xs:schema>"), null);
				}
				return schema;
			}
		}

		public static WebReferenceOptions Read(TextReader reader, ValidationEventHandler validationEventHandler)
		{
			XmlTextReader xmlTextReader = new XmlTextReader(reader);
			xmlTextReader.XmlResolver = null;
			xmlTextReader.ProhibitDtd = true;
			return Read(xmlTextReader, validationEventHandler);
		}

		public static WebReferenceOptions Read(Stream stream, ValidationEventHandler validationEventHandler)
		{
			XmlTextReader xmlTextReader = new XmlTextReader(stream);
			xmlTextReader.XmlResolver = null;
			xmlTextReader.ProhibitDtd = true;
			return Read(xmlTextReader, validationEventHandler);
		}

		public static WebReferenceOptions Read(XmlReader xmlReader, ValidationEventHandler validationEventHandler)
		{
			XmlValidatingReader xmlValidatingReader = new XmlValidatingReader(xmlReader);
			xmlValidatingReader.ValidationType = ValidationType.Schema;
			if (validationEventHandler != null)
			{
				xmlValidatingReader.ValidationEventHandler += validationEventHandler;
			}
			else
			{
				xmlValidatingReader.ValidationEventHandler += SchemaValidationHandler;
			}
			xmlValidatingReader.Schemas.Add(Schema);
			webReferenceOptionsSerializer webReferenceOptionsSerializer2 = new webReferenceOptionsSerializer();
			try
			{
				return (WebReferenceOptions)webReferenceOptionsSerializer2.Deserialize(xmlValidatingReader);
			}
			catch (Exception ex)
			{
				throw ex;
			}
			catch
			{
				throw;
			}
			finally
			{
				xmlValidatingReader.Close();
			}
		}

		private static void SchemaValidationHandler(object sender, ValidationEventArgs args)
		{
			if (args.Severity != 0)
			{
				return;
			}
			throw new InvalidOperationException(Res.GetString("WsdlInstanceValidationDetails", args.Message, args.Exception.LineNumber.ToString(CultureInfo.InvariantCulture), args.Exception.LinePosition.ToString(CultureInfo.InvariantCulture)));
		}
	}
	internal class WebReferenceOptionsSerializationWriter : XmlSerializationWriter
	{
		private string Write1_CodeGenerationOptions(CodeGenerationOptions v)
		{
			string text = null;
			return v switch
			{
				CodeGenerationOptions.GenerateProperties => "properties", 
				CodeGenerationOptions.GenerateNewAsync => "newAsync", 
				CodeGenerationOptions.GenerateOldAsync => "oldAsync", 
				CodeGenerationOptions.GenerateOrder => "order", 
				CodeGenerationOptions.EnableDataBinding => "enableDataBinding", 
				_ => XmlSerializationWriter.FromEnum((long)v, new string[5] { "properties", "newAsync", "oldAsync", "order", "enableDataBinding" }, new long[5] { 1L, 2L, 4L, 8L, 16L }, "System.Xml.Serialization.CodeGenerationOptions"), 
			};
		}

		private string Write2_ServiceDescriptionImportStyle(ServiceDescriptionImportStyle v)
		{
			string text = null;
			return v switch
			{
				ServiceDescriptionImportStyle.Client => "client", 
				ServiceDescriptionImportStyle.Server => "server", 
				ServiceDescriptionImportStyle.ServerInterface => "serverInterface", 
				_ => throw CreateInvalidEnumValueException(((long)v).ToString(CultureInfo.InvariantCulture), "System.Web.Services.Description.ServiceDescriptionImportStyle"), 
			};
		}

		private void Write4_WebReferenceOptions(string n, string ns, WebReferenceOptions o, bool isNullable, bool needType)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(n, ns);
				}
				return;
			}
			if (!needType)
			{
				Type type = o.GetType();
				if (type != typeof(WebReferenceOptions))
				{
					throw CreateUnknownTypeException(o);
				}
			}
			base.EscapeName = false;
			WriteStartElement(n, ns, o);
			if (needType)
			{
				WriteXsiType("webReferenceOptions", "http://microsoft.com/webReference/");
			}
			if (o.CodeGenerationOptions != CodeGenerationOptions.GenerateOldAsync)
			{
				WriteElementString("codeGenerationOptions", "http://microsoft.com/webReference/", Write1_CodeGenerationOptions(o.CodeGenerationOptions));
			}
			StringCollection schemaImporterExtensions = o.SchemaImporterExtensions;
			if (schemaImporterExtensions != null)
			{
				WriteStartElement("schemaImporterExtensions", "http://microsoft.com/webReference/");
				for (int i = 0; i < schemaImporterExtensions.Count; i++)
				{
					WriteNullableStringLiteral("type", "http://microsoft.com/webReference/", schemaImporterExtensions[i]);
				}
				WriteEndElement();
			}
			if (o.Style != 0)
			{
				WriteElementString("style", "http://microsoft.com/webReference/", Write2_ServiceDescriptionImportStyle(o.Style));
			}
			WriteElementStringRaw("verbose", "http://microsoft.com/webReference/", XmlConvert.ToString(o.Verbose));
			WriteEndElement(o);
		}

		protected override void InitCallbacks()
		{
		}

		internal void Write5_webReferenceOptions(object o)
		{
			WriteStartDocument();
			if (o == null)
			{
				WriteNullTagLiteral("webReferenceOptions", "http://microsoft.com/webReference/");
				return;
			}
			TopLevelElement();
			Write4_WebReferenceOptions("webReferenceOptions", "http://microsoft.com/webReference/", (WebReferenceOptions)o, isNullable: true, needType: false);
		}
	}
	internal class WebReferenceOptionsSerializationReader : XmlSerializationReader
	{
		private Hashtable _CodeGenerationOptionsValues;

		private string id2_Item;

		private string id5_type;

		private string id4_schemaImporterExtensions;

		private string id3_codeGenerationOptions;

		private string id6_style;

		private string id7_verbose;

		private string id1_webReferenceOptions;

		internal Hashtable CodeGenerationOptionsValues
		{
			get
			{
				if (_CodeGenerationOptionsValues == null)
				{
					Hashtable hashtable = new Hashtable();
					hashtable.Add("properties", 1L);
					hashtable.Add("newAsync", 2L);
					hashtable.Add("oldAsync", 4L);
					hashtable.Add("order", 8L);
					hashtable.Add("enableDataBinding", 16L);
					_CodeGenerationOptionsValues = hashtable;
				}
				return _CodeGenerationOptionsValues;
			}
		}

		private CodeGenerationOptions Read1_CodeGenerationOptions(string s)
		{
			return (CodeGenerationOptions)XmlSerializationReader.ToEnum(s, CodeGenerationOptionsValues, "System.Xml.Serialization.CodeGenerationOptions");
		}

		private ServiceDescriptionImportStyle Read2_ServiceDescriptionImportStyle(string s)
		{
			return s switch
			{
				"client" => ServiceDescriptionImportStyle.Client, 
				"server" => ServiceDescriptionImportStyle.Server, 
				"serverInterface" => ServiceDescriptionImportStyle.ServerInterface, 
				_ => throw CreateUnknownConstantException(s, typeof(ServiceDescriptionImportStyle)), 
			};
		}

		private WebReferenceOptions Read4_WebReferenceOptions(bool isNullable, bool checkType)
		{
			XmlQualifiedName xmlQualifiedName = (checkType ? GetXsiType() : null);
			bool flag = false;
			if (isNullable)
			{
				flag = ReadNull();
			}
			if (checkType && !(xmlQualifiedName == null) && ((object)xmlQualifiedName.Name != id1_webReferenceOptions || (object)xmlQualifiedName.Namespace != id2_Item))
			{
				throw CreateUnknownTypeException(xmlQualifiedName);
			}
			if (flag)
			{
				return null;
			}
			WebReferenceOptions webReferenceOptions = new WebReferenceOptions();
			_ = webReferenceOptions.SchemaImporterExtensions;
			bool[] array = new bool[4];
			while (base.Reader.MoveToNextAttribute())
			{
				if (!IsXmlnsAttribute(base.Reader.Name))
				{
					UnknownNode(webReferenceOptions);
				}
			}
			base.Reader.MoveToElement();
			if (base.Reader.IsEmptyElement)
			{
				base.Reader.Skip();
				return webReferenceOptions;
			}
			base.Reader.ReadStartElement();
			base.Reader.MoveToContent();
			int whileIterations = 0;
			int readerCount = base.ReaderCount;
			while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
			{
				if (base.Reader.NodeType == XmlNodeType.Element)
				{
					if (!array[0] && (object)base.Reader.LocalName == id3_codeGenerationOptions && (object)base.Reader.NamespaceURI == id2_Item)
					{
						if (base.Reader.IsEmptyElement)
						{
							base.Reader.Skip();
						}
						else
						{
							webReferenceOptions.CodeGenerationOptions = Read1_CodeGenerationOptions(base.Reader.ReadElementString());
						}
						array[0] = true;
					}
					else if ((object)base.Reader.LocalName == id4_schemaImporterExtensions && (object)base.Reader.NamespaceURI == id2_Item)
					{
						if (!ReadNull())
						{
							StringCollection schemaImporterExtensions = webReferenceOptions.SchemaImporterExtensions;
							if (schemaImporterExtensions == null || base.Reader.IsEmptyElement)
							{
								base.Reader.Skip();
							}
							else
							{
								base.Reader.ReadStartElement();
								base.Reader.MoveToContent();
								int whileIterations2 = 0;
								int readerCount2 = base.ReaderCount;
								while (base.Reader.NodeType != XmlNodeType.EndElement && base.Reader.NodeType != 0)
								{
									if (base.Reader.NodeType == XmlNodeType.Element)
									{
										if ((object)base.Reader.LocalName == id5_type && (object)base.Reader.NamespaceURI == id2_Item)
										{
											if (ReadNull())
											{
												schemaImporterExtensions.Add(null);
											}
											else
											{
												schemaImporterExtensions.Add(base.Reader.ReadElementString());
											}
										}
										else
										{
											UnknownNode(null, "http://microsoft.com/webReference/:type");
										}
									}
									else
									{
										UnknownNode(null, "http://microsoft.com/webReference/:type");
									}
									base.Reader.MoveToContent();
									CheckReaderCount(ref whileIterations2, ref readerCount2);
								}
								ReadEndElement();
							}
						}
					}
					else if (!array[2] && (object)base.Reader.LocalName == id6_style && (object)base.Reader.NamespaceURI == id2_Item)
					{
						if (base.Reader.IsEmptyElement)
						{
							base.Reader.Skip();
						}
						else
						{
							webReferenceOptions.Style = Read2_ServiceDescriptionImportStyle(base.Reader.ReadElementString());
						}
						array[2] = true;
					}
					else if (!array[3] && (object)base.Reader.LocalName == id7_verbose && (object)base.Reader.NamespaceURI == id2_Item)
					{
						webReferenceOptions.Verbose = XmlConvert.ToBoolean(base.Reader.ReadElementString());
						array[3] = true;
					}
					else
					{
						UnknownNode(webReferenceOptions, "http://microsoft.com/webReference/:codeGenerationOptions, http://microsoft.com/webReference/:schemaImporterExtensions, http://microsoft.com/webReference/:style, http://microsoft.com/webReference/:verbose");
					}
				}
				else
				{
					UnknownNode(webReferenceOptions, "http://microsoft.com/webReference/:codeGenerationOptions, http://microsoft.com/webReference/:schemaImporterExtensions, http://microsoft.com/webReference/:style, http://microsoft.com/webReference/:verbose");
				}
				base.Reader.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			ReadEndElement();
			return webReferenceOptions;
		}

		protected override void InitCallbacks()
		{
		}

		internal object Read5_webReferenceOptions()
		{
			object result = null;
			base.Reader.MoveToContent();
			if (base.Reader.NodeType == XmlNodeType.Element)
			{
				if ((object)base.Reader.LocalName != id1_webReferenceOptions || (object)base.Reader.NamespaceURI != id2_Item)
				{
					throw CreateUnknownNodeException();
				}
				result = Read4_WebReferenceOptions(isNullable: true, checkType: true);
			}
			else
			{
				UnknownNode(null, "http://microsoft.com/webReference/:webReferenceOptions");
			}
			return result;
		}

		protected override void InitIDs()
		{
			id2_Item = base.Reader.NameTable.Add("http://microsoft.com/webReference/");
			id5_type = base.Reader.NameTable.Add("type");
			id4_schemaImporterExtensions = base.Reader.NameTable.Add("schemaImporterExtensions");
			id3_codeGenerationOptions = base.Reader.NameTable.Add("codeGenerationOptions");
			id6_style = base.Reader.NameTable.Add("style");
			id7_verbose = base.Reader.NameTable.Add("verbose");
			id1_webReferenceOptions = base.Reader.NameTable.Add("webReferenceOptions");
		}
	}
	internal sealed class webReferenceOptionsSerializer : XmlSerializer
	{
		protected override XmlSerializationReader CreateReader()
		{
			return new WebReferenceOptionsSerializationReader();
		}

		protected override XmlSerializationWriter CreateWriter()
		{
			return new WebReferenceOptionsSerializationWriter();
		}

		public override bool CanDeserialize(XmlReader xmlReader)
		{
			return true;
		}

		protected override void Serialize(object objectToSerialize, XmlSerializationWriter writer)
		{
			((WebReferenceOptionsSerializationWriter)writer).Write5_webReferenceOptions(objectToSerialize);
		}

		protected override object Deserialize(XmlSerializationReader reader)
		{
			return ((WebReferenceOptionsSerializationReader)reader).Read5_webReferenceOptions();
		}
	}
	public sealed class WebServicesInteroperability
	{
		private WebServicesInteroperability()
		{
		}

		public static bool CheckConformance(WsiProfiles claims, ServiceDescription description, BasicProfileViolationCollection violations)
		{
			if (description == null)
			{
				throw new ArgumentNullException("description");
			}
			ServiceDescriptionCollection serviceDescriptionCollection = new ServiceDescriptionCollection();
			serviceDescriptionCollection.Add(description);
			return CheckConformance(claims, serviceDescriptionCollection, violations);
		}

		public static bool CheckConformance(WsiProfiles claims, ServiceDescriptionCollection descriptions, BasicProfileViolationCollection violations)
		{
			if ((claims & WsiProfiles.BasicProfile1_1) == 0)
			{
				return true;
			}
			if (descriptions == null)
			{
				throw new ArgumentNullException("descriptions");
			}
			if (violations == null)
			{
				throw new ArgumentNullException("violations");
			}
			int count = violations.Count;
			AnalyzeDescription(descriptions, violations);
			return count == violations.Count;
		}

		public static bool CheckConformance(WsiProfiles claims, WebReference webReference, BasicProfileViolationCollection violations)
		{
			if ((claims & WsiProfiles.BasicProfile1_1) == 0)
			{
				return true;
			}
			if (webReference == null)
			{
				return true;
			}
			if (violations == null)
			{
				throw new ArgumentNullException("violations");
			}
			XmlSchemas schemas = new XmlSchemas();
			ServiceDescriptionCollection descriptions = new ServiceDescriptionCollection();
			StringCollection warnings = new StringCollection();
			foreach (DictionaryEntry document in webReference.Documents)
			{
				ServiceDescriptionImporter.AddDocument((string)document.Key, document.Value, schemas, descriptions, warnings);
			}
			int count = violations.Count;
			AnalyzeDescription(descriptions, violations);
			return count == violations.Count;
		}

		internal static bool AnalyzeBinding(Binding binding, ServiceDescription description, ServiceDescriptionCollection descriptions, BasicProfileViolationCollection violations)
		{
			bool flag = false;
			bool flag2 = false;
			SoapBinding soapBinding = (SoapBinding)binding.Extensions.Find(typeof(SoapBinding));
			if (soapBinding == null || soapBinding.GetType() != typeof(SoapBinding))
			{
				return false;
			}
			SoapBindingStyle soapBindingStyle = ((soapBinding.Style == SoapBindingStyle.Default) ? SoapBindingStyle.Document : soapBinding.Style);
			if (soapBinding.Transport.Length == 0)
			{
				violations.Add("R2701", Res.GetString("BindingMissingAttribute", binding.Name, description.TargetNamespace, "transport"));
			}
			else if (soapBinding.Transport != "http://schemas.xmlsoap.org/soap/http")
			{
				violations.Add("R2702", Res.GetString("BindingInvalidAttribute", binding.Name, description.TargetNamespace, "transport", soapBinding.Transport));
			}
			PortType portType = descriptions.GetPortType(binding.Type);
			Hashtable hashtable = new Hashtable();
			if (portType != null)
			{
				foreach (Operation operation3 in portType.Operations)
				{
					if (operation3.Messages.Flow == OperationFlow.Notification)
					{
						violations.Add("R2303", Res.GetString("OperationFlowNotification", operation3.Name, binding.Type.Namespace, binding.Type.Namespace));
					}
					if (operation3.Messages.Flow == OperationFlow.SolicitResponse)
					{
						violations.Add("R2303", Res.GetString("OperationFlowSolicitResponse", operation3.Name, binding.Type.Namespace, binding.Type.Namespace));
					}
					if (hashtable[operation3.Name] != null)
					{
						violations.Add("R2304", Res.GetString("Operation", operation3.Name, binding.Type.Name, binding.Type.Namespace));
						continue;
					}
					OperationBinding operationBinding = null;
					foreach (OperationBinding operation4 in binding.Operations)
					{
						if (operation3.IsBoundBy(operation4))
						{
							if (operationBinding != null)
							{
								violations.Add("R2304", Res.GetString("OperationBinding", operationBinding.Name, operationBinding.Parent.Name, description.TargetNamespace));
							}
							operationBinding = operation4;
						}
					}
					if (operationBinding == null)
					{
						violations.Add("R2718", Res.GetString("OperationMissingBinding", operation3.Name, binding.Type.Name, binding.Type.Namespace));
					}
					else
					{
						hashtable.Add(operation3.Name, operation3);
					}
				}
			}
			Hashtable wireSignatures = new Hashtable();
			SoapBindingStyle soapBindingStyle2 = SoapBindingStyle.Default;
			foreach (OperationBinding operation5 in binding.Operations)
			{
				SoapBindingStyle soapBindingStyle3 = soapBindingStyle;
				string name = operation5.Name;
				if (name == null)
				{
					continue;
				}
				if (hashtable[name] == null)
				{
					violations.Add("R2718", Res.GetString("PortTypeOperationMissing", operation5.Name, binding.Name, description.TargetNamespace, binding.Type.Name, binding.Type.Namespace));
				}
				Operation operation2 = FindOperation(portType.Operations, operation5);
				SoapOperationBinding soapOperationBinding = (SoapOperationBinding)operation5.Extensions.Find(typeof(SoapOperationBinding));
				if (soapOperationBinding != null)
				{
					if (soapBindingStyle2 == SoapBindingStyle.Default)
					{
						soapBindingStyle2 = soapOperationBinding.Style;
					}
					flag |= soapBindingStyle2 != soapOperationBinding.Style;
					soapBindingStyle3 = ((soapOperationBinding.Style != 0) ? soapOperationBinding.Style : soapBindingStyle);
				}
				if (operation5.Input != null)
				{
					SoapBodyBinding soapBodyBinding = FindSoapBodyBinding(input: true, operation5.Input.Extensions, violations, soapBindingStyle3 == SoapBindingStyle.Document, operation5.Name, binding.Name, description.TargetNamespace);
					if (soapBodyBinding != null && soapBodyBinding.Use != SoapBindingUse.Encoded)
					{
						Message message = ((operation2 == null) ? null : ((operation2.Messages.Input == null) ? null : descriptions.GetMessage(operation2.Messages.Input.Message)));
						if (soapBindingStyle3 == SoapBindingStyle.Rpc)
						{
							CheckMessageParts(message, soapBodyBinding.Parts, element: false, operation5.Name, binding.Name, description.TargetNamespace, wireSignatures, violations);
						}
						else
						{
							flag2 = flag2 || (soapBodyBinding.Parts != null && soapBodyBinding.Parts.Length > 1);
							int num = ((soapBodyBinding.Parts != null) ? soapBodyBinding.Parts.Length : 0);
							CheckMessageParts(message, soapBodyBinding.Parts, element: true, operation5.Name, binding.Name, description.TargetNamespace, wireSignatures, violations);
							if (num == 0 && message != null && message.Parts.Count > 1)
							{
								violations.Add("R2210", Res.GetString("OperationBinding", operation5.Name, binding.Name, description.TargetNamespace));
							}
						}
					}
				}
				if (operation5.Output != null)
				{
					SoapBodyBinding soapBodyBinding2 = FindSoapBodyBinding(input: false, operation5.Output.Extensions, violations, soapBindingStyle3 == SoapBindingStyle.Document, operation5.Name, binding.Name, description.TargetNamespace);
					if (soapBodyBinding2 != null && soapBodyBinding2.Use != SoapBindingUse.Encoded)
					{
						Message message2 = ((operation2 == null) ? null : ((operation2.Messages.Output == null) ? null : descriptions.GetMessage(operation2.Messages.Output.Message)));
						if (soapBindingStyle3 == SoapBindingStyle.Rpc)
						{
							CheckMessageParts(message2, soapBodyBinding2.Parts, element: false, operation5.Name, binding.Name, description.TargetNamespace, null, violations);
						}
						else
						{
							flag2 = flag2 || (soapBodyBinding2.Parts != null && soapBodyBinding2.Parts.Length > 1);
							int num2 = ((soapBodyBinding2.Parts != null) ? soapBodyBinding2.Parts.Length : 0);
							CheckMessageParts(message2, soapBodyBinding2.Parts, element: true, operation5.Name, binding.Name, description.TargetNamespace, null, violations);
							if (num2 == 0 && message2 != null && message2.Parts.Count > 1)
							{
								violations.Add("R2210", Res.GetString("OperationBinding", operation5.Name, binding.Name, description.TargetNamespace));
							}
						}
					}
				}
				foreach (FaultBinding fault in operation5.Faults)
				{
					foreach (ServiceDescriptionFormatExtension extension in fault.Extensions)
					{
						if (!(extension is SoapFaultBinding))
						{
							continue;
						}
						SoapFaultBinding soapFaultBinding = (SoapFaultBinding)extension;
						if (soapFaultBinding.Use == SoapBindingUse.Encoded)
						{
							violations.Add("R2706", MessageString(soapFaultBinding, operation5.Name, binding.Name, description.TargetNamespace, input: false, null));
							continue;
						}
						if (soapFaultBinding.Name == null || soapFaultBinding.Name.Length == 0)
						{
							violations.Add("R2721", Res.GetString("FaultBinding", fault.Name, operation5.Name, binding.Name, description.TargetNamespace));
						}
						else if (soapFaultBinding.Name != fault.Name)
						{
							violations.Add("R2754", Res.GetString("FaultBinding", fault.Name, operation5.Name, binding.Name, description.TargetNamespace));
						}
						if (soapFaultBinding.Namespace != null && soapFaultBinding.Namespace.Length > 0)
						{
							violations.Add((soapBindingStyle3 == SoapBindingStyle.Document) ? "R2716" : "R2726", MessageString(soapFaultBinding, operation5.Name, binding.Name, description.TargetNamespace, input: false, null));
						}
					}
				}
				if (hashtable[operation5.Name] == null)
				{
					violations.Add("R2718", Res.GetString("PortTypeOperationMissing", operation5.Name, binding.Name, description.TargetNamespace, binding.Type.Name, binding.Type.Namespace));
				}
			}
			if (flag2)
			{
				violations.Add("R2201", Res.GetString("BindingMultipleParts", binding.Name, description.TargetNamespace, "parts"));
			}
			if (flag)
			{
				violations.Add("R2705", Res.GetString("Binding", binding.Name, description.TargetNamespace));
			}
			return true;
		}

		internal static void AnalyzeDescription(ServiceDescriptionCollection descriptions, BasicProfileViolationCollection violations)
		{
			bool flag = false;
			foreach (ServiceDescription description in descriptions)
			{
				SchemaCompiler.Compile(description.Types.Schemas);
				CheckWsdlImports(description, violations);
				CheckTypes(description, violations);
				StringEnumerator enumerator2 = description.ValidationWarnings.GetEnumerator();
				try
				{
					while (enumerator2.MoveNext())
					{
						string current = enumerator2.Current;
						violations.Add("R2028, R2029", current);
					}
				}
				finally
				{
					if (enumerator2 is IDisposable disposable)
					{
						disposable.Dispose();
					}
				}
				foreach (Binding binding in description.Bindings)
				{
					flag |= AnalyzeBinding(binding, description, descriptions, violations);
				}
			}
			if (flag)
			{
				CheckExtensions(descriptions, violations);
			}
			else
			{
				violations.Add("Rxxxx");
			}
		}

		private static void CheckWsdlImports(ServiceDescription description, BasicProfileViolationCollection violations)
		{
			foreach (Import import in description.Imports)
			{
				if (import.Location == null || import.Location.Length == 0)
				{
					violations.Add("R2007", Res.GetString("Description", description.TargetNamespace));
				}
				string @namespace = import.Namespace;
				if (@namespace.Length != 0 && !Uri.TryCreate(@namespace, UriKind.Absolute, out var _))
				{
					violations.Add("R2803", Res.GetString("Description", description.TargetNamespace));
				}
			}
		}

		private static void CheckTypes(ServiceDescription description, BasicProfileViolationCollection violations)
		{
			foreach (XmlSchema schema in description.Types.Schemas)
			{
				if (schema.TargetNamespace != null && schema.TargetNamespace.Length != 0)
				{
					continue;
				}
				foreach (XmlSchemaObject item in schema.Items)
				{
					if (!(item is XmlSchemaAnnotation))
					{
						violations.Add("R2105", Res.GetString("Element", "schema", description.TargetNamespace));
						return;
					}
				}
			}
		}

		private static void CheckMessagePart(MessagePart part, bool element, string message, string operation, string binding, string ns, Hashtable wireSignatures, BasicProfileViolationCollection violations)
		{
			if (part == null)
			{
				if (!element)
				{
					AddSignature(wireSignatures, operation, ns, message, ns, violations);
				}
				else
				{
					AddSignature(wireSignatures, null, null, message, ns, violations);
				}
				return;
			}
			if (part.Type != null && !part.Type.IsEmpty && part.Element != null && !part.Element.IsEmpty)
			{
				violations.Add("R2306", Res.GetString("Part", part.Name, message, ns));
			}
			else
			{
				XmlQualifiedName xmlQualifiedName = ((part.Type == null || part.Type.IsEmpty) ? part.Element : part.Type);
				if (xmlQualifiedName.Namespace == null || xmlQualifiedName.Namespace.Length == 0)
				{
					violations.Add("R1014", Res.GetString("Part", part.Name, message, ns));
				}
			}
			if (!element && (part.Type == null || part.Type.IsEmpty))
			{
				violations.Add("R2203", Res.GetString("Part", part.Name, message, ns));
			}
			if (element && (part.Element == null || part.Element.IsEmpty))
			{
				violations.Add("R2204", Res.GetString("Part", part.Name, message, ns));
			}
			if (!element)
			{
				AddSignature(wireSignatures, operation, ns, message, ns, violations);
			}
			else if (part.Element != null)
			{
				AddSignature(wireSignatures, part.Element.Name, part.Element.Namespace, message, ns, violations);
			}
		}

		private static void AddSignature(Hashtable wireSignatures, string name, string ns, string message, string messageNs, BasicProfileViolationCollection violations)
		{
			if (wireSignatures == null)
			{
				return;
			}
			string key = ns + ":" + name;
			string text = (string)wireSignatures[key];
			string text2 = ((ns == null && name == null) ? Res.GetString("WireSignatureEmpty", message, messageNs) : Res.GetString("WireSignature", message, messageNs, ns, name));
			if (text != null)
			{
				if (text.Length > 0)
				{
					violations.Add("R2710", text);
					violations.Add("R2710", text2);
					wireSignatures[key] = string.Empty;
				}
			}
			else
			{
				wireSignatures[key] = text2;
			}
		}

		private static void CheckMessageParts(Message message, string[] parts, bool element, string operation, string binding, string ns, Hashtable wireSignatures, BasicProfileViolationCollection violations)
		{
			if (message == null)
			{
				return;
			}
			if (message.Parts == null || message.Parts.Count == 0)
			{
				if (!element)
				{
					AddSignature(wireSignatures, operation, ns, message.Name, ns, violations);
				}
				else
				{
					AddSignature(wireSignatures, null, null, message.Name, ns, violations);
				}
				return;
			}
			if (parts == null || parts.Length == 0)
			{
				for (int i = 0; i < message.Parts.Count; i++)
				{
					CheckMessagePart(message.Parts[i], element, message.Name, operation, binding, ns, (i == 0) ? wireSignatures : null, violations);
				}
				return;
			}
			for (int j = 0; j < parts.Length; j++)
			{
				if (parts[j] != null)
				{
					_ = message.Parts[parts[j]];
					CheckMessagePart(message.Parts[j], element, message.Name, operation, binding, ns, (j == 0) ? wireSignatures : null, violations);
				}
			}
		}

		private static SoapBodyBinding FindSoapBodyBinding(bool input, ServiceDescriptionFormatExtensionCollection extensions, BasicProfileViolationCollection violations, bool documentBinding, string operationName, string bindingName, string bindingNs)
		{
			SoapBodyBinding soapBodyBinding = null;
			for (int i = 0; i < extensions.Count; i++)
			{
				object obj = extensions[i];
				string text = null;
				bool flag = false;
				bool flag2 = false;
				if (obj is SoapBodyBinding)
				{
					flag = true;
					soapBodyBinding = (SoapBodyBinding)obj;
					text = soapBodyBinding.Namespace;
					flag2 = soapBodyBinding.Use == SoapBindingUse.Encoded;
				}
				else if (obj is SoapHeaderBinding)
				{
					flag = true;
					SoapHeaderBinding soapHeaderBinding = (SoapHeaderBinding)obj;
					text = soapHeaderBinding.Namespace;
					flag2 = soapHeaderBinding.Use == SoapBindingUse.Encoded;
					if (!flag2 && (soapHeaderBinding.Part == null || soapHeaderBinding.Part.Length == 0))
					{
						violations.Add("R2720", MessageString(soapHeaderBinding, operationName, bindingName, bindingNs, input, null));
					}
					if (soapHeaderBinding.Fault != null)
					{
						flag2 |= soapHeaderBinding.Fault.Use == SoapBindingUse.Encoded;
						if (!flag2)
						{
							if (soapHeaderBinding.Fault.Part == null || soapHeaderBinding.Fault.Part.Length == 0)
							{
								violations.Add("R2720", MessageString(soapHeaderBinding.Fault, operationName, bindingName, bindingNs, input, null));
							}
							if (soapHeaderBinding.Fault.Namespace != null && soapHeaderBinding.Fault.Namespace.Length > 0)
							{
								violations.Add(documentBinding ? "R2716" : "R2726", MessageString(obj, operationName, bindingName, bindingNs, input, null));
							}
						}
					}
				}
				if (flag2)
				{
					violations.Add("R2706", MessageString(obj, operationName, bindingName, bindingNs, input, null));
				}
				else
				{
					if (!flag)
					{
						continue;
					}
					Uri result;
					if (text == null || text.Length == 0)
					{
						if (!documentBinding && obj is SoapBodyBinding)
						{
							violations.Add("R2717", MessageString(obj, operationName, bindingName, bindingNs, input, null));
						}
					}
					else if (documentBinding || !(obj is SoapBodyBinding))
					{
						violations.Add(documentBinding ? "R2716" : "R2726", MessageString(obj, operationName, bindingName, bindingNs, input, null));
					}
					else if (!Uri.TryCreate(text, UriKind.Absolute, out result))
					{
						violations.Add("R2717", MessageString(obj, operationName, bindingName, bindingNs, input, Res.GetString("UriValueRelative", text)));
					}
				}
			}
			return soapBodyBinding;
		}

		private static string MessageString(object item, string operation, string binding, string ns, bool input, string details)
		{
			string text = null;
			string text2 = null;
			if (item is SoapBodyBinding)
			{
				text = (input ? "InputElement" : "OutputElement");
				text2 = "soapbind:body";
			}
			else if (item is SoapHeaderBinding)
			{
				text = (input ? "InputElement" : "OutputElement");
				text2 = "soapbind:header";
			}
			else if (item is SoapFaultBinding)
			{
				text = "Fault";
				text2 = ((SoapFaultBinding)item).Name;
			}
			else if (item is SoapHeaderFaultBinding)
			{
				text = "HeaderFault";
				text2 = "soapbind:headerfault";
			}
			if (text == null)
			{
				return null;
			}
			return Res.GetString(text, text2, operation, binding, ns, details);
		}

		private static bool CheckExtensions(ServiceDescriptionFormatExtensionCollection extensions)
		{
			foreach (ServiceDescriptionFormatExtension extension in extensions)
			{
				if (extension.Required)
				{
					return false;
				}
			}
			return true;
		}

		private static void CheckExtensions(Binding binding, ServiceDescription description, BasicProfileViolationCollection violations)
		{
			SoapBinding soapBinding = (SoapBinding)binding.Extensions.Find(typeof(SoapBinding));
			if (soapBinding != null && soapBinding.GetType() == typeof(SoapBinding) && !CheckExtensions(binding.Extensions))
			{
				violations.Add("R2026", Res.GetString("BindingInvalidAttribute", binding.Name, description.TargetNamespace, "wsdl:required", "true"));
			}
		}

		private static void CheckExtensions(ServiceDescriptionCollection descriptions, BasicProfileViolationCollection violations)
		{
			Hashtable hashtable = new Hashtable();
			foreach (ServiceDescription description in descriptions)
			{
				WsiProfiles conformanceClaims = ServiceDescription.GetConformanceClaims(description.Types.DocumentationElement);
				if (conformanceClaims == WsiProfiles.BasicProfile1_1 && !CheckExtensions(description.Extensions))
				{
					violations.Add("R2026", Res.GetString("Element", "wsdl:types", description.TargetNamespace));
				}
				foreach (Service service in description.Services)
				{
					foreach (Port port in service.Ports)
					{
						WsiProfiles conformanceClaims2 = ServiceDescription.GetConformanceClaims(port.DocumentationElement);
						if (conformanceClaims2 == WsiProfiles.BasicProfile1_1)
						{
							if (!CheckExtensions(port.Extensions))
							{
								violations.Add("R2026", Res.GetString("Port", port.Name, service.Name, description.TargetNamespace));
							}
							Binding binding = descriptions.GetBinding(port.Binding);
							if (hashtable[binding] != null)
							{
								CheckExtensions(binding, description, violations);
								hashtable.Add(binding, binding);
							}
						}
					}
				}
				foreach (Binding binding2 in description.Bindings)
				{
					SoapBinding soapBinding = (SoapBinding)binding2.Extensions.Find(typeof(SoapBinding));
					if (soapBinding != null && soapBinding.GetType() == typeof(SoapBinding) && hashtable[binding2] == null)
					{
						WsiProfiles conformanceClaims3 = ServiceDescription.GetConformanceClaims(binding2.DocumentationElement);
						if (conformanceClaims3 == WsiProfiles.BasicProfile1_1)
						{
							CheckExtensions(binding2, description, violations);
							hashtable.Add(binding2, binding2);
						}
					}
				}
			}
		}

		private static Operation FindOperation(OperationCollection operations, OperationBinding bindingOperation)
		{
			foreach (Operation operation in operations)
			{
				if (operation.IsBoundBy(bindingOperation))
				{
					return operation;
				}
			}
			return null;
		}
	}
	public class BasicProfileViolation
	{
		private WsiProfiles claims = WsiProfiles.BasicProfile1_1;

		private string normativeStatement;

		private string details;

		private string recommendation;

		private StringCollection elements;

		public WsiProfiles Claims => claims;

		public string Details
		{
			get
			{
				if (details == null)
				{
					return string.Empty;
				}
				return details;
			}
		}

		public StringCollection Elements
		{
			get
			{
				if (elements == null)
				{
					elements = new StringCollection();
				}
				return elements;
			}
		}

		public string NormativeStatement => normativeStatement;

		public string Recommendation => recommendation;

		internal BasicProfileViolation(string normativeStatement)
			: this(normativeStatement, null)
		{
		}

		internal BasicProfileViolation(string normativeStatement, string element)
		{
			this.normativeStatement = normativeStatement;
			int num = normativeStatement.IndexOf(',');
			if (num >= 0)
			{
				normativeStatement = normativeStatement.Substring(0, num);
			}
			details = Res.GetString("HelpGeneratorServiceConformance" + normativeStatement);
			recommendation = Res.GetString("HelpGeneratorServiceConformance" + normativeStatement + "_r");
			if (element != null)
			{
				Elements.Add(element);
			}
			if (this.normativeStatement == "Rxxxx")
			{
				this.normativeStatement = Res.GetString("Rxxxx");
			}
		}

		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append(normativeStatement);
			stringBuilder.Append(": ");
			stringBuilder.Append(Details);
			StringEnumerator enumerator = Elements.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					string current = enumerator.Current;
					stringBuilder.Append(Environment.NewLine);
					stringBuilder.Append("  -  ");
					stringBuilder.Append(current);
				}
			}
			finally
			{
				if (enumerator is IDisposable disposable)
				{
					disposable.Dispose();
				}
			}
			return stringBuilder.ToString();
		}
	}
	public class BasicProfileViolationCollection : CollectionBase, IEnumerable<BasicProfileViolation>, IEnumerable
	{
		private Hashtable violations = new Hashtable();

		public BasicProfileViolation this[int index]
		{
			get
			{
				return (BasicProfileViolation)base.List[index];
			}
			set
			{
				base.List[index] = value;
			}
		}

		internal int Add(BasicProfileViolation violation)
		{
			BasicProfileViolation basicProfileViolation = (BasicProfileViolation)violations[violation.NormativeStatement];
			if (basicProfileViolation == null)
			{
				violations[violation.NormativeStatement] = violation;
				return base.List.Add(violation);
			}
			StringEnumerator enumerator = violation.Elements.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					string current = enumerator.Current;
					basicProfileViolation.Elements.Add(current);
				}
			}
			finally
			{
				if (enumerator is IDisposable disposable)
				{
					disposable.Dispose();
				}
			}
			return IndexOf(basicProfileViolation);
		}

		internal int Add(string normativeStatement)
		{
			return Add(new BasicProfileViolation(normativeStatement));
		}

		internal int Add(string normativeStatement, string element)
		{
			return Add(new BasicProfileViolation(normativeStatement, element));
		}

		IEnumerator<BasicProfileViolation> IEnumerable<BasicProfileViolation>.GetEnumerator()
		{
			return new BasicProfileViolationEnumerator(this);
		}

		public void Insert(int index, BasicProfileViolation violation)
		{
			base.List.Insert(index, violation);
		}

		public int IndexOf(BasicProfileViolation violation)
		{
			return base.List.IndexOf(violation);
		}

		public bool Contains(BasicProfileViolation violation)
		{
			return base.List.Contains(violation);
		}

		public void Remove(BasicProfileViolation violation)
		{
			base.List.Remove(violation);
		}

		public void CopyTo(BasicProfileViolation[] array, int index)
		{
			base.List.CopyTo(array, index);
		}

		public override string ToString()
		{
			if (base.List.Count > 0)
			{
				StringBuilder stringBuilder = new StringBuilder();
				for (int i = 0; i < base.List.Count; i++)
				{
					BasicProfileViolation basicProfileViolation = this[i];
					if (i != 0)
					{
						stringBuilder.Append(Environment.NewLine);
					}
					stringBuilder.Append(basicProfileViolation.NormativeStatement);
					stringBuilder.Append(": ");
					stringBuilder.Append(basicProfileViolation.Details);
					StringEnumerator enumerator = basicProfileViolation.Elements.GetEnumerator();
					try
					{
						while (enumerator.MoveNext())
						{
							string current = enumerator.Current;
							stringBuilder.Append(Environment.NewLine);
							stringBuilder.Append("  -  ");
							stringBuilder.Append(current);
						}
					}
					finally
					{
						if (enumerator is IDisposable disposable)
						{
							disposable.Dispose();
						}
					}
					if (basicProfileViolation.Recommendation != null && basicProfileViolation.Recommendation.Length > 0)
					{
						stringBuilder.Append(Environment.NewLine);
						stringBuilder.Append(basicProfileViolation.Recommendation);
					}
				}
				return stringBuilder.ToString();
			}
			return string.Empty;
		}
	}
	public class BasicProfileViolationEnumerator : IEnumerator<BasicProfileViolation>, IDisposable, IEnumerator
	{
		private BasicProfileViolationCollection list;

		private int idx;

		private int end;

		public BasicProfileViolation Current => list[idx];

		object IEnumerator.Current => list[idx];

		public BasicProfileViolationEnumerator(BasicProfileViolationCollection list)
		{
			this.list = list;
			idx = -1;
			end = list.Count - 1;
		}

		public void Dispose()
		{
		}

		public bool MoveNext()
		{
			if (idx >= end)
			{
				return false;
			}
			idx++;
			return true;
		}

		void IEnumerator.Reset()
		{
			idx = -1;
		}
	}
}
namespace System.Web.Services.Diagnostics
{
	internal static class Tracing
	{
		private const string TraceSourceAsmx = "System.Web.Services.Asmx";

		private static bool tracingEnabled = true;

		private static bool tracingInitialized;

		private static bool appDomainShutdown;

		private static TraceSource asmxTraceSource;

		private static object internalSyncObject;

		private static object InternalSyncObject
		{
			get
			{
				if (internalSyncObject == null)
				{
					object value = new object();
					Interlocked.CompareExchange(ref internalSyncObject, value, null);
				}
				return internalSyncObject;
			}
		}

		internal static bool On
		{
			get
			{
				if (!tracingInitialized)
				{
					InitializeLogging();
				}
				return tracingEnabled;
			}
		}

		internal static bool IsVerbose => ValidateSettings(Asmx, TraceEventType.Verbose);

		internal static TraceSource Asmx
		{
			get
			{
				if (!tracingInitialized)
				{
					InitializeLogging();
				}
				if (!tracingEnabled)
				{
					return null;
				}
				return asmxTraceSource;
			}
		}

		private static void InitializeLogging()
		{
			lock (InternalSyncObject)
			{
				if (!tracingInitialized)
				{
					bool flag = false;
					asmxTraceSource = new TraceSource("System.Web.Services.Asmx");
					if (asmxTraceSource.Switch.ShouldTrace(TraceEventType.Critical))
					{
						flag = true;
						AppDomain currentDomain = AppDomain.CurrentDomain;
						currentDomain.UnhandledException += UnhandledExceptionHandler;
						currentDomain.DomainUnload += AppDomainUnloadEvent;
						currentDomain.ProcessExit += ProcessExitEvent;
					}
					tracingEnabled = flag;
					tracingInitialized = true;
				}
			}
		}

		private static void Close()
		{
			if (asmxTraceSource != null)
			{
				asmxTraceSource.Close();
			}
		}

		private static void UnhandledExceptionHandler(object sender, UnhandledExceptionEventArgs args)
		{
			Exception e = (Exception)args.ExceptionObject;
			ExceptionCatch(TraceEventType.Error, sender, "UnhandledExceptionHandler", e);
		}

		private static void ProcessExitEvent(object sender, EventArgs e)
		{
			Close();
			appDomainShutdown = true;
		}

		private static void AppDomainUnloadEvent(object sender, EventArgs e)
		{
			Close();
			appDomainShutdown = true;
		}

		private static bool ValidateSettings(TraceSource traceSource, TraceEventType traceLevel)
		{
			if (!tracingEnabled)
			{
				return false;
			}
			if (!tracingInitialized)
			{
				InitializeLogging();
			}
			if (traceSource == null || !traceSource.Switch.ShouldTrace(traceLevel))
			{
				return false;
			}
			if (appDomainShutdown)
			{
				return false;
			}
			return true;
		}

		internal static void Information(string format, params object[] args)
		{
			if (ValidateSettings(Asmx, TraceEventType.Information))
			{
				TraceEvent(TraceEventType.Information, Res.GetString(format, args));
			}
		}

		private static void TraceEvent(TraceEventType eventType, string format)
		{
			Asmx.TraceEvent(eventType, 0, format);
		}

		internal static Exception ExceptionThrow(TraceMethod method, Exception e)
		{
			return ExceptionThrow(TraceEventType.Error, method, e);
		}

		internal static Exception ExceptionThrow(TraceEventType eventType, TraceMethod method, Exception e)
		{
			if (!ValidateSettings(Asmx, eventType))
			{
				return e;
			}
			TraceEvent(eventType, Res.GetString("TraceExceptionThrown", method.ToString(), e.GetType(), e.Message));
			StackTrace(eventType, e);
			return e;
		}

		internal static Exception ExceptionCatch(TraceMethod method, Exception e)
		{
			return ExceptionCatch(TraceEventType.Error, method, e);
		}

		internal static Exception ExceptionCatch(TraceEventType eventType, TraceMethod method, Exception e)
		{
			if (!ValidateSettings(Asmx, eventType))
			{
				return e;
			}
			TraceEvent(eventType, Res.GetString("TraceExceptionCought", method, e.GetType(), e.Message));
			StackTrace(eventType, e);
			return e;
		}

		internal static Exception ExceptionCatch(TraceEventType eventType, object target, string method, Exception e)
		{
			if (!ValidateSettings(Asmx, eventType))
			{
				return e;
			}
			TraceEvent(eventType, Res.GetString("TraceExceptionCought", TraceMethod.MethodId(target, method), e.GetType(), e.Message));
			StackTrace(eventType, e);
			return e;
		}

		internal static Exception ExceptionIgnore(TraceEventType eventType, TraceMethod method, Exception e)
		{
			if (!ValidateSettings(Asmx, eventType))
			{
				return e;
			}
			TraceEvent(eventType, Res.GetString("TraceExceptionIgnored", method, e.GetType(), e.Message));
			StackTrace(eventType, e);
			return e;
		}

		private static void StackTrace(TraceEventType eventType, Exception e)
		{
			if (IsVerbose && !string.IsNullOrEmpty(e.StackTrace))
			{
				TraceEvent(eventType, Res.GetString("TraceExceptionDetails", e.ToString()));
			}
		}

		internal static string TraceId(string id)
		{
			return Res.GetString(id);
		}

		private static string GetHostByAddress(string ipAddress)
		{
			try
			{
				return Dns.GetHostByAddress(ipAddress).HostName;
			}
			catch
			{
				return null;
			}
		}

		internal static List<string> Details(HttpRequest request)
		{
			if (request == null)
			{
				return null;
			}
			List<string> list = null;
			list = new List<string>();
			list.Add(Res.GetString("TraceUserHostAddress", request.UserHostAddress));
			string text = ((request.UserHostAddress == request.UserHostName) ? GetHostByAddress(request.UserHostAddress) : request.UserHostName);
			if (!string.IsNullOrEmpty(text))
			{
				list.Add(Res.GetString("TraceUserHostName", text));
			}
			list.Add(Res.GetString("TraceUrl", request.HttpMethod, request.Url));
			if (request.UrlReferrer != null)
			{
				list.Add(Res.GetString("TraceUrlReferrer", request.UrlReferrer));
			}
			return list;
		}

		internal static void Enter(string callId, TraceMethod caller)
		{
			Enter(callId, caller, null, null);
		}

		internal static void Enter(string callId, TraceMethod caller, List<string> details)
		{
			Enter(callId, caller, null, details);
		}

		internal static void Enter(string callId, TraceMethod caller, TraceMethod callDetails)
		{
			Enter(callId, caller, callDetails, null);
		}

		internal static void Enter(string callId, TraceMethod caller, TraceMethod callDetails, List<string> details)
		{
			if (!ValidateSettings(Asmx, TraceEventType.Information))
			{
				return;
			}
			string text = ((callDetails == null) ? Res.GetString("TraceCallEnter", callId, caller) : Res.GetString("TraceCallEnterDetails", callId, caller, callDetails));
			if (details != null && details.Count > 0)
			{
				StringBuilder stringBuilder = new StringBuilder(text);
				foreach (string detail in details)
				{
					stringBuilder.Append(Environment.NewLine);
					stringBuilder.Append("    ");
					stringBuilder.Append(detail);
				}
				text = stringBuilder.ToString();
			}
			TraceEvent(TraceEventType.Information, text);
		}

		internal static XmlDeserializationEvents GetDeserializationEvents()
		{
			XmlDeserializationEvents result = default(XmlDeserializationEvents);
			result.OnUnknownElement = OnUnknownElement;
			result.OnUnknownAttribute = OnUnknownAttribute;
			return result;
		}

		internal static void Exit(string callId, TraceMethod caller)
		{
			if (ValidateSettings(Asmx, TraceEventType.Information))
			{
				TraceEvent(TraceEventType.Information, Res.GetString("TraceCallExit", callId, caller));
			}
		}

		internal static void OnUnknownElement(object sender, XmlElementEventArgs e)
		{
			if (ValidateSettings(Asmx, TraceEventType.Warning) && e.Element != null)
			{
				string text = RuntimeUtils.ElementString(e.Element);
				string name = ((e.ExpectedElements == null) ? "WebUnknownElement" : ((e.ExpectedElements.Length == 0) ? "WebUnknownElement1" : "WebUnknownElement2"));
				TraceEvent(TraceEventType.Warning, Res.GetString(name, text, e.ExpectedElements));
			}
		}

		internal static void OnUnknownAttribute(object sender, XmlAttributeEventArgs e)
		{
			if (ValidateSettings(Asmx, TraceEventType.Warning) && e.Attr != null && !RuntimeUtils.IsKnownNamespace(e.Attr.NamespaceURI))
			{
				string name = ((e.ExpectedAttributes == null) ? "WebUnknownAttribute" : ((e.ExpectedAttributes.Length == 0) ? "WebUnknownAttribute2" : "WebUnknownAttribute3"));
				TraceEvent(TraceEventType.Warning, Res.GetString(name, e.Attr.Name, e.Attr.Value, e.ExpectedAttributes));
			}
		}
	}
	internal class TraceMethod
	{
		private object target;

		private string name;

		private object[] args;

		private string call;

		internal TraceMethod(object target, string name, params object[] args)
		{
			this.target = target;
			this.name = name;
			this.args = args;
		}

		public override string ToString()
		{
			if (call == null)
			{
				call = CallString(target, name, args);
			}
			return call;
		}

		internal static string CallString(object target, string method, params object[] args)
		{
			StringBuilder stringBuilder = new StringBuilder();
			WriteObjectId(stringBuilder, target);
			stringBuilder.Append(':');
			stringBuilder.Append(':');
			stringBuilder.Append(method);
			stringBuilder.Append('(');
			for (int i = 0; i < args.Length; i++)
			{
				object obj = args[i];
				WriteObjectId(stringBuilder, obj);
				if (obj != null)
				{
					stringBuilder.Append('=');
					WriteValue(stringBuilder, obj);
				}
				if (i + 1 < args.Length)
				{
					stringBuilder.Append(',');
					stringBuilder.Append(' ');
				}
			}
			stringBuilder.Append(')');
			return stringBuilder.ToString();
		}

		internal static string MethodId(object target, string method)
		{
			StringBuilder stringBuilder = new StringBuilder();
			WriteObjectId(stringBuilder, target);
			stringBuilder.Append(':');
			stringBuilder.Append(':');
			stringBuilder.Append(method);
			return stringBuilder.ToString();
		}

		private static void WriteObjectId(StringBuilder sb, object o)
		{
			if (o == null)
			{
				sb.Append("(null)");
			}
			else if (o is Type)
			{
				Type type = (Type)o;
				sb.Append(type.FullName);
				if (!type.IsAbstract || !type.IsSealed)
				{
					sb.Append('#');
					sb.Append(HashString(o));
				}
			}
			else
			{
				sb.Append(o.GetType().FullName);
				sb.Append('#');
				sb.Append(HashString(o));
			}
		}

		private static void WriteValue(StringBuilder sb, object o)
		{
			if (o == null)
			{
				return;
			}
			if (o is string)
			{
				sb.Append('"');
				sb.Append(o);
				sb.Append('"');
				return;
			}
			Type type = o.GetType();
			if (type.IsArray)
			{
				sb.Append('[');
				sb.Append(((Array)o).Length);
				sb.Append(']');
				return;
			}
			string text = o.ToString();
			if (type.FullName == text)
			{
				sb.Append('.');
				sb.Append('.');
			}
			else
			{
				sb.Append(text);
			}
		}

		private static string HashString(object objectValue)
		{
			if (objectValue == null)
			{
				return "(null)";
			}
			return objectValue.GetHashCode().ToString(NumberFormatInfo.InvariantInfo);
		}
	}
}
namespace System.Web.Services.Configuration
{
	public enum PriorityGroup
	{
		High,
		Low
	}
	public sealed class DiagnosticsElement : ConfigurationElement
	{
		private ConfigurationPropertyCollection properties = new ConfigurationPropertyCollection();

		private readonly ConfigurationProperty suppressReturningExceptions = new ConfigurationProperty("suppressReturningExceptions", typeof(bool), false);

		[ConfigurationProperty("suppressReturningExceptions", DefaultValue = false)]
		public bool SuppressReturningExceptions
		{
			get
			{
				return (bool)base[suppressReturningExceptions];
			}
			set
			{
				base[suppressReturningExceptions] = value;
			}
		}

		protected internal override ConfigurationPropertyCollection Properties
		{
			protected get
			{
				return properties;
			}
		}

		public DiagnosticsElement()
		{
			properties.Add(suppressReturningExceptions);
		}
	}
	public sealed class SoapEnvelopeProcessingElement : ConfigurationElement
	{
		private ConfigurationPropertyCollection properties = new ConfigurationPropertyCollection();

		private readonly ConfigurationProperty readTimeout = new ConfigurationProperty("readTimeout", typeof(int), int.MaxValue, new InfiniteIntConverter(), null, ConfigurationPropertyOptions.None);

		private readonly ConfigurationProperty strict = new ConfigurationProperty("strict", typeof(bool), false);

		[ConfigurationProperty("readTimeout", DefaultValue = int.MaxValue)]
		[TypeConverter(typeof(InfiniteIntConverter))]
		public int ReadTimeout
		{
			get
			{
				return (int)base[readTimeout];
			}
			set
			{
				base[readTimeout] = value;
			}
		}

		[ConfigurationProperty("strict", DefaultValue = false)]
		public bool IsStrict
		{
			get
			{
				return (bool)base[strict];
			}
			set
			{
				base[strict] = value;
			}
		}

		protected internal override ConfigurationPropertyCollection Properties
		{
			protected get
			{
				return properties;
			}
		}

		public SoapEnvelopeProcessingElement()
		{
			properties.Add(readTimeout);
			properties.Add(strict);
		}

		public SoapEnvelopeProcessingElement(int readTimeout)
			: this()
		{
			ReadTimeout = readTimeout;
		}

		public SoapEnvelopeProcessingElement(int readTimeout, bool strict)
			: this()
		{
			ReadTimeout = readTimeout;
			IsStrict = strict;
		}
	}
	public sealed class SoapExtensionTypeElement : ConfigurationElement
	{
		private ConfigurationPropertyCollection properties = new ConfigurationPropertyCollection();

		private readonly ConfigurationProperty group = new ConfigurationProperty("group", typeof(PriorityGroup), PriorityGroup.Low, new EnumConverter(typeof(PriorityGroup)), null, ConfigurationPropertyOptions.IsKey);

		private readonly ConfigurationProperty priority = new ConfigurationProperty("priority", typeof(int), 0, null, new IntegerValidator(0, int.MaxValue), ConfigurationPropertyOptions.IsKey);

		private readonly ConfigurationProperty type = new ConfigurationProperty("type", typeof(Type), null, new TypeTypeConverter(), null, ConfigurationPropertyOptions.IsKey);

		[ConfigurationProperty("group", IsKey = true, DefaultValue = PriorityGroup.Low)]
		public PriorityGroup Group
		{
			get
			{
				return (PriorityGroup)base[group];
			}
			set
			{
				if (Enum.IsDefined(typeof(PriorityGroup), value))
				{
					base[group] = value;
					return;
				}
				throw new ArgumentException(Res.GetString("Invalid_priority_group_value"), "value");
			}
		}

		[ConfigurationProperty("priority", IsKey = true, DefaultValue = 0)]
		[IntegerValidator(MinValue = 0)]
		public int Priority
		{
			get
			{
				return (int)base[priority];
			}
			set
			{
				base[priority] = value;
			}
		}

		[TypeConverter(typeof(TypeTypeConverter))]
		[ConfigurationProperty("type", IsKey = true)]
		public Type Type
		{
			get
			{
				return (Type)base[type];
			}
			set
			{
				base[type] = value;
			}
		}

		protected internal override ConfigurationPropertyCollection Properties
		{
			protected get
			{
				return properties;
			}
		}

		public SoapExtensionTypeElement()
		{
			properties.Add(group);
			properties.Add(priority);
			properties.Add(type);
		}

		public SoapExtensionTypeElement(string type, int priority, PriorityGroup group)
			: this()
		{
			Type = Type.GetType(type, throwOnError: true, ignoreCase: true);
			Priority = priority;
			Group = group;
		}

		public SoapExtensionTypeElement(Type type, int priority, PriorityGroup group)
			: this(type.AssemblyQualifiedName, priority, group)
		{
		}
	}
	internal class TypeAndNameConverter : TypeConverter
	{
		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
		{
			if (sourceType == typeof(string))
			{
				return true;
			}
			return base.CanConvertFrom(context, sourceType);
		}

		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
		{
			if (value is string)
			{
				return new TypeAndName((string)value);
			}
			return base.ConvertFrom(context, culture, value);
		}

		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
		{
			if (destinationType == typeof(string))
			{
				TypeAndName typeAndName = (TypeAndName)value;
				if (typeAndName.name != null)
				{
					return typeAndName.name;
				}
				return typeAndName.type.AssemblyQualifiedName;
			}
			return base.ConvertTo(context, culture, value, destinationType);
		}
	}
	internal class TypeTypeConverter : TypeAndNameConverter
	{
		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
		{
			return base.CanConvertFrom(context, sourceType);
		}

		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
		{
			if (value is string)
			{
				TypeAndName typeAndName = (TypeAndName)base.ConvertFrom(context, culture, value);
				return typeAndName.type;
			}
			return base.ConvertFrom(context, culture, value);
		}

		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
		{
			if (destinationType == typeof(string))
			{
				TypeAndName value2 = new TypeAndName((Type)value);
				return base.ConvertTo(context, culture, (object)value2, destinationType);
			}
			return base.ConvertTo(context, culture, value, destinationType);
		}
	}
	[ConfigurationCollection(typeof(SoapExtensionTypeElement))]
	public sealed class SoapExtensionTypeElementCollection : ConfigurationElementCollection
	{
		public SoapExtensionTypeElement this[object key]
		{
			get
			{
				if (key == null)
				{
					throw new ArgumentNullException("key");
				}
				SoapExtensionTypeElement soapExtensionTypeElement = (SoapExtensionTypeElement)BaseGet(key);
				if (soapExtensionTypeElement == null)
				{
					throw new KeyNotFoundException(string.Format(CultureInfo.InvariantCulture, Res.GetString("ConfigKeyNotFoundInElementCollection"), key.ToString()));
				}
				return soapExtensionTypeElement;
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				if (key == null)
				{
					throw new ArgumentNullException("key");
				}
				if (GetElementKey(value).Equals(key))
				{
					if (BaseGet(key) != null)
					{
						BaseRemove(key);
					}
					Add(value);
					return;
				}
				throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, Res.GetString("ConfigKeysDoNotMatch"), GetElementKey(value).ToString(), key.ToString()));
			}
		}

		public SoapExtensionTypeElement this[int index]
		{
			get
			{
				return (SoapExtensionTypeElement)BaseGet(index);
			}
			set
			{
				if (BaseGet(index) != null)
				{
					BaseRemoveAt(index);
				}
				BaseAdd(index, value);
			}
		}

		public void Add(SoapExtensionTypeElement element)
		{
			if (element == null)
			{
				throw new ArgumentNullException("element");
			}
			BaseAdd(element);
		}

		public void Clear()
		{
			BaseClear();
		}

		public bool ContainsKey(object key)
		{
			if (key == null)
			{
				throw new ArgumentNullException("key");
			}
			return BaseGet(key) != null;
		}

		protected override ConfigurationElement CreateNewElement()
		{
			return new SoapExtensionTypeElement();
		}

		public void CopyTo(SoapExtensionTypeElement[] array, int index)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			((ICollection)this).CopyTo((Array)array, index);
		}

		protected override object GetElementKey(ConfigurationElement element)
		{
			if (element == null)
			{
				throw new ArgumentNullException("element");
			}
			return element;
		}

		public int IndexOf(SoapExtensionTypeElement element)
		{
			if (element == null)
			{
				throw new ArgumentNullException("element");
			}
			return BaseIndexOf(element);
		}

		public void Remove(SoapExtensionTypeElement element)
		{
			if (element == null)
			{
				throw new ArgumentNullException("element");
			}
			BaseRemove(GetElementKey(element));
		}

		public void RemoveAt(object key)
		{
			if (key == null)
			{
				throw new ArgumentNullException("key");
			}
			BaseRemove(key);
		}

		public void RemoveAt(int index)
		{
			BaseRemoveAt(index);
		}
	}
	public sealed class TypeElement : ConfigurationElement
	{
		private ConfigurationPropertyCollection properties = new ConfigurationPropertyCollection();

		private readonly ConfigurationProperty type = new ConfigurationProperty("type", typeof(TypeAndName), null, new TypeAndNameConverter(), null, ConfigurationPropertyOptions.IsKey);

		[ConfigurationProperty("type", IsKey = true)]
		[TypeConverter(typeof(TypeAndNameConverter))]
		public Type Type
		{
			get
			{
				return ((TypeAndName)base[type]).type;
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				base[type] = new TypeAndName(value);
			}
		}

		protected internal override ConfigurationPropertyCollection Properties
		{
			protected get
			{
				return properties;
			}
		}

		public TypeElement()
		{
			properties.Add(type);
		}

		public TypeElement(string type)
			: this()
		{
			base[this.type] = new TypeAndName(type);
		}

		public TypeElement(Type type)
			: this(type.AssemblyQualifiedName)
		{
		}
	}
	internal class TypeAndName
	{
		public readonly Type type;

		public readonly string name;

		public TypeAndName(string name)
		{
			type = Type.GetType(name, throwOnError: true, ignoreCase: true);
			this.name = name;
		}

		public TypeAndName(Type type)
		{
			this.type = type;
		}

		public override int GetHashCode()
		{
			return type.GetHashCode();
		}

		public override bool Equals(object comparand)
		{
			return type.Equals(((TypeAndName)comparand).type);
		}
	}
	[ConfigurationCollection(typeof(TypeElement))]
	public sealed class TypeElementCollection : ConfigurationElementCollection
	{
		public TypeElement this[object key]
		{
			get
			{
				if (key == null)
				{
					throw new ArgumentNullException("key");
				}
				TypeElement typeElement = (TypeElement)BaseGet(key);
				if (typeElement == null)
				{
					throw new KeyNotFoundException(string.Format(CultureInfo.InvariantCulture, Res.GetString("ConfigKeyNotFoundInElementCollection"), key.ToString()));
				}
				return typeElement;
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				if (key == null)
				{
					throw new ArgumentNullException("key");
				}
				if (GetElementKey(value).Equals(key))
				{
					if (BaseGet(key) != null)
					{
						BaseRemove(key);
					}
					Add(value);
					return;
				}
				throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, Res.GetString("ConfigKeysDoNotMatch"), GetElementKey(value).ToString(), key.ToString()));
			}
		}

		public TypeElement this[int index]
		{
			get
			{
				return (TypeElement)BaseGet(index);
			}
			set
			{
				if (BaseGet(index) != null)
				{
					BaseRemoveAt(index);
				}
				BaseAdd(index, value);
			}
		}

		public void Add(TypeElement element)
		{
			if (element == null)
			{
				throw new ArgumentNullException("element");
			}
			BaseAdd(element);
		}

		public void Clear()
		{
			BaseClear();
		}

		public bool ContainsKey(object key)
		{
			if (key == null)
			{
				throw new ArgumentNullException("key");
			}
			return BaseGet(key) != null;
		}

		protected override ConfigurationElement CreateNewElement()
		{
			return new TypeElement();
		}

		public void CopyTo(TypeElement[] array, int index)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			((ICollection)this).CopyTo((Array)array, index);
		}

		protected override object GetElementKey(ConfigurationElement element)
		{
			if (element == null)
			{
				throw new ArgumentNullException("element");
			}
			TypeElement typeElement = (TypeElement)element;
			return typeElement.Type;
		}

		public int IndexOf(TypeElement element)
		{
			if (element == null)
			{
				throw new ArgumentNullException("element");
			}
			return BaseIndexOf(element);
		}

		public void Remove(TypeElement element)
		{
			if (element == null)
			{
				throw new ArgumentNullException("element");
			}
			BaseRemove(GetElementKey(element));
		}

		public void RemoveAt(object key)
		{
			if (key == null)
			{
				throw new ArgumentNullException("key");
			}
			BaseRemove(key);
		}

		public void RemoveAt(int index)
		{
			BaseRemoveAt(index);
		}
	}
	public sealed class WebServicesSection : ConfigurationSection
	{
		private const string SectionName = "system.web/webServices";

		private ConfigurationPropertyCollection properties = new ConfigurationPropertyCollection();

		private static object classSyncObject;

		private readonly ConfigurationProperty conformanceWarnings = new ConfigurationProperty("conformanceWarnings", typeof(WsiProfilesElementCollection), null, ConfigurationPropertyOptions.None);

		private readonly ConfigurationProperty protocols = new ConfigurationProperty("protocols", typeof(ProtocolElementCollection), null, ConfigurationPropertyOptions.None);

		private readonly ConfigurationProperty serviceDescriptionFormatExtensionTypes = new ConfigurationProperty("serviceDescriptionFormatExtensionTypes", typeof(TypeElementCollection), null, ConfigurationPropertyOptions.None);

		private readonly ConfigurationProperty soapEnvelopeProcessing = new ConfigurationProperty("soapEnvelopeProcessing", typeof(SoapEnvelopeProcessingElement), null, ConfigurationPropertyOptions.None);

		private readonly ConfigurationProperty soapExtensionImporterTypes = new ConfigurationProperty("soapExtensionImporterTypes", typeof(TypeElementCollection), null, ConfigurationPropertyOptions.None);

		private readonly ConfigurationProperty soapExtensionReflectorTypes = new ConfigurationProperty("soapExtensionReflectorTypes", typeof(TypeElementCollection), null, ConfigurationPropertyOptions.None);

		private readonly ConfigurationProperty soapExtensionTypes = new ConfigurationProperty("soapExtensionTypes", typeof(SoapExtensionTypeElementCollection), null, ConfigurationPropertyOptions.None);

		private readonly ConfigurationProperty soapTransportImporterTypes = new ConfigurationProperty("soapTransportImporterTypes", typeof(TypeElementCollection), null, ConfigurationPropertyOptions.None);

		private readonly ConfigurationProperty wsdlHelpGenerator = new ConfigurationProperty("wsdlHelpGenerator", typeof(WsdlHelpGeneratorElement), null, ConfigurationPropertyOptions.None);

		private readonly ConfigurationProperty soapServerProtocolFactoryType = new ConfigurationProperty("soapServerProtocolFactory", typeof(TypeElement), null, ConfigurationPropertyOptions.None);

		private readonly ConfigurationProperty diagnostics = new ConfigurationProperty("diagnostics", typeof(DiagnosticsElement), null, ConfigurationPropertyOptions.None);

		private Type[] defaultFormatTypes = new Type[21]
		{
			typeof(HttpAddressBinding),
			typeof(HttpBinding),
			typeof(HttpOperationBinding),
			typeof(HttpUrlEncodedBinding),
			typeof(HttpUrlReplacementBinding),
			typeof(MimeContentBinding),
			typeof(MimeXmlBinding),
			typeof(MimeMultipartRelatedBinding),
			typeof(MimeTextBinding),
			typeof(System.Web.Services.Description.SoapBinding),
			typeof(SoapOperationBinding),
			typeof(SoapBodyBinding),
			typeof(SoapFaultBinding),
			typeof(SoapHeaderBinding),
			typeof(SoapAddressBinding),
			typeof(Soap12Binding),
			typeof(Soap12OperationBinding),
			typeof(Soap12BodyBinding),
			typeof(Soap12FaultBinding),
			typeof(Soap12HeaderBinding),
			typeof(Soap12AddressBinding)
		};

		private Type[] discoveryReferenceTypes = new Type[4]
		{
			typeof(DiscoveryDocumentReference),
			typeof(ContractReference),
			typeof(SchemaReference),
			typeof(System.Web.Services.Discovery.SoapBinding)
		};

		private XmlSerializer discoveryDocumentSerializer;

		private WebServiceProtocols enabledProtocols;

		private Type[] mimeImporterTypes = new Type[3]
		{
			typeof(MimeXmlImporter),
			typeof(MimeFormImporter),
			typeof(MimeTextImporter)
		};

		private Type[] mimeReflectorTypes = new Type[2]
		{
			typeof(MimeXmlReflector),
			typeof(MimeFormReflector)
		};

		private Type[] parameterReaderTypes = new Type[2]
		{
			typeof(UrlParameterReader),
			typeof(HtmlFormParameterReader)
		};

		private Type[] protocolImporterTypes = new Type[0];

		private Type[] protocolReflectorTypes = new Type[0];

		private Type[] returnWriterTypes = new Type[1] { typeof(XmlReturnWriter) };

		private ServerProtocolFactory[] serverProtocolFactories;

		private Type soapServerProtocolFactory;

		private static object ClassSyncObject
		{
			get
			{
				if (classSyncObject == null)
				{
					object value = new object();
					Interlocked.CompareExchange(ref classSyncObject, value, null);
				}
				return classSyncObject;
			}
		}

		[ConfigurationProperty("conformanceWarnings")]
		public WsiProfilesElementCollection ConformanceWarnings => (WsiProfilesElementCollection)base[conformanceWarnings];

		internal WsiProfiles EnabledConformanceWarnings
		{
			get
			{
				WsiProfiles wsiProfiles = WsiProfiles.None;
				foreach (WsiProfilesElement conformanceWarning in ConformanceWarnings)
				{
					wsiProfiles |= conformanceWarning.Name;
				}
				return wsiProfiles;
			}
		}

		public static WebServicesSection Current
		{
			get
			{
				WebServicesSection webServicesSection = null;
				if (Thread.GetDomain().GetData(".appDomain") != null)
				{
					webServicesSection = GetConfigFromHttpContext();
				}
				if (webServicesSection == null)
				{
					webServicesSection = (WebServicesSection)System.Configuration.PrivilegedConfigurationManager.GetSection("system.web/webServices");
				}
				return webServicesSection;
			}
		}

		internal XmlSerializer DiscoveryDocumentSerializer
		{
			get
			{
				if (discoveryDocumentSerializer == null)
				{
					lock (ClassSyncObject)
					{
						if (discoveryDocumentSerializer == null)
						{
							XmlAttributeOverrides xmlAttributeOverrides = new XmlAttributeOverrides();
							XmlAttributes xmlAttributes = new XmlAttributes();
							Type[] array = DiscoveryReferenceTypes;
							foreach (Type type in array)
							{
								object[] customAttributes = type.GetCustomAttributes(typeof(XmlRootAttribute), inherit: false);
								if (customAttributes.Length == 0)
								{
									throw new InvalidOperationException(Res.GetString("WebMissingCustomAttribute", type.FullName, "XmlRoot"));
								}
								string elementName = ((XmlRootAttribute)customAttributes[0]).ElementName;
								string @namespace = ((XmlRootAttribute)customAttributes[0]).Namespace;
								XmlElementAttribute xmlElementAttribute = new XmlElementAttribute(elementName, type);
								xmlElementAttribute.Namespace = @namespace;
								xmlAttributes.XmlElements.Add(xmlElementAttribute);
							}
							xmlAttributeOverrides.Add(typeof(DiscoveryDocument), "References", xmlAttributes);
							discoveryDocumentSerializer = new DiscoveryDocumentSerializer();
						}
					}
				}
				return discoveryDocumentSerializer;
			}
		}

		internal Type[] DiscoveryReferenceTypes => discoveryReferenceTypes;

		public WebServiceProtocols EnabledProtocols
		{
			get
			{
				if (enabledProtocols == WebServiceProtocols.Unknown)
				{
					lock (ClassSyncObject)
					{
						if (enabledProtocols == WebServiceProtocols.Unknown)
						{
							WebServiceProtocols webServiceProtocols = WebServiceProtocols.Unknown;
							foreach (ProtocolElement protocol in Protocols)
							{
								webServiceProtocols |= protocol.Name;
							}
							enabledProtocols = webServiceProtocols;
						}
					}
				}
				return enabledProtocols;
			}
		}

		internal Type[] MimeImporterTypes => mimeImporterTypes;

		internal Type[] MimeReflectorTypes => mimeReflectorTypes;

		internal Type[] ParameterReaderTypes => parameterReaderTypes;

		protected internal override ConfigurationPropertyCollection Properties
		{
			protected get
			{
				return properties;
			}
		}

		internal Type[] ProtocolImporterTypes
		{
			get
			{
				if (protocolImporterTypes.Length == 0)
				{
					lock (ClassSyncObject)
					{
						if (protocolImporterTypes.Length == 0)
						{
							WebServiceProtocols webServiceProtocols = EnabledProtocols;
							List<Type> list = new List<Type>();
							if ((webServiceProtocols & WebServiceProtocols.HttpSoap) != 0)
							{
								list.Add(typeof(SoapProtocolImporter));
							}
							if ((webServiceProtocols & WebServiceProtocols.HttpSoap12) != 0)
							{
								list.Add(typeof(Soap12ProtocolImporter));
							}
							if ((webServiceProtocols & WebServiceProtocols.HttpGet) != 0)
							{
								list.Add(typeof(HttpGetProtocolImporter));
							}
							if ((webServiceProtocols & WebServiceProtocols.HttpPost) != 0)
							{
								list.Add(typeof(HttpPostProtocolImporter));
							}
							protocolImporterTypes = list.ToArray();
						}
					}
				}
				return protocolImporterTypes;
			}
			set
			{
				protocolImporterTypes = value;
			}
		}

		internal Type[] ProtocolReflectorTypes
		{
			get
			{
				if (protocolReflectorTypes.Length == 0)
				{
					lock (ClassSyncObject)
					{
						if (protocolReflectorTypes.Length == 0)
						{
							WebServiceProtocols webServiceProtocols = EnabledProtocols;
							List<Type> list = new List<Type>();
							if ((webServiceProtocols & WebServiceProtocols.HttpSoap) != 0)
							{
								list.Add(typeof(SoapProtocolReflector));
							}
							if ((webServiceProtocols & WebServiceProtocols.HttpSoap12) != 0)
							{
								list.Add(typeof(Soap12ProtocolReflector));
							}
							if ((webServiceProtocols & WebServiceProtocols.HttpGet) != 0)
							{
								list.Add(typeof(HttpGetProtocolReflector));
							}
							if ((webServiceProtocols & WebServiceProtocols.HttpPost) != 0)
							{
								list.Add(typeof(HttpPostProtocolReflector));
							}
							protocolReflectorTypes = list.ToArray();
						}
					}
				}
				return protocolReflectorTypes;
			}
			set
			{
				protocolReflectorTypes = value;
			}
		}

		[ConfigurationProperty("protocols")]
		public ProtocolElementCollection Protocols => (ProtocolElementCollection)base[protocols];

		[ConfigurationProperty("soapEnvelopeProcessing")]
		public SoapEnvelopeProcessingElement SoapEnvelopeProcessing
		{
			get
			{
				return (SoapEnvelopeProcessingElement)base[soapEnvelopeProcessing];
			}
			set
			{
				base[soapEnvelopeProcessing] = value;
			}
		}

		public DiagnosticsElement Diagnostics
		{
			get
			{
				return (DiagnosticsElement)base[diagnostics];
			}
			set
			{
				base[diagnostics] = value;
			}
		}

		internal Type[] ReturnWriterTypes => returnWriterTypes;

		internal ServerProtocolFactory[] ServerProtocolFactories
		{
			get
			{
				if (serverProtocolFactories == null)
				{
					lock (ClassSyncObject)
					{
						if (serverProtocolFactories == null)
						{
							WebServiceProtocols webServiceProtocols = EnabledProtocols;
							List<ServerProtocolFactory> list = new List<ServerProtocolFactory>();
							if ((webServiceProtocols & WebServiceProtocols.AnyHttpSoap) != 0)
							{
								list.Add((ServerProtocolFactory)Activator.CreateInstance(SoapServerProtocolFactory));
							}
							if ((webServiceProtocols & WebServiceProtocols.HttpPost) != 0)
							{
								list.Add(new HttpPostServerProtocolFactory());
							}
							if ((webServiceProtocols & WebServiceProtocols.HttpPostLocalhost) != 0)
							{
								list.Add(new HttpPostLocalhostServerProtocolFactory());
							}
							if ((webServiceProtocols & WebServiceProtocols.HttpGet) != 0)
							{
								list.Add(new HttpGetServerProtocolFactory());
							}
							if ((webServiceProtocols & WebServiceProtocols.Documentation) != 0)
							{
								list.Add(new DiscoveryServerProtocolFactory());
								list.Add(new DocumentationServerProtocolFactory());
							}
							serverProtocolFactories = list.ToArray();
						}
					}
				}
				return serverProtocolFactories;
			}
		}

		internal bool ServiceDescriptionExtended => ServiceDescriptionFormatExtensionTypes.Count > 0;

		[ConfigurationProperty("serviceDescriptionFormatExtensionTypes")]
		public TypeElementCollection ServiceDescriptionFormatExtensionTypes => (TypeElementCollection)base[serviceDescriptionFormatExtensionTypes];

		[ConfigurationProperty("soapExtensionImporterTypes")]
		public TypeElementCollection SoapExtensionImporterTypes => (TypeElementCollection)base[soapExtensionImporterTypes];

		[ConfigurationProperty("soapExtensionReflectorTypes")]
		public TypeElementCollection SoapExtensionReflectorTypes => (TypeElementCollection)base[soapExtensionReflectorTypes];

		[ConfigurationProperty("soapExtensionTypes")]
		public SoapExtensionTypeElementCollection SoapExtensionTypes => (SoapExtensionTypeElementCollection)base[soapExtensionTypes];

		[ConfigurationProperty("soapServerProtocolFactory")]
		public TypeElement SoapServerProtocolFactoryType => (TypeElement)base[soapServerProtocolFactoryType];

		internal Type SoapServerProtocolFactory
		{
			get
			{
				if (soapServerProtocolFactory == null)
				{
					lock (ClassSyncObject)
					{
						if (soapServerProtocolFactory == null)
						{
							soapServerProtocolFactory = SoapServerProtocolFactoryType.Type;
						}
					}
				}
				return soapServerProtocolFactory;
			}
		}

		[ConfigurationProperty("soapTransportImporterTypes")]
		public TypeElementCollection SoapTransportImporterTypes => (TypeElementCollection)base[soapTransportImporterTypes];

		internal Type[] SoapTransportImporters
		{
			get
			{
				Type[] array = new Type[1 + SoapTransportImporterTypes.Count];
				array[0] = typeof(SoapHttpTransportImporter);
				for (int i = 0; i < SoapTransportImporterTypes.Count; i++)
				{
					array[i + 1] = SoapTransportImporterTypes[i].Type;
				}
				return array;
			}
		}

		[ConfigurationProperty("wsdlHelpGenerator")]
		public WsdlHelpGeneratorElement WsdlHelpGenerator => (WsdlHelpGeneratorElement)base[wsdlHelpGenerator];

		public WebServicesSection()
		{
			properties.Add(conformanceWarnings);
			properties.Add(protocols);
			properties.Add(serviceDescriptionFormatExtensionTypes);
			properties.Add(soapEnvelopeProcessing);
			properties.Add(soapExtensionImporterTypes);
			properties.Add(soapExtensionReflectorTypes);
			properties.Add(soapExtensionTypes);
			properties.Add(soapTransportImporterTypes);
			properties.Add(wsdlHelpGenerator);
			properties.Add(soapServerProtocolFactoryType);
			properties.Add(diagnostics);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[ConfigurationPermission(SecurityAction.Assert, Unrestricted = true)]
		private static WebServicesSection GetConfigFromHttpContext()
		{
			HttpContext current = HttpContext.Current;
			if (current != null)
			{
				return (WebServicesSection)current.GetSection("system.web/webServices");
			}
			return null;
		}

		internal Type[] GetAllFormatExtensionTypes()
		{
			if (ServiceDescriptionFormatExtensionTypes.Count == 0)
			{
				return defaultFormatTypes;
			}
			Type[] array = new Type[defaultFormatTypes.Length + ServiceDescriptionFormatExtensionTypes.Count];
			Array.Copy(defaultFormatTypes, array, defaultFormatTypes.Length);
			for (int i = 0; i < ServiceDescriptionFormatExtensionTypes.Count; i++)
			{
				array[i + defaultFormatTypes.Length] = ServiceDescriptionFormatExtensionTypes[i].Type;
			}
			return array;
		}

		private static XmlFormatExtensionPointAttribute GetExtensionPointAttribute(Type type)
		{
			object[] customAttributes = type.GetCustomAttributes(typeof(XmlFormatExtensionPointAttribute), inherit: false);
			if (customAttributes.Length == 0)
			{
				throw new ArgumentException(Res.GetString("TheSyntaxOfTypeMayNotBeExtended1", type.FullName), "type");
			}
			return (XmlFormatExtensionPointAttribute)customAttributes[0];
		}

		[ConfigurationPermission(SecurityAction.Assert, Unrestricted = true)]
		public static WebServicesSection GetSection(System.Configuration.Configuration config)
		{
			if (config == null)
			{
				throw new ArgumentNullException("config");
			}
			return (WebServicesSection)config.GetSection("system.web/webServices");
		}

		protected override void InitializeDefault()
		{
			ConformanceWarnings.SetDefaults();
			Protocols.SetDefaults();
			if (Thread.GetDomain().GetData(".appDomain") != null)
			{
				WsdlHelpGenerator.SetDefaults();
			}
			SoapServerProtocolFactoryType.Type = typeof(SoapServerProtocolFactory);
		}

		internal static void LoadXmlFormatExtensions(Type[] extensionTypes, XmlAttributeOverrides overrides, XmlSerializerNamespaces namespaces)
		{
			Hashtable hashtable = new Hashtable();
			hashtable.Add(typeof(ServiceDescription), new XmlAttributes());
			hashtable.Add(typeof(Import), new XmlAttributes());
			hashtable.Add(typeof(Port), new XmlAttributes());
			hashtable.Add(typeof(Service), new XmlAttributes());
			hashtable.Add(typeof(FaultBinding), new XmlAttributes());
			hashtable.Add(typeof(InputBinding), new XmlAttributes());
			hashtable.Add(typeof(OutputBinding), new XmlAttributes());
			hashtable.Add(typeof(OperationBinding), new XmlAttributes());
			hashtable.Add(typeof(Binding), new XmlAttributes());
			hashtable.Add(typeof(OperationFault), new XmlAttributes());
			hashtable.Add(typeof(OperationInput), new XmlAttributes());
			hashtable.Add(typeof(OperationOutput), new XmlAttributes());
			hashtable.Add(typeof(Operation), new XmlAttributes());
			hashtable.Add(typeof(PortType), new XmlAttributes());
			hashtable.Add(typeof(Message), new XmlAttributes());
			hashtable.Add(typeof(MessagePart), new XmlAttributes());
			hashtable.Add(typeof(Types), new XmlAttributes());
			Hashtable hashtable2 = new Hashtable();
			foreach (Type type in extensionTypes)
			{
				if (hashtable2[type] != null)
				{
					continue;
				}
				hashtable2.Add(type, type);
				object[] customAttributes = type.GetCustomAttributes(typeof(XmlFormatExtensionAttribute), inherit: false);
				if (customAttributes.Length == 0)
				{
					throw new ArgumentException(Res.GetString("RequiredXmlFormatExtensionAttributeIsMissing1", type.FullName), "extensionTypes");
				}
				XmlFormatExtensionAttribute xmlFormatExtensionAttribute = (XmlFormatExtensionAttribute)customAttributes[0];
				Type[] extensionPoints = xmlFormatExtensionAttribute.ExtensionPoints;
				foreach (Type key in extensionPoints)
				{
					XmlAttributes xmlAttributes = (XmlAttributes)hashtable[key];
					if (xmlAttributes == null)
					{
						xmlAttributes = new XmlAttributes();
						hashtable.Add(key, xmlAttributes);
					}
					XmlElementAttribute xmlElementAttribute = new XmlElementAttribute(xmlFormatExtensionAttribute.ElementName, type);
					xmlElementAttribute.Namespace = xmlFormatExtensionAttribute.Namespace;
					xmlAttributes.XmlElements.Add(xmlElementAttribute);
				}
				customAttributes = type.GetCustomAttributes(typeof(XmlFormatExtensionPrefixAttribute), inherit: false);
				string[] array = new string[customAttributes.Length];
				Hashtable hashtable3 = new Hashtable();
				for (int k = 0; k < customAttributes.Length; k++)
				{
					XmlFormatExtensionPrefixAttribute xmlFormatExtensionPrefixAttribute = (XmlFormatExtensionPrefixAttribute)customAttributes[k];
					array[k] = xmlFormatExtensionPrefixAttribute.Prefix;
					hashtable3.Add(xmlFormatExtensionPrefixAttribute.Prefix, xmlFormatExtensionPrefixAttribute.Namespace);
				}
				Array.Sort(array, InvariantComparer.Default);
				for (int l = 0; l < array.Length; l++)
				{
					namespaces.Add(array[l], (string)hashtable3[array[l]]);
				}
			}
			foreach (Type key2 in hashtable.Keys)
			{
				XmlFormatExtensionPointAttribute extensionPointAttribute = GetExtensionPointAttribute(key2);
				XmlAttributes xmlAttributes2 = (XmlAttributes)hashtable[key2];
				if (extensionPointAttribute.AllowElements)
				{
					xmlAttributes2.XmlAnyElements.Add(new XmlAnyElementAttribute());
				}
				overrides.Add(key2, extensionPointAttribute.MemberName, xmlAttributes2);
			}
		}

		protected override void Reset(ConfigurationElement parentElement)
		{
			serverProtocolFactories = null;
			enabledProtocols = WebServiceProtocols.Unknown;
			if (parentElement != null)
			{
				WebServicesSection webServicesSection = (WebServicesSection)parentElement;
				discoveryDocumentSerializer = webServicesSection.discoveryDocumentSerializer;
			}
			base.Reset(parentElement);
		}

		private void TurnOnGetAndPost()
		{
			bool flag = (EnabledProtocols & WebServiceProtocols.HttpPost) == 0;
			bool flag2 = (EnabledProtocols & WebServiceProtocols.HttpGet) == 0;
			if (flag2 || flag)
			{
				ArrayList arrayList = new ArrayList(ProtocolImporterTypes);
				ArrayList arrayList2 = new ArrayList(ProtocolReflectorTypes);
				if (flag)
				{
					arrayList.Add(typeof(HttpPostProtocolImporter));
					arrayList2.Add(typeof(HttpPostProtocolReflector));
				}
				if (flag2)
				{
					arrayList.Add(typeof(HttpGetProtocolImporter));
					arrayList2.Add(typeof(HttpGetProtocolReflector));
				}
				ProtocolImporterTypes = (Type[])arrayList.ToArray(typeof(Type));
				ProtocolReflectorTypes = (Type[])arrayList2.ToArray(typeof(Type));
				enabledProtocols |= WebServiceProtocols.HttpGet | WebServiceProtocols.HttpPost;
			}
		}
	}
	public sealed class WsdlHelpGeneratorElement : ConfigurationElement
	{
		private ConfigurationPropertyCollection properties = new ConfigurationPropertyCollection();

		private readonly ConfigurationProperty href = new ConfigurationProperty("href", typeof(string), null, ConfigurationPropertyOptions.IsRequired);

		private string virtualPath;

		private string actualPath;

		private bool needToValidateHref;

		internal string HelpGeneratorVirtualPath => virtualPath + Href;

		internal string HelpGeneratorPath => Path.Combine(actualPath, Href);

		[ConfigurationProperty("href", IsRequired = true)]
		public string Href
		{
			get
			{
				return (string)base[href];
			}
			set
			{
				if (value == null)
				{
					value = string.Empty;
				}
				if (needToValidateHref && value.Length > 0)
				{
					CheckIOReadPermission(actualPath, value);
				}
				base[href] = value;
			}
		}

		protected internal override ConfigurationPropertyCollection Properties
		{
			protected get
			{
				return properties;
			}
		}

		public WsdlHelpGeneratorElement()
		{
			properties.Add(href);
		}

		[FileIOPermission(SecurityAction.Assert, Unrestricted = true)]
		private string GetConfigurationDirectory()
		{
			return HttpRuntime.MachineConfigurationDirectory;
		}

		protected override void DeserializeElement(XmlReader reader, bool serializeCollectionKey)
		{
			base.DeserializeElement(reader, serializeCollectionKey);
			ContextInformation evaluationContext = base.EvaluationContext;
			if (!(evaluationContext.HostingContext is WebContext webContext) || Href.Length == 0)
			{
				return;
			}
			string text = webContext.Path;
			string text2 = null;
			if (text == null)
			{
				text = HostingEnvironment.ApplicationVirtualPath;
				if (text == null)
				{
					text = "";
				}
				text2 = GetConfigurationDirectory();
			}
			else
			{
				text2 = HostingEnvironment.MapPath(text);
			}
			if (!text.EndsWith("/", StringComparison.Ordinal))
			{
				text += "/";
			}
			CheckIOReadPermission(text2, Href);
			actualPath = text2;
			virtualPath = text;
			needToValidateHref = true;
		}

		protected override void Reset(ConfigurationElement parentElement)
		{
			WsdlHelpGeneratorElement wsdlHelpGeneratorElement = (WsdlHelpGeneratorElement)parentElement;
			ContextInformation evaluationContext = base.EvaluationContext;
			if (evaluationContext.HostingContext is WebContext webContext)
			{
				string text = webContext.Path;
				bool flag = text == null;
				actualPath = wsdlHelpGeneratorElement.actualPath;
				if (flag)
				{
					text = HostingEnvironment.ApplicationVirtualPath;
				}
				if (text != null && !text.EndsWith("/", StringComparison.Ordinal))
				{
					text += "/";
				}
				if (text == null && parentElement != null)
				{
					virtualPath = wsdlHelpGeneratorElement.virtualPath;
				}
				else if (text != null)
				{
					virtualPath = text;
				}
			}
			base.Reset(parentElement);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		internal void SetDefaults()
		{
			HttpContext current = HttpContext.Current;
			if (current != null)
			{
				virtualPath = HostingEnvironment.ApplicationVirtualPath;
			}
			actualPath = GetConfigurationDirectory();
			if (virtualPath != null && !virtualPath.EndsWith("/", StringComparison.Ordinal))
			{
				virtualPath += "/";
			}
			if (actualPath != null && !actualPath.EndsWith("\\", StringComparison.Ordinal))
			{
				actualPath += "\\";
			}
			Href = "DefaultWsdlHelpGenerator.aspx";
			CheckIOReadPermission(actualPath, Href);
			needToValidateHref = true;
		}

		private static void CheckIOReadPermission(string path, string file)
		{
			if (path != null)
			{
				string fullPath = Path.GetFullPath(Path.Combine(path, file));
				new FileIOPermission(FileIOPermissionAccess.Read, fullPath).Demand();
			}
		}
	}
	public sealed class ProtocolElement : ConfigurationElement
	{
		private ConfigurationPropertyCollection properties = new ConfigurationPropertyCollection();

		private readonly ConfigurationProperty name = new ConfigurationProperty("name", typeof(WebServiceProtocols), WebServiceProtocols.Unknown, ConfigurationPropertyOptions.IsKey);

		[ConfigurationProperty("name", IsKey = true, DefaultValue = WebServiceProtocols.Unknown)]
		public WebServiceProtocols Name
		{
			get
			{
				return (WebServiceProtocols)base[name];
			}
			set
			{
				if (!IsValidProtocolsValue(value))
				{
					value = WebServiceProtocols.Unknown;
				}
				base[name] = value;
			}
		}

		protected internal override ConfigurationPropertyCollection Properties
		{
			protected get
			{
				return properties;
			}
		}

		public ProtocolElement()
		{
			properties.Add(name);
		}

		public ProtocolElement(WebServiceProtocols protocol)
			: this()
		{
			Name = protocol;
		}

		private bool IsValidProtocolsValue(WebServiceProtocols value)
		{
			return Enum.IsDefined(typeof(WebServiceProtocols), value);
		}
	}
	[ConfigurationCollection(typeof(ProtocolElement))]
	public sealed class ProtocolElementCollection : ConfigurationElementCollection
	{
		public ProtocolElement this[object key]
		{
			get
			{
				if (key == null)
				{
					throw new ArgumentNullException("key");
				}
				ProtocolElement protocolElement = (ProtocolElement)BaseGet(key);
				if (protocolElement == null)
				{
					throw new KeyNotFoundException(string.Format(CultureInfo.InvariantCulture, Res.GetString("ConfigKeyNotFoundInElementCollection"), key.ToString()));
				}
				return protocolElement;
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				if (key == null)
				{
					throw new ArgumentNullException("key");
				}
				if (GetElementKey(value).Equals(key))
				{
					if (BaseGet(key) != null)
					{
						BaseRemove(key);
					}
					Add(value);
					return;
				}
				throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, Res.GetString("ConfigKeysDoNotMatch"), GetElementKey(value).ToString(), key.ToString()));
			}
		}

		public ProtocolElement this[int index]
		{
			get
			{
				return (ProtocolElement)BaseGet(index);
			}
			set
			{
				if (BaseGet(index) != null)
				{
					BaseRemoveAt(index);
				}
				BaseAdd(index, value);
			}
		}

		public void Add(ProtocolElement element)
		{
			if (element == null)
			{
				throw new ArgumentNullException("element");
			}
			BaseAdd(element);
		}

		public void Clear()
		{
			BaseClear();
		}

		public bool ContainsKey(object key)
		{
			if (key == null)
			{
				throw new ArgumentNullException("key");
			}
			return BaseGet(key) != null;
		}

		protected override ConfigurationElement CreateNewElement()
		{
			return new ProtocolElement();
		}

		public void CopyTo(ProtocolElement[] array, int index)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			((ICollection)this).CopyTo((Array)array, index);
		}

		protected override object GetElementKey(ConfigurationElement element)
		{
			if (element == null)
			{
				throw new ArgumentNullException("element");
			}
			ProtocolElement protocolElement = (ProtocolElement)element;
			return protocolElement.Name.ToString();
		}

		public int IndexOf(ProtocolElement element)
		{
			if (element == null)
			{
				throw new ArgumentNullException("element");
			}
			return BaseIndexOf(element);
		}

		public void Remove(ProtocolElement element)
		{
			if (element == null)
			{
				throw new ArgumentNullException("element");
			}
			BaseRemove(GetElementKey(element));
		}

		public void RemoveAt(object key)
		{
			if (key == null)
			{
				throw new ArgumentNullException("key");
			}
			BaseRemove(key);
		}

		public void RemoveAt(int index)
		{
			BaseRemoveAt(index);
		}

		internal void SetDefaults()
		{
			ProtocolElement element = new ProtocolElement(WebServiceProtocols.HttpSoap12);
			ProtocolElement element2 = new ProtocolElement(WebServiceProtocols.HttpSoap);
			ProtocolElement element3 = new ProtocolElement(WebServiceProtocols.HttpPostLocalhost);
			ProtocolElement element4 = new ProtocolElement(WebServiceProtocols.Documentation);
			Add(element);
			Add(element2);
			Add(element3);
			Add(element4);
		}
	}
	[Flags]
	public enum WebServiceProtocols
	{
		Unknown = 0,
		HttpSoap = 1,
		HttpGet = 2,
		HttpPost = 4,
		Documentation = 8,
		HttpPostLocalhost = 0x10,
		HttpSoap12 = 0x20,
		AnyHttpSoap = 0x21
	}
	public sealed class WsiProfilesElement : ConfigurationElement
	{
		private ConfigurationPropertyCollection properties = new ConfigurationPropertyCollection();

		private readonly ConfigurationProperty name = new ConfigurationProperty("name", typeof(WsiProfiles), WsiProfiles.None, ConfigurationPropertyOptions.IsKey);

		[ConfigurationProperty("name", IsKey = true, DefaultValue = WsiProfiles.None)]
		public WsiProfiles Name
		{
			get
			{
				return (WsiProfiles)base[name];
			}
			set
			{
				if (!IsValidWsiProfilesValue(value))
				{
					throw new ArgumentOutOfRangeException("value");
				}
				base[name] = value;
			}
		}

		protected internal override ConfigurationPropertyCollection Properties
		{
			protected get
			{
				return properties;
			}
		}

		public WsiProfilesElement()
		{
			properties.Add(name);
		}

		public WsiProfilesElement(WsiProfiles name)
			: this()
		{
			Name = name;
		}

		private bool IsValidWsiProfilesValue(WsiProfiles value)
		{
			return Enum.IsDefined(typeof(WsiProfiles), value);
		}
	}
	[ConfigurationCollection(typeof(WsiProfilesElement))]
	public sealed class WsiProfilesElementCollection : ConfigurationElementCollection
	{
		public WsiProfilesElement this[object key]
		{
			get
			{
				if (key == null)
				{
					throw new ArgumentNullException("key");
				}
				WsiProfilesElement wsiProfilesElement = (WsiProfilesElement)BaseGet(key);
				if (wsiProfilesElement == null)
				{
					throw new KeyNotFoundException(string.Format(CultureInfo.InvariantCulture, Res.GetString("ConfigKeyNotFoundInElementCollection"), key.ToString()));
				}
				return wsiProfilesElement;
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				if (key == null)
				{
					throw new ArgumentNullException("key");
				}
				if (GetElementKey(value).Equals(key))
				{
					if (BaseGet(key) != null)
					{
						BaseRemove(key);
					}
					Add(value);
					return;
				}
				throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, Res.GetString("ConfigKeysDoNotMatch"), GetElementKey(value).ToString(), key.ToString()));
			}
		}

		public WsiProfilesElement this[int index]
		{
			get
			{
				return (WsiProfilesElement)BaseGet(index);
			}
			set
			{
				if (BaseGet(index) != null)
				{
					BaseRemoveAt(index);
				}
				BaseAdd(index, value);
			}
		}

		public void Add(WsiProfilesElement element)
		{
			if (element == null)
			{
				throw new ArgumentNullException("element");
			}
			BaseAdd(element);
		}

		public void Clear()
		{
			BaseClear();
		}

		public bool ContainsKey(object key)
		{
			if (key == null)
			{
				throw new ArgumentNullException("key");
			}
			return BaseGet(key) != null;
		}

		protected override ConfigurationElement CreateNewElement()
		{
			return new WsiProfilesElement();
		}

		public void CopyTo(WsiProfilesElement[] array, int index)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			((ICollection)this).CopyTo((Array)array, index);
		}

		protected override object GetElementKey(ConfigurationElement element)
		{
			if (element == null)
			{
				throw new ArgumentNullException("element");
			}
			WsiProfilesElement wsiProfilesElement = (WsiProfilesElement)element;
			return wsiProfilesElement.Name.ToString();
		}

		public int IndexOf(WsiProfilesElement element)
		{
			if (element == null)
			{
				throw new ArgumentNullException("element");
			}
			return BaseIndexOf(element);
		}

		public void Remove(WsiProfilesElement element)
		{
			if (element == null)
			{
				throw new ArgumentNullException("element");
			}
			BaseRemove(GetElementKey(element));
		}

		public void RemoveAt(object key)
		{
			if (key == null)
			{
				throw new ArgumentNullException("key");
			}
			BaseRemove(key);
		}

		public void RemoveAt(int index)
		{
			BaseRemoveAt(index);
		}

		internal void SetDefaults()
		{
			WsiProfilesElement element = new WsiProfilesElement(WsiProfiles.BasicProfile1_1);
			Add(element);
		}
	}
	[AttributeUsage(AttributeTargets.Class)]
	public sealed class XmlFormatExtensionAttribute : Attribute
	{
		private Type[] types;

		private string name;

		private string ns;

		public Type[] ExtensionPoints
		{
			get
			{
				if (types != null)
				{
					return types;
				}
				return new Type[0];
			}
			set
			{
				types = value;
			}
		}

		public string Namespace
		{
			get
			{
				if (ns != null)
				{
					return ns;
				}
				return string.Empty;
			}
			set
			{
				ns = value;
			}
		}

		public string ElementName
		{
			get
			{
				if (name != null)
				{
					return name;
				}
				return string.Empty;
			}
			set
			{
				name = value;
			}
		}

		public XmlFormatExtensionAttribute()
		{
		}

		public XmlFormatExtensionAttribute(string elementName, string ns, Type extensionPoint1)
			: this(elementName, ns, new Type[1] { extensionPoint1 })
		{
		}

		public XmlFormatExtensionAttribute(string elementName, string ns, Type extensionPoint1, Type extensionPoint2)
			: this(elementName, ns, new Type[2] { extensionPoint1, extensionPoint2 })
		{
		}

		public XmlFormatExtensionAttribute(string elementName, string ns, Type extensionPoint1, Type extensionPoint2, Type extensionPoint3)
			: this(elementName, ns, new Type[3] { extensionPoint1, extensionPoint2, extensionPoint3 })
		{
		}

		public XmlFormatExtensionAttribute(string elementName, string ns, Type extensionPoint1, Type extensionPoint2, Type extensionPoint3, Type extensionPoint4)
			: this(elementName, ns, new Type[4] { extensionPoint1, extensionPoint2, extensionPoint3, extensionPoint4 })
		{
		}

		public XmlFormatExtensionAttribute(string elementName, string ns, Type[] extensionPoints)
		{
			name = elementName;
			this.ns = ns;
			types = extensionPoints;
		}
	}
	[AttributeUsage(AttributeTargets.Class)]
	public sealed class XmlFormatExtensionPointAttribute : Attribute
	{
		private string name;

		private bool allowElements = true;

		public string MemberName
		{
			get
			{
				if (name != null)
				{
					return name;
				}
				return string.Empty;
			}
			set
			{
				name = value;
			}
		}

		public bool AllowElements
		{
			get
			{
				return allowElements;
			}
			set
			{
				allowElements = value;
			}
		}

		public XmlFormatExtensionPointAttribute(string memberName)
		{
			name = memberName;
		}
	}
	[AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
	public sealed class XmlFormatExtensionPrefixAttribute : Attribute
	{
		private string prefix;

		private string ns;

		public string Prefix
		{
			get
			{
				if (prefix != null)
				{
					return prefix;
				}
				return string.Empty;
			}
			set
			{
				prefix = value;
			}
		}

		public string Namespace
		{
			get
			{
				if (ns != null)
				{
					return ns;
				}
				return string.Empty;
			}
			set
			{
				ns = value;
			}
		}

		public XmlFormatExtensionPrefixAttribute()
		{
		}

		public XmlFormatExtensionPrefixAttribute(string prefix, string ns)
		{
			this.prefix = prefix;
			this.ns = ns;
		}
	}
}
namespace System
{
	[Serializable]
	internal class InvariantComparer : IComparer
	{
		private CompareInfo m_compareInfo;

		internal static readonly InvariantComparer Default = new InvariantComparer();

		internal InvariantComparer()
		{
			m_compareInfo = CultureInfo.InvariantCulture.CompareInfo;
		}

		public int Compare(object a, object b)
		{
			string text = a as string;
			string text2 = b as string;
			if (text != null && text2 != null)
			{
				return m_compareInfo.Compare(text, text2);
			}
			return Comparer.Default.Compare(a, b);
		}
	}
}
namespace System.Web.Services.Protocols
{
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	public sealed class SoapServerMethod
	{
		internal LogicalMethodInfo methodInfo;

		internal XmlSerializer returnSerializer;

		internal XmlSerializer parameterSerializer;

		internal XmlSerializer inHeaderSerializer;

		internal XmlSerializer outHeaderSerializer;

		internal SoapHeaderMapping[] inHeaderMappings;

		internal SoapHeaderMapping[] outHeaderMappings;

		internal SoapReflectedExtension[] extensions;

		internal object[] extensionInitializers;

		internal string action;

		internal bool oneWay;

		internal bool rpc;

		internal SoapBindingUse use;

		internal SoapParameterStyle paramStyle;

		internal WsiProfiles wsiClaims;

		public LogicalMethodInfo MethodInfo => methodInfo;

		public XmlSerializer ReturnSerializer => returnSerializer;

		public XmlSerializer ParameterSerializer => parameterSerializer;

		public XmlSerializer InHeaderSerializer => inHeaderSerializer;

		public XmlSerializer OutHeaderSerializer => outHeaderSerializer;

		public SoapHeaderMapping[] InHeaderMappings => inHeaderMappings;

		public SoapHeaderMapping[] OutHeaderMappings => outHeaderMappings;

		public string Action => action;

		public bool OneWay => oneWay;

		public bool Rpc => rpc;

		public SoapBindingUse BindingUse => use;

		public SoapParameterStyle ParameterStyle => paramStyle;

		public WsiProfiles WsiClaims => wsiClaims;

		public SoapServerMethod()
		{
		}

		public SoapServerMethod(Type serverType, LogicalMethodInfo methodInfo)
		{
			this.methodInfo = methodInfo;
			WebServiceAttribute attribute = WebServiceReflector.GetAttribute(serverType);
			string @namespace = attribute.Namespace;
			bool serviceDefaultIsEncoded = SoapReflector.ServiceDefaultIsEncoded(serverType);
			SoapReflectionImporter soapReflectionImporter = SoapReflector.CreateSoapImporter(@namespace, serviceDefaultIsEncoded);
			XmlReflectionImporter xmlReflectionImporter = SoapReflector.CreateXmlImporter(@namespace, serviceDefaultIsEncoded);
			SoapReflector.IncludeTypes(methodInfo, soapReflectionImporter);
			WebMethodReflector.IncludeTypes(methodInfo, xmlReflectionImporter);
			SoapReflectedMethod soapMethod = SoapReflector.ReflectMethod(methodInfo, client: false, xmlReflectionImporter, soapReflectionImporter, @namespace);
			ImportReflectedMethod(soapMethod);
			ImportSerializers(soapMethod, GetServerTypeEvidence(serverType));
			ImportHeaderSerializers(soapMethod);
		}

		[SecurityPermission(SecurityAction.Assert, ControlEvidence = true)]
		private Evidence GetServerTypeEvidence(Type type)
		{
			return type.Assembly.Evidence;
		}

		private List<XmlMapping> GetXmlMappingsForMethod(SoapReflectedMethod soapMethod)
		{
			List<XmlMapping> list = new List<XmlMapping>();
			list.Add(soapMethod.requestMappings);
			if (soapMethod.responseMappings != null)
			{
				list.Add(soapMethod.responseMappings);
			}
			list.Add(soapMethod.inHeaderMappings);
			if (soapMethod.outHeaderMappings != null)
			{
				list.Add(soapMethod.outHeaderMappings);
			}
			return list;
		}

		private void ImportReflectedMethod(SoapReflectedMethod soapMethod)
		{
			action = soapMethod.action;
			extensions = soapMethod.extensions;
			extensionInitializers = SoapReflectedExtension.GetInitializers(methodInfo, soapMethod.extensions);
			oneWay = soapMethod.oneWay;
			rpc = soapMethod.rpc;
			use = soapMethod.use;
			paramStyle = soapMethod.paramStyle;
			wsiClaims = ((soapMethod.binding != null) ? soapMethod.binding.ConformsTo : WsiProfiles.None);
		}

		private void ImportHeaderSerializers(SoapReflectedMethod soapMethod)
		{
			List<SoapHeaderMapping> list = new List<SoapHeaderMapping>();
			List<SoapHeaderMapping> list2 = new List<SoapHeaderMapping>();
			for (int i = 0; i < soapMethod.headers.Length; i++)
			{
				SoapHeaderMapping soapHeaderMapping = new SoapHeaderMapping();
				SoapReflectedHeader soapReflectedHeader = soapMethod.headers[i];
				soapHeaderMapping.memberInfo = soapReflectedHeader.memberInfo;
				soapHeaderMapping.repeats = soapReflectedHeader.repeats;
				soapHeaderMapping.custom = soapReflectedHeader.custom;
				soapHeaderMapping.direction = soapReflectedHeader.direction;
				soapHeaderMapping.headerType = soapReflectedHeader.headerType;
				if (soapHeaderMapping.direction == SoapHeaderDirection.In)
				{
					list.Add(soapHeaderMapping);
					continue;
				}
				if (soapHeaderMapping.direction == SoapHeaderDirection.Out)
				{
					list2.Add(soapHeaderMapping);
					continue;
				}
				list.Add(soapHeaderMapping);
				list2.Add(soapHeaderMapping);
			}
			inHeaderMappings = list.ToArray();
			if (outHeaderSerializer != null)
			{
				outHeaderMappings = list2.ToArray();
			}
		}

		private void ImportSerializers(SoapReflectedMethod soapMethod, Evidence serverEvidence)
		{
			List<XmlMapping> xmlMappingsForMethod = GetXmlMappingsForMethod(soapMethod);
			XmlMapping[] array = xmlMappingsForMethod.ToArray();
			TraceMethod caller = (Tracing.On ? new TraceMethod(this, "ImportSerializers") : null);
			if (Tracing.On)
			{
				Tracing.Enter(Tracing.TraceId("TraceCreateSerializer"), caller, new TraceMethod(typeof(XmlSerializer), "FromMappings", array, serverEvidence));
			}
			XmlSerializer[] array2 = XmlSerializer.FromMappings(array, serverEvidence);
			if (Tracing.On)
			{
				Tracing.Exit(Tracing.TraceId("TraceCreateSerializer"), caller);
			}
			int num = 0;
			parameterSerializer = array2[num++];
			if (soapMethod.responseMappings != null)
			{
				returnSerializer = array2[num++];
			}
			inHeaderSerializer = array2[num++];
			if (soapMethod.outHeaderMappings != null)
			{
				outHeaderSerializer = array2[num++];
			}
		}
	}
}
